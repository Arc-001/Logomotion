{"messages": [{"role": "user", "content": "Animate a diagram of a venturi meter, label fluid entry and exit, indicate head, and then display and manipulate Bernoulli's equation to derive the velocity of fluid at the wider section."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass nice(Scene):\n\n    def construct(self):\n        l = Line([-5, 2, 0], [-2, 2, 0], color=YELLOW)\n        self.add(l)\n        l1 = Line([-5, 0, 0], [-2, 0, 0], color=YELLOW)\n        self.add(l1)\n        l2 = Line([-2, 2, 0], [-1, 1.5, 0], color=YELLOW)\n        self.add(l2)\n        l3 = Line([-2, 0, 0], [-1, 0.5, 0], color=YELLOW)\n        self.add(l3)\n        l4 = Line([-1, 1.5, 0], [1, 1.5, 0], color=YELLOW)\n        self.add(l4)\n        l5 = Line([-1, 0.5, 0], [1, 0.5, 0], color=YELLOW)\n        self.add(l5)\n        l6 = Line([1, 0.5, 0], [2, 0, 0], color=YELLOW)\n        self.add(l6)\n        l7 = Line([1, 1.5, 0], [2, 2, 0], color=YELLOW)\n        self.add(l7)\n        l8 = Line([2, 2, 0], [5, 2, 0], color=YELLOW)\n        self.add(l8)\n        l9 = Line([2, 0, 0], [5, 0, 0], color=YELLOW)\n        self.add(l9)\n        l10 = Line([-1, 0.5, 0], [-1, 1.5, 0], color=YELLOW)\n        self.add(l10)\n        l11 = Line([1, 0.5, 0], [1, 1.5, 0], color=YELLOW)\n        self.add(l11)\n        l12 = Line([-2.5, 0, 0], [-2.5, -1, 0], color=YELLOW)\n        self.add(l12)\n        l13 = Line([-0.5, 0.5, 0], [-0.5, -1, 0], color=YELLOW)\n        self.add(l13)\n        l14 = Line([-2.6, 0, 0], [-2.6, -1, 0], color=YELLOW)\n        self.add(l14)\n        l15 = Line([-0.4, 0.5, 0], [-0.4, -1, 0], color=YELLOW)\n        self.add(l15)\n        c1 = Arc(angle=-PI, color=YELLOW).shift(DOWN).shift(1.5 * LEFT)\n        self.add(c1)\n        c2 = Arc(radius=1.1, angle=-PI, color=YELLOW).shift(DOWN).shift(1.5 * LEFT)\n        self.add(c2)\n        l16 = Line([-2, 2, 0], [-2, 0, 0], color=YELLOW)\n        self.add(l16)\n        l17 = Line([2, 2, 0], [2, 0, 0], color=YELLOW)\n        self.add(l17)\n        vm = VGroup(l, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, c1, c2)\n        self.add(vm.shift(UL))\n        animations = [FadeInFromDown(vm)]\n        self.play(AnimationGroup(*animations, lag_ratio=0.5))\n        self.wait(2)\n        a1 = Arrow(start=LEFT, end=RIGHT, color=BLUE).shift(6.5 * LEFT).shift(2 * UP)\n        anime = [FadeInFromPoint(a1, [-6.5, 2, 0])]\n        self.play(AnimationGroup(*anime, lag_ratio=0.4))\n        arrowwriting1 = TextMobject('Fluid Entry', color=BLUE, slant=ITALIC).shift(6 * LEFT).shift(1.5 * UP).scale(0.5)\n        self.play(Write(arrowwriting1))\n        self.wait()\n        a2 = Arrow(start=LEFT, end=RIGHT, color=BLUE).shift(3.5 * RIGHT).shift(2 * UP)\n        anime2 = [FadeInFromPoint(a2, [3.5, 2, 0])]\n        self.play(AnimationGroup(*anime2, lag_ratio=0.4))\n        arrowwriting2 = TextMobject('Fluid Exit', color=BLUE, slant=ITALIC).shift(3.5 * RIGHT).shift(1.5 * UP).scale(0.5)\n        self.play(Write(arrowwriting2))\n        self.wait(3)\n        dl = DashedLine([-3.8, 0, 0], [-0.5, 0, 0])\n        self.add(dl)\n        dl2 = DashedLine([-1.7, 0.5, 0], [-0.5, 0.5, 0])\n        self.add(dl2)\n        self.wait(3)\n        distance = Line([-0.5, 0, 0], [-0.5, 0.5, 0])\n        b = Brace(distance, buff=0.1)\n        t = b.get_text('Head').next_to(b).scale(0.7)\n        self.add(b)\n        self.play(Write(t))\n        self.wait(3)\n        venturimeter = Group(vm, a1, a2, dl, dl2, b, t, arrowwriting1, arrowwriting2)\n        anim = [FadeToColor(venturimeter.set_color(), PINK)]\n        self.play(AnimationGroup(*anim, lag_ratio=0.5))\n        self.wait(3)\n        self.add(venturimeter.shift(LEFT).scale(0.7))\n        self.wait(3)\n        writing = TextMobject(\"Applying Bernoulli's Equation,\").shift(3 * RIGHT).scale(0.8)\n        self.play(Write(writing))\n        writings = TexMobject('\\\\frac {P_1}{\\\\rho g} +\\\\frac{v_1^2}{2g}+z_1 =\\\\frac{P_2}{\\\\rho g} +\\\\frac{v_2^2}{2g}+ z_2 ').shift(2 * RIGHT).shift(DOWN).scale(0.8)\n        self.play(Write(writings))\n        self.wait(3)\n        h = TexMobject('Here, z_1 =z_2 ').shift(3 * RIGHT).shift(2 * DOWN).scale(0.8)\n        self.play(Write(h))\n        i = TexMobject('So,     \\\\frac {P_1}{\\\\rho g} +\\\\frac{v_1^2}{2g}=\\\\frac{P_2}{\\\\rho g} +\\\\frac{v_2^2}{2g}').shift(2 * RIGHT).shift(3 * DOWN).scale(0.8)\n        self.play(Write(i))\n        self.wait(2)\n        self.play(FadeOut(writing))\n        self.play(FadeOut(writings))\n        self.play(FadeOut(h))\n        self.add(i.shift(3 * UP))\n        self.wait(3)\n        a = TexMobject('\\\\frac{P_1-P_2}{\\\\rho g} =\\\\frac{v_2^2 - v_1^2}{2g}=h(say)').shift(2 * RIGHT).shift(1.5 * DOWN).scale(0.7)\n        self.play(Write(a))\n        self.wait(3)\n        b = TexMobject('P_1-P_2=\\\\delta P=\\\\rho gh').shift(2 * RIGHT).shift(2.5 * DOWN).scale(0.7)\n        self.play(Write(b))\n        c = TexMobject('v_1=\\\\frac{A_2 v_2}{A_1} (from\\\\ continuity\\\\ equation)').shift(2 * RIGHT).shift(3.5 * DOWN).scale(0.7)\n        self.play(Write(c))\n        self.wait(3)\n        self.play(FadeOut(i))\n        self.play(FadeOut(a))\n        self.play(FadeOut(b))\n        self.play(FadeOut(c))\n        d = TexMobject('Substituiting, \\\\frac{v_2^2-(\\\\frac{A_2 v_2}{A_1})^2}{2g}=h').shift(3 * RIGHT)\n        self.play(Write(d))\n        self.wait(3)\n        e = TexMobject('\\\\frac{A_1 v_2^2 - A_2 v_1^2}{2g A_1^2}=h').shift(2 * RIGHT).shift(DOWN)\n        self.play(Write(e))\n        self.wait()\n        f = TexMobject('v_2^2=2gh \\\\times \\\\frac{A_1^2}{A_1^2-A_2^2}').shift(2 * RIGHT).shift(2 * DOWN)\n        self.play(Transform(e, f))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Animate the behavior of an electron between two charged plates, showing potential and kinetic energy."}, {"role": "assistant", "content": "from manim import *\n\nclass Eq(Scene):\n\n    def construct(self):\n        title = Tex('An $e^-$ inside potential').to_corner(UP + LEFT)\n        axes = Axes(x_range=[-10, 10, 4], y_range=[-1.5, 1.5, 4], x_length=6, y_length=3, axis_config={'color': WHITE, 'font_size': 5}).shift(2.3 * DOWN)\n        x_label = axes.get_x_axis_label(MathTex('x', font_size=30))\n        y_label = axes.get_y_axis_label(MathTex('V(x)', font_size=30))\n        axes_g = VGroup(axes, x_label, y_label)\n        plate_l = Rectangle(color=BLUE, height=6, width=2, fill_opacity=1).shift(4 * LEFT)\n        plate_r = Rectangle(color=RED, height=6, width=2, fill_opacity=1).shift(4 * RIGHT)\n        pos_sign = MathTex('+', font_size=70).move_to(plate_r.get_center())\n        neg_sign = MathTex('-', font_size=70).move_to(plate_l.get_center())\n\n        def func(x):\n            return np.array([-1.0, 0.0, 0.0])\n        x_range = [plate_l.get_right()[0], plate_r.get_left()[0], 1.0]\n        y_range = [plate_l.get_bottom()[1], plate_l.get_top()[1], 1.0]\n        vector_field = ArrowVectorField(func, x_range=x_range, y_range=y_range, length_func=lambda x: x / 2, opacity=0.5)\n        el = Dot().move_to([0, plate_l.get_center()[1], 0])\n        plates = VGroup(plate_l, plate_r, pos_sign, neg_sign)\n        set_up = VGroup(plates, el, vector_field)\n        ' start of show '\n        self.play(Create(title))\n        self.play(FadeIn(plates))\n        self.play(Create(vector_field))\n        self.play(Create(el))\n        self.wait()\n        self.play(set_up.animate.scale(0.5).shift(1.2 * UP))\n        disc_l = axes.point_to_coords(plate_l.get_right())[0]\n        disc_r = axes.point_to_coords(plate_r.get_left())[0]\n        eps = 1e-08\n        plot = axes.plot_line_graph([-8, disc_l, disc_l + eps, disc_r, disc_r + eps, disc_r + 3], [-1, -1, 0, 0, 1, 1], add_vertex_dots=False)\n        plot2 = axes.plot_line_graph([-8, disc_r + 3], [-0.8, -0.8], add_vertex_dots=False)\n        plot_E = axes.plot_line_graph([-8, 8], [0.5, 0.5], add_vertex_dots=False, line_color=BLUE)\n        self.wait()\n        self.play(Create(axes_g))\n        self.play(FadeIn(plot))\n        self.wait()\n        force_arrow = Arrow([-0.5, 1, 0], [+0.5, 1, 0])\n        force_label = MathTex('F_e', font_size=20).next_to(force_arrow)\n        self.play(Create(force_arrow), Create(force_label))\n        self.wait()\n        el_origin = el.get_center()\n        self.play(el.animate(rate_func=rate_functions.ease_in_quad).move_to(plate_r.get_left()))\n        self.play(FadeOut(force_arrow), FadeOut(force_label))\n        self.wait()\n        self.play(plate_r.animate.set_color(BLUE), Transform(pos_sign, neg_sign.copy().move_to(plate_r.get_center())), Transform(plot, plot2), FadeOut(vector_field))\n        force_arrow.next_to(el, LEFT).flip().shift(DOWN * 0.1)\n        force_label.next_to(force_arrow, DOWN)\n        self.play(FadeIn(VGroup(force_arrow, force_label)))\n        self.wait()\n        self.play(el.animate(rate_func=rate_functions.ease_in_quad).move_to(el_origin))\n        self.play(FadeOut(VGroup(force_arrow, force_label)))\n        self.wait()\n        self.play(Transform(title, Tex('$e^-$ can reach the plates with enough energy').to_corner(UL)))\n        energy_eq = MathTex('E = K + V').to_edge()\n        self.play(Create(plot_E))\n        self.play(Write(energy_eq))\n        self.wait()\n        self.play(Transform(energy_eq, MathTex('K = E - V').to_edge()))\n        self.wait()\n        self.play(Transform(energy_eq, MathTex('K > V').to_edge()))\n        self.play(Indicate(plot2))\n        self.play(Indicate(plot_E, WHITE))"}]}
{"messages": [{"role": "user", "content": "Render a 3D scene with axes, rotating the camera around it."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene3D(ThreeDScene):\n\n    def construct(self):\n        ax = ThreeDAxes()\n        self.add(ax)\n        self.set_camera_orientation(phi=2 * PI / 5, theta=PI / 5)\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait()\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Introduce the concept of diagonalization by writing text about transformation matrices and then displaying a 2x2 matrix representing M."}, {"role": "assistant", "content": "from manim import *\n\nclass Mine(Scene):\n\n    def construct(self):\n        title = Tex(\"Let's learn diagonalization\")\n        we_know = Tex('we know that a \\\\textit{tronsformation matrix equation} \\\\\\\\ is written like')\n        matrix_eq = Tex('R=Mr')\n        VGroup(title, we_know, matrix_eq).arrange(DOWN)\n        group1 = [we_know, matrix_eq]\n        self.play(Write(title))\n        self.wait()\n        self.play(FadeIn(we_know), FadeIn(matrix_eq))\n        self.wait()\n        first_t = Tex('First')\n        first_t.to_corner(UP + LEFT)\n        self.play(Transform(title, first_t), LaggedStart(*[FadeOut(obj, direction=DOWN) for obj in group1]))\n        self.wait()\n        matrix_M = Matrix([['a', 'b'], ['c', 'd']]).set_color(YELLOW)\n        consider_t = Tex('Let $M$ be a transformation matrix')\n        t1 = Tex('M = ')\n        group2 = VGroup(t1, matrix_M).arrange(RIGHT)\n        VGroup(consider_t, group2).arrange(DOWN)\n        self.play(Write(consider_t))\n        self.play(Create(matrix_M), Create(t1))\n        self.wait()\n        objs = [group2, consider_t]\n        thus_t = Tex('Thus we have')\n        thus_t.to_corner(LEFT + UP)\n        self.play(FadeOut(title))\n        self.play(*[FadeOut(obj) for obj in objs])\n        self.play(Write(thus_t))\n        self.wait()\n        right_arrow = MathTex('\\\\Rightarrow')\n        matrix_r = MathTex('\\\\begin{bmatrix} x \\\\\\\\ y \\\\end{bmatrix}')\n        matrix_R = Matrix([['X'], ['Y']])\n        equal_sign = MathTex('=')\n        matrix_eq_group = VGroup(matrix_eq, right_arrow, matrix_R, equal_sign, matrix_M, matrix_r).arrange(RIGHT)\n        self.play(Create(matrix_eq_group))\n        self.wait()\n        self.play(FadeOut(matrix_eq_group))\n        lambda_condition_1 = MathTex('R', '=', '\\\\lambda')\n        lambda_condition_1.align_to(matrix_r, LEFT)\n        lambda_condition = VGroup(lambda_condition_1, matrix_r).arrange().shift(3 * RIGHT)\n        lambda_condition_t = Tex('The eigenvalue condition is')\n        finally_t = Tex('Finally')\n        finally_t.to_corner(LEFT + UP)\n        lambda_condition_eq = VGroup(MathTex('Mr = \\\\lambda r'), right_arrow, matrix_M, matrix_r.copy(), equal_sign, MathTex('\\\\lambda'), matrix_r).arrange(RIGHT)\n        self.play(Write(lambda_condition_t))\n        self.wait()\n        self.play(FadeOut(lambda_condition_t))\n        self.play(Create(lambda_condition))\n        self.wait()\n        self.play(FadeOut(lambda_condition))\n        self.play(FadeOut(thus_t))\n        self.play(Write(finally_t))\n        self.play(Create(lambda_condition_eq))\n\n        def fadeInAndOut(self, obj, time=2):\n            self.play(FadeIn(obj))\n            self.wait(time)\n            self.play(FadeOut(obj))"}]}
{"messages": [{"role": "user", "content": "Illustrate the process of solving the time-dependent Schr\u00f6dinger equation by displaying steps, the equation, its separation into spatial and temporal parts, and the final solution."}, {"role": "assistant", "content": "from manim import *\n\nclass TISE(Scene):\n\n    def fade_in_out(self, obj, delay=1):\n        self.play(FadeIn(obj))\n        self.wait(delay)\n        self.play(FadeOut(obj))\n\n    def construct(self):\n        title = Title('Solving Time-Dependent Schr\u00f6dinger Equation')\n        self.play(Write(title))\n        self.wait()\n        steps = VGroup(Text(\"1. Solve Shc\u00f6dinger's PDE\"), Text('2. Using Hamiltonian operator'), Text('3. Find the general solution'), Text('4. Some intresting properties.')).arrange(DOWN, aligned_edge=LEFT, buff=0.5).scale(0.7).shift(0.2 * UP)\n        for obj in steps:\n            self.play(Write(obj))\n            self.wait()\n        self.play(FadeOut(steps))\n        self.wait()\n        tdse = MathTex('i\\\\hbar', '\\\\frac{\\\\partial\\\\Psi}{\\\\partial t}', '= - \\\\frac{\\\\hbar^2}{2m}', '\\\\frac{\\\\partial^2 \\\\Psi}{\\\\partial x^2}', '+U\\\\Psi').scale(1.5).shift(RIGHT)\n        func = VGroup(MathTex('\\\\Psi = \\\\Psi(x, t)'), MathTex('U = U(x)'), MathTex('\\\\Psi(x, t) = \\\\psi(x) \\\\phi(t)'), MathTex('\\\\frac{\\\\partial\\\\Psi}{\\\\partial t} = \\\\psi(x)\\\\frac{d \\\\phi(t)}{d t}'), MathTex('\\\\frac{\\\\partial^2 \\\\Psi}{\\\\partial x^2} = \\\\phi(t) \\\\frac{d^2 \\\\psi(x)}{d x^2}')).arrange(DOWN, aligned_edge=LEFT).scale(0.7).to_edge(LEFT).shift(UP)\n        self.play(Write(tdse))\n        self.play(Write(func[0]))\n        self.play(tdse.animate.shift(1.8 * UP).scale(0.5))\n        self.fade_in_out(Text('Separation of Variables').shift(2 * DOWN))\n        self.play(Write(func[1]))\n        self.play(Write(func[2]))\n        self.play(Circumscribe(tdse[1]), Circumscribe(tdse[3]))\n        self.wait()\n        self.play(Write(func[3]))\n        self.play(Write(func[4]))\n        tise = MathTex('i \\\\hbar \\\\psi\\\\frac{d \\\\phi}{d t}', '=', '- \\\\frac{\\\\hbar^2}{2m} \\\\frac{d^2 \\\\psi}{d x^2} \\\\phi +U \\\\psi \\\\phi').scale(0.75).next_to(tdse, DOWN, buff=1)\n        tise_1 = MathTex('i \\\\hbar \\\\frac{1}{\\\\phi} \\\\frac{d \\\\phi}{d t}', '=', '- \\\\frac{\\\\hbar^2}{2m} \\\\frac{1}{\\\\psi} \\\\frac{d^2 \\\\psi}{d x^2} +U').scale(0.75).next_to(tdse, DOWN, buff=1)\n        self.play(Write(tise))\n        self.wait()\n        self.play(Transform(tise, tise_1))\n        self.wait()\n        frame_t = SurroundingRectangle(tise_1[0])\n        frame_x = SurroundingRectangle(tise_1[2])\n        equal_E = MathTex('=E').scale(0.75).next_to(tise_1)\n        self.play(Create(frame_t))\n        self.play(ReplacementTransform(frame_t, frame_x))\n        self.wait()\n        self.play(FadeOut(frame_x))\n        self.wait()\n        self.play(Create(equal_E))\n        self.wait()\n        Psi = MathTex('\\\\Psi(x, t) = \\\\psi(x)\\\\, \\\\phi(t)').to_edge(UP, 2)\n        Psi_t = MathTex('\\\\Psi(x, t) = \\\\psi(x)\\\\, e^{\\\\frac{E}{i \\\\hbar }t} {{\\\\cdot}} {{e^C}}').move_to(Psi)\n        time_dep = VGroup(MathTex('i \\\\hbar \\\\frac{1}{\\\\phi} \\\\frac{d \\\\phi}{d t} = E'), MathTex(' \\\\frac{1}{\\\\phi} \\\\frac{d \\\\phi}{d t} = \\\\frac{E}{i \\\\hbar }'), MathTex('\\\\frac{d \\\\phi}{\\\\phi} = \\\\frac{E}{i \\\\hbar }\\\\, dt'), MathTex('\\\\int \\\\frac{d \\\\phi}{\\\\phi} = \\\\int \\\\frac{E}{i \\\\hbar }\\\\, dt'), MathTex('{\\\\ln(\\\\phi)} = \\\\frac{E}{i \\\\hbar }t + C'), MathTex('e^{\\\\ln(\\\\phi)} = e^{\\\\frac{E}{i \\\\hbar }t + C}'), MathTex('\\\\phi(t) = e^{\\\\frac{E}{i \\\\hbar }t} \\\\cdot {{e^C}}')).scale(1.5)\n        time_dep[0].scale(1 / 1.5)\n        time_dep_sol = MathTex('\\\\phi(t) = e^{\\\\frac{E}{i \\\\hbar }t}').scale(2).shift(0.5 * DOWN)\n        time_ind = VGroup(MathTex('- \\\\frac{\\\\hbar^2}{2m} \\\\frac{1}{\\\\psi} \\\\frac{d^2 \\\\psi}{d x^2} + U = E'), MathTex('- \\\\frac{\\\\hbar^2}{2m} \\\\frac{d^2 \\\\psi}{d x^2} + U\\\\psi = E \\\\psi')).to_edge(RIGHT, buff=1)\n        self.play(*[FadeOut(obj) for obj in [tdse, func, equal_E]])\n        time_dep[0].to_edge(LEFT, 1.5)\n        self.play(ReplacementTransform(tise.copy(), time_dep[0]), ReplacementTransform(tise, time_ind[0]))\n        self.wait()\n        self.play(ReplacementTransform(time_ind[0], time_ind[1]))\n        self.play(FadeOut(time_ind))\n        self.play(ReplacementTransform(time_dep[0], time_dep[1]))\n        self.fade_in_out(Text('Separable DE', 2).to_edge(UP, 1.5))\n        for i in range(1, 6):\n            self.play(ReplacementTransform(time_dep[i], time_dep[i + 1]))\n            self.wait(0.5)\n        self.play(Circumscribe(time_dep[6][-1]))\n        self.play(Write(Psi))\n        self.play(ReplacementTransform(Psi, Psi_t), FadeOut(time_dep[6]))\n        self.play(Psi_t.animate.move_to(ORIGIN).scale(2))"}]}
{"messages": [{"role": "user", "content": "Render a world map and a number plane with a dark background."}, {"role": "assistant", "content": "from typing import Tuple\nfrom manim import VGroup, Scene, config, FadeIn, AnimationGroup, Transform, ReplacementTransform, Rectangle, Create, UP, Text, DOWN, FadeOut, LEFT, RIGHT\nfrom shapely.geometry import MultiLineString, LineString\nfrom util.lego_projection_transformer_builder import LegoProjectionTransformerBuilder\nfrom util.number_plane_helper import generate_transformable_number_plane\nfrom util.shapely_helper import load_world_map, split_world_map_at_longitude\nfrom util.shapely_manim_helper import shapely_multi_polygon_to_manim, shapely_multi_line_string_to_manim\n\nclass RenderFirstFrame(Scene):\n\n    def construct(self):\n        self.camera.background_color = '#212121'\n        land_group = shapely_multi_polygon_to_manim(load_world_map(), '#FFFFFF', transform_wgs84_to_void)\n        axis_group = generate_transformable_number_plane(-180, 180, 5, -90, 90, 5, transform_wgs84_to_void)\n        self.add(VGroup(land_group, axis_group))"}]}
{"messages": [{"role": "user", "content": "Animate the transformation of a world map from a standard WGS84 projection to a distorted LEGO projection, showing steps including stretching, latitude distortion, and splitting the map."}, {"role": "assistant", "content": "from typing import Tuple\nfrom manim import VGroup, Scene, config, FadeIn, AnimationGroup, Transform, ReplacementTransform, Rectangle, Create, UP, Text, DOWN, FadeOut, LEFT, RIGHT\nfrom shapely.geometry import MultiLineString, LineString\nfrom util.lego_projection_transformer_builder import LegoProjectionTransformerBuilder\nfrom util.number_plane_helper import generate_transformable_number_plane\nfrom util.shapely_helper import load_world_map, split_world_map_at_longitude\nfrom util.shapely_manim_helper import shapely_multi_polygon_to_manim, shapely_multi_line_string_to_manim\n\nclass Render(Scene):\n\n    def construct(self):\n        self.camera.background_color = '#212121'\n        land_shapes = load_world_map()\n        builder = LegoProjectionTransformerBuilder(canvas_width=content_width, canvas_height=content_height)\n        transform_wgs84_to_lego = builder.build_wgs84_to_lego()\n        wgs84_rect = Rectangle(width=content_width, height=180 * content_width / 360, background_stroke_width=50, stroke_width=20, stroke_opacity=1)\n        content_rect = Rectangle(width=content_width, height=content_height, background_stroke_width=50, stroke_width=20, stroke_opacity=1)\n        wgs84_rect.shift(content_offset)\n        content_rect.shift(content_offset)\n        land_group = shapely_multi_polygon_to_manim(land_shapes, '#FFFFFF', transform_wgs84_to_void)\n        axis_group = generate_transformable_number_plane(-180, 180, 5, -90, 90, 5, transform_wgs84_to_void)\n        land_group.shift(content_offset)\n        axis_group.shift(content_offset)\n        self.add(VGroup(land_group, axis_group))\n        step_1_text = Text('Step 1: World map in standard WGS84 projection.', font='sans-serif').scale(8).next_to(content_rect, DOWN)\n        step_1_text.shift(frame_padding / 2 * DOWN)\n        self.play(FadeIn(step_1_text))\n        self.play(Create(wgs84_rect))\n        self.wait()\n        self.play(AnimationGroup(FadeOut(wgs84_rect), FadeOut(step_1_text)))\n        step_2_text = Text('Step 2: Stretch the map to the size-ratio of the LEGO world map.', font='sans-serif').scale(8).next_to(content_rect, DOWN)\n        step_2_text.shift(frame_padding / 2 * DOWN)\n        self.play(AnimationGroup(FadeIn(step_2_text)))\n        self.play(Create(content_rect))\n        land_group_stretched = shapely_multi_polygon_to_manim(land_shapes, '#FFFFFF', transform_wgs84_to_fit_content)\n        axis_group_stretched = generate_transformable_number_plane(-180, 180, 5, -90, 90, 5, transform_wgs84_to_fit_content)\n        land_group_stretched.shift(content_offset)\n        axis_group_stretched.shift(content_offset)\n        self.play(Transform(VGroup(land_group, axis_group), VGroup(land_group_stretched, axis_group_stretched)))\n        self.wait()\n        self.play(FadeOut(step_2_text))\n        step_3_text = Text('Step 3: Distort the latitudes individually.', font='sans-serif').scale(8).next_to(content_rect, DOWN)\n        step_3_text.shift(frame_padding / 2 * DOWN)\n        latitude_lines = shapely_multi_line_string_to_manim(builder.get_latitude_bands_as_multi_line_string(), '#FF0000', transform_wgs84_to_fit_content)\n        canvas_lines = shapely_multi_line_string_to_manim(builder.get_canvas_bands_as_multi_line_string(), '#FF0000', lambda x: (x[0], content_height / 2 - x[1], 0))\n        latitude_lines.shift(content_offset)\n        canvas_lines.shift(content_offset)\n        self.play(AnimationGroup(FadeIn(step_3_text), Create(latitude_lines)))\n        self.wait()\n        land_group_lego = shapely_multi_polygon_to_manim(land_shapes, '#FFFFFF', transform_wgs84_to_lego)\n        axis_group_lego = generate_transformable_number_plane(-180, 180, 5, -90, 90, 5, transform_wgs84_to_lego)\n        land_group_lego.shift(content_offset)\n        axis_group_lego.shift(content_offset)\n        self.play(ReplacementTransform(VGroup(land_group, axis_group, latitude_lines), VGroup(land_group_lego, axis_group_lego, canvas_lines)))\n        self.wait()\n        self.play(AnimationGroup(FadeOut(step_3_text), FadeOut(canvas_lines)))\n        longitude_lines = shapely_multi_line_string_to_manim(MultiLineString([LineString([(0, 90), (0, -90)])]), '#FF0000', transform_wgs84_to_fit_content)\n        longitude_lines.shift(content_offset)\n        longitude_lines.z_index = 1\n        step_4_text = Text('Step 4: Shift the world map to the left.', font='sans-serif').scale(8).next_to(content_rect, DOWN)\n        step_4_text.shift(frame_padding / 2 * DOWN)\n        self.play(AnimationGroup(FadeIn(step_4_text), Create(longitude_lines)))\n        land_group_lego_left = land_group_lego.copy()\n        land_group_lego_right = land_group_lego.copy()\n        axis_group_lego_left = axis_group_lego.copy()\n        axis_group_lego_right = axis_group_lego.copy()\n        land_group_lego_left.shift(content_width * LEFT)\n        land_group_lego_right.shift(content_width * RIGHT)\n        axis_group_lego_left.shift(content_width * LEFT)\n        axis_group_lego_right.shift(content_width * RIGHT)\n        self.play(FadeIn(VGroup(land_group_lego_left, land_group_lego_right, axis_group_lego_left, axis_group_lego_right)))\n        self.play(VGroup(land_group_lego, land_group_lego_left, land_group_lego_right, axis_group_lego, axis_group_lego_left, axis_group_lego_right).animate.shift(4 * LEFT))\n        land_shapes_left, land_shapes_right = split_world_map_at_longitude(land_shapes, -180 + 4 * 360 / content_width)\n        land_group_left = shapely_multi_polygon_to_manim(land_shapes_left, '#FFFFFF', transform_wgs84_to_lego)\n        land_group_right = shapely_multi_polygon_to_manim(land_shapes_right, '#FFFFFF', transform_wgs84_to_lego)\n        land_group_left.shift(content_offset)\n        land_group_right.shift(content_offset)\n        land_group_left.shift((content_width - 4) * RIGHT)\n        land_group_right.shift(4 * LEFT)\n        self.play(AnimationGroup(FadeIn(land_group_left), FadeIn(land_group_right)))\n        self.play(AnimationGroup(FadeOut(land_group_lego), FadeOut(land_group_lego_left), FadeOut(land_group_lego_right), FadeOut(axis_group_lego), FadeOut(axis_group_lego_left), FadeOut(axis_group_lego_right), FadeOut(step_4_text), FadeOut(longitude_lines)))\n        self.wait()\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a heart shape growing from the center, then display accompanying text on either side."}, {"role": "assistant", "content": "from manim import *\n\nclass CreateCircle(Scene):\n\n    def construct(self):\n        circle_left = Circle(radius=1.5, color=RED).shift(LEFT)\n        circle_right = Circle(radius=1.5, color=RED).shift(RIGHT)\n        circle_left.set_fill(RED, opacity=1)\n        circle_right.set_fill(RED, opacity=1)\n        triangle = Polygon([-2, -1, 0], [2, -1, 0], [0, -3, 0], color=RED).set_fill(RED, opacity=1)\n        heart = VGroup(circle_left, circle_right, triangle)\n        heart.move_to(ORIGIN)\n        heart.scale(0.1)\n        self.play(GrowFromCenter(heart))\n        self.wait(1)\n        text_left = Text('Made with').next_to(heart, LEFT)\n        text_right = Text('using Manim').next_to(heart, RIGHT)\n        self.play(Write(text_left), Write(text_right))"}]}
{"messages": [{"role": "user", "content": "Animate the steps of Cannon's algorithm by performing and visualizing circular shifts on matrices and then distributing them in parallel."}, {"role": "assistant", "content": "from manim import *\nimport copy\n\nclass CannonScene(Scene):\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.A = self.createSquareMatrix(3, 'A', BLUE, 0.8, 0.5)\n        self.B = self.createSquareMatrix(3, 'B', GREEN, 0.8, 0.5)\n        self.P = self.createSquareMatrix(3, 'P', RED, 0.8, 0.2)\n        self.C = self.createSquareMatrix(3, 'C', ORANGE, 0.8, 0.5).scale(0.6)\n        self.title = Text(\"Cannon's Algorithm\", color=WHITE).to_edge(UP + LEFT).scale(0.8)\n        self.A_0 = None\n        self.B_0 = None\n        self.A_1 = None\n        self.B_1 = None\n        self.A_2 = None\n        self.B_2 = None\n\n    def construct(self):\n        self.play(Write(self.title))\n        self.animateInitial()\n        self.P.scale(1.2)\n        self.animateStep0()\n        self.animateStep1()\n        self.animateStep2()\n        self.play(FadeOut(self.title))\n        self.animateEnd()\n        self.wait(2)\n\n    def createSquareMatrix(self, size, label, color, scale, opacity):\n        matrix = VGroup()\n        for x in range(size):\n            row = VGroup()\n            for y in range(size):\n                cell = Square(side_length=1 * scale, fill_color=color, fill_opacity=opacity, stroke_width=1 * scale)\n                cell_label = MathTex(label + '_{' + str(x) + str(y) + '}', color=WHITE).scale(cell.get_height())\n                cell.add(cell_label)\n                row.add(cell)\n            matrix.add(row.arrange(RIGHT, buff=0.1 * scale))\n        matrix.arrange(DOWN, buff=0.1 * scale)\n        return matrix\n\n    def animateInitial(self):\n        A = self.A\n        B = self.B\n        P = self.P\n        A.move_to(LEFT * 4)\n        B.move_to(ORIGIN)\n        P.move_to(RIGHT * 4)\n        A_text = Text('A (3x3)', color=WHITE).next_to(A, UP).scale(0.5)\n        B_text = Text('B (3x3)', color=WHITE).next_to(B, UP).scale(0.5)\n        P_text = Text('P (3x3)', color=WHITE).next_to(P, UP).scale(0.5)\n        steps_text = MathTex('\\\\text{Algorithm works in } \\\\sqrt{P} \\\\text{ steps} = \\\\sqrt{9} = 3 \\\\text{ steps}', color=WHITE).next_to(B, DOWN, buff=1).scale(0.8)\n        self.play(Create(A), Create(B), Create(P))\n        self.play(Write(A_text), Write(B_text), Write(P_text))\n        self.play(Write(steps_text))\n        self.wait(2)\n        self.play(FadeOut(A, B, P))\n        self.play(FadeOut(A_text, B_text, P_text, steps_text))\n        self.wait(1)\n        pass\n\n    def animateStep0(self):\n        A = self.A\n        B = self.B\n        P = self.P\n        arrows = VGroup()\n        texts = VGroup()\n        step_0 = Text(\"Step 0: Circular shift i-th row of matrix A's blocks i positions to the left\", color=WHITE).scale(0.6)\n        step_0.next_to(self.title, DOWN, buff=0.5).align_to(self.title, LEFT)\n        self.play(Write(step_0))\n        self.play(Create(A))\n        self.wait(1)\n        for i in range(3):\n            arrow = Arrow(A[i].get_center() + RIGHT * 2, A[i].get_center() + RIGHT * 1.5, buff=0)\n            arrows.add(arrow)\n            text = Text(f'Shift by {i}').scale(0.3)\n            texts.add(text)\n            text.next_to(arrow, RIGHT, buff=0.5)\n            self.play(Create(arrow), Write(text))\n            self.wait(1)\n        self.A_0 = self.circularShiftLeft(A)\n        self.play(FadeOut(A), FadeOut(arrows), FadeOut(texts), FadeOut(step_0))\n        arrows = VGroup()\n        texts = VGroup()\n        step_0 = Text(\"Step 0: Circular shift j-th column of matrix B's blocks j positions up\", color=WHITE).scale(0.6)\n        step_0.next_to(self.title, DOWN, buff=0.5).align_to(self.title, LEFT)\n        B.move_to(LEFT * 4)\n        self.play(Write(step_0))\n        self.play(Create(B))\n        self.wait(1)\n        for i in range(3):\n            arrow = Arrow(B[1][i].get_center() + DOWN * 2, B[1][i].get_center() + DOWN * 1.5, buff=0)\n            arrows.add(arrow)\n            text = Text(f'Shift by {i}').scale(0.3)\n            texts.add(text)\n            text.next_to(arrow, DOWN, buff=0.5)\n            self.play(Create(arrow), Write(text))\n            self.wait(1)\n        self.B_0 = self.circularShiftUp(B)\n        self.play(FadeOut(B), FadeOut(arrows), FadeOut(texts), FadeOut(step_0))\n        self.wait(1)\n        A_0_copy = copy.deepcopy(self.A_0)\n        B_0_copy = copy.deepcopy(self.B_0)\n        A_0_copy.move_to(LEFT * 4).scale(0.6)\n        B_0_copy.move_to(RIGHT * 4).scale(0.6)\n        P.move_to(ORIGIN)\n        self.play(Create(A_0_copy), Create(B_0_copy), Create(P))\n        self.wait(1)\n        self.parallelDistributeMatrix(A_0_copy, B_0_copy, P)\n        self.play(FadeOut(P))\n        self.wait(1)\n        pass\n\n    def animateStep1(self):\n        A = self.A_0\n        B = self.B_0\n        P = self.P\n        arrows = VGroup()\n        texts = VGroup()\n        step_1 = Text(\"Step 1: Circular shift each row of matrix A's blocks 1 position to the left\", color=WHITE).scale(0.6)\n        step_1.next_to(self.title, DOWN, buff=0.5).align_to(self.title, LEFT)\n        A.move_to(LEFT * 4)\n        self.play(Write(step_1))\n        self.play(Create(A))\n        self.wait(1)\n        for i in range(3):\n            arrow = Arrow(A[i].get_center() + RIGHT * 2, A[i].get_center() + RIGHT * 1.5, buff=0)\n            arrows.add(arrow)\n            text = Text(f'Shift by 1').scale(0.3)\n            texts.add(text)\n            text.next_to(arrow, RIGHT, buff=0.5)\n            self.play(Create(arrow), Write(text))\n            self.wait(1)\n        self.A_1 = self.circularShiftLeftOnePosition(A)\n        self.play(FadeOut(A), FadeOut(arrows), FadeOut(texts), FadeOut(step_1))\n        arrows = VGroup()\n        texts = VGroup()\n        step_1 = Text(\"Step 1: Circular shift each column of matrix B's blocks 1 position up\", color=WHITE).scale(0.6)\n        step_1.next_to(self.title, DOWN, buff=0.5).align_to(self.title, LEFT)\n        B.move_to(LEFT * 4)\n        self.play(Write(step_1))\n        self.play(Create(B))\n        self.wait(1)\n        for i in range(3):\n            arrow = Arrow(B[i][1].get_center() + DOWN * 2, B[i][1].get_center() + DOWN * 1.5, buff=0)\n            arrows.add(arrow)\n            text = Text(f'Shift by 1').scale(0.3)\n            texts.add(text)\n            text.next_to(arrow, DOWN, buff=0.5)\n            self.play(Create(arrow), Write(text))\n            self.wait(1)\n        self.B_1 = self.circularShiftUpOnePosition(B)\n        self.play(FadeOut(B), FadeOut(arrows), FadeOut(texts), FadeOut(step_1))\n        self.wait(1)\n        A_1_copy = copy.deepcopy(self.A_1)\n        B_1_copy = copy.deepcopy(self.B_1)\n        A_1_copy.move_to(LEFT * 4).scale(0.6)\n        B_1_copy.move_to(RIGHT * 4).scale(0.6)\n        P.move_to(ORIGIN)\n        self.play(Create(A_1_copy), Create(B_1_copy), Create(P))\n        self.wait(1)\n        self.parallelDistributeMatrix(A_1_copy, B_1_copy, P)\n        self.play(FadeOut(P))\n        self.wait(1)\n        pass\n\n    def animateStep2(self):\n        A = self.A_1\n        B = self.B_1\n        P = self.P\n        arrows = VGroup()\n        texts = VGroup()\n        step_2 = Text(\"Step 2: Circular shift each row of matrix A's blocks 1 position to the left\", color=WHITE).scale(0.6)\n        step_2.next_to(self.title, DOWN, buff=0.5).align_to(self.title, LEFT)\n        A.move_to(LEFT * 4)\n        self.play(Write(step_2))\n        self.play(Create(A))\n        self.wait(1)\n        for i in range(3):\n            arrow = Arrow(A[i].get_center() + RIGHT * 2, A[i].get_center() + RIGHT * 1.5, buff=0)\n            arrows.add(arrow)\n            text = Text(f'Shift by 1').scale(0.3)\n            texts.add(text)\n            text.next_to(arrow, RIGHT, buff=0.5)\n            self.play(Create(arrow), Write(text))\n            self.wait(1)\n        self.A_2 = self.circularShiftLeftOnePosition(A)\n        self.play(FadeOut(A), FadeOut(arrows), FadeOut(texts), FadeOut(step_2))\n        arrows = VGroup()\n        texts = VGroup()\n        step_2 = Text(\"Step 2: Circular shift each column of matrix B's blocks 1 position up\", color=WHITE).scale(0.6)\n        step_2.next_to(self.title, DOWN, buff=0.5).align_to(self.title, LEFT)\n        B.move_to(LEFT * 4)\n        self.play(Write(step_2))\n        self.play(Create(B))\n        self.wait(1)\n        for i in range(3):\n            arrow = Arrow(B[i][1].get_center() + DOWN * 2, B[i][1].get_center() + DOWN * 1.5, buff=0)\n            arrows.add(arrow)\n            text = Text(f'Shift by 1').scale(0.3)\n            texts.add(text)\n            text.next_to(arrow, DOWN, buff=0.5)\n            self.play(Create(arrow), Write(text))\n            self.wait(1)\n        self.B_2 = self.circularShiftUpOnePosition(B)\n        self.play(FadeOut(B), FadeOut(arrows), FadeOut(texts), FadeOut(step_2))\n        self.wait(1)\n        A_2_copy = copy.deepcopy(self.A_2)\n        B_2_copy = copy.deepcopy(self.B_2)\n        A_2_copy.move_to(LEFT * 4).scale(0.6)\n        B_2_copy.move_to(RIGHT * 4).scale(0.6)\n        P.move_to(ORIGIN)\n        self.play(Create(A_2_copy), Create(B_2_copy), Create(P))\n        self.wait(1)\n        self.parallelDistributeMatrix(A_2_copy, B_2_copy, P)\n        self.play(FadeOut(P))\n        self.wait(1)\n        pass\n\n    def circularShiftLeft(self, matrix):\n        new_matrix = VGroup()\n        elements = []\n        for i in range(3):\n            row = VGroup()\n            for j in range(3):\n                element = matrix[i][(j + i) % 3].copy()\n                self.play(element.animate.move_to(matrix[i][j].get_center() + RIGHT * 6), run_time=2)\n                elements.append(element)\n                row.add(element)\n            new_matrix.add(row)\n        self.wait(1)\n        self.play(*[FadeOut(element) for element in elements], run_time=2)\n        return new_matrix\n\n    def circularShiftUp(self, matrix):\n        new_matrix = VGroup()\n        elements = []\n        for i in range(3):\n            col = VGroup()\n            for j in range(3):\n                element = matrix[(j + i) % 3][i].copy()\n                self.play(element.animate.move_to(matrix[j][i].get_center() + RIGHT * 6), run_time=2)\n                elements.append(element)\n                col.add(element)\n            new_matrix.add(col)\n        self.wait(1)\n        self.play(*[FadeOut(element) for element in elements], run_time=2)\n        return new_matrix\n\n    def parallelDistributeMatrix(self, A, B, P):\n        text = MathTex('\\\\text{Each processor } P_{i,j} \\\\text{ locally updates matrix block } C_{i,j} \\\\text{ in parallel.}').scale(0.6)\n        text.next_to(self.title, DOWN, buff=0.5).align_to(self.title, LEFT)\n        self.play(Write(text))\n        animations = [ApplyMethod(A[i][j].move_to, P[i][j].get_center() + UP * 0.25 + LEFT * 0.25) for i in range(len(A)) for j in range(len(A[i]))] + [ApplyMethod(B[j][i].move_to, P[i][j].get_center() + UP * 0.25 + RIGHT * 0.25) for i in range(len(B)) for j in range(len(B[i]))]\n        self.play(*animations, run_time=3)\n        self.wait(2)\n        animationYellow = []\n        animationMultiply = []\n        animationFadeOut = []\n        animationTransform = []\n        for i in range(len(P)):\n            for j in range(len(P[i])):\n                animationYellow.append(A[i][j].animate.set_color(YELLOW))\n                animationYellow.append(B[j][i].animate.set_color(YELLOW))\n                multiply_symbol = MathTex('\\\\times').move_to(P[i][j].get_center() + UP * 0.25)\n                animationMultiply.append(Write(multiply_symbol))\n                self.C[i][j].move_to(P[i][j].get_center() + UP * 0.25)\n                animationFadeOut.append(FadeOut(multiply_symbol))\n                animationTransform.append(Transform(A[i][j], self.C[i][j]))\n                animationTransform.append(Transform(B[j][i], self.C[i][j]))\n        self.play(*animationYellow, run_time=1)\n        self.wait(1)\n        self.play(*animationMultiply, run_time=1)\n        self.wait(1)\n        self.play(*animationFadeOut, run_time=1)\n        self.wait(1)\n        self.play(*animationTransform, run_time=2)\n        self.wait(1)\n        self.play(FadeOut(self.C), FadeOut(A), FadeOut(B), FadeOut(text))\n        self.wait(1)\n        pass\n\n    def circularShiftLeftOnePosition(self, matrix):\n        new_matrix = VGroup()\n        elements = []\n        for i in range(3):\n            row = VGroup()\n            for j in range(3):\n                element = matrix[i][(j + 1) % 3].copy()\n                self.play(element.animate.move_to(matrix[i][j].get_center() + RIGHT * 6), run_time=2)\n                elements.append(element)\n                row.add(element)\n            new_matrix.add(row)\n        self.wait(1)\n        self.play(*[FadeOut(element) for element in elements], run_time=2)\n        return new_matrix\n\n    def circularShiftUpOnePosition(self, matrix):\n        new_matrix = VGroup()\n        elements = []\n        for i in range(3):\n            col = VGroup()\n            for j in range(3):\n                element = matrix[i][(j + 1) % 3].copy()\n                self.play(element.animate.move_to(matrix[i][j].get_center() + RIGHT * 6), run_time=2)\n                elements.append(element)\n                col.add(element)\n            new_matrix.add(col)\n        self.wait(1)\n        self.play(*[FadeOut(element) for element in elements], run_time=2)\n        return new_matrix\n\n    def animateEnd(self):\n        circle_left = Circle(radius=1.5, color=RED).shift(LEFT)\n        circle_right = Circle(radius=1.5, color=RED).shift(RIGHT)\n        circle_left.set_fill(RED, opacity=1)\n        circle_right.set_fill(RED, opacity=1)\n        triangle = Polygon([-2, -1, 0], [2, -1, 0], [0, -3, 0], color=RED).set_fill(RED, opacity=1)\n        heart = VGroup(circle_left, circle_right, triangle)\n        heart.move_to(ORIGIN)\n        heart.scale(0.1)\n        self.play(GrowFromCenter(heart))\n        self.wait(1)\n        text_left = Text('Made with').next_to(heart, LEFT)\n        text_right = Text('using Manim').next_to(heart, RIGHT)\n        self.play(Write(text_left), Write(text_right))\n        pass"}]}
{"messages": [{"role": "user", "content": "Illustrate Fox's algorithm for matrix multiplication, showing broadcast, parallel updates, and circular shifts step-by-step."}, {"role": "assistant", "content": "from manim import *\nimport copy\n\nclass Fox(Scene):\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.A = self.createSquareMatrix(3, 'A', BLUE, 0.8, 0.5)\n        self.B = self.createSquareMatrix(3, 'B', GREEN, 0.8, 0.5)\n        self.C = self.createSquareMatrix(3, 'C', ORANGE, 0.8, 0.5)\n        self.grid = self.createGrid()\n        self.title = Text(\"Fox's Algorithm\", color=WHITE).to_edge(UP + LEFT).scale(0.8)\n        self.text = None\n\n    def construct(self):\n        self.play(Write(self.title))\n        self.A.move_to(DOWN + 0.8 * LEFT + 0.4 * DOWN)\n        self.B.move_to(DOWN + 0.8 * RIGHT + 0.4 * DOWN)\n        self.grid.move_to(DOWN)\n        self.changeText('Algorithm works in $\\\\sqrt{P} \\\\text{ steps} = \\\\sqrt{9} = 3 \\\\text{ steps}$')\n        self.play(*[FadeIn(o) for o in (self.A, self.B, self.grid)])\n        self.wait(1)\n        self.changeText('1.1 One to all broadcast of block $A_{i,i}$ within each row $i$ ; k = 0.')\n        A_0 = self.broadcastMatrix(self.A)\n        self.wait(1)\n        self.changeText('1.2 Each processor $P_{i,j}$ locally updates $C_{i,j}$.')\n        B_0 = copy.deepcopy(self.B)\n        self.parallelMultiplyMatrix(A_0, self.B, self.C)\n        self.wait(1)\n        self.play(*[FadeOut(o) for o in (self.A, self.grid)])\n        self.wait(1)\n        self.changeText('2.1 One to all broadcast of block $A_{i,(i+k) \\\\mod \\\\sqrt{P}}$ within each row $i$ ; k = 1.')\n        self.play(*[FadeIn(o) for o in (self.A, B_0, self.grid)])\n        A_1 = self.broadcastMatrix(self.A, 1)\n        self.wait(1)\n        self.changeText('2.2 Circular shift each column of $B$ up by one.')\n        self.play(*[CyclicReplace(*column[::-1]) for column in zip(*B_0)])\n        self.wait(1)\n        self.changeText('2.3 Each processor $P_{i,j}$ locally updates $C_{i,j}$.')\n        B_0 = self.shiftB(B_0)\n        B_1 = copy.deepcopy(B_0)\n        self.parallelMultiplyMatrix(A_1, B_0, self.C)\n        self.wait(1)\n        self.play(*[FadeOut(o) for o in (self.A, self.grid)])\n        self.wait(1)\n        self.changeText('3.1 One to all broadcast of block $A_{i,(i+k) \\\\mod \\\\sqrt{P}}$ within each row $i$ ; k = 2.')\n        self.play(*[FadeIn(o) for o in (self.A, B_1, self.grid)])\n        A_2 = self.broadcastMatrix(self.A, 2)\n        self.wait(1)\n        self.changeText('3.2 Circular shift each column of $B$ up by one.')\n        self.play(*[CyclicReplace(*column[::-1]) for column in zip(*B_1)])\n        self.wait(1)\n        self.changeText('3.3 Each processor $P_{i,j}$ locally updates $C_{i,j}$.')\n        B_1 = self.shiftB(B_1)\n        self.parallelMultiplyMatrix(A_2, B_1, self.C)\n        self.wait(1)\n        self.play(*[FadeOut(o) for o in (self.A, self.grid, self.text)])\n        self.play(FadeOut(self.title))\n        self.animateEnd()\n        self.wait(2)\n\n    def shiftB(self, B):\n        B = [[column[(i + 1) % len(column)] for i in range(len(column))] for column in zip(*B)]\n        B = [VGroup(*column) for column in B]\n        B = VGroup(*B)\n        B = [list(column) for column in B]\n        B = list(map(list, zip(*B)))\n        B = VGroup(*[VGroup(*column) for column in B])\n        return B\n\n    def broadcastMatrix(self, matrix, k=0):\n        new_matrix = VGroup()\n        elements = []\n        broadcastAnimation = []\n        for i in range(3):\n            row = VGroup()\n            for j in range(3):\n                element = matrix[i][(i + k) % 3].copy()\n                broadcastAnimation.append(element.animate.move_to(matrix[i][j].get_center() + RIGHT * 0.8))\n                elements.append(element)\n                row.add(element)\n            new_matrix.add(row)\n        self.wait(1)\n        self.play(*broadcastAnimation, run_time=2)\n        self.wait(1)\n        return new_matrix\n\n    def createSquareMatrix(self, size, label, color, scale, opacity):\n        matrix = VGroup()\n        for x in range(size):\n            row = VGroup()\n            for y in range(size):\n                cell = Square(side_length=0.8, fill_color=color, fill_opacity=opacity, stroke_width=1)\n                cell_label = MathTex(label + '_{' + str(x) + str(y) + '}', color=WHITE).scale(cell.get_height())\n                cell.add(cell_label)\n                row.add(cell)\n            matrix.add(row.arrange(RIGHT, buff=1.6))\n        matrix.arrange(DOWN, buff=0.8)\n        return matrix\n\n    def createGrid(self):\n        grid = VGroup()\n        for i in range(3):\n            row = VGroup()\n            for j in range(3):\n                cell = Rectangle(height=1.6, width=2.4, fill_color=WHITE, fill_opacity=0, stroke_width=2)\n                cell_label = MathTex('P_{' + str(i) + str(j) + '}', color=WHITE).scale(cell.get_height() / 2)\n                cell_label.move_to(cell_label.get_center() + 0.4 * UP)\n                cell.add(cell_label)\n                row.add(cell)\n            grid.add(row.arrange(RIGHT, buff=0))\n        grid.arrange(DOWN, buff=0)\n        return grid\n\n    def changeText(self, text):\n        self.remove(self.text)\n        self.text = Tex(text, color=WHITE).scale(0.6)\n        self.text.next_to(self.title, DOWN, buff=0.5).align_to(self.title, LEFT)\n        self.play(Write(self.text))\n\n    def parallelMultiplyMatrix(self, A, B, P):\n        animationYellow = []\n        animationMultiply = []\n        animationFadeOut = []\n        animationTransform = []\n        for i in range(len(P)):\n            for j in range(len(P[i])):\n                animationYellow.append(A[i][j].animate.set_color(YELLOW))\n                animationYellow.append(B[i][j].animate.set_color(YELLOW))\n                multiply_symbol = MathTex('\\\\times').move_to(A[i][j].get_center() + RIGHT * 0.4)\n                animationMultiply.append(Write(multiply_symbol))\n                self.C[i][j].move_to(A[i][j].get_center() + RIGHT * 0.4)\n                animationFadeOut.append(FadeOut(multiply_symbol))\n                animationTransform.append(Transform(A[i][j], self.C[i][j]))\n                animationTransform.append(Transform(B[i][j], self.C[i][j]))\n        self.play(*animationYellow, run_time=1)\n        self.wait(1)\n        self.play(*animationMultiply, run_time=1)\n        self.wait(1)\n        self.play(*animationFadeOut, run_time=1)\n        self.wait(1)\n        self.play(*animationTransform, run_time=2)\n        self.wait(1)\n        self.play(FadeOut(self.C), FadeOut(A), FadeOut(B))\n        self.wait(1)\n        pass\n\n    def circularShiftUpOnePosition(self, matrix):\n        new_matrix = VGroup()\n        for i in range(3):\n            row = VGroup()\n            for j in range(3):\n                element = matrix[(j + 1) % 3][i].copy()\n                row.add(element)\n            new_matrix.add(row.arrange(RIGHT, buff=1.6))\n        new_matrix.arrange(DOWN, buff=0.8)\n        return new_matrix\n\n    def animateEnd(self):\n        circle_left = Circle(radius=1.5, color=RED).shift(LEFT)\n        circle_right = Circle(radius=1.5, color=RED).shift(RIGHT)\n        circle_left.set_fill(RED, opacity=1)\n        circle_right.set_fill(RED, opacity=1)\n        triangle = Polygon([-2, -1, 0], [2, -1, 0], [0, -3, 0], color=RED).set_fill(RED, opacity=1)\n        heart = VGroup(circle_left, circle_right, triangle)\n        heart.move_to(ORIGIN)\n        heart.scale(0.1)\n        self.play(GrowFromCenter(heart))\n        self.wait(1)\n        text_left = Text('Made with').next_to(heart, LEFT)\n        text_right = Text('using Manim').next_to(heart, RIGHT)\n        self.play(Write(text_left), Write(text_right))\n        pass"}]}
{"messages": [{"role": "user", "content": "Introduce Newton's Laws of Motion by animating an arrow and the letter 'F' representing force, followed by displaying the text for Newton's Second, First, and Universal Gravitation laws."}, {"role": "assistant", "content": "from manim import *\n\nclass intro(Scene):\n\n    def construct(self):\n        start_point = (-2, 0, 0)\n        end_point = (2, 0, 0)\n        line = Line(start_point, end_point)\n        arrow_size = 8\n        arrow = Arrow(end_point - RIGHT * arrow_size / 2, end_point, buff=0)\n        self.play(Create(arrow, run_time=2.5))\n        F = Text('F', font_size=400)\n        F.next_to(arrow, DOWN)\n        self.play(Create(F), arrow.animate.shift(UP * 3), F.animate.shift(UP * 3))\n        self.wait(1)\n        vectorF = VGroup(F, arrow)\n        self.play(ScaleInPlace(vectorF, 0.15, run_time=1))\n        self.play(vectorF.animate.shift(UP * 1.5))\n        self.wait(1)\n        law2 = Text(\"Newton's Second Law of Motion\", font_size=45)\n        law2.next_to(vectorF, RIGHT)\n        law2.move_to(UP * 3.5)\n        t0 = MathTex(' = ma', font_size=70)\n        self.play(vectorF.animate.shift(LEFT))\n        t0.next_to(vectorF, RIGHT)\n        self.play(Create(law2), FadeIn(t0, shift=RIGHT))\n        self.wait(1)\n        secondLaw = VGroup(vectorF, t0, law2)\n        law1 = Text(\"Newton's First Law (for Rotation)\", font_size=45)\n        law1.move_to(law2.get_center() + DOWN * 2.5)\n        t1 = Tex('An object at rest remains at rest, or if in motion, remains in motion at a constant velocity unless acted on by a net external force.', font_size=35)\n        t1.next_to(law1, DOWN)\n        self.play(Create(law1))\n        self.play(Create(t1))\n        self.wait(1)\n        law3 = Text(\"Newton's Law of Universal Gravitation\", font_size=40)\n        law3.move_to(law1.get_center() + DOWN * 2.5)\n        t2 = MathTex('F_G = G\\\\frac{m_1m_2}{r^2}')\n        t2.next_to(law3, DOWN * 1.5)\n        self.play(Create(law3))\n        self.play(Create(t2))\n        self.wait(15)"}]}
{"messages": [{"role": "user", "content": "Illustrate the relationship between Newton's First Law and the Law of Gravitation by transforming relevant terms and displaying their equivalent forms."}, {"role": "assistant", "content": "from manim import *\n\nclass gravitation(Scene):\n\n    def construct(self):\n        t01 = MathTex('F =')\n        t02 = MathTex('ma')\n        t0 = VGroup(t01, t02).arrange(RIGHT)\n        t0t = Text(\"Newton's First Law\", font_size=30)\n        t0.move_to(UP * 2.5 + LEFT * 3)\n        t0t.next_to(t0, UP * 2.3)\n        t11 = MathTex('F_g')\n        t12 = MathTex('= \\\\frac{Gmm}{r^2}')\n        t1 = VGroup(t11, t12).arrange(RIGHT)\n        t1t = Text(\"Newton's Law of Gravitation\", font_size=30)\n        t1.move_to(UP * 2.5 + RIGHT * 3)\n        t1t.next_to(t1, UP)\n        self.play(Create(t0), Create(t0t))\n        self.play(Create(t1), Create(t1t))\n        self.wait(1)\n        self.play(FadeOut(t0t), FadeOut(t1t))\n        self.wait(1)\n        r_transform = VGroup(t01, t02, t11, t12)\n        self.wait(0.5)\n        temp1 = MathTex('= \\\\frac{GM_{Earth}m}{r_{Earth}^2}')\n        temp_copy1 = temp1.copy().move_to(r_transform[3].get_center())\n        self.play(ReplacementTransform(r_transform[3], temp_copy1), t11.animate.shift(LEFT * 0.6))\n        r_transform.add(temp_copy1)\n        r_transform.remove(t12)\n        self.wait(10)\n        temp2 = MathTex('mg')\n        temp_copy2 = temp2.copy().move_to(r_transform[1].get_center())\n        self.play(ReplacementTransform(r_transform[1], temp_copy2))\n        r_transform.add(temp_copy2)\n        r_transform.remove(t02)\n        self.wait(10)\n        self.play(FadeOut(r_transform[0]), FadeOut(r_transform[1]))\n        self.play(r_transform[3].animate.shift(RIGHT * 1.5), r_transform[2].animate.shift(LEFT * 2.2))\n        r_transform.remove(r_transform[0])\n        r_transform.remove(r_transform[2])\n        self.wait(1)\n        t2 = MathTex('r_{Earth}^2g= GM_{Earth}')\n        t2.next_to(r_transform, DOWN)\n        t2.move_to(UP * 0.3)\n        self.play(Create(t2))\n        self.wait(1)\n        box = SurroundingRectangle(t2, color=BLUE, buff=0.3, corner_radius=0.1)\n        self.add(box, t2)\n        self.play(Create(box))\n        self.wait(10)\n        t3 = MathTex('\\\\text{Where,}\\\\: r_{Earth} = 61378.1\\\\: \\\\text{kilometers}')\n        t3.next_to(t2, DOWN)\n        t3.move_to(DOWN)\n        t4 = MathTex('g=9.8m/s^2')\n        t4.next_to(t3, DOWN)\n        t4.move_to(DOWN * 1.7 + RIGHT * 0.3)\n        self.play(Create(t3))\n        self.wait(12)\n        self.play(Create(t4))\n        self.wait(30)"}]}
{"messages": [{"role": "user", "content": "Display the text \"Cavendish Experiment\" at the top of the screen for 30 seconds."}, {"role": "assistant", "content": "from manim import *\n\nclass cavendishExperimentText(Scene):\n\n    def construct(self):\n        cavendishExperiment = Text('Cavendish Experiment', font_size=45)\n        cavendishExperiment.move_to(UP * 3)\n        self.play(Create(cavendishExperiment))\n        self.wait(30)"}]}
{"messages": [{"role": "user", "content": "Present a physics equation for net torque, gradually transform terms to show derivations, and highlight the final equation with a blue rectangle."}, {"role": "assistant", "content": "from manim import *\n\nclass deriveGWithK(Scene):\n\n    def construct(self):\n        t01 = MathTex('\\\\tau_{net}')\n        t02 = MathTex('=')\n        t03 = MathTex('\\\\tau_{gravity}')\n        t041 = MathTex('+')\n        t042 = MathTex('\\\\tau_{wire}')\n        t04 = VGroup(t041, t042).arrange(RIGHT, buff=0.5)\n        t0 = VGroup(t01, t02, t03, t04).arrange(RIGHT, buff=0.2)\n        self.play(Create(t0, run_time=3))\n        self.wait(10)\n        temp1 = MathTex('2(F_g\\\\frac{L}{2})')\n        temp_copy = temp1.copy().move_to(t0[2].get_center())\n        self.play(ReplacementTransform(t0[2], temp_copy))\n        self.wait(11)\n        temp1 = MathTex('F_gL')\n        temp_copy = temp1.copy().move_to(t0[2].get_center())\n        self.play(ReplacementTransform(t0[2], temp_copy))\n        self.wait(1)\n        t041n = MathTex('-')\n        t042n = MathTex('k\\\\theta')\n        temp2 = VGroup(t041n, t042n).arrange(RIGHT, buff=0.5)\n        temp_copy = temp2.copy().move_to(t0[3].get_center())\n        self.play(ReplacementTransform(t0[3], temp_copy))\n        t0.add(temp_copy)\n        self.wait(1)\n        self.play(FadeOut(t0, run_time=0.01))\n        zero = MathTex('0')\n        zero.move_to(UP * 2.85 + LEFT * 2.2)\n        self.play(t0.animate.shift(UP * 2.8))\n        self.play(FadeOut(t0[0]))\n        self.play(FadeIn(zero))\n        self.wait(10)\n        path = ArcBetweenPoints(temp_copy.get_center(), zero.get_center() + LEFT * 0.5, angle=PI / 2, stroke_width=8)\n        self.play(FadeOut(temp_copy[0]), run_time=0.3)\n        temp_copy.remove(temp_copy[0])\n        self.play(MoveAlongPath(temp_copy, path), FadeOut(zero), run_time=1)\n        t0.remove(t01)\n        self.play(t0.animate.shift(RIGHT * 1.4))\n        t2 = MathTex(' \\\\frac{k\\\\theta}{L}')\n        t3 = MathTex('\\\\frac{GMm}{r^2}')\n        r_transform = VGroup(t2, MathTex('='), MathTex('F_g'), MathTex('='), t3)\n        r_transform.arrange(direction=RIGHT, buff=1)\n        r_transform.next_to(t0, DOWN * 1.2)\n        r_transform.move_to(r_transform.get_center() + RIGHT * 1.85)\n        self.play(Create(r_transform[:3]))\n        self.wait(1)\n        self.play(Create(r_transform[3:]))\n        self.wait(11)\n        self.play(FadeOut(r_transform[2]), FadeOut(r_transform[3]))\n        self.play(r_transform[4].animate.shift(LEFT * 3))\n        r_transform.remove(r_transform[2])\n        r_transform.remove(r_transform[3])\n        self.wait(1)\n        t5 = MathTex('\\\\frac{k\\\\theta r^2}{LMm} \\\\;=\\\\; G')\n        t5.next_to(r_transform, DOWN * 1.5)\n        t5.move_to(t5.get_center() + LEFT * 1.1)\n        self.play(Create(t5))\n        box = SurroundingRectangle(t5, color=BLUE, buff=0.3, corner_radius=0.1)\n        self.add(box, t5)\n        self.play(Create(box))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Display Hooke's Law formula for 10 seconds."}, {"role": "assistant", "content": "from manim import *\n\nclass hookesLaw(Scene):\n\n    def construct(self):\n        hookeslaw = MathTex('\\\\tau = -k\\\\theta')\n        self.play(Create(hookeslaw))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Derive the formula for k from the formula for T, showing each algebraic manipulation with text transformations and highlighting the final result with a blue box."}, {"role": "assistant", "content": "from manim import *\n\nclass deriveKFromT(Scene):\n\n    def construct(self):\n        periodT = MathTex('T')\n        periodRest = MathTex('= 2\\\\pi \\\\sqrt{\\\\frac{I_{net}}{k}}')\n        periodT.next_to(periodRest, LEFT)\n        self.play(Create(periodT), Create(periodRest))\n        self.wait(15)\n        periodTSquared = MathTex('T^2')\n        periodRestSquared = MathTex('= (2\\\\pi)^2 \\\\frac{I_{net}}{k}')\n        periodTSquared.next_to(periodRestSquared, LEFT)\n        self.play(ReplacementTransform(periodRest, periodRestSquared), ReplacementTransform(periodT, periodTSquared))\n        self.wait(1)\n        periodTSquaredK = MathTex('k T^2')\n        periodRestSquaredK = MathTex('= (2\\\\pi)^2 I_{net}')\n        periodTSquaredK.next_to(periodRestSquaredK, LEFT)\n        self.play(ReplacementTransform(periodRestSquared, periodRestSquaredK), ReplacementTransform(periodTSquared, periodTSquaredK))\n        self.wait(1)\n        k0 = MathTex('k')\n        kRest0 = MathTex('= \\\\frac{(2\\\\pi)^2 I_{net}}{T^2}')\n        k0.next_to(kRest0, LEFT)\n        self.play(ReplacementTransform(periodTSquaredK, k0), ReplacementTransform(periodRestSquaredK, kRest0))\n        self.wait(1)\n        k = MathTex('k')\n        kRest = MathTex('=  (\\\\frac{2\\\\pi}{T})^2I_{net}')\n        k.next_to(kRest, LEFT)\n        self.play(ReplacementTransform(k0, k), ReplacementTransform(kRest0, kRest))\n        group = VGroup(k, kRest)\n        box = SurroundingRectangle(group, color=BLUE, buff=0.3, corner_radius=0.1)\n        self.add(box, group)\n        self.play(Create(box))\n        self.wait(20)"}]}
{"messages": [{"role": "user", "content": "Visualize a 3D rod with spheres at each end and a rope, then rotate the assembly back and forth."}, {"role": "assistant", "content": "from manim import *\n\nclass setup(ThreeDScene):\n\n    def construct(self):\n        rod = Cylinder(radius=0.15, height=8, direction=DOWN)\n        rod.set_fill(color=GOLD)\n        brass1 = Sphere(radius=0.5)\n        brass2 = Sphere(radius=0.5)\n        brass1.set_fill(color=GOLD)\n        brass2.set_fill(color=GOLD)\n        brass1.next_to(rod, DOWN, buff=0)\n        brass2.next_to(rod, UP, buff=0)\n        rope = Cylinder(radius=0.05, height=8, direction=RIGHT)\n        rope.set_fill(color=GRAY)\n        rope.next_to(rod, RIGHT, buff=0)\n        group = VGroup(rod, brass1, brass2, rope)\n        angle = PI / 12\n        line = Line(start=10 * DOWN, end=10 * UP, stroke_width=0.3)\n        line2 = Line(start=10 * DOWN, end=10 * UP, stroke_width=0.3)\n        line2.rotate(angle + 8 * DEGREES, about_point=ORIGIN)\n        line3 = Line(start=10 * DOWN, end=10 * UP, stroke_width=0.3)\n        line3.rotate(-(angle + 8 * DEGREES), about_point=ORIGIN)\n        self.set_camera_orientation(phi=120 * DEGREES, theta=0 * DEGREES)\n        self.camera.focal_distance = 10\n        self.play(Create(group), Create(line), Create(line2), Create(line3))\n        self.play(Rotate(group, angle=angle, axis=RIGHT, about_point=group.get_center()), run_time=2)\n        self.play(Rotate(group, angle=-2 * angle, axis=RIGHT, about_point=group.get_center()), run_time=2)\n        self.play(Rotate(group, angle=2 * angle, axis=RIGHT, about_point=group.get_center()), run_time=2)\n        self.play(Rotate(group, angle=-2 * angle, axis=RIGHT, about_point=group.get_center()), run_time=2)"}]}
{"messages": [{"role": "user", "content": "Display and transform mathematical expressions to illustrate the concept of rotational inertia and its relation to torsion, culminating in a boxed final equation."}, {"role": "assistant", "content": "from manim import *\n\nclass rotationalInertiaK(Scene):\n\n    def construct(self):\n        k = Text('k')\n        text = Text('<- torsion constant')\n        text.move_to(RIGHT)\n        self.play(Create(k))\n        self.wait(0.5)\n        self.play(k.animate.shift(LEFT * 2.5))\n        self.play(FadeIn(text, shift=RIGHT))\n        self.wait(2)\n        self.play(FadeOut(k), FadeOut(text))\n        t01 = MathTex('I_{net}')\n        t02 = MathTex('=')\n        t03 = MathTex('I_{point\\\\,mass}')\n        t04 = MathTex('+')\n        t05 = MathTex('I_{point\\\\,mass}')\n        t06 = MathTex('+')\n        t07 = MathTex('I_{rotating\\\\,rod}')\n        t0 = VGroup(t01, t02, t03, t04, t05, t06, t07).arrange(RIGHT, buff=0.2)\n        self.play(Create(t0))\n        self.wait(10)\n        temp1 = MathTex('m(\\\\frac{L}{2})^2')\n        temp_copy1 = temp1.copy().move_to(t0[2].get_center())\n        temp_copy2 = temp1.copy().move_to(t0[4].get_center())\n        self.play(ReplacementTransform(t0[2], temp_copy1), ReplacementTransform(t0[4], temp_copy2))\n        self.wait(7)\n        temp1 = MathTex('\\\\frac{m_{rod}(L)^2}{12}')\n        temp_copy3 = temp1.copy().move_to(t0[6].get_center())\n        self.play(ReplacementTransform(t0[6], temp_copy3))\n        self.wait(18)\n        t3 = MathTex('\\\\frac{GMm}{r^2}')\n        r_transform = VGroup(t01, t02, temp_copy1, t04, temp_copy2, t06, temp_copy3)\n        temp4 = MathTex('2m(\\\\frac{L}{2})^2')\n        temp_copy4 = temp4.copy().move_to(r_transform[4].get_center() + LEFT * 1.3)\n        self.play(FadeOut(r_transform[2], run_time=0.3), FadeOut(r_transform[3], run_time=0.3), r_transform[0].animate.shift(RIGHT * 1.4), r_transform[1].animate.shift(RIGHT * 1.5), r_transform[4].animate.shift(LEFT * 1.3), ReplacementTransform(r_transform[4], temp_copy4), r_transform[5].animate.shift(LEFT * 1.3), r_transform[6].animate.shift(LEFT))\n        self.wait(1)\n        r_transform.remove(temp_copy1)\n        r_transform.remove(t04)\n        r_transform.remove(temp_copy2)\n        r_transform.add(temp_copy4)\n        self.play(r_transform.animate.shift(UP * 3))\n        self.wait(1)\n        t2 = MathTex('k = I_{net} (\\\\frac{2\\\\pi}{T})^2')\n        t2.next_to(r_transform, DOWN * 2)\n        self.play(Create(t2))\n        self.wait(1)\n        t3 = MathTex('\\\\therefore k = (\\\\frac{m_{rod}(L)^2}{12} + 2m(\\\\frac{L}{2})^2)\\\\;(\\\\frac{2\\\\pi}{T})^2')\n        t3.next_to(t2, DOWN * 2)\n        self.play(Create(t3, run_time=2))\n        self.wait(2)\n        box = SurroundingRectangle(t3, color=BLUE, buff=0.3, corner_radius=0.1)\n        self.add(box, t3)\n        self.play(Create(box))\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Derive an equation by sequentially transforming and revealing mathematical terms and then enclosing the final result in a box."}, {"role": "assistant", "content": "from manim import *\n\nclass deriveG(Scene):\n\n    def construct(self):\n        t01 = MathTex('\\\\tau_{net}')\n        t02 = MathTex('=')\n        t03 = MathTex('\\\\tau_{gravity}')\n        t041 = MathTex('+')\n        t042 = MathTex('\\\\tau_{wire}')\n        t04 = VGroup(t041, t042).arrange(RIGHT, buff=0.5)\n        t0 = VGroup(t01, t02, t03, t04).arrange(RIGHT, buff=0.2)\n        self.play(Create(t0, run_time=3))\n        self.wait(1)\n        temp1 = MathTex('2(F_g\\\\frac{L}{2})')\n        temp_copy = temp1.copy().move_to(t0[2].get_center())\n        self.play(ReplacementTransform(t0[2], temp_copy))\n        self.wait(1)\n        temp1 = MathTex('F_gL')\n        temp_copy = temp1.copy().move_to(t0[2].get_center())\n        self.play(ReplacementTransform(t0[2], temp_copy))\n        self.wait(1)\n        t041n = MathTex('-')\n        t042n = MathTex('k\\\\theta')\n        temp2 = VGroup(t041n, t042n).arrange(RIGHT, buff=0.5)\n        temp_copy = temp2.copy().move_to(t0[3].get_center())\n        self.play(ReplacementTransform(t0[3], temp_copy))\n        t0.add(temp_copy)\n        self.wait(1)\n        self.play(FadeOut(t0, run_time=0.01))\n        zero = MathTex('0')\n        zero.move_to(UP * 2.85 + LEFT * 2.2)\n        self.play(t0.animate.shift(UP * 2.8))\n        self.play(FadeOut(t0[0]))\n        self.play(FadeIn(zero))\n        self.wait(1)\n        path = ArcBetweenPoints(temp_copy.get_center(), zero.get_center() + LEFT * 0.5, angle=PI / 2, stroke_width=8)\n        self.play(FadeOut(temp_copy[0]), run_time=0.3)\n        temp_copy.remove(temp_copy[0])\n        self.play(MoveAlongPath(temp_copy, path), FadeOut(zero), run_time=1)\n        t0.remove(t01)\n        self.play(t0.animate.shift(RIGHT * 1.4))\n        t2 = MathTex(' \\\\frac{k\\\\theta}{L}')\n        t3 = MathTex('\\\\frac{GMm}{r^2}')\n        r_transform = VGroup(t2, MathTex('='), MathTex('F_g'), MathTex('='), t3)\n        r_transform.arrange(direction=RIGHT, buff=1)\n        r_transform.next_to(t0, DOWN * 1.2)\n        r_transform.move_to(r_transform.get_center() + RIGHT * 1.85)\n        self.play(Create(r_transform[:3]))\n        self.wait(1)\n        self.play(Create(r_transform[3:]))\n        self.wait(1)\n        self.play(FadeOut(r_transform[2]), FadeOut(r_transform[3]))\n        self.play(r_transform[4].animate.shift(LEFT * 3))\n        r_transform.remove(r_transform[2])\n        r_transform.remove(r_transform[3])\n        self.wait(1)\n        t5 = MathTex('\\\\frac{k\\\\theta r^2}{LMm} \\\\;=\\\\; G')\n        t5.next_to(r_transform, DOWN * 1.4)\n        t5.move_to(t5.get_center() + LEFT * 1.1)\n        self.play(Create(t5))\n        self.wait(10)\n        t6 = MathTex('G \\\\;=\\\\; \\\\frac{(\\\\frac{m_{rod}(L)^2}{12}+2m(\\\\frac{L}{2})^2)(\\\\frac{2\\\\pi}{T})^2\\\\theta r^2}{LMm}')\n        t6.next_to(t5, DOWN * 2)\n        t6.shift(RIGHT * 1.2)\n        self.play(Create(t6, run_time=4))\n        self.wait(1)\n        box = SurroundingRectangle(t6, color=BLUE, buff=0.3, corner_radius=0.1)\n        self.add(box, t6)\n        self.play(Create(box))\n        self.wait(20)"}]}
{"messages": [{"role": "user", "content": "Write the equation 'a = b + c', animate 'a' moving left, draw an arc connecting 'c' to a point near 'a', fade out the '+' sign, fade in a '-' sign between 'a' and 'c', and finally shift the modified equation."}, {"role": "assistant", "content": "from manim import *\n\nclass testArc(Scene):\n\n    def construct(self):\n        a = Text('a')\n        equals1 = Text('=')\n        b = Text('b')\n        plus = Text('+')\n        c = Text('c')\n        minus = Text('-')\n        equation1 = VGroup(a, equals1, b, plus, c).arrange(RIGHT, buff=0.5)\n        equation1.shift(UP * 2)\n        self.play(Write(equation1))\n        self.wait(1)\n        self.play(a.animate.shift(LEFT))\n        path = ArcBetweenPoints(c.get_center(), a.get_center() + RIGHT * 1, angle=PI / 2, stroke_width=8)\n        self.play(MoveAlongPath(c, path), FadeOut(plus), run_time=1)\n        minus.move_to((a.get_center() + c.get_center()) / 2)\n        self.play(FadeIn(minus))\n        equation1.add(minus)\n        equation1.remove(plus)\n        self.play(equation1.animate.shift(RIGHT + UP))\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Present the equation a = b = c, fade out 'b' and '=', then shift 'c' to the left and display a new equation below."}, {"role": "assistant", "content": "from manim import *\n\nclass testCombine(Scene):\n\n    def construct(self):\n        r_transform = VGroup(Text('a '), Text('='), Text('b'), Text('='), Text('c'))\n        r_transform.arrange(direction=RIGHT, buff=1)\n        self.play(Create(r_transform))\n        self.play(FadeOut(r_transform[2]), FadeOut(r_transform[3]))\n        self.play(r_transform[4].animate.shift(LEFT * 3))\n        r_transform.remove(r_transform[2])\n        r_transform.remove(r_transform[3])\n        t4 = MathTex('\\\\frac{k\\\\theta}{L} = \\\\frac{GMm}{r^2}')\n        t4.next_to(r_transform, DOWN)\n        self.play(Create(t4))"}]}
{"messages": [{"role": "user", "content": "Animate a circle with an updater that draws an increasing number of colored lines originating from points on the circle's circumference, with the line endpoints dynamically changing based on a value tracker."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Updater2(Scene):\n    CONFIG = {'x': 100, 'radius': 3.5, 'end_value': 25, 'total_time': 30, 'gradient_colors': [RED, YELLOW, BLUE]}\n\n    def construct(self):\n        mod_tracker = ValueTracker(0)\n        circle = Circle()\n        circle.scale(self.radius)\n        lines = self.get_obj(circle, mod_tracker.get_value())\n        lines.add_updater(lambda m: m.become(self.get_obj(circle, mod_tracker.get_value())))\n        self.play(ShowCreation(circle))\n        self.play(ShowCreation(lines))\n        self.wait()\n        self.play(mod_tracker.set_value, self.end_value, rate_func=linear, run_time=self.total_time)\n        self.wait(3)\n\n    def get_obj(self, circle, mod):\n        lines = VGroup()\n        for i in range(self.x):\n            start = circle.point_from_proportion(i % self.x / self.x)\n            end = circle.point_from_proportion(i * mod % self.x / self.x)\n            line = Line(start, end).set_stroke(width=1)\n            lines.add(line)\n        lines.set_color_by_gradient(*self.gradient_colors)\n        return lines"}]}
{"messages": [{"role": "user", "content": "Display \"Group Theory\" above a 2x3 grid of colorful, abstract triangle shapes."}, {"role": "assistant", "content": "from manim import *\n\nclass Thumbnail(Scene):\n\n    def construct(self):\n        grouptheory = MathTex('\\\\text{Group Theory}').scale(2.4).move_to(UP * 2.8)\n        t1 = TriangleGroup(color=BLUE).with_top().scale(1.15)\n        t1.submobjects[0].color = YELLOW\n        t2 = TriangleGroup(color=GREEN).with_do_nothing().scale(1.15)\n        t2.submobjects[0].color = YELLOW\n        t3 = TriangleGroup(color=BLUE).with_rotate120().scale(1.15)\n        t3.submobjects[0].color = YELLOW\n        t4 = TriangleGroup(color=GREEN).with_rotate240().scale(1.15)\n        t4.submobjects[0].color = YELLOW\n        t5 = TriangleGroup(color=BLUE).with_right().scale(1.15)\n        t5.submobjects[0].color = YELLOW\n        t6 = TriangleGroup(color=GREEN).with_left().scale(1.15)\n        t6.submobjects[0].color = YELLOW\n        l1 = VGroup(t1, t2, t3).arrange(RIGHT, LARGE_BUFF * 2)\n        l2 = VGroup(t4, t5, t6).arrange(RIGHT, LARGE_BUFF * 2)\n        l1.next_to(grouptheory, DOWN, LARGE_BUFF * 0.7)\n        l2.next_to(l1, DOWN, MED_LARGE_BUFF)\n        self.add(grouptheory, l1, l2)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Display the text \"DavideRadaelli\" with a dynamically appearing green square logo composed of four columns of varying heights."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene0(Scene):\n\n    def construct(self):\n        self.wait(1)\n        green1 = '#00a359'\n        green2 = '#00b764'\n        green3 = '#00e17b'\n        green4 = '#00ff8b'\n        l1 = VGroup(Square(1, color=green1, fill_opacity=1), Square(1, color=green1, fill_opacity=1), Square(1, color=green1, fill_opacity=1), Square(1, color=green1, fill_opacity=1)).arrange(DOWN)\n        l2 = VGroup(Square(1, color=green2, fill_opacity=1), Square(1, color=green2, fill_opacity=1), Square(1, color=green2, fill_opacity=1)).arrange(DOWN)\n        l3 = VGroup(Square(1, color=green3, fill_opacity=1), Square(1, color=green3, fill_opacity=1)).arrange(DOWN)\n        l4 = VGroup(Square(1, color=green4, fill_opacity=1)).arrange(DOWN)\n        logo = VGroup(l1, l2, l3, l4).arrange(RIGHT).move_to(ORIGIN + UP).scale(0.8)\n        t1 = MathTex('\\\\text{Davide Radaelli}').scale(2.4)\n        t1.next_to(logo, DOWN)\n        p1 = np.array((l1.get_bottom()[0], t1.get_top()[1] + 0.8, 0))\n        p2 = np.array((l2.get_bottom()[0], t1.get_top()[1] + 0.8, 0))\n        p3 = np.array((l3.get_bottom()[0], t1.get_top()[1] + 0.8, 0))\n        p4 = np.array((l4.get_bottom()[0], t1.get_top()[1] + 0.8, 0))\n        l1.move_to(p1, aligned_edge=DOWN)\n        l2.move_to(p2, aligned_edge=DOWN)\n        l3.move_to(p3, aligned_edge=DOWN)\n        l4.move_to(p4, aligned_edge=DOWN)\n        VGroup(l1, l2, l3, l4, t1).move_to(ORIGIN)\n        self.play(AnimationGroup(Write(t1, run_time=5), Create(l1.submobjects[0], run_time=3), Create(l1.submobjects[1], run_time=3), Create(l1.submobjects[2], run_time=3), Create(l1.submobjects[3], run_time=3), Create(l2.submobjects[0], run_time=3), Create(l2.submobjects[1], run_time=3), Create(l2.submobjects[2], run_time=3), Create(l3.submobjects[0], run_time=3), Create(l3.submobjects[1], run_time=3), Create(l4.submobjects[0], run_time=3), lag_ratio=0.07))\n        self.wait(1.5)\n        self.play(FadeOut(l1, l2, l3, l4, t1))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Present \"Group Theory\" text, then introduce the definition of a group with its components, highlighting associativity and the operation, followed by \"Symmetry\" text and a visual representation, and finally a question mark with an equivalence symbol."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene1(Scene):\n\n    def construct(self):\n        self.wait(1)\n        t1 = MathTex('\\\\text{Group Theory}').scale(2)\n        self.play(Write(t1), run_time=1.5)\n        self.wait(3)\n        t2 = MathTex('\\\\left( ', 'G', ', ', '\\\\circ', '\\\\right)').shift(LEFT * 4).scale(2).shift(UP * 0.5)\n        t3 = MathTex('\\n                     &\\\\to \\\\text{associativity} \\\\\\\\ \\n                     &\\\\to \\\\text{neutral element} \\\\\\\\ \\n                     &\\\\to \\\\text{inverses}').next_to(t2, DOWN, MED_LARGE_BUFF)\n        self.play(t1.animate.shift(UP * 3).scale(0.7))\n        self.wait(2)\n        self.play(Write(t2), Write(t3))\n        self.wait(3)\n        self.play(Indicate(t2[1]))\n        self.wait(1)\n        self.play(Indicate(t2[3]))\n        self.wait(1.5)\n        t1 = TriangleGroup().with_top().with_right().with_left().shift(RIGHT * 4 + DOWN * 0.6).scale(2)\n        t2 = MathTex('\\\\text{Symmetry}').next_to(t1, DOWN)\n        self.wait(3)\n        self.play(Create(t1.get_mobject()), run_time=2)\n        self.wait(0.1)\n        self.play(Create(t1.submobjects[0]), run_time=0.6)\n        self.play(Create(t1.submobjects[1]), run_time=0.6)\n        self.play(Create(t1.submobjects[2]), run_time=0.6)\n        self.wait(0.5)\n        self.play(Write(t2), run_time=2)\n        self.wait(3)\n        a1 = MathTex('\\\\Leftrightarrow', font_size=144)\n        q1 = Text('?', font_size=64)\n        a1.shift(DOWN)\n        self.wait(1)\n        self.play(Write(a1), Write(q1))\n        self.wait(4)"}]}
{"messages": [{"role": "user", "content": "Show a transformation sequence demonstrating the relationship between intuitive and rigorous concepts with corresponding text descriptions and culminating in a symmetry question."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene2(Scene):\n\n    def construct(self):\n        self.wait(1)\n        t1 = MathTex('\\\\text{intuitive} \\\\Rightarrow \\\\text{rigorous}').scale(2)\n        self.play(Write(t1), run_time=2)\n        self.wait(2)\n        self.play(FadeOut(t1))\n        t1 = TriangleGroup().scale(2.7).shift(LEFT * 2.7)\n        t2 = MathTex('&\\\\to \\\\text{top flip} \\\\\\\\', '&\\\\to \\\\text{left flip} \\\\\\\\', '&\\\\to \\\\text{right flip} \\\\\\\\', '&\\\\to \\\\text{rotate 120} \\\\\\\\', '&\\\\to \\\\text{rotate 240} \\\\\\\\', '&\\\\to \\\\text{do nothing}').next_to(t1, RIGHT, 2.7)\n        self.play(Create(t1))\n        self.wait(2)\n        self.play(Write(t2[0]), t1.flip_top())\n        self.wait(1)\n        self.play(Write(t2[1]), t1.flip_left())\n        self.wait(1)\n        self.play(Write(t2[2]), t1.flip_right())\n        self.wait(2)\n        self.play(Write(t2[3]), t1.rotate120())\n        self.wait(1)\n        self.play(Write(t2[4]), t1.rotate240())\n        self.wait(2)\n        self.play(Write(t2[5]), t1.do_nothing())\n        self.wait(1)\n        t3 = MathTex('\\\\text{Symmetry?}').scale(2).shift(UP * 3)\n        self.play(t1.animate.shift(DOWN), t2.animate.shift(DOWN))\n        self.play(Write(t3))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display the word \"duality\" in a gradient and then fade it out."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene3(Scene):\n\n    def construct(self):\n        self.wait(1.5)\n        t1 = Text('duality', gradient=(RED, ORANGE), font_size=142)\n        self.play(Write(t1), run_time=1.5)\n        self.wait(3)\n        self.play(FadeOut(t1))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Demonstrate the concept of intrinsic symmetries and group properties using a rotating and flipping triangle with accompanying text and mathematical expressions."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene4(Scene):\n\n    def construct(self):\n        self.wait(1)\n        t1 = MathTex('\\\\text{adjective}').scale(1.2)\n        t2 = MathTex('\\\\text{verb}').scale(1.2)\n        VGroup(t1, t2).arrange(RIGHT, 6).move_to(ORIGIN).shift(UP * 1.8)\n        t3 = TriangleGroup().with_top().with_right().with_left().scale(1.8).next_to(t1, DOWN, MED_LARGE_BUFF)\n        t4 = Text('\"That triangle is very symmetric\"').scale(0.5).next_to(t3, DOWN, MED_SMALL_BUFF)\n        self.play(Write(t1))\n        self.wait(1)\n        triangle = t3.get_mobject()\n        self.play(Create(triangle), run_time=2)\n        self.play(Create(t3.submobjects[0]), run_time=0.8)\n        self.play(Create(t3.submobjects[1]), run_time=0.8)\n        self.play(Create(t3.submobjects[2]), run_time=0.8)\n        self.wait(2)\n        self.play(Write(t4))\n        self.wait(1)\n        self.play(FadeOut(t4))\n        self.wait(1)\n        total = VGroup(Text('fliptop(x)'), Text('flipright(x)'), Text('flipleft(x)'), Text('rotate120(x)'), Text('rotate240(x)'), Text('donothing(x)')).arrange(DOWN).scale(0.7)\n        total.next_to(t2, DOWN, MED_LARGE_BUFF)\n        b1 = Brace(total, direction=LEFT).scale(1.07)\n        b2 = Brace(total, direction=RIGHT).scale(1.07)\n        self.wait(1)\n        self.play(Write(t2))\n        self.wait(2)\n        self.play(FadeIn(total))\n        self.wait()\n        self.play(FadeIn(b1), FadeIn(b2))\n        self.wait(2)\n        t5 = MathTex('\\\\text{Instrinsic Symmetries}').move_to(t1)\n        middle = np.array((ORIGIN[0], b1.get_left()[1], 0))\n        t6 = MathTex('\\\\Rightarrow').scale(2.7).move_to(middle)\n        t7 = MathTex('\\\\text{Set of Symmetries}').move_to(t2)\n        self.play(ReplacementTransform(t1, t5))\n        self.play(Write(t6))\n        self.play(ReplacementTransform(t2, t7))\n        self.wait(6)\n        self.play(FadeOut(t3, t6, t5, t7, total, b1, b2))\n        self.play(triangle.animate.move_to(ORIGIN + DOWN * 0.7).scale(1.2))\n        self.wait(1)\n        t1 = MathTex('\\\\text{rotate120}', '\\\\circ', '\\\\text{rotate240}', '=', '\\\\text{donothing}').shift(UP * 2.7).scale(1.2)\n        bb1 = SurroundingRectangle(t1[0])\n        bb2 = SurroundingRectangle(t1[2])\n        bb3 = SurroundingRectangle(t1[4])\n        self.play(Write(t1))\n        self.play(triangle.rotate120(), Create(bb1))\n        self.play(triangle.rotate240(), ReplacementTransform(bb1, bb2))\n        self.wait(1)\n        self.play(triangle.do_nothing(), ReplacementTransform(bb2, bb3))\n        self.play(FadeOut(bb3))\n        self.wait(2)\n        t2 = MathTex('\\\\text{fliptop}', '\\\\circ', '\\\\text{flipright}', '\\\\circ', '\\\\text{rotate240}', '=', '\\\\text{rotate120}').shift(UP * 2.7).scale(1.2)\n        bb1 = SurroundingRectangle(t2[0])\n        bb2 = SurroundingRectangle(t2[2])\n        bb3 = SurroundingRectangle(t2[4])\n        bb4 = SurroundingRectangle(t2[6])\n        self.play(ReplacementTransform(t1, t2))\n        self.wait(1)\n        self.play(triangle.flip_top(), Create(bb1))\n        self.play(triangle.flip_right(), ReplacementTransform(bb1, bb2))\n        self.play(triangle.rotate240(), ReplacementTransform(bb2, bb3))\n        self.wait(1)\n        self.play(triangle.rotate120(), ReplacementTransform(bb3, bb4))\n        self.wait(1)\n        self.play(FadeOut(bb4))\n        self.wait(2)\n        t1 = MathTex('\\\\left( \\\\text{symmetries, composition} \\\\right) \\\\text{ is a group}').move_to(t2).scale(1.2)\n        self.play(ReplacementTransform(t2, t1), triangle.animate.shift(DOWN * 0.6))\n        self.wait(1)\n        t21 = MathTex('1.')\n        t2 = MathTex('\\\\left( a\\\\circ b \\\\right)\\\\circ c = a \\\\circ \\\\left( b\\\\circ c \\\\right)')\n        t2 = VGroup(t21, t2)\n        t2.arrange(RIGHT, 0.5)\n        t2.next_to(t1, DOWN)\n        t3 = MathTex('\\\\text{neutral} \\\\circ a = a')\n        t31 = MathTex('2.')\n        t3 = VGroup(t31, t3)\n        t3.arrange(RIGHT, 0.5)\n        t3.next_to(t1, DOWN)\n        t4 = MathTex('a \\\\circ a^{-1} = \\\\text{neutral}')\n        t41 = MathTex('3.')\n        t4 = VGroup(t41, t4)\n        t4.arrange(RIGHT, 0.5)\n        t4.next_to(t1, DOWN)\n        self.play(Write(t2))\n        self.play(triangle.flip_right())\n        self.play(triangle.rotate240())\n        self.play(triangle.do_nothing())\n        self.play(triangle.flip_left())\n        self.wait(2)\n        self.play(ReplacementTransform(t2, t3))\n        self.wait(1)\n        self.play(triangle.do_nothing(), run_time=3)\n        self.wait(2)\n        self.play(ReplacementTransform(t3, t4))\n        self.play(triangle.rotate120())\n        self.play(triangle.rotate240())\n        self.wait(1)\n        self.play(triangle.flip_top())\n        self.play(triangle.flip_top())\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display various mathematical concepts like rings, shapes, manifolds, functions, numbers, vector spaces, topological spaces, groups, and sets with accompanying text, fading them in sequentially."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene5(Scene):\n\n    def construct(self):\n        self.wait(2)\n        t1 = MathTex('\\\\left( \\\\text{symmetries, composition} \\\\right)').scale(1.2)\n        t1.shift(UP * 3 + LEFT * 3)\n        self.play(Write(t1))\n        self.wait(10)\n        rings_display = MathTex('\\\\left( \\\\mathbb{Z}, + \\\\right)').scale(1.5)\n        rings_text = MathTex('\\\\text{rings}')\n        rings = VGroup(rings_display, rings_text)\n        rings.arrange(DOWN, 0.2)\n        square = Square()\n        triangle = Triangle()\n        circle = Circle()\n        shapes_display = VGroup(square, VGroup(triangle, circle).arrange(DOWN, 0.5))\n        shapes_display.arrange(RIGHT, 0.5).scale(0.4)\n        shapes_text = MathTex('\\\\text{shapes}')\n        shapes = VGroup(shapes_display, shapes_text)\n        shapes.arrange(DOWN, 0.2)\n        torus = Torus().rotate_about_origin(60 * DEGREES, RIGHT)\n        manifolds_display = VGroup(torus).scale(0.3)\n        manifold_text = MathTex('\\\\text{manifolds}')\n        manifolds = VGroup(manifolds_display, manifold_text)\n        manifolds.arrange(DOWN, 0.2)\n        axes = Axes(x_range=[-5, 5.3, 1], y_range=[-1.5, 1.5, 1], x_length=5, axis_config={'color': WHITE})\n        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)\n        functions_display = VGroup(axes, sin_graph).scale(0.45)\n        functions_text = MathTex('\\\\text{functions}')\n        functions = VGroup(functions_display, functions_text)\n        functions.arrange(DOWN, 0.2)\n        numbers_display = MathTex('\\\\left( \\\\mathbb{R}, + \\\\right)').scale(1.5)\n        numbers_text = MathTex('\\\\text{numbers}')\n        numbers = VGroup(numbers_display, numbers_text)\n        numbers.arrange(DOWN, 0.2)\n        vectorspaces_display = MathTex('\\\\left( V, +, \\\\cdot  \\\\right)').scale(1.5)\n        vectorspaces_text = MathTex('\\\\text{vector}')\n        vectorspaces_text2 = MathTex('\\\\text{spaces}')\n        vectorspaces = VGroup(vectorspaces_display, vectorspaces_text, vectorspaces_text2)\n        vectorspaces.arrange(DOWN, 0.2)\n        vectorspaces_text.shift(LEFT * 0.3)\n        vectorspaces_text2.shift(RIGHT * 0.1)\n        topo_display = MathTex('\\\\left( X, \\\\mathcal{O} \\\\right)').scale(1.5)\n        topo_text = MathTex('\\\\text{topological}')\n        topo_text2 = MathTex('\\\\text{spaces}')\n        topo = VGroup(topo_display, topo_text, topo_text2)\n        topo.arrange(DOWN, 0.2)\n        groups_display = MathTex('\\\\left(G, + \\\\right)').scale(1.5)\n        groups_text = MathTex('\\\\text{groups}')\n        groups = VGroup(groups_display, groups_text)\n        groups.arrange(DOWN, 0.2)\n        sets_display = MathTex('\\\\left\\\\{ 1, 2, 3 \\\\right\\\\}').scale(1.5)\n        sets_text = MathTex('\\\\text{sets}')\n        sets = VGroup(sets_display, sets_text)\n        sets.arrange(DOWN, 0.2)\n        rings.shift(UP * 0.8, LEFT * 5.3)\n        shapes.shift(LEFT * 2.8)\n        manifolds.shift(UP * 0.5)\n        functions.shift(UP * 2 + RIGHT * 2.9)\n        numbers.shift(UP * 2 + RIGHT * 5.5)\n        vectorspaces.shift(LEFT * 5 + DOWN * 2.4)\n        topo.shift(DOWN * 2 + RIGHT * 5)\n        groups.shift(DOWN * 2.2 + RIGHT * 2.2)\n        sets.shift(DOWN * 2.5 + LEFT * 1.4)\n        self.play(FadeIn(functions), run_time=1)\n        self.wait(0.3)\n        self.play(FadeIn(sets), run_time=1)\n        self.wait(0.3)\n        self.play(FadeIn(shapes), run_time=1)\n        self.wait(0.3)\n        self.play(FadeIn(numbers), run_time=1)\n        self.wait(2)\n        self.play(FadeIn(rings), run_time=1)\n        self.wait(0.3)\n        self.play(FadeIn(vectorspaces), run_time=1)\n        self.wait(0.3)\n        self.play(FadeIn(manifolds), run_time=1)\n        self.wait(0.3)\n        self.play(FadeIn(topo), run_time=1)\n        self.wait(0.3)\n        self.play(FadeIn(groups), run_time=1)\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Illustrate set transformations and permutations with arrows and bounding boxes, culminating in a demonstration of set composition."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene6(Scene):\n\n    def construct(self):\n        self.wait(2)\n        t1 = MathTex('\\\\left\\\\{ 1, 2, 3, 4 \\\\right\\\\}').scale(1.5)\n        t1.shift(UP * 2.8 + LEFT * 3.5)\n        t2 = VGroup(MathTex('1\\\\to 2'), MathTex('2\\\\to 1'), MathTex('3\\\\to 3'), MathTex('4\\\\to 4')).arrange(DOWN, 0.4)\n        rect = SurroundingRectangle(t2, color=WHITE, buff=MED_LARGE_BUFF)\n        t2.add(SurroundingRectangle(t2, color=WHITE, buff=MED_LARGE_BUFF))\n        t3 = VGroup(MathTex('1\\\\to 1'), MathTex('2\\\\to 2'), MathTex('3\\\\to 3'), MathTex('4\\\\to 3')).arrange(DOWN, 0.4)\n        t3.add(SurroundingRectangle(t3, color=WHITE, buff=MED_LARGE_BUFF))\n        t4 = MathTex('\\\\left\\\\{ 2, 1, 3, 4 \\\\right\\\\}').scale(1.5)\n        t4.shift(DOWN * 2.8 + RIGHT * 3.5)\n        bb0 = SurroundingRectangle(t1, color=GREEN, buff=SMALL_BUFF)\n        bb1 = SurroundingRectangle(t4, color=GREEN, buff=SMALL_BUFF)\n        t5 = MathTex('\\\\left\\\\{ 1, 2, 3 \\\\right\\\\}').scale(1.5)\n        t5.shift(DOWN * 2.8 + RIGHT * 3.5)\n        p1 = t1.get_bottom() + DOWN * 0.2\n        p2 = np.array((t1.get_bottom()[0], t2.get_left()[1], 0))\n        p3 = t2.get_left()\n        p4 = t2.get_right()\n        p5 = np.array((t4.get_top()[0], t2.get_right()[1], 0))\n        p6 = t4.get_top() + UP * 0.2\n        arrow1 = VGroup(Line(p1, p2, stroke_width=4), Arrow(p2, p3, buff=0, stroke_width=4))\n        arrow2 = VGroup(Line(p4, p5, stroke_width=4), Arrow(p5, p6, buff=0, stroke_width=4))\n        self.play(Write(t1))\n        self.wait(12)\n        self.play(FadeIn(arrow1))\n        self.play(FadeIn(t2))\n        self.wait(6)\n        self.play(FadeIn(arrow2))\n        self.play(Write(t4))\n        self.wait(10)\n        self.play(Create(bb1), Create(bb0))\n        self.wait(2)\n        self.add(rect)\n        self.play(FadeOut(bb0, bb1, t2))\n        self.wait(4)\n        self.play(FadeIn(t3))\n        self.remove(rect)\n        self.wait(1)\n        self.play(ReplacementTransform(t4, t5))\n        bb2 = SurroundingRectangle(t1, color=RED, buff=SMALL_BUFF)\n        bb3 = SurroundingRectangle(t5, color=RED, buff=SMALL_BUFF)\n        self.wait()\n        self.play(Create(bb2), Create(bb3))\n        self.wait(2)\n        self.play(FadeOut(bb2, bb3))\n        self.wait(3)\n        self.play(FadeOut(arrow1, arrow2, t1, t5))\n        b1 = VGroup(MathTex('1\\\\to 4'), MathTex('2\\\\to 3'), MathTex('3\\\\to 2'), MathTex('4\\\\to 1')).arrange(DOWN, 0.4)\n        b1.add(SurroundingRectangle(b1, color=WHITE, buff=MED_LARGE_BUFF))\n        b1.next_to(t3, RIGHT, MED_SMALL_BUFF)\n        b2 = VGroup(MathTex('1\\\\to 1'), MathTex('2\\\\to 2'), MathTex('3\\\\to 3'), MathTex('4\\\\to 4')).arrange(DOWN, 0.4)\n        b2.add(SurroundingRectangle(b2, color=WHITE, buff=MED_LARGE_BUFF))\n        b2.next_to(t3, LEFT, MED_SMALL_BUFF)\n        dotdot1 = MathTex('...').scale(2).next_to(b1, RIGHT, buff=LARGE_BUFF, aligned_edge=RIGHT)\n        dotdot2 = MathTex('...').scale(2).next_to(b2, LEFT, buff=LARGE_BUFF, aligned_edge=LEFT)\n        t5 = MathTex('\\\\text{Permutations of 4 elements } S_4').scale(1.3).shift(UP * 3)\n        self.wait()\n        self.play(ReplacementTransform(t3, t2))\n        self.play(FadeIn(b1))\n        self.play(FadeIn(b2))\n        self.play(Write(dotdot1), Write(dotdot2))\n        self.wait(2)\n        self.play(Write(t5))\n        self.wait(6)\n        symmetries = VGroup(b1, t2, b2, dotdot1)\n        self.play(symmetries.animate.scale(0.5).shift(LEFT * 1.5), FadeOut(dotdot2))\n        b1 = Brace(symmetries, LEFT).scale(1.2)\n        comp = MathTex('\\\\circ').scale(2).next_to(symmetries, RIGHT, buff=LARGE_BUFF)\n        comma = MathTex(',').scale(2)\n        comma.move_to((symmetries.get_right() + comp.get_left()) / 2)\n        comma.shift(DOWN * 0.3)\n        b2 = Brace(symmetries, RIGHT).scale(1.2)\n        b2.next_to(comp, RIGHT)\n        self.play(FadeIn(b1, comma, comp, b2))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Show a sequence of mathematical expressions related to symmetry and then reveal a star symbol."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene7(Scene):\n\n    def construct(self):\n        self.wait(8)\n        t1 = MathTex('\\\\left( G, \\\\circ \\\\right) \\\\Rightarrow', '\\\\text{symmetry?}').scale(1.2)\n        t2 = MathTex('\\\\left( \\\\mathbb{R}, + \\\\right) \\\\Rightarrow', '\\\\text{symmetry?}').scale(1.2)\n        t3 = MathTex('\\\\left( \\\\mathbb{R}, + \\\\right) \\\\Rightarrow', '\\\\text{(symmetry, composition)}').scale(1.2)\n        t4 = MathTex('\\\\Rightarrow ', '\\\\bigstar').scale(1.2)\n        t4[1].become(Triangle().move_to(t4[1]).scale(0.7).shift(RIGHT * 0.5))\n        t4.next_to(t3, RIGHT, buff=-0.5)\n        self.play(Write(t1))\n        self.wait(6)\n        self.play(ReplacementTransform(t1, t2))\n        self.wait(12)\n        self.play(ReplacementTransform(t2, t3))\n        self.wait(12)\n        self.play(t3.animate.shift(LEFT), FadeIn(t4))\n        self.wait(8)"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of a real number being an element of the set of real numbers with addition, showing a specific example with translation, then demonstrating a set of translation functions and their composition."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene8(Scene):\n\n    def construct(self):\n        self.wait(3)\n        t2 = MathTex('a\\\\in \\\\mathbb{R}').scale(1.4)\n        t3 = MathTex('\\\\left( \\\\mathbb{R}, + \\\\right)').scale(1.4)\n        t4 = MathTex('t_a(x)=a+x').scale(1.4)\n        t2.shift(LEFT * 3.5)\n        t3.shift(UP * 1.5)\n        t4.shift(RIGHT * 3.5)\n        a1 = Arrow(start=t2.get_right(), end=t4.get_left(), stroke_width=4, color=BLUE)\n        a2 = Line(start=t3.get_bottom(), end=[t3.get_bottom()[0], a1.get_right()[1], 0], color=BLUE)\n        t2.shift(LEFT * 0.5)\n        t3.shift(UP * 0.5)\n        t4.shift(RIGHT * 0.5)\n        total = VGroup(t2, t3, t4, a1, a2)\n        total.move_to(ORIGIN)\n        self.play(Write(t2))\n        self.wait()\n        self.play(Write(t3))\n        self.play(FadeIn(a1, a2))\n        self.wait(2)\n        self.play(Write(t4))\n        self.wait(7)\n        t2n = MathTex('3\\\\in \\\\mathbb{R}').scale(1.4).move_to(t2)\n        t4n = MathTex('t_3(x)=3+x').scale(1.4).move_to(t4)\n        self.play(FadeOut(t2, t4))\n        self.play(Write(t2n))\n        self.play(Write(t4n))\n        self.wait(5)\n        self.play(FadeOut(t2n, t4n, a1, a2, t3))\n        l1 = MathTex('t_3(x)=3+x').scale(1.4)\n        l2 = MathTex('t_8(x)=8+x').scale(1.4)\n        dotdot = MathTex('...')\n        l3 = MathTex('t_5(x)=5+x').scale(1.4)\n        composition = MathTex('\\\\text{composition}').scale(1.5)\n        comma = MathTex(',').scale(2)\n        ts = VGroup(l1, l2, dotdot, l3)\n        ts.arrange(DOWN, 0.2)\n        composition.next_to(ts, RIGHT, 1)\n        b1 = Brace(ts, LEFT).scale(1.1)\n        b2 = Brace(ts, RIGHT).scale(1.1)\n        b2.next_to(composition, RIGHT)\n        comma.move_to((ts.get_right() + composition.get_left()) / 2)\n        comma.shift(DOWN * 0.3)\n        setoft = VGroup(b1, ts, comma, composition, b2)\n        setoft.move_to(ORIGIN)\n        symmetry = MathTex('\\\\text{symmetries}').scale(1.5).move_to(ts)\n        self.play(Write(l1))\n        self.play(Write(l2))\n        self.play(Write(dotdot), Write(l3))\n        self.play(FadeIn(b1, b2, comma, composition))\n        self.wait(5.5)\n        self.play(ReplacementTransform(ts, symmetry), comma.animate.move_to((symmetry.get_right() + composition.get_left()) / 2 + DOWN * 0.3))\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Animate a number line that shifts and displays arrows and corresponding mathematical expressions to illustrate transformations."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene9(Scene):\n\n    def construct(self):\n        self.wait(2)\n        line = NumberLine(x_range=(-15, 15), include_numbers=True, color=BLUE).scale(1.2).shift(UP)\n        shadow_line = line.copy().shift(DOWN * 2).fade(0.5)\n        zero_point = line.number_to_point(0)\n        num_point = line.number_to_point(3)\n        arrow = Arrow(zero_point, num_point, stroke_width=2, buff=0, color=GREEN)\n        arrow.shift(MED_LARGE_BUFF * UP)\n        self.play(Create(line), run_time=3)\n        self.wait(1)\n        self.play(line.animate.shift(0.5 * RIGHT), run_time=1)\n        self.play(line.animate.shift(1 * LEFT), run_time=1)\n        self.play(line.animate.shift(0.5 * RIGHT), run_time=1)\n        self.wait(2)\n        self.play(FadeIn(shadow_line))\n        t1 = MathTex('t_3(x)=3+x').scale(1.4).shift(UP * 3)\n        t2 = MathTex('t_2(x)=2+x').scale(1.4).shift(UP * 3)\n        t3 = MathTex('t_5(x)=5+x').scale(1.4).shift(UP * 3)\n        self.play(Create(arrow), FadeIn(t1))\n        self.play(line.animate.shift(num_point - zero_point), run_time=2)\n        self.play(FadeOut(arrow), FadeOut(t1))\n        self.wait(4)\n        arrow2 = Arrow(line.number_to_point(0), line.number_to_point(2), stroke_width=2, buff=0, color=GREEN)\n        arrow2.shift(MED_LARGE_BUFF * UP)\n        self.play(Create(arrow2), FadeIn(t2))\n        self.play(line.animate.shift(line.number_to_point(2) - line.number_to_point(0)), run_time=2)\n        self.play(FadeOut(arrow2), FadeOut(t2))\n        self.wait()\n        shadow_arrow = Arrow(shadow_line.number_to_point(0), shadow_line.number_to_point(5), stroke_width=2, buff=0, color=GREEN)\n        shadow_arrow.shift(MED_LARGE_BUFF * UP)\n        self.play(Create(shadow_arrow), FadeIn(t3))\n        self.play(shadow_line.animate.shift(shadow_line.number_to_point(5) - shadow_line.number_to_point(0)), run_time=3)\n        self.play(FadeOut(shadow_arrow), FadeOut(t3))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display mathematical expressions, a number line with green arrows, and animate the number line by shifting, scaling, and rotating it."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene10(Scene):\n\n    def construct(self):\n        self.wait()\n        t3 = MathTex('\\\\text{(symmetry, composition)} \\\\Rightarrow ', '\\\\bigstar').scale(1.2)\n        t3[1].become(Triangle().move_to(t3[1]).scale(0.7).shift(RIGHT * 0.5))\n        t3.shift(LEFT * 0.5)\n        self.play(Write(t3))\n        self.wait(4)\n        self.play(FadeOut(t3))\n        self.wait()\n        t4 = MathTex('\\\\Big\\\\{ \\\\mathbb{R}, \\\\mathcal{O}, \\\\mathscr{A}, \\\\text{frame field} \\\\Big\\\\}').scale(1.2)\n        self.play(Write(t4))\n        self.wait(16)\n        line = NumberLine(x_range=(-15, 15))\n        for x in range(-15, 14):\n            current_num = x\n            next_num = x + 1\n            arrow = Arrow(line.number_to_point(current_num), line.number_to_point(next_num), stroke_width=2, buff=0, color=GREEN)\n            arrow.shift(MED_LARGE_BUFF * UP)\n            arrow.scale(0.9)\n            line.add(arrow)\n        shadow_line = line.copy().shift(DOWN * 2).fade(0.5)\n        self.play(t4.animate.shift(UP * 2))\n        self.play(FadeIn(line), run_time=1)\n        self.play(FadeIn(shadow_line))\n        self.wait(8)\n        self.play(line.animate.shift(RIGHT), run_time=2)\n        self.play(line.animate.shift(LEFT), run_time=2)\n        self.wait()\n        self.play(line.animate.scale(1.2), run_time=2)\n        self.play(line.animate.scale(0.8333333333), run_time=2)\n        self.wait()\n        self.play(line.animate.rotate(180 * DEGREES, UP, about_point=line.number_to_point(0)), run_time=2)\n        self.play(line.animate.rotate(180 * DEGREES, UP, about_point=line.number_to_point(0)), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display text \"intuitive\" and \"rigorous\" with an arrow between them, highlighting each word multiple times."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene11(Scene):\n\n    def construct(self):\n        self.wait()\n        t3 = MathTex('\\\\text{(symmetry, composition)} \\\\Rightarrow ', '\\\\bigstar').scale(1.2)\n        t3[1].become(Triangle().move_to(t3[1]).scale(0.7).shift(RIGHT * 0.5))\n        t3.shift(LEFT * 0.5)\n        bb = SurroundingRectangle(t3, color=GREEN, buff=MED_SMALL_BUFF)\n        self.play(Write(t3))\n        self.play(Create(bb), run_time=2)\n        self.play(Uncreate(bb), run_time=2)\n        self.wait(4)\n        self.play(FadeOut(t3, bb))\n        self.wait(2)\n        text = MathTex('\\\\text{intuitive}', '\\\\Longleftrightarrow', '\\\\text{rigorous}').scale(1.5)\n        self.play(Write(text))\n        self.wait(4)\n        self.play(Indicate(text[0]))\n        self.play(Indicate(text[2]))\n        self.wait(7)\n        self.play(Indicate(text[2]))\n        self.play(Indicate(text[0]))\n        self.wait(8)"}]}
{"messages": [{"role": "user", "content": "Animate a breadth-first search on a graph, showing the queue and paths dynamically, and finally highlighting the shortest path."}, {"role": "assistant", "content": "from manim import *\n\nclass LabeledModifiedGraph(Scene):\n\n    def change_queue(self, graph, l):\n        l = '\\n'.join(l)\n        queue2 = Text(f'Queue:\\n{l}', font_size=24)\n        queue2.next_to(graph, RIGHT)\n        queue2.to_edge(UP)\n        queue2.shift(DOWN)\n        self.play(FadeOut(self.queue), FadeIn(queue2))\n        self.queue = queue2\n        self.wait(0.1)\n\n    def change_paths(self, graph, text):\n        paths2 = Text('Paths:\\n' + text, font_size=24)\n        paths2.next_to(graph, RIGHT)\n        paths2.to_edge(UP)\n        paths2.shift(3 * DOWN)\n        self.play(FadeOut(self.paths), FadeIn(paths2))\n        self.paths = paths2\n        self.wait(0.1)\n\n    def construct(self):\n        vertices = ['S', 2, 3, 4, 5, 6, 7, 'E']\n        edges = [('S', 2), ('S', 4), (2, 3), (2, 7), (2, 'E'), (3, 4), (3, 5), (3, 6), (3, 7), (3, 'E'), (5, 'E'), (6, 7), (6, 'E')]\n        graph = Graph(vertices, edges, layout_scale=2.5, labels=True, vertex_config={'S': {'fill_color': RED}, 2: {'fill_color': RED}, 'E': {'fill_color': RED}}, edge_config={('S', 2): {'stroke_color': RED}, (2, 'E'): {'stroke_color': RED}})\n        self.add(graph)\n        self.wait(1)\n        graph.generate_target()\n        graph.target.move_to(3 * LEFT)\n        self.play(MoveToTarget(graph))\n        self.wait(1)\n        title1 = Text('Fixed length search')\n        title1.to_edge(UP)\n        self.play(Write(title1))\n        self.wait(0.5)\n        title2 = Text('Fixed (5) length search')\n        title2.to_edge(UP)\n        self.play(Transform(title1, title2))\n        distances = Text('Distances to S:\\n2 - 1\\n3 - 2\\n4 - 1\\n5 - 3\\n6 - 3\\n7 - 3\\nE - 2', font_size=24)\n        distances.shift(UP + 1.5 * RIGHT)\n        self.play(Write(distances))\n        self.wait(2)\n        predecessors = Text('Precessors from the start:\\nS \u27f6 2\\n2 \u27f6 3\\nS \u27f6 4\\n3 \u27f6 5\\n3 \u27f6 6\\n2 \u27f6 7\\n2 \u27f6 E\\n', font_size=24)\n        predecessors.next_to(distances, DOWN)\n        predecessors.shift(0.9 * RIGHT)\n        self.play(Write(predecessors))\n        self.wait(2)\n        self.play(Uncreate(distances))\n        self.play(Uncreate(predecessors))\n        self.queue = Text('Queue:\\nS', font_size=24)\n        self.queue.next_to(graph, RIGHT)\n        self.queue.to_edge(UP)\n        self.queue.shift(DOWN)\n        self.play(Write(self.queue))\n        self.wait(1)\n        self.paths = Text('Paths:\\nS \u27f6 2', font_size=24)\n        self.paths.next_to(graph, RIGHT)\n        self.paths.to_edge(UP)\n        self.paths.shift(3 * DOWN)\n        self.play(Write(self.paths))\n        self.change_queue(graph, ['S', '2'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4')\n        self.change_queue(graph, ['S', '2', '4'])\n        self.change_queue(graph, ['2', '4'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4\\nS \u27f6 2 \u27f6 3')\n        self.change_queue(graph, ['2', '4', '3'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4\\nS \u27f6 2 \u27f6 3\\nS \u27f6 2 \u27f6 7')\n        self.change_queue(graph, ['2', '4', '3', '7'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4\\nS \u27f6 2 \u27f6 3\\nS \u27f6 2 \u27f6 7\\nS \u27f6 2 \u27f6 E')\n        self.change_queue(graph, ['4', '3', '7'])\n        self.change_queue(graph, ['3', '7'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4\\nS \u27f6 2 \u27f6 3\\nS \u27f6 2 \u27f6 3 \u27f6 5\\nS \u27f6 2 \u27f6 7\\nS \u27f6 2 \u27f6 E')\n        self.change_queue(graph, ['3', '7', '5'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4\\nS \u27f6 2 \u27f6 3\\nS \u27f6 2 \u27f6 3 \u27f6 5\\nS \u27f6 2 \u27f6 3 \u27f6 6\\nS \u27f6 2 \u27f6 7\\nS \u27f6 2 \u27f6 E')\n        self.change_queue(graph, ['3', '7', '5', '6'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4\\nS \u27f6 2 \u27f6 3\\nS \u27f6 2 \u27f6 3 \u27f6 5\\nS \u27f6 2 \u27f6 3 \u27f6 6\\nS \u27f6 2 \u27f6 3 \u27f6 7\\nS \u27f6 2 \u27f6 E')\n        self.change_queue(graph, ['3', '7', '5', '6', '7'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4\\nS \u27f6 2 \u27f6 3\\nS \u27f6 2 \u27f6 3 \u27f6 5\\nS \u27f6 2 \u27f6 3 \u27f6 6\\nS \u27f6 2 \u27f6 3 \u27f6 7\\nS \u27f6 2 \u27f6 3 \u27f6 E')\n        self.change_queue(graph, ['7', '5', '6', '7'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4\\nS \u27f6 2 \u27f6 3\\nS \u27f6 2 \u27f6 3 \u27f6 5\\nS \u27f6 2 \u27f6 3 \u27f6 7 \u27f6 6\\nS \u27f6 2 \u27f6 3 \u27f6 7\\nS \u27f6 2 \u27f6 3 \u27f6 E')\n        self.change_queue(graph, ['5', '6', '7'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4\\nS \u27f6 2 \u27f6 3\\nS \u27f6 2 \u27f6 3 \u27f6 5\\nS \u27f6 2 \u27f6 3 \u27f6 7 \u27f6 6\\nS \u27f6 2 \u27f6 3 \u27f6 7\\nS \u27f6 2 \u27f6 3 \u27f6 5 \u27f6 E')\n        self.change_queue(graph, ['6', '7'])\n        self.change_paths(graph, 'S \u27f6 2\\nS \u27f6 4\\nS \u27f6 2 \u27f6 3\\nS \u27f6 2 \u27f6 3 \u27f6 5\\nS \u27f6 2 \u27f6 3 \u27f6 7 \u27f6 6\\nS \u27f6 2 \u27f6 3 \u27f6 7\\nS \u27f6 2 \u27f6 3 \u27f6 7 \u27f6 6 \u27f6 E')\n        self.wait(1)\n        graph2 = Graph(vertices, edges, layout_scale=2.5, labels=True, vertex_config={'S': {'fill_color': RED}, 2: {'fill_color': RED}, 3: {'fill_color': RED}, 7: {'fill_color': RED}, 6: {'fill_color': RED}, 'E': {'fill_color': RED}}, edge_config={('S', 2): {'stroke_color': RED}, (2, 3): {'stroke_color': RED}, (3, 7): {'stroke_color': RED}, (7, 6): {'stroke_color': RED}, (6, 'E'): {'stroke_color': RED}})\n        graph2.shift(3 * LEFT)\n        self.play(ReplacementTransform(graph, graph2))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate the Fourier transform of a loaded path, visualizing the decomposition into complex exponentials with rotating vectors and their cumulative path."}, {"role": "assistant", "content": "import math\nimport sys\nimport os\nimport json\nimport cv2\nfrom matplotlib import pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nfrom matplotlib.widgets import Slider, Button, RangeSlider, RadioButtons, TextBox\nfrom scipy.spatial import Delaunay\nfrom scipy.fftpack import fft\nimport heapq\nimport threading\nimport tkinter\nimport tkinter as tk\nfrom tkinter import ttk\nfrom tkinter.filedialog import askopenfilename\nfrom functools import partial\nimport copy\nfrom manim import *\nfrom pathlib import Path\n\nclass FourierRender(Scene):\n\n    def construct(self):\n        self.init()\n        path = self.dft_path()\n        factor = 6 / np.max(path[:, 1])\n        x_Offset = -(np.sum(path[:, 0] * factor) / len(path))\n        y_Offset = -3\n        fx = fft(path[:, 0] * factor + x_Offset + (path[:, 1] * factor + y_Offset) * 1j)\n        fr = np.arange(len(fx))\n        N = len(fx)\n        srot = np.flipud(np.argsort(np.abs(fx)))\n        fx = fx[srot]\n        fr = fr[srot]\n        rf = np.array([np.dot(fx, [np.exp(1j * 2 * np.pi * n * k / N) for k in fr]) / N for n in range(N)])\n        print('path\u8def\u5f84')\n        print(path[:20, :])\n        print('fft\u8def\u5f84')\n        print(rf[:20])\n        print(fx.ndim, '\\t', fx.shape)\n        print(fx[0])\n        factor = 6 / np.max(path[:, 1])\n        x_Offset = -(np.sum(path[:, 0] * factor) / len(path))\n        y_Offset = -3\n        c1 = np.array([factor * x + x_Offset + (factor * y + y_Offset) * 1j for x, y in path])\n        print(c1.size)\n        self.dotxyz = [0, 0, 0]\n        fre = np.linspace(-self.frequency_range, self.frequency_range, 2 * self.frequency_range + 1)\n        kwr = np.array([np.dot(c1, [np.exp(-2 * np.pi * n * t * 1j) / c1.size for t in np.linspace(0, 1, c1.size + 1)[:-1]]) for n in fre])\n        srot = np.flipud(np.argsort(np.abs(kwr)))\n        kwrs = []\n        fres = []\n        for n in srot:\n            kwrs.append(kwr[n])\n            fres.append(fre[n])\n        kwr = np.array(kwrs)\n        fre = np.array(fres)\n\n        def guij(dec):\n            if self.model:\n                lisc = np.dot(fx, [np.exp(1j * 2 * np.pi * dec * k / N) for k in fr]) / N\n                return [lisc.real, lisc.imag, 0]\n            else:\n                t = dec / self.frame_length\n                lisc = np.dot(kwr, [np.exp(2 * np.pi * fre[n] * t * 1j) for n in range(fre.size)])\n                return [lisc.real, lisc.imag, 0]\n\n        def guij1(dec):\n            lisc = np.dot(fx, [np.exp(1j * 2 * np.pi * dec * k / N) for k in fr]) / N\n            return [lisc.real, lisc.imag, 0]\n\n        def lincirs(dec):\n            if self.model:\n                lisc = fx * np.array([np.exp(1j * 2 * np.pi * dec * k / N) for k in fr]) / N\n                xyz = [0, 0, 0]\n                xyz1 = [0, 0, 0]\n                vg = VGroup()\n                for n in range(len(fr)):\n                    xyz[0] += lisc[n].real\n                    xyz[1] += lisc[n].imag\n                    if xyz[0] != xyz1[0] and xyz[1] != xyz1[1]:\n                        if np.abs(fx[n]) / N > 0.01 and n > 0:\n                            vg.add(Circle(np.abs(fx[n]) / N, stroke_width=2).move_to(xyz1))\n                        vg.add(Line(xyz1, xyz, color=YELLOW, stroke_width=2))\n                    xyz1[0] = xyz[0]\n                    xyz1[1] = xyz[1]\n                self.dotxyz = copy.deepcopy(xyz)\n                return vg\n            else:\n                t = dec / self.frame_length\n                lisc = kwr * np.array([np.exp(2 * np.pi * fre[n] * t * 1j) for n in range(fre.size)])\n                xyz = [0, 0, 0]\n                xyz1 = [0, 0, 0]\n                vg = VGroup()\n                for n in range(fre.size):\n                    xyz[0] += lisc[n].real\n                    xyz[1] += lisc[n].imag\n                    if xyz[0] != xyz1[0] or xyz[1] != xyz1[1]:\n                        if np.abs(kwr[n]) > 0.1 and n > 0:\n                            vg.add(Circle(np.abs(kwr[n]), stroke_width=2).move_to(xyz1))\n                        vg.add(Line(xyz1, xyz, color=YELLOW, stroke_width=2))\n                    xyz1[0] = xyz[0]\n                    xyz1[1] = xyz[1]\n                self.dotxyz = copy.deepcopy(xyz)\n                return vg\n\n        def lincirs1(dec):\n            lisc = fx * np.array([np.exp(1j * 2 * np.pi * dec * k / N) for k in fr]) / N\n            xyz = [0, 0, 0]\n            xyz1 = [0, 0, 0]\n            vg = VGroup()\n            for n in range(len(fr)):\n                xyz[0] += lisc[n].real\n                xyz[1] += lisc[n].imag\n                if xyz[0] != xyz1[0] and xyz[1] != xyz1[1]:\n                    if np.abs(fx[n]) / N > 0.1 and n > 0:\n                        vg.add(Circle(np.abs(fx[n]) / N, stroke_width=2).move_to(xyz1))\n                    vg.add(Line(xyz1, xyz, color=YELLOW, stroke_width=2))\n                xyz1[0] = xyz[0]\n                xyz1[1] = xyz[1]\n            self.dotxyz = copy.deepcopy(xyz)\n            return vg\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-3, 3, 1], x_length=6, y_length=6, axis_config={'include_numbers': False, 'close_new_points': False}, tips=False, x_axis_config={'stroke_color': BLACK, 'font_size': 12, 'tick_size': 0.05}, y_axis_config={'stroke_color': BLACK, 'font_size': 12, 'tick_size': 0.05})\n        decimal = DecimalNumber(-1, color=BLACK).move_to([-6, 0, 0])\n        dot = Dot(radius=0.01).move_to(guij(0))\n        pdot1 = TracedPath(dot.get_center)\n        alpha = ValueTracker(0)\n        decimal.add_updater(lambda d: d.set_value(d.get_value() + 1))\n        dot.add_updater(lambda d: d.move_to(self.dotxyz))\n        Gcirlin = always_redraw(lambda: lincirs(decimal.get_value()))\n        self.add(axes, decimal, Gcirlin, pdot1, dot)\n        self.play(alpha.animate.set_value(1), rate_func=linear, run_time=self.get_time())\n\n    def dft_path(self):\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        file_name = 'points.npy'\n        file_path = os.path.join(current_dir, file_name)\n        loaded_point = np.load(file_path)\n        ncontour = loaded_point.copy()\n        max_xy = 1 / np.max((np.max(ncontour[:, 0]), np.max(ncontour[:, 1])))\n        ncontour = ncontour.astype(np.float64)\n        ncontour *= max_xy\n        return ncontour\n\n    def init(self):\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        config_file = os.path.join(current_dir, 'config.json')\n        with open(config_file, 'r') as f:\n            loaded_config = json.load(f)\n        self.length = loaded_config['length']\n        self.frame_rate = loaded_config['frame_rate']\n        self.frequency_range = loaded_config['frequency_range']\n        self.frame_length = loaded_config['frame_length']\n        self.model = loaded_config['model']\n\n    def get_time(self):\n        if self.model:\n            time = math.ceil(self.length / self.frame_rate)\n            return time\n        else:\n            time = math.ceil(self.frame_length / self.frame_rate)\n            return time\n\n    def save_data(self):\n        config = {'length': self.length, 'frame_rate': self.frame_rate, 'frequency_range': self.frequency_range, 'frame_length': self.frame_length, 'model': self.model}\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        config_file = os.path.join(current_dir, 'config.json')\n        with open(config_file, 'w') as f:\n            json.dump(config, f, indent=4)\n        print(f'\u914d\u7f6e\u5df2\u4fdd\u5b58\u5230 {config_file}')"}]}
{"messages": [{"role": "user", "content": "Visualize a maze, find and mark the optimal starting point to minimize total distance to all targets, and show the paths from that point to the targets."}, {"role": "assistant", "content": "from manim import *\nfrom lib.maze import Maze\nfrom lib.solver import MazeSolver\n\nclass AnimateMaze(Scene):\n\n    def setup(self):\n        self.maze = Maze(rows=25, cols=60, n_targets=16, fill_fraction=0.25, random_seed=None)\n        self.maze_solver = MazeSolver(self.maze)\n\n    def construct(self):\n        title = Text('Optimal path finding.', font_size=64)\n        body = Text('\\n            Given a maze containing wall and targets\\n            find the point from which the total\\n            distance to all targets is minimized.\\n            ', font_size=32)\n        VGroup(title, body).arrange(DOWN, buff=1)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(Write(body))\n        self.wait(3)\n        self.play(FadeOut(title, body, shift=OUT))\n        boxes = VGroup(*[Text(s, t2c={self.maze.wall_cell: WHITE, self.maze.target_cell: RED}).scale(0.5) for s in self.maze.get_all_cell_values()])\n        boxes.arrange_in_grid(buff=(0.0, 0.0), rows=self.maze.num_rows, cols=self.maze.num_cols, flow_order='rd')\n        self.play(ShowIncreasingSubsets(boxes), run_time=5)\n        self.wait(1)\n        optimal_point, min_dist = self.maze_solver.find_optimal_point()\n\n        def get_box_coordinates(grid_row, grid_col) -> tuple[float, float, float]:\n            top_left_corner = boxes[0].get_center()\n            delta_x = boxes[1].get_center()[0] - top_left_corner[0]\n            delta_y = boxes[self.maze.num_cols].get_center()[1] - top_left_corner[1]\n            new_point_x = top_left_corner[0] + grid_col * delta_x\n            new_point_y = top_left_corner[1] + grid_row * delta_y\n            return [new_point_x, new_point_y, 0.0]\n        optimal_mark = Cross(stroke_color=GREEN, scale_factor=0.125, stroke_width=8).move_to(get_box_coordinates(*optimal_point))\n        self.play(Indicate(optimal_mark), run_time=1)\n        self.wait(1)\n        paths = self.maze_solver.get_paths_from_point(optimal_point)\n        path_points = VGroup(*[Text('+', font_size=32, color=BLUE, stroke_width=0, weight=BOLD).move_to(get_box_coordinates(*point)).scale(0.5) for point in paths])\n        self.add(path_points)\n        self.play(Write(path_points), run_time=4)\n        self.wait(4)\n        conclusion_text = Text('Solution Achieved!', font_size=48, font='Noto Sans')\n        summary = VGroup(Text(f'Optimal Point: ({optimal_point[0]}, {optimal_point[1]})', font_size=36), Text(f'Total Distance: {min_dist}', font_size=36)).arrange(direction=DOWN).next_to(conclusion_text, DOWN)\n        self.play(FadeOut(*boxes, optimal_mark, path_points, optimal_mark))\n        self.play(Write(conclusion_text))\n        self.play(FadeIn(summary))\n        self.wait(2)\n        self.play(FadeOut(conclusion_text, summary))"}]}
{"messages": [{"role": "user", "content": "Generate a 3D maze animation by showing walls and targets, then rotating the camera."}, {"role": "assistant", "content": "from manim import *\nfrom lib.maze3d import Maze3D\nfrom dataclasses import dataclass\nimport numpy as np\n\nclass AnimateMaze3d(ThreeDScene):\n\n    def setup(self):\n        self.maze_config = MazeConfig(scale_factor=1.0, side_length=0.25)\n        self.maze = Maze3D(layers=self.maze_config.layers, rows=self.maze_config.rows, cols=self.maze_config.cols, n_targets=self.maze_config.n_targets, fill_fraction=self.maze_config.fill_fraction, random_seed=None)\n        self.color_fill = {self.maze.wall_cell: WHITE, self.maze.target_cell: RED, self.maze.empty_cell: BLACK}\n        self.opacity_fill = {self.maze.wall_cell: 0.25, self.maze.target_cell: 0.75, self.maze.empty_cell: 0.0}\n\n    def _get_maze_cell(self, idx: tuple, cell_type: str) -> Cube:\n        return Cube(side_length=2 / 3 * self.maze_config.side_length if cell_type != self.maze.wall_cell else 1 / 3 * self.maze_config.side_length, fill_color=self.color_fill[cell_type], fill_opacity=self.opacity_fill[cell_type], stroke_opacity=self.opacity_fill[cell_type], background_stroke_opacity=self.opacity_fill[cell_type]).move_to(maze_idx_to_coords(idx, self.maze, self.maze_config.side_length))\n\n    def construct(self):\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        walls = VGroup(*[self._get_maze_cell(idx, self.maze.wall_cell) for idx in self.maze.get_wall_cells()])\n        targets = VGroup(*[self._get_maze_cell(idx, self.maze.target_cell) for idx in self.maze.get_target_cells()])\n        full_graph = VGroup(walls, targets)\n        self.play(ShowIncreasingSubsets(full_graph), run_time=2)\n        self.begin_3dillusion_camera_rotation(rate=0.5)\n        self.wait(3)\n        self.stop_3dillusion_camera_rotation()"}]}
{"messages": [{"role": "user", "content": "Animate the dynamic creation and modification of geometric shapes based on boolean operations and angular transformations."}, {"role": "assistant", "content": "from manim import *\nimport math\nimport itertools\n\nclass BooleanOperations(Scene):\n\n    def construct(self):\n        self.filter_rot = 0\n\n        def updateFilters(mob, dt):\n            if self.filter_rot == 0:\n                self.filter_rot += dt\n                return\n            mob.submobjects = []\n            start_angle = 0\n            end_angle = PI / 2\n            n_filters = 5\n            filter_angles = []\n            circles = []\n            for i in range(1, n_filters + 1):\n                filter_angles.append(start_angle + i * (end_angle - start_angle) / (n_filters + 1))\n                angle = smlerp(0, 2 * PI * (i - 1) / n_filters, self.filter_rot)\n                circle = Circle(radius=1.0, arc_center=0.5 * math.cos(angle) * RIGHT + 0.5 * math.sin(angle) * UP)\n                circles.append(circle)\n            for i in range(1, n_filters + 1):\n                for intersects in itertools.combinations(range(n_filters), i):\n                    intensity = 1.0\n                    p_angle = start_angle\n                    for j in intersects:\n                        dAngle = filter_angles[j] - p_angle\n                        intensity *= math.pow(math.cos(dAngle), 2)\n                        p_angle = filter_angles[j]\n                    intensity *= math.pow(math.cos(end_angle - p_angle), 2)\n                    if i == n_filters:\n                        mob.add(Intersection(*circles, color=WHITE, fill_opacity=intensity))\n                    else:\n                        intersect_circles = [circles[j] for j in range(n_filters) if j in intersects]\n                        if len(intersect_circles) == 1:\n                            intersect = intersect_circles[0]\n                        else:\n                            intersect = Intersection(*intersect_circles)\n                        not_intersect_circles = [circles[j] for j in range(n_filters) if j not in intersects]\n                        if len(not_intersect_circles) == 1:\n                            not_intersect = not_intersect_circles[0]\n                        else:\n                            not_intersect = Union(*not_intersect_circles)\n                        mob.add(Difference(intersect, not_intersect, color=WHITE, fill_opacity=intensity))\n            self.filter_rot += dt\n            self.filter_rot = min(self.filter_rot, 1.0)\n        filters = Mobject().add_updater(updateFilters, call_updater=False)\n        self.add(filters)\n        self.wait(2.0)"}]}
{"messages": [{"role": "user", "content": "Animate a question about Segway balancing transforming into a statement about cybernetics, followed by a transition to a statement about complex systems leading to chaos."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Segue(Scene):\n\n    def construct(self):\n        question = TextMobject('How does a Segway balance?')\n        segue = VGroup(*TextMobject('Segue $\\\\rightarrow$ ', 'Cybernetics!'))\n        segue[1].set_color_by_gradient(GREEN, RED)\n        self.play(Write(question))\n        self.wait(2)\n        self.play(Transform(question, segue))\n        maintain = VGroup(*TextMobject('Complex systems ', '$\\\\nrightarrow$ chaos'))\n        maintain[0].set_color(GREEN)\n        maintain[1].set_color(RED)\n        self.wait(2)\n        self.play(FadeOutAndShiftDown(question), Write(maintain))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of gravity affecting a block with feedback mechanisms, showing error propagation and amplification over time."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass GravityBlock(Scene):\n\n    def construct(self):\n        left_arrow = Arrow(start=LEFT * 3 + UP, end=LEFT * 2 + UP)\n        left_arrow.set_stroke(width=2)\n        left_label = TextMobject('Random error')\n        left_label.next_to(left_arrow, LEFT, MED_SMALL_BUFF)\n        gravity = TextMobject('Gravity')\n        box = SurroundingRectangle(gravity, buff=LARGE_BUFF, color=WHITE)\n        right_arrow = Arrow(start=RIGHT * 2, end=RIGHT * 4).set_color(RED)\n        right_label = TextMobject('$e(t)$').set_color(RED)\n        right_label.next_to(right_arrow, RIGHT, MED_SMALL_BUFF)\n        prev_arrow = Arrow(start=LEFT * 3 + DOWN, end=LEFT * 2 + DOWN)\n        prev_arrow.set_stroke(width=2)\n        prev_label = TextMobject('Previous error')\n        prev_label.next_to(prev_arrow, LEFT, MED_SMALL_BUFF)\n        feedback = [Line(RIGHT * 4 + RIGHT * MED_LARGE_BUFF + DOWN * MED_LARGE_BUFF, RIGHT * 4 + RIGHT * MED_LARGE_BUFF + DOWN * 3), Line(RIGHT * 4 + RIGHT * MED_LARGE_BUFF + DOWN * 3, LEFT * 4 + DOWN * 3), Line(LEFT * 4 + DOWN * 3, LEFT * 4 + DOWN + DOWN * MED_LARGE_BUFF)]\n        feedback = [obj.set_stroke(width=2) for obj in feedback]\n        lower = VGroup(*feedback)\n        self.play(Write(left_arrow), Write(left_label), Write(gravity), DrawBorderThenFill(box), Write(right_arrow), Write(right_label), Write(prev_arrow), Write(prev_label), Write(lower))\n        self.wait(1)\n        self.play(Transform(prev_arrow, prev_arrow.copy().set_stroke(width=4)), Transform(right_arrow, right_arrow.copy().set_stroke(width=4)), Transform(lower, VGroup(*[obj.copy().set_stroke(width=4) for obj in feedback])))\n        self.wait(0.5)\n        self.play(Transform(prev_arrow, prev_arrow.copy().set_stroke(width=8)), Transform(right_arrow, right_arrow.copy().set_stroke(width=8)), Transform(lower, VGroup(*[obj.copy().set_stroke(width=8) for obj in feedback])))\n        self.wait(0.5)\n        self.play(Transform(prev_arrow, prev_arrow.copy().set_stroke(width=14)), Transform(right_arrow, right_arrow.copy().set_stroke(width=14)), Transform(lower, VGroup(*[obj.copy().set_stroke(width=14) for obj in feedback])))\n        self.wait(0.5)\n        self.play(Transform(prev_arrow, prev_arrow.copy().set_stroke(width=22)), Transform(right_arrow, right_arrow.copy().set_stroke(width=22)), Transform(lower, VGroup(*[obj.copy().set_stroke(width=22) for obj in feedback])))"}]}
{"messages": [{"role": "user", "content": "Show text, then a system diagram that transforms into a modified version, with a red line and brace appearing and disappearing."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Closeup(Scene):\n\n    def construct(self):\n        aha = TextMobject('Changing the feedback loop')\n        self.play(Write(aha))\n        system = TikzMobject('\\n            \\\\begin{tikzpicture}[\\n                circlenode/.style={circle, draw},\\n                rectanglenode/.style={rectangle, draw, minimum width=2em},\\n                wheelnode/.style={circle, draw, minimum size=1.5em}\\n            ]\\n                \\\\node[circlenode] at (-0.25,0) {};\\n                \\\\draw (-0.25,0)--(0,-4);\\n                \\\\node[rectanglenode] at (0,-4) {};\\n                \\\\node[wheelnode] at (0.5,-4) {};\\n                \\\\node[wheelnode] at (-0.5, -4) {};\\n            \\\\end{tikzpicture}\\n            ')\n        self.wait(1)\n        self.play(FadeOutAndShiftDown(aha), Write(system))\n        line = Line(UP * 2.65 + UP * MED_SMALL_BUFF + LEFT * 0.35, DOWN * 2.75 + LEFT * 0.35)\n        line.set_color(RED)\n        invisible_line = Line(DOWN * 2.75 + LEFT * 0.35, DOWN * 2.75).set_color(BLACK)\n        self.play(Write(line))\n        brace = Brace(invisible_line, DOWN, buff=0.1)\n        self.play(Write(brace))\n        self.wait(3)\n        system_final = TikzMobject('\\n            \\\\begin{tikzpicture}[\\n                circlenode/.style={circle, draw},\\n                rectanglenode/.style={rectangle, draw, minimum width=2em},\\n                wheelnode/.style={circle, draw, minimum size=1.5em}\\n            ]\\n                \\\\node[circlenode] at (-0.25,0) {};\\n                \\\\draw (-0.25,0)--(-0.25,-4);\\n                \\\\node[rectanglenode] at (-0.25,-4) {};\\n                \\\\node[wheelnode] at (0.25,-4) {};\\n                \\\\node[wheelnode] at (-0.75, -4) {};\\n            \\\\end{tikzpicture}\\n            ').shift(LEFT * 0.35)\n        arrow = Arrow(start=ORIGIN, end=LEFT).set_color(YELLOW)\n        self.play(Write(arrow))\n        self.wait(2)\n        self.play(FadeOutAndShiftDown(arrow), FadeOutAndShiftDown(invisible_line), FadeOutAndShiftDown(line), FadeOutAndShiftDown(brace), Transform(system, system_final))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate a feedback loop with labels for random error, gravity, sensor input, and proportional control, connected by arrows and lines."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Proportional(Scene):\n\n    def construct(self):\n        left_arrow = Arrow(start=LEFT * 3 + UP, end=LEFT * 2 + UP)\n        left_arrow.set_stroke(width=8)\n        left_label = TextMobject('Random error')\n        left_label.next_to(left_arrow, LEFT, MED_SMALL_BUFF)\n        gravity = TextMobject('Gravity')\n        box = SurroundingRectangle(gravity, buff=LARGE_BUFF, color=WHITE)\n        right_arrow = Arrow(start=RIGHT * 2, end=RIGHT * 4)\n        right_label = TextMobject('$e(t)$')\n        right_label.next_to(right_arrow, RIGHT, MED_SMALL_BUFF)\n        brace = Brace(right_label, DOWN, buff=0.1)\n        prev_arrow = Arrow(start=LEFT * 3 + DOWN, end=LEFT * 2 + DOWN)\n        prev_arrow.set_stroke(width=8)\n        prev_label = TextMobject('wheels go brrr')\n        prev_label.next_to(prev_arrow, LEFT, MED_SMALL_BUFF)\n        sensor = TextMobject('Sensor').next_to(right_label, DOWN, MED_LARGE_BUFF).set_color(BLUE)\n        sensor_box = SurroundingRectangle(sensor, buff=SMALL_BUFF, color=BLUE)\n        bottom_label = TextMobject('Proportional ($K_p e(t)$)').set_color(YELLOW).next_to(box, DOWN, MED_LARGE_BUFF)\n        bottom_box = SurroundingRectangle(bottom_label, buff=SMALL_BUFF, color=YELLOW)\n        p_right = Line([sensor.get_center()[0], bottom_label.get_center()[1], 0], bottom_label.get_center() + RIGHT * 2.5)\n        feedback = [Line(sensor.get_center() + DOWN * 0.5, [sensor.get_center()[0], bottom_label.get_center()[1], 0]), p_right, Line([0, bottom_label.get_center()[1], 0] + LEFT * 2.5, [prev_label.get_center()[0], bottom_label.get_center()[1], 0]), Line([prev_label.get_center()[0], bottom_label.get_center()[1], 0], prev_label.get_center() + DOWN * 0.5)]\n        feedback = [obj.set_stroke(width=8) for obj in feedback]\n        self.play(Write(gravity), Write(left_arrow), Write(left_label), Write(right_arrow), Write(right_label), DrawBorderThenFill(box))\n        self.play(Write(sensor), DrawBorderThenFill(sensor_box))\n        self.play(Write(brace))\n        self.play(Write(VGroup(*feedback)), Write(prev_arrow), Write(prev_label))\n        self.wait(1)\n        self.play(Write(bottom_label), DrawBorderThenFill(bottom_box))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate a system diagram showing gravity, random error, a sensor, proportional control, and integral control, with arrows and boxes indicating data flow and calculations."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport json\n\nclass Integral(Scene):\n\n    def construct(self):\n        left_arrow = Arrow(start=LEFT * 3 + UP, end=LEFT * 2 + UP)\n        left_arrow.set_stroke(width=8)\n        left_label = TextMobject('Random error')\n        left_label.next_to(left_arrow, LEFT, MED_SMALL_BUFF)\n        gravity = TextMobject('Gravity')\n        box = SurroundingRectangle(gravity, buff=LARGE_BUFF, color=WHITE)\n        right_arrow = Arrow(start=RIGHT * 2, end=RIGHT * 4)\n        right_label = TextMobject('$e(t)$')\n        right_label.next_to(right_arrow, RIGHT, MED_SMALL_BUFF)\n        brace = Brace(right_label, DOWN, buff=0.1)\n        prev_arrow = Arrow(start=LEFT * 3 + DOWN, end=LEFT * 2 + DOWN)\n        prev_arrow.set_stroke(width=8)\n        prev_label = TextMobject('wheels go brrr')\n        prev_label.next_to(prev_arrow, LEFT, MED_SMALL_BUFF)\n        sensor = TextMobject('Sensor').next_to(right_label, DOWN, MED_LARGE_BUFF).set_color(BLUE)\n        sensor_box = SurroundingRectangle(sensor, buff=SMALL_BUFF, color=BLUE)\n        bottom_label = TextMobject('Proportional ($K_p e(t)$)').set_color(YELLOW).next_to(box, DOWN, MED_LARGE_BUFF)\n        bottom_box = SurroundingRectangle(bottom_label, buff=SMALL_BUFF, color=YELLOW)\n        p_right = Line([sensor.get_center()[0], bottom_label.get_center()[1], 0], bottom_label.get_center() + RIGHT * 2.5)\n        feedback = [Line(sensor.get_center() + DOWN * 0.5, [sensor.get_center()[0], bottom_label.get_center()[1], 0]), p_right, Line([0, bottom_label.get_center()[1], 0] + LEFT * 2.5, [prev_label.get_center()[0], bottom_label.get_center()[1], 0]), Line([prev_label.get_center()[0], bottom_label.get_center()[1], 0], prev_label.get_center() + DOWN * 0.5)]\n        feedback = VGroup(*[obj.set_stroke(width=8) for obj in feedback])\n        integral_label = TextMobject('Integral ($K_i \\\\int_0^t e(\\\\tau) d\\\\tau$)').set_color(GREEN).next_to(bottom_box, DOWN, MED_LARGE_BUFF)\n        integral_box = SurroundingRectangle(integral_label, buff=SMALL_BUFF, color=GREEN)\n        i_right = Line([sensor.get_center()[0], integral_label.get_center()[1], 0], integral_label.get_center() + RIGHT * 2.6)\n        integral_loop = [Line(sensor.get_center() + DOWN * 0.5, [sensor.get_center()[0], integral_label.get_center()[1], 0]), i_right, Line(integral_label.get_center() + LEFT * 2.6, [prev_label.get_center()[0], integral_label.get_center()[1], 0]), Line([prev_label.get_center()[0], integral_label.get_center()[1], 0], prev_label.get_center() + DOWN * 0.5)]\n        integral_loop = VGroup(*[obj.set_stroke(width=8) for obj in integral_loop])\n        all = [gravity, left_arrow, left_label, right_arrow, right_label, box, feedback, bottom_label, prev_arrow, prev_label, sensor, brace, sensor_box, bottom_box, integral_label, integral_loop, integral_box]\n        VGroup(*all).shift(UP)\n        self.play(Write(gravity), Write(left_arrow), Write(left_label), Write(right_arrow), Write(right_label), DrawBorderThenFill(box), Write(feedback), Write(bottom_label), Write(prev_arrow), Write(prev_label), Write(sensor), Write(brace), DrawBorderThenFill(sensor_box), DrawBorderThenFill(bottom_box), Write(integral_label), Write(integral_loop))\n        self.play(DrawBorderThenFill(integral_box))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a system with a circle connected to a rectangle, with two wheels at the bottom, demonstrating an overshoot motion by transforming the connections and positions."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport json\n\nclass Overshoot(Scene):\n\n    def construct(self):\n        system = TikzMobject('\\n            \\\\begin{tikzpicture}[\\n                circlenode/.style={circle, draw},\\n                rectanglenode/.style={rectangle, draw, minimum width=2em},\\n                wheelnode/.style={circle, draw, minimum size=1.5em}\\n            ]\\n                \\\\node[circlenode] at (-0.25,0) {};\\n                \\\\draw (-0.25,0)--(0,-4);\\n                \\\\node[rectanglenode] at (0,-4) {};\\n                \\\\node[wheelnode] at (0.5,-4) {};\\n                \\\\node[wheelnode] at (-0.5, -4) {};\\n            \\\\end{tikzpicture}\\n            ')\n        line = Line(UP * 2.65 + UP * MED_SMALL_BUFF + LEFT * 0.35, DOWN * 2.75 + LEFT * 0.35)\n        line.set_color(RED)\n        arrow = Arrow(start=ORIGIN, end=LEFT).set_color(YELLOW)\n        self.play(Write(system), Write(line))\n        self.wait(1)\n        self.play(Write(arrow))\n        system_final = TikzMobject('\\n            \\\\begin{tikzpicture}[\\n                circlenode/.style={circle, draw},\\n                rectanglenode/.style={rectangle, draw, minimum width=2em},\\n                wheelnode/.style={circle, draw, minimum size=1.5em}\\n            ]\\n                \\\\node[circlenode] at (-0.25,0) {};\\n                \\\\draw (-0.25,0)--(-0.25,-4);\\n                \\\\node[rectanglenode] at (-0.25,-4) {};\\n                \\\\node[wheelnode] at (0.25,-4) {};\\n                \\\\node[wheelnode] at (-0.75, -4) {};\\n            \\\\end{tikzpicture}\\n            ').shift(LEFT * 0.35)\n        self.wait(1)\n        self.play(FadeOutAndShiftDown(arrow), Transform(system, system_final))\n        system_overshoot = TikzMobject('\\n            \\\\begin{tikzpicture}[\\n                circlenode/.style={circle, draw},\\n                rectanglenode/.style={rectangle, draw, minimum width=2em},\\n                wheelnode/.style={circle, draw, minimum size=1.5em}\\n            ]\\n                \\\\node[circlenode] at (-0.5,0) {};\\n                \\\\draw (-0.5,0)--(-0.75,-4);\\n                \\\\node[rectanglenode] at (-0.75,-4) {};\\n                \\\\node[wheelnode] at (-0.25,-4) {};\\n                \\\\node[wheelnode] at (-1.25, -4) {};\\n            \\\\end{tikzpicture}\\n            ').shift(LEFT * 1.05)\n        self.wait(1)\n        self.play(Transform(line, line.copy().shift(LEFT * 0.35)), Transform(system, system_overshoot))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the components of a PID controller with visual feedback loops and then combine them to form a PID controller."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport json\n\nclass PID(Scene):\n\n    def construct(self):\n        left_arrow = Arrow(start=LEFT * 3 + UP, end=LEFT * 2 + UP)\n        left_arrow.set_stroke(width=8)\n        left_label = TextMobject('Random error')\n        left_label.next_to(left_arrow, LEFT, MED_SMALL_BUFF)\n        gravity = TextMobject('Gravity')\n        box = SurroundingRectangle(gravity, buff=LARGE_BUFF, color=WHITE)\n        right_arrow = Arrow(start=RIGHT * 2, end=RIGHT * 4)\n        right_label = TextMobject('$e(t)$')\n        right_label.next_to(right_arrow, RIGHT, MED_SMALL_BUFF)\n        brace = Brace(right_label, DOWN, buff=0.1)\n        prev_arrow = Arrow(start=LEFT * 3 + DOWN, end=LEFT * 2 + DOWN)\n        prev_arrow.set_stroke(width=8)\n        prev_label = TextMobject('wheels go brrr')\n        prev_label.next_to(prev_arrow, LEFT, MED_SMALL_BUFF)\n        sensor = TextMobject('Sensor').next_to(right_label, DOWN, MED_LARGE_BUFF).set_color(BLUE)\n        sensor_box = SurroundingRectangle(sensor, buff=SMALL_BUFF, color=BLUE)\n        bottom_label = TextMobject('Proportional ($K_p e(t)$)').set_color(YELLOW).next_to(box, DOWN, MED_LARGE_BUFF)\n        bottom_box = SurroundingRectangle(bottom_label, buff=SMALL_BUFF, color=YELLOW)\n        p_right = Line([sensor.get_center()[0], bottom_label.get_center()[1], 0], bottom_label.get_center() + RIGHT * 2.5)\n        feedback = [Line(sensor.get_center() + DOWN * 0.5, [sensor.get_center()[0], bottom_label.get_center()[1], 0]), p_right, Line([0, bottom_label.get_center()[1], 0] + LEFT * 2.5, [prev_label.get_center()[0], bottom_label.get_center()[1], 0]), Line([prev_label.get_center()[0], bottom_label.get_center()[1], 0], prev_label.get_center() + DOWN * 0.5)]\n        feedback = VGroup(*[obj.set_stroke(width=8) for obj in feedback])\n        integral_label = TextMobject('Integral ($K_i \\\\int_0^t e(\\\\tau) d\\\\tau$)').set_color(GREEN).next_to(bottom_box, DOWN, MED_LARGE_BUFF)\n        integral_box = SurroundingRectangle(integral_label, buff=SMALL_BUFF, color=GREEN)\n        i_right = Line([sensor.get_center()[0], integral_label.get_center()[1], 0], integral_label.get_center() + RIGHT * 2.6)\n        integral_loop = [Line(sensor.get_center() + DOWN * 0.5, [sensor.get_center()[0], integral_label.get_center()[1], 0]), i_right, Line(integral_label.get_center() + LEFT * 2.6, [prev_label.get_center()[0], integral_label.get_center()[1], 0]), Line([prev_label.get_center()[0], integral_label.get_center()[1], 0], prev_label.get_center() + DOWN * 0.5)]\n        integral_loop = VGroup(*[obj.set_stroke(width=8) for obj in integral_loop])\n        derivative_label = TextMobject('Derivative ($K_d \\\\frac{de(t)}{dt}$)').set_color(PURPLE).next_to(integral_box, DOWN, MED_LARGE_BUFF)\n        derivative_box = SurroundingRectangle(derivative_label, buff=SMALL_BUFF, color=PURPLE)\n        d_right = Line([sensor.get_center()[0], derivative_label.get_center()[1], 0], derivative_label.get_center() + RIGHT * 2.4)\n        derivative_loop = [Line(sensor.get_center() + DOWN * 0.5, [sensor.get_center()[0], derivative_label.get_center()[1], 0]), d_right, Line(derivative_label.get_center() + LEFT * 2.4, [prev_label.get_center()[0], derivative_label.get_center()[1], 0]), Line([prev_label.get_center()[0], derivative_label.get_center()[1], 0], prev_label.get_center() + DOWN * 0.5)]\n        derivative_loop = VGroup(*[obj.set_stroke(width=8) for obj in derivative_loop])\n        all = [gravity, left_arrow, left_label, right_arrow, right_label, box, feedback, bottom_label, prev_arrow, prev_label, sensor, brace, sensor_box, bottom_box, integral_label, integral_loop, integral_box, derivative_loop, derivative_label, derivative_box]\n        VGroup(*all).shift(UP * 2)\n        self.play(Write(gravity), Write(left_arrow), Write(left_label), Write(right_arrow), Write(right_label), DrawBorderThenFill(box), Write(feedback), Write(bottom_label), Write(prev_arrow), Write(prev_label), Write(sensor), Write(brace), DrawBorderThenFill(sensor_box), Write(integral_label), Write(integral_loop), Write(derivative_loop), Write(derivative_label))\n        self.wait(2)\n        self.play(DrawBorderThenFill(bottom_box), run_time=0.9)\n        self.play(DrawBorderThenFill(integral_box), run_time=0.9)\n        self.play(DrawBorderThenFill(derivative_box), run_time=0.9)\n        self.play(FadeOutAndShiftDown(VGroup(*all)))\n        first = VGroup(*TextMobject('Proportional', ' + ', 'Integral', ' + ', 'Derivative'))\n        first[0].set_color(YELLOW)\n        first[2].set_color(GREEN)\n        first[4].set_color(PURPLE)\n        second = VGroup(*TextMobject('PID ', 'Controller', '$\\\\rightarrow$ Complex Systems!'))\n        second[0].set_color_by_gradient(YELLOW, GREEN)\n        second[1].set_color_by_gradient(GREEN, PURPLE)\n        self.play(Write(first))\n        self.play(Transform(first, second))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Display text about Manim, a project link, a PID controller tuning link, and a message about the Segway."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport json\n\nclass ThankYou(Scene):\n\n    def construct(self):\n        love = TextMobject('Hand-coded with $\\\\heartsuit$ using ', 'Manim ', 'and ', 'matter.js')\n        love[1].set_color(BLUE)\n        love[3].set_color(YELLOW)\n        demo = TextMobject('Tune your own PID controller: ', 'https://SASE-Labs-2021.gitub.io/inverted-pendulum')\n        demo[1].set_color(GREEN)\n        learn = TextMobject('How to tune a PID controller: ', 'https://nathanielbd.github.io/posts/segue-from-segways/')\n        learn[1].set_color(GREEN)\n        love.shift(UP * 1.5)\n        learn.shift(DOWN * 1.5)\n        segway = TextMobject('RIP Segway (2001-2020)')\n        segway.shift(DOWN * 3)\n        self.play(Write(love), Write(demo), Write(learn), Write(segway))\n        self.wait(20)"}]}
{"messages": [{"role": "user", "content": "Visualize grouped box plots with individual data points for multiple categories."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\n\nclass SeabornBoxPlotScene(Scene):\n\n    def construct(self):\n        categories = ['Cat1', 'Cat2', 'Cat3']\n        subcat1_data = {'Cat1': (-1, -0.5, 0, 0.5, 1), 'Cat2': (-1.5, -1, 0, 1, 1.5), 'Cat3': (-2, -0.75, 0.5, 0.75, 2)}\n        subcat2_data = {'Cat1': (-1.2, -0.6, 0.1, 0.6, 1.2), 'Cat2': (-1.4, -0.9, 0.2, 1.1, 1.6), 'Cat3': (-1.8, -0.7, 0.6, 0.8, 2.1)}\n        subcat1_points = {'Cat1': [-0.8, -0.4, 0.2, 0.4, 0.9], 'Cat2': [-1.3, -0.9, 0.1, 0.9, 1.4], 'Cat3': [-1.9, -0.7, 0.6, 0.7, 1.9]}\n        subcat2_points = {'Cat1': [-1.1, -0.5, 0.3, 0.5, 1.1], 'Cat2': [-1.2, -0.8, 0.3, 1.0, 1.5], 'Cat3': [-1.7, -0.6, 0.7, 0.8, 2.0]}\n        box_width = 0.3\n        spacing = 1.2\n        group_spacing = 0.3\n        axes = Axes(x_range=[0, len(categories) * spacing, spacing], y_range=[-3, 3, 1], x_length=10, y_length=6, axis_config={'color': BLUE, 'include_numbers': True, 'numbers_to_include': [-3, -2, -1, 0, 1, 2, 3]}).to_edge(DOWN, buff=1)\n        axes.get_x_axis().set_opacity(0)\n        self.play(Create(axes))\n        cats_v = VGroup()\n        for i, cat in enumerate(categories):\n            cat_label = Text(cat, font_size=10).next_to(axes.c2p(i + 1 * spacing, -3), DOWN)\n            cats_v.add(cat_label)\n        self.play(Write(cats_v))\n\n        def create_boxplot(data, x_pos, color, label):\n            min_val, q1, median, q3, max_val = data\n            box = Rectangle(width=box_width, height=axes.y_length * (q3 - q1) / 6, stroke_color=color, fill_color=color, fill_opacity=0.5).move_to(axes.c2p(x_pos, (q1 + q3) / 2))\n            lower_whisker = Line(start=axes.c2p(x_pos, q1), end=axes.c2p(x_pos, min_val))\n            lower_whisker_hor = Line(start=axes.c2p(x_pos - box_width / 8, min_val), end=axes.c2p(x_pos + box_width / 8, min_val))\n            upper_whisker_hor = Line(start=axes.c2p(x_pos, q3), end=axes.c2p(x_pos, max_val))\n            upper_whisker = Line(start=axes.c2p(x_pos - box_width / 8, max_val), end=axes.c2p(x_pos + box_width / 8, max_val))\n            median_line = Line(start=axes.c2p(x_pos - box_width / 6, median), end=axes.c2p(x_pos + box_width / 6, median))\n            lab = Text(label, font_size=10).next_to(lower_whisker, DOWN)\n            return VGroup(box, lower_whisker, lower_whisker_hor, upper_whisker, upper_whisker_hor, median_line, lab)\n        dots = VGroup()\n        boxes = VGroup()\n        for i, cat in enumerate(categories):\n            case_group = create_boxplot(subcat1_data[cat], i + 1 * spacing - group_spacing / 2, RED, 'SubCat1')\n            control_group = create_boxplot(subcat2_data[cat], i + 1 * spacing + group_spacing / 2, GREEN, 'SubCat1')\n            boxes.add(case_group)\n            boxes.add(control_group)\n            for value in subcat1_points[cat]:\n                dot = Dot(color=RED).move_to(axes.c2p(i + 1 * spacing - group_spacing / 2, value))\n                dots.add(dot)\n            for value in subcat2_points[cat]:\n                dot = Dot(color=GREEN).move_to(axes.c2p(i + 1 * spacing + group_spacing / 2, value))\n                dots.add(dot)\n        self.play(Create(boxes), run_time=1)\n        self.play(FadeIn(dots, scale=0.5), run_time=1)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Demonstrate the concept of velocity by animating a moving dot along an axis, showing coordinate changes, calculating distance and time, and finally presenting the velocity formula."}, {"role": "assistant", "content": "from manim import *\n\nclass Index(Scene):\n\n    def construct(self):\n        title = Text('V\u1eadn t\u1ed1c', font_size=144, font='Noto Sans')\n        origin_marker = Line([-0.25, 0, 0], [0.25, 0, 0]).rotate(PI / 2).shift(DOWN)\n        axis_line = Line([-6, 0, 0], [6, 0, 0]).shift(DOWN)\n        description1 = Text('V\u1eadn t\u1ed1c ph\u1ee5 thu\u1ed9c v\u00e0o chi\u1ec1u d\u01b0\u01a1ng', font='Noto Sans', font_size=22).shift(UP)\n        description2 = Text('Ch\u1ecdn v\u1eadt m\u1ed1c nh\u01b0 h\u00ecnh, chi\u1ec1u d\u01b0\u01a1ng theo chi\u1ec1u vect\u01a1', font='Noto Sans', font_size=18).next_to(description1, DOWN * 0.5)\n        reference_object = Text('V\u1eadt m\u1ed1c', font_size=20, font='Noto Sans').next_to(origin_marker, DOWN * 0.4)\n        direction_vector = Arrow(ORIGIN, [2, 0, 0]).shift(RIGHT * 5).shift(DOWN)\n        formula = MathTex('V = \\\\frac{S}{t}').shift(UP * 2)\n        direction_text = Text('Chi\u1ec1u d\u01b0\u01a1ng', font_size=20, font='Noto Sans').next_to(direction_vector, DOWN * 0.5)\n        formula_label = Text('C\u00f4ng th\u1ee9c:', font_size=25, font='Noto Sans').next_to(formula, LEFT)\n        formula_description = create_text('Trong \u0111\u00f3: ').next_to(formula, RIGHT)\n        velocity_description = create_text('V: V\u1eadn t\u1ed1c').next_to(formula_description, RIGHT + UP * 0.5)\n        distance_description = create_text('S: Qu\u00e3ng \u0111\u01b0\u1eddng').next_to(formula_description, RIGHT)\n        time_description = create_text('t: Th\u1eddi gian').next_to(formula_description, RIGHT + DOWN * 0.5)\n        unit_markers = VGroup(*[Line([-0.05, 0, 0], [0.05, 0, 0]).rotate(PI / 2).shift(DOWN).shift(RIGHT * i) for i in range(1, 7)], *[Line([-0.05, 0, 0], [0.05, 0, 0]).rotate(PI / 2).shift(DOWN).shift(LEFT * i) for i in range(1, 7)])\n        time_label = Text('t = ', font_size=40).next_to(axis_line, DOWN * 6 + LEFT * 0.7)\n        time_value = DecimalNumber().set_color(WHITE).next_to(time_label, RIGHT)\n        time_group = VGroup(time_label, time_value)\n        moving_dot = Dot(color=BLUE).shift(DOWN)\n        coordinate_label = create_text('T\u1ecda \u0111\u1ed9: ').next_to(origin_marker, DOWN * 2 + LEFT * 0.5)\n        coordinate_value = DecimalNumber().set_color(WHITE).next_to(coordinate_label, RIGHT * 0.5)\n        distance_label = Text('S', color=YELLOW).shift(LEFT * 4 + UP * 0.5)\n        equals_sign1 = Text(' = ', color=WHITE).next_to(distance_label, RIGHT)\n        end_position_value = DecimalNumber().set_color(RED).next_to(equals_sign1, RIGHT)\n        minus_sign = Text(' - ', color=WHITE).next_to(end_position_value, RIGHT)\n        start_position_value = DecimalNumber().set_color(GREEN).next_to(minus_sign, RIGHT)\n        equals_sign2 = Text(' = ', color=WHITE).next_to(start_position_value, RIGHT * 2)\n        distance_value = DecimalNumber().set_color(YELLOW).next_to(equals_sign2, RIGHT)\n        start_dot = Dot(color=GREEN).shift(DOWN + LEFT * 4)\n        end_dot = Dot(color=RED).shift(DOWN + LEFT * 4)\n        distance_line = Line()\n        distance_line.add_updater(lambda z: z.become(Line(start_dot.get_center(), end_dot.get_center()).set_color(YELLOW)))\n        direction_note = create_text('N\u1ebfu t\u1ecda \u0111\u1ed9 \u0111i\u1ec3m n\u1eb1m c\u00f9ng v\u1ec1 ph\u00eda v\u1edbi chi\u1ec1u d\u01b0\u01a1ng th\u00ec n\u00f3 d\u01b0\u01a1ng v\u00e0 ng\u01b0\u1ee3c l\u1ea1i').shift(UP)\n        opposite_vector = Arrow(ORIGIN, [-2, 0, 0]).next_to(axis_line, UP * 2).shift(LEFT)\n        distance_note1 = create_text('Qu\u00e3ng \u0111\u01b0\u1eddng (S) l\u00e0 kho\u1ea3ng c\u00e1ch t\u1eeb v\u1ecb tr\u00ed (t\u1ecda \u0111\u1ed9) \u0111\u1ea7u \u0111\u00ean v\u1ecb tr\u00ed (t\u1ecda \u0111\u1ed9) cu\u1ed1i').shift(UP * 2 + LEFT * 2)\n        distance_note2 = create_text('hay n\u00f3i c\u00e1ch kh\u00e1c l\u00e0 b\u1eb1ng v\u1ecb tr\u00ed (t\u1ecda \u0111\u1ed9) cu\u1ed1i tr\u1eeb cho v\u1ecb tr\u00ed (t\u1ecda \u0111\u1ed9) \u0111\u1ea7u').shift(UP * 1.5 + LEFT * 2)\n        time_note = create_text('Th\u1eddi gian (t) l\u00e0 th\u1eddi gian ch\u1ea5t \u0111i\u1ec3m \u0111i t\u1eeb v\u1ecb tr\u00ed (t\u1ecda \u0111\u1ed9) \u0111\u1ea7u \u0111\u1ebfn v\u1ecb tr\u00ed (t\u1ecda \u0111\u1ed9) cu\u1ed1i').shift(UP * 2 + LEFT * 2)\n        self.wait(1)\n        self.play(Write(title))\n        self.wait(3)\n        self.play(Transform(title, origin_marker))\n        self.play(Create(axis_line))\n        self.play(Create(description1))\n        self.wait(1)\n        self.play(Create(description2))\n        self.wait(0.5)\n        self.play(Create(reference_object))\n        self.play(Create(direction_vector))\n        self.play(Create(direction_text))\n        self.wait(3)\n        self.play(FadeOut(description1, description2, direction_text, reference_object), direction_vector.animate.next_to(axis_line, UP * 2).shift(RIGHT))\n        self.play(FadeIn(formula_label, formula))\n        self.play(FadeIn(formula_description, velocity_description, distance_description, time_description))\n        self.wait(3)\n        self.play(FadeOut(formula_label, formula_description, velocity_description, distance_description, time_description), formula.animate.next_to(axis_line, UP * 10).shift(RIGHT * 5))\n        self.play(FadeIn(unit_markers))\n        self.play(FadeIn(moving_dot, coordinate_label, coordinate_value))\n        self.wait(1)\n        self.play(moving_dot.animate.shift(LEFT * 4), Count(coordinate_value, 0, -4))\n        self.wait(1)\n        self.wait(1)\n        self.play(moving_dot.animate.shift(RIGHT * 7), Count(coordinate_value, -4, 3))\n        self.play(FadeIn(direction_note))\n        self.wait(1)\n        self.play(Transform(direction_vector, opposite_vector), Count(coordinate_value, 3, -3))\n        self.wait(1)\n        self.play(moving_dot.animate.shift(LEFT * 5), Count(coordinate_value, -3, 2))\n        self.wait(1)\n        self.play(moving_dot.animate.shift(LEFT * 2), Count(coordinate_value, 2, 4))\n        self.wait(1)\n        self.play(Transform(direction_vector, Arrow(ORIGIN, [2, 0, 0]).next_to(axis_line, UP * 2).shift(RIGHT)), Count(coordinate_value, 4, -4))\n        self.wait(1)\n        self.play(moving_dot.animate.shift(LEFT * 1), Count(coordinate_value, -4, -5))\n        self.wait(1)\n        self.play(moving_dot.animate.shift(RIGHT * 8), Count(coordinate_value, -5, 3))\n        self.wait(1)\n        self.play(moving_dot.animate.shift(RIGHT * 3), Count(coordinate_value, 3, 6))\n        self.wait(1)\n        self.play(moving_dot.animate.shift(LEFT * 6), Count(coordinate_value, 6, 0), FadeOut(direction_note))\n        self.play(FadeIn(distance_note1))\n        self.play(moving_dot.animate.shift(LEFT * 4), Count(coordinate_value, 0, -4), FadeIn(distance_note2))\n        self.play(FadeIn(distance_label, equals_sign1))\n        self.play(FadeIn(start_dot), Count(start_position_value, 0, -4))\n        self.wait(1)\n        self.play(moving_dot.animate.shift(RIGHT * 7), Count(coordinate_value, -4, 3), Create(minus_sign), FadeIn(distance_line), end_dot.animate.shift(RIGHT * 7), Count(end_position_value, 0, 3))\n        self.wait(1)\n        self.play(FadeIn(equals_sign2))\n        self.play(Count(distance_value, 0, 7))\n        self.wait(5)\n        self.play(FadeOut(distance_label, equals_sign1, end_position_value, minus_sign, start_position_value, equals_sign2, distance_value, distance_note2, distance_note1))\n        self.wait(1)\n        self.play(FadeIn(time_group))\n        self.play(FadeIn(time_note))\n        self.wait(3)\n        self.play(moving_dot.animate.shift(LEFT * 7), Count(coordinate_value, 3, -4), Count(time_value, 0, 5), run_time=5)\n        self.wait(3)\n        self.play(FadeOut(time_note))\n        self.play(Count(time_value, 5, 0), run_time=0.3)\n        self.wait(1)\n        self.play(moving_dot.animate.shift(RIGHT * 7), Count(coordinate_value, -4, 3), Count(time_value, 0, 7), run_time=7)\n        self.wait(3)\n        self.play(FadeOut(distance_line, start_dot, end_dot))\n        self.play(Count(time_value, 7, 0), moving_dot.animate.shift(LEFT * 3), Count(coordinate_value, 3, 0), run_time=0.3)\n        self.wait(1)\n        distance_label = Text('S', color=YELLOW).shift(LEFT * 4 + UP * 0.5)\n        equals_sign1 = Text(' = ', color=WHITE).next_to(distance_label, RIGHT)\n        end_position_value = DecimalNumber().set_color(RED).next_to(equals_sign1, RIGHT)\n        minus_sign = Text(' - ', color=WHITE).next_to(end_position_value, RIGHT)\n        start_position_value = DecimalNumber().set_color(GREEN).next_to(minus_sign, RIGHT)\n        equals_sign2 = Text(' = ', color=WHITE).next_to(start_position_value, RIGHT * 2)\n        distance_value = DecimalNumber().set_color(YELLOW).next_to(equals_sign2, RIGHT)\n        start_dot = Dot(color=GREEN).shift(DOWN + LEFT * 2)\n        end_dot = Dot(color=RED).shift(DOWN + RIGHT * 3)\n        distance_line = Line()\n        distance_line.add_updater(lambda z: z.become(Line(start_dot.get_center(), moving_dot.get_center()).set_color(YELLOW)))\n        example_note1 = create_text('Gi\u1ea3 s\u1eed \u0111i\u1ec3m xu\u1ea5t ph\u00e1t l\u00e0 V\u1ecb tr\u1ecb th\u1ee9 -2, \u0111i\u1ec3m d\u1eebng l\u00e0 V\u1ecb tr\u00ed th\u1ee9 3').shift(UP * 2 + LEFT * 2)\n        self.play(FadeIn(example_note1))\n        self.wait(1)\n        example_note2 = create_text('v\u00e0 th\u1eddi gian di chuy\u1ec3n c\u1ee7a ch\u1ea5t \u0111i\u1ec3m l\u00e0 8s').shift(UP * 1.5 + LEFT * 2)\n        self.play(FadeIn(start_dot, end_dot, example_note2))\n        self.wait(2)\n        self.play(FadeOut(example_note1, example_note2), moving_dot.animate.shift(LEFT * 2), Count(coordinate_value, 0, -2))\n        calculation_note = Text('Ta s\u1ebd c\u00f3: ', font_size=31, font='Noto Sans').shift(UP * 2 + LEFT * 3)\n        self.play(FadeIn(calculation_note))\n        self.play(FadeIn(distance_label, equals_sign1, minus_sign))\n        self.play(Count(start_position_value, 0, -2))\n        self.play(moving_dot.animate.shift(RIGHT * 5), Count(coordinate_value, -2, 3), Count(time_value, 0, 8), FadeIn(distance_line), run_time=8)\n        self.play(Count(end_position_value, 0, 3))\n        self.play(FadeIn(equals_sign2))\n        self.play(Count(distance_value, 0, 5))\n        self.wait(3)\n        self.play(FadeOut(calculation_note, equals_sign1, minus_sign, end_position_value, start_position_value), VGroup(equals_sign2, distance_value).animate.shift(LEFT * 3 + UP * 1), distance_label.animate.shift(UP * 1 + RIGHT * 0.5), time_group.animate.next_to(origin_marker, UP * 4 + LEFT * 7))\n        fraction_line = Line(UP * 1 + LEFT * 4.3, UP * 1 + LEFT * 1.3)\n        self.play(Create(fraction_line))\n        equals_sign3 = Text(' = ', color=WHITE).next_to(fraction_line, RIGHT * 0.5)\n        velocity_value = DecimalNumber().set_color(WHITE).next_to(equals_sign3, RIGHT * 0.5)\n        self.play(Create(equals_sign3))\n        self.play(Count(velocity_value, 0, 5 / 8))\n        self.wait(3)\n        velocity_label = Text('V ', font_size=40, font='Noto Sans').next_to(equals_sign3, LEFT * 0.5)\n        self.play(Transform(VGroup(equals_sign2, distance_value, distance_label, time_group, fraction_line), velocity_label))\n        self.wait(1)\n        self.play(VGroup(equals_sign3, velocity_value, velocity_label, VGroup(equals_sign2, distance_value, distance_label, time_group, fraction_line)).animate.next_to(origin_marker, UP * 3.5))\n        self.wait(5)\n        self.play(FadeOut(distance_line))\n        self.play(FadeOut(axis_line, origin_marker, title, unit_markers, VGroup(equals_sign2, distance_value, distance_label, time_group, fraction_line), VGroup(equals_sign3, velocity_value, velocity_label), direction_vector, start_dot, end_dot, coordinate_label, coordinate_value, moving_dot))\n        self.play(formula.animate.next_to(origin_marker, UP))\n        self.wait(5)\n        self.play(Transform(formula, Text('V\u1eadn t\u1ed1c', font_size=144, font='Noto Sans')))\n        self.wait(5)\n        self.play(FadeOut(formula))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Visualize the calculation of the area under a parametric curve and the volume of revolution for a given function."}, {"role": "assistant", "content": "from manim import *\nfrom manim.utils.rate_functions import ease_in_out_sine\n\nclass Animation(ThreeDScene):\n\n    def construct(self):\n\n        def func(x):\n            if x < 0 or x > 2:\n                return 0\n            return x * np.sqrt(4 - x ** 2)\n\n        def func_x(t):\n            return -2 * np.cos(t)\n\n        def func_y(t):\n            return -2 * np.sin(2 * t)\n        intro_line1 = Tex('\\\\text{AP Calculus AB}', font_size=24, color=WHITE)\n        intro_line2 = Tex('\\\\text{2021 FRQ - Question 3}', font_size=18, color=WHITE)\n        intro_line3 = Tex('\\\\text{Ben K}', font_size=12, color=WHITE)\n        intro_group = VGroup(intro_line1, intro_line2, intro_line3).arrange(DOWN, center=True).move_to(ORIGIN)\n        self.play(Write(intro_group), run_time=2.5)\n        self.wait(1.0)\n        self.play(FadeOut(intro_group), run_time=1)\n        self.wait(0.5)\n        axes = ThreeDAxes(x_range=[0, 2.2, 0.5], y_range=[0, 2.2, 0.5], z_range=[-2.2, 2.2, 0.5], x_length=8, y_length=2.5, z_length=8, tips=False, stroke_width=2)\n        axes.z_axis.set_opacity(0)\n        axes.add(MathTex('x').next_to(axes.x_axis.get_end(), RIGHT, buff=0.4), MathTex('y').next_to(axes.y_axis.get_end(), UP, buff=0.4))\n        axes.scale(0.3)\n        graph = axes.plot_parametric_curve(lambda t: (func_x(t), func_y(t), 0), t_range=[PI / 2, PI], color=PINK, stroke_width=2).set_z_index(1)\n        general_problem = Tex('A company designs spinning toys using the family of functions $y = c x \\\\sqrt{4 - x^2}$ where $c$ is a positive constant. The figure below shows the region in the first quadrant bounded by the $x$-axis and the graph of $y = c x \\\\sqrt{4 - x^2}$, for some $c$. Each spinning toy is in the shape of the solid generated when such a region is revolved about the $x$-axis. Both $x$ and $y$ are measured in inches.', font_size=10, tex_environment='flushleft').shift(UP * 0.6)\n        graph_group = VGroup(graph, axes).shift(DOWN * 0.7)\n        self.play(Write(general_problem), run_time=6)\n        self.wait(0.25)\n        self.play(Create(axes), run_time=1.5)\n        axes.set_z_index(2)\n        self.wait(0.25)\n        self.play(Create(graph), run_time=2)\n        self.wait(3)\n        self.play(general_problem.animate.scale(0.7).shift(LEFT * 0.8).shift(UP * 0.2), graph_group.animate.scale(0.5).shift(UP * 1.2).shift(RIGHT * 1.15), run_time=2)\n        problem_a = Tex('(a) Find the area of the region in the first quadrant bounded by the $x$-axis and the graph of $y = c x \\\\sqrt{4 - x^2}$ for $c = 6$.', font_size=8, tex_environment='center').shift(UP * 0.35)\n        self.play(Write(problem_a), run_time=3)\n        self.wait(0.5)\n        x_tracker_a1 = ValueTracker(PI / 2)\n\n        def get_parametric_area():\n            t_vals = np.linspace(PI / 2, x_tracker_a1.get_value(), 100)\n            points = [axes.c2p(func_x(t), func_y(t), 0) for t in t_vals]\n            points.insert(0, axes.c2p(func_x(t_vals[0]), 0, 0))\n            points.append(axes.c2p(func_x(t_vals[-1]), 0, 0))\n            return Polygon(*points, color=BLUE, fill_opacity=0.5, stroke_width=0)\n        area = always_redraw(get_parametric_area).set_z_index(-1)\n        self.add(area)\n        self.play(x_tracker_a1.animate.set_value(PI), run_time=3, rate_func=ease_in_out_sine)\n        self.wait(2)\n        integral_definition = Tex('Since we know that the area under a curve $f$ is $\\\\int_a^b f(x) dx$, we can find the area of the region by plugging in the given function:', font_size=8, tex_environment='center')\n        integral_definition_2 = Tex('$A = \\\\int_a^b cx\\\\sqrt{4 - x^2} dx$', font_size=8, tex_environment='center').next_to(integral_definition, DOWN).shift(UP * 0.175)\n        self.play(Write(integral_definition), run_time=3)\n        self.play(Write(integral_definition_2), run_time=1.5)\n        self.wait(2)\n        self.play(FadeOut(integral_definition), run_time=1)\n        parta_area_1 = Tex('Given that $c = 6$, we can now plug in c into our integral:', font_size=8, tex_environment='center')\n        parta_area_2 = Tex('$A = \\\\int_a^b 6x\\\\sqrt{4 - x^2} dx$', font_size=8, tex_environment='center').next_to(parta_area_1, DOWN).shift(UP * 0.112)\n        parta_area_3 = Tex('To find the endpoints of the integral, we can set the equation $y = 6x\\\\sqrt{4 - x^2}$ equal to 0 and solve for $x$:', font_size=8, tex_environment='center').shift(DOWN * 0.1)\n        parta_area_4 = Tex('$6x\\\\sqrt{4 - x^2} = 0$', font_size=8, tex_environment='center').shift(DOWN * 0.3)\n        parta_area_5 = Tex('$x\\\\sqrt{4 - x^2} = 0$', font_size=8, tex_environment='center').shift(DOWN * 0.3)\n        parta_area_6 = Tex('$x = 0$', font_size=8, tex_environment='center').shift(DOWN * 0.5).shift(LEFT * 0.25)\n        parta_area_7 = Tex('$0 = \\\\sqrt{4 - x^2}$', font_size=8, tex_environment='center').shift(DOWN * 0.495).shift(RIGHT * 0.15)\n        parta_area_8 = Tex('$0 = 4 - x^2$', font_size=8, tex_environment='center').shift(DOWN * 0.495).shift(RIGHT * 0.15)\n        parta_area_9 = Tex('$x^2 = 4$', font_size=8, tex_environment='center').shift(DOWN * 0.495).shift(RIGHT * 0.15)\n        parta_area_10 = Tex('$x = \\\\pm2$', font_size=8, tex_environment='center').shift(DOWN * 0.495).shift(RIGHT * 0.15)\n        parta_area_11 = Tex(\"Since length can't be negative, 2 has to be positive\", font_size=8, tex_environment='center').shift(DOWN * 0.66)\n        parta_area_12 = Tex('$x = 2$', font_size=8, tex_environment='center').shift(DOWN * 0.495).shift(RIGHT * 0.15)\n        parta_area_13 = Tex('Thus, the lower and upper bounds of the integral are $0$ and $2$ respectively.', font_size=8, tex_environment='center').shift(DOWN * 0.75)\n        parta_area_14 = Tex('$A = \\\\int_0^2 6x\\\\sqrt{4 - x^2} dx$', font_size=8, tex_environment='center').shift(UP * 0.114)\n        parta_area_14tip = Tex('We will need to use u-sub to solve this integral!', font_size=6, tex_environment='center').shift(RIGHT * 1.1).shift(DOWN * 0.095)\n        parta_area_15 = Tex('Let $u = 4 - x^2$', font_size=8, tex_environment='center').shift(DOWN * 0.08)\n        parta_area_16 = Tex('$du = -2x dx$', font_size=8, tex_environment='center').shift(DOWN * 0.21)\n        parta_area_17 = Tex('$-\\\\frac{1}{2}du = x dx$', font_size=8, tex_environment='center').shift(DOWN * 0.34)\n        parta_area_18tip = Tex('Remember to change the limits of integration!', font_size=6, tex_environment='center').shift(RIGHT * 1.15).shift(DOWN * 0.512)\n        parta_area_18 = Tex('$x = 0 \\\\Rightarrow u = 4 - 0^2 = 4$', font_size=8, tex_environment='center').shift(DOWN * 0.45)\n        parta_area_19 = Tex('$x = 2 \\\\Rightarrow u = 4 - 2^2 = 0$', font_size=8, tex_environment='center').shift(DOWN * 0.55)\n        parta_area_20 = Tex('$A = \\\\int_4^0 6\\\\left(-\\\\frac{1}{2}\\\\sqrt{u}\\\\right) du$', font_size=8, tex_environment='center').shift(UP * 0.115)\n        parta_area_21 = Tex('$A = -3\\\\int_4^0 \\\\sqrt{u} du$', font_size=8, tex_environment='center').shift(UP * 0.115)\n        parta_area_22 = Tex('$A = 3\\\\int_0^4 \\\\sqrt{u} du$', font_size=8, tex_environment='center').shift(UP * 0.115)\n        parta_area_23 = Tex('$A = 2u^{\\\\frac{3}{2}}\\\\bigg \\\\rvert^{u = 4}_{u = 0}$', font_size=8, tex_environment='center').shift(UP * 0.115)\n        parta_area_24 = Tex('$A = 2(4)^{\\\\frac{3}{2}} - 2(0)^{\\\\frac{3}{2}}$', font_size=8, tex_environment='center').shift(UP * 0.115)\n        parta_area_25 = Tex('$A = 2(8) - 0$', font_size=8, tex_environment='center').shift(UP * 0.115)\n        parta_area_26 = Tex('$A = 16$', font_size=8, tex_environment='center').shift(UP * 0.115)\n        parta_area_27_final = Tex('$\\\\therefore \\\\text{The area of the region is } 16 \\\\text{ square inches.}$', font_size=8, tex_environment='center').shift(DOWN * 0.2)\n        parta_area_27_final_tip = Tex('Remember to add units!', font_size=6, tex_environment='center').shift(DOWN * 0.45)\n        parta_area_27_final_box = SurroundingRectangle(parta_area_27_final, color=WHITE, stroke_width=1, buff=0.1)\n        self.play(Write(parta_area_1), run_time=2)\n        self.play(FadeTransform(integral_definition_2, parta_area_2), run_time=1)\n        self.wait(2)\n        self.play(FadeOut(parta_area_1), parta_area_2.animate.shift(UP * 0.35), run_time=1)\n        self.play(Write(parta_area_3), run_time=3)\n        self.wait(0.1)\n        self.play(Write(parta_area_4), run_time=1.5)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_4, parta_area_5), run_time=1)\n        self.play(FadeIn(parta_area_6), FadeIn(parta_area_7), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_7, parta_area_8), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_8, parta_area_9), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_9, parta_area_10), run_time=1)\n        self.wait(0.5)\n        self.play(Write(parta_area_11), run_time=1.5)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_10, parta_area_12), run_time=1)\n        self.wait(0.5)\n        self.play(FadeOut(parta_area_11), run_time=1)\n        self.play(Write(parta_area_13), run_time=2)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_2, parta_area_14), run_time=0.5)\n        self.wait(0.25)\n        self.play(FadeOut(parta_area_13), FadeOut(parta_area_3), FadeOut(parta_area_5), FadeOut(parta_area_6), FadeOut(parta_area_12), run_time=0.5)\n        self.wait(0.5)\n        self.play(Write(parta_area_15), FadeIn(parta_area_14tip), run_time=1)\n        self.wait(0.5)\n        self.play(FadeOut(parta_area_14tip), run_time=1)\n        self.wait(0.5)\n        self.play(Write(parta_area_16), run_time=1)\n        self.wait(0.5)\n        self.play(Write(parta_area_17), run_time=1)\n        self.wait(0.5)\n        self.play(Write(parta_area_18), Write(parta_area_19), FadeIn(parta_area_18tip), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_14, parta_area_20), run_time=1)\n        self.wait(0.5)\n        self.play(FadeOut(parta_area_15), FadeOut(parta_area_16), FadeOut(parta_area_17), FadeOut(parta_area_18), FadeOut(parta_area_18tip), FadeOut(parta_area_19), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_20, parta_area_21), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_21, parta_area_22), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_22, parta_area_23), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_23, parta_area_24), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_24, parta_area_25), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(parta_area_25, parta_area_26), run_time=1)\n        self.wait(0.5)\n        self.play(Write(parta_area_27_final), run_time=1)\n        self.play(Create(parta_area_27_final_box), run_time=1)\n        self.wait(0.25)\n        self.play(FadeIn(parta_area_27_final_tip), run_time=1.5)\n        self.wait(2)\n        self.play(FadeOut(problem_a), FadeOut(parta_area_26), FadeOut(parta_area_27_final), FadeOut(parta_area_27_final_box), FadeOut(parta_area_27_final_tip), FadeOut(area), FadeOut(x_tracker_a1), run_time=1)\n        self.wait(0.5)\n        problem_b = Tex('(b) It is known that, for $y=cx\\\\sqrt{4-x^2}$, $\\\\frac{dy}{dx} = \\\\frac{c\\\\left(4-2x^2\\\\right)}{\\\\sqrt{4-x^2}}$. For a particular spinning toy, the radius of the largest cross-sectional circular slice is $1.2$ inches. What is the value of $c$ for this spinning toy?', font_size=8, tex_environment='center').shift(UP * 0.35)\n        x_tracker_b1 = ValueTracker(0)\n        partb_dot = always_redraw(lambda: Dot(axes.c2p(x_tracker_b1.get_value(), func(x_tracker_b1.get_value())), radius=0.025, color=BLUE))\n        self.play(Write(problem_b), run_time=3.5)\n        self.wait(0.5)\n        partb_dot.set_z_index(3)\n        partb_ddx_1 = Tex('The cross-sectional circular slice with the largest radius occurs where $cx\\\\sqrt{4 - x^2}$ has its maximum on the interval $0 < x < 2$.', font_size=8, tex_environment='center').shift(DOWN * 0.05)\n        partb_ddx_2 = Tex('To find the maximum, we can set the derivative equal to $0$ and solve for $x$:', font_size=8, tex_environment='center').shift(DOWN * 0.24)\n        partb_ddx_3 = Tex('$\\\\frac{dy}{dx} = \\\\frac{c\\\\left(4-2x^2\\\\right)}{\\\\sqrt{4-x^2}} = 0$', font_size=8, tex_environment='center').shift(DOWN * 0.45)\n        partb_ddx_3_tip = Tex('Remember to set the derivative equal to $0$!', font_size=6, tex_environment='center').shift(RIGHT * 1.1).shift(DOWN * 0.46)\n        partb_ddx_4 = Tex('$c\\\\left(4-2x^2\\\\right) = 0$', font_size=8, tex_environment='center').shift(DOWN * 0.45)\n        partb_ddx_5 = Tex('$c = 0$', font_size=8, tex_environment='center').shift(LEFT * 0.25).shift(DOWN * 0.618)\n        partb_ddx_6 = Tex('$4-2x^2 = 0$', font_size=8, tex_environment='center').shift(RIGHT * 0.15).shift(DOWN * 0.61)\n        partb_ddx_7 = Tex('$2x^2 = 4$', font_size=8, tex_environment='center').shift(RIGHT * 0.15).shift(DOWN * 0.61)\n        partb_ddx_8 = Tex('$x^2 = 2$', font_size=8, tex_environment='center').shift(RIGHT * 0.15).shift(DOWN * 0.61)\n        partb_ddx_9 = Tex('$x = \\\\pm\\\\sqrt{2}$', font_size=8, tex_environment='center').shift(RIGHT * 0.15).shift(DOWN * 0.61)\n        partb_ddx_9_tip = Tex(\"Since length can't be negative, $\\\\sqrt{2}$ has to be positive.\", font_size=8, tex_environment='center').shift(DOWN * 0.8)\n        partb_ddx_10 = Tex('$x = \\\\sqrt{2}$', font_size=8, tex_environment='center').shift(RIGHT * 0.15).shift(DOWN * 0.61)\n        partb_ddx_11 = Tex(\"Now that we've found $x$, we can solve for $c$ given that the radius is $1.2$ inches.\", font_size=8, tex_environment='center').shift(DOWN * 0.8)\n        partb_ddx_12 = Tex('$1.2 = cx\\\\sqrt{4 - x^2}$', font_size=8, tex_environment='center').shift(DOWN * 0.1)\n        partb_ddx_13 = Tex('$1.2 = c\\\\sqrt{2}\\\\sqrt{4 - \\\\sqrt{2}^2}$', font_size=6, tex_environment='center').shift(DOWN * 0.1)\n        partb_ddx_14 = Tex('$1.2 = c\\\\sqrt{2}\\\\sqrt{4 - 2}$', font_size=8, tex_environment='center').shift(DOWN * 0.1)\n        partb_ddx_15 = Tex('$1.2 = c\\\\sqrt{2}\\\\sqrt{2}$', font_size=8, tex_environment='center').shift(DOWN * 0.1)\n        partb_ddx_16 = Tex('$1.2 = 2c$', font_size=9, tex_environment='center').shift(DOWN * 0.1)\n        partb_ddx_17 = Tex('$c = 0.6$', font_size=9, tex_environment='center').shift(DOWN * 0.1)\n        partb_ddx_17_final = Tex('$\\\\therefore \\\\text{The value of } c \\\\text{ is } 0.6 \\\\text{.}$', font_size=8, tex_environment='center').shift(DOWN * 0.35)\n        partb_ddx_17_final_box = SurroundingRectangle(partb_ddx_17_final, color=WHITE, stroke_width=1, buff=0.1)\n        self.play(Write(partb_ddx_1), run_time=3)\n        self.play(FadeIn(partb_dot), run_time=0.5)\n        self.play(x_tracker_b1.animate.set_value(1.41421), run_time=3, rate_func=ease_in_out_sine)\n        self.wait(1)\n        self.play(Write(partb_ddx_2), run_time=2)\n        self.wait(0.5)\n        self.play(Write(partb_ddx_3), run_time=2)\n        self.play(FadeIn(partb_ddx_3_tip), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partb_ddx_3, partb_ddx_4), FadeOut(partb_ddx_3_tip), run_time=1)\n        self.wait(0.5)\n        self.play(FadeIn(partb_ddx_5), FadeIn(partb_ddx_6), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partb_ddx_6, partb_ddx_7), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partb_ddx_7, partb_ddx_8), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partb_ddx_8, partb_ddx_9), run_time=1)\n        self.wait(0.5)\n        self.play(Write(partb_ddx_9_tip), run_time=2)\n        self.wait(0.5)\n        self.play(FadeTransform(partb_ddx_9, partb_ddx_10), FadeOut(partb_ddx_9_tip), run_time=1)\n        self.wait(0.5)\n        self.play(Write(partb_ddx_11), run_time=2)\n        self.wait(1)\n        self.play(FadeOut(partb_ddx_1), FadeOut(partb_ddx_2), FadeOut(partb_ddx_4), FadeOut(partb_ddx_5), FadeOut(partb_ddx_11), partb_ddx_10.animate.move_to(ORIGIN).shift(DOWN * 0.3), FadeIn(partb_ddx_12), run_time=1)\n        self.wait(1)\n        self.play(FadeTransform(VGroup(partb_ddx_10, partb_ddx_12), partb_ddx_13), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partb_ddx_13, partb_ddx_14), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partb_ddx_14, partb_ddx_15), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partb_ddx_15, partb_ddx_16), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partb_ddx_16, partb_ddx_17), run_time=1)\n        self.wait(0.5)\n        self.play(Write(partb_ddx_17_final), run_time=1)\n        self.play(Create(partb_ddx_17_final_box), run_time=1)\n        self.wait(2)\n        self.play(FadeOut(problem_b), FadeOut(partb_dot), FadeOut(partb_ddx_17), FadeOut(partb_ddx_17_final), FadeOut(partb_ddx_17_final_box), run_time=1)\n        self.wait(0.5)\n        new_axes = ThreeDAxes(x_range=[0, 2.2, 0.5], y_range=[-2.2, 2.2, 0.5], z_range=[-2.2, 2.2, 0.5], x_length=8, y_length=5, z_length=8, tips=False)\n        new_axes.add(MathTex('x').next_to(new_axes.x_axis.get_end(), RIGHT, buff=0.4).scale(1.1), MathTex('y').next_to(new_axes.y_axis.get_end(), UP, buff=0.4).scale(1.1), MathTex('z').next_to(new_axes.z_axis.get_end(), OUT, buff=0.4).scale(1.1))\n        new_axes.scale(0.15)\n        problem_c = Tex('(c) For another spinning toy, the volume is $2\\\\pi$ cubic inches. What is the value of $c$ for this spinning toy?', font_size=8, tex_environment='center').shift(UP * 0.3)\n        self.play(Write(problem_c), run_time=3)\n        self.wait(0.5)\n        self.add_fixed_in_frame_mobjects(general_problem, problem_c)\n        e = ValueTracker(0)\n        surface = always_redraw(lambda: Surface(lambda u, v: new_axes.c2p(func_x(u), func_y(u) * np.cos(v), func_y(u) * np.sin(v)), u_range=[PI / 2, PI], v_range=[0, e.get_value()], checkerboard_colors=[GREEN, PURPLE], fill_opacity=0.5))\n        n_slices = 1000\n        slices = VGroup()\n        for i in range(n_slices):\n            x = (i + 0.5) * 2 / n_slices\n            radius = func(x)\n            if radius == 0:\n                continue\n            p0 = new_axes.c2p(x, 0, 0)\n            p1 = new_axes.c2p(x, radius, 0)\n            scaled_radius = np.linalg.norm(p1 - p0)\n            disk = Circle(radius=scaled_radius, color=RED, fill_opacity=0.005, stroke_opacity=0.0)\n            disk.rotate(PI / 2, axis=UP)\n            disk.move_to(new_axes.c2p(x, 0, 0))\n            slices.add(disk)\n        slices.set_z_index(3)\n        new_graph = new_axes.plot_parametric_curve(lambda t: (func_x(t), func_y(t), 0), t_range=[PI / 2, PI], color=PINK, stroke_width=2).set_z_index(1)\n        VGroup(new_axes, new_graph, slices).shift(DOWN * 0.9)\n        self.play(graph_group.animate.move_to(ORIGIN).scale(1.1).shift(DOWN * 0.3).shift(RIGHT * 0.2), run_time=2.5)\n        self.play(FadeOut(graph), run_time=1)\n        self.play(Transform(axes, new_axes), run_time=1.5)\n        self.play(Create(new_graph), run_time=2)\n        self.add(surface)\n        self.move_camera(phi=45 * DEGREES, theta=-130 * DEGREES, gamma=-50 * DEGREES, run_time=3, rate_func=ease_in_out_sine)\n        self.play(LaggedStart(*[Create(b) for b in slices], lag_ratio=0.05), run_time=6, rate_func=ease_in_out_sine)\n        self.wait(2)\n        self.play(Rotating(new_graph, axis=RIGHT, radians=TAU, about_point=new_axes.c2p(0, 0, 0)), e.animate.set_value(2 * PI), run_time=6, rate_func=ease_in_out_sine)\n        self.wait(2)\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, gamma=0 * DEGREES, run_time=3, rate_func=ease_in_out_sine, added_anims=[*[disk.animate.set_fill(opacity=0.05) for disk in slices]])\n        self.remove(axes, new_graph)\n        self.play(VGroup(new_axes, slices).animate.scale(0.7).shift(UP * 1.35).shift(RIGHT * 1.2), run_time=2)\n        self.wait(1)\n        partc_volume_1 = Tex('Given that the function is revolved around the x axis, we can use the equation $\\\\int_a^b \\\\pi f(x)^2 dx$ to find the volume of the solid.', font_size=8, tex_environment='center').shift(UP * 0.05)\n        partc_volume_1_tip = Tex('Remember that the area of a circle is $\\\\pi r^2$!', font_size=6, tex_environment='flushleft').shift(RIGHT * 1.2).shift(DOWN * 0.35)\n        partc_volume_1_tip2 = Tex('Remember to square the function!', font_size=6, tex_environment='flushleft').shift(RIGHT * 1.2).shift(DOWN * 0.45)\n        partc_volume_2 = Tex('After substituting our function into the equation, we get:', font_size=8, tex_environment='center').shift(DOWN * 0.15)\n        partc_volume_3 = Tex('$V = \\\\int_0^2 \\\\pi \\\\left(cx\\\\sqrt{4 - x^2}\\\\right)^2 dx$', font_size=8, tex_environment='center').shift(DOWN * 0.35)\n        partc_volume_4 = Tex('$V = \\\\pi c^2 \\\\int_0^2 x^2(4 - x^2) dx$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_5 = Tex('$V = \\\\pi c^2 \\\\int_0^2 (4x^2 - x^4) dx$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_6 = Tex('$V = \\\\pi c^2 \\\\left(\\\\frac{4x^3}{3} - \\\\frac{x^5}{5}\\\\right) \\\\bigg \\\\rvert^{x = 2}_{x = 0}$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_7 = Tex('$V = \\\\pi c^2 \\\\left(\\\\frac{4(2)^3}{3} - \\\\frac{(2)^5}{5} - \\\\left(\\\\frac{4(0)^3}{3} - \\\\frac{(0)^5}{5}\\\\right)\\\\right)$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_8 = Tex('$V = \\\\pi c^2 \\\\left(\\\\frac{32}{3} - \\\\frac{32}{5}\\\\right)$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_9 = Tex('$V = \\\\frac{64\\\\pi c^2}{15}$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_10 = Tex('Since we know that the volume is $2\\\\pi$, we can set the equation equal to $2\\\\pi$ and solve for $c$.', font_size=8, tex_environment='center').shift(DOWN * 0.25)\n        partc_volume_11 = Tex('$\\\\frac{64\\\\pi c^2}{15} = 2\\\\pi$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_12 = Tex('$\\\\frac{64c^2}{15} = 2$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_13 = Tex('$64c^2 = 30$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_14 = Tex('$c^2 = \\\\frac{30}{64}$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_15 = Tex('$c = \\\\sqrt{\\\\frac{30}{64}}$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_16 = Tex('$c = \\\\sqrt{\\\\frac{15}{32}}$', font_size=8, tex_environment='center').shift(DOWN * 0.0)\n        partc_volume_17_final = Tex('$\\\\therefore \\\\text{When the volume is } 2\\\\pi \\\\text{ cubic inches, the value of } c \\\\text{ is } \\\\sqrt{\\\\frac{15}{32}}\\\\text{.}$', font_size=8, tex_environment='center').shift(DOWN * 0.4)\n        partc_volume_17_final_box = SurroundingRectangle(partc_volume_17_final, color=WHITE, stroke_width=1, buff=0.1)\n        self.play(Write(partc_volume_1), run_time=3)\n        self.wait(1)\n        self.play(Write(partc_volume_2), run_time=2)\n        self.wait(0.25)\n        self.play(Write(partc_volume_3), FadeIn(partc_volume_1_tip), FadeIn(partc_volume_1_tip2), run_time=2)\n        self.wait(1)\n        self.play(FadeOut(partc_volume_2), FadeOut(partc_volume_1_tip), FadeOut(partc_volume_1_tip2), FadeOut(partc_volume_1), run_time=1)\n        self.wait(0.5)\n        self.play(partc_volume_3.animate.shift(UP * 0.35), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_3, partc_volume_4), FadeOut(partc_volume_3), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_4, partc_volume_5), FadeOut(partc_volume_4), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_5, partc_volume_6), FadeOut(partc_volume_5), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_6, partc_volume_7), FadeOut(partc_volume_6), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_7, partc_volume_8), FadeOut(partc_volume_7), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_8, partc_volume_9), FadeOut(partc_volume_8), run_time=1)\n        self.wait(0.5)\n        self.play(Write(partc_volume_10), run_time=3)\n        self.wait(2)\n        self.play(FadeTransform(partc_volume_9, partc_volume_11), FadeOut(partc_volume_10), FadeOut(partc_volume_9))\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_11, partc_volume_12), FadeOut(partc_volume_11), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_12, partc_volume_13), FadeOut(partc_volume_12), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_13, partc_volume_14), FadeOut(partc_volume_13), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_14, partc_volume_15), FadeOut(partc_volume_14), run_time=1)\n        self.wait(0.5)\n        self.play(FadeTransform(partc_volume_15, partc_volume_16), FadeOut(partc_volume_15), run_time=1)\n        self.wait(0.5)\n        self.play(Write(partc_volume_17_final), run_time=1)\n        self.play(Create(partc_volume_17_final_box), run_time=1)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Write the Chinese characters for \"\u4e07\u6728\u957f\u98ce\" and its English subtitle \"Directed by DistinctWind\" on screen, then fade them out."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Main(Scene):\n\n    def construct(self):\n        title = Text('\u4e07\u6728\u957f\u98ce', font='msyh', stroke_width=0)\n        sub_title = Text('Directed by DistinctWind', font='mayh', stroke_width=0)\n        sub_title.scale(0.5)\n        sub_title.next_to(title, DOWN * 1.5)\n        self.play(Write(title))\n        self.play(Write(sub_title))\n        self.wait()\n        self.play(Uncreate(title), Uncreate(sub_title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate a maze and highlight its starting point."}, {"role": "assistant", "content": "import sys\nimport os\nfrom manimlib import *\nfrom utils.imports import *\n\nclass RecallingMaze(Scene):\n\n    def construct(self):\n        maze = Maze(5, 5)\n        maze.set_start(3, 3)\n        maze.set_end(1, 1)\n        self.play(ShowCreation(maze))\n        self.wait()\n        poi = Dot(color=RED).move_to(maze.get_rec(*maze.start))\n        self.play(FadeIn(poi, scale=0.5))\n        return super().construct()"}]}
{"messages": [{"role": "user", "content": "Animate text to turn red while simultaneously scaling the camera frame down."}, {"role": "assistant", "content": "import sys\nimport os\nfrom manimlib import *\nfrom utils.imports import *\n\nclass try_playing_together(Scene):\n\n    def construct(self):\n        text = Text('text')\n        self.add(text)\n        self.play(text.animate.set_color(RED), self.camera.frame.animate.scale(0.5))\n        return super().construct()"}]}
{"messages": [{"role": "user", "content": "Show and then unshow a dot, followed by showing the original dot and a copy of it."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass UnShowCreationTest(Scene):\n\n    def construct(self):\n        dot = Dot()\n        self.play(ShowCreation(dot))\n        dot_cmp = dot.copy()\n        self.play(Uncreate(dot))\n        self.play(ShowCreation(dot))\n        self.play(ShowCreation(dot_cmp))"}]}
{"messages": [{"role": "user", "content": "Generate a maze with specified dimensions and a start and end point, then add an arrow indicating a path within the maze."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass MazeTest(Scene):\n\n    def construct(self):\n        maze = Maze(9, 16, scale_factor=0.7)\n        maze.set_start(1, 1)\n        maze.set_end(9, 16)\n        maze.set_bar_randomly()\n        arrow = maze.get_arrow(3, 5, UP)\n        self.add(maze)\n        self.add(arrow)"}]}
{"messages": [{"role": "user", "content": "Arrange four regular pentagons in the corners of the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass TextRegularPolygon(Scene):\n\n    def construct(self):\n        tri2 = RegularPolygon(n=5, start_angle=PI / 2)\n        tri3 = RegularPolygon(n=5, start_angle=PI)\n        tri1 = RegularPolygon(n=5, start_angle=0)\n        tri4 = RegularPolygon(n=5, start_angle=3 * PI / 2)\n        tri1.to_corner(UL)\n        tri2.to_corner(UR)\n        tri3.to_corner(DR)\n        tri4.to_corner(DL)\n        self.add(tri1, tri2, tri3, tri4)"}]}
{"messages": [{"role": "user", "content": "Animate a dot and move the camera to the right to follow it."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass MovingCameraText(MovingCameraScene):\n\n    def setup(self):\n        MovingCameraScene.setup(self)\n\n    def construct(self):\n        dot = Dot()\n        frame = self.camera_frame\n        self.add(dot)\n        self.play(ApplyMethod(frame.shift, RIGHT))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render a maze with a starting point and an arrow pointing downwards from a specified cell."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass MazeText(Scene):\n\n    def construct(self):\n        maze = Maze(9, 16, scale_factor=0.8)\n        maze.set_start(1, 1)\n        maze.set_end(9, 16)\n        self.add(maze)\n        arrow = maze.get_arrow((1, 3), DOWN)\n        self.add(arrow)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Show a group of three rectangles with five sides each, created with a show creation animation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass TextMultiRectangle(Scene):\n\n    def construct(self):\n        m = MultiRectangle(3, 5)\n        self.play(ShowCreation(m))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate the zooming functionality of a `ZoomedScene` by showing a dot, an image, and then animating a zoomed-in view of the dot within the image."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass ZoomedSceneExample(ZoomedScene):\n    CONFIG = {'zoom_factor': 0.3, 'zoomed_display_height': 1, 'zoomed_display_width': 6, 'image_frame_stroke_width': 20, 'zoomed_camera_config': {'default_frame_stroke_width': 3}}\n\n    def construct(self):\n        dot = Dot().shift(UL * 2)\n        image = ImageMobject(np.uint8([[0, 100, 30, 200], [255, 0, 5, 33]]))\n        image.set_height(7)\n        frame_text = TextMobject('Frame', color=PURPLE).scale(1.4)\n        zoomed_camera_text = TextMobject('Zommed camera', color=RED).scale(1.4)\n        self.add(image, dot)\n        zoomed_camera = self.zoomed_camera\n        zoomed_display = self.zoomed_display\n        frame = zoomed_camera.frame\n        zoomed_display_frame = zoomed_display.display_frame\n        frame.move_to(dot)\n        frame.set_color(PURPLE)\n        zoomed_display_frame.set_color(RED)\n        zoomed_display.shift(DOWN)\n        zd_rect = BackgroundRectangle(zoomed_display, fill_opacity=0, buff=MED_SMALL_BUFF)\n        self.add_foreground_mobject(zd_rect)\n        unfold_camera = UpdateFromFunc(zd_rect, lambda rect: rect.replace(zoomed_display))\n        frame_text.next_to(frame, DOWN)\n        self.play(ShowCreation(frame), FadeInFromDown(frame_text))\n        self.activate_zooming()\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera)\n        zoomed_camera_text.next_to(zoomed_display_frame, DOWN)\n        self.play(FadeInFromDown(zoomed_camera_text))\n        scale_factor = [0.5, 1.5, 0]\n        self.play(frame.scale, scale_factor, zoomed_display.scale, scale_factor, FadeOut(zoomed_camera_text), FadeOut(frame_text))\n        self.play(frame.scale, 3, frame.shift, 2.5 * DOWN)\n        self.play(ScaleInPlace(zoomed_display, 2))\n        self.wait()\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera, rate_func=lambda t: smooth(1 - t))\n        self.play(Uncreate(zoomed_display_frame), FadeOut(frame))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Apply a gradient color to text and math objects, and a gradient sheen to another text object."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass color_text(Scene):\n\n    def construct(self):\n        text = TextMobject('text')\n        text.set_color_by_gradient(BLUE, WHITE, YELLOW, RED)\n        tex = TexMobject('tex')\n        tex.set_color_by_gradient(BLUE, WHITE, YELLOW, RED)\n        trying = TextMobject('trying').set_color([BLUE, WHITE, YELLOW, RED])\n        trying.set_sheen_direction(LEFT)\n        self.add(VGroup(text, tex, trying).arrange(DOWN))"}]}
{"messages": [{"role": "user", "content": "Create a simple 3D scene with no objects."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass Dtest(ThreeDScene):\n\n    def construct(self):\n        pass"}]}
{"messages": [{"role": "user", "content": "Animate a grid of squares where two specific squares are labeled and a path is drawn connecting them through a depth-first search traversal of the grid."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass Test_vgroup_square(Scene):\n\n    def construct(self):\n        g = VGroup(*[Square().scale(0.3) for x in range(5)]).arrange(RIGHT, buff=0)\n        f = VGroup(*[VGroup(*[Square().scale(0.5) for x in range(5)]).arrange(RIGHT, buff=0) for y in range(3)]).arrange(DOWN, buff=0)\n        self.add(f)\n        s = TextMobject('S').scale(1.25).set_color(GREEN).set_opacity(0.5)\n        s.move_to(f[0][0].get_center())\n        t = TextMobject('T').scale(1.25).set_color(RED).set_opacity(0.5)\n        t.move_to(f[2][4].get_center())\n        self.play(Write(s), Write(t))\n        self.wait()\n        path = []\n        vis = []\n        mov_x = (-1, 0, 1, 0)\n        mov_y = (0, 1, 0, -1)\n        cnt = 0\n        sp = []\n        text = TextMobject('cnt=' + str(cnt)).set_color(GREEN).to_corner(UL)\n        self.play(Write(text))\n\n        def show_path(self):\n            nonlocal cnt, sp\n            cnt += 1\n            p = VGroup(*[Line(f[begin[0]][begin[1]].get_center(), f[end[0]][end[1]].get_center()).set_color(GREEN) for begin, end in path])\n            if cnt == 1:\n                self.play(ShowCreation(p))\n                sp.append(p)\n                text.target = TextMobject('cnt=' + str(cnt)).set_color(GREEN).to_corner(UL)\n                self.play(MoveToTarget(text))\n                self.wait(3)\n            else:\n                self.remove(sp[0])\n                self.add(p)\n                text.target = TextMobject('cnt=' + str(cnt)).set_color(GREEN).to_corner(UL)\n                self.play(MoveToTarget(text), run_time=0.1)\n                sp[0] = p\n\n        def dfs(x, y):\n            nonlocal path, vis, cnt\n            vis.append((x, y))\n            for i in range(4):\n                now_x = x + mov_x[i]\n                now_y = y + mov_y[i]\n                if (now_x, now_y) in vis:\n                    continue\n                if 0 <= now_x <= 2 and 0 <= now_y <= 4:\n                    path.append(((x, y), (now_x, now_y)))\n                    if now_x == 2 and now_y == 4:\n                        show_path(self)\n                    else:\n                        dfs(now_x, now_y)\n                    path.pop()\n            vis.pop()\n        dfs(0, 0)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a group of text objects and then change the color of the third text object to red."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass Test_vgroup(Scene):\n\n    def construct(self):\n        v = VGroup(*[TextMobject(str(x)) for x in range(5)]).arrange(RIGHT)\n        self.play(Write(v))\n        self.wait()\n        self.play(v[2].set_color, RED, run_time=3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show the product rule formula, highlight the first derivative term with a frame, then transform that frame into a frame around the second derivative term with a curved animation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass MoveFrameBox(Scene):\n\n    def construct(self):\n        text = TexMobject('\\\\frac{d}{dx}f(x)g(x)=', 'f(x)\\\\frac{d}{dx}g(x)', '+', 'g(x)\\\\frac{d}{dx}f(x)')\n        self.play(Write(text))\n        framebox1 = SurroundingRectangle(text[1], buff=0.1)\n        framebox2 = SurroundingRectangle(text[3], buff=0.1)\n        self.play(ShowCreation(framebox1))\n        self.wait()\n        self.play(ReplacementTransform(framebox1.copy(), framebox2), path_arc=-math.pi)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the text \"HELLO WORLD\" with upward and downward braces, each displaying explanatory text."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass Underline(Scene):\n\n    def construct(self):\n        greet = TextMobject('HELLO', 'WORLD')\n        dbrace = Brace(greet[0], DOWN)\n        ubrace = Brace(greet[1], UP)\n        dtext = dbrace.get_text('down')\n        utext = ubrace.get_text('up')\n        self.play(Write(greet))\n        self.play(GrowFromCenter(dbrace), GrowFromCenter(ubrace))\n        self.wait()\n        self.play(FadeIn(dtext), FadeIn(utext))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Write the Fourier transform formula and highlight the integral limits with a green box."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass FrameBox2(Scene):\n\n    def construct(self):\n        text = TexMobject('\\\\hat g(', 'f', ')', '=', '\\\\int', '_{t_1}', '^{t_{2}}', 'g(', 't', ')', 'e', '^{-2\\\\pi i', 'f', 't}', 'dt')\n        seleccion = VGroup(text[4], text[5], text[6])\n        frameBox = SurroundingRectangle(seleccion, buff=0.5 * SMALL_BUFF)\n        frameBox.set_stroke(GREEN, 3)\n        self.play(Write(text))\n        self.wait(0.5)\n        self.play(ShowCreation(frameBox))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate a summation formula by writing it to the screen and then scaling it up and down twice."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass ChangeSize(Scene):\n\n    def construct(self):\n        text = TexMobject('\\\\sum_{i=0}^n i=\\\\frac{n(n+1)}{2}')\n        self.play(Write(text))\n        text.scale_in_place(2)\n        self.wait()\n        text.scale_in_place(0.5)\n        self.wait()\n        text.scale(2)\n        self.wait()\n        text.scale(0.5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Color the 'x' characters in a mathematical expression red as it is written."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass ColorByCaracter(Scene):\n\n    def construct(self):\n        text = TexMobject('{d', '\\\\over', 'd', 'x}', '\\\\int^', 'x_', 'a', 'f(', 't', ')d', 't', '=', 'f(', 'x', ')')\n        text.set_color_by_tex('x', RED)\n        self.play(Write(text))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a large text string with various characters."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass Sizes(Scene):\n\n    def construct(self):\n        textHuge = TextMobject('{\\\\Huge Huge Text 012.\\\\#!?} Text')\n        self.add(textHuge)"}]}
{"messages": [{"role": "user", "content": "Display the words \"UP\", \"DOWN\", \"LEFT\", and \"RIGHT\" with each word flipped in its corresponding direction."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass FlipObject(Scene):\n\n    def construct(self):\n        up = TextMobject('UP')\n        down = TextMobject('DOWN')\n        left = TextMobject('LEFT')\n        right = TextMobject('RIGHT')\n        up.flip(UP)\n        up.move_to(UP)\n        down.flip(DOWN)\n        down.move_to(DOWN)\n        left.flip(LEFT)\n        left.move_to(LEFT)\n        right.flip(RIGHT)\n        right.move_to(RIGHT)\n        self.play(Write(up), Write(down), Write(left), Write(right))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Show the text \"Hi! How do you do?\" and sequentially rotate it by increasing increments."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass Roating(Scene):\n\n    def construct(self):\n        text = TextMobject('Hi! How do you do?')\n        self.play(ShowCreation(text))\n        self.wait()\n        self.play(ApplyMethod(text.rotate, PI / 4))\n        self.wait()\n        self.play(ApplyMethod(text.rotate, PI / 4))\n        self.wait()\n        self.play(ApplyMethod(text.rotate, PI / 2))\n        self.wait()\n        self.play(ApplyMethod(text.rotate, PI))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a visual representation of a target with multiple rings and then animate \"shots\" impacting specific points within the target, revealing coordinates upon impact."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass Shoot(Scene):\n\n    def construct(self):\n        c1 = Circle(color=BLUE)\n        c2 = Circle(color=RED, fill_color=RED, fill_opacity=1)\n        c2.scale(0.1)\n        l1 = Line(np.array([-1, 0, 0]), np.array([1, 0, 0]))\n        l2 = Line(np.array([0, -1, 0]), np.array([0, 1, 0]))\n        scope = VGroup(c1, c2, l1, l2)\n        t = []\n        lr = np.array([-4, -2, 0])\n        for i in range(3):\n            for j in range(5):\n                c = Circle(color=YELLOW, fill_color=YELLOW, fill_opacity=0.5)\n                c.scale(0.5)\n                t.append(c)\n                self.play(FadeIn(c), run_time=0.1)\n                self.play(ApplyMethod(c.move_to, lr + UP * i * 2 + RIGHT * j * 2), run_time=0.1)\n\n        def shoot(x, y):\n            self.play(ApplyMethod(scope.move_to, lr + UP * x * 2 + RIGHT * y * 2))\n            t[x * 5 + y].target = Circle(color=GRAY, fill_color=GRAY, fill_opacity=0.5)\n            t[x * 5 + y].target.move_to(lr + UP * x * 2 + RIGHT * y * 2)\n            t[x * 5 + y].target.scale(0.5)\n            scope.target = scope.copy()\n            scope.set_color(RED)\n            scope.scale(2)\n            self.play(MoveToTarget(t[x * 5 + y]), MoveToTarget(scope), run_time=0.5)\n            self.wait()\n            text = TextMobject('$(' + str(x) + ', ' + str(y) + ')$')\n            text.next_to(t[x * 5 + y], DOWN * 0.1)\n            self.play(FadeIn(text))\n        shoot(0, 1)\n        shoot(1, 4)\n        shoot(2, 0)\n        shoot(0, 3)"}]}
{"messages": [{"role": "user", "content": "Animate Chinese text \"\u4f60\u597d\u9e2d\" appearing, then surround it with a blue rectangle, scale the whole group, and finally transform the text to \"Hello!\" in green with the rectangle turning red."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass Fun(Scene):\n\n    def construct(self):\n        greet = TextMobject('\u4f60\u597d\u9e2d', color=WHITE)\n        rec = Rectangle(color=BLUE)\n        rec.surround(greet)\n        group1 = VGroup(greet, rec)\n        self.play(Write(greet))\n        self.wait()\n        self.play(FadeInFromLarge(rec, scale_factor=1.5))\n        self.wait()\n        greet.target = TextMobject('Hello!', color=GREEN)\n        greet.target.scale(2.5)\n        self.play(ApplyMethod(group1.scale, 2.5))\n        self.play(ApplyMethod(rec.set_color, RED), MoveToTarget(greet))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a number plane and wait for three seconds."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass mgird(Scene):\n\n    def construct(self):\n        gird = NumberPlane()\n        self.add(gird)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Create four red dots at the corners of the screen with corresponding text labels."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass corner(Scene):\n\n    def construct(self):\n        ul = Dot()\n        ur = Dot()\n        dr = Dot()\n        dl = Dot()\n        ul.to_corner(UL)\n        ul.set_color(RED)\n        ur.to_corner(UR)\n        ur.set_color(RED)\n        dl.to_corner(DL)\n        dl.set_color(RED)\n        dr.to_corner(DR)\n        dr.set_color(RED)\n        ult = TextMobject('UPANDLEFTPOINT')\n        urt = TextMobject('UPANDRIGHTPOINT')\n        drt = TextMobject('DOWNANDRIGHTPOINT')\n        dlt = TextMobject('DOWNANDLEFTPOINT')\n        ult.next_to(ul, RIGHT * 0.5 + DOWN * 0.5)\n        urt.next_to(ur, LEFT * 0.5 + DOWN * 0.5)\n        drt.next_to(dr, LEFT * 0.5 + UP * 0.5)\n        dlt.next_to(dl, RIGHT * 0.5 + UP * 0.5)\n        self.play(ShowCreation(ul), ShowCreation(ur), ShowCreation(dr), ShowCreation(dl))\n        self.wait(2)\n        self.play(Write(ult), Write(urt), Write(drt), Write(dlt))"}]}
{"messages": [{"role": "user", "content": "Demonstrate various text animation methods including FadeIn, ShowCreation, DrawBorderThenFill, Write, FadeOut, Uncreate, FadeInFromDown, and FadeOutAndShiftDown."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass PlayMethods(Scene):\n\n    def construct(self):\n        fade = TextMobject('Fade')\n        creation = TextMobject('ShowCreation')\n        border = TextMobject('Border')\n        write = TextMobject('Write')\n        fade.move_to(UP * 2)\n        creation.move_to(DOWN * 2)\n        border.move_to(LEFT * 2)\n        write.move_to(RIGHT * 2)\n        self.play(FadeIn(fade), ShowCreation(creation), DrawBorderThenFill(border), Write(write))\n        self.wait(2)\n        self.play(FadeOut(fade), Uncreate(creation))\n        self.wait(2)\n        self.play(FadeInFromDown(fade))\n        self.wait(2)\n        self.play(FadeOutAndShiftDown(fade))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display the word \"text\" and then animate it to change into the word \"HI!\" in red and shifted left."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass WriteText(Scene):\n\n    def construct(self):\n        t = TextMobject('text')\n        self.wait(2)\n        self.play(Write(t))\n        t.target = TextMobject('HI!')\n        t.target.set_color(RED)\n        t.target.shift(LEFT)\n        self.wait(2)\n        self.play(MoveToTarget(t), run_time=2)"}]}
{"messages": [{"role": "user", "content": "Arrange three text objects vertically, transform the top one into the middle one, then the middle one into the bottom one, and finally write all three text objects aligned to the left."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom project.utils.imports import *\nimport numpy\nimport math\n\nclass TextArray(Scene):\n\n    def construct(self):\n        text = TextMobject('text0', 'text1', 'text2')\n        text[0].move_to(UP * 2)\n        text[2].move_to(DOWN * 2)\n        self.wait(2)\n        self.play(Transform(text[0], text[1]))\n        self.wait(2)\n        self.play(Transform(text[1], text[2]))\n        self.wait(2)\n        text[0].move_to(LEFT)\n        text[1].move_to(LEFT)\n        text[2].move_to(LEFT)\n        self.play(Write(text[0]), Write(text[1]), Write(text[2]))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Explain the Rule of 72 by first showing its definition and examples, then deriving it mathematically and concluding with a thank you message."}, {"role": "assistant", "content": "from manim import *\nimport manim\n\nclass RuleOf72(Scene):\n\n    def construct(self):\n        t = Text('What Is \"Rule Of 72\" ?', gradient=(RED, ORANGE, BLUE, PURPLE), font_size=96)\n        self.play(Write(t))\n        self.play(Unwrite(t))\n        title = Title(f'It Is Finance Estimates')\n        equation = MathTex('\\\\text{Year Of Double} = \\\\frac{72}{\\\\text{Interest Rate}}')\n        self.play(Create(title))\n        self.play(Write(equation))\n        framebox = SurroundingRectangle(equation, buff=0.5)\n        self.play(Write(framebox))\n        self.wait(3)\n        self.clear()\n        example1 = MathTex('\\\\text{1. At 8\\\\% interest, your money takes } \\\\frac{72}{8} = 9 \\\\text{ years to double}')\n        example2 = MathTex('\\\\text{2. If GDP grows at 5\\\\% a year, economy doubles in } \\\\frac{72}{5} = 14 \\\\text{ years}')\n        example3 = MathTex('\\\\text{3. If inflation rates go from 2\\\\% to 3\\\\%, your money will lose half its value in 24 years instead of 36.}')\n        example1.scale(0.6)\n        example2.scale(0.6)\n        example3.scale(0.6)\n        example2.next_to(example1, DOWN)\n        example3.next_to(example2, DOWN)\n        self.play(Write(example1))\n        self.wait(1.5)\n        self.play(Write(example2))\n        self.wait(1.5)\n        self.play(Write(example3))\n        self.wait(2.5)\n        self.clear()\n        question = Text('But Why Is 72 ? ', t2c={'72': RED})\n        self.play(Create(question))\n        self.wait(2.0)\n        question_topleft = Text('But Why Is 72 ? ', t2c={'72': RED}).scale(0.7)\n        question_topleft.to_corner(UP + LEFT)\n        self.play(Transform(question, question_topleft))\n        self.wait()\n        t1 = Tex('Suppose we have \\\\$1 and a yearly interest rate R.\\nAfter one year we have:')\n        t2 = MathTex('\\\\rightarrow 1 * (1 + R)', color=YELLOW)\n        t3 = Tex(\"E.g at 10\\\\% interest, we'd have \\\\$1 * (1 + 0.1) = \\\\$1.10 at the end of year\")\n        t4 = Tex(\"After 2 years, we's have\")\n        t5 = MathTex('\\\\rightarrow 1 * (1 + R) * (1 + R) = 1 * (1 + R)^2', color=YELLOW)\n        t6 = MathTex('\\\\text{And at 10\\\\% interest, we have }\\\\$1 * (1.1)^2 = \\\\$1.21\\\\text{ at the end of year 2.}')\n        t7 = Tex('Extending this year after year, after N years we have')\n        t8 = MathTex('\\\\rightarrow 1 * (1 + R)^N', color=YELLOW)\n        x = VGroup(t1, t2, t3, t4, t5, t6, t7, t8).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7)\n        self.play(Write(x[0]))\n        self.wait()\n        self.play(Indicate(t2))\n        self.wait()\n        self.play(Write(x[2]))\n        self.wait()\n        self.play(Write(x[3]))\n        self.wait()\n        self.play(Indicate(x[4]))\n        self.wait()\n        self.play(Write(x[5]))\n        self.wait()\n        self.play(Write(x[6]))\n        self.wait()\n        self.play(Indicate(x[7]))\n        self.wait(3)\n        self.play(Unwrite(x))\n        self.clear()\n        q1 = Text('How long it takes to double?', t2c={'double': RED})\n        self.play(Create(q1))\n        self.wait()\n        q2 = Text('How long it takes to double?', t2c={'double': RED}).scale(0.7)\n        q2.to_corner(UP + LEFT)\n        self.play(Transform(q1, q2))\n        self.wait()\n        eq1 = MathTex('1 * (1 + R)^N = 2')\n        eq2 = MathTex('(1 + R)^N = 2')\n        eq3 = MathTex('ln((1 + R)^N) = ln(2) \\\\text{ (natural log of both sides)}')\n        eq4 = MathTex('N * ln(1 + R) = 0.693')\n        eq5 = MathTex('N * R = 0.693 \\\\text{ (For small R, } ln(1+R) \\\\approx R)')\n        eq6 = MathTex('N = 0.693 / R')\n        eq7 = MathTex('N = 69.3 / R\\\\% \\\\text{ (Multiply right hand side by 100)}', color=YELLOW_C)\n        eq8 = Text('69.3 is nice but not easily divisible. 72 is closeby, and have many more factors (2, 3, 4, 6, 12, ...)', t2c={'72': RED, '69.3': YELLOW}).scale(0.7)\n        eq9 = Text('So the rule of 72 it is', color=RED)\n        eq_group = VGroup(eq1, eq2, eq3, eq4, eq5, eq6, eq7, eq8, eq9).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7)\n        self.play(Indicate(eq1))\n        self.wait()\n        self.play(Indicate(eq2))\n        self.wait()\n        self.play(Indicate(eq3))\n        self.wait()\n        self.play(Indicate(eq4))\n        self.wait()\n        self.play(Indicate(eq5))\n        self.wait()\n        self.play(Indicate(eq6))\n        self.wait()\n        self.play(Indicate(eq7))\n        self.wait()\n        self.play(Indicate(eq8))\n        self.wait()\n        self.play(Indicate(eq9))\n        self.wait(3)\n        self.play(Unwrite(eq_group))\n        self.clear()\n        t = Text('Thanks for watching and happy learning!', gradient=(RED, BLUE, PURPLE))\n        self.play(Write(t))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the Black-Scholes formula and its components, highlighting each one."}, {"role": "assistant", "content": "from manim import *\nimport manim\n\nclass BlackScholesModel(Scene):\n\n    def construct(self):\n        eq1 = MathTex('C = N(d_1)S_t - N(d_2)Ke^{-rt}')\n        eq1.scale(2)\n        self.add(eq1)\n        framebox = SurroundingRectangle(eq1, buff=0.5)\n        self.add(framebox)\n        self.wait()\n        ask = Text('Do You Know Me?', color=RED, font_size=96)\n        self.remove(eq1)\n        self.play(Transform(framebox, ask))\n        self.wait(2)\n        self.clear()\n        eq1 = MathTex('C = N(d_1)S_t - N(d_2)Ke^{-rt}')\n        eq2 = MathTex('\\\\text{where } d_1 = \\\\frac{\\\\ln(\\\\frac{S_t}{K}) + (r + \\\\frac{\\\\sigma}{2})t}{\\\\sigma\\\\sqrt{t}}')\n        eq3 = MathTex('\\\\text{and } d_2 = d_1 - \\\\sigma\\\\sqrt{t}')\n        eq4 = MathTex('C = \\\\text{call option price}')\n        eq5 = MathTex('N = \\\\text{CDF of the normal distribution}')\n        eq6 = MathTex('S_t = \\\\text{spot price of an asset}')\n        eq7 = MathTex('K = \\\\text{strike price}')\n        eq8 = MathTex('r = \\\\text{risk-free interest rate}')\n        eq9 = MathTex('t = \\\\text{time to maturity}')\n        eq10 = MathTex('\\\\sigma = \\\\text{time to maturity}')\n        eq_group = VGroup(eq1, eq2, eq3, eq4, eq5, eq6, eq7, eq8, eq9, eq10).arrange(direction=DOWN, buff=0.36, aligned_edge=LEFT).scale(0.9)\n        eq1.scale(1.5)\n        self.add(eq1)\n        self.play(Circumscribe(eq1))\n        boxeq1 = SurroundingRectangle(eq1, buff=0.15)\n        self.play(Write(boxeq1))\n        self.wait()\n        self.play(Indicate(eq2))\n        self.wait()\n        self.play(Indicate(eq3))\n        self.wait()\n        self.play(Indicate(eq4))\n        self.wait()\n        self.play(Indicate(eq5))\n        self.wait()\n        self.play(Indicate(eq6))\n        self.wait()\n        self.play(Indicate(eq7))\n        self.wait()\n        self.play(Indicate(eq8))\n        self.wait()\n        self.play(Indicate(eq9))\n        self.wait()\n        self.play(Indicate(eq10))\n        self.wait()\n        self.wait(3)\n        self.remove(boxeq1)\n        t = Text('By DevPool', color=RED)\n        self.play(Transform(eq_group, t))\n        self.play(FocusOn(t))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate the expansion of $(a+b)^2$ into $a^2 + 2ab + b^2$ using geometric shapes and algebraic terms."}, {"role": "assistant", "content": "import numpy as np\nfrom manimlib import *\n\nclass Demoapluabcarre(Scene):\n    CONFIG = {'couleur_carre_a': YELLOW, 'couleur_carre_b': RED, 'couleur_rectangle_c': ORANGE, 'couleur_rectangle_d': ORANGE, 'grosseur_ligne': 1, 'opacite': 1}\n\n    def construct(self):\n        title = TextMobject('D\u00e9monstration de ', '$(a+b)^2$ ', '$= a^2 + 2ab + b^2$')\n        aplusb = TexMobject('(a+b)')\n        deuxab = TexMobject('2ab')\n        ab_1 = TexMobject('ab')\n        acarre = TexMobject('a^2')\n        bcarre = TexMobject('b^2')\n        ab_copie = ab_1.copy()\n        acarre.move_to([0, 3.1, 0])\n        bcarre.move_to([1.25, 3.08, 0])\n        ab_1.move_to([2.45, 3.05, 0])\n        ab_copie.move_to([3.85, 3.05, 0])\n        a_1 = TexMobject('a')\n        plus = TexMobject('+')\n        egal = TexMobject('=')\n        aplusbcarre = TexMobject('(a+b)^2')\n        self.play(Write(title))\n        self.wait(2)\n        vec_1 = np.array([-2.3, 3, 0])\n        egal.move_to([-1, 3, 0])\n        a_1.move_to(vec_1)\n        aplusb.move_to(vec_1)\n        a_1.move_to(vec_1)\n        aplusbcarre.move_to([-2.3, 3.05, 0])\n        m = np.array([-2, 1.5, 0])\n        n = np.array([2, 1.5, 0])\n        p = np.array([2, -2.5, 0])\n        q = np.array([-2, -2.5, 0])\n        a = np.array([-2, 0.5, 0])\n        b = np.array([1, 0.5, 0])\n        c = np.array([1, -2.5, 0])\n        d = np.array([1, 1.5, 0])\n        e = np.array([2, 0.5, 0])\n        ligne_a = Line(start=q, end=c, color=self.couleur_carre_a)\n        ligne_b = Line(start=c, end=p, color=self.couleur_rectangle_c)\n        cote_a = TexMobject('a')\n        cote_b = TexMobject('b')\n        cote_abis = TexMobject('a')\n        cote_bbis = TexMobject('b')\n        coord_cote_a = np.array([-2.5, -1, 0])\n        coord_cote_b = np.array([-2.5, 1, 0])\n        coord_cote_abis = np.array([-0.5, -3, 0])\n        coord_cote_bbis = np.array([1.5, -3, 0])\n        cote_a.move_to(coord_cote_a)\n        cote_b.move_to(coord_cote_b)\n        cote_abis.move_to(coord_cote_abis)\n        cote_bbis.move_to(coord_cote_bbis)\n        self.play(FadeOut(title[0]), FadeOut(title[2]), title[1].move_to, vec_1, Transform(title[1], a_1), Write(cote_abis), ShowCreation(ligne_a))\n        self.wait()\n        self.play(Write(cote_bbis), ShowCreation(ligne_b), Transform(title[1], aplusb))\n        self.wait()\n        carre_a = Polygon(a, b, c, q, color=self.couleur_carre_a).set_fill(self.couleur_carre_a, self.opacite).set_stroke(None, self.grosseur_ligne)\n        carre_b = Polygon(d, n, e, b, color=self.couleur_carre_b).set_fill(self.couleur_carre_b, self.opacite).set_stroke(None, self.grosseur_ligne)\n        rectangle_c = Polygon(m, d, b, a, color=self.couleur_rectangle_c).set_fill(self.couleur_rectangle_c, self.opacite).set_stroke(None, self.grosseur_ligne)\n        rectangle_d = Polygon(b, e, p, c, color=self.couleur_rectangle_d).set_fill(self.couleur_rectangle_d, self.opacite).set_stroke(None, self.grosseur_ligne)\n        self.play(ShowCreation(carre_a), ShowCreation(carre_b), ShowCreation(rectangle_c), ShowCreation(rectangle_d), Write(cote_a), Write(cote_b), ReplacementTransform(title[1], aplusbcarre))\n        self.wait()\n        groupe_a_copie = carre_a.copy()\n        groupe_b_copie = carre_b.copy()\n        groupe_c_copie = rectangle_c.copy()\n        groupe_d_copie = rectangle_d.copy()\n        plus_1 = plus.copy()\n        plus_1.move_to([0.76, 3, 0])\n        plus_2 = plus.copy()\n        plus_2.move_to([1.72, 3, 0])\n        plus_3 = plus.copy()\n        plus_3.move_to([3.2, 3, 0])\n        self.play(Write(egal), groupe_a_copie.move_to, [0, 3, 0], groupe_a_copie.scale, 0.25, Write(plus_1))\n        self.play(groupe_b_copie.move_to, [1.25, 3, 0], groupe_b_copie.scale, 0.25, Write(plus_2))\n        self.play(groupe_c_copie.move_to, [2.45, 3, 0], groupe_c_copie.scale, 0.25, Write(plus_3))\n        self.play(groupe_d_copie.move_to, [3.7, 3, 0], groupe_d_copie.scale, 0.25)\n        self.wait()\n        cote_a_copie = cote_a.copy()\n        cote_b_copie = cote_b.copy()\n        cote_abis_copie = cote_abis.copy()\n        cote_bbis_copie = cote_bbis.copy()\n        cote_a_copiie = cote_a_copie.copy()\n        cote_b_copiie = cote_b_copie.copy()\n        cote_abis_copiie = cote_abis_copie.copy()\n        cote_bbis_copiie = cote_bbis_copie.copy()\n        self.play(cote_a_copie.move_to, [-0.12, 3, 0], cote_abis_copie.move_to, [0.12, 3, 0])\n        self.play(Transform(groupe_a_copie, acarre), FadeOut(cote_a_copie), FadeOut(cote_abis_copie))\n        self.play(cote_b_copie.move_to, [1.13, 3, 0], cote_bbis_copie.move_to, [1.37, 3, 0])\n        self.play(Transform(groupe_b_copie, bcarre), FadeOut(cote_b_copie), FadeOut(cote_bbis_copie))\n        self.play(cote_abis_copiie.move_to, [2.33, 3, 0], cote_b_copiie.move_to, [2.57, 3.07, 0])\n        self.play(Transform(groupe_c_copie, ab_1), FadeOut(cote_abis_copiie), FadeOut(cote_b_copiie))\n        self.play(cote_bbis_copiie.move_to, [3.58, 3.07, 0], cote_a_copiie.move_to, [3.82, 3, 0])\n        self.play(Transform(groupe_d_copie, ab_copie), FadeOut(cote_bbis_copiie), FadeOut(cote_a_copiie))\n        self.wait()\n        formule_f = TexMobject('(a+b)^2 = a^2 + 2ab + b^2')\n        formule_f.move_to([0, 3, 0])\n        groupe_bis = VGroup(groupe_a_copie, groupe_b_copie, groupe_c_copie, groupe_d_copie, plus_1, plus_2, plus_3, egal, aplusbcarre)\n        self.play(Transform(groupe_bis, formule_f))\n        self.remove()\n        fin = TextMobject('Voil\u00e0 :)')\n        self.wait()\n        self.play(Write(fin))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the action of an Eisenstein series of weight 10 on the complex plane using a dynamically changing matrix."}, {"role": "assistant", "content": "from manim import *\nfrom numba import njit\nfrom colorsys import hls_to_rgb\nfrom cmath import phase\nfrom typing import Sequence, Callable\n\nclass EisensteinSeriesG10(Scene):\n\n    def construct(self):\n        a, b, c, d = (ValueTracker(1), ValueTracker(0), ValueTracker(0), ValueTracker(1))\n        screen_rect = Rectangle(height=config.frame_height)\n        im = always_redraw(lambda: ImageMobject(plot_eisenstein_series(k=10, max_term_order=10, matrix_for_action=np.array([[a.get_value(), b.get_value()], [c.get_value(), d.get_value()]]))).match_height(screen_rect))\n        self.add(im)\n        self.wait()\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the output of a complex function as an image on the screen."}, {"role": "assistant", "content": "from manim import *\nfrom numba import njit\nfrom colorsys import hls_to_rgb\nfrom cmath import phase\nfrom typing import Sequence, Callable\n\nclass PlotComplexFunctions(Scene):\n\n    def construct(self):\n\n        def func(z: complex) -> complex:\n            try:\n                return np.exp(-1 / z)\n            except ZeroDivisionError:\n                return 0\n        RATIO = 1920 / 1080\n        x_min, x_max = (-2, 2)\n        num = 1000\n        y_min, y_max = (-2, 2)\n        rect = Rectangle(height=config.frame_height)\n        im = ImageMobject(plot_complex_function(func, real_range=[x_min * RATIO, x_max * RATIO, np.abs(x_max - x_min) / num], imag_range=[y_min, y_max, np.abs(y_max - y_min) / num], h_factor=0.1))\n        im.match_height(rect).move_to(ORIGIN)\n        self.add(im)"}]}
{"messages": [{"role": "user", "content": "Animate a 3D Klein bottle with axes and camera rotation."}, {"role": "assistant", "content": "\n\nclass BouteilleKlein(ThreeDScene):\n\n    def construct(self):\n        self.set_camera_orientation(phi=80 * DEGREES, theta=-100 * DEGREES, distance=10)\n\n        def f_klein(u, v):\n            a, b, c = (3, 4, 2)\n            r = c * (1 - np.cos(u) / 2)\n            if u <= np.pi:\n                x = (a * (1 + np.sin(u)) + r * np.cos(v)) * np.cos(u)\n                y = (b + r * np.cos(v)) * np.sin(u)\n            else:\n                x = a * (1 + np.sin(u)) * np.cos(u) - r * np.cos(v)\n                y = b * np.sin(u)\n            z = r * np.sin(v)\n            return np.array([0.5 * x, 0.75 * y, 0.5 * z])\n        axes = ThreeDAxes()\n        self.begin_ambient_camera_rotation(rate=0.2, about='theta')\n        BouteilleKlein = ParametricSurface(f_klein, u_min=0, u_max=2 * np.pi, v_min=0, v_max=2 * np.pi)\n        BouteilleKlein.center().rotate(PI / 8, np.array([1, 0, 0])).shift(np.array([0, 0, 0.8]))\n        self.play(Create(axes), Create(BouteilleKlein))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Create an animated introduction sequence displaying a stack of theorem boxes fading in, followed by a \"For specialists!\" text appearing with a dramatic entrance, and finally a covering rectangle animating."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass Introduction(Scene):\n\n    def construct(self):\n        group_of_thm_boxes = VGroup(*[TheoremObject(k, rgb_to_hex((0, k * 0.1, 1 - 2 * k * 0.1)), WHITE) for k in range(1, 6)]).add(MathTex('\\\\vdots'))\n        for k in range(len(group_of_thm_boxes) - 1):\n            group_of_thm_boxes[k + 1].next_to(group_of_thm_boxes[k], DOWN, buff=0.3)\n        group_of_thm_boxes.move_to(ORIGIN).scale(0.9)\n        for_specialists_text = Tex('For specialists !', color=RED).scale(2.5).rotate(-PI / 4)\n        for_specialists_text.set_stroke(BLACK, width=2)\n        list_of_fade_in_anim = [FadeIn(group_of_thm_boxes[k].text, shift=UP) for k in range(len(group_of_thm_boxes) - 1)]\n        list_of_fade_in_anim.append(FadeIn(group_of_thm_boxes[-1], shift=UP))\n        self.play(AnimationGroup(*list_of_fade_in_anim, run_time=3.5, lag_ratio=0.5), AnimationGroup(*[DrawBorderThenFill(group_of_thm_boxes[k].rectangle) for k in range(len(group_of_thm_boxes) - 1)], run_time=3, lag_ratio=0.5))\n        self.wait(3)\n        self.play(FadeIn(for_specialists_text, shift=100 * Line(for_specialists_text.get_center(), np.array([0, 0, -1])).get_unit_vector()), run_time=2)\n        self.wait(3)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show the Pythagorean theorem and then animate its rearrangement, leading to a question mark over a new section."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass OldTheorems(MovingCameraScene):\n\n    def construct(self):\n        screen_1 = Rectangle(height=5.5 * config.frame_height / config.frame_width, width=5.5).set_fill(opacity=0).set_stroke(YELLOW, width=4)\n        screen_1_label = Tex('old, well-known').next_to(screen_1, DOWN)\n        screen_2 = screen_1.copy().next_to(screen_1, RIGHT, buff=1)\n        screen_2_label = Tex('relatively unknown').next_to(screen_2, DOWN)\n        VGroup(screen_1, screen_1_label, screen_2, screen_2_label).move_to(ORIGIN)\n        question_marks = Tex('???').scale(2).move_to(screen_2)\n        square = Polygon(ORIGIN, 3.5 * RIGHT, 3.5 * UR, 3.5 * UP, color=WHITE)\n        triangle_1 = Polygon(ORIGIN, 2 * RIGHT, 1.5 * UP).set_fill(BLUE, opacity=1).set_stroke(width=0)\n        triangle_2 = triangle_1.copy().rotate(PI / 2, about_point=ORIGIN).shift(3.5 * RIGHT)\n        triangle_3 = triangle_2.copy().rotate(PI / 2, about_point=3.5 * RIGHT).shift(3.5 * UP)\n        triangle_4 = triangle_3.copy().rotate(PI / 2, about_point=3.5 * UR).shift(3.5 * LEFT)\n        c_squarred = MathTex('c^2').move_to(square)\n        a_squarred = MathTex('a^2').move_to(2.75 * UR)\n        b_squarred = MathTex('b^2').move_to(UR)\n        pythagoras_thm = VGroup(square, triangle_1, triangle_2, triangle_3, triangle_4, c_squarred, a_squarred, b_squarred)\n        pythagoras_thm.move_to(screen_1).scale(0.75 * screen_1.height / pythagoras_thm.height)\n        triangle_1.shift(0.01 * UR)\n        triangle_2.shift(0.01 * UL)\n        triangle_3.shift(0.01 * DL)\n        triangle_4.shift(0.01 * DR)\n        square.set_z_index(VGroup(triangle_1, triangle_2, triangle_3, triangle_4).z_index + 1)\n        self.play(Create(screen_1), Create(square), AnimationGroup(*[DrawBorderThenFill(triangle) for triangle in VGroup(triangle_1, triangle_2, triangle_3, triangle_4)], lag_ratio=0.5), Write(screen_1_label), run_time=3)\n        self.wait()\n        self.play(Write(c_squarred))\n        self.wait()\n        a_length, b_length = (triangle_1.get_vertices()[2][1] - triangle_1.get_vertices()[0][1] - 0.01, triangle_1.get_vertices()[1][0] - triangle_1.get_vertices()[0][0] - 0.01)\n        c_length = np.sqrt(a_length ** 2 + b_length ** 2)\n        c_vec = (b_length * RIGHT + a_length * DOWN) / np.linalg.norm(b_length * RIGHT + a_length * DOWN)\n        self.play(triangle_1.animate.shift(b_length * UP), triangle_3.animate.shift(a_length * LEFT), triangle_4.animate.shift(c_length * c_vec), FadeOut(c_squarred), run_time=2)\n        self.wait()\n        self.play(Write(a_squarred), Write(b_squarred))\n        self.wait()\n        self.play(Create(screen_2), Write(screen_2_label), Write(question_marks), run_time=3)\n        self.wait()\n        self.play(self.camera.frame.animate.move_to(screen_2).scale((screen_2.height - 0.05) / config.frame_height), FadeOut(question_marks), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize Morley's Trisector Theorem by constructing a triangle, its angle trisectors, and the inner equilateral triangle, then animating the vertices of the outer triangle and observing the effect on the inner figure."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass MorleysTheorem(Scene):\n\n    def construct(self):\n        z_1, z_2, z_3 = (ComplexValueTracker(complex(0, 3)), ComplexValueTracker(complex(-1, -3)), ComplexValueTracker(complex(3, -3)))\n        morley_triangle = always_redraw(lambda: MorleyTriangle([z_1.get_value(), z_2.get_value(), z_3.get_value()]))\n        self.wait()\n        self.play(AnimationGroup(*[Create(VGroup(side, dot)) for side, dot in zip(morley_triangle.outer_lines, morley_triangle.outer_dots)], lag_ratio=0.4, run_time=3), AnimationGroup(*[Write(label) for label in morley_triangle.outer_labels], lag_ratio=0.4, run_time=3))\n        self.wait()\n        self.play(*[Create(angle) for angle in morley_triangle.outer_angle], *[Write(label) for label in morley_triangle.outer_angle_labels], run_time=2)\n        self.wait()\n        self.play(*[Create(trisector[0]) for trisector in morley_triangle.trisectors], *[Create(trisector[1]) for trisector in morley_triangle.trisectors], run_time=2)\n        self.play(*[Create(morley_triangle.inner_lines)], run_time=2)\n        self.play(FadeIn(morley_triangle.inner_dots), *[Write(morley_triangle.inner_labels)], run_time=1.5)\n        self.wait(2)\n        self.add(morley_triangle)\n        self.remove(morley_triangle.outer_angle, morley_triangle.outer_angle_labels, morley_triangle.outer_dots, morley_triangle.outer_lines, morley_triangle.outer_labels, morley_triangle.inner_dots, morley_triangle.inner_lines, morley_triangle.inner_labels)\n        self.play(z_1.animate.set_value(complex(2, 3)), run_time=2)\n        self.wait()\n        self.play(z_1.animate.set_value(complex(3, 1)), z_2.animate.set_value(complex(-3, 1)), z_3.animate.set_value(complex(0, -2)), run_time=2)\n        self.wait()\n        self.play(z_3.animate.set_value(complex(-2, -2)), run_time=2)\n        self.play(z_3.animate.set_value(complex(2, -2)), run_time=2)\n        self.wait(3)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display portraits of Frank Morley and Alain Connes with their names and borders, then fade them in with an accompanying covering rectangle animation."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass ConnesProofIntro(Scene):\n\n    def construct(self):\n        morley_svg = SVGMobject('Frank_Morley.svg').scale(3)\n        morley_border = SurroundingRectangle(morley_svg, buff=0)\n        morley_label = Tex('Frank \\\\textsc{Morley}').next_to(morley_svg, DOWN)\n        connes_svg = SVGMobject('Alain_Connes.svg').scale(3)\n        connes_border = SurroundingRectangle(connes_svg, buff=0)\n        connes_label = Tex('Alain \\\\textsc{Connes}').next_to(connes_svg, DOWN)\n        morley = Group(morley_svg, morley_border, morley_label)\n        connes = Group(connes_svg, connes_border, connes_label).next_to(morley, RIGHT, buff=0.5)\n        Group(morley, connes).move_to(ORIGIN)\n        self.wait()\n        self.play(AnimationGroup(*[FadeIn(morley_part) for morley_part in morley_svg], run_time=5, lag_ratio=0.3), AnimationGroup(*[FadeIn(connes_part) for connes_part in connes_svg], run_time=5, lag_ratio=0.3), Create(morley_border), Create(connes_border), Write(morley_label), Write(connes_label), run_time=5)\n        self.wait(10)\n        self.play(FadeIn(CoveringRectangle()))"}]}
{"messages": [{"role": "user", "content": "Display a Morley triangle related to group theory and Alain Connes' proof of the generalized Morley theorem."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass HowToStart(Scene):\n\n    def construct(self):\n        tex_1 = Tex('Groups \\\\\\\\ Complex numbers \\\\\\\\ Symetries \\\\\\\\ Linear maps', tex_environment='flushleft').scale(2)\n        tex_2 = Tex('How to start ?').scale(3)\n        mt = MorleyTriangle(vertices=[complex(3, 3), complex(-2, 1), complex(0, -3)]).scale(0.5)\n        general_framework = Rectangle(color=RED).scale(1.25).next_to(mt, RIGHT, buff=3)\n        general_framework_label = Tex('Field and group theory', color=RED).next_to(general_framework, UP)\n        VGroup(mt, general_framework, general_framework_label).move_to(ORIGIN)\n        arrow = Arrow(mt.get_center() + 1.25 * mt.width / 2 * RIGHT, general_framework.get_center() + 1.25 * general_framework.width / 2 * LEFT, color=YELLOW)\n        arrow_label = Tex(\"Alain \\\\textsc{Connes}' \\\\\\\\ proof\").scale(0.65).next_to(arrow, UP)\n        self.wait()\n        self.play(Write(tex_1), run_time=5)\n        self.wait()\n        self.play(FadeOut(tex_1))\n        self.wait(2)\n        self.play(Write(tex_2), run_time=2)\n        self.wait(3)\n        self.play(ReplacementTransform(tex_2, mt))\n        self.wait()\n        self.play(AnimationGroup(AnimationGroup(GrowArrow(arrow), Write(arrow_label), lag_ratio=0), AnimationGroup(Create(general_framework), Write(general_framework_label), lag_ratio=0), lag_ratio=0.5), run_time=3)\n        self.play(ReplacementTransform(mt.copy(), Tex(\"Generalized \\\\textsc{Morley}' \\\\\\\\ theorem\").move_to(general_framework).scale(0.9)), run_time=1.5)\n        self.wait(2)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display an SVG proof, then fade it out to reveal an animated triangle with angles and implication symbols."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass ConwayProof(Scene):\n\n    def construct(self):\n        svg = SVGMobject('Conway_proof.svg').scale(2.55)\n        channel_name = Tex('video by Exponentielle Hippie').scale(0.9).next_to(svg, DOWN, buff=0.5)\n        border = SurroundingRectangle(svg, buff=0)\n        Group(svg, channel_name, border).move_to(ORIGIN)\n        triangle_shape = Triangle().scale(2).rotate(PI / 4)\n        vertices = triangle_shape.get_vertices()\n        angles = VGroup(Angle(Line(vertices[0], vertices[1]), Line(vertices[0], vertices[2])), Angle(Line(vertices[1], vertices[2]), Line(vertices[1], vertices[0])), Angle(Line(vertices[2], vertices[0]), Line(vertices[2], vertices[1])))\n        triangle = VGroup(triangle_shape, angles)\n        equivalent_sign = MathTex('\\\\iff').scale(3).next_to(triangle, RIGHT, buff=0.5)\n        dots = MathTex('\\\\hdots').scale(3).next_to(equivalent_sign, RIGHT, buff=0.5)\n        VGroup(triangle, equivalent_sign, dots).move_to(ORIGIN)\n        self.wait()\n        self.play(FadeIn(svg), Create(border), Write(channel_name), run_time=2)\n        self.wait(4)\n        self.play(FadeOut(*[part for part in svg], border), Unwrite(channel_name))\n        self.wait(4)\n        self.play(AnimationGroup(Create(triangle), Write(equivalent_sign), Write(dots), lag_ratio=0.4, run_time=3))\n        self.wait(2)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the geometric representation of complex numbers, starting with a triangle and its labels, followed by the complex number $j$ and its algebraic form, and concluding with an animation of a point moving on a circle representing its exponential form."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass ComplexNumbers1(ZoomedScene):\n\n    def construct(self):\n        plane = ComplexPlane(background_line_style={'stroke_opacity': 0.5}).add_coordinates()\n        triangle = Triangle()\n        triangle.match_height(Line(plane.c2p(0, 0), plane.c2p(0, 1.5))).move_to(plane.c2p(0, 0)).shift(1 / 4 * plane.c2p(1, 0)).rotate(-PI / 2)\n        labels = VGroup(MathTex('a').rotate(-PI / 12).move_to(triangle.get_vertices()[0] + 0.3 * RIGHT), MathTex('b').rotate(-PI / 12).move_to(triangle.get_vertices()[1] + 0.3 * np.array([-1 / 2, np.sqrt(3) / 2, 0])), MathTex('c').rotate(-PI / 12).move_to(triangle.get_vertices()[2] + 0.3 * np.array([-1 / 2, -np.sqrt(3) / 2, 0])))\n        VGroup(triangle, labels).rotate(PI / 12).scale(1.4).shift(2.2 * UP + 3 * RIGHT)\n        j = Dot(plane.c2p(-1 / 2, np.sqrt(3) / 2), color=YELLOW).set_z_index(plane.z_index + 4)\n        j_label = MathTex('j = -\\\\frac{1}{2} + i\\\\frac{\\\\sqrt{3}}{2}', color=BLUE).scale(0.75).next_to(j, UL, buff=MED_SMALL_BUFF).shift(0.25 * DOWN)\n        j_label_bis = MathTex('= ', 'e^{\\\\frac{2i\\\\pi}{3}}', color=BLUE).scale(0.75)\n        j_label_bis[0].next_to(j_label[0][1], DOWN, buff=0.75)\n        j_label_bis[1].next_to(j_label_bis[0], RIGHT).shift(0.1 * UP)\n        j_label_background = BackgroundRectangle(j_label, buff=SMALL_BUFF).set_z_index(plane.z_index + 2)\n        j_label_background_bis = BackgroundRectangle(VGroup(j_label, j_label_bis), buff=SMALL_BUFF).set_z_index(plane.z_index + 2)\n        VGroup(j_label, j_label_bis).set_z_index(j_label_background.z_index + 1)\n        dashed_lines = VGroup(DashedLine(start=plane.c2p(-1 / 2, 0), end=plane.c2p(-1 / 2, np.sqrt(3) / 2), color=BLUE), DashedLine(start=plane.c2p(0, np.sqrt(3) / 2), end=plane.c2p(-1 / 2, np.sqrt(3) / 2), color=BLUE))\n        j.set_z_index(plane.z_index + 3)\n        equation = MathTex('a + bj + cj^2 = 0')\n        equation_background = BackgroundRectangle(equation, fill_opacity=0.75, buff=SMALL_BUFF)\n        equation.set_z_index(equation_background.z_index + 1)\n        VGroup(equation, equation_background).move_to(plane.c2p(-3.5, -2)).scale(1.5)\n        link_arrow = CurvedDoubleArrow(equation.get_center() + 3.25 * RIGHT, triangle.get_center() + 1.5 * DOWN, color=YELLOW)\n        link_text = Tex('geometry -- algebra \\\\\\\\ link').next_to(link_arrow.point_from_proportion(0.5), DR)\n        link_text_background = BackgroundRectangle(link_text, fill_opacity=0.75, buff=SMALL_BUFF)\n        link_text.set_z_index(link_text_background.z_index + 1)\n        self.wait()\n        self.play(FadeIn(plane))\n        self.wait(2)\n        self.play(AnimationGroup(Create(triangle), AnimationGroup(*[Write(label) for label in labels], lag_ratio=0), lag_ratio=0.3, run_time=3))\n        self.wait(2)\n        self.play(AnimationGroup(*[Wiggle(label, scale_value=1.25, rotation_angle=0.02 * TAU) for label in labels], lag_ratio=0.5, run_time=4))\n        self.wait(2)\n        self.play(Write(equation), FadeIn(equation_background), run_time=2)\n        self.wait(2)\n        self.play(FadeIn(j), Write(j_label), FadeIn(j_label_background), Create(dashed_lines), run_time=2)\n        self.wait(5)\n        self.play(Create(link_arrow), run_time=2)\n        self.play(Write(link_text), FadeIn(link_text_background), run_time=2)\n        self.wait(2)\n        self.play(FadeOut(triangle, *labels, equation, equation_background, link_arrow, link_text, link_text_background))\n        self.wait(6)\n        self.play(self.camera.frame.animate.scale(0.5).shift(0.4 * UP))\n        self.wait(2)\n        self.play(Wiggle(dashed_lines[0], scale_value=1.25, rotation_angle=0.02 * TAU), Wiggle(dashed_lines[1], scale_value=1.25, rotation_angle=0.02 * TAU))\n        theta = ValueTracker(0.01)\n        exponential_form = always_redraw(lambda: Dot(plane.c2p(np.cos(theta.get_value()), np.sin(theta.get_value())), color=YELLOW).set_z_index(plane.z_index + 4))\n        module_line = always_redraw(lambda: Line(plane.c2p(0, 0), plane.c2p(np.cos(theta.get_value()), np.sin(theta.get_value())), color=BLUE).set_z_index(plane.z_index + 3))\n        module_line_label = MathTex('|j|', color=BLUE).scale(0.6).add_updater(lambda label: label.move_to(plane.c2p(np.cos(theta.get_value()), np.sin(theta.get_value())) / 2 + 0.25 * np.array([-np.sin(theta.get_value()), np.cos(theta.get_value()), 0.0])), call_updater=True)\n        module_line_label_background = BackgroundRectangle(module_line_label, fill_opacity=0.75)\n        module_line_label.set_z_index(module_line_label_background.z_index + 1)\n        module_line_label_background.add_updater(lambda rect: rect.move_to(plane.c2p(np.cos(theta.get_value()), np.sin(theta.get_value())) / 2 + 0.25 * np.array([-np.sin(theta.get_value()), np.cos(theta.get_value()), 0.0])))\n        argument_angle = always_redraw(lambda: Angle(Line(plane.c2p(0, 0), plane.c2p(1, 0)), Line(plane.c2p(0, 0), plane.c2p(np.cos(theta.get_value()), np.sin(theta.get_value()))), color=YELLOW).set_z_index(plane.z_index + 2) if theta.get_value() != 0 else Line().scale(0))\n        argument_angle_label = MathTex('\\\\mathrm{arg}(j)', color=YELLOW).add_updater(lambda label: label.move_to(Angle(Line(plane.c2p(0, 0), plane.c2p(1, 0)), Line(plane.c2p(0, 0), plane.c2p(np.cos(theta.get_value()), np.sin(theta.get_value()))), radius=0.4 + 0.25).point_from_proportion(0.5)).scale_to_fit_height(0.2 * 3 / (2 * PI) * theta.get_value()).set_z_index(plane.z_index + 3), call_updater=True)\n        argument_angle_label_background = BackgroundRectangle(MathTex('arg(j)'), fill_opacity=0.75)\n        argument_angle_label.set_z_index(argument_angle_label_background.z_index + 1)\n        argument_angle_label_background.add_updater(lambda rect: rect.move_to(Angle(Line(plane.c2p(0, 0), plane.c2p(1, 0)), Line(plane.c2p(0, 0), plane.c2p(np.cos(theta.get_value()), np.sin(theta.get_value()))), radius=0.4 + 0.25).point_from_proportion(0.5)).scale_to_fit_height(0.3 * 3 / (2 * PI) * theta.get_value()).set_z_index(plane.z_index + 2), call_updater=True)\n        self.play(Create(module_line), FadeIn(exponential_form, shift=RIGHT), Write(module_line_label), FadeIn(module_line_label_background), run_time=2)\n        self.wait()\n        self.play(Wiggle(module_line, scale_value=1.25, rotation_angle=0.02 * TAU))\n        self.wait()\n        self.add(argument_angle, argument_angle_label)\n        self.play(theta.animate.set_value(2 * PI / 3), run_time=2)\n        self.wait()\n        self.play(Wiggle(argument_angle, scale_value=1.25, rotation_angle=0.02 * TAU))\n        self.wait()\n        self.play(Write(j_label_bis), Transform(j_label_background, j_label_background_bis), run_time=1.5)\n        self.wait(5)\n        plane_copy = plane.copy().set_z_index(plane.z_index + 1)\n        plane_copy.remove(plane_copy.coordinate_labels)\n        self.play(Rotate(plane_copy, 2 * PI / 3, about_point=plane.c2p(0, 0)), plane.animate.set_opacity(0.5), run_time=2)\n        self.wait()\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize complex numbers, their polar and Cartesian representations, and the effect of multiplication by a complex number using animated transformations and number planes."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass ComplexNumbers2(Scene):\n\n    def construct(self):\n        tex_env = TexTemplate().add_to_preamble('\\\\usepackage{mathrsfs}')\n        rightarrow_tex = MathTex('\\\\longrightarrow')\n        C_tex = MathTex('\\\\mathbb{C}').next_to(rightarrow_tex, LEFT, buff=MED_LARGE_BUFF)\n        direct_similitudes = MathTex('\\\\mathscr{S}_{+}(\\\\mathbb{C})', tex_template=tex_env).next_to(rightarrow_tex, RIGHT, buff=MED_LARGE_BUFF)\n        tex_group = VGroup(rightarrow_tex, C_tex, direct_similitudes).scale(2)\n        C_plane_left = NumberPlane(x_range=[-6.01, 6.01], y_range=[-4.01, 4.01]).scale(0.45).move_to(config.frame_width / 4 * LEFT)\n        C_plane_right = C_plane_left.copy().move_to(config.frame_width / 4 * RIGHT)\n        mapsto_tex_planes = MathTex('\\\\longmapsto')\n        tex_group.set_z_index(C_plane_left.z_index + 1)\n        mapsto_tex = MathTex('\\\\longmapsto').to_edge(DOWN, buff=0.75)\n        z_tex = MathTex('z', color=YELLOW).next_to(C_plane_left, DOWN).to_edge(DOWN, buff=0.75)\n        z_exp_tex = MathTex('|z|', 'e^{i\\\\mathrm{arg}(z)}').move_to(z_tex).shift(0.1 * UP)\n        z_exp_tex_bis = MathTex('r', 'e^{i\\\\theta}').move_to(z_tex).shift(0.145 * UP + 0.3 * LEFT)\n        z_exp_tex_bis[1][0:2].move_to(z_exp_tex[1][0:2])\n        VGroup(z_exp_tex[0], z_exp_tex_bis[0]).set_color(BLUE)\n        VGroup(z_exp_tex[1][2:], z_exp_tex_bis[1][2]).set_color(RED)\n        z_exp_tex_bis_target = z_exp_tex_bis.copy()\n        double_arrow_tex = MathTex('\\\\leftrightarrow').next_to(z_exp_tex_bis_target, RIGHT)\n        matrix_tex = MathTex('r\\\\begin{pmatrix} \\\\cos{(\\\\theta)} & -\\\\sin{(\\\\theta)} \\\\\\\\ \\\\sin{(\\\\theta)} & \\\\cos{(\\\\theta)} \\\\end{pmatrix}').scale(0.75)\n        matrix_tex[0][0].set_color(BLUE).scale(1 / 0.75)\n        VGroup(matrix_tex[0][6], matrix_tex[0][13], matrix_tex[0][19], matrix_tex[0][25]).set_color(RED)\n        matrix_tex.next_to(double_arrow_tex, RIGHT)\n        VGroup(z_exp_tex_bis_target, double_arrow_tex, matrix_tex).move_to(z_tex).to_edge(DOWN)\n        z_exp_tex_bis_target.shift(0.1 * UP)\n        re_it_copy = z_exp_tex_bis.copy()\n        func_tex = MathTex('f_z : w \\\\mapsto ', 'z', 'w').next_to(C_plane_right, DOWN).to_edge(DOWN, buff=0.75)\n        func_tex_exp = MathTex('f_z : w \\\\mapsto ', 're^{i\\\\theta}', 'w')\n        VGroup(func_tex[0][1], func_tex[1], func_tex_exp[0][1]).set_color(YELLOW)\n        func_tex_exp[1][0].set_color(BLUE)\n        func_tex_exp[1][3].set_color(RED)\n        func_tex_exp[0].move_to(func_tex[0])\n        func_tex_exp[1].next_to(func_tex_exp[0], RIGHT)\n        func_tex_exp[2].next_to(func_tex_exp[1], RIGHT, buff=SMALL_BUFF)\n        func_tex_exp[1].shift(0.1 * UP)\n        label_f_1 = MathTex('z = f_z(1)').scale(0.75).next_to(C_plane_right.c2p(1, 1), UR).set_z_index(C_plane_left.z_index + 2)\n        label_f_1[0][0:4:3].set_color(YELLOW)\n        label_f_1_rect = BackgroundRectangle(label_f_1, buff=SMALL_BUFF).set_z_index(label_f_1.z_index - 1)\n        rectangle = SurroundingRectangle(C_plane_right, buff=0).stretch(0.863, 0)\n        background = Difference(Rectangle(height=config.frame_height, width=config.frame_width), rectangle).set_fill(BLACK, opacity=1).set_stroke(width=0).set_z_index(-1)\n        z_1 = Dot(C_plane_left.c2p(1, 1), color=YELLOW)\n        z_2 = Dot(C_plane_left.c2p(-0.5, 2), color=YELLOW)\n        z_3 = Dot(C_plane_left.c2p(-2, -3), color=YELLOW)\n        z_group = VGroup(z_1, z_2, z_3)\n        z_1_copy = z_1.copy().set_z_index(C_plane_right.z_index + 2)\n        z_2_copy = z_2.copy().set_z_index(C_plane_right.z_index + 2)\n        z_3_copy = z_3.copy().set_z_index(C_plane_right.z_index + 2)\n        plane_copy_group = []\n        for z in z_group:\n            plane = NumberPlane(x_range=[-10.01, 10.01], y_range=[-10.01, 10.01]).scale(0.45).move_to(config.frame_width / 4 * RIGHT).set_z_index(background.z_index - 1)\n            pos = C_plane_left.p2c(z.get_center())\n            matrix = np.array([[pos[0], -pos[1]], [pos[1], pos[0]]])\n            plane_copy_group.append((plane, matrix))\n            if z == z_3:\n                plane_copy_group.append((plane.copy(), np.sqrt(pos[0] ** 2 + pos[1] ** 2) * np.eye(2)))\n        self.add(background)\n        self.play(Write(tex_group), run_time=3)\n        self.wait(5)\n        self.play(C_tex.animate.scale(0.5).next_to(C_plane_left, DOWN).to_edge(UP, buff=0.75), rightarrow_tex.animate.scale(0.5).move_to(ORIGIN).to_edge(UP, buff=0.75), direct_similitudes.animate.scale(0.5).next_to(C_plane_right, UP).to_edge(UP, buff=0.75), Create(C_plane_left), Create(z_1), run_time=3)\n        self.play(ReplacementTransform(z_1.copy(), z_tex))\n        self.wait()\n        self.play(Write(mapsto_tex_planes), Write(mapsto_tex))\n        self.wait()\n        self.play(z_1_copy.animate.move_to(C_plane_right.c2p(1, 0)), ReplacementTransform(C_plane_left.copy().set_z_index(z_1.z_index - 1), C_plane_right), run_time=2)\n        z_1_copy.add_updater(lambda point: point.move_to(plane_copy_group[0][0].c2p(1, 0)))\n        self.add(plane_copy_group[0][0])\n        self.wait()\n        self.play(C_plane_right.animate.set_opacity(0.25).set_z_index(background.z_index - 2), ApplyMatrix(plane_copy_group[0][1], plane_copy_group[0][0], about_point=C_plane_right.c2p(0, 0)))\n        self.wait()\n        self.play(ReplacementTransform(VGroup(C_plane_right.copy(), z_1_copy.copy()), func_tex), run_time=2)\n        self.wait(2)\n        self.play(FadeIn(label_f_1_rect), Write(label_f_1), run_time=2)\n        self.wait(4)\n        self.play(FadeOut(z_1_copy, label_f_1, label_f_1_rect), plane_copy_group[0][0].animate.set_opacity(0), ReplacementTransform(z_1, z_2))\n        self.wait(0.5)\n        self.play(z_2_copy.animate.move_to(C_plane_right.c2p(1, 0)), FadeIn(plane_copy_group[1][0]))\n        self.wait()\n        z_2_copy.add_updater(lambda point: point.move_to(plane_copy_group[1][0].c2p(1, 0)))\n        self.play(ApplyMatrix(plane_copy_group[1][1], plane_copy_group[1][0], about_point=C_plane_right.c2p(0, 0)))\n        self.wait()\n        self.play(FadeOut(z_2_copy), plane_copy_group[1][0].animate.set_opacity(0), ReplacementTransform(z_2, z_3))\n        self.wait(0.5)\n        self.play(z_3_copy.animate.move_to(C_plane_right.c2p(1, 0)), FadeIn(plane_copy_group[2][0]))\n        self.wait()\n        z_3_copy.add_updater(lambda point: point.move_to(plane_copy_group[2][0].c2p(1, 0)))\n        self.play(ApplyMatrix(plane_copy_group[2][1], plane_copy_group[2][0], about_point=C_plane_right.c2p(0, 0)))\n        self.wait()\n        z_3_copy.clear_updaters()\n        self.play(plane_copy_group[2][0].animate.set_opacity(0), FadeIn(plane_copy_group[3][0]), z_3_copy.animate.move_to(plane_copy_group[3][0].c2p(1, 0)), run_time=1.5)\n        self.wait()\n        z_3_copy.add_updater(lambda point: point.move_to(plane_copy_group[3][0].c2p(1, 0)))\n        self.wait()\n        self.play(ReplacementTransform(z_tex, z_exp_tex))\n        self.wait(2)\n        self.play(ReplacementTransform(z_exp_tex[0], z_exp_tex_bis[0]))\n        self.wait()\n        self.play(ReplacementTransform(z_exp_tex[1][2:], z_exp_tex_bis[1][2:]))\n        self.remove(*z_exp_tex[1])\n        self.add(z_exp_tex_bis[1])\n        self.play(*[ReplacementTransform(part, part_exp) for part, part_exp in zip(func_tex, func_tex_exp)], re_it_copy.animate.move_to(func_tex_exp[1]))\n        self.remove(re_it_copy)\n        self.wait(3)\n        self.play(FocusOn(func_tex_exp, opacity=0.4))\n        self.play(Wiggle(func_tex_exp[1][1:], scale_value=1.5, rotation_angle=0.03 * TAU), run_time=2)\n        self.wait()\n        self.play(Rotate(plane_copy_group[3][0], np.arctan(3 / 2) + PI), run_time=2)\n        self.wait()\n        self.play(Wiggle(func_tex_exp[1][0], scale_value=1.5, rotation_angle=0.03 * TAU), run_time=2)\n        self.wait()\n        self.play(ApplyMatrix(plane_copy_group[3][1], plane_copy_group[3][0], about_point=C_plane_right.c2p(0, 0)), run_time=2)\n        self.wait(5)\n        self.play(ReplacementTransform(z_exp_tex_bis, z_exp_tex_bis_target), Write(VGroup(double_arrow_tex, matrix_tex)), run_time=3)\n        self.wait(5)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize complex number multiplication by showing the rotation of a point on a complex plane."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass ComplexNumbers3(ZoomedScene):\n\n    def construct(self):\n        plane = ComplexPlane(y_range=[-6, 6], background_line_style={'stroke_opacity': 0.5}).add_coordinates()\n        self.camera.frame.shift(UP)\n        arg_j_jp1_tex = MathTex('\\\\mathrm{arg}(j) &= ', '\\\\frac{2\\\\pi}{3}', '\\\\\\\\ \\\\mathrm{arg}(1 + j) &=', '\\\\frac{\\\\pi}{3}').shift(4 * LEFT + 0.5 * DOWN)\n        arg_j_jp1_tex[0][4].set_color(BLUE)\n        arg_j_jp1_tex[2][4:7].set_color(GREEN)\n        arg_j_jp1_tex_rectangle = BackgroundRectangle(arg_j_jp1_tex, buff=MED_SMALL_BUFF)\n        arg_j_jp1_tex.set_z_index(arg_j_jp1_tex_rectangle.z_index + 1)\n        j = Dot(plane.c2p(-1 / 2, np.sqrt(3) / 2), color=BLUE)\n        j_label = MathTex('j', color=BLUE).scale(0.8).next_to(j, j.get_center() / np.linalg.norm(j.get_center()), buff=MED_SMALL_BUFF)\n        j_label_rectangle = BackgroundRectangle(j_label, fill_opacity=0.5, buff=SMALL_BUFF).set_z_index(plane.z_index + 1)\n        VGroup(j_label, j).set_z_index(j_label_rectangle.z_index + 1)\n        jp1 = Dot(plane.c2p(1 / 2, np.sqrt(3) / 2), color=GREEN)\n        jp1_label = MathTex('j + 1', color=GREEN).scale(0.8).next_to(jp1, 2 * jp1.get_center() / np.linalg.norm(jp1.get_center()), buff=MED_SMALL_BUFF).shift(0.25 * DOWN)\n        jp1_label_rectangle = BackgroundRectangle(jp1_label, fill_opacity=0.5, buff=SMALL_BUFF).set_z_index(plane.z_index + 1)\n        VGroup(jp1_label, jp1).set_z_index(jp1_label_rectangle.z_index + 1)\n        z = Dot(plane.n2p(3 + 1j), color=YELLOW)\n        z_label = MathTex('z', color=YELLOW).next_to(z, z.get_center() / np.linalg.norm(z.get_center()), buff=MED_SMALL_BUFF)\n        z_label_rectangle = BackgroundRectangle(z_label, fill_opacity=0.5, buff=SMALL_BUFF).set_z_index(plane.z_index + 1)\n        z_label.set_z_index(z_label_rectangle.z_index + 1)\n        jz = Dot(plane.n2p(complex(-1 / 2, np.sqrt(3) / 2) * (3 + 1j)), color=YELLOW)\n        jz_label = MathTex('jz', color=YELLOW).next_to(jz, jz.get_center() / np.linalg.norm(jz.get_center()), buff=MED_SMALL_BUFF).set_z_index(z_label.z_index)\n        jz_label[0][0].set_color(BLUE)\n        jz_label_rectangle = BackgroundRectangle(jz_label, fill_opacity=0.5, buff=SMALL_BUFF).set_z_index(plane.z_index + 1)\n        jp1z = Dot(plane.n2p(complex(1 / 2, np.sqrt(3) / 2) * (3 + 1j)), color=YELLOW)\n        jp1z_label = MathTex('(1 + j)z', color=YELLOW).next_to(jp1z, 2 * jp1z.get_center() / np.linalg.norm(jp1z.get_center()), buff=MED_SMALL_BUFF).set_z_index(z_label.z_index)\n        jp1z_label[0][0:5].set_color(GREEN)\n        jp1z_label_rectangle = BackgroundRectangle(jp1z_label, fill_opacity=0.5, buff=SMALL_BUFF).set_z_index(plane.z_index + 1)\n        z_copy = z.copy()\n        z_label_copy = z_label.copy()\n        z_label_rectangle_copy = z_label_rectangle.copy()\n        z_copy_bis = z.copy()\n        z_label_copy_bis = z_label.copy()\n        z_label_rectangle_copy_bis = z_label_rectangle.copy()\n        line = Line(plane.c2p(0, 0), z_copy.get_center())\n        line_bis = always_redraw(lambda: Line(plane.c2p(0, 0), z_copy.get_center()))\n        line_tiers = always_redraw(lambda: Line(plane.c2p(0, 0), z_copy_bis.get_center()))\n        fixed_line_j = Line(plane.c2p(0, 0), jz.get_center())\n        fixed_line_jp1 = Line(plane.c2p(0, 0), jp1z.get_center())\n        angle_j = Angle(line, fixed_line_j, radius=0.5, color=BLUE).set_z_index(arg_j_jp1_tex_rectangle.z_index + 1)\n        angle_jp1 = Angle(line, fixed_line_jp1, radius=0.5, color=GREEN).set_z_index(arg_j_jp1_tex_rectangle.z_index + 1)\n        self.play(FadeIn(plane, j_label_rectangle, j_label), Create(j))\n        self.wait()\n        self.play(Create(line), Create(z), Write(z_label), FadeIn(z_label_rectangle))\n        self.add(line_bis)\n        self.wait()\n        self.play(ReplacementTransform(z_copy, jz, path_arc=2 * PI / 3), ReplacementTransform(z_label_copy, jz_label, path_arc=2 * PI / 3), ReplacementTransform(z_label_rectangle_copy, jz_label_rectangle, path_arc=2 * PI / 3), Create(angle_j), run_time=3)\n        self.add(line_tiers)\n        self.wait()\n        self.play(Write(arg_j_jp1_tex[0]), FadeIn(arg_j_jp1_tex_rectangle))\n        self.play(ReplacementTransform(angle_j, arg_j_jp1_tex[1]))\n        self.wait(4)\n        self.play(ReplacementTransform(j.copy(), jp1), ReplacementTransform(j_label.copy(), jp1_label), ReplacementTransform(j_label_rectangle.copy(), jp1_label_rectangle))\n        self.wait()\n        self.play(ReplacementTransform(z_copy_bis, jp1z, path_arc=PI / 3), ReplacementTransform(z_label_copy_bis, jp1z_label, path_arc=PI / 3), ReplacementTransform(z_label_rectangle_copy_bis, jp1z_label_rectangle, path_arc=PI / 3), Create(angle_jp1), run_time=3)\n        self.wait()\n        self.play(Write(arg_j_jp1_tex[2]))\n        self.play(ReplacementTransform(angle_jp1, arg_j_jp1_tex[3]))\n        self.wait(2)\n        rectangle = CoveringRectangle()\n        ending_plane = plane.copy().set_z_index(rectangle.z_index + 1)\n        self.play(FadeIn(rectangle, ending_plane))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate an equivalence proof involving a triangle and complex number relationships on a complex plane."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass EquivalenceProof(ZoomedScene):\n\n    def construct(self):\n        plane = ComplexPlane(x_range=[-10, 10], y_range=[-6, 6], background_line_style={'stroke_opacity': 0.5}).add_coordinates()\n        self.camera.frame.shift(UP)\n        triangle = Triangle(color=RED)\n        triangle.match_height(Line(plane.c2p(0, 0), plane.c2p(0, 1.5))).move_to(plane.c2p(0, 0)).shift(1 / 4 * plane.c2p(1, 0)).rotate(-PI / 2)\n        labels = VGroup(MathTex('a').scale(1 / 1.4).rotate(-PI / 12).move_to(triangle.get_vertices()[0] + 0.4 * RIGHT), MathTex('b').scale(1 / 1.4).rotate(-PI / 12).move_to(triangle.get_vertices()[1] + 0.4 * np.array([-1 / 2, np.sqrt(3) / 2, 0])), MathTex('c').scale(1 / 1.4).rotate(-PI / 12).move_to(triangle.get_vertices()[2] + 0.4 * np.array([-1 / 2, -np.sqrt(3) / 2, 0])))\n        label_rectangles = VGroup(BackgroundRectangle(labels[0].copy().rotate(PI / 12), fill_opacity=0.5, buff=SMALL_BUFF).rotate(-PI / 12), BackgroundRectangle(labels[1].copy().rotate(PI / 12), fill_opacity=0.5, buff=SMALL_BUFF).rotate(-PI / 12), BackgroundRectangle(labels[2].copy().rotate(PI / 12), fill_opacity=0.5, buff=SMALL_BUFF).rotate(-PI / 12))\n        labels.set_z_index(label_rectangles.z_index + 1)\n        centered_triangle = triangle.copy()\n        centered_labels = VGroup(MathTex('a - c').rotate(-PI / 12).scale(1 / 1.4).move_to(triangle.get_vertices()[0] + 0.6 * RIGHT), MathTex('b - c').rotate(-PI / 12).scale(1 / 1.4).move_to(triangle.get_vertices()[1] + 0.4 * np.array([-1 / 2, np.sqrt(3) / 2, 0])), MathTex('0').rotate(-PI / 12).scale(1 / 1.4).move_to(triangle.get_vertices()[2] + 0.3 * np.array([-1 / 2, -np.sqrt(3) / 2, 0])))\n        centered_label_rectangles = VGroup(BackgroundRectangle(centered_labels[0].copy().rotate(PI / 12), fill_opacity=0.5, buff=SMALL_BUFF).rotate(-PI / 12), BackgroundRectangle(centered_labels[1].copy().rotate(PI / 12), fill_opacity=0.5, buff=SMALL_BUFF).rotate(-PI / 12), BackgroundRectangle(centered_labels[2].copy().rotate(PI / 12), fill_opacity=0.5, buff=SMALL_BUFF).rotate(-PI / 12))\n        centered_labels.set_z_index(centered_label_rectangles.z_index + 1)\n        VGroup(triangle, labels, label_rectangles, centered_triangle, centered_labels, centered_label_rectangles).rotate(PI / 12).scale(1.4).shift(2.2 * UP + 3 * RIGHT)\n        VGroup(centered_triangle, centered_labels, centered_label_rectangles).shift(-triangle.get_vertices()[2] + 0.01 * UP + 0.007 * RIGHT)\n        conditions_tex = MathTex('\\\\alpha &= ', ' \\\\frac{\\\\pi}{3}', '\\\\\\\\|a-c| ', ' &= ', ' |b-c|').move_to(plane.c2p(0, 2.5)).to_edge(buff=0.75)\n        conditions_tex_rectangle = BackgroundRectangle(conditions_tex, buff=MED_SMALL_BUFF)\n        conditions_tex.set_z_index(conditions_tex_rectangle.z_index + 1)\n        angle = Angle(Line(plane.c2p(0, 0), centered_triangle.get_vertices()[0]), Line(plane.c2p(0, 0), centered_triangle.get_vertices()[1]), radius=0.5).set_z_index(conditions_tex_rectangle.z_index + 1)\n        centered_triangle.set_z_index(angle.z_index + 1)\n        angle_label = MathTex('\\\\alpha').move_to(Angle(*angle.get_lines(), radius=angle.radius + 0.3).point_from_proportion(0.5))\n        angle_label_rectangle = BackgroundRectangle(angle_label, buff=SMALL_BUFF)\n        angle_label.set_z_index(angle_label_rectangle.z_index + 1)\n        centered_triangle.set_z_index(angle.z_index + 1)\n        j_relation = MathTex('1 + j + j^2 = 0').next_to(conditions_tex, DOWN, buff=0.5)\n        j_relation_rectangle = BackgroundRectangle(j_relation, buff=MED_LARGE_BUFF)\n        j_relation.set_z_index(j_relation_rectangle.z_index + 1)\n        iff_relation = MathTex('b-c = (1+j)(a-c)', ' \\\\iff ', 'a + bj + cj^2 = 0').move_to(plane.c2p(-2, -1.25))\n        iff_relation_rectangle = BackgroundRectangle(iff_relation, buff=MED_SMALL_BUFF)\n        iff_relation.set_z_index(j_relation_rectangle.z_index + 1)\n        VGroup(j_relation[0][2], j_relation[0][4], iff_relation[2][3], iff_relation[2][6]).set_color(BLUE)\n        VGroup(iff_relation[0][4:9]).set_color(GREEN)\n        self.add(plane)\n        self.wait(2)\n        self.play(Create(triangle), *[Write(label) for label in labels], FadeIn(*label_rectangles), run_time=2)\n        self.wait(2)\n        self.play(ReplacementTransform(triangle, centered_triangle), *[ReplacementTransform(label, centered_label) for label, centered_label in zip(labels, centered_labels)], *[ReplacementTransform(rectangle, centered_rectangle) for rectangle, centered_rectangle in zip(label_rectangles, centered_label_rectangles)], run_time=2)\n        self.wait()\n        self.play(FadeOut(centered_labels[2], centered_label_rectangles[2]), self.camera.frame.animate.shift(2 * LEFT).scale(0.8))\n        self.wait(5)\n        self.play(Write(conditions_tex[0]), Create(angle), FadeIn(conditions_tex_rectangle))\n        self.play(ReplacementTransform(angle, conditions_tex[1]), run_time=2)\n        self.wait()\n        self.play(ReplacementTransform(Line(centered_triangle.get_vertices()[2], centered_triangle.get_vertices()[0], color=RED), conditions_tex[2]), ReplacementTransform(Line(centered_triangle.get_vertices()[2], centered_triangle.get_vertices()[1], color=RED), conditions_tex[4]), Write(conditions_tex[3]), run_time=2)\n        self.wait(5)\n        self.play(Write(iff_relation[0]), FadeIn(iff_relation_rectangle), run_time=2)\n        self.wait(2)\n        self.play(Write(j_relation), FadeIn(j_relation_rectangle), run_time=2)\n        self.play(Circumscribe(j_relation))\n        self.wait()\n        self.play(Write(iff_relation[1:]), run_time=2)\n        self.wait()\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate the multiplicative symmetries of an equilateral triangle using mathematical equations and transformations."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass EquilateralTriangleSymetries(Scene):\n\n    def construct(self):\n        relation_1 = MathTex('a + bj + cj^2 = 0')\n        relation_2 = MathTex('aj + bj^2 + c', 'j^3', '= 0').next_to(relation_1, DOWN, buff=LARGE_BUFF)\n        relation_3 = MathTex('aj^2 + b + cj = 0').next_to(relation_2, DOWN, buff=LARGE_BUFF)\n        VGroup(relation_1, relation_2, relation_3).move_to(ORIGIN)\n        j_cubed_width = relation_2[1].width\n        multiply_by_j_arrow = CurvedArrow(relation_1.get_center() - relation_1.height / 2.5 * UP, relation_2.get_center() + relation_2.height / 2.5 * UP, color=YELLOW).shift((0.3 + max(relation_1.width / 2, relation_2.width / 2)) * LEFT)\n        multiply_by_j_label = MathTex('\\\\times j').next_to(multiply_by_j_arrow, LEFT)\n        multiply_by_j_label[0][1].set_color(BLUE)\n        multiply_by_j_arrow_bis = CurvedArrow(relation_2.get_center() - relation_2.height / 2.5 * UP, relation_3.get_center() + relation_3.height / 2.5 * UP, color=YELLOW).shift((0.3 + max(relation_2.width / 2, relation_3.width / 2)) * LEFT)\n        multiply_by_j_label_bis = multiply_by_j_label.copy().next_to(multiply_by_j_arrow_bis, LEFT)\n        brace = Brace(relation_2[1], buff=SMALL_BUFF)\n        brace_label = MathTex('= 1').scale(0.5).next_to(brace, DOWN, buff=SMALL_BUFF)\n        screen = Rectangle(width=8, height=5).set_fill(BLACK, opacity=1).set_stroke(WHITE, 4, opacity=1)\n        triangle = Triangle().scale(2).rotate(-PI / 2).move_to(screen).set_z_index(screen.z_index + 1)\n        D_6 = MathTex('D_6').move_to(triangle.get_center() + 1 / 2 * LEFT).scale(2)\n        self.wait()\n        self.play(FadeIn(relation_1))\n        self.wait()\n        self.play(Create(multiply_by_j_arrow), Write(multiply_by_j_label), ReplacementTransform(relation_1.copy(), relation_2), run_time=2)\n        self.wait(4)\n        self.play(FadeIn(brace, brace_label))\n        self.wait()\n        self.play(FadeOut(brace, brace_label, relation_2[1]), relation_2[2].animate.shift(j_cubed_width * LEFT / 2), relation_2[0].animate.shift(j_cubed_width * RIGHT / 2))\n        self.wait(4)\n        self.play(Create(multiply_by_j_arrow_bis), Write(multiply_by_j_label_bis), ReplacementTransform(VGroup(relation_2[0], relation_2[2]).copy(), relation_3), run_time=2)\n        self.wait(9)\n        self.play(GrowFromCenter(screen))\n        self.wait()\n        self.play(FadeIn(triangle))\n        self.wait()\n        self.play(Rotate(triangle, 2 * PI / 3, about_point=1 / 2 * LEFT), run_time=1.5)\n        self.wait()\n        self.play(Rotate(triangle, 4 * PI / 3, about_point=1 / 2 * LEFT), run_time=1.5)\n        self.wait(14)\n        self.play(triangle.animate.flip(RIGHT), run_time=1.5)\n        self.wait()\n        self.play(triangle.animate.rotate(4 * PI / 3, about_point=1 / 2 * LEFT).flip(RIGHT).rotate(-4 * PI / 3, about_point=1 / 2 * LEFT), run_time=1.5)\n        self.play(triangle.animate.rotate(2 * PI / 3, about_point=1 / 2 * LEFT).flip(RIGHT).rotate(-2 * PI / 3, about_point=1 / 2 * LEFT), run_time=1.5)\n        self.wait(5)\n        self.play(Write(D_6))\n        self.wait(15)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display an image with a title and border, then fade them out while unwriting the title."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass GroupVideoBy3b1b(Scene):\n\n    def construct(self):\n        img = ImageMobject('3b1b_video.png').scale(1.5)\n        channel_name = Tex('video by 3Blue1Brown').scale(0.9).next_to(img, DOWN, buff=0.5)\n        border = SurroundingRectangle(img, buff=0)\n        Group(img, channel_name, border).move_to(ORIGIN)\n        self.wait()\n        self.play(FadeIn(img), Create(border), Write(channel_name), run_time=2)\n        self.wait(4)\n        self.play(FadeOut(img, border), Unwrite(channel_name))\n        self.wait(4)"}]}
{"messages": [{"role": "user", "content": "Fade in and then fade out an equation representing an algebraic relation."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass AlgebraicRelation(Scene):\n\n    def construct(self):\n        relation = MathTex('P + Qj + Rj^2 = 0').scale(2)\n        self.wait()\n        self.play(FadeIn(relation), run_time=1.5)\n        self.wait(2)\n        self.play(FadeOut(relation), run_time=1.5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the Aff(R) math symbol and hold it for ten seconds."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass AffRWait(Scene):\n\n    def construct(self):\n        aff_group_R_tex = MathTex('\\\\mathrm{Af~\\\\hspace{-0.42em}f}(\\\\mathbb{R})').scale(3)\n        self.add(aff_group_R_tex)\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Display the affine group of real numbers and visualize its transformation properties by animating a graph on a number plane and then transforming a number line with various scaling and shifting parameters."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass AffineGroupR(Scene):\n\n    def construct(self):\n        aff_group_C_tex = MathTex('\\\\mathrm{Af~\\\\hspace{-0.42em}f}(\\\\mathbb{C})').scale(3)\n        aff_group_R_tex = MathTex('\\\\mathrm{Af~\\\\hspace{-0.42em}f}(\\\\mathbb{R})').scale(3)\n        affine_real_func_tex = MathTex('&x \\\\mapsto ax + b\\\\\\\\', '&a \\\\in \\\\mathbb{R}^{\\\\star}, b \\\\in \\\\mathbb{R}').scale(2)\n        plane = NumberPlane(x_range=[-4.01, 4.01], y_range=[-3.01, 3.01]).scale(0.75).shift(0.5 * DOWN)\n        plane_rect = SurroundingRectangle(plane, buff=0).set_z_index(plane.z_index + 1)\n        a, b = (ValueTracker(1), ValueTracker(0))\n        graph = plane.plot(lambda x: a.get_value() * x + b.get_value(), x_range=[-3, 3], color=YELLOW).set_z_index(plane.z_index + 1)\n\n        def graph_updater(graph):\n            try:\n                if a.get_value() >= 0:\n                    graph.become(plane.plot(lambda x: a.get_value() * x + b.get_value(), x_range=[max(-(3 + b.get_value()) / a.get_value(), -4), min((3 - b.get_value()) / a.get_value(), 4)], color=YELLOW))\n                else:\n                    graph.become(plane.plot(lambda x: a.get_value() * x + b.get_value(), x_range=[max((3 - b.get_value()) / a.get_value(), -4), min(-(3 + b.get_value()) / a.get_value(), 4)], color=YELLOW))\n            except ZeroDivisionError:\n                graph.become(plane.plot(lambda x: a.get_value() * x + b.get_value(), x_range=[-4, 4], color=YELLOW))\n            graph.set_z_index(plane.z_index + 1)\n        real_line = NumberLine(x_range=[-50, 50], include_numbers=[0, 1])\n        transformation_list = [(2, 0), (-1, 2), (-3, -4), (-1 / 3, 2)]\n        self.wait()\n        self.play(Write(aff_group_C_tex), run_time=2)\n        self.wait(3)\n        self.play(FadeOut(aff_group_C_tex))\n        self.wait()\n        self.play(Write(aff_group_R_tex), run_time=2)\n        self.wait()\n        self.play(aff_group_R_tex.animate.scale(1 / 2).to_edge(UP, buff=0.75), Write(affine_real_func_tex), run_time=3)\n        self.wait(3)\n        self.play(FadeIn(plane), Create(plane_rect), ReplacementTransform(affine_real_func_tex, graph))\n        graph.add_updater(graph_updater)\n        self.wait()\n        self.play(a.animate.set_value(4), b.animate.set_value(2), run_time=2)\n        self.play(a.animate.set_value(-1 / 2), b.animate.set_value(-1), run_time=2)\n        self.play(a.animate.set_value(1), b.animate.set_value(0), run_time=2)\n        self.wait()\n        self.play(FadeOut(plane, plane_rect), Uncreate(graph))\n        self.wait(2)\n        self.play(FadeIn(real_line))\n        self.wait()\n        for transformation in transformation_list:\n            a, b = transformation\n            new_line = NumberLine(x_range=[-50, 50], unit_size=a, include_numbers=[0, 1]).shift(b * RIGHT)\n            self.play(Transform(real_line, new_line), run_time=2)\n            self.wait()\n        self.wait()\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the affine group acting on the complex plane by showing transformations like translation, scaling, and rotation applied to a number plane."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass AffineGroupC(Scene):\n\n    def construct(self):\n        scale_factor = 0.75\n        aff_group_C_tex = MathTex('\\\\mathrm{Af~\\\\hspace{-0.42em}f}(\\\\mathbb{C})').scale(3 / 2).to_edge(UP, buff=0.75)\n        affine_complex_func_tex = MathTex('&z \\\\mapsto az + b\\\\\\\\', '&a \\\\in \\\\mathbb{C}^{\\\\star}, b \\\\in \\\\mathbb{C}').scale(2)\n        plane = NumberPlane(x_range=[-4.01, 4.01], y_range=[-3.01, 3.01]).scale(0.75).shift(0.5 * DOWN)\n        plane_copy = NumberPlane(x_range=[-50.01, 50.01], y_range=[-50.01, 50.01]).scale(scale_factor).shift(0.5 * DOWN)\n        plane_rect = SurroundingRectangle(plane, buff=0)\n        rectangle = Difference(Rectangle(width=20, height=20), Rectangle(width=plane_rect.width, height=plane_rect.height).move_to(plane)).set_fill(BLACK, 1).set_stroke(width=0)\n        plane_copy.set_z_index(rectangle.z_index - 1)\n        VGroup(plane, aff_group_C_tex, affine_complex_func_tex).set_z_index(rectangle.z_index + 2)\n        plane_rect.set_z_index(plane.z_index + 1)\n        tex_template = TexTemplate()\n        tex_template.add_to_preamble('\\\\usepackage{mathrsfs}')\n        translation_group = MathTex('\\\\mathrm{T}(\\\\mathbb{C})').move_to(plane).scale(4)\n        similitude_group = MathTex('\\\\mathscr{S}_{+}(\\\\mathbb{C})', tex_template=tex_template).move_to(plane).scale(4)\n        rotation_group = MathTex('\\\\mathrm{SO}(\\\\mathbb{C})').move_to(plane).scale(4)\n        VGroup(translation_group, similitude_group, rotation_group).set_z_index(plane_copy.z_index + 2)\n        a_1, b_1 = (complex(-1, 2), complex(-1, 1))\n        a_2, b_2 = (1, complex(2, 3))\n        a_3, b_3 = (complex(2, -1), 0)\n        a_4, b_4 = (np.exp(2 * PI / 3 * complex(0, 1)), 0)\n        plane_center = complex(plane.c2p(0, 0)[0], plane.c2p(0, 0)[1])\n        plane_copy_save = plane_copy.copy()\n        self.add(rectangle)\n        self.wait()\n        self.play(Write(aff_group_C_tex), Write(affine_complex_func_tex), run_time=2)\n        self.wait(3)\n        self.play(ReplacementTransform(affine_complex_func_tex, plane), Create(plane_rect), run_time=2)\n        self.add(plane_copy)\n        self.wait(2)\n        self.play(Rotate(plane_copy, np.arctan(2) + PI / 2), plane.animate.set_opacity(0.25), run_time=1.5)\n        self.play(ApplyComplexFunction(lambda z: np.sqrt(a_1.real ** 2 + a_1.imag ** 2) * (z - plane_center) / scale_factor * scale_factor + plane_center, plane_copy), run_time=1.5)\n        self.play(ApplyComplexFunction(lambda z: ((z - plane_center) / scale_factor + b_1) * scale_factor + plane_center, plane_copy), run_time=1.5)\n        self.wait(2)\n        self.play(Transform(plane_copy, plane_copy_save), run_time=1)\n        self.wait(2)\n        self.play(ApplyComplexFunction(lambda z: (a_2 * (z - plane_center) / scale_factor + b_2) * scale_factor + plane_center, plane_copy), run_time=2)\n        self.wait(3)\n        self.play(Transform(plane_copy, plane_copy_save), ReplacementTransform(plane_copy.copy(), translation_group), run_time=1)\n        self.wait()\n        self.play(FadeOut(translation_group))\n        self.wait(2)\n        self.play(ApplyComplexFunction(lambda z: (a_3 * (z - plane_center) / scale_factor + b_3) * scale_factor + plane_center, plane_copy), run_time=2)\n        self.wait(3)\n        self.play(Transform(plane_copy, plane_copy_save), ReplacementTransform(plane_copy.copy(), similitude_group), run_time=1)\n        self.wait()\n        self.play(FadeOut(similitude_group))\n        self.wait(2)\n        self.play(Rotate(plane_copy, 2 * PI / 3), run_time=2)\n        self.wait(3)\n        self.play(ReplacementTransform(plane_copy.copy(), rotation_group), run_time=1)\n        self.wait()\n        self.play(FadeOut(rotation_group))\n        self.wait(2)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()\n\n    def get_blurred_image(self, radius, iterations):\n        current_image = self.camera.pixel_array\n        blurred_image = Image.fromarray(current_image).filter(ImageFilter.GaussianBlur(radius=radius))\n        for k in range(iterations - 1):\n            temp_array = np.clip(np.asarray(blurred_image) + 2 * np.ones(np.asarray(blurred_image).shape, dtype=np.uint8), 0, 255, dtype=np.uint8)\n            blurred_image = Image.fromarray(temp_array).filter(ImageFilter.GaussianBlur(radius=radius))\n        new_image = ImageMobject(np.asarray(blurred_image))\n        new_image.height = config.frame_height\n        return new_image"}]}
{"messages": [{"role": "user", "content": "Demonstrate the composition of complex number transformations and their relation to semi-direct products."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass CompositionOfTransformations(Scene):\n\n    def construct(self):\n        plane = NumberPlane(x_range=[-4.01, 4.01], y_range=[-3.01, 3.01])\n        plane_copy = NumberPlane(x_range=[-50.01, 50.01], y_range=[-50.01, 50.01])\n        screen = BackgroundRectangle(plane, buff=0).set_fill(BLACK, 1)\n        rectangle = Difference(Rectangle(width=20, height=20), Rectangle(width=screen.width, height=screen.height).move_to(plane)).set_fill(BLACK, 1).set_stroke(width=0)\n        couple_rep_tex = MathTex('(b, a)').scale(1.5)\n        couple_rep_tex_copy = couple_rep_tex.copy().scale(1.5)\n        couple_rep_tex_2 = MathTex('(d, c)').scale(1.5).next_to(couple_rep_tex, RIGHT)\n        couple_rep_tex_3 = MathTex(' = (f, e)').scale(1.5).next_to(couple_rep_tex_2, RIGHT)\n        e_tex = MathTex('e =', '\\\\varphi(a, b, c, d)', '\\\\overset{?}{=}', ' ac').scale(1.5).to_edge()\n        f_tex = MathTex('f =', '\\\\psi(a, b, c, d)', '\\\\overset{?}{=} ', ' b + d', 'ad + b').scale(1.5).next_to(e_tex, DOWN).to_edge().shift(0.1 * LEFT)\n        VGroup(e_tex, f_tex).next_to(VGroup(couple_rep_tex, couple_rep_tex_2, couple_rep_tex_3), DOWN, buff=0.75)\n        VGroup(couple_rep_tex, couple_rep_tex_2, couple_rep_tex_3, e_tex, f_tex).move_to(ORIGIN)\n        VGroup(e_tex, f_tex).shift(RIGHT)\n        eq_tex = MathTex('=').scale(1.5).move_to(f_tex[2])\n        eq_tex_copy = MathTex('=').scale(1.5).move_to(e_tex[2]).shift(0.3 * DOWN)\n        f_tex[-1].next_to(eq_tex, RIGHT)\n        VGroup(eq_tex, f_tex[-1]).shift(0.2 * DOWN)\n        eq_tex.shift(0.05 * DOWN)\n        semi_direct_product = MathTex('\\\\mathrm{Af~\\\\hspace{-0.42em}f}(\\\\mathbb{C}) = \\\\mathbb{C} \\\\rtimes \\\\mathrm{GL}(\\\\mathbb{C})').scale(1.5).next_to(VGroup(couple_rep_tex, couple_rep_tex_2, couple_rep_tex_3, e_tex, f_tex), DOWN, buff=0.75)\n        action_tex = MathTex('z \\\\in \\\\mathrm{GL}(\\\\mathbb{C}) \\\\mapsto (w \\\\mapsto zw) \\\\in \\\\mathrm{Aut}(\\\\mathbb{C})').scale(1.5).next_to(semi_direct_product, DOWN)\n        screen.set_z_index(VGroup(couple_rep_tex, couple_rep_tex_2, couple_rep_tex_3, e_tex, f_tex).z_index + 1)\n        plane.set_z_index(screen.z_index + 1)\n        plane_copy.set_z_index(plane.z_index + 1)\n        rectangle.set_z_index(plane_copy.z_index + 1)\n        c, d = (complex(-1, 1), complex(1, 1))\n        a, b = (2 * np.exp(-PI / 3 * complex(0, 1)), complex(-2, 3))\n        zero_dot = always_redraw(lambda: Dot(plane_copy.c2p(0, 0), color=YELLOW).set_z_index(plane_copy.z_index + 1))\n        dot_label_0 = MathTex('0').next_to(zero_dot, RIGHT)\n        dot_label_d = MathTex('d').next_to(plane.c2p(d.real, d.imag), plane.c2p(d.real, d.imag) / np.linalg.norm(plane.c2p(d.real, d.imag)))\n        dot_label_ad = MathTex('ad').next_to(plane.c2p((a * d).real, (a * d).imag), plane.c2p((a * d).real, (a * d).imag) / np.linalg.norm(plane.c2p((a * d).real, (a * d).imag)))\n        dot_label_ad_b = MathTex('ad + b').next_to(plane.c2p((a * d + b).real, (a * d + b).imag), plane.c2p((a * d + b).real, (a * d + b).imag) / np.linalg.norm(plane.c2p((a * d + b).real, (a * d + b).imag)))\n        dot_label_0_rectangle = BackgroundRectangle(dot_label_0, buff=SMALL_BUFF).set_z_index(plane_copy.z_index + 1)\n        VGroup(dot_label_0, dot_label_d, dot_label_ad, dot_label_ad_b).set_z_index(dot_label_0_rectangle.z_index + 1)\n        matrix = np.array([[1, -1], [1, 1]])\n        cross = Cross(f_tex[2:4]).shift(0.15 * DOWN)\n        self.wait()\n        self.play(Write(couple_rep_tex_copy), run_time=1.5)\n        self.wait(3)\n        self.play(ApplyMatrix(matrix, couple_rep_tex_copy[0][3], about_point=couple_rep_tex_copy.get_center()), run_time=1)\n        self.play(ApplyMatrix(np.linalg.inv(matrix), couple_rep_tex_copy[0][3], about_point=couple_rep_tex_copy.get_center()), run_time=1)\n        self.wait()\n        self.play(couple_rep_tex_copy[0][1].animate.shift(2 * RIGHT + UP), run_time=1)\n        self.play(couple_rep_tex_copy[0][1].animate.shift(2 * LEFT + DOWN), run_time=1)\n        self.wait()\n        self.play(ReplacementTransform(couple_rep_tex_copy, couple_rep_tex))\n        self.play(Write(couple_rep_tex_2))\n        self.wait()\n        self.play(ReplacementTransform(VGroup(couple_rep_tex.copy(), couple_rep_tex_2.copy()), couple_rep_tex_3))\n        self.wait(2)\n        self.play(Write(e_tex[0:2]), Write(f_tex[0:2]), run_time=2)\n        '\\n        self.wait()\\n        self.play(Write(e_tex[2:]))\\n        self.play(Write(f_tex[2:4]))\\n        self.wait(2)\\n        self.play(GrowFromCenter(cross), Indicate(e_tex[2:], scale_factor=1.25, color=GREEN))\\n        self.wait()\\n        self.play(GrowFromCenter(VGroup(plane, screen)), run_time=1.5)\\n        self.add(plane_copy, rectangle)\\n        self.wait()\\n        self.play(Create(zero_dot), Write(dot_label_0), FadeIn(dot_label_0_rectangle), run_time=1.5)\\n        self.wait()\\n        self.play(ApplyComplexFunction(lambda z: c*z, plane_copy), run_time=2)\\n        self.play(\\n            ApplyComplexFunction(lambda z: z + d, plane_copy),\\n            ReplacementTransform(dot_label_0, dot_label_d),\\n            Transform(dot_label_0_rectangle, BackgroundRectangle(dot_label_d).set_z_index(dot_label_0_rectangle.z_index)), run_time=2\\n        )\\n        self.wait()\\n        self.play(\\n            ApplyComplexFunction(lambda z: a*z, plane_copy),\\n            ReplacementTransform(dot_label_d, dot_label_ad),\\n            Transform(dot_label_0_rectangle, BackgroundRectangle(dot_label_ad).set_z_index(dot_label_0_rectangle.z_index)), run_time=2\\n        )\\n        self.wait()\\n        self.play(\\n            ApplyComplexFunction(lambda z: z + b, plane_copy),\\n            ReplacementTransform(dot_label_ad, dot_label_ad_b),\\n            Transform(dot_label_0_rectangle, BackgroundRectangle(dot_label_ad_b).set_z_index(dot_label_0_rectangle.z_index)), run_time=2\\n        )\\n        self.wait(3)\\n        self.play(Indicate(dot_label_ad_b), cross.animate.set_opacity(0))\\n        self.wait(2)\\n        zero_dot.clear_updaters()\\n        self.play(\\n            ShrinkToCenter(VGroup(plane, screen, zero_dot, dot_label_ad_b, dot_label_0_rectangle)),\\n            plane_copy.animate.set_opacity(0), run_time=1.5\\n        )\\n        self.remove(rectangle)\\n        self.wait()\\n        self.play(\\n            ReplacementTransform(f_tex[3], f_tex[4]),\\n            ReplacementTransform(f_tex[2], eq_tex),\\n            ReplacementTransform(e_tex[2], eq_tex_copy), run_time=1.5\\n        )\\n        self.wait()\\n        self.play(Indicate(f_tex[4], scale_factor=1.25, color=GREEN), Indicate(e_tex[-1], color=GREEN))\\n        self.wait()\\n        VGroup(semi_direct_product, action_tex).set_opacity(0)\\n        self.play(\\n            VGroup(couple_rep_tex, couple_rep_tex_2, couple_rep_tex_3, e_tex, f_tex, semi_direct_product, action_tex).animate.move_to(ORIGIN),\\n            VGroup(eq_tex, eq_tex_copy).animate.set_opacity(0)\\n        )\\n        self.play(Write(semi_direct_product.copy().set_opacity(1)), run_time=3)\\n        self.play(Write(action_tex.copy().set_opacity(1)), run_time=3)\\n        self.wait(2)\\n        self.play(FadeIn(CoveringRectangle()))\\n        self.wait()\\n        '"}]}
{"messages": [{"role": "user", "content": "Display an image for 2.5 seconds."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass CompositionOfTransformationsWait(Scene):\n\n    def construct(self):\n        im = ImageMobject('CompositionOfTransformationsWait.png')\n        self.add(im)\n        self.wait(2.5)"}]}
{"messages": [{"role": "user", "content": "Visualize a complex plane undergoing scaling, translation, and rotation, demonstrating an affine transformation with accompanying mathematical notation."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass AffineRotations(Scene):\n\n    def construct(self):\n        scale_factor = 0.8\n        plane = NumberPlane(x_range=[-4.01, 4.01], y_range=[-3.01, 3.01]).scale(scale_factor).shift(0.75 * UP)\n        plane_copy = NumberPlane(x_range=[-50.01, 50.01], y_range=[-50.01, 50.01]).scale(scale_factor).shift(0.75 * UP)\n        screen = BackgroundRectangle(plane, buff=0).set_fill(BLACK, 1)\n        rectangle = Difference(Rectangle(width=20, height=20), Rectangle(width=screen.width, height=screen.height).move_to(plane)).set_fill(BLACK, 1).set_stroke(width=0)\n        plane_center = complex(plane.c2p(0, 0)[0], plane.c2p(0, 0)[1])\n        plane_center_array = plane.c2p(0, 0)\n        plane_copy.set_z_index(plane.z_index + 1)\n        rectangle.set_z_index(plane_copy.z_index + 1)\n        a_tex = MathTex('a = e^{i\\\\theta}').scale(1.25).next_to(plane, DOWN, buff=0.75)\n        func_tex = MathTex('z \\\\mapsto e^{i\\\\theta}(z-c) + c = e^{i\\\\theta}z + (1 - e^{i\\\\theta})c').next_to(plane, DOWN, buff=0.75).scale(1.25)\n        VGroup(a_tex, func_tex).set_z_index(rectangle.z_index + 1)\n        c = complex(1, 1)\n        c_dot = always_redraw(lambda: Dot(plane_copy.c2p(c.real, c.imag)).set_z_index(plane_copy.z_index + 1))\n        c_label = MathTex('c').next_to(plane.c2p(1, 1), plane.c2p(1, 1) / np.linalg.norm(plane.c2p(1, 1)))\n        c_label_rectangle = BackgroundRectangle(c_label, buff=SMALL_BUFF).set_z_index(plane_copy.z_index + 1)\n        zero_label = MathTex('0').next_to(plane.c2p(0, 0), plane.c2p(0, 0) / np.linalg.norm(plane.c2p(0, 0))).set_z_index(plane_copy.z_index + 1)\n        zero_label_rectangle = BackgroundRectangle(zero_label, buff=SMALL_BUFF).set_z_index(plane_copy.z_index + 1)\n        VGroup(c_label, zero_label_rectangle).set_z_index(c_label_rectangle.z_index + 1)\n        c_label_copy = c_label.copy()\n        c_label_rectangle_copy = c_label_rectangle.copy()\n        self.add(rectangle)\n        self.wait()\n        self.play(FadeIn(plane_copy))\n        self.wait()\n        self.play(Write(a_tex))\n        self.play(Wiggle(a_tex[0][-1], scale_value=1.25, rotation_angle=0.02 * TAU))\n        self.wait()\n        self.play(Create(c_dot), Write(c_label), FadeIn(c_label_rectangle))\n        self.wait()\n        self.play(ApplyComplexFunction(lambda z: ((z - plane_center) / scale_factor - c + plane_center) * scale_factor, plane_copy), Transform(c_label, zero_label.copy()), Transform(c_label_rectangle, zero_label_rectangle.copy()), run_time=2)\n        self.wait()\n        self.play(Rotate(plane_copy, PI / 3, about_point=plane_center_array), run_time=2)\n        self.wait()\n        self.play(ApplyComplexFunction(lambda z: ((z - plane_center) / scale_factor + c + plane_center) * scale_factor, plane_copy), Transform(c_label, c_label_copy), Transform(c_label_rectangle, c_label_rectangle_copy), run_time=2)\n        self.wait(2)\n        self.play(ReplacementTransform(a_tex, func_tex), run_time=2)\n        self.wait()\n        self.play(Rotate(plane_copy, PI / 3, about_point=c_dot.get_center()), run_time=2)\n        self.wait(2)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render a Morley Triangle, then label its vertices with gA, gB, gC and their cubes, animate rotations of the triangle's sides, and finally scale the triangle and display a formula for \"i\"."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass ProofSetup(Scene):\n\n    def construct(self):\n        triangle = MorleyTriangle([complex(-3, 1), complex(3, 2), complex(0, -2)], direct=False)\n        triangle_copy = triangle.copy()\n        cross = Cross(VGroup(triangle.outer_lines, triangle.outer_dots).copy().scale(1.5), stroke_width=16)\n        g_A = MathTex('g_A')\n        g_B = MathTex('g_B').next_to(g_A, DOWN, buff=0.75)\n        g_C = MathTex('g_C').next_to(g_B, DOWN, buff=0.75)\n        VGroup(g_A, g_B, g_C).move_to(ORIGIN).to_edge(buff=1)\n        g_A_cube = MathTex('g_A^3')\n        g_B_cube = MathTex('g_B^3').next_to(g_A_cube, DOWN, buff=0.75)\n        g_C_cube = MathTex('g_C^3').next_to(g_B_cube, DOWN, buff=0.75)\n        i_tex = MathTex('i = g_A^3g_B^3g_C^3').next_to(g_C_cube, DOWN, buff=0.75)\n        VGroup(g_A_cube, g_B_cube, g_C_cube, i_tex).move_to(ORIGIN).to_edge(RIGHT, buff=1)\n        self.wait()\n        self.play(DrawBorderThenFill(triangle), run_time=3)\n        self.play(FadeIn(triangle_copy))\n        triangle_copy.set_opacity(0.25)\n        triangle_copy.outer_angle.set_fill(opacity=0).set_stroke(opacity=0.25)\n        self.wait(2)\n        self.play(Rotate(VGroup(*[part for part in triangle.subvmobjects if part != triangle.A_label]), 2 / 3 * triangle.BAC_angle_value, about_point=triangle.A.get_center()), run_time=1)\n        self.play(Rotate(VGroup(*[part for part in triangle.subvmobjects if part != triangle.A_label]), -2 / 3 * triangle.BAC_angle_value, about_point=triangle.A.get_center()), run_time=1)\n        self.wait()\n        self.play(Rotate(VGroup(*[part for part in triangle.subvmobjects if part != triangle.B_label]), 2 / 3 * triangle.CBA_angle_value, about_point=triangle.B.get_center()), run_time=1)\n        self.play(Rotate(VGroup(*[part for part in triangle.subvmobjects if part != triangle.B_label]), -2 / 3 * triangle.CBA_angle_value, about_point=triangle.B.get_center()), run_time=1)\n        self.wait()\n        self.play(Rotate(VGroup(*[part for part in triangle.subvmobjects if part != triangle.C_label]), 2 / 3 * triangle.ACB_angle_value, about_point=triangle.C.get_center()), run_time=1)\n        self.play(Rotate(VGroup(*[part for part in triangle.subvmobjects if part != triangle.C_label]), -2 / 3 * triangle.ACB_angle_value, about_point=triangle.C.get_center()), run_time=1)\n        self.wait(2)\n        self.play(AnimationGroup(Write(g_A), Write(g_B), Write(g_C), lag_ratio=0.3))\n        self.wait()\n        self.play(Rotate(VGroup(*[part for part in triangle.subvmobjects if part != triangle.A_label]), 2 * triangle.BAC_angle_value, about_point=triangle.A.get_center()), Write(g_A_cube), run_time=1)\n        self.play(Rotate(VGroup(*[part for part in triangle.subvmobjects if part != triangle.A_label]), -2 * triangle.BAC_angle_value, about_point=triangle.A.get_center()), run_time=1)\n        self.wait()\n        self.play(AnimationGroup(Write(g_B_cube), Write(g_C_cube), lag_ratio=0.3))\n        self.wait(3)\n        self.play(ScaleInPlace(triangle, 1.5))\n        self.play(GrowFromCenter(cross))\n        self.wait()\n        self.play(ScaleInPlace(triangle, 1 / 1.5), FadeOut(triangle_copy, cross))\n        self.wait()\n        self.play(Write(i_tex), triangle.animate.scale(0.7).shift(1.75 * UP + 0.75 * RIGHT))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate a proof of identity involving rotations and color changes on triangles while displaying corresponding mathematical expressions."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass IdentityProof(Scene):\n\n    def construct(self):\n        triangle = MorleyTriangle([complex(-3, 1), complex(3, 2), complex(0, -2)], direct=False)\n        triangle.save_state()\n        triangle.scale(0.7).shift(1.75 * UP + 0.75 * RIGHT)\n        triangle_C = triangle.copy()\n        triangle_C.remove(triangle_C.C_label)\n        triangle_B = triangle.copy()\n        triangle_B.remove(triangle_B.B_label, triangle_B.A_label)\n        triangle_A = triangle.copy()\n        triangle_A.remove(triangle_A.C_label, triangle_A.B_label, triangle_A.A_label)\n        g_A = MathTex('g_A')\n        g_B = MathTex('g_B').next_to(g_A, DOWN, buff=0.75)\n        g_C = MathTex('g_C').next_to(g_B, DOWN, buff=0.75)\n        VGroup(g_A, g_B, g_C).move_to(ORIGIN).to_edge(buff=1)\n        g_A_cube = MathTex('g_A^3')\n        g_B_cube = MathTex('g_B^3').next_to(g_A_cube, DOWN, buff=0.75)\n        g_C_cube = MathTex('g_C^3').next_to(g_B_cube, DOWN, buff=0.75)\n        i_tex = MathTex('i = g_A^3g_B^3g_C^3')\n        i_tex.next_to(g_C_cube, DOWN, buff=0.75)\n        VGroup(g_A_cube, g_B_cube, g_C_cube, i_tex).move_to(ORIGIN).to_edge(RIGHT, buff=1)\n        i_exp = MathTex('i = ', 'r_{CA}', 'r_{AB}', 'r_{AB}', 'r_{BC}', 'r_{BC}', 'r_{CA}').to_edge(DOWN, buff=0.6)\n        VGroup(i_exp[1], i_exp[6]).set_color(PURE_GREEN)\n        i_exp[2:4].set_color(PURE_RED)\n        i_exp[4:6].set_color(PURPLE_E)\n        id_tex = MathTex('\\\\mathrm{id}').next_to(i_exp[0], RIGHT)\n        self.add(triangle, g_A, g_B, g_C, g_A_cube, g_B_cube, g_C_cube, i_tex)\n        self.wait(2)\n        self.play(Rotate(VGroup(triangle_C, triangle_B, triangle_A), 2 * triangle_C.ACB_angle_value, about_point=triangle_C.C.get_center()), run_time=2)\n        self.play(Rotate(VGroup(triangle_B, triangle_A), 2 * triangle.CBA_angle_value, about_point=triangle_B.B.get_center()), run_time=2)\n        self.play(Rotate(triangle_A, 2 * triangle.BAC_angle_value, about_point=triangle_A.A.get_center()), run_time=2)\n        triangle_A.remove(triangle_A.P_label, triangle_A.Q_label, triangle_A.R_label, triangle_A.ACB_angle_label, triangle_A.BAC_angle_label, triangle_A.CBA_angle_label)\n        self.wait(3)\n        self.play(*[Wiggle(line, scale_value=1.2, rotation_angle=0.015 * TAU) for line in VGroup(triangle.AB_line, triangle_A.AB_line, triangle_B.AB_line, triangle_C.AB_line)])\n        self.play(*[line.animate.set_color(PURE_RED) for line in VGroup(triangle.AB_line, triangle_A.AB_line, triangle_B.AB_line, triangle_C.AB_line)], run_time=0.5)\n        self.play(*[Wiggle(line, scale_value=1.2, rotation_angle=0.015 * TAU) for line in VGroup(triangle.BC_line, triangle_A.BC_line, triangle_B.BC_line, triangle_C.BC_line)])\n        self.play(*[line.animate.set_color(PURPLE_E) for line in VGroup(triangle.AB_line, triangle_A.BC_line, triangle_B.BC_line, triangle_C.BC_line)], run_time=0.5)\n        self.play(*[Wiggle(line, scale_value=1.2, rotation_angle=0.015 * TAU) for line in VGroup(triangle.CA_line, triangle_A.CA_line, triangle_B.CA_line, triangle_C.CA_line)])\n        self.play(*[line.animate.set_color(PURE_GREEN) for line in VGroup(triangle.CA_line, triangle_A.CA_line, triangle_B.CA_line, triangle_C.CA_line)], run_time=0.5)\n        self.wait(3)\n        self.play(Indicate(VGroup(triangle.CA_line, triangle.A, triangle.C, triangle_A.CA_line, triangle_A.A, triangle_A.C, triangle_B.AB_line, triangle_B.A, triangle_B.B, triangle_C.BC_line, triangle_C.B, triangle_C.C), color=None), run_time=2)\n        self.wait()\n        self.play(Rotate(triangle_A, PI, axis=triangle.CA_line.get_vector(), about_point=triangle.A.get_center()), run_time=1.5)\n        self.play(Rotate(triangle_A, PI, axis=triangle.CA_line.get_vector(), about_point=triangle.A.get_center()), run_time=1.5)\n        self.wait(3)\n        self.play(Rotate(triangle_A, PI, axis=triangle.CA_line.get_vector(), about_point=triangle.A.get_center()), Write(VGroup(i_exp[0], i_exp[6])), run_time=1.5)\n        self.play(Rotate(triangle_A, PI, axis=triangle_C.BC_line.get_vector(), about_point=triangle_C.C.get_center()), Write(i_exp[5]), run_time=1.5)\n        self.wait(0.5)\n        self.play(Rotate(triangle_A, PI, axis=triangle_C.BC_line.get_vector(), about_point=triangle_C.C.get_center()), Write(i_exp[4]), run_time=1.5)\n        self.play(Rotate(triangle_A, PI, axis=triangle_B.AB_line.get_vector(), about_point=triangle_B.B.get_center()), Write(i_exp[3]), run_time=1.5)\n        self.wait(0.5)\n        self.play(Rotate(triangle_A, PI, axis=triangle_B.AB_line.get_vector(), about_point=triangle_B.B.get_center()), Write(i_exp[2]), run_time=1.5)\n        self.play(Rotate(triangle_A, PI, axis=triangle.CA_line.get_vector(), about_point=triangle.A.get_center()), Write(i_exp[1]), run_time=1.5)\n        self.wait(2)\n        self.play(Wiggle(i_exp[2:4], scale_value=1.25))\n        self.play(FadeOut(i_exp[2:4]), i_exp[4:].animate.shift(i_exp[2:4].width * LEFT))\n        self.play(Wiggle(i_exp[4:6], scale_value=1.25))\n        self.play(FadeOut(i_exp[4:6]), i_exp[6:].animate.shift(i_exp[4:6].width * LEFT))\n        self.play(Wiggle(VGroup(i_exp[1], i_exp[6]), scale_value=1.25))\n        self.play(ReplacementTransform(VGroup(i_exp[1], i_exp[6]), id_tex))\n        self.wait(2)\n        self.play(FadeOut(i_exp[0], id_tex, triangle_A, triangle_B, triangle_C), triangle.animate.restore())\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the complex number representation of a triangle's angle trisectors and their relationship to fixed points, culminating in a demonstration of the equation $P + Qj + Rj^2 = 0$."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass TrisectorsIntersectionsAsFixedPoints(Scene):\n\n    def construct(self):\n        triangle = MorleyTriangle([complex(-3, 1), complex(3, 2), complex(0, -2)], direct=False)\n        triangle_copy = triangle.copy().set_opacity(0.2)\n        VGroup(triangle_copy.R, triangle_copy.R_label).set_opacity(1)\n        VGroup(triangle_copy.BAC_angle, triangle_copy.ACB_angle, triangle_copy.CBA_angle).set_fill(opacity=0).set_stroke(opacity=0.2)\n        R_copy = triangle.R.copy()\n        trisector_from_A_copy = triangle.trisectors_from_A[0].copy().rotate(2 / 3 * triangle.BAC_angle_value, about_point=triangle.A.get_center())\n        trisector_from_B_copy = triangle.trisectors_from_B[1].copy().rotate(-2 / 3 * triangle.CBA_angle_value, about_point=triangle.B.get_center())\n        A_trisector_angle = Angle(triangle.AB_line, trisector_from_A_copy, radius=triangle.BAC_angle.radius, color=triangle.BAC_angle.color).set_z_index(triangle.AB_line.z_index - 1)\n        B_trisector_angle = Angle(trisector_from_B_copy, Line(triangle.B.get_center(), triangle.A.get_center()), radius=triangle.CBA_angle.radius, color=triangle.CBA_angle.color).set_z_index(triangle.AB_line.z_index - 1)\n        A_trisector_angle_label = triangle.BAC_angle_label[0][1].copy().move_to(Angle(triangle.AB_line, trisector_from_A_copy, radius=triangle.BAC_angle.radius + 0.4).point_from_proportion(0.5))\n        B_trisector_angle_label = triangle.CBA_angle_label[0][1].copy().move_to(Angle(trisector_from_B_copy, Line(triangle.B.get_center(), triangle.A.get_center()), radius=triangle.CBA_angle.radius + 0.4).point_from_proportion(0.25))\n        R_copy.set_z_index(trisector_from_B_copy.z_index + 1)\n        g_A = MathTex('g_A')\n        g_B = MathTex('g_B').next_to(g_A, DOWN, buff=0.75)\n        g_C = MathTex('g_C').next_to(g_B, DOWN, buff=0.75)\n        VGroup(g_A, g_B, g_C).move_to(ORIGIN).to_edge(buff=1)\n        g_A_cube = MathTex('g_A^3')\n        g_B_cube = MathTex('g_B^3').next_to(g_A_cube, DOWN, buff=0.75)\n        g_C_cube = MathTex('g_C^3').next_to(g_B_cube, DOWN, buff=0.75)\n        i_tex = MathTex('i = g_A^3g_B^3g_C^3')\n        i_tex.next_to(g_C_cube, DOWN, buff=0.75)\n        VGroup(g_A_cube, g_B_cube, g_C_cube, i_tex).move_to(ORIGIN).to_edge(RIGHT, buff=1)\n        g_B_g_A = MathTex('g_Bg_A').move_to(g_A_cube)\n        g_C_g_B = MathTex('g_Cg_B').move_to(g_B_cube)\n        g_A_g_C = MathTex('g_Ag_C').move_to(g_C_cube)\n        rectangle_2 = BackgroundRectangle(VGroup(g_B_g_A, g_C_g_B, g_A_g_C), buff=SMALL_BUFF).set_z_index(VGroup(g_B_g_A, g_C_g_B, g_A_g_C).z_index - 1)\n        fixed_point = MathTex('g_Ag_B(R) = R').to_edge(DOWN, buff=0.75).move_to(i_tex).to_edge(buff=1)\n        self.add(triangle, g_A, g_B, g_C, g_A_cube, g_B_cube, g_C_cube, i_tex, rectangle_2)\n        self.wait(2)\n        self.play(ReplacementTransform(g_A_cube, g_B_g_A))\n        self.play(ReplacementTransform(g_B_cube, g_C_g_B))\n        self.play(ReplacementTransform(g_C_cube, g_A_g_C))\n        self.wait(2)\n        self.play(Wiggle(VGroup(triangle.R, triangle.R_label)))\n        self.wait(2)\n        self.play(g_A.animate.move_to(g_B_g_A).to_edge(buff=1), g_B.animate.move_to(g_C_g_B).to_edge(buff=1), g_C.animate.move_to(g_A_g_C).to_edge(buff=1), Write(fixed_point))\n        rectangle_1 = BackgroundRectangle(VGroup(g_A, g_B, g_C), buff=SMALL_BUFF).set_z_index(VGroup(g_A, g_B, g_C).z_index - 1)\n        rectangle_3 = BackgroundRectangle(fixed_point, buff=SMALL_BUFF).set_z_index(fixed_point.z_index - 1)\n        self.add(rectangle_1, rectangle_3, R_copy)\n        start = triangle.A.get_center() + 10 * (triangle.B.get_center() - triangle.A.get_center())\n        end = triangle.A.get_center() - 10 * (triangle.B.get_center() - triangle.A.get_center())\n        AB_line = DashedLine(start=start, end=end).set_z_index(min([triangle.AB_line.z_index - 1, rectangle_1.z_index - 1, rectangle_2.z_index - 1, rectangle_3.z_index - 1]))\n        self.play(FadeIn(AB_line))\n        self.wait()\n        self.play(Rotate(R_copy, PI, triangle.AB_line.get_vector(), triangle.A.get_center()), run_time=1.5)\n        self.wait()\n        self.play(Create(trisector_from_A_copy), Create(A_trisector_angle), Write(A_trisector_angle_label), run_time=1.5)\n        self.play(Wiggle(VGroup(A_trisector_angle, A_trisector_angle_label)))\n        self.wait()\n        self.play(Rotate(triangle_copy, 2 / 3 * triangle.BAC_angle_value, about_point=triangle.A.get_center()), run_time=2)\n        self.wait()\n        self.play(Rotate(R_copy, PI, triangle.AB_line.get_vector(), triangle.A.get_center()), Create(trisector_from_B_copy), Create(B_trisector_angle), Write(B_trisector_angle_label), run_time=1.5)\n        self.wait()\n        self.play(Wiggle(VGroup(B_trisector_angle, B_trisector_angle_label)))\n        self.wait()\n        self.play(Rotate(triangle_copy, 2 / 3 * triangle.CBA_angle_value, about_point=triangle.B.get_center()), run_time=2)\n        self.wait()\n        self.play(Circumscribe(fixed_point))\n        self.wait()\n        p_qj_rj2 = MathTex('P + Qj + Rj^2 = 0').to_edge(DOWN, buff=0.5)\n        self.play(Write(p_qj_rj2), run_time=3)\n        self.play(Circumscribe(p_qj_rj2))\n        self.wait(3)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the mathematical proof of Morley's Theorem by sequentially displaying and transforming complex number expressions, fixed-point equations, and their relationships."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass MorleyTheoremProof(Scene):\n\n    def construct(self):\n        g_A_tex = MathTex('g_A = (', 't_A, ', 's_A = e^{2i\\\\alpha})')\n        g_B_tex = MathTex('g_B = (t_B, s_B = e^{2i\\\\beta})').next_to(g_A_tex, DOWN)\n        g_C_tex = MathTex('g_C = (t_C, s_C = e^{2i\\\\gamma})').next_to(g_B_tex, DOWN)\n        j_tex = MathTex('j = s_As_Bs_C = e^{2i(\\\\alpha + \\\\beta + \\\\gamma)}').next_to(g_C_tex, DOWN, buff=0.75)\n        VGroup(g_A_tex, g_B_tex, g_C_tex, j_tex).move_to(ORIGIN).scale(1.25)\n        i_tex = MathTex('i = g_A^3g_B^3g_C^3 = (t_i, s_i)', ' = (0, 1)')\n        t_i_exp = MathTex('-js_A^2s_B', '(s_A-j)', '(s_B-j)', '(s_C-j)', '(S + Tj + Uj^2)', ' = 0').next_to(i_tex, DOWN, buff=0.75)\n        P_exp = MathTex('S = \\\\frac{s_Ct_B + t_C}{1-s_Cs_B}').scale(0.8).next_to(t_i_exp, DOWN, buff=1.25)\n        Q_exp = MathTex('T = \\\\frac{s_At_C + t_A}{1-s_As_C}').scale(0.8).next_to(P_exp, DOWN)\n        R_exp = MathTex('U = \\\\frac{s_Bt_A + t_B}{1-s_Bs_A}').scale(0.8).next_to(Q_exp, DOWN)\n        rectangle = SurroundingRectangle(VGroup(P_exp, Q_exp, R_exp), buff=MED_SMALL_BUFF)\n        brace = Brace(t_i_exp[0], buff=0)\n        brace_label = always_redraw(lambda: MathTex('\\\\neq 0').scale(0.8).next_to(brace, DOWN))\n        VGroup(i_tex, t_i_exp, P_exp, Q_exp, R_exp, rectangle, brace, brace_label).move_to(ORIGIN)\n        Q_tex_y_pos = Q_exp.get_center()[1]\n        composition_formula = MathTex('(t_A, s_A)(t_B, s_B) = (s_At_B + t_A, s_As_B)').next_to(i_tex, DOWN, buff=0.75)\n        PQR_exp_copy = VGroup(P_exp, Q_exp, R_exp, rectangle).copy()\n        implications = MathTex('s_A', ' = ', 'j =', ' s_A', 's_Bs_C', '\\\\implies', ' g_Cg_B = (1, t_{CB})')\n        P_fixed_point = MathTex('g_Cg_B(S) = S')\n        Q_fixed_point = MathTex('g_Ag_C(T) = T').next_to(P_fixed_point, DOWN)\n        R_fixed_point = MathTex('g_Bg_A(U) = U').next_to(Q_fixed_point, DOWN)\n        rectangle_2 = SurroundingRectangle(VGroup(P_fixed_point, Q_fixed_point, R_fixed_point), buff=MED_SMALL_BUFF)\n        VGroup(P_fixed_point, Q_fixed_point, R_fixed_point, rectangle_2).next_to(PQR_exp_copy, RIGHT, buff=1)\n        VGroup(P_fixed_point, Q_fixed_point, R_fixed_point, rectangle_2, PQR_exp_copy).move_to(ORIGIN).shift(Q_tex_y_pos * UP)\n        implications.next_to(PQR_exp_copy[1], RIGHT, buff=1).shift(2 * LEFT)\n        cross = Cross(implications[6])\n        self.wait(2)\n        self.play(Write(g_A_tex[0]))\n        self.wait()\n        self.play(Write(g_A_tex[1]))\n        self.wait()\n        self.play(Write(g_A_tex[2]))\n        self.play(Write(g_B_tex), Write(g_C_tex), run_time=2)\n        self.wait(3)\n        self.play(Write(j_tex), run_time=2)\n        self.wait(2)\n        self.play(Transform(j_tex[0][12:], MathTex('\\\\frac{\\\\pi}{3}').scale(0.75).next_to(j_tex[0][11], RIGHT, buff=0.1)))\n        self.wait(2)\n        self.play(FadeOut(g_A_tex, g_B_tex, g_C_tex, j_tex))\n        self.wait(3)\n        self.play(Write(i_tex[0]), run_time=3)\n        self.wait(2)\n        self.play(Write(composition_formula), run_time=3)\n        self.play(Circumscribe(composition_formula))\n        self.wait(3)\n        self.play(FadeOut(composition_formula))\n        self.wait(6)\n        self.play(Write(t_i_exp[0:5]), run_time=5)\n        self.wait()\n        self.play(Write(P_exp), run_time=2)\n        self.play(Write(Q_exp), run_time=2)\n        self.play(Write(R_exp), run_time=2)\n        self.play(Create(rectangle))\n        self.wait(2)\n        self.play(Write(i_tex[1]))\n        self.play(ReplacementTransform(i_tex[1].copy(), t_i_exp[5]))\n        self.wait(3)\n        self.play(FadeIn(brace), Write(brace_label), run_time=2)\n        self.wait(3)\n        self.play(Transform(brace, Brace(t_i_exp[1], buff=0)), run_time=1.5)\n        self.wait()\n        self.play(VGroup(P_exp, Q_exp, R_exp, rectangle).animate.to_edge(buff=1.5), ReplacementTransform(t_i_exp[1].copy(), implications[0:5]), run_time=2)\n        self.wait(3)\n        self.play(Transform(implications[0], MathTex('1').move_to(implications[0]).shift(0.05 * UP)), FadeOut(implications[2:4]), implications[4].animate.shift(implications[2:4].width * LEFT))\n        VGroup(implications[5:7], cross).shift(implications[2:4].width * LEFT)\n        self.wait(3)\n        self.play(Write(implications[5:7]), run_time=2)\n        self.wait(2)\n        self.play(GrowFromCenter(cross))\n        self.wait()\n        self.play(FadeOut(implications[0], implications[1], implications[4], implications[5:7], cross))\n        self.wait()\n        self.play(Transform(brace, Brace(t_i_exp[2], buff=0)), run_time=1)\n        self.play(Transform(brace, Brace(t_i_exp[3], buff=0)), run_time=1)\n        self.wait()\n        new_brace = Brace(t_i_exp[4], buff=0)\n        brace_label.clear_updaters()\n        brace_label_eq_0 = MathTex('= 0').scale(0.8).next_to(new_brace, DOWN)\n        self.play(ReplacementTransform(brace, new_brace), ReplacementTransform(brace_label, brace_label_eq_0))\n        self.wait()\n        self.play(FadeOut(new_brace, brace_label_eq_0, t_i_exp[0:4], t_i_exp[4][0], t_i_exp[4][-1]), t_i_exp[4][1:9].animate.shift(VGroup(t_i_exp[4][1:9], t_i_exp[5]).get_center()[0] * LEFT), t_i_exp[5].animate.shift((VGroup(t_i_exp[4][1:9], t_i_exp[5]).get_center()[0] + 0.25) * LEFT), run_time=2)\n        self.wait()\n        self.play(VGroup(P_exp, Q_exp, R_exp, rectangle).animate.move_to(PQR_exp_copy), Write(P_fixed_point), Write(Q_fixed_point), Write(R_fixed_point), run_time=2)\n        self.play(Create(rectangle_2))\n        self.wait(3)\n        self.play(Transform(t_i_exp[4][1], MathTex('P').move_to(t_i_exp[4][1])), Transform(t_i_exp[4][3], MathTex('Q').move_to(t_i_exp[4][3])), Transform(t_i_exp[4][6], MathTex('R').move_to(t_i_exp[4][6])))\n        self.wait(3)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate three points on a sphere forming arcs and angle indicators."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass Epilog(ThreeDScene):\n\n    def construct(self):\n        radius = 3\n        sphere = OpenGLSurface(lambda u, v: radius * np.array([np.cos(u) * np.sin(v), np.sin(u) * np.sin(v), -np.cos(v)]), u_range=(0, TAU), v_range=(0, PI), color=BLUE)\n        self.set_camera_orientation(65 * DEGREES, 40 * DEGREES)\n        A = OpenGLSurface(lambda u, v: DEFAULT_DOT_RADIUS * np.array([np.cos(u) * np.sin(v), np.sin(u) * np.sin(v), -np.cos(v)]), u_range=(0, TAU), v_range=(0, PI), resolution=(20, 20), color=WHITE).move_to(np.array([0, 0, 3]))\n        B = OpenGLSurface(lambda u, v: DEFAULT_DOT_RADIUS * np.array([np.cos(u) * np.sin(v), np.sin(u) * np.sin(v), -np.cos(v)]), u_range=(0, TAU), v_range=(0, PI), resolution=(20, 20), color=WHITE).move_to(np.array([0, -3, 0]))\n        C = OpenGLSurface(lambda u, v: DEFAULT_DOT_RADIUS * np.array([np.cos(u) * np.sin(v), np.sin(u) * np.sin(v), -np.cos(v)]), u_range=(0, TAU), v_range=(0, PI), resolution=(20, 20), color=WHITE).move_to(np.array([3, 0, 0]))\n        AB = ArcBetweenPoints(A.get_center(), B.get_center()).rotate(PI, B.get_center() - A.get_center(), A.get_center())\n        BC = ArcBetweenPoints(B.get_center(), C.get_center(), radius=radius)\n        CA = ArcBetweenPoints(A.get_center(), C.get_center(), radius=radius)\n        angle_radius = 0.5\n        B_angle = VGroup(ArcBetweenPoints(AB.point_from_proportion(1 - angle_radius / AB.get_arc_length()), self.rotation_matrix(angle_radius / radius) @ AB.point_from_proportion(1 - angle_radius / AB.get_arc_length()), radius=radius), ArcBetweenPoints(BC.point_from_proportion(angle_radius / BC.get_arc_length()), self.rotation_matrix(angle_radius / radius) @ AB.point_from_proportion(1 - angle_radius / AB.get_arc_length()), radius=radius).rotate(PI / 2 + PI / 6, BC.point_from_proportion(angle_radius / BC.get_arc_length()) - self.rotation_matrix(angle_radius / radius) @ AB.point_from_proportion(1 - angle_radius / AB.get_arc_length()), about_point=BC.point_from_proportion(angle_radius / BC.get_arc_length()))).set_color(GREEN)\n        C_angle = VGroup(ArcBetweenPoints(BC.point_from_proportion(1 - angle_radius / BC.get_arc_length()), self.rotation_matrix(-angle_radius / radius) @ CA.point_from_proportion(1 - angle_radius / CA.get_arc_length()), radius=radius).rotate(PI / 2 + PI / 6, BC.point_from_proportion(1 - angle_radius / BC.get_arc_length()) - self.rotation_matrix(-angle_radius / radius) @ CA.point_from_proportion(1 - angle_radius / CA.get_arc_length()), about_point=BC.point_from_proportion(1 - angle_radius / BC.get_arc_length())), ArcBetweenPoints(CA.point_from_proportion(1 - angle_radius / CA.get_arc_length()), self.rotation_matrix(-angle_radius / radius) @ CA.point_from_proportion(1 - angle_radius / CA.get_arc_length()), radius=radius).rotate(PI, CA.point_from_proportion(1 - angle_radius / CA.get_arc_length()) - self.rotation_matrix(-angle_radius / radius) @ CA.point_from_proportion(1 - angle_radius / CA.get_arc_length()), about_point=CA.point_from_proportion(1 - angle_radius / CA.get_arc_length()))).set_color(GREEN)\n        A_angle = VGroup(B_angle[0].copy().rotate(2 * B_angle[1].get_arc_length() / radius - PI / 2, C.get_center(), C.get_center()), B_angle[1].copy().rotate(B_angle[0].get_arc_length() / radius - PI / 2, C.get_center(), C.get_center()))\n        self.wait()\n        self.play(Create(sphere), run_time=2)\n        self.wait(8)\n        self.play(FadeIn(A_angle, B_angle, C_angle, AB, BC, CA, A, B, C))\n        self.wait(30)\n\n    def rotation_matrix(self, angle):\n        return np.array([[np.cos(angle), -np.sin(angle), 0], [np.sin(angle), np.cos(angle), 0], [0, 0, 1]])"}]}
{"messages": [{"role": "user", "content": "Animate the creation of a hyperbolic surface and then rotate the camera around it."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass Epilog2(ThreeDScene):\n\n    def construct(self):\n        hyperbolic_surface = OpenGLSurface(lambda u, v: np.array([u, v, 1 / 2 * (u ** 2 - v ** 2)]), u_range=(-2, 2), v_range=(-2, 2), color=BLUE).scale(1.25).shift(0.5 * np.array([0, 0, 1]))\n        self.set_camera_orientation(65 * DEGREES, 20 * DEGREES)\n        self.wait()\n        self.begin_ambient_camera_rotation()\n        self.play(Create(hyperbolic_surface), run_time=2)\n        self.wait(40)"}]}
{"messages": [{"role": "user", "content": "Show a double arrow with a label, then transform an equilateral triangle into an isosceles triangle and finally into a right triangle, ending with a covering rectangle."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass Epilog3(Scene):\n\n    def construct(self):\n        double_arrow = DoubleArrow(LEFT, 2 * RIGHT, color=YELLOW)\n        double_arrow_label = Tex('link ?').next_to(double_arrow, UP)\n        equilateral_triangle = Triangle().scale(1.5).rotate(PI / 5).next_to(double_arrow, RIGHT, buff=1.25)\n        isoceles_triangle = Triangle().stretch(1.4, 1).scale(1.5).next_to(double_arrow, RIGHT, buff=1.25)\n        right_triangle = Polygon(ORIGIN, UP, 2 * RIGHT).scale(1.5).next_to(double_arrow, RIGHT, buff=1.25)\n        self.wait()\n        self.play(GrowArrow(double_arrow), Write(double_arrow_label), run_time=1.5)\n        self.wait()\n        self.play(Create(equilateral_triangle))\n        self.wait(10)\n        self.play(Transform(equilateral_triangle, isoceles_triangle))\n        self.wait(2)\n        self.play(Transform(equilateral_triangle, right_triangle))\n        self.wait(5)\n        self.play(FadeIn(CoveringRectangle()))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display animation, music, and proof credits sequentially with fades."}, {"role": "assistant", "content": "from objects import *\nfrom colormap import rgb2hex\nfrom scipy.ndimage import convolve\nfrom PIL import Image, ImageFilter\nfrom manim.opengl import *\nfrom pyglet.window import key\n\nclass Credits(Scene):\n\n    def construct(self):\n        credits_tex = Tex('Animations made with Manim CE').scale(1.5)\n        music_credits = Tex(\"Musics : 'Odyssey' by Kevin \\\\textsc{MacLeod}\").scale(1.5)\n        proof_credits = Tex(\"Proof : Alain \\\\textsc{Connes}'s article \\\\\\\\ 'A new proof of \\\\textsc{Morley}'s theorem'\").scale(1.5)\n        self.wait()\n        self.play(FadeIn(credits_tex))\n        self.wait(2)\n        self.play(FadeOut(credits_tex))\n        self.wait()\n        self.play(FadeIn(music_credits))\n        self.wait(2)\n        self.play(FadeOut(music_credits))\n        self.wait()\n        self.play(FadeIn(proof_credits))\n        self.wait(4)\n        self.play(FadeOut(proof_credits))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render a 3D parametric surface representing a M\u00f6bius strip."}, {"role": "assistant", "content": "\n\nclass RubanMoebius(ThreeDScene):\n\n    def construct(self):\n        self.set_camera_orientation(phi=np.pi / 2.75, theta=np.pi / 6, distance=2)\n\n        def f_moebius(u, v):\n            return np.array([(1 + u / 2 * np.cos(v / 2)) * np.cos(v), (1 + u / 2 * np.cos(v / 2)) * np.sin(v), u / 2 * np.sin(v / 2)])\n        RubanMoebius = ParametricSurface(f_moebius, u_min=-1, u_max=1, v_min=0, v_max=2 * np.pi)\n        self.add(RubanMoebius)"}]}
{"messages": [{"role": "user", "content": "Animate Newton's fractal by sequentially updating complex number roots and their labels on a number plane."}, {"role": "assistant", "content": "from manim import *\nfrom numba import njit\nfrom scipy.integrate import quad\n\nclass NewtonFractalsP2(Scene):\n\n    def construct(self):\n        z_1, z_2, z_3, z_4, z_5 = (ComplexValueTracker(0), ComplexValueTracker(0), ComplexValueTracker(0), ComplexValueTracker(0), ComplexValueTracker(0))\n        z_1.set_value(complex(1, 1))\n        z_2.set_value(unit_roots(5)[4])\n        z_3.set_value(complex(-0.75, 0.5))\n        z_4.set_value(unit_roots(5)[3])\n        z_5.set_value(unit_roots(5)[4])\n        complex_plane = NumberPlane(x_range=np.array([-1.5 * SCREEN_RATIO, 1.5 * SCREEN_RATIO, MULTIPLE_X * UNIT_SIZE_X], dtype=np.float), y_range=np.array([-1.5, 1.5, MULTIPLE_Y * UNIT_SIZE_Y], dtype=np.float), x_length=config.frame_width, y_length=config.frame_height)\n        Dot_z_1 = (always_redraw(lambda: Dot(complex_plane.c2p(z_1.get_value().real, z_1.get_value().imag), color=BLACK, radius=DEFAULT_SMALL_DOT_RADIUS)),)\n        Dot_z_2 = (always_redraw(lambda: Dot(complex_plane.c2p(z_2.get_value().real, z_2.get_value().imag), color=BLACK, radius=DEFAULT_SMALL_DOT_RADIUS)),)\n        Dot_z_3 = (always_redraw(lambda: Dot(complex_plane.c2p(z_3.get_value().real, z_3.get_value().imag), color=BLACK, radius=DEFAULT_SMALL_DOT_RADIUS)),)\n        Dot_z_4 = (always_redraw(lambda: Dot(complex_plane.c2p(z_4.get_value().real, z_4.get_value().imag), color=BLACK, radius=DEFAULT_SMALL_DOT_RADIUS)),)\n        Dot_z_5 = (always_redraw(lambda: Dot(complex_plane.c2p(z_5.get_value().real, z_5.get_value().imag), color=BLACK, radius=DEFAULT_SMALL_DOT_RADIUS)),)\n        roots_dots = [Dot_z_1[0], Dot_z_2[0], Dot_z_3[0], Dot_z_4[0], Dot_z_5[0]]\n        label_z_1 = (MathTex('z_1', color=BLACK).move_to(complex_plane.c2p(*get_array(unit_roots(5)[0]))).shift(0.4 * normalize(complex_plane.c2p(*get_array(unit_roots(5)[0])))),)\n        label_z_2 = (MathTex('z_2', color=BLACK).move_to(complex_plane.c2p(*get_array(unit_roots(5)[1]))).shift(0.4 * normalize(complex_plane.c2p(*get_array(unit_roots(5)[1])))),)\n        label_z_3 = (MathTex('z_3', color=BLACK).move_to(complex_plane.c2p(*get_array(unit_roots(5)[2]))).shift(0.4 * normalize(complex_plane.c2p(*get_array(unit_roots(5)[2])))),)\n        label_z_4 = (MathTex('z_4', color=BLACK).move_to(complex_plane.c2p(*get_array(unit_roots(5)[3]))).shift(0.4 * normalize(complex_plane.c2p(*get_array(unit_roots(5)[3])))),)\n        label_z_5 = (MathTex('z_5', color=BLACK).move_to(complex_plane.c2p(*get_array(unit_roots(5)[4]))).shift(0.4 * normalize(complex_plane.c2p(*get_array(unit_roots(5)[4])))),)\n\n        def update_labels(label, tracker):\n            label.move_to(complex_plane.c2p(tracker.get_value().real, tracker.get_value().imag)).shift(0.4 * normalize(complex_plane.c2p(tracker.get_value().real, tracker.get_value().imag)))\n        roots_dots_labels = [label_z_1[0], label_z_2[0], label_z_3[0], label_z_4[0], label_z_5[0]]\n        im = always_redraw(lambda: fit_screen_height(ImageMobject(newton_fractal(np.array([z_1.get_value(), z_2.get_value(), z_3.get_value(), z_4.get_value(), z_5.get_value()], dtype=complex)))))\n        self.add(im)\n        self.add(*roots_dots)\n        '\\n        self.wait()\\n        self.play(\\n            AnimationGroup(\\n                AnimationGroup(\\n                    z_1.animate.set_value(unit_roots(5)[0]),\\n                    FadeIn(label_z_1[0], shift=complex_plane.c2p(*get_array(unit_roots(5)[0])) + .4 * normalize(complex_plane.c2p(*get_array(unit_roots(5)[0]))))\\n                ),\\n                AnimationGroup(\\n                    z_2.animate.set_value(unit_roots(5)[1]),\\n                    FadeIn(label_z_2[0], shift=complex_plane.c2p(*get_array(unit_roots(5)[1])) + .4 * normalize(complex_plane.c2p(*get_array(unit_roots(5)[1]))))\\n                ),\\n                AnimationGroup(\\n                    z_3.animate.set_value(unit_roots(5)[2]),\\n                    FadeIn(label_z_3[0], shift=complex_plane.c2p(*get_array(unit_roots(5)[2])) + .4 * normalize(complex_plane.c2p(*get_array(unit_roots(5)[2]))))\\n                ),\\n                AnimationGroup(\\n                    z_4.animate.set_value(unit_roots(5)[3]),\\n                    FadeIn(label_z_4[0], shift=complex_plane.c2p(*get_array(unit_roots(5)[3])) + .4 * normalize(complex_plane.c2p(*get_array(unit_roots(5)[3]))))\\n                ),\\n                AnimationGroup(\\n                    z_5.animate.set_value(unit_roots(5)[4]),\\n                    FadeIn(label_z_5[0], shift=complex_plane.c2p(*get_array(unit_roots(5)[4])) + .4 * normalize(complex_plane.c2p(*get_array(unit_roots(5)[4]))))\\n                ), lag_ratio=.5\\n            ), run_time=10\\n        )\\n        #self.wait()\\n        '\n        label_z_1[0].add_updater(lambda label: update_labels(label, z_1))\n        label_z_2[0].add_updater(lambda label: update_labels(label, z_2))\n        label_z_3[0].add_updater(lambda label: update_labels(label, z_3))\n        label_z_4[0].add_updater(lambda label: update_labels(label, z_4))\n        label_z_5[0].add_updater(lambda label: update_labels(label, z_5))\n        self.add(label_z_1[0], label_z_2[0], label_z_3[0], label_z_4[0], label_z_5[0])\n        '\\n        #self.play(z_1.animate.set_value(complex(1, 1)), run_time=2)\\n        #self.wait()\\n        #self.play(z_3.animate.set_value(complex(-.75, .5)), z_2.animate.set_value(unit_roots(5)[4]), run_time=4, rate_func=smooth_increase)\\n        #self.wait()\\n        '\n        self.play(z_4.animate.set_value(complex(0, -1)), z_5.animate.set_value(complex(-1, -1)), run_time=3, rate_func=linear)\n        self.play(z_1.animate.set_value(unit_roots(3)[0]), z_2.animate.set_value(unit_roots(3)[1]), z_3.animate.set_value(unit_roots(3)[1]), z_4.animate.set_value(unit_roots(3)[2]), z_5.animate.set_value(unit_roots(3)[2]), run_time=3, rate_func=smooth_decrease)\n        self.wait()\n        self.play(z_1.animate.set_value(unit_roots(3)[2]), z_2.animate.set_value(unit_roots(3)[0]), z_3.animate.set_value(unit_roots(3)[0]), z_4.animate.set_value(unit_roots(3)[1]), z_5.animate.set_value(unit_roots(3)[1]), run_time=3, rate_func=smooth_increase)\n        self.play(z_1.animate.set_value(unit_roots(3)[1]), z_2.animate.set_value(unit_roots(3)[2]), z_3.animate.set_value(unit_roots(3)[2]), z_4.animate.set_value(unit_roots(3)[0]), z_5.animate.set_value(unit_roots(3)[0]), run_time=3, rate_func=smooth_decrease)\n        self.wait()\n        self.play(z_1.animate.set_value(unit_roots(5)[0]), z_2.animate.set_value(unit_roots(5)[1]), z_3.animate.set_value(unit_roots(5)[2]), z_4.animate.set_value(unit_roots(5)[3]), z_5.animate.set_value(unit_roots(5)[4]), run_time=4)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create an empty Manim scene for an introduction."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass Introduction(Scene):\n\n    def construct(self):\n        pass"}]}
{"messages": [{"role": "user", "content": "Visualize a vector field within a unit circle and demonstrate the convergence of points towards a fixed point."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass BrouwerIntroAnimation(MovingCameraScene):\n\n    def construct(self):\n        plane = NumberPlane(x_axis_config={'stroke_width': 0.5}, y_axis_config={'stroke_width': 0.5}, background_line_style={'stroke_width': 0.5})\n        unit_circle = Circle(1, color=RED)\n        a = np.array([0.2, -0.3, 0])\n        vector_field = ArrowVectorField(lambda pos: (fixed_point_func(pos, a) - pos) * (np.linalg.norm(pos) <= 1), x_range=[-1, 1, 0.15], y_range=[-1, 1, 0.15], vector_config={'stroke_width': 0.3})\n        for vector in vector_field:\n            vec_array = vector.get_end() - vector.get_start()\n            vector.tip.scale(0.3, about_point=vector.get_start() + vec_array / 2)\n            vector.tip.shift(0.1 * vec_array)\n        dot_list = VGroup()\n        for vector in vector_field:\n            dot = Dot(vector.get_start(), radius=DEFAULT_SMALL_DOT_RADIUS / 5)\n            dot_list += dot\n        fixed_point_dot = Dot(a, radius=DEFAULT_SMALL_DOT_RADIUS / 5)\n        self.play(AnimationGroup(Create(plane), Create(unit_circle), lag_ratio=0.5), run_time=3)\n        self.play(self.camera.frame.animate.set(width=5), unit_circle.animate.set(stroke_width=1), run_time=3)\n        self.play(*[GrowArrow(vector) for vector in vector_field], run_time=3)\n        self.wait(0.5)\n        self.play(*[FadeIn(dot) for dot in dot_list if np.linalg.norm(dot.get_center()) <= 1 and np.linalg.norm(dot.get_center() - a) >= 0.05], FadeIn(fixed_point_dot), vector_field.animate.set_opacity(0.5))\n        self.wait(0.5)\n        self.play(*[dot.animate.shift(vector.get_end() - vector.get_start()) for dot, vector in zip(dot_list, vector_field) if np.linalg.norm(dot.get_center()) <= 1], fixed_point_dot.animate.move_to(fixed_point_func(fixed_point_dot.get_center(), a)), run_time=3)\n        self.play(Flash(fixed_point_dot, line_length=0.05, flash_radius=3 * fixed_point_dot.radius, line_stroke_width=1))\n        self.wait()\n        self.play(FadeOut(vector_field, *[dot for dot in dot_list if np.linalg.norm(dot.get_center()) <= 1], fixed_point_dot, unit_circle, plane))"}]}
{"messages": [{"role": "user", "content": "Display an image of Brouwer with a caption and then fade in a title for \"Chapter 1: Fixed Points.\""}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass BrouwerHistory(Scene):\n\n    def construct(self):\n        image = SVGMobject('brouwer.svg')\n        image.height = config.frame_height / 1.2\n        image_rectangle = SurroundingRectangle(image, buff=0)\n        caption = Tex('Luitzen Egbertus Jan \\\\textsc{Brouwer}').next_to(image_rectangle, DOWN)\n        Group(image, image_rectangle, caption).move_to(ORIGIN)\n        self.play(AnimationGroup(AnimationGroup(Create(image_rectangle), Write(caption), lag_ratio=0, run_time=5), AnimationGroup(*[FadeIn(sub_image) for sub_image in image], lag_ratio=0.5, run_time=15)))\n        self.wait(10)\n        self.play(FadeOut(image, image_rectangle, caption), run_time=5)\n        self.wait()\n        title = Tex('Chapter 1 : Fixed Points')\n        underline = Underline(title).set_opacity([0, 1, 1, 0])\n        title_group = VGroup(title, underline).scale(1.5)\n        self.play(FadeIn(title_group), run_time=3)\n        self.play(FadeOut(title_group), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the intersection of a function's curve and the identity line, highlighting the fixed point with dashed lines, and then transform the function's curve to represent the difference between the function and the identity, before fading everything out."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass DefFixedPoints(Scene):\n\n    def construct(self):\n        tex_scale_factor = 0.7\n        f = lambda x: 0.3 * x ** 3 + 0.5 * x ** 2 - x - 0.5\n        fixed_point = dichotomie(lambda x: f(x) - x, -1, 2)\n        axes = Axes(x_range=[-1.2, 2.2], y_range=[-1.2, 2.2], x_length=6, y_length=6, tips=False)\n        axes_labels = axes.get_axis_labels()\n        v_dashed_line = DashedLine(axes.c2p(fixed_point, fixed_point), axes.c2p(fixed_point, 0), color=WHITE)\n        h_dashed_line = DashedLine(axes.c2p(fixed_point, fixed_point), axes.c2p(0, fixed_point), color=WHITE)\n        f_curve = axes.plot(f, x_range=[-1, 2])\n        f_label = MathTex('f').scale(tex_scale_factor).next_to(f_curve.get_end(), RIGHT)\n        id_curve = axes.plot(lambda x: x, x_range=[-1, 2], color=RED)\n        id_label = Tex('Id', color=RED).scale(tex_scale_factor).next_to(id_curve.get_end(), UP)\n        x_label = MathTex('x').scale(0.8).next_to(axes.c2p(fixed_point, 0), UP)\n        y_label = MathTex('f(x) = x').scale(tex_scale_factor).next_to(axes.c2p(0, fixed_point), RIGHT)\n        x_dot = Dot(axes.c2p(fixed_point, 0), color=YELLOW)\n        y_dot = Dot(axes.c2p(0, fixed_point), color=YELLOW)\n        intersection_point = Dot(axes.c2p(fixed_point, fixed_point), color=YELLOW)\n        f_m_id_curve = axes.plot(lambda x: f(x) - x, x_range=[-1, 2]).set_z_index(f_curve.z_index)\n        f_m_id_label = MathTex('f - \\\\mathrm{Id}').scale(tex_scale_factor).next_to(f_m_id_curve.get_end(), RIGHT)\n        self.play(Create(axes), Write(axes_labels), run_time=2)\n        self.wait(0.5)\n        self.play(Create(f_curve), Create(id_curve), Write(f_label), Write(id_label), run_time=2)\n        self.wait(0.5)\n        self.play(Create(intersection_point), Flash(intersection_point), run_time=1.5)\n        self.wait(0.5)\n        self.play(Create(v_dashed_line), Create(h_dashed_line), Create(x_dot), Create(y_dot), run_time=1.5)\n        self.play(Write(x_label), Write(y_label))\n        self.wait()\n        self.play(Transform(f_curve, f_m_id_curve), Transform(f_label, f_m_id_label), run_time=3)\n        self.wait()\n        self.play(AnimationGroup(FadeOut(f_curve, id_curve, f_label, id_label), FadeOut(axes, axes_labels, x_dot, x_label, y_dot, y_label, h_dashed_line, v_dashed_line, intersection_point), lag_ratio=0.3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the Brouwer Fixed Point Theorem by plotting a function f and the identity line, then showing the difference function g and its behavior to find a fixed point."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass BrouwerDim1Proof(Scene):\n\n    def construct(self):\n        thm = Tex('$f : [0, 1] \\\\to [0, 1], \\\\hspace{0.15cm} \\\\mathcal{C}^0 \\\\implies \\\\exists x \\\\in [0, 1], \\\\hspace{0.15cm} f(x)=x$', tex_environment=TexTemplate().add_to_preamble('\\\\usepackage{mathrsfs}')).scale(1.25)\n        tex_scale_factor = 0.7\n        axes = Axes(x_range=[-0.2, 1.2, 0.25], y_range=[-0.7, 1.2, 0.25], x_length=4.5, y_length=5.5, tips=False, x_axis_config={'include_numbers': True, 'numbers_to_include': [0, 1], 'decimal_number_config': {'num_decimal_places': 0}}, y_axis_config={'include_numbers': True, 'numbers_to_include': [0, 1], 'decimal_number_config': {'num_decimal_places': 0}}).to_edge(DOWN, buff=0.75).shift(2 * LEFT)\n        axes_labels = axes.get_axis_labels()\n        f = lambda x: 0.8 * np.sin(2.5 * x) + 0.1\n        g = lambda x: f(x) - x\n        fixed_point = dichotomie(lambda x: f(x) - x, 0, 1)\n        f_curve = axes.plot(f, x_range=[0, 1])\n        f_curve_copy = f_curve.generate_target()\n        f_label = MathTex('f').scale(tex_scale_factor).next_to(f_curve.get_end(), RIGHT)\n        f_label_copy = f_label.generate_target()\n        id_curve = axes.plot(lambda x: x, x_range=[0, 1], color=RED)\n        id_label = Tex('Id', color=RED).scale(tex_scale_factor).next_to(id_curve.get_end(), RIGHT)\n        g_curve = axes.plot(g, x_range=[0, 1], color=ORANGE)\n        g_label = MathTex('g = f - \\\\mathrm{Id}', color=ORANGE).scale(tex_scale_factor).next_to(g_curve.get_end(), RIGHT)\n        g_def = MathTex('g : [0, 1] &\\\\to [0, 1] \\\\\\\\ x &\\\\mapsto f(x) - x').scale(0.85).to_edge(RIGHT, buff=1.5)\n        dot_0 = Dot(axes.c2p(0, g(0)), color=YELLOW).set_z_index(g_curve.z_index + 2)\n        dot_1 = Dot(axes.c2p(1, g(1)), color=YELLOW).set_z_index(g_curve.z_index + 2)\n        moving_dot_left = dot_0.generate_target().set_color(RED).set_z_index(g_curve.z_index + 1)\n        moving_dot_right = dot_1.generate_target().set_color(RED).set_z_index(g_curve.z_index + 1)\n        distance_conversion = np.linalg.norm(axes.c2p(1, 0) - axes.c2p(0, 0))\n        curve_continuity_text = Tex('continious')\n        curve_continuity_text.scale(0.75 / curve_continuity_text.width).move_to(0.34 * RIGHT).apply_function(lambda pos: np.array([pos[0], pos[1] + g(pos[0]), 0]))\n        curve_continuity_text.scale(0.35 * distance_conversion).stretch(2, 0).next_to(axes.c2p(3 / 8, g(3 / 8)), UP, buff=-0.25).stretch(1.25, 1)\n        self.play(Write(thm), run_time=5)\n        self.wait()\n        self.play(thm.animate.scale(0.6).to_edge(UP), Create(axes), Write(axes_labels), run_time=3.25)\n        self.play(Create(f_curve), Create(id_curve), Write(f_label), Write(id_label), run_time=2)\n        self.wait()\n        self.play(Write(g_def), Transform(f_curve_copy, g_curve), Transform(f_label_copy, g_label), id_curve.animate.set_stroke(opacity=0.25), f_curve.animate.set_stroke(opacity=0.25), run_time=3)\n        self.wait()\n        self.play(AnimationGroup(AnimationGroup(Create(dot_0), Flash(dot_0), lag_ratio=0), AnimationGroup(Create(dot_1), Flash(dot_1), lag_ratio=0), lag_ratio=0.75), run_time=4)\n        self.wait()\n        self.play(MoveAlongPath(moving_dot_left, axes.plot(g, x_range=[0, fixed_point])), MoveAlongPath(moving_dot_right, axes.plot(g, x_range=[fixed_point, 1]).reverse_direction()), Write(curve_continuity_text), run_time=4)\n        self.play(id_curve.animate.set_stroke(opacity=1), f_curve.animate.set_stroke(opacity=1), moving_dot_left.animate.move_to(axes.c2p(fixed_point, fixed_point)), run_time=2)\n        self.wait()\n        '\\n        self.play(\\n            AnimationGroup(\\n                FadeOut(f_curve, id_curve, f_label, id_label, f_curve_copy, f_label_copy, g_def),\\n                FadeOut(axes, axes_labels, moving_dot_right, moving_dot_left, dot_0, dot_1, thm),\\n                lag_ratio=0.3\\n            )\\n        )\\n        self.wait()\\n        '"}]}
{"messages": [{"role": "user", "content": "Display a chapter title for Brouwer's theorem with an underline, then fade it out."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass FixedPointsThmList(Scene):\n\n    def construct(self):\n        title = Tex(\"Chapter 2 : \\\\textsc{Brouwer}'s theorem\")\n        underline = Underline(title).set_opacity([0, 1, 1, 0])\n        title_group = VGroup(title, underline).scale(1.5)\n        self.play(FadeIn(title_group), run_time=3)\n        self.play(FadeOut(title_group), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the Cauchy-Lipschitz theorem by plotting solutions to a differential equation and then fading in and out an image."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass CauchyLipschitzThm(Scene):\n\n    def construct(self):\n        plane = NumberPlane(x_axis_config={'stroke_width': 1, 'stroke_opacity': 0.8}, y_axis_config={'stroke_width': 1, 'stroke_opacity': 0.8}, background_line_style={'stroke_width': 1, 'stroke_opacity': 0.8})\n        x_values = np.linspace(-8, 7.15, 1000)\n\n        def diff_eq(y, x):\n            return 0.05 * y - np.sin(y) / 10\n        curves = []\n        for init_height in np.arange(-4, 4.25, 0.25):\n            solution = odeint(diff_eq, init_height, x_values)\n            curve = plane.plot_line_graph(x_values, solution[:, 0], add_vertex_dots=False, line_color=interpolate_color(RED, BLUE, init_height / 8 + 1 / 2))\n            curves.append(curve)\n        diff_eq_tex = MathTex('\\\\begin{cases} \\\\displaystyle \\\\frac{\\\\mathrm{d}y}{\\\\mathrm{d}x} = \\\\frac{y - 2\\\\sin{(y)}}{20} \\\\\\\\ y(-8) \\\\in [-4, 4] \\\\end{cases}').scale(0.8).to_edge(DOWN, buff=0.5)\n        rectangle_diff_eq = SurroundingRectangle(diff_eq_tex, color=BLACK, fill_opacity=0.6, stroke_opacity=0)\n        diff_eq_tex.set_z_index(rectangle_diff_eq.z_index + 1)\n        cauchy_lipschitz_thm_tex = Tex('Let $E$ be a \\\\textsc{Banach} space, $\\\\Omega$ an open set of $\\\\mathbb{R} \\\\times E$ and $f : \\\\Omega \\\\to E$ a continuous function. If $f$ is \\\\textit{locally lipschitzian}, $$\\\\begin{cases} \\\\displaystyle \\\\frac{\\\\mathrm{d}y}{\\\\mathrm{d}x} = f(x, y) \\\\\\\\ y(x_0 \\\\in \\\\mathbb{R}) = y_0 \\\\in E\\\\end{cases}$$ has a unique maximal solution.', tex_environment='flushleft').scale(0.7).to_edge(UP, buff=0.5)\n        rectangle_cl = SurroundingRectangle(cauchy_lipschitz_thm_tex, color=BLACK, fill_opacity=0.6, stroke_opacity=0)\n        cauchy_lipschitz_thm_tex.set_z_index(rectangle_cl.z_index + 1)\n        hex_image = ImageMobject('hex_image.jpg').set_z_index(31)\n        hex_image.height = 0.8 * config.frame_height\n        self.play(FadeIn(plane))\n        self.play(AnimationGroup(AnimationGroup(*[Create(curve) for curve in curves], lag_ratio=0.5, run_time=6), AnimationGroup(Write(diff_eq_tex), Write(cauchy_lipschitz_thm_tex), FadeIn(rectangle_diff_eq, rectangle_cl), lag_ratio=0, run_time=4), lag_ratio=1 / 6))\n        self.wait()\n        self.play(FadeIn(Rectangle(width=30, height=30, fill_color=BLACK, fill_opacity=1).set_z_index(30)), run_time=1.5)\n        self.wait()\n        self.play(FadeIn(hex_image), run_time=1.5)\n        self.wait()\n        self.play(FadeOut(hex_image), run_time=1.5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display Brouwer's fixed-point theorem statement with an underline, then fade it out."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass BrouwersThm(Scene):\n\n    def construct(self):\n        thm = Tex(\"Brouwer's theorem :\\\\\\\\\", 'Let $(E, ||\\\\cdot||)$ be a finite-dimensional normed vector space, \\\\\\\\$K$ a non-empty convex compact subset of E and', '$$f : K \\\\to K$$', 'a continuous map. Then $f$ has a fixed point.', tex_environment='flushleft').scale(0.9)\n        thm[0].move_to(ORIGIN).shift(2 * UP).scale(1 / 0.9)\n        thm[1:4].move_to(ORIGIN).shift(0.5 * DOWN)\n        thm[2].shift(2 * LEFT)\n        underline = Underline(thm[0]).set_opacity([0, 1, 0])\n        self.play(Write(thm), Create(underline), run_time=10)\n        self.wait()\n        self.play(FadeOut(thm, underline))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate a vector field on a plane, demonstrating a point's transformation and the effect of different vector field densities and continuity."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass BrouwersThmIllustration1(MovingCameraScene):\n\n    def construct(self):\n        plane = NumberPlane(x_axis_config={'stroke_width': 0.5}, y_axis_config={'stroke_width': 0.5}, background_line_style={'stroke_width': 0.5})\n        unit_circle = Circle(1, color=RED)\n        tex_scale_factor = 0.3\n        tex_buff = 0.1\n        a = np.array([0.4, 0.6, 0])\n        theta = PI / 6\n        vector_field = ArrowVectorField(lambda pos: (rotation(theta) @ pos - pos) * (np.linalg.norm(pos) <= 1), x_range=[-1, 1, 0.25], y_range=[-1, 1, 0.25], vector_config={'stroke_width': 1}, length_func=lambda norm: norm)\n        vector_field_with_too_many_arrows = ArrowVectorField(lambda pos: (rotation(theta) @ pos - pos) * (np.linalg.norm(pos) <= 1), x_range=[-1, 1, 0.1], y_range=[-1, 1, 0.1], vector_config={'stroke_width': 1}, length_func=lambda norm: norm)\n        vector_field_bis = ArrowVectorField(lambda pos: (fixed_point_func(pos, a) - pos) * (np.linalg.norm(pos) <= 1), x_range=[-1, 1, 0.2], y_range=[-1, 1, 0.2], vector_config={'stroke_width': 0.8}, length_func=lambda norm: 6 * 0.45 * sigmoid(norm))\n        for vector in vector_field_bis:\n            vector.scale(1 / 6, scale_tips=True, about_point=vector.get_start())\n        vector_field.move_to(ORIGIN)\n        vector_field_bis.remove(vector_field_bis[85])\n        arrow_ex_index = 42\n        ex_dot = Dot(vector_field[arrow_ex_index].get_start(), radius=DEFAULT_SMALL_DOT_RADIUS / 2)\n        ex_dot_copy = ex_dot.generate_target().move_to(vector_field[arrow_ex_index].get_end())\n        ex_image_dot = Dot(ex_dot.get_center(), radius=DEFAULT_SMALL_DOT_RADIUS / 2)\n        ex_arrow = vector_field[arrow_ex_index]\n        ex_arrow_array = ex_arrow.get_end() - ex_arrow.get_start()\n        VGroup(ex_dot, ex_image_dot, ex_dot_copy, ex_image_dot).set_z_index(ex_arrow.z_index + 1)\n        ex_dot_label = MathTex('x').scale(tex_scale_factor).next_to(ex_dot, -ex_arrow_array / np.linalg.norm(ex_arrow_array), buff=tex_buff)\n        ex_arrow_label = MathTex('f(x) - x').scale(tex_scale_factor / 2).move_to(ex_arrow).rotate(ex_arrow.get_slope()).shift(-0.35 * np.array([-ex_arrow_array[1], ex_arrow_array[0], 0]))\n        ex_image_dot_label = MathTex('f(x)').scale(tex_scale_factor).next_to(ex_dot_copy, ex_arrow_array / np.linalg.norm(ex_arrow_array), buff=tex_buff)\n        rectangles = VGroup(SurroundingRectangle(ex_dot_label, color=BLACK, stroke_opacity=0, fill_opacity=0.75, buff=0.025), SurroundingRectangle(ex_arrow_label, color=BLACK, stroke_opacity=0, fill_opacity=0.75, buff=0.025), SurroundingRectangle(ex_image_dot_label, color=BLACK, stroke_opacity=0, fill_opacity=0.75, buff=0.025)).set_z_index(vector_field.z_index + 1)\n        VGroup(ex_dot_label, ex_arrow_label, ex_image_dot_label, vector_field[arrow_ex_index]).set_z_index(vector_field.z_index + 2)\n        VGroup(ex_dot, ex_image_dot).set_z_index(vector_field[arrow_ex_index].z_index + 1)\n        x_tex = MathTex('x = \\\\begin{pmatrix} x_1 \\\\\\\\ x_2 \\\\end{pmatrix}').shift(1.6 * RIGHT).scale(tex_scale_factor).set_z_index(plane.z_index + 2)\n        f_x_tex = MathTex('\\\\mapsto f(x) = \\\\begin{pmatrix} f_1(x_1) \\\\\\\\ f_2(x_2) \\\\end{pmatrix}').scale(tex_scale_factor).next_to(x_tex, RIGHT, buff=tex_buff).set_z_index(plane.z_index + 2)\n        rectangle_tex = SurroundingRectangle(VGroup(x_tex, f_x_tex), color=BLACK, stroke_opacity=0, fill_opacity=0.9).set_z_index(x_tex.z_index - 1)\n        self.play(Create(plane), Create(unit_circle), run_time=2)\n        self.play(self.camera.frame.animate.set(width=5).shift(RIGHT), unit_circle.animate.set(stroke_width=1), run_time=3)\n        self.wait()\n        self.play(Create(ex_dot), FadeIn(x_tex, ex_dot_label, rectangle_tex))\n        self.wait()\n        self.play(Transform(ex_image_dot, ex_dot_copy), GrowArrow(ex_arrow), FadeIn(ex_image_dot_label, f_x_tex, ex_arrow_label), run_time=2)\n        self.wait()\n        self.play(*[GrowArrow(vector_field[k]) for k in range(len(vector_field)) if k != 42], FadeIn(rectangles), run_time=1.5)\n        self.wait()\n        self.play(FadeOut(ex_dot, ex_image_dot, ex_dot_label, ex_image_dot_label, ex_arrow_label, rectangles))\n        self.wait()\n        dot_list = VGroup(*[Dot(vector.get_start(), radius=DEFAULT_SMALL_DOT_RADIUS / 2) for vector in vector_field if np.linalg.norm(vector.get_end()) <= 1 and np.linalg.norm(vector.get_start()) <= 1])\n        vector_field[arrow_ex_index].set_z_index(vector_field[0].z_index)\n        self.play(FadeIn(dot_list))\n        self.play(*[dot.animate.shift(rotation(theta) @ dot.get_center() - dot.get_center()) for dot in dot_list])\n        self.wait()\n        self.play(FadeOut(dot_list))\n        self.wait()\n        self.play(*[GrowArrow(vector) for vector in vector_field_with_too_many_arrows])\n        self.wait()\n        self.play(*[GrowArrow(vector, reverse_rate_function=True) for vector in vector_field_with_too_many_arrows])\n        self.wait()\n        not_valid_index = 69\n        self.play(vector_field[not_valid_index].animate.rotate(-PI / 3, about_point=vector_field[not_valid_index].get_start()))\n        self.wait()\n        cross = Cross(vector_field[not_valid_index], stroke_width=2)\n        self.play(GrowFromCenter(cross))\n        self.wait()\n        self.play(AnimationGroup(FadeOut(cross), vector_field[not_valid_index].animate.rotate(PI / 3, about_point=vector_field[not_valid_index].get_start()), lag_ratio=0))\n        self.wait()\n        moving_dot = Dot(vector_field[69].get_start(), radius=DEFAULT_SMALL_DOT_RADIUS / 2).set_z_index(vector_field[0].z_index + 2)\n        dot_pos = moving_dot.get_center()\n        moving_arrow = always_redraw(lambda: vector_field.get_vector(moving_dot.get_center()))\n        self.play(vector_field.animate.set_opacity(0.25), Create(VGroup(moving_dot, moving_arrow)))\n        self.wait()\n        self.play(moving_dot.animate.shift(0.05 * RIGHT), run_time=2)\n        self.play(MoveAlongPath(moving_dot, Circle(0.05).move_to(dot_pos)), run_time=4)\n        self.play(moving_dot.animate.shift(0.05 * LEFT), run_time=2)\n        self.play(FadeOut(moving_dot, moving_arrow), vector_field.animate.set_opacity(1), VGroup(x_tex, f_x_tex, rectangle_tex).animate.shift(0.75 * UP))\n        self.wait()\n        not_continuous_vector_field = ArrowVectorField(lambda pos: np.exp(-1 / (1 - pos[0] ** 2 - pos[1] ** 2)) * ((1 + pos[0]) * RIGHT * (pos[0] >= 0) + (1 - pos[0]) * LEFT * (pos[0] < 0)) * (np.linalg.norm(pos) <= 1), x_range=[-1, 1, 0.15], y_range=[-1, 1, 0.15], vector_config={'stroke_width': 1}, length_func=lambda norm: norm).set_opacity(0.5)\n        moving_dot_bis = Dot(np.array([0.05, 0.05, 0]), radius=DEFAULT_SMALL_DOT_RADIUS / 2).set_z_index(not_continuous_vector_field[0].z_index + 2)\n        dot_pos_bis = moving_dot_bis.get_center()\n        moving_arrow_bis = always_redraw(lambda: not_continuous_vector_field.get_vector(moving_dot_bis.get_center()))\n        oceane = MathTex('f : \\\\begin{pmatrix} x_1 \\\\\\\\ x_2 \\\\end{pmatrix}', '\\\\mapsto e^{-\\\\frac{1}{1 - x_1^2 - x_2^2}} \\\\displaystyle \\\\begin{pmatrix} 1 + \\\\text{sign}(x_1) x_1 \\\\\\\\ 0 \\\\end{pmatrix}').scale(tex_scale_factor / 1.25).shift(2.25 * RIGHT)\n        camille = SurroundingRectangle(oceane, stroke_width=0, color=BLACK, fill_opacity=0.9)\n        oceane.set_z_index(camille.z_index + 1)\n        self.play(ReplacementTransform(vector_field, not_continuous_vector_field), FadeIn(oceane, camille))\n        self.play(FadeIn(moving_dot_bis, moving_arrow_bis))\n        self.wait()\n        self.play(moving_dot_bis.animate.move_to(np.array([-0.05, 0.05, 0])))\n        self.play(moving_dot_bis.animate.move_to(np.array([-0.05, -0.05, 0])))\n        self.play(moving_dot_bis.animate.move_to(np.array([-0.05, 0, 0])))\n        self.play(moving_dot_bis.animate.move_to(dot_pos_bis))\n        self.wait()\n        self.play(FadeOut(moving_dot_bis, moving_arrow_bis), ReplacementTransform(not_continuous_vector_field, vector_field_bis), VGroup(x_tex, f_x_tex, rectangle_tex).animate.shift(0.75 * DOWN), FadeOut(oceane, camille, x_tex, f_x_tex, rectangle_tex), self.camera.frame.animate.shift(LEFT), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the flow of a vector field around a unit circle, highlight a fixed point, and then transition to illustrating a second, transformed vector field and its fixed point associated with a convex shape."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass BrouwersThmIllustration2(MovingCameraScene):\n\n    def construct(self):\n        plane = NumberPlane(x_range=[-config.frame_width, config.frame_width, 1], y_range=[-config.frame_height, config.frame_height, 1], x_length=2 * config.frame_width, y_length=2 * config.frame_height, x_axis_config={'stroke_width': 0.5}, y_axis_config={'stroke_width': 0.5}, background_line_style={'stroke_width': 0.5})\n        unit_circle = Circle(1, color=RED, stroke_width=1)\n        self.camera.frame.width = 5\n        a = np.array([0.4, 0.6, 0])\n        vector_field = ArrowVectorField(lambda pos: (fixed_point_func(pos, a) - pos) * (np.linalg.norm(pos) <= 1), x_range=[-1, 1, 0.2], y_range=[-1, 1, 0.2], vector_config={'stroke_width': 0.8}, length_func=lambda norm: 6 * 0.45 * sigmoid(norm))\n        for vector in vector_field:\n            vector.scale(1 / 6, scale_tips=True, about_point=vector.get_start())\n        vector_field.move_to(ORIGIN)\n        vector_field.remove(vector_field[85])\n        vector_field_model = ArrowVectorField(lambda pos: (fixed_point_func(pos, a) - pos) * (np.linalg.norm(pos) <= 1), x_range=[-1, 1, 0.2], y_range=[-1, 1, 0.2], vector_config={'stroke_width': 0.8})\n        fixed_point = Dot(a, radius=DEFAULT_SMALL_DOT_RADIUS / 2, color=RED)\n        dots_list = VGroup(*[Dot(vector.get_start(), radius=DEFAULT_SMALL_DOT_RADIUS / 3, color=YELLOW) for vector in vector_field_model]).sort(submob_func=lambda pos: -pos.get_center()[1])\n        self.add(plane, unit_circle, vector_field)\n        self.wait()\n        self.play(AnimationGroup(*[FadeIn(dot, shift=Line(dot.get_center(), np.array([0, 0, -4])).get_unit_vector()) for dot in dots_list if np.linalg.norm(dot.get_center()) <= 1 and np.linalg.norm(dot.get_center() - fixed_point.get_center()) >= 0.1], lag_ratio=0.05), vector_field.animate.set_opacity(0.5), run_time=3)\n        self.wait()\n        self.play(FocusOn(fixed_point))\n        self.play(FadeIn(fixed_point), Flash(fixed_point, line_length=0.1, flash_radius=2.5 * fixed_point.radius, line_stroke_width=1, color=RED), run_time=1.5)\n        self.play(*[dot.animate.shift(vector_field_model.get_vector(dot.get_center()).get_vector()) for dot in dots_list if np.linalg.norm(dot.get_center()) <= 1 and np.linalg.norm(dot.get_center() - fixed_point.get_center()) >= 0.1], fixed_point.animate.shift(vector_field_model.func(fixed_point.get_center())), run_time=2)\n        self.wait()\n        compact_convex = SVGMobject('potato_2.svg').set_color(RED).move_to(ORIGIN)\n        compact_convex_curve = VMobject(stroke_width=1).start_new_path(compact_convex.get_all_points()[0])\n        compact_convex_curve.add_points_as_corners(compact_convex.get_all_points()[1:])\n        width, height = (compact_convex_curve.width, compact_convex_curve.height)\n        compact_convex_curve.scale(2 / max(width, height)).stretch(0.95, 0)\n        compact_convex.scale(2 / max(width, height), about_point=compact_convex.get_center()).set_stroke(width=1)\n        compact_convex.scale(1.5).shift(5 * UR)\n        self.play(self.camera.frame.animate.move_to(compact_convex).scale(1.5), Create(compact_convex), run_time=2)\n        self.wait()\n        a_2 = np.array([0.3, -0.4, 0])\n        vector_field_2 = ArrowVectorField(lambda pos: (fixed_point_func(pos, a_2) - pos) * (len(Intersection(compact_convex_curve, Dot(pos, radius=DEFAULT_SMALL_DOT_RADIUS / 2)).points) == len(Intersection(compact_convex_curve, Dot(compact_convex_curve.get_center(), radius=DEFAULT_SMALL_DOT_RADIUS / 2)).points)), x_range=[-1, 1, 0.15], y_range=[-1, 1, 0.15], vector_config={'stroke_width': 1}, length_func=lambda norm: 6 * 0.35 * sigmoid(norm))\n        for vector in vector_field_2:\n            vector.scale(1 / 6, scale_tips=True, about_point=vector.get_start())\n        vector_field_2.scale(1.5).shift(5 * UR).shift(0.1 * RIGHT)\n        vector_field_2.remove(*[vector for vector in vector_field_2 if np.linalg.norm(vector.get_vector()) == 0])\n        vector_field_2.remove(vector_field_2[8], vector_field_2[48], vector_field_2[75])\n        fixed_point_2 = Dot(5 * UR + 1.5 * a_2 + 0.1 * RIGHT + 0.04 * DOWN, radius=1.5 * DEFAULT_SMALL_DOT_RADIUS / 2, color=RED)\n        dots_list_2 = VGroup(*[Dot(vector.get_start(), radius=1.5 * DEFAULT_SMALL_DOT_RADIUS / 3, color=YELLOW) for vector in vector_field_2])\n        compact_convex.set_z_index(dots_list_2[0].z_index + 1)\n        self.play(*[GrowArrow(vector) for vector in vector_field_2], run_time=1.5)\n        self.wait()\n        self.play(AnimationGroup(*[FadeIn(dot, shift=Line(dot.get_center(), compact_convex.get_center() - np.array([0, 0, 4])).get_unit_vector()) for dot in dots_list_2], lag_ratio=0), vector_field_2.animate.set_opacity(0.5), run_time=1.5)\n        self.wait()\n        self.play(FocusOn(fixed_point_2))\n        self.play(FadeIn(fixed_point_2), Flash(fixed_point_2, line_length=1.5 * 0.1, flash_radius=1.5 * 2.5 * fixed_point.radius, line_stroke_width=1.5 * 1, color=RED), run_time=1.5)\n        self.play(*[dots_list_2[k].animate.shift(vector_field_2[k].get_vector()) for k in range(len(dots_list_2))], fixed_point_2.animate.shift(vector_field_2.func(fixed_point_2.get_center())), run_time=2)\n        self.wait()\n        self.play(FadeIn(Rectangle(width=50, height=50, fill_color=BLACK, fill_opacity=1).set_z_index(100)), run_time=1.5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a Manim scene named CoffeeCup with an empty construct method."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass CoffeeCup(Scene):\n\n    def construct(self):\n        pass"}]}
{"messages": [{"role": "user", "content": "Display a title slide for Chapter 3 of the Hex game, followed by images and captions of John Forbes Nash and Piet Hein, then fade them out."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass HexHistory(Scene):\n\n    def construct(self):\n        title = Tex('Chapter 3 : \\\\textsc{Hex} game')\n        underline = Underline(title).set_opacity([0, 1, 1, 0])\n        title_group = VGroup(title, underline).scale(1.5)\n        self.play(FadeIn(title_group), run_time=3)\n        self.play(FadeOut(title_group), run_time=2)\n        self.wait()\n        image_nash, image_hein = (SVGMobject('nash.svg'), SVGMobject('hein.svg'))\n        image_nash.height = config.frame_height / 1.25\n        image_hein.height = config.frame_height / 1.25\n        image_nash_rectangle = SurroundingRectangle(image_nash, buff=0).set_z_index(image_nash.z_index + 1)\n        image_hein_rectangle = SurroundingRectangle(image_hein, buff=0).set_z_index(image_hein.z_index + 1).next_to(image_nash_rectangle, RIGHT)\n        image_hein.move_to(image_hein_rectangle)\n        caption_nash = Tex('John Forbes \\\\textsc{Nash}').next_to(image_nash_rectangle, DOWN)\n        caption_hein = Tex('Piet \\\\textsc{Hein}').next_to(image_hein_rectangle, DOWN)\n        Group(image_nash, image_nash_rectangle, caption_nash, image_hein, image_hein_rectangle, caption_hein).move_to(ORIGIN)\n        self.play(AnimationGroup(AnimationGroup(Create(image_nash_rectangle), Create(image_hein_rectangle), Write(caption_nash), Write(caption_hein), lag_ratio=0, run_time=5), AnimationGroup(*[FadeIn(sub_image) for sub_image in image_nash], lag_ratio=0.5, run_time=15), AnimationGroup(*[FadeIn(sub_image) for sub_image in image_hein], lag_ratio=0.5, run_time=15)))\n        self.wait(10)\n        self.play(FadeOut(image_nash, image_nash_rectangle, caption_nash, image_hein, image_hein_rectangle, caption_hein), run_time=5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the setup and gameplay of a hex board game, showing pawns being placed, winning paths indicated, and a character moving along these paths."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass HexGame(Scene):\n\n    def construct(self):\n        board_image = BoardImage(hexagon_stroke_color=WHITE, sides_stroke_color=WHITE).scale(0.75)\n        board_hexagons = board_image[:-4]\n        board_sides = board_image[-4:]\n        board = Board()\n        pawn_radius = 0.8 * board_image.side_length / 2\n        h_arrow = DoubleArrow(start=board_hexagons[0][0].get_center(), end=board_hexagons[0][-1].get_center(), color=YELLOW).shift(0.75 * UP).stretch(1.15, 0)\n        v_arrow = DoubleArrow(start=board_hexagons[0][-1].get_center(), end=board_hexagons[-1][-1].get_center(), color=YELLOW).rotate(PI / 3).stretch(1.15, 0).rotate(-PI / 3).shift(0.75 * (np.sqrt(3) / 2 * RIGHT + 1 / 2 * UP))\n        h_arrow_label, v_arrow_label = (MathTex('11').next_to(h_arrow, UP, buff=0.1), MathTex('11').next_to(v_arrow.get_center(), np.sqrt(3) / 2 * UP + 1 / 2 * RIGHT, buff=0.25))\n        game_1_w = [(0, 0), (0, 1), (0, 5), (0, 6), (0, 8), (0, 9), (1, 0), (1, 1), (1, 4), (1, 5), (1, 7), (1, 8), (1, 10), (2, 0), (2, 3), (2, 4), (2, 5), (2, 6), (2, 8), (3, 9), (3, 10), (4, 1), (4, 3), (4, 4), (4, 6), (4, 10), (5, 2), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10), (6, 0), (6, 2), (6, 3), (6, 4), (6, 6), (6, 7), (6, 8), (7, 2), (7, 6), (7, 9), (7, 10), (8, 0), (8, 1), (8, 2), (8, 4), (8, 5), (9, 0), (9, 1), (9, 2), (9, 6), (9, 10), (10, 0), (10, 1), (10, 3), (10, 6), (10, 7), (7, 7)]\n        game_1_b = [(k, l) for k in range(11) for l in range(11)]\n        for pos in game_1_w:\n            game_1_b.remove(pos)\n        game_1_b.append((0, 2))\n        blacks_winning_path = [(5, 0), (5, 1), (4, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (2, 9), (2, 10)]\n        white_winning_path = [(0, 9), (1, 8), (2, 8), (2, 9), (3, 9), (3, 10), (4, 10), (5, 9), (5, 8), (5, 7), (5, 6), (5, 5), (5, 4), (6, 3), (7, 2), (8, 2), (9, 2), (10, 1)]\n        blacks_winning_pawns = VGroup(*[Dot(board_hexagons[pos[0]][pos[1]].get_center(), color=BLACK, radius=pawn_radius).set_z_index(board_hexagons[0][0].z_index + 1) for pos in blacks_winning_path])\n        whites_winning_pawns = VGroup(*[Dot(board_hexagons[pos[0]][pos[1]].get_center(), color=WHITE, radius=pawn_radius).set_z_index(board_hexagons[0][0].z_index + 1) for pos in white_winning_path])\n        w_pawns = VGroup(*[Dot(board_hexagons[pos[0]][pos[1]].get_center(), color=WHITE, radius=pawn_radius).set_z_index(board_hexagons[0][0].z_index + 1) for pos in game_1_w])\n        b_pawns = VGroup(*[Dot(board_hexagons[pos[0]][pos[1]].get_center(), color=BLACK, radius=pawn_radius).set_z_index(board_hexagons[0][0].z_index + 1) for pos in game_1_b])\n        w_pawns_copy, b_pawns_copy = (w_pawns.copy(), b_pawns.copy())\n        b_pawns_copy[12].set_color(WHITE)\n        w_pawns_copy[37].set_color(BLACK)\n        rd.shuffle(w_pawns)\n        rd.shuffle(b_pawns)\n        self.play(AnimationGroup(*[FadeIn(hexagon, shift=-Line(hexagon.get_center(), np.array([0, 0, -6])).get_unit_vector()) for hexagon in board_hexagons], lag_ratio=0.1), run_time=3)\n        self.wait()\n        self.play(*[DrawBorderThenFill(side) for side in board_sides])\n        self.wait()\n        self.play(DrawBorderThenFill(VGroup(h_arrow, v_arrow)), Write(VGroup(v_arrow_label, h_arrow_label)))\n        self.wait()\n        self.play(FadeOut(h_arrow, v_arrow), Unwrite(VGroup(v_arrow_label, h_arrow_label)))\n        self.wait()\n        self.play(FadeIn(w_pawns[0]), run_time=0.5)\n        self.wait()\n        self.play(FadeIn(b_pawns[0]), run_time=0.5)\n        self.wait()\n        self.add(*[hexagon for hexagon in board_hexagons], w_pawns[0], b_pawns[0])\n        self.play(AnimationGroup(*[AnimationGroup(FadeIn(w_pawns[k]), FadeIn(b_pawns[k]), lag_ratio=0.5) for k in range(1, len(w_pawns))], lag_ratio=0.5), run_time=10)\n        self.wait()\n        self.play(AnimationGroup(*[Indicate(blacks_winning_pawns[k]) for k in range(len(blacks_winning_pawns))], lag_ratio=0.2), run_time=2.5)\n        self.remove(*[blacks_winning_pawns[k] for k in range(len(blacks_winning_pawns))])\n        self.wait()\n        self.play(Transform(b_pawns, b_pawns_copy), Transform(w_pawns, w_pawns_copy))\n        self.wait()\n        b_pawns.save_state()\n        w_pawns.save_state()\n        self.play(AnimationGroup(*[Indicate(whites_winning_pawns[k]) for k in range(len(whites_winning_pawns))], lag_ratio=0.2), run_time=2.5)\n        self.remove(*[pawn for pawn in whites_winning_pawns])\n        self.wait()\n        self.play(AnimationGroup(AnimationGroup(b_pawns[12].animate.set_color(BLACK), w_pawns[37].animate.set_color(WHITE), lag_ratio=0), AnimationGroup(*[Transform(pawn, board_hexagons[0][0].copy().set_color(BLUE).move_to(pawn)) for pawn in w_pawns]), lag_ratio=1))\n        self.play(AnimationGroup(*[Transform(pawn, board_hexagons[0][0].copy().set_color(DARK_BROWN).move_to(pawn)) for pawn in b_pawns]))\n        bonhomme = SVGMobject('bonhomme.svg').scale(0.25).set_z_index(w_pawns[0].z_index + 1).move_to(blacks_winning_pawns[0])\n        blacks_winning_path_line = VMobject().add(*[Line(blacks_winning_pawns[k].get_center(), blacks_winning_pawns[k + 1].get_center()) for k in range(len(blacks_winning_pawns) - 1)])\n        points_b = []\n        for sub in blacks_winning_path_line:\n            for point in sub.points:\n                points_b.append(point)\n        blacks_winning_path_line = blacks_winning_path_line.set_points_as_corners(points_b)\n        whites_winning_path_line = VMobject().add(*[Line(whites_winning_pawns[k].get_center(), whites_winning_pawns[k + 1].get_center()) for k in range(len(whites_winning_pawns) - 1)])\n        points_w = []\n        for sub in whites_winning_path_line:\n            for point in sub.points:\n                points_w.append(point)\n        whites_winning_path_line = whites_winning_path_line.set_points_as_corners(points_w)\n        self.wait()\n        self.play(FadeIn(bonhomme))\n        self.wait()\n        self.play(MoveAlongPath(bonhomme, blacks_winning_path_line), run_time=3)\n        self.wait()\n        self.play(b_pawns[12].animate.set_color(BLUE).set_z_index(b_pawns[0][0].z_index - 1), w_pawns[37].animate.set_color(DARK_BROWN), bonhomme.animate.move_to(whites_winning_pawns[0]))\n        self.wait()\n        self.play(MoveAlongPath(bonhomme, whites_winning_path_line), run_time=3)\n        self.wait()\n        self.play(b_pawns.animate.restore(), w_pawns.animate.restore(), FadeOut(bonhomme))"}]}
{"messages": [{"role": "user", "content": "Animate a Hex game board, showing pawn movements and indicating winning paths, culminating in a visual recap of a theorem."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass HexThmProof(Scene):\n\n    def construct(self):\n        board_image = BoardImage(hexagon_stroke_color=WHITE, sides_stroke_color=WHITE).scale(0.75)\n        board_hexagons = board_image[:-4]\n        board_sides = board_image[-4:]\n        pawn_radius = 0.8 * board_image.side_length / 2\n        game_1_w = [(0, 0), (0, 1), (0, 5), (0, 6), (0, 8), (0, 9), (1, 0), (1, 1), (1, 4), (1, 5), (1, 7), (1, 8), (1, 10), (2, 0), (2, 3), (2, 4), (2, 5), (2, 6), (2, 8), (2, 9), (3, 9), (3, 10), (4, 1), (4, 3), (4, 4), (4, 6), (4, 10), (5, 2), (5, 4), (5, 5), (5, 6), (5, 7), (5, 8), (5, 9), (5, 10), (6, 0), (6, 2), (6, 3), (6, 6), (6, 7), (6, 8), (7, 2), (7, 6), (7, 7), (7, 9), (7, 10), (8, 0), (8, 1), (8, 2), (8, 4), (8, 5), (9, 0), (9, 1), (9, 2), (9, 6), (9, 10), (10, 0), (10, 1), (10, 3), (10, 6), (10, 7)]\n        game_1_b = [(k, l) for k in range(11) for l in range(11)]\n        for pos in game_1_w:\n            game_1_b.remove(pos)\n        game_1_b.append((0, 2))\n        blacks_winning_path = [(3, 0), (2, 1), (2, 2), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7), (3, 8), (2, 9), (1, 9), (0, 10)]\n        white_winning_path = [(0, 9), (1, 8), (2, 8), (2, 9), (3, 9), (3, 10), (4, 10), (5, 9), (5, 8), (5, 7), (5, 6), (5, 5), (5, 4), (6, 3), (7, 2), (8, 2), (9, 2), (10, 1)]\n        blacks_winning_pawns = VGroup(*[Dot(board_hexagons[pos[0]][pos[1]].get_center(), color=BLACK, radius=pawn_radius).set_z_index(board_hexagons[0][0].z_index + 1) for pos in blacks_winning_path])\n        whites_winning_pawns = VGroup(*[Dot(board_hexagons[pos[0]][pos[1]].get_center(), color=WHITE, radius=pawn_radius).set_z_index(board_hexagons[0][0].z_index + 1) for pos in white_winning_path])\n        w_pawns = VGroup(*[Dot(board_hexagons[pos[0]][pos[1]].get_center(), color=WHITE, radius=pawn_radius).set_z_index(board_hexagons[0][0].z_index + 1) for pos in game_1_w])\n        b_pawns = VGroup(*[Dot(board_hexagons[pos[0]][pos[1]].get_center(), color=BLACK, radius=pawn_radius).set_z_index(board_hexagons[0][0].z_index + 1) for pos in game_1_b])\n        label_1 = MathTex('1').move_to(board_sides[0]).shift(0.75 * UP)\n        label_2 = MathTex('2').move_to(board_sides[3]).shift(0.75 * (0.5 * UP + np.sqrt(3) / 2 * RIGHT))\n        label_3 = MathTex('3').move_to(board_sides[1]).shift(0.75 * DOWN)\n        label_4 = MathTex('4').move_to(board_sides[2]).shift(0.75 * (0.5 * DOWN + np.sqrt(3) / 2 * LEFT))\n        sides_labels = VGroup(label_1, label_2, label_3, label_4)\n        cross = Cross(w_pawns[19]).set_z_index(w_pawns[0].z_index + 1)\n        self.add(board_hexagons, board_sides, w_pawns, b_pawns)\n        self.wait()\n        self.play(AnimationGroup(*[Write(label) for label in sides_labels], lag_ratio=0.5))\n        self.wait()\n        self.play(AnimationGroup(Indicate(VGroup(label_1, label_3), scale_factor=1.05), Indicate(VGroup(label_2, label_4), scale_factor=1.05), lag_ratio=1), run_time=3)\n        non_relied_to_1_pawns_1 = VGroup(*b_pawns, w_pawns[22], w_pawns[35], w_pawns[44], w_pawns[45], w_pawns[54], w_pawns[55], w_pawns[58], w_pawns[59], w_pawns[60])\n        non_relied_to_1_pawns_2 = VGroup(*w_pawns[19:], b_pawns[37], w_pawns[12]).remove(*[pawn for pawn in non_relied_to_1_pawns_1 if pawn in w_pawns])\n        self.wait()\n        self.play(FadeOut(non_relied_to_1_pawns_1), run_time=2)\n        self.wait()\n        self.play(AnimationGroup(*[Indicate(whites_winning_pawns[k]) for k in range(len(whites_winning_pawns))], lag_ratio=0.2), run_time=2.5)\n        self.remove(*whites_winning_pawns)\n        b_pawns[37].set_color(WHITE)\n        self.wait()\n        self.play(w_pawns[19].animate.set_color(BLACK), FadeIn(b_pawns[37]))\n        self.play(FadeIn(cross, shift=np.array([0, 0, -1])))\n        self.wait()\n        self.play(FadeOut(cross), FadeOut(non_relied_to_1_pawns_2))\n        self.wait()\n        b_adjacent_boxes = VGroup(*b_pawns[:22], w_pawns[19]).remove(*[b_pawns[1], b_pawns[12], b_pawns[14]])\n        board_hexagons[0][2].set_z_index(board_hexagons[0][2].z_index + 1)\n        self.play(Indicate(board_hexagons[0][2]), run_time=1.5)\n        board_hexagons[0][2].set_z_index(board_hexagons[0][2].z_index - 1)\n        self.wait()\n        self.play(FadeIn(b_adjacent_boxes[0]))\n        self.wait()\n        self.play(FadeIn(*[b_adjacent_boxes[k] for k in range(1, len(b_adjacent_boxes))]), run_time=2)\n        self.wait()\n        self.play(AnimationGroup(*[Indicate(blacks_winning_pawns[k]) for k in range(len(blacks_winning_pawns))], lag_ratio=0.2), run_time=2.5)\n        self.remove(*blacks_winning_pawns)\n        self.wait()\n        self.play(FadeOut(b_adjacent_boxes[3]), w_pawns[5].animate.set_color(BLACK))\n        self.wait()\n        self.play(Indicate(board_sides[0]))\n        self.wait()\n        self.play(FadeIn(b_pawns[1], b_adjacent_boxes[3]))\n        self.wait()\n        blacks_winning_path_2 = [pawn for pawn in blacks_winning_path]\n        blacks_winning_path_2.append((0, 10))\n        blacks_winning_path_2[-2] = (0, 9)\n        blacks_winning_pawns_2 = VGroup(*[Dot(board_hexagons[pos[0]][pos[1]].get_center(), color=BLACK, radius=pawn_radius).set_z_index(board_hexagons[0][0].z_index + 1) for pos in blacks_winning_path_2])\n        self.play(AnimationGroup(*[Indicate(blacks_winning_pawns[k]) for k in range(len(blacks_winning_pawns))], lag_ratio=0.2), run_time=2.5)\n        rectangle = SurroundingRectangle(board_image, color=BLACK, fill_color=BLACK, fill_opacity=1).set_z_index(w_pawns[0].z_index + 1)\n        self.wait()\n        self.play(blacks_winning_pawns_2.animate.set_color(YELLOW))\n        self.wait()\n        self.play(AnimationGroup(Unwrite(VGroup(label_1, label_2, label_3, label_4)), FadeIn(rectangle), lag_ratio=0.5))\n        hex_thm_recap = MathTex('&\\\\forall B, W \\\\subset \\\\mathcal{B}_k,', '\\\\hspace{0.075cm} \\\\mathcal{B}_k \\\\subset B \\\\cup W, \\\\\\\\', '&\\\\exists \\\\text{path} \\\\subset B, \\\\hspace{0.1cm} \\\\text{path connects} \\\\hspace{0.1cm} B \\\\hspace{0.1cm} \\\\text{edges or} \\\\\\\\', '&\\\\exists \\\\text{path} \\\\subset W, \\\\hspace{0.1cm} \\\\text{path connects} \\\\hspace{0.1cm} W \\\\hspace{0.1cm} \\\\text{edges}.').scale(1.25).set_z_index(rectangle.z_index + 1)\n        VGroup(hex_thm_recap[0][1], hex_thm_recap[1][3], hex_thm_recap[2][6], hex_thm_recap[2][20]).set_color(BLACK).set_stroke(color=WHITE, width=0.75)\n        self.play(FadeIn(hex_thm_recap[0]))\n        self.wait()\n        self.play(FadeIn(hex_thm_recap[1]))\n        self.wait()\n        self.play(FadeIn(hex_thm_recap[2]))\n        self.wait()\n        self.play(FadeIn(hex_thm_recap[3]))\n        self.wait()\n        self.play(FadeOut(*hex_thm_recap))\n        self.wait()\n        title = Tex(\"Chapter 4 : \\\\textsc{Brouwer}'s theorem proof\").set_z_index(rectangle.z_index + 1).scale(0.9)\n        underline = Underline(title).set_opacity([0, 1, 1, 0]).set_z_index(title.z_index)\n        title_group = VGroup(title, underline).scale(1.5)\n        self.play(FadeIn(title_group), run_time=3)\n        self.play(FadeOut(title_group), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a bulleted list of mathematical theorems and then fade it out."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass Requirements(Scene):\n\n    def construct(self):\n        list = Tex(\"\\\\begin{itemize} \\\\item Uniform Continuity \\\\item Heine's theorem \\\\item Boundedness theorem \\\\end{itemize}\").scale(1.5)\n        self.wait()\n        self.play(FadeIn(list))\n        self.wait(3)\n        self.play(FadeOut(list))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a mathematical proof involving vector fields, a unit circle, a compact convex set, and labeled fixed points, progressing through definitions and transformations."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass BrouwersThmProof1(MovingCameraScene):\n\n    def construct(self):\n        scale_factor = 2.5\n        plane = NumberPlane(x_range=[-config['frame_x_radius'], config['frame_x_radius'], 0.5], y_range=[-config['frame_y_radius'], config['frame_y_radius'], 0.5], background_line_style={'stroke_opacity': 0.5}).scale(scale_factor).shift(3 * LEFT)\n        unit_circle = Square(color=RED).move_to(plane.c2p(0, 0)).scale(scale_factor)\n        compact_convex = SVGMobject('potato.svg').flip().set_color(RED)\n        width, height = (compact_convex.width, compact_convex.height)\n        proportion_x, proportion_y = (2 / width, 1 / height)\n        compact_convex.scale(2 / width)\n        compact_convex_curve = VMobject().start_new_path(compact_convex.get_all_points()[0])\n        compact_convex_curve.add_points_as_corners(compact_convex.get_all_points()[1:])\n        compact_convex.scale(2.5 * width / 2).shift(13 * LEFT + 5 * UP)\n        compact_convex_for_transform = compact_convex.generate_target().set_z_index(compact_convex.z_index + 1)\n        vector_field = ArrowVectorField(lambda pos: fixed_point_func(pos, a) - pos, x_range=[-1, 1, 0.25], y_range=[-1, 1, 0.25], vector_config={'stroke_width': 1}, length_func=lambda norm: 6 * 0.55 * sigmoid(norm)).scale(scale_factor).shift(3 * LEFT)\n        for vector in vector_field:\n            vector.scale(1 / 6, scale_tips=True, about_point=vector.get_start())\n        vector_field.move_to(plane.c2p(0, 0))\n        vector_field_in_compact_convex = ArrowVectorField(lambda pos: (fixed_point_func(pos, (proportion_x * LEFT + proportion_y * UP) / 2.5) - pos) * (len(Intersection(compact_convex_curve, Dot(pos, radius=DEFAULT_SMALL_DOT_RADIUS)).points) == len(Intersection(compact_convex_curve, Dot((proportion_x * LEFT + proportion_y * UP) / 2.5, radius=DEFAULT_SMALL_DOT_RADIUS)).points)), x_range=[-1, 1, 0.17], y_range=[-1, 1, 0.12], vector_config={'stroke_width': 1}, length_func=lambda norm: 12 * 0.45 * sigmoid(norm)).scale(2.5 * width / 2).shift(13 * LEFT + 5 * UP).set_z_index(plane.z_index + 1)\n        for vector in vector_field_in_compact_convex:\n            vector.scale(1 / 12, scale_tips=True, about_point=vector.get_start())\n        vector_field_in_compact_convex.move_to(compact_convex.get_center())\n        vector_field_in_compact_convex_for_transform = vector_field_in_compact_convex.copy()\n        compact_convex_label = MathTex(\"K'\", color=RED).next_to(compact_convex, UR, buff=-0.15).shift(0.35 * DL).shift(0.1 * DOWN)\n        unit_circle_label = MathTex('K', color=RED).next_to(unit_circle, UL)\n        arrow_K_p_K = CurvedArrow(plane.c2p(-2.25, 2.75), plane.c2p(0, 1.35), color=YELLOW)\n        arrow_K_p_K.flip(arrow_K_p_K.get_end() - arrow_K_p_K.get_start())\n        arrow_K_p_K_label = MathTex('\\\\varphi', color=YELLOW).move_to(arrow_K_p_K.point_from_proportion(0.5)).shift(0.3 * UP + 0.6 * RIGHT)\n        fixed_dot = Dot(plane.c2p(*a), color=GREEN).set_z_index(vector_field[0].z_index + 2)\n        fixed_dot_label = MathTex('f(', 'x', ') = ', 'x').scale(0.9).next_to(fixed_dot, UR).set_z_index(vector_field[0].z_index + 2)\n        fixed_dot_label[1:5:2].set_color(GREEN)\n        rectangle_fixed_dot = SurroundingRectangle(VGroup(fixed_dot, fixed_dot_label), color=BLACK, stroke_opacity=0, fill_opacity=0.8, buff=0.2).set_z_index(vector_field[0].z_index + 1)\n        fixed_dot_in_compact_convex = Dot(compact_convex.get_center() + 1.15 * LEFT + 0.85 * UP, color=YELLOW).set_z_index(vector_field_in_compact_convex.z_index + 1)\n        fixed_dot_in_compact_convex_label = MathTex('g(', '\\\\varphi^{-1}', '(', 'x', ')) = ', '\\\\varphi^{-1}', '(', 'x', ')').next_to(fixed_dot_in_compact_convex, UP).set_z_index(compact_convex.z_index + 2)\n        rectangle_compact_convex_fixed_dot = SurroundingRectangle(fixed_dot_in_compact_convex_label, color=BLACK, stroke_opacity=0, fill_opacity=0.8).set_z_index(compact_convex.z_index + 1)\n        fixed_dot_in_compact_convex_label[1:9:4].set_color(YELLOW)\n        fixed_dot_in_compact_convex_label[3:11:4].set_color(GREEN)\n        arrow_fixed_points = CurvedArrow(plane.c2p(-1.25, 0), plane.c2p(-3, 0.8), color=YELLOW).set_z_index(rectangle_fixed_dot.z_index + 1).shift(0.25 * DOWN)\n        arrow_fixed_points.flip(arrow_fixed_points.get_end() - arrow_fixed_points.get_start())\n        arrow_fixed_points_label = MathTex('\\\\varphi^{-1}', color=YELLOW).move_to(arrow_fixed_points.point_from_proportion(0.5)).shift(0.4 * DOWN + 0.6 * LEFT)\n        self.camera.frame.save_state()\n        tex_f = MathTex('f : ', 'K', ' \\\\to', ' K ', '\\\\hspace{0.2cm} \\\\text{continuous}')\n        tex_f[-1].set_color(BLUE)\n        tex_f[1:5:2].set_color(RED)\n        tex_K = MathTex('K', ' = \\\\mathcal{B}_{||\\\\cdot||_{\\\\infty}}(0, 1) =  \\\\{u \\\\in \\\\mathbb{R}^2, ||u||_{\\\\infty} = 1\\\\}').next_to(tex_f, DOWN, buff=0.5)\n        tex_inf_norm = MathTex('||x = (x_1, x_2)||_{\\\\infty} = \\\\max{(|x_1|, |x_2|)}').next_to(tex_K, DOWN, buff=0.5)\n        tex_K[0].set_color(RED)\n        tex_convex_compact = Tex(\"$K' \\\\subset \\\\mathbb{R}^2$ non-empty convex compact \\\\\\\\ \\\\vspace{0.1cm} $\\\\downarrow$ \\\\vspace{0.1cm} \\\\\\\\ $\\\\exists$\", '$\\\\varphi$ ', '$ : $', \" $ K' $\", ' $ \\\\to $', ' $ K $ ', ' an ', '\\\\emph{homeomorphism}').next_to(tex_inf_norm, DOWN, buff=0.75)\n        VGroup(tex_convex_compact[0][0:2], *tex_convex_compact[3:5:2], tex_convex_compact[5]).set_color(RED)\n        tex_convex_compact[1].set_color(YELLOW)\n        tex_fixed_point = Tex('$g : $', \" $ K' $ \", ' $ \\\\to $ ', \" $ K'$\", ', \\\\hspace{0.05cm} $f = \\\\varphi \\\\circ g \\\\circ \\\\varphi^{-1}$', '\\\\\\\\ \\\\vspace{0.1cm} $\\\\downarrow$ \\\\vspace{0.1cm} \\\\\\\\ $f(x) = x \\\\iff g(\\\\varphi^{-1}(x)) = \\\\varphi^{-1}(x)$').next_to(tex_convex_compact, DOWN, buff=0.75)\n        tex_fixed_point[1:5:2].set_color(RED)\n        VGroup(tex_fixed_point[4][3], tex_fixed_point[4][7:10]).set_color(YELLOW)\n        VGroup(tex_fixed_point[5][11:13], tex_fixed_point[5][19:22]).set_color(YELLOW)\n        VGroup(tex_fixed_point[5][3:9:3], tex_fixed_point[5][15:31:8]).set_color(GREEN)\n        tex_group = VGroup(tex_f, tex_K, tex_convex_compact, tex_fixed_point, tex_inf_norm).scale(0.75).move_to(plane.c2p(0, 0)).to_edge(RIGHT).set_z_index(plane.z_index + 3)\n        tex_group_rectangle = SurroundingRectangle(tex_group, color=BLACK, stroke_opacity=0, fill_opacity=0.8, buff=0.2).set_z_index(plane.z_index + 2)\n        self.play(FadeIn(plane), Create(unit_circle), Write(unit_circle_label), run_time=2)\n        self.wait()\n        self.play(Write(tex_f), FadeIn(tex_group_rectangle), *[GrowArrow(vector) for vector in vector_field], run_time=2)\n        self.play(Write(tex_K), run_time=3)\n        self.play(Write(tex_inf_norm), run_time=2.5)\n        self.wait()\n        self.play(Write(tex_convex_compact), run_time=4)\n        self.wait()\n        self.play(Indicate(tex_convex_compact[-1]), run_time=2)\n        self.wait()\n        self.play(self.camera.frame.animate.scale(2).shift(2 * UP + 5 * LEFT), run_time=2)\n        self.wait()\n        self.play(Create(compact_convex), Write(compact_convex_label), run_time=3)\n        self.wait()\n        self.play(*[GrowArrow(vector) for vector in vector_field_in_compact_convex], run_time=2)\n        self.wait()\n        self.play(Transform(compact_convex_for_transform, unit_circle), Transform(vector_field_in_compact_convex_for_transform, vector_field), Create(arrow_K_p_K), Write(arrow_K_p_K_label), compact_convex.animate.set_stroke_opacity(0.5), run_time=3)\n        self.wait()\n        self.play(self.camera.frame.animate.restore(), run_time=2)\n        self.camera.frame.save_state()\n        self.wait()\n        self.play(Write(tex_fixed_point[:-1]), run_time=4)\n        self.wait()\n        self.play(Write(tex_fixed_point[-1]), run_time=4)\n        self.play(Create(fixed_dot), Write(fixed_dot_label), FadeIn(rectangle_fixed_dot), run_time=2)\n        self.wait()\n        self.play(self.camera.frame.animate.scale(2).shift(2 * UP + 5 * LEFT), Create(arrow_fixed_points), Write(arrow_fixed_points_label), run_time=2)\n        self.play(Create(fixed_dot_in_compact_convex), Write(fixed_dot_in_compact_convex_label), FadeIn(rectangle_compact_convex_fixed_dot), run_time=2)\n        self.wait()\n        self.play(self.camera.frame.animate.restore(), AnimationGroup(FadeOut(fixed_dot_in_compact_convex, fixed_dot_in_compact_convex_label, rectangle_compact_convex_fixed_dot), FadeOut(compact_convex, arrow_fixed_points, arrow_fixed_points_label, arrow_K_p_K, arrow_K_p_K_label, fixed_dot, fixed_dot_label, tex_group, tex_group_rectangle, rectangle_fixed_dot, vector_field_in_compact_convex), lag_ratio=0.1), run_time=2)"}]}
{"messages": [{"role": "user", "content": "Demonstrate Heine's theorem by showing the definition of uniform continuity with interactive visualizations of epsilon-delta neighborhoods for the square root and reciprocal functions."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass BrouwersThmProof2(MovingCameraScene):\n\n    def construct(self):\n        scale_factor = 2.5\n        plane = NumberPlane(x_range=[-config['frame_x_radius'], config['frame_x_radius'], 0.5], y_range=[-config['frame_y_radius'], config['frame_y_radius'], 0.5], background_line_style={'stroke_opacity': 0.5}).scale(scale_factor).shift(3 * LEFT)\n        unit_circle = Square(color=RED).move_to(plane.c2p(0, 0)).scale(scale_factor)\n        unit_circle_label = MathTex('K', color=RED).next_to(unit_circle, UL)\n        vector_field = ArrowVectorField(lambda pos: fixed_point_func(pos, a) - pos, x_range=[-1, 1, 0.25], y_range=[-1, 1, 0.25], vector_config={'stroke_width': 1}, length_func=lambda norm: 6 * 0.55 * sigmoid(norm))\n        vector_field.scale(scale_factor).shift(3 * LEFT)\n        for vector in vector_field:\n            vector.scale(1 / 6, scale_tips=True, about_point=vector.get_start())\n        vector_field.move_to(plane.c2p(0, 0))\n        heine_thm = Tex(\"\\\\textsc{Heine}'s thm \\\\\\\\\", '$\\\\downarrow$ \\\\\\\\', ' $f$ is uniformly continuous over ', ' $K$').scale(0.9)\n        heine_thm[-1].set_color(RED)\n        uc_tex = MathTex('\\\\forall \\\\varepsilon > 0, \\\\exists \\\\delta > 0, \\\\forall x, y \\\\in ', 'K \\\\\\\\', '||x-y||_{\\\\infty} \\\\leqslant \\\\delta \\\\implies ||f(x)-f(y)||_{\\\\infty} \\\\leqslant \\\\varepsilon')\n        uc_tex[1].set_color(RED)\n        uc_tex[0:2].scale(0.9).next_to(heine_thm, DOWN, buff=1)\n        uc_tex[-1].scale(0.75).next_to(uc_tex[0:2], DOWN, buff=0.3)\n        tex_group = VGroup(heine_thm, uc_tex).move_to(ORIGIN).to_edge(RIGHT).set_z_index(plane.z_index + 2)\n        tex_rectangle = SurroundingRectangle(tex_group, color=BLACK, fill_opacity=0.8, stroke_width=0, buff=0.2).set_z_index(plane.z_index + 1)\n        self.add(plane, unit_circle, unit_circle_label, vector_field)\n        self.wait()\n        self.play(Write(heine_thm), FadeIn(tex_rectangle), run_time=3)\n        self.wait()\n        self.play(Write(uc_tex), run_time=6)\n        self.wait()\n        window = Rectangle(fill_color=BLACK, fill_opacity=0.9, height=0.8 * 8, width=0.8 * 14).set_z_index(tex_group.z_index + 1)\n        axes = Axes(x_range=[0, 4], y_range=[0, 4], x_length=0.75 * window.height, y_length=0.8 * window.height, tips=False).set_z_index(window.z_index + 1)\n        inv_curve = axes.plot(lambda x: 1 / x, x_range=[1 / 4, 4, 0.01], color=RED).set_z_index(axes.z_index + 1)\n        inv_label = MathTex('\\\\frac{1}{\\\\cdot}', color=RED).scale(0.8).next_to(inv_curve.get_end(), RIGHT).set_z_index(window.z_index + 1)\n        root_curve = axes.plot(np.sqrt, x_range=[0, 4, 0.01], color=BLUE).set_z_index(axes.z_index + 1)\n        root_label = MathTex('\\\\sqrt{\\\\cdot}', color=BLUE).scale(0.8).next_to(root_curve.get_end(), RIGHT).set_z_index(window.z_index + 1)\n        x = ValueTracker(0.5)\n        epsilon = ValueTracker(0.4)\n\n        class UniformContinuityWindow(VMobject):\n\n            def __init__(self, x: float, epsilon: float, delta: float, axes: Axes, function: Callable[[float], float], curve: ParametricFunction, add_labels: bool=False, **kwargs):\n                self.x = x\n                self.epsilon = epsilon\n                self.delta = delta\n                self.axes = axes\n                self.f = function\n                self.curve = curve\n                self.up_line, self.down_line = self.get_lines()\n                super().__init__(**kwargs)\n                self.add(*self.get_lines())\n                self.add(Polygon(self.up_line.get_start(), self.up_line.get_end(), self.down_line.get_end(), self.down_line.get_start(), color=self.curve.color, fill_opacity=0.5, stroke_width=0))\n                self.set_z_index(self.curve.z_index + 1)\n                if add_labels:\n                    self.add(*self.get_labels())\n\n            def get_lines(self):\n                up_line = Line(self.axes.c2p(0, 0), self.axes.c2p(0.8 * 2 * self.delta, 0), color=self.curve.color).move_to(self.axes.c2p(self.x, self.f(self.x) + self.epsilon))\n                down_line = Line(self.axes.c2p(0, 0), self.axes.c2p(0.8 * 2 * self.delta, 0), color=self.curve.color).move_to(self.axes.c2p(self.x, self.f(self.x) - self.epsilon))\n                return (up_line, down_line)\n\n            def get_labels(self):\n                return VGroup(*self.get_epsilon_label(), *self.get_delta_label())\n\n            def get_epsilon_label(self):\n                self.epsilon_brace = Brace(Line(self.up_line.get_start(), self.down_line.get_start()), direction=LEFT, buff=0.1)\n                self.epsilon_brace_label = MathTex('2\\\\varepsilon').scale(0.65).next_to(self.epsilon_brace, LEFT, buff=0.15)\n                self.epsilon_label = VGroup(self.epsilon_brace, self.epsilon_brace_label).set_z_index(self.z_index + 1)\n                self.epsilon_rectangle = SurroundingRectangle(self.epsilon_label, color=BLACK, fill_opacity=0.5, stroke_width=0, buff=0.05).set_z_index(self.z_index)\n                self.epsilon_label.add(self.epsilon_rectangle)\n                return self.epsilon_label\n\n            def get_delta_label(self):\n                self.delta_brace = Brace(self.down_line, direction=DOWN, buff=0.1)\n                self.delta_brace_label = MathTex('< 2\\\\delta').scale(0.65).next_to(self.delta_brace, DOWN, buff=0.15)\n                self.delta_label = VGroup(self.delta_brace, self.delta_brace_label).set_z_index(self.z_index + 1)\n                self.delta_rectangle = SurroundingRectangle(self.delta_label, color=BLACK, fill_opacity=0.5, stroke_width=0, buff=0.05).set_z_index(self.z_index)\n                self.delta_label.add(self.delta_rectangle)\n                return self.delta_label\n        root_window = always_redraw(lambda: UniformContinuityWindow(x.get_value(), epsilon.get_value(), epsilon.get_value() ** 2, axes, np.sqrt, root_curve, add_labels=True))\n        x_dot = Dot().set_z_index(root_window.z_index + 1).add_updater(lambda dot: dot.move_to(axes.c2p(x.get_value(), np.sqrt(x.get_value()))))\n        self.play(GrowFromCenter(window), run_time=1.5)\n        self.play(FadeIn(axes))\n        self.wait()\n        self.play(Create(root_curve), Write(root_label), run_time=1.5)\n        self.wait()\n        self.play(FadeIn(root_window, x_dot))\n        self.wait()\n        self.play(x.animate.set_value(4), run_time=4)\n        self.wait()\n        self.play(epsilon.animate.set_value(0.25))\n        self.play(x.animate.set_value(0), run_time=2)\n        self.play(x.animate.set_value(4), run_time=2)\n        self.play(epsilon.animate.set_value(0.5))\n        self.wait()\n        root_window.clear_updaters()\n        x_dot.clear_updaters()\n        inv_window = always_redraw(lambda: UniformContinuityWindow(x.get_value(), epsilon.get_value(), epsilon.get_value() ** 2, axes, lambda x: 1 / x, inv_curve, add_labels=True))\n        self.play(Transform(root_window, inv_window.generate_target()), ReplacementTransform(root_curve, inv_curve), ReplacementTransform(root_label, inv_label), x_dot.animate.move_to(axes.c2p(x.get_value(), 1 / x.get_value())))\n        self.wait()\n        self.remove(root_window)\n        self.add(inv_window)\n        x_dot.add_updater(lambda dot: dot.move_to(axes.c2p(x.get_value(), 1 / x.get_value())))\n        self.play(x.animate.set_value(0.6), run_time=4)\n        self.wait()\n        self.play(epsilon.animate.set_value(0.25))\n        self.wait()\n        self.play(x.animate.set_value(0.28))\n        self.wait()\n        self.play(FadeOut(inv_curve, inv_label, x_dot, inv_window, axes))\n        self.play(GrowFromCenter(window), reverse_rate_function=True)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate the concept of uniform continuity on a number plane with a vector field, illustrating the relationship between delta and epsilon using visual boxes and braces."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass BrouwersThmProof3(MovingCameraScene):\n\n    def construct(self):\n        scale_factor = 2.5\n        plane = NumberPlane(x_range=[-config['frame_x_radius'], config['frame_x_radius'], 0.5], y_range=[-config['frame_y_radius'], config['frame_y_radius'], 0.5], background_line_style={'stroke_opacity': 0.5}).scale(scale_factor).shift(3 * LEFT)\n        unit_distance_conversion = np.linalg.norm(plane.c2p(1, 0) - plane.c2p(0, 0))\n        unit_circle = Square(color=RED).move_to(plane.c2p(0, 0)).scale(scale_factor)\n        unit_circle_label = MathTex('K', color=RED).next_to(unit_circle, UL)\n        vector_field = ArrowVectorField(lambda pos: fixed_point_func(pos, a) - pos, x_range=[-1, 1, 0.25], y_range=[-1, 1, 0.25], vector_config={'stroke_width': 1}, length_func=lambda norm: 6 * 0.55 * sigmoid(norm))\n        vector_field_target = vector_field.generate_target()\n        vector_field_target.length_func = lambda norm: 0.55 * sigmoid(norm)\n        vector_field.scale(scale_factor).shift(3 * LEFT)\n        for vector in vector_field:\n            vector.scale(1 / 6, scale_tips=True, about_point=vector.get_start())\n        vector_field.move_to(plane.c2p(0, 0))\n\n        def get_delta(epsilon: float, dx: float, plane: NumberPlane, vector_field: ArrowVectorField) -> float:\n            delta_list = []\n            for x in it.product(np.arange(-1 + dx, 1, dx), np.arange(-1 + dx, 1, dx)):\n                x = np.hstack((x, 0))\n                delta_x = 0\n                f_x = vector_field.get_vector(x).get_end()\n                for ring_size in np.arange(dx / 4, dx + dx / 4, dx / 4):\n                    ring = Square(side_length=2 * ring_size * unit_distance_conversion).move_to(plane.c2p(x[0], x[1]))\n                    points = [ring.point_from_proportion(k / ring_size) for k in np.arange(0, ring_size, ring_size / 5)]\n                    for y in points:\n                        f_y = vector_field.get_vector(np.hstack((plane.p2c(y), 0))).get_end()\n                        if inf_norm(f_x - f_y) <= epsilon:\n                            delta_x = inf_norm(x - y)\n                delta_list.append(delta_x)\n            return min(delta_list)\n        heine_thm = Tex(\"\\\\textsc{Heine}'s thm \\\\\\\\\", '$\\\\downarrow$ \\\\\\\\', ' $f$ is uniformly continuous over ', ' $K$').scale(0.9)\n        heine_thm[-1].set_color(RED)\n        uc_tex = MathTex('\\\\forall \\\\varepsilon > 0, \\\\exists \\\\delta > 0, \\\\forall x, y \\\\in ', 'K \\\\\\\\', '||x-y||_{\\\\infty} \\\\leqslant \\\\delta \\\\implies ||f(x)-f(y)||_{\\\\infty} \\\\leqslant \\\\varepsilon')\n        uc_tex[1].set_color(RED)\n        uc_tex[0:2].scale(0.9).next_to(heine_thm, DOWN, buff=1)\n        uc_tex[-1].scale(0.75).next_to(uc_tex[0:2], DOWN, buff=0.3)\n        tex_group = VGroup(heine_thm, uc_tex).move_to(ORIGIN).to_edge(RIGHT).set_z_index(plane.z_index + 2)\n        tex_rectangle = SurroundingRectangle(tex_group, color=BLACK, fill_opacity=0.8, stroke_width=0, buff=0.2).set_z_index(plane.z_index + 1)\n        self.add(plane, unit_circle, unit_circle_label, vector_field, tex_group, tex_rectangle)\n        self.wait()\n        epsilon = 0.2\n        delta = 0.27\n        board_size = int(np.ceil(2 / delta))\n\n        class UniformContinuityBoxes(VMobject):\n\n            def __init__(self, point: np.ndarray, side_length: float, color: str, label: str, brace_position: str='UP', **kwargs):\n                super().__init__(**kwargs)\n                self.point = point\n                self.side_length = side_length\n                self.color = color\n                self.label = label\n                self.brace_position = brace_position\n                self.box = Square(self.side_length * unit_distance_conversion, color=self.color).move_to(plane.c2p(*self.point))\n                self.brace = Brace(Line(plane.c2p(point[0], point[1] + int((self.brace_position == 'UP') - (self.brace_position == 'DOWN')) * self.side_length / 2), plane.c2p(point[0] + self.side_length / 2, point[1] + int((self.brace_position == 'UP') - (self.brace_position == 'DOWN')) * self.side_length / 2)), UP * (self.brace_position == 'UP') + DOWN * (self.brace_position == 'DOWN'), buff=0, color=self.color)\n                self.brace_label = MathTex(self.label, color=self.color).scale(0.6).next_to(self.brace, UP * (self.brace_position == 'UP') + DOWN * (self.brace_position == 'DOWN'), buff=0.15)\n                self.brace_label_rectangle = SurroundingRectangle(VGroup(self.brace, self.brace_label), color=BLACK, fill_opacity=0.75, stroke_width=0, buff=0.05)\n                self.add(self.box, self.brace, self.brace_label, self.brace_label_rectangle)\n                self.set_z_index(vector_field.z_index + 1)\n                VGroup(self.brace, self.brace_label, self.box).set_z_index(self.z_index + 1)\n        delta_box_init = UniformContinuityBoxes(np.array([0.3, 0.2, 0]), delta, GREEN, '\\\\delta', brace_position='DOWN')\n        epsilon_box_init = UniformContinuityBoxes(vector_field_target.get_vector(np.hstack((plane.p2c(delta_box_init.box.get_center()), 0))).get_end(), epsilon, PURPLE, '\\\\varepsilon')\n        self.play(Indicate(uc_tex[0][1], scale_factor=1.5, color=PURPLE), Indicate(uc_tex[0][6], scale_factor=1.5, color=GREEN), run_time=1.5)\n        self.play(GrowFromCenter(epsilon_box_init.box), GrowFromCenter(delta_box_init.box), Write(VGroup(delta_box_init.brace, delta_box_init.brace_label, epsilon_box_init.brace, epsilon_box_init.brace_label)), FadeIn(delta_box_init.brace_label_rectangle), FadeIn(epsilon_box_init.brace_label_rectangle), uc_tex[0][1].animate.set_color(PURPLE), uc_tex[0][6].animate.set_color(GREEN), run_time=2)\n        delta_box = UniformContinuityBoxes(np.array([0.3, 0.2, 0]), delta, GREEN, '\\\\delta', brace_position='DOWN')\n        epsilon_box = always_redraw(lambda: UniformContinuityBoxes(vector_field_target.get_vector(np.hstack((plane.p2c(delta_box.box.get_center()), 0))).get_end(), epsilon, PURPLE, '\\\\varepsilon'))\n        self.add(delta_box, epsilon_box)\n        self.remove(*delta_box_init, *epsilon_box_init)\n        self.wait()\n        self.play(delta_box.animate.shift(LEFT))\n        self.play(delta_box.animate.shift(UL), run_time=2)\n        self.play(delta_box.animate.move_to(plane.c2p(-0.7, -0.8)), run_time=2)\n        self.play(delta_box.animate.shift(3 * RIGHT + UP))\n        self.wait()\n        self.play(FadeOut(delta_box, epsilon_box, tex_group, tex_rectangle))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the Brouwer Fixed Point Theorem proof by visualizing a vector field, a unit square, and defining regions within the square based on distance from a fixed point."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass BrouwersThmProof4(MovingCameraScene):\n\n    def construct(self):\n        scale_factor = 2.5\n        epsilon = 0.31\n        delta = 0.3\n        board_size = 10\n        plane = NumberPlane(x_range=[-config['frame_x_radius'], config['frame_x_radius'], 0.5], y_range=[-config['frame_y_radius'], config['frame_y_radius'], 0.5], background_line_style={'stroke_opacity': 0.5}).scale(scale_factor).shift(3 * LEFT)\n        unit_distance_conversion = np.linalg.norm(plane.c2p(1, 0) - plane.c2p(0, 0))\n        unit_circle = Square(color=RED).move_to(plane.c2p(0, 0)).scale(scale_factor)\n        unit_circle_label = MathTex('K', color=RED).next_to(unit_circle, UL)\n        vector_field = ArrowVectorField(lambda pos: fixed_point_func(pos, a) - pos, x_range=[-1, 1, 0.25], y_range=[-1, 1, 0.25], vector_config={'stroke_width': 1}, length_func=lambda norm: 6 * 0.55 * sigmoid(norm)).set_z_index(plane.z_index + 3)\n        vector_field_target = vector_field.generate_target()\n        vector_field.scale(scale_factor).shift(3 * LEFT)\n        for vector in vector_field:\n            vector.scale(1 / 6, scale_tips=True, about_point=vector.get_start())\n        vector_field.move_to(plane.c2p(0, 0))\n        self.add(plane, vector_field, unit_circle, unit_circle_label)\n        self.wait()\n\n        def get_vector_in_vector_field(point: np.ndarray, plane: NumberPlane, vector_field: ArrowVectorField) -> Vector:\n            scale_factor = np.linalg.norm(plane.c2p(1, 0) - plane.c2p(0, 0))\n            shift = plane.get_center()\n            return vector_field.get_vector(point).apply_function(lambda vector: scale_factor * vector).shift(shift)\n        board = BoardImage(board_size=board_size + 1, board_color=YELLOW, hexagon_stroke_color=WHITE, sides_stroke_color=WHITE).set_opacity(0.5)\n        board[board_size + 1:board_size + 5].set_opacity(0)\n        epsilon_delta_tex = MathTex('\\\\varepsilon > 0, \\\\hspace{0.1cm} 0 < \\\\delta \\\\leqslant \\\\varepsilon').scale(0.8)\n        epsilon_delta_tex[0][0:20:10].set_color(PURPLE)\n        epsilon_delta_tex[0][6:10:2].set_color(GREEN)\n        k_tex = MathTex('\\\\mathbb{N} \\\\ni k > \\\\frac{2}{\\\\delta}').scale(0.8).next_to(epsilon_delta_tex, DOWN, buff=0.65)\n        k_tex[0][6].set_color(GREEN)\n        B_k_tex = MathTex('B_k = \\\\left\\\\{ \\\\left( -1 + \\\\frac{2u}{k} , -1 + \\\\frac{2v}{k} \\\\right), (u, v) \\\\in [\\\\![ 0, k ]\\\\!] \\\\right\\\\}').scale(0.6).next_to(k_tex, DOWN, buff=0.65)\n        B_k_label = MathTex('B_k', color=ORANGE).next_to(unit_circle, UR, buff=0.45)\n        B_k_tex[0][0:2].set_color(ORANGE)\n        RLUD_tex = MathTex('&R = \\\\{ z = (z_1, z_2) \\\\in B_k \\\\hspace{0.1cm} | \\\\hspace{0.1cm} f_1(z) - z_1 > \\\\varepsilon\\\\} \\\\\\\\', '&L = \\\\{ z = (z_1, z_2) \\\\in B_k \\\\hspace{0.1cm} | \\\\hspace{0.1cm} z_1 - f_1(z) > \\\\varepsilon\\\\} \\\\\\\\', '&U = \\\\{ z = (z_1, z_2) \\\\in B_k \\\\hspace{0.1cm} | \\\\hspace{0.1cm} f_2(z) - z_2 > \\\\varepsilon\\\\} \\\\\\\\', '&D = \\\\{ z = (z_1, z_2) \\\\in B_k \\\\hspace{0.1cm} | \\\\hspace{0.1cm} z_2 - f_2(z) > \\\\varepsilon\\\\}').scale(0.7).next_to(B_k_tex, DOWN, buff=0.65)\n        RLUD_tex[0][0].set_color(RED)\n        RLUD_tex[1][0].set_color(PURE_RED)\n        RLUD_tex[2][0].set_color('#0000BB')\n        RLUD_tex[3][0].set_color(PURE_BLUE)\n        VGroup(RLUD_tex[0][-2], RLUD_tex[1][-2], RLUD_tex[2][-2], RLUD_tex[3][-2]).set_color(PURPLE)\n        tex_group = VGroup(epsilon_delta_tex, k_tex, B_k_tex, RLUD_tex)\n        tex_group.move_to(ORIGIN).to_edge(RIGHT, buff=0.5)\n        tex_rectangle = SurroundingRectangle(tex_group, color=BLACK, fill_opacity=0.9, stroke_width=0)\n        tex_group.set_z_index(tex_rectangle.z_index + 1)\n        epsilon_brace = Brace(Line(plane.c2p(0, 0), plane.c2p(epsilon, 0)), DOWN, color=PURPLE, buff=0.1)\n        epsilon_brace_label = MathTex('\\\\varepsilon', color=PURPLE).scale(0.8).next_to(epsilon_brace, DOWN, buff=0.15)\n        epsilon_brace_rectangle = SurroundingRectangle(VGroup(epsilon_brace, epsilon_brace_label), color=BLACK, fill_opacity=1, stroke_width=0)\n        VGroup(epsilon_brace, epsilon_brace_label).set_z_index(vector_field.z_index + 2)\n        epsilon_brace_rectangle.set_z_index(vector_field.z_index + 1)\n\n        class UniformContinuityBoxes(VMobject):\n\n            def __init__(self, point: np.ndarray, side_length: float, color: str, label: str, brace_position: str='UP', **kwargs):\n                super().__init__(**kwargs)\n                self.point = point\n                self.side_length = side_length\n                self.color = color\n                self.label = label\n                self.brace_position = brace_position\n                self.box = Square(self.side_length * unit_distance_conversion, color=self.color).move_to(plane.c2p(*self.point))\n                self.brace = Brace(Line(plane.c2p(point[0], point[1] + int((self.brace_position == 'UP') - (self.brace_position == 'DOWN')) * self.side_length / 2), plane.c2p(point[0] + self.side_length / 2, point[1] + int((self.brace_position == 'UP') - (self.brace_position == 'DOWN')) * self.side_length / 2)), UP * (self.brace_position == 'UP') + DOWN * (self.brace_position == 'DOWN'), buff=0, color=self.color)\n                self.brace_label = MathTex(self.label, color=self.color).scale(0.6).next_to(self.brace, UP * (self.brace_position == 'UP') + DOWN * (self.brace_position == 'DOWN'), buff=0.15)\n                self.brace_label_rectangle = SurroundingRectangle(VGroup(self.brace, self.brace_label), color=BLACK, fill_opacity=0.75, stroke_width=0, buff=0.05)\n                self.add(self.box, self.brace, self.brace_label, self.brace_label_rectangle)\n                self.set_z_index(vector_field.z_index + 1)\n                VGroup(self.brace, self.brace_label, self.box).set_z_index(self.z_index + 1)\n        self.play(Write(epsilon_delta_tex), FadeIn(tex_rectangle), run_time=1.5)\n        self.wait()\n        self.play(FocusOn(epsilon_brace_rectangle))\n        self.play(FadeIn(epsilon_brace, epsilon_brace_label, epsilon_brace_rectangle))\n        self.wait()\n        self.play(FadeOut(epsilon_brace, epsilon_brace_label, epsilon_brace_rectangle))\n        self.wait()\n        self.play(Write(k_tex), run_time=1.5)\n        self.wait()\n        self.play(Create(board), run_time=3)\n        self.wait()\n        self.play(board.animate.apply_matrix(np.array([[1, 0.58], [0, 1]])).move_to(plane.c2p(0, 0)).stretch(1.16, 1).match_height(Square().scale(1.2 * scale_factor)), run_time=3)\n        B_k = []\n        for line in range(board_size + 1):\n            for row in range(board_size + 1):\n                B_k.append(np.hstack((plane.p2c(board[line][row].get_center()), 0)))\n        B_k_dots = VGroup(*[Dot(plane.c2p(*pos), radius=1.5 * DEFAULT_SMALL_DOT_RADIUS, color=RED) for pos in B_k])\n        vector_field_for_board = vector_field.copy()\n        vector_field_for_board.remove(*vector_field_for_board)\n        vector_field_for_board.add(*[get_vector_in_vector_field(point, plane, vector_field_target) for point in B_k])\n        vector_field_for_board[3 * (board_size + 1) + 3] = Vector(plane.c2p(*a) - board[3][3].get_center()).set_color(BLUE).shift(board[3][3].get_center())\n        vector_field_for_board.set_z_index(vector_field.z_index + 5)\n        for vector in vector_field_for_board:\n            vector.scale(1 / 6, scale_tips=True, about_point=vector.get_start())\n        vector_2_1 = vector_field_for_board[2 * (board_size + 1) + 1].copy()\n        vector_3_2 = vector_field_for_board[3 * (board_size + 1) + 2].copy()\n        vector_3_4 = vector_field_for_board[3 * (board_size + 1) + 4].copy()\n        VGroup(vector_3_2, vector_3_4).set_color(WHITE)\n        vector_3_4.set_stroke(BLACK, width=1)\n        vector_3_2.set_stroke(BLACK, width=1)\n        vector_field_for_board.move_to(plane.c2p(0, 0))\n        self.wait()\n        self.play(ReplacementTransform(vector_field, vector_field_for_board), run_time=2)\n        self.wait()\n        self.play(FadeOut(vector_field_for_board))\n        delta_box = UniformContinuityBoxes(B_k[3 * (board_size + 1) + 2], delta, BLACK, '\\\\frac{\\\\delta}{2}').set_z_index(board.z_index + 3)\n        VGroup(delta_box.brace, delta_box.brace_label).shift(0.035 * UP)\n        delta_box.brace_label.set_stroke(width=1.5)\n        delta_box.brace_label_rectangle.set_opacity(0)\n        self.wait()\n        self.play(FadeIn(delta_box))\n        self.wait()\n        self.play(FadeOut(delta_box))\n        self.wait()\n        self.play(Write(B_k_tex), run_time=3)\n        self.wait()\n        self.play(FadeIn(B_k_dots), Write(B_k_label))\n        self.wait()\n        self.play(FadeOut(B_k_dots, B_k_label), board[0:board_size + 1].animate.set_opacity(0.65), board[3][3].animate.set_z_index(vector_field_for_board.z_index - 2).set_opacity(0.65))\n        self.wait()\n        self.play(Write(RLUD_tex[0]), run_time=3)\n        self.wait()\n        self.play(AnimationGroup(*[board[index // (board_size + 1)][index % (board_size + 1)].animate.set_color(RED) for index in range(len(vector_field_for_board)) if (vector_field_for_board[index].get_end() - vector_field_for_board[index].get_start())[0] / unit_distance_conversion > epsilon], lag_ratio=0.25), run_time=2)\n        self.wait()\n        z_dot = Dot(plane.c2p(*B_k[2 * (board_size + 1) + 1]), radius=1.5 * DEFAULT_SMALL_DOT_RADIUS, color=BLACK).set_z_index(vector_field_for_board.z_index + 2)\n        z_dot_label = MathTex('z', color=BLACK, stroke_width=1.5).scale(0.8).next_to(z_dot, LEFT, buff=0.15).set_z_index(z_dot.z_index)\n        f_z_dot = Dot(vector_field_for_board[2 * (board_size + 1) + 1].get_end(), radius=1.5 * DEFAULT_SMALL_DOT_RADIUS, color=BLACK).set_z_index(z_dot.z_index)\n        f_z_dot_label = MathTex('f(z)', color=BLACK, stroke_width=1.5).scale(0.8).next_to(f_z_dot, RIGHT, buff=0.15).set_z_index(z_dot.z_index)\n        f_z_array = vector_field_for_board[2 * (board_size + 1) + 1].get_end() - vector_field_for_board[2 * (board_size + 1) + 1].get_start()\n        f_z_brace = Brace(Line(z_dot.get_center(), z_dot.get_center() + f_z_array[0] * RIGHT), UP, buff=0, color=BLACK).set_z_index(z_dot.z_index - 1)\n        f_z_brace_label = MathTex('f_1(z) - z_1', '> \\\\varepsilon', color=BLACK, stroke_width=2).scale(0.8).set_z_index(z_dot.z_index - 1)\n        f_z_brace_label[0].next_to(f_z_brace, UP, buff=0.15)\n        f_z_brace_label[1].next_to(f_z_brace_label[0], RIGHT)\n        VGroup(epsilon_brace, epsilon_brace_label).next_to(Line(z_dot.get_center(), z_dot.get_center() + epsilon * unit_distance_conversion * RIGHT), DOWN, buff=0).set_z_index(z_dot.z_index - 1)\n        epsilon_brace_label.shift(0.09 * UP).set_stroke(width=1.75)\n        self.play(Create(z_dot), Write(z_dot_label), FadeIn(vector_2_1))\n        self.wait()\n        self.play(z_dot.animate.shift(f_z_array), Write(f_z_dot_label))\n        self.wait()\n        self.play(Write(VGroup(f_z_brace, f_z_brace_label[0])))\n        self.wait()\n        self.play(FadeIn(epsilon_brace, epsilon_brace_label), Write(f_z_brace_label[1]))\n        self.wait()\n        self.play(FadeOut(vector_2_1, z_dot, z_dot_label, f_z_dot_label, f_z_brace, f_z_brace_label[0], f_z_brace_label[1], epsilon_brace, epsilon_brace_label))\n        self.wait()\n        self.play(Write(RLUD_tex[1]), AnimationGroup(*[board[index // (board_size + 1)][index % (board_size + 1)].animate.set_color(PURE_RED) for index in range(len(vector_field_for_board)) if -(vector_field_for_board[index].get_end() - vector_field_for_board[index].get_start())[0] / unit_distance_conversion > epsilon], lag_ratio=0), run_time=2)\n        self.wait()\n        self.play(Write(RLUD_tex[2]), AnimationGroup(*[board[index // (board_size + 1)][index % (board_size + 1)].animate.set_stroke('#0000BB') for index in range(len(vector_field_for_board)) if (vector_field_for_board[index].get_end() - vector_field_for_board[index].get_start())[1] / unit_distance_conversion > epsilon], lag_ratio=0), run_time=2)\n        self.wait()\n        self.play(Write(RLUD_tex[3]), AnimationGroup(*[board[index // (board_size + 1)][index % (board_size + 1)].animate.set_stroke(PURE_BLUE) for index in range(len(vector_field_for_board)) if -(vector_field_for_board[index].get_end() - vector_field_for_board[index].get_start())[1] / unit_distance_conversion > epsilon], lag_ratio=0), run_time=2)\n        self.wait()\n        z_R_dot = Dot(vector_3_2.get_start(), radius=DEFAULT_SMALL_DOT_RADIUS, color=BLACK).set_z_index(vector_field_for_board.z_index + 2)\n        z_L_dot = Dot(vector_3_4.get_start(), radius=DEFAULT_SMALL_DOT_RADIUS, color=BLACK).set_z_index(z_R_dot.z_index)\n        z_R_dot_label = MathTex('z_R', color=BLACK, stroke_width=1.5).scale(0.7).next_to(z_R_dot, LEFT, buff=0.15).set_z_index(z_R_dot.z_index)\n        z_L_dot_label = MathTex('z_L', color=BLACK, stroke_width=1.5).scale(0.7).next_to(z_L_dot, RIGHT, buff=0.15).set_z_index(z_R_dot.z_index)\n        R_line = Line(ORIGIN, (vector_3_2.get_end() - vector_3_2.get_start())[0] * RIGHT, color=BLACK).shift(z_R_dot.get_center() + 0.5 * UP).set_z_index(z_R_dot.z_index)\n        L_line = Line(ORIGIN, -(vector_3_4.get_end() - vector_3_4.get_start())[0] * RIGHT, color=BLACK).shift(R_line.get_end()).set_z_index(z_R_dot.z_index)\n        R_line_brace = Brace(R_line, UP, buff=0, color=BLACK).set_z_index(z_R_dot.z_index)\n        RL_lines_brace = Brace(VGroup(R_line, L_line), UP, buff=0, color=BLACK).set_z_index(z_R_dot.z_index)\n        RL_lines_brace_label = MathTex('f_1(z_R) - z_{R, 1}', '+ z_{L, 1} - f_1(z_L)', color=BLACK, stroke_width=1.6).scale(0.5).set_z_index(z_R_dot.z_index)\n        RL_lines_brace_label_target = RL_lines_brace_label.generate_target().next_to(RL_lines_brace, UP, buff=0.1)\n        RL_lines_brace_label[0].next_to(R_line_brace, UP, buff=0.1)\n        RL_lines_brace_label[1].move_to(RL_lines_brace_label_target[1])\n        g_2_epsilon_tex = MathTex('> 2\\\\varepsilon', color=BLACK, stroke_width=1.6).scale(0.5).next_to(RL_lines_brace_label_target, RIGHT, buff=0.1).set_z_index(z_R_dot.z_index)\n        two_epsilon_brace = Brace(Line(R_line.get_start(), R_line.get_start() + 2 * epsilon * unit_distance_conversion * RIGHT), DOWN, buff=0, color=PURPLE).set_z_index(z_R_dot.z_index)\n        two_epsilon_brace_label = MathTex('2\\\\varepsilon', color=PURPLE, stroke_width=1.75).scale(0.8).next_to(two_epsilon_brace, DOWN, buff=0.1).set_z_index(z_R_dot.z_index)\n        self.play(FadeOut(k_tex, B_k_tex, *RLUD_tex[2:]), RLUD_tex[:2].animate.next_to(epsilon_delta_tex, DOWN, buff=0.5), run_time=1.5)\n        self.wait()\n        RL_not_connected_tex = Tex('$R$ and $L$ are not connected.').scale(0.8).next_to(RLUD_tex[1], DOWN, buff=0.5)\n        RL_not_connected_tex[0][0].set_color(RED)\n        RL_not_connected_tex[0][4].set_color(PURE_RED)\n        UD_not_connected_tex = Tex('Same for $U$ and $D$.').next_to(RL_not_connected_tex, DOWN, buff=0.5)\n        UD_not_connected_tex[0][7].set_color('#0000BB')\n        UD_not_connected_tex[0][11].set_color(PURE_BLUE)\n        z_R_z_L_tex = Tex('$z_R \\\\in R, z_L \\\\in L$  in adjacents hexagons').scale(0.7).next_to(RL_not_connected_tex, DOWN, buff=0.5)\n        z_R_z_L_tex[0][3].set_color(RED)\n        z_R_z_L_tex[0][8].set_color(PURE_RED)\n        z_R_z_L_cond_tex = MathTex('z_{L, 1} - z_{R, 1} \\\\leqslant ||z_L - z_R||_{\\\\infty} \\\\leqslant', '\\\\delta').scale(0.8).next_to(z_R_z_L_tex, DOWN, buff=0.5)\n        z_R_z_L_cond_tex[-1].set_color(GREEN)\n        z_R_z_L_cond_tex_rectangle = SurroundingRectangle(z_R_z_L_cond_tex, buff=0.2)\n        self.play(Write(RL_not_connected_tex), run_time=2)\n        self.wait()\n        self.play(Write(z_R_z_L_tex), run_time=3)\n        self.wait()\n        self.play(board[0:board_size + 1].animate.set_opacity(0.5), FadeIn(z_R_dot, z_L_dot, vector_3_2, vector_3_4), Write(VGroup(z_R_dot_label, z_L_dot_label)))\n        self.wait()\n        self.play(Write(z_R_z_L_cond_tex), run_time=2)\n        self.play(Create(z_R_z_L_cond_tex_rectangle), run_time=1.5)\n        self.wait()\n        self.play(ReplacementTransform(vector_3_2.copy(), R_line), FadeIn(R_line_brace, RL_lines_brace_label[0]))\n        self.wait()\n        self.play(ReplacementTransform(vector_3_4.copy(), L_line), ReplacementTransform(R_line_brace, RL_lines_brace), FadeIn(RL_lines_brace_label[1]), RL_lines_brace_label[0].animate.move_to(RL_lines_brace_label_target[0]))\n        self.wait()\n        self.play(FadeIn(two_epsilon_brace, two_epsilon_brace_label), Write(g_2_epsilon_tex))\n        self.wait()\n        self.play(FadeOut(two_epsilon_brace, two_epsilon_brace_label))\n        self.wait()\n        formula_z_f_z = VGroup(RL_lines_brace_label.copy(), g_2_epsilon_tex.copy())\n        formula_z_f_z_tex = MathTex('f_1(z_R) ', ' - ', ' z_{R, 1} ', ' + ', ' z_{L, 1} ', ' - ', ' f_1(z_L) ', ' > ', ' 2 ', ' \\\\varepsilon ').scale(0.7).next_to(z_R_z_L_cond_tex_rectangle, DOWN, buff=0.5)\n        formula_z_f_z_tex_2 = formula_z_f_z_tex.copy()\n        formula_z_f_z_tex_2[5:].next_to(formula_z_f_z_tex_2[0], RIGHT, buff=0.15)\n        formula_z_f_z_tex_2[1:5].next_to(formula_z_f_z_tex_2[-1], RIGHT, buff=0.15)\n        m_sine = formula_z_f_z_tex_2[1].get_center()\n        formula_z_f_z_tex_2[1].move_to(formula_z_f_z_tex_2[3])\n        formula_z_f_z_tex_2[3].move_to(m_sine)\n        self.play(ReplacementTransform(formula_z_f_z, formula_z_f_z_tex))\n        self.wait()\n        self.play(*[formula_z_f_z_tex[k].animate.move_to(formula_z_f_z_tex_2[k]) for k in range(len(formula_z_f_z_tex))])\n        brace_g_delta_epsilon = Brace(formula_z_f_z_tex[1:5], DOWN)\n        brace_g_delta_epsilon_label = MathTex('\\\\geqslant', '-\\\\delta', '\\\\geqslant', '-\\\\varepsilon').scale(0.7).next_to(brace_g_delta_epsilon, DOWN, buff=0.15)\n        self.wait()\n        self.play(Write(VGroup(brace_g_delta_epsilon, brace_g_delta_epsilon_label)), run_time=2)\n        self.wait()\n        self.play(FadeOut(formula_z_f_z_tex[1:5], brace_g_delta_epsilon, brace_g_delta_epsilon_label[:3]), brace_g_delta_epsilon_label[3].animate.next_to(formula_z_f_z_tex[-1], RIGHT, buff=0.15))\n        self.play(formula_z_f_z_tex[-1].animate.move_to(formula_z_f_z_tex[-2]).shift(0.03 * DOWN), FadeOut(formula_z_f_z_tex[-2], brace_g_delta_epsilon_label[3]))\n        self.wait()\n        remaining_tex = VGroup(formula_z_f_z_tex[0], formula_z_f_z_tex[5:8], formula_z_f_z_tex[-1])\n        cross = Cross(remaining_tex)\n        self.play(GrowFromCenter(cross))\n        self.wait()\n        self.play(FadeOut(remaining_tex, cross, z_L_dot, z_L_dot_label, z_R_dot, z_R_dot_label, vector_3_2, vector_3_4, RL_lines_brace, *RL_lines_brace_label, R_line, L_line, z_R_z_L_cond_tex, z_R_z_L_cond_tex_rectangle, z_R_z_L_tex, g_2_epsilon_tex, epsilon_delta_tex, *RLUD_tex[0:2]), RL_not_connected_tex.animate.shift(2 * UP))\n        self.wait()\n        UD_not_connected_tex.scale(0.8).next_to(RL_not_connected_tex, DOWN, buff=0.3)\n        R_not_connected_right_edge_tex = Tex(\"R isn't connected to the right edge.\").scale(0.75).next_to(UD_not_connected_tex, DOWN, buff=0.5)\n        R_not_connected_right_edge_tex[0][0].set_color(RED)\n        LUD_not_connected_edges_tex = Tex('Same for $L$, $U$ and $D$.').scale(0.8).next_to(R_not_connected_right_edge_tex, DOWN, buff=0.3)\n        LUD_not_connected_edges_tex[0][7].set_color(PURE_RED)\n        LUD_not_connected_edges_tex[0][9].set_color('#0000BB')\n        LUD_not_connected_edges_tex[0][13].set_color(PURE_BLUE)\n        hex_thm_contrapositive_tex = Tex('$\\\\nexists$ \\\\hspace{0.05cm} red path from r.e to l.e and \\\\\\\\ $\\\\nexists$ \\\\hspace{0.05cm} blue path from u.e to d.e \\\\\\\\', '$\\\\implies$ \\\\\\\\', '$B_k \\\\not \\\\subset R \\\\cup L \\\\cup U \\\\cup D$').scale(0.75).next_to(LUD_not_connected_edges_tex, DOWN, buff=0.5)\n        hex_thm_contrapositive_tex[-1][4].set_color(RED)\n        hex_thm_contrapositive_tex[-1][6].set_color(PURE_RED)\n        hex_thm_contrapositive_tex[-1][8].set_color('#0000BB')\n        hex_thm_contrapositive_tex[-1][10].set_color(PURE_BLUE)\n        hex_thm_contrapositive_tex[1].rotate(-PI / 2).scale(0.8 / 0.75)\n        hex_thm_contrapositive_tex[1:].shift(0.2 * DOWN)\n        hex_thm_contrapositive_tex[2].shift(0.2 * DOWN)\n        hex_thm_contrapositive_tex_2 = Tex('\\\\textsc{Hex} theorem contrapositive').scale(0.35).set_z_index(hex_thm_contrapositive_tex.z_index + 2).move_to(hex_thm_contrapositive_tex[1])\n        hex_thm_contrapositive_tex_2_rectangle = SurroundingRectangle(hex_thm_contrapositive_tex_2, color=BLACK, fill_opacity=0.8, stroke_width=0, buff=0.1).set_z_index(hex_thm_contrapositive_tex.z_index + 1)\n        hex_thm_contrapositive_tex\n        right_edge_vectors = vector_field_for_board[board_size:(board_size + 2) ** 2 - 1:board_size + 1].copy()\n        self.play(Write(UD_not_connected_tex), run_time=2)\n        self.wait()\n        self.play(Write(R_not_connected_right_edge_tex, run_rime=2.5))\n        self.wait()\n        self.play(AnimationGroup(*[GrowArrow(vector) for vector in right_edge_vectors], lag_ratio=0.25), run_time=2.5)\n        self.wait()\n        self.play(FadeOut(*right_edge_vectors))\n        self.wait()\n        self.play(Write(LUD_not_connected_edges_tex), run_time=2)\n        self.wait()\n        self.play(Write(hex_thm_contrapositive_tex[0], run_time=5))\n        self.wait()\n        self.play(Write(hex_thm_contrapositive_tex[1]))\n        self.play(FadeIn(hex_thm_contrapositive_tex_2_rectangle), Write(hex_thm_contrapositive_tex_2), run_time=1.5)\n        self.play(Write(hex_thm_contrapositive_tex[2]), run_time=2)\n        self.wait()\n        self.play(FadeOut(UD_not_connected_tex, LUD_not_connected_edges_tex, R_not_connected_right_edge_tex, RL_not_connected_tex), VGroup(hex_thm_contrapositive_tex, hex_thm_contrapositive_tex_2, hex_thm_contrapositive_tex_2_rectangle).animate.shift(3 * UP), run_time=1.5)\n        self.wait()\n        exists_fixed_hex_tex = MathTex('\\\\forall \\\\varepsilon > 0, \\\\exists z_{\\\\varepsilon} \\\\in B_k \\\\\\\\ ||f(z_{\\\\varepsilon}) - z_{\\\\varepsilon}||_{\\\\infty} \\\\leqslant \\\\varepsilon').scale(0.8).next_to(hex_thm_contrapositive_tex, DOWN, buff=0.5)\n        inf_f_m_id_tex = MathTex('\\\\inf_K ||f - \\\\mathrm{Id}||_{\\\\infty} = 0').scale(0.8).next_to(exists_fixed_hex_tex, DOWN, buff=0.5)\n        target_start, target_end = (Dot().next_to(exists_fixed_hex_tex, UL).get_center(), Dot().next_to(board[3][3], UR).shift(0.2 * DOWN).get_center())\n        arrow_indication = CurvedArrow(target_start, target_end, color=YELLOW).set_z_index(vector_field.z_index + 2)\n        self.play(Write(exists_fixed_hex_tex), run_time=3)\n        self.play(Create(arrow_indication), run_time=1.5)\n        self.play(Indicate(board[3][3], scale_factor=1.5), run_time=2)\n        self.wait()\n        self.play(Write(inf_f_m_id_tex), FadeOut(arrow_indication), run_time=1.5)\n        self.wait()\n        self.play(FadeOut(hex_thm_contrapositive_tex, hex_thm_contrapositive_tex_2, hex_thm_contrapositive_tex_2_rectangle, exists_fixed_hex_tex), inf_f_m_id_tex.animate.shift(4 * UP), run_time=1.5)\n        self.wait()\n        conclusion_1 = Tex('$||f - \\\\mathrm{Id}||_{\\\\infty}$ continuous \\\\\\\\', '$K$', ' compact set').scale(0.75).next_to(inf_f_m_id_tex, DOWN, buff=0.5)\n        conclusion_1_bis = MathTex('&\\\\exists z \\\\in K, \\\\\\\\', '&\\\\inf_K ||f - \\\\mathrm{Id}||_{\\\\infty} = ||f(z) - z||_{\\\\infty} = 0').scale(0.75).next_to(conclusion_1, DOWN, buff=0.5)\n        conclusion_1[1].set_color(RED)\n        conclusion_2 = MathTex('f(z) = z').scale(0.8).next_to(conclusion_1_bis, DOWN, buff=0.6)\n        conclusion_2_rectangle = SurroundingRectangle(conclusion_2, buff=0.2)\n        self.play(Write(conclusion_1), run_time=3)\n        self.wait()\n        self.play(Write(conclusion_1_bis), run_time=4)\n        self.wait()\n        self.play(Write(conclusion_2), run_time=2)\n        self.play(Create(conclusion_2_rectangle), run_time=1.5)\n        self.wait()\n        self.play(FadeIn(Rectangle(color=BLACK, width=30, height=20, fill_opacity=1).set_z_index(100)))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the Hex theorem and then show credits for animations, music, and proofs."}, {"role": "assistant", "content": "from manim import *\nfrom functions import *\nfrom scipy.integrate import odeint\nfrom HEX.objects import *\nimport itertools as it\nimport random as rd\n\nclass ConclusionAndCredits(Scene):\n\n    def construct(self):\n        eq_tex = Tex(\"\\\\textsc{Hex} theorem  $\\\\iff$ \\\\textsc{Brouwer}'s theorem\").scale(1.25)\n        credits_tex = Tex(\"Animations made with Manim CE \\\\\\\\ \\\\vspace{0.3cm} Musics : 'Odyssey' \\\\& 'Disquiet' by Kevin MacLeod \\\\\\\\ \\\\vspace{0.3cm} Proofs : Wikipedia page for B. thm, El Jj blog page \\\\& David \\\\textsc{Gale}'s article about B. thm\", tex_environment='flushleft').scale(0.6)\n        self.wait()\n        self.play(FadeIn(eq_tex))\n        self.wait(2)\n        self.play(FadeOut(eq_tex))\n        self.wait(3)\n        self.play(Write(credits_tex), run_time=8)\n        self.wait(4)\n        self.play(FadeOut(credits_tex))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render a 3D parametric surface resembling a toroid with a pinched center."}, {"role": "assistant", "content": "\n\nclass TorePince(ThreeDScene):\n\n    def construct(self):\n        self.set_camera_orientation(phi=65 * DEGREES, theta=180 * DEGREES, distance=8)\n\n        def f_tore_pince(u, v):\n            a, b, k = (3, 1, 1 / 2)\n            return np.array([(a + b * np.cos(v) * np.cos(k * u)) * np.cos(u), (a + b * np.cos(v) * np.cos(k * u)) * np.sin(u), b * np.sin(v) * np.cos(k * u)])\n        TorePince = ParametricSurface(f_tore_pince, u_min=-4, u_max=4, v_min=0, v_max=2 * np.pi)\n        self.add(TorePince)"}]}
{"messages": [{"role": "user", "content": "Illustrate the Cordes-Levy theorem by first displaying the theorem statement with colored keywords, then visualizing the function and key intervals on a graph, and finally demonstrating the proof using an auxiliary function and the intermediate value theorem."}, {"role": "assistant", "content": "from manim import *\nfrom typing import Callable\n\nclass ThmCordesLevy(Scene):\n\n    def construct(self):\n        self.animate_thm_words()\n        self.explanation_thm()\n\n    def get_thm_words(self):\n        thm_words = Tex('Thm : ', 'Soit  ', '  $f : [a, b] \\\\rightarrow \\\\mathbb{R}$  ', '  continue', ' telle que ', '$f(a) = f(b)$', '. Alors :', '$$\\\\forall n \\\\in \\\\mathbb{N}, \\\\; \\\\exists c_n \\\\in \\\\left[a, b - \\\\frac{b-a}{n}\\\\right], \\\\quad f(c_n) = f\\\\left(c_n + \\\\frac{b-a}{n}\\\\right).$$').move_to(ORIGIN).scale(0.9)\n        underline = always_redraw(lambda: Underline(thm_words[0], stroke_width=2).set_opacity([0, 1, 0]).set_length(1.1))\n        thm_words[-1].next_to(thm_words[0], RIGHT, buff=0.2).shift(DOWN)\n        thm_words[3].set_color(RED)\n        thm_words[5].set_color(YELLOW)\n        thm_words[-1][1].set_color(PURPLE)\n        VGroup(thm_words[-1][6:8], thm_words[-1][23:25], thm_words[-1][29:31]).set_color(GREEN)\n        VGroup(thm_words[-1][14:19], thm_words[-1][32:37]).set_color(BLUE)\n        return (thm_words, underline)\n\n    def animate_thm_words(self):\n        thm_words, underline = self.get_thm_words()\n        self.add(thm_words, underline)\n        self.wait(5)\n        self.play(thm_words.animate.scale(0.6 * 1 / 0.9).to_edge(UP))\n\n    def explanation_thm(self):\n        self.setup_axes_and_labels()\n        self.setup_curve()\n        self.display_b_a_over_n_label()\n        self.compute_and_display_chord()\n        self.transition()\n        self.proof()\n\n    def setup_axes_and_labels(self):\n        self.axes = Axes(x_range=[-0.2, 3, 0.5], y_range=[-0.2, 2, 0.5], x_length=7, y_length=2.2 * 7 / 3.2, tips=False).shift(0.75 * DOWN)\n        self.a, self.b, self.f_a_f_b = (MathTex('a').next_to(self.axes.c2p(a, 0), DOWN), MathTex('b').next_to(self.axes.c2p(b, 0), DOWN), MathTex('f(a) = f(b)').next_to(self.axes.c2p(0, f(a)), LEFT))\n        self.labels_axis = self.axes.get_axis_labels('x', 'f(x)')\n        self.play(Create(self.axes), Write(self.labels_axis), Write(VGroup(self.a, self.b)), run_time=2.5)\n        self.wait(0.5)\n\n    def setup_curve(self):\n        self.f_curve = self.axes.plot(f, x_range=[0.5, 2.5])\n        self.dot_f_a, self.dot_f_b = (Dot(self.axes.c2p(a, f(a)), color=YELLOW), Dot(self.axes.c2p(b, f(b)), color=YELLOW))\n        self.play(Create(self.f_curve), Create(VGroup(self.dot_f_a, self.dot_f_b)), run_time=2)\n        self.wait(0.5)\n\n    def display_b_a_over_n_label(self):\n        self.underbrace_delta_x = BraceLabel(Line(self.axes.c2p(a, 0), self.axes.c2p(a + delta_x, 0)), '\\\\frac{b-a}{n}', UP, buff=0, font_size=24, color=BLUE)\n        self.underbrace_delta_x.label.shift(0.15 * DOWN).set_color(BLUE)\n        self.play(FadeIn(self.underbrace_delta_x), run_time=1.5)\n        self.wait(0.5)\n\n    def compute_and_display_chord(self):\n        n_tracker = ValueTracker(6)\n        self.c_n_label = MathTex('c_n', color=GREEN).add_updater(lambda mob: mob.next_to(self.axes.c2p(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())), 0), DOWN))\n        self.c_n_dot = always_redraw(lambda: Dot(self.axes.c2p(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())), f(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())))), color=GREEN))\n        self.c_n_delta_x_dot = always_redraw(lambda: Dot(self.axes.c2p(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())) + (b - a) / n_tracker.get_value(), f(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())) + (b - a) / n_tracker.get_value())), color=GREEN))\n        self.c_n_dashed_line = always_redraw(lambda: DashedLine(self.axes.c2p(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())), f(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())))), self.axes.c2p(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())), 0)).set_z_index(self.c_n_dot.z_index - 1))\n        self.line_c_n_c_n_delta_x = always_redraw(lambda: Line(self.axes.c2p(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())), f(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())))), self.axes.c2p(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())) + (b - a) / n_tracker.get_value(), f(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())) + (b - a) / n_tracker.get_value())), color=BLUE).set_z_index(self.c_n_dot.z_index - 1))\n        self.other_brace = self.underbrace_delta_x.copy()\n        self.other_brace.label.set_color(BLUE)\n\n        def update_brace_1(brace):\n            brace.become(BraceLabel(Line(self.axes.c2p(a, 0), self.axes.c2p(a + (b - a) / n_tracker.get_value(), 0)), '\\\\frac{b-a}{n}', UP, buff=0, font_size=24, color=BLUE))\n            brace.label.shift(0.15 * DOWN).set_color(BLUE)\n        self.underbrace_delta_x.add_updater(update_brace_1)\n        self.play(Create(VGroup(self.c_n_dot, self.c_n_delta_x_dot, self.line_c_n_c_n_delta_x)), self.other_brace.animate.next_to(self.line_c_n_c_n_delta_x, UP, buff=0), run_time=2)\n\n        def update_brace_2(brace):\n            brace.become(BraceLabel(Line(self.axes.c2p(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())), f(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())))), self.axes.c2p(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())) + (b - a) / n_tracker.get_value(), f(dichotomie(lambda x: f(x) - f(x + (b - a) / n_tracker.get_value())) + (b - a) / n_tracker.get_value()))), '\\\\frac{b-a}{n}', UP, buff=0, font_size=24, color=BLUE))\n            brace.label.shift(0.15 * DOWN).set_color(BLUE)\n        self.other_brace.add_updater(update_brace_2)\n        self.play(Create(self.c_n_dashed_line), Write(self.c_n_label))\n        self.wait()\n        self.play(n_tracker.animate.set_value(10), run_time=2)\n        self.wait()\n        self.play(n_tracker.animate.set_value(2), run_time=2.5)\n        self.wait()\n        self.play(n_tracker.animate.set_value(6), run_time=2)\n        self.wait()\n\n    def transition(self):\n        self.new_axes = Axes(x_range=self.axes.x_range, y_range=[-1, 2, 0.5], x_length=(self.axes.y_length + 1) * 3.2 / 3 + 1, y_length=self.axes.y_length + 1, tips=False).scale(0.8).move_to(self.axes).to_edge(RIGHT, buff=0.5).shift(0.15 * DOWN)\n        self.new_f_curve = self.new_axes.plot(f, x_range=[0.5, 2.5]).set_z_index(self.dot_f_a.z_index - 1)\n        self.play(Uncreate(VGroup(self.underbrace_delta_x, self.other_brace, self.c_n_dot, self.c_n_delta_x_dot, self.line_c_n_c_n_delta_x, self.c_n_dashed_line)), Unwrite(self.c_n_label, self.f_a_f_b))\n        self.play(Transform(self.axes, self.new_axes), Transform(self.f_curve, self.new_f_curve), self.a.animate.scale(0.8).next_to(self.new_axes.c2p(a, 0), DOWN), self.b.animate.scale(0.8).next_to(self.new_axes.c2p(b, 0), DOWN), self.dot_f_a.animate.scale(0.8).move_to(self.new_f_curve.get_start()), self.dot_f_b.animate.scale(0.8).move_to(self.new_f_curve.get_end()), self.labels_axis[0].animate.scale(0.8).next_to(self.new_axes.x_axis, UR, buff=SMALL_BUFF), self.labels_axis[1].animate.scale(0.8).next_to(self.new_axes.y_axis, UP + 0.5 * RIGHT, buff=SMALL_BUFF), run_time=1.5)\n        self.add(self.new_axes, self.new_f_curve)\n        self.remove(self.axes, self.f_curve)\n\n    def proof(self):\n        self.animate_text_1()\n        self.setup_g_curve()\n        self.animate_g_sum()\n        self.tvi()\n        self.conclusion()\n\n    def animate_text_1(self):\n        self.proof_text = Tex('D\u00e9monstration : ').scale(0.7).to_edge().shift(1.75 * UP)\n        self.text_1 = Tex('On introduit la fonction auxiliaire $g$ ', 'continue', ' :').next_to(self.proof_text, DOWN).scale(0.7).to_edge().shift(0.25 * DOWN)\n        self.text_1[0][-1].set_color(ORANGE)\n        self.text_1[1].set_color(RED)\n        self.g_text = MathTex('g : &\\\\left[a, b - \\\\frac{b-a}{n}\\\\right] \\\\rightarrow \\\\mathbb{R} \\\\\\\\ &x \\\\mapsto f(x) - f\\\\left( x + \\\\frac{b - a}{n} \\\\right) ').scale(0.7).next_to(self.text_1, DOWN).shift(0.25 * DL)\n        self.g_text[0][0].set_color(ORANGE)\n        VGroup(self.g_text[0][7:12], self.g_text[0][27:32]).set_color(BLUE)\n        self.g_text[0][15:].shift(0.5 * RIGHT)\n        self.play(Write(self.proof_text))\n        self.play(Write(self.text_1))\n        self.play(DrawBorderThenFill(self.g_text))\n        self.wait()\n\n    def setup_g_curve(self):\n        self.g_curve = self.new_axes.plot(g, x_range=[0.5, 2.5 - delta_x], color=ORANGE)\n        self.g_curve_label = MathTex('g', color=ORANGE).scale(0.8).next_to(self.g_curve.get_end(), RIGHT)\n        self.dot_g_a, self.dot_g_b = (Dot(self.new_axes.c2p(a, g(a)), color=YELLOW).scale(0.8), Dot(self.new_axes.c2p(b - delta_x, g(b - delta_x)), color=YELLOW).scale(0.8))\n        self.play(Create(self.g_curve), Create(VGroup(self.dot_g_a, self.dot_g_b)), Write(self.g_curve_label), self.new_f_curve.animate.set_stroke(opacity=0.35), VGroup(self.dot_f_a, self.dot_f_b).animate.set_opacity(0.5), run_time=2)\n        self.wait()\n\n    def animate_g_sum(self):\n        self.g_sum_text = MathTex('\\\\sum_{k = 0}^{n - 1} g\\\\left( a + k\\\\frac{b - a}{n} \\\\right) &= ', '\\\\sum_{k = 0}^{n - 1} f\\\\left( a + (k + 1)\\\\frac{b - a}{n} \\\\right) - f\\\\left( a + k\\\\frac{b - a}{n} \\\\right)\\\\\\\\', '&= f\\\\left( a + 1\\\\frac{b - a}{n} \\\\right)', '- f\\\\left( a + 0\\\\frac{b - a}{n} \\\\right) \\\\\\\\', '&+f\\\\left( a + 2\\\\frac{b - a}{n} \\\\right)', '- f\\\\left( a + 1\\\\frac{b - a}{n} \\\\right) \\\\\\\\', '&+ f\\\\left( a + 3\\\\frac{b - a}{n} \\\\right)', '- f\\\\left( a + 2\\\\frac{b - a}{n} \\\\right) \\\\\\\\', '&+ ... +', 'f\\\\left( a + n\\\\frac{b - a}{n} \\\\right)', '- f\\\\left( a + (n-1)\\\\frac{b - a}{n} \\\\right)').scale(0.7).set_z_index(self.text_1.z_index + 2)\n        self.g_sum_text[4:11].shift(0.3 * RIGHT)\n        eq_sign = MathTex('=').scale(0.7).move_to(self.g_sum_text[2][0]).set_z_index(self.g_sum_text.z_index)\n        f_a_m_f_b = MathTex('f(b)', ' - f(a)').scale(0.7).next_to(eq_sign, RIGHT).set_z_index(self.g_sum_text.z_index)\n        eq_zero = MathTex('= 0').scale(0.7).next_to(f_a_m_f_b, RIGHT).set_z_index(self.g_sum_text.z_index)\n        crosses = VGroup(Cross(self.g_sum_text[2][1:12]).set_z_index(self.g_sum_text.z_index), *[Cross(self.g_sum_text[k]).set_z_index(self.g_sum_text.z_index) for k in [4, 5, 6, 7, 8, 10]])\n        somme_telescopique = Tex(\"C'est une somme\\\\\\\\\", 't\u00e9lescopique', ' !').scale(0.7).set_z_index(self.g_sum_text.z_index).next_to(self.g_sum_text[0], DOWN, buff=1).shift(0.2 * LEFT)\n        somme_telescopique[1].set_color(RED)\n        background_rectangle = BackgroundRectangle(self.g_sum_text, stroke_opacity=0.75, stroke_width=1.5, stroke_color=WHITE, fill_opacity=0.9, buff=0.5).set_z_index(self.g_sum_text.z_index - 1)\n        self.play(GrowFromCenter(background_rectangle))\n        self.play(Write(self.g_sum_text), run_time=15)\n        self.wait()\n        self.play(Indicate(VGroup(self.g_sum_text[2][1:12], self.g_sum_text[5]), color=BLUE), Indicate(VGroup(self.g_sum_text[4], self.g_sum_text[7]), color=GREEN))\n        self.wait()\n        self.play(*[GrowFromCenter(cross) for cross in crosses])\n        self.wait()\n        self.play(Write(somme_telescopique))\n        self.wait()\n        self.play(FadeOut(VGroup(*[self.g_sum_text[k] for k in [2, 4, 5, 6, 7, 8, 10]], crosses, somme_telescopique)), Write(eq_sign), Transform(self.g_sum_text[3], f_a_m_f_b[0]), Transform(self.g_sum_text[9], f_a_m_f_b[1]), Transform(background_rectangle, BackgroundRectangle(VGroup(*[self.g_sum_text[k] for k in [0, 1]], eq_zero, eq_sign, f_a_m_f_b), stroke_opacity=0.75, stroke_width=1.5, stroke_color=WHITE, fill_opacity=0.9, buff=0.5).set_z_index(self.g_sum_text.z_index - 1)), run_time=2)\n        self.remove(self.g_sum_text[3], self.g_sum_text[9])\n        self.add(f_a_m_f_b)\n        self.play(Write(eq_zero))\n        g_sum_copy = MathTex('\\\\sum_{k = 0}^{n - 1} g\\\\left( a + k\\\\frac{b - a}{n} \\\\right) =').scale(0.7).next_to(self.proof_text, DOWN, buff=0.5).to_edge(LEFT)\n        self.play(self.g_sum_text[0].animate.next_to(self.proof_text, DOWN, buff=0.5).to_edge(LEFT), eq_zero[0][1].animate.next_to(g_sum_copy, RIGHT), FadeOut(VGroup(background_rectangle, eq_sign, f_a_m_f_b, self.g_sum_text[1], eq_zero[0][0])), FadeOut(VGroup(self.text_1, self.g_text)))\n        self.g_sum_eq_0 = VGroup(self.g_sum_text[0], eq_zero[0][1])\n        self.wait()\n\n    def tvi(self):\n        text_g_nulle = Tex('$g$', ' est donc soit nulle partout, soit de signe \\\\\\\\', ' non constant, car il faut que la somme soit\\\\\\\\', ' nulle (\u00e7a se compense).', tex_environment='flushleft').scale(0.7).next_to(self.g_sum_eq_0, DOWN, buff=0.5).to_edge(LEFT)\n        text_g_nulle[0].set_color(ORANGE)\n        self.play(Write(text_g_nulle), run_time=3)\n        self.wait()\n        text_tvi = Tex('On utilise le TVI, ', ' $g$ ', \" s'annule donc quelque part.\").scale(0.7).next_to(text_g_nulle, DOWN, buff=0.5).to_edge()\n        text_tvi[1].set_color(ORANGE)\n        self.play(Write(text_tvi), run_time=2)\n        self.wait()\n\n    def conclusion(self):\n        root = dichotomie(g, 2, 2.5)\n        dot_g_0 = Dot(self.new_axes.c2p(root, 0), color=GREEN).scale(0.8)\n        group_dots_and_labels = VGroup(self.c_n_dot, self.c_n_delta_x_dot, self.c_n_dashed_line, self.line_c_n_c_n_delta_x)\n        for item in group_dots_and_labels:\n            item.clear_updaters()\n        self.new_c_n_label = MathTex('c_n', color=GREEN).scale(0.8).next_to(self.new_axes.c2p(root, 0), DL, buff=0.2)\n        self.c_n_dot.scale(0.8).move_to(self.new_axes.c2p(root, f(root))).set_z_index(self.g_curve.z_index + 2)\n        self.c_n_delta_x_dot.scale(0.8).move_to(self.new_axes.c2p(root + delta_x, f(root + delta_x))).set_z_index(self.g_curve.z_index + 2)\n        self.c_n_dashed_line = DashedLine(self.new_axes.c2p(root, 0), self.c_n_dot).set_z_index(self.g_curve.z_index + 1)\n        self.line_c_n_c_n_delta_x = Line(self.c_n_dot, self.c_n_delta_x_dot, color=BLUE).set_z_index(self.g_curve.z_index + 1)\n        dot_g_0.set_z_index(self.c_n_dashed_line.z_index + 1)\n        self.new_c_n_label.set_z_index(self.c_n_dashed_line.z_index + 1)\n        self.new_brace = BraceLabel(self.line_c_n_c_n_delta_x, '\\\\frac{b-a}{n}', UP, buff=0, font_size=24, color=BLUE)\n        self.new_brace.brace.stretch(1.25, 0)\n        self.new_brace.label.shift(0.15 * DOWN).set_color(BLUE)\n        text_g_c_n_eq_0 = MathTex('g', '(', 'c_n', ') = 0').scale(0.8).shift(3 * RIGHT + 3 * DOWN)\n        text_g_c_n_eq_0[0].set_color(ORANGE)\n        text_g_c_n_eq_0[2].set_color(GREEN)\n        self.wait(0.5)\n        self.play(FadeIn(VGroup(dot_g_0, self.c_n_dot, self.new_c_n_label, self.c_n_delta_x_dot, self.c_n_dashed_line, self.line_c_n_c_n_delta_x, self.new_brace)), self.new_f_curve.animate.set_stroke(opacity=1), VGroup(self.dot_f_a, self.dot_f_b).animate.set_opacity(1), Write(text_g_c_n_eq_0))\n        box = SurroundingRectangle(text_g_c_n_eq_0, buff=0.15)\n        self.play(ShowCreationThenFadeOut(box))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate a Sierpinski triangle by iteratively connecting random midpoints of a larger triangle."}, {"role": "assistant", "content": "from manim import *\nimport random as rd\n\nclass SierpinskiTriangle(Scene):\n\n    def construct(self):\n        self.polygon = RegularPolygon(n=3, stroke_width=0.25, color=WHITE).scale(4).move_to(ORIGIN)\n        group_of_points = [np.array([0.0, 0.0, 0.0])]\n        group_of_dots = VGroup(Dot(group_of_points[0], radius=0.0025))\n        for k in range(max_num_of_points - 1):\n            new_point = self.get_random_point(group_of_points)\n            group_of_points.append(new_point)\n            group_of_dots.add(Dot(new_point, radius=0.005))\n        self.add(self.polygon)\n        self.play(ShowIncreasingSubsets(group_of_dots), run_time=10)\n\n    def get_random_point(self, group_of_points):\n        rand_int = rd.randint(0, len(self.polygon.get_vertices()) - 1)\n        return Line(group_of_points[-1], self.polygon.get_vertices()[rand_int]).get_midpoint()"}]}
{"messages": [{"role": "user", "content": "Illustrate the intermediate value theorem using a function graph and demonstrating the dichotomous method for finding a root."}, {"role": "assistant", "content": "from manim import *\n\nclass TVIDichotomieFull(Scene):\n\n    def construct(self):\n        thm_words, underline = self.get_thm_words()\n        self.add(thm_words, underline)\n        self.wait(6)\n        self.play(thm_words.animate.scale(0.6).to_edge(UP))\n        self.add_graph()\n        self.explication_thm()\n        self.demo_dichotomie()\n\n    def get_thm_words(self):\n        template = TexTemplate()\n        template.add_to_preamble('\\\\usepackage{mathabx}')\n        thm_words = Tex('Thm : ', 'Soit  ', '  $f : [a, b] \\\\rightarrow \\\\mathbb{R}$  ', '  continue', '. Alors :', '$$\\\\forall k \\\\in \\\\underset{\\\\curvearrowbotleftright}{[f(a), f(b)]}, \\\\; \\\\exists x_k \\\\in [a, b], \\\\; f(x_k) = k.$$', tex_template=template)\n        underline = always_redraw(lambda: Underline(thm_words[0], stroke_width=2).set_opacity([0, 1, 0]).set_length(1.1))\n        thm_words[-1].scale(0.9).next_to(thm_words[0], RIGHT, buff=0.2).shift(0.85 * DOWN)\n        thm_words[3].set_color(RED)\n        thm_words[-1][1].set_color(GREEN)\n        VGroup(thm_words[-1][17], thm_words[-1][18]).set_color(BLUE)\n        return (thm_words, underline)\n\n    def add_graph(self):\n        self.axes = Axes(x_range=[0, 4, 0.5], y_range=[0, 3, 0.5], x_length=5, y_length=4, tips=False)\n        self.f = lambda x: 0.3 * (x - 1 / 2) ** 3 - 0.7 * (x - 1 / 2) ** 2 + 0.1 * (x - 1 / 2) + 0.9\n        self.a, self.b = (MathTex('a').scale(0.7).next_to(Dot(self.axes.c2p(a, 0)), DOWN), MathTex('b').scale(0.7).next_to(Dot(self.axes.c2p(b, 0)), DOWN))\n        self.f_a, self.f_b = (MathTex('f(a)').scale(0.7).next_to(Dot(self.axes.c2p(0, self.f(a))), LEFT), MathTex('f(b)').scale(0.7).next_to(Dot(self.axes.c2p(0, self.f(b))), LEFT))\n        VGroup(self.axes, self.a, self.b, self.f_a, self.f_b).scale(1.2).move_to(ORIGIN).shift(0.5 * DOWN)\n        self.dot_a_f_a, self.dot_b_f_b = (Dot(self.axes.c2p(a, self.f(a))), Dot(self.axes.c2p(b, self.f(b))))\n        self.graph = self.axes.plot(self.f, x_range=[a, b], color=YELLOW)\n        self.play(FadeIn(VGroup(self.axes, self.graph, self.a, self.b, self.f_a, self.f_b, self.dot_a_f_a, self.dot_b_f_b)))\n        self.wait()\n\n    def explication_thm(self):\n        x_k = ValueTracker(3.05)\n        self.k = always_redraw(lambda: MathTex('k', color=GREEN).scale(0.7 * 1.2).next_to(Dot(self.axes.c2p(0, self.f(x_k.get_value()))), LEFT))\n        self.x_k = always_redraw(lambda: MathTex('x_k', color=BLUE).scale(0.7 * 1.2).next_to(Dot(self.axes.c2p(x_k.get_value(), 0)), DOWN))\n        self.dashed_line_k = always_redraw(lambda: DashedLine(self.axes.c2p(0, self.f(x_k.get_value())), self.axes.c2p(x_k.get_value(), self.f(x_k.get_value()))))\n        self.dashed_line_x_k = always_redraw(lambda: DashedLine(self.axes.c2p(x_k.get_value(), self.f(x_k.get_value())), self.axes.c2p(x_k.get_value(), 0)))\n        self.curve_point = always_redraw(lambda: Dot(self.axes.c2p(x_k.get_value(), self.f(x_k.get_value())), color=DARK_BROWN).set_z_index(self.dashed_line_x_k.z_index + 1))\n        self.play(Write(self.k), Create(self.dashed_line_k), run_time=1.5)\n        self.play(Create(self.curve_point), Create(self.dashed_line_x_k), run_time=1.5)\n        self.play(Write(self.x_k))\n        self.wait()\n        self.play(x_k.animate.set_value(3.45))\n        self.wait(0.5)\n        self.play(x_k.animate.set_value(1), run_time=2)\n        self.wait(0.5)\n        self.play(x_k.animate.set_value(3.05), run_time=1.5)\n        self.wait()\n        self.play(Unwrite(self.k), Uncreate(self.dashed_line_k), Uncreate(self.curve_point), Uncreate(self.dashed_line_x_k), Unwrite(self.x_k), VGroup(self.axes, self.a, self.b, self.f_a, self.f_b, self.graph, self.dot_a_f_a, self.dot_b_f_b).animate.shift(0.5 * UP).scale(1 / 1.2).to_edge(RIGHT, buff=0.7).shift(0.75 * DOWN), run_time=2)\n        self.wait(0.5)\n\n    def demo_dichotomie(self):\n        text_type_demo = Tex('D\u00e9montration par \\\\textit{dichotomie}.').scale(0.7).to_edge().shift(1.75 * UP)\n        text_construction_suite = Tex('On construit les suites ', '$(a_n)$', ' et ', '$(b_n)$', ' suivantes :').scale(0.6).next_to(text_type_demo, DOWN, buff=0.5).to_edge()\n        text_construction_suite[1].set_color(YELLOW)\n        text_construction_suite[3].set_color(PURPLE)\n        text_a_n_b_n = MathTex('\\\\begin{cases} a_0 = a, \\\\,\\\\, b_0 = b \\\\\\\\ a_{n+1} = \\\\begin{cases} c_n \\\\quad \\\\text{si} \\\\quad f(c_n) \\\\leqslant k \\\\\\\\ a_n \\\\quad \\\\text{sinon} \\\\end{cases} \\\\\\\\ b_{n+1} = \\\\begin{cases} b_n \\\\quad \\\\text{si} \\\\quad f(c_n) \\\\leqslant k \\\\\\\\ c_n \\\\quad \\\\text{sinon} \\\\end{cases} \\\\end{cases}').scale(0.6).next_to(text_construction_suite, DOWN, buff=0.5)\n        text_c_n = Tex('o\u00f9 ', '$\\\\displaystyle{\\\\,\\\\, c_n = \\\\frac{a_n + b_n}{2} \\\\,\\\\,}$', ' pour $n \\\\in \\\\mathbb{N}$.').scale(0.6).next_to(text_a_n_b_n, DOWN, buff=0.5).to_edge()\n        text_a_0 = MathTex('a_0', color=YELLOW).scale(0.7 * 1.2 * 0.5).next_to(Dot(self.axes.c2p(a, 0)), DOWN, buff=0.15)\n        text_b_0 = MathTex('b_0', color=PURPLE).scale(0.7 * 1.2 * 0.5).next_to(Dot(self.axes.c2p(b, 0)), DOWN, buff=0.12)\n        k_dot = Dot(self.axes.c2p(0, k), radius=DEFAULT_SMALL_DOT_RADIUS, color=GREEN)\n        x_k_dot = Dot(self.axes.c2p(3.05, 0), radius=DEFAULT_SMALL_DOT_RADIUS, color=BLUE)\n        text_k = MathTex('k', color=GREEN).scale(0.7).next_to(k_dot, LEFT)\n        text_x_k = MathTex('x_k', color=BLUE).scale(0.7).next_to(x_k_dot, DOWN)\n        list_texts_a = [text_a_0]\n        list_texts_b = [text_b_0]\n        self.play(Write(text_type_demo), run_time=2)\n        self.play(Write(text_construction_suite), run_time=2)\n        self.play(DrawBorderThenFill(text_a_n_b_n))\n        self.play(DrawBorderThenFill(text_c_n))\n        self.wait(4)\n        dot_a_0, dot_b_0 = (Dot(self.axes.c2p(a, 0), radius=DEFAULT_SMALL_DOT_RADIUS, color=YELLOW), Dot(self.axes.c2p(b, 0), radius=DEFAULT_SMALL_DOT_RADIUS, color=PURPLE))\n        dot_f_a_n, dot_f_b_n = (Dot(self.axes.c2p(0, self.f(a)), radius=DEFAULT_SMALL_DOT_RADIUS, color=YELLOW), Dot(self.axes.c2p(0, self.f(b)), radius=DEFAULT_SMALL_DOT_RADIUS, color=PURPLE))\n        text_f_a_0, text_f_b_0 = (self.f_a.copy(), self.f_b.copy())\n        list_text_f_a_n, list_text_f_b_n = ([text_f_a_0], [text_f_b_0])\n        self.play(Transform(self.a, text_a_0), Transform(self.b, text_b_0), Create(VGroup(dot_a_0, dot_b_0, k_dot, dot_f_a_n, dot_f_b_n)), Write(text_k))\n        self.add(text_a_0, text_b_0)\n        self.remove(self.a, self.b)\n        self.wait()\n        a_n, b_n = ([a], [b])\n        list_dots = []\n        text_b_4 = MathTex('b_4', color=PURPLE).scale(0.7 * 1.2 * 0.5).next_to(Dot(self.axes.c2p(3.25, 0)), UP, buff=0.13)\n        for etape in range(nb_etapes):\n            c_n = (a_n[etape] + b_n[etape]) / 2\n            text_c_n_2 = MathTex('c_{}'.format(etape)).next_to(Dot(self.axes.c2p(c_n, 0)), DOWN, buff=0.15).scale(0.7 * 1.2 * 0.5)\n            dashed_line_c_n = DashedLine(self.axes.c2p(c_n, 0), self.axes.c2p(c_n, self.f(c_n)))\n            dashed_line_f_c_n = DashedLine(self.axes.c2p(c_n, self.f(c_n)), self.axes.c2p(0, self.f(c_n)))\n            c_n_f_c_n_dot = Dot(self.axes.c2p(c_n, self.f(c_n)), color=DARK_BROWN)\n            f_c_n_dot = Dot(self.axes.c2p(0, self.f(c_n)), radius=DEFAULT_SMALL_DOT_RADIUS)\n            c_n_f_c_n_dot.set_z_index(c_n_f_c_n_dot.z_index + 1)\n            c_n_dot = Dot(self.axes.c2p(c_n, 0), radius=DEFAULT_SMALL_DOT_RADIUS, color=YELLOW * (self.f(c_n) <= k) + PURPLE * (self.f(c_n) > k))\n            list_dots.append(c_n_dot)\n            self.play(Write(text_c_n_2), Create(VGroup(c_n_dot, dashed_line_c_n)), run_time=1.5)\n            self.play(Create(VGroup(c_n_f_c_n_dot, dashed_line_f_c_n)))\n            self.play(Create(f_c_n_dot))\n            self.wait(0.5)\n            self.play(Indicate(VGroup(k_dot, f_c_n_dot), scale_factor=1.25))\n            self.wait(0.5)\n            self.play(FadeOut(VGroup(dashed_line_c_n, dashed_line_f_c_n, c_n_f_c_n_dot, f_c_n_dot)))\n            self.wait(0.5)\n            if self.f(c_n) <= k:\n                new_a_n = c_n\n                new_b_n = b_n[etape]\n                text_new_a_n = MathTex('a_{}'.format(etape + 1), color=YELLOW).scale(0.7 * 1.2 * 0.5).next_to(Dot(self.axes.c2p(c_n, 0)), DOWN * (etape < 3) + UP * (etape >= 3), buff=0.15)\n                text_new_b_n = MathTex('= b_{}'.format(etape + 1), color=PURPLE).scale(0.7 * 1.2 * 0.5).next_to(list_texts_b[etape], RIGHT, buff=0.08)\n                a_n.append(new_a_n)\n                b_n.append(new_b_n)\n                list_texts_a.append(text_new_a_n)\n                list_texts_b.append(text_new_b_n)\n                text_f_a_n = MathTex('f(a_{})'.format(etape + 1)).scale(0.7 * 1.2 * 0.5).next_to(self.axes.c2p(0, self.f(new_a_n)), LEFT)\n                text_f_b_n = MathTex('f(b_{})'.format(etape + 1)).scale(0.7 * 1.2 * 0.5).next_to(self.axes.c2p(0, self.f(new_b_n)), LEFT)\n                VGroup(*text_f_a_n[0][2:4]).set_color(YELLOW)\n                VGroup(*text_f_b_n[0][2:4]).set_color(PURPLE)\n                self.play(Transform(text_c_n_2, text_new_a_n), Write(text_new_b_n), dot_f_a_n.animate.move_to(self.axes.c2p(0, self.f(new_a_n))), Transform(list_text_f_a_n[-1], text_f_a_n), Transform(list_text_f_b_n[-1], text_f_b_n), run_time=1.5)\n                self.add(text_new_a_n, text_f_a_n, text_f_b_n)\n                self.remove(text_c_n_2, list_text_f_a_n[-1], list_text_f_b_n[-1])\n                list_text_f_a_n.append(text_f_a_n)\n                list_text_f_b_n.append(text_f_b_n)\n                self.wait(0.5)\n            else:\n                new_a_n = a_n[etape]\n                new_b_n = c_n\n                text_new_a_n = MathTex('= a_{}'.format(etape + 1), color=YELLOW).scale(0.7 * 1.2 * 0.5).next_to(list_texts_a[etape], RIGHT, buff=0.08)\n                text_new_b_n = MathTex('b_{}'.format(etape + 1), color=PURPLE).scale(0.7 * 1.2 * 0.5).next_to(Dot(self.axes.c2p(c_n, 0)), DOWN * (etape < 2) + UP * (etape >= 2), buff=0.13)\n                a_n.append(new_a_n)\n                b_n.append(new_b_n)\n                list_texts_a.append(text_new_a_n)\n                list_texts_b.append(text_new_b_n)\n                text_f_a_n = MathTex('f(a_{})'.format(etape + 1)).scale(0.7 * 1.2 * 0.5).next_to(self.axes.c2p(0, self.f(new_a_n)), LEFT)\n                text_f_b_n = MathTex('f(b_{})'.format(etape + 1)).scale(0.7 * 1.2 * 0.5).next_to(self.axes.c2p(0, self.f(new_b_n)), LEFT)\n                VGroup(*text_f_a_n[0][2:4]).set_color(YELLOW)\n                VGroup(*text_f_b_n[0][2:4]).set_color(PURPLE)\n                self.play(Transform(text_c_n_2, text_new_b_n), Write(text_new_a_n), dot_f_b_n.animate.move_to(self.axes.c2p(0, self.f(new_b_n))), Transform(list_text_f_a_n[-1], text_f_a_n), Transform(list_text_f_b_n[-1], text_f_b_n), run_time=1.5)\n                self.add(text_new_b_n, text_f_a_n, text_f_b_n)\n                self.remove(text_c_n_2, list_text_f_a_n[-1], list_text_f_b_n[-1])\n                list_text_f_a_n.append(text_f_a_n)\n                list_text_f_b_n.append(text_f_b_n)\n                self.wait(0.5)\n        self.play(FadeOut(VGroup(*list_texts_a[1:4], *list_texts_b[1:3], list_texts_b[4], *list_dots[0:2])), Transform(list_texts_b[3], text_b_4), Create(x_k_dot), Write(text_x_k), text_a_0.animate.scale(2 / 1.2).next_to(dot_a_0, DOWN), text_b_0.animate.scale(2 / 1.2).next_to(dot_b_0, DOWN, buff=0.22), text_k.animate.scale(1.2 * 0.5))\n        self.add(text_b_4)\n        self.remove(list_texts_b[3])\n        self.wait(0.4)\n        self.play(FadeOut(VGroup(text_construction_suite, text_a_n_b_n, text_c_n)))\n        self.wait(0.5)\n        text_suites_adjacentes_1 = Tex('Les suites ', ' $(a_n)$ ', ' et ', ' $(b_n)$ ', ' sont adjacentes,').scale(0.7).next_to(text_type_demo, DOWN, buff=0.4).to_edge()\n        text_suites_adjacentes_2 = Tex('elles convergent donc vers la m\u00eame limite', ' $x_k$.').scale(0.7).next_to(text_suites_adjacentes_1, DOWN, buff=0.4).to_edge()\n        text_continuite = Tex('Par ', ' continuit\u00e9 ', ' de $f$, ', ' $f(a_n), f(b_n) \\\\to f(x_k)$.').scale(0.7).next_to(text_suites_adjacentes_2, DOWN, buff=0.4).to_edge()\n        text_encadrement = Tex('Or', '$$\\\\forall n \\\\in \\\\mathbb{N}, f(a_n) \\\\leqslant k \\\\leqslant f(b_n)$$', 'Donc par passage \u00e0 la limite, ', '$k = f(x_k)$.', tex_environment='flushleft').scale(0.7).next_to(text_continuite, DOWN, buff=0.4).to_edge()\n        text_continuite[3].shift(0.2 * RIGHT)\n        text_encadrement[1].shift(2.75 * LEFT)\n        VGroup(text_encadrement[2], text_encadrement[3]).shift(0.25 * DOWN)\n        VGroup(*text_encadrement[1][5:]).shift(0.25 * RIGHT)\n        VGroup(text_suites_adjacentes_1[1], *text_continuite[3][2:4], *text_encadrement[1][7:9]).set_color(YELLOW)\n        VGroup(text_suites_adjacentes_1[3], *text_continuite[3][8:10], *text_encadrement[1][15:17]).set_color(PURPLE)\n        VGroup(text_suites_adjacentes_2[1], *text_continuite[3][14:16], *text_encadrement[3][4:6]).set_color(BLUE)\n        VGroup(text_encadrement[1][11], text_encadrement[3][0]).set_color(GREEN)\n        text_continuite[1].set_color(RED)\n        self.play(DrawBorderThenFill(text_suites_adjacentes_1))\n        self.wait()\n        self.play(DrawBorderThenFill(text_suites_adjacentes_2))\n        self.wait()\n        self.play(DrawBorderThenFill(text_continuite))\n        self.wait()\n        self.play(DrawBorderThenFill(text_encadrement))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Animate a demonstration of a CPU clock signal, including its waveform, voltage levels, period, frequency, and edge transitions."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\n\nclass CPUClock(CPUClockBase, MovingCameraScene):\n    \"\"\"CPU Clock animation with cinematic camera movements\"\"\"\n\n    def __init__(self, language='en'):\n        CPUClockBase.__init__(self)\n        MovingCameraScene.__init__(self)\n        self.lang = language\n\n    def construct(self):\n        self.intro_sequence()\n        self.main_clock_demo()\n\n    def intro_sequence(self):\n        \"\"\"Introduction with minimal camera movements\"\"\"\n        grid = NumberPlane(x_range=[-10, 10, 1], y_range=[-6, 6, 1], background_line_style={'stroke_color': BLUE_E, 'stroke_width': 1, 'stroke_opacity': 0.2})\n        title = Text(self.t('intro_title'), font_size=56, color=BLUE)\n        title.set_stroke(BLUE_B, width=2)\n        subtitle = Text(self.t('intro_text'), font_size=28, color=WHITE)\n        subtitle.next_to(title, DOWN, buff=0.5)\n        self.add(grid)\n        self.play(Write(title), run_time=2)\n        self.play(FadeIn(subtitle, shift=UP))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in [title, subtitle]], grid.animate.set_opacity(0.1), run_time=1.5)\n\n    def main_clock_demo(self):\n        \"\"\"Main clock signal demonstration\"\"\"\n        axes = Axes(x_range=[0, 8, 1], y_range=[-0.5, 4, 1], x_length=10, y_length=4, axis_config={'color': BLUE_B, 'include_tip': True, 'tip_length': 0.3, 'include_numbers': True, 'numbers_with_elongated_ticks': [0, 2, 4, 6, 8], 'tick_size': 0.1}, x_axis_config={'numbers_to_include': np.arange(0, 9, 2), 'font_size': 24}, y_axis_config={'numbers_to_include': [0, 3.3], 'decimal_number_config': {'num_decimal_places': 1}, 'font_size': 24})\n        time_icon = VGroup(Circle(radius=0.15, color=WHITE, stroke_width=2), Line(ORIGIN, UP * 0.1, color=WHITE, stroke_width=2), Line(ORIGIN, RIGHT * 0.12, color=WHITE, stroke_width=2).rotate(PI / 3, about_point=ORIGIN))\n        time_icon.scale(1.5)\n        voltage_icon = VGroup(Line(UP * 0.2, DOWN * 0.1 + LEFT * 0.05, color=YELLOW, stroke_width=3), Line(DOWN * 0.1 + LEFT * 0.05, DOWN * 0.1 + RIGHT * 0.05, color=YELLOW, stroke_width=3), Line(DOWN * 0.1 + RIGHT * 0.05, DOWN * 0.3, color=YELLOW, stroke_width=3))\n        voltage_icon.scale(1.2)\n        x_label = VGroup(time_icon, Text(f\"{self.t('time_axis')} ({self.t('time_unit')})\", font_size=28)).arrange(RIGHT, buff=0.3)\n        x_label.next_to(axes.x_axis, DOWN, buff=0.5)\n        y_label = VGroup(voltage_icon, Text(self.t('voltage_axis'), font_size=28)).arrange(RIGHT, buff=0.3)\n        y_label.rotate(PI / 2)\n        y_label.next_to(axes.y_axis, LEFT, buff=0.5)\n        self.play(Create(axes), run_time=2)\n        self.play(Write(x_label), Write(y_label))\n        clock_period = 2\n        voltage_high = 3.3\n        voltage_low = 0\n        num_cycles = 4\n        clock_path = self.create_clock_signal(axes, clock_period, voltage_high, voltage_low, num_cycles)\n        self.play(Create(clock_path), run_time=3, rate_func=linear)\n        self.add_voltage_indicators(axes, voltage_high, voltage_low)\n        self.create_tracker_system(axes, clock_period, voltage_high, voltage_low, num_cycles)\n        self.show_period_frequency(axes, clock_period)\n        self.demonstrate_edges(axes, clock_period, voltage_high, voltage_low)\n        self.wait(2)\n        self.play(FadeOut(self.info_bg), FadeOut(self.time_display), FadeOut(self.voltage_display), FadeOut(self.tracker_dot), run_time=1)\n        self.play(*[FadeOut(mob) for mob in self.mobjects], run_time=2)\n\n    def create_clock_signal(self, axes, period, v_high, v_low, cycles):\n        \"\"\"Create a stylized clock signal with gradient effect\"\"\"\n        points = []\n        for cycle in range(cycles):\n            t_start = cycle * period\n            t_mid = t_start + period / 2\n            t_end = t_start + period\n            if cycle == 0:\n                points.append(axes.c2p(t_start, v_low))\n            rise_points = [axes.c2p(t_start, v_low), axes.c2p(t_start + 0.05, v_low + (v_high - v_low) * 0.5), axes.c2p(t_start + 0.1, v_high)]\n            points.extend(rise_points[1:])\n            points.append(axes.c2p(t_mid - 0.1, v_high))\n            fall_points = [axes.c2p(t_mid - 0.1, v_high), axes.c2p(t_mid - 0.05, v_high - (v_high - v_low) * 0.5), axes.c2p(t_mid, v_low)]\n            points.extend(fall_points[1:])\n            points.append(axes.c2p(t_end, v_low))\n        clock_signal = VMobject()\n        clock_signal.set_points_as_corners(points)\n        clock_signal.set_stroke(color=[YELLOW, ORANGE], width=4)\n        clock_signal.set_sheen_direction(RIGHT)\n        return clock_signal\n\n    def add_voltage_indicators(self, axes, v_high, v_low):\n        \"\"\"Add animated voltage level indicators\"\"\"\n        high_line = DashedLine(axes.c2p(0, v_high), axes.c2p(8, v_high), color=GREEN, stroke_width=2, dash_length=0.1)\n        high_label = VGroup(Text('1', font_size=32, color=GREEN), Text(self.t('high'), font_size=20, color=GREEN)).arrange(DOWN, buff=0.1)\n        high_label.next_to(high_line, LEFT, buff=0.3)\n        low_line = DashedLine(axes.c2p(0, v_low), axes.c2p(8, v_low), color=RED, stroke_width=2, dash_length=0.1)\n        low_label = VGroup(Text('0', font_size=32, color=RED), Text(self.t('low'), font_size=20, color=RED)).arrange(DOWN, buff=0.1)\n        low_label.next_to(low_line, LEFT, buff=0.3)\n        self.play(Create(high_line), Create(low_line), FadeIn(high_label, scale=0.8), FadeIn(low_label, scale=0.8))\n        self.play(high_label[0].animate.scale(1.2).set_color(YELLOW), low_label[0].animate.scale(1.2).set_color(ORANGE), rate_func=there_and_back, run_time=1)\n\n    def create_tracker_system(self, axes, period, v_high, v_low, cycles):\n        \"\"\"Create an advanced tracking system with visual effects\"\"\"\n        self.tracker_dot = Dot(radius=0.15, color=BLUE)\n        self.tracker_dot.set_glow_factor(0.8)\n        self.tracker_dot.move_to(axes.c2p(0, v_low))\n        tracker_dot = self.tracker_dot\n        trail = TracedPath(tracker_dot.get_center, stroke_color=[BLUE, PURPLE], stroke_width=2, stroke_opacity=[1, 0])\n        self.info_bg = RoundedRectangle(width=5, height=1.5, corner_radius=0.2, fill_color=BLACK, fill_opacity=0.9, stroke_color=BLUE, stroke_width=2).to_corner(UR, buff=0.3)\n        self.time_display = always_redraw(lambda: VGroup(Text(self.t('current_time') + ':', font_size=20, color=BLUE_B), Text(f\"{(tracker_dot.get_x() - axes.c2p(0, 0)[0]) / (axes.c2p(1, 0)[0] - axes.c2p(0, 0)[0]):.2f} {self.t('time_unit')}\", font_size=24, font='monospace', color=WHITE)).arrange(RIGHT, buff=0.3).move_to(self.info_bg.get_center() + UP * 0.3))\n        self.voltage_display = always_redraw(lambda: VGroup(Text(self.t('current_voltage') + ':', font_size=20, color=YELLOW), Text(f'{(tracker_dot.get_y() - axes.c2p(0, 0)[1]) * 3.3 / (axes.c2p(0, 3.3)[1] - axes.c2p(0, 0)[1]):.2f}V', font_size=24, font='monospace', color=WHITE)).arrange(RIGHT, buff=0.3).move_to(self.info_bg.get_center() + DOWN * 0.3))\n        self.play(FadeIn(self.info_bg), Create(tracker_dot), Write(self.time_display), Write(self.voltage_display))\n        self.add(trail)\n        self.clock_time = 0\n\n        def update_tracker(mob, dt):\n            self.clock_time += dt\n            t = self.clock_time * 2\n            cycle = int(t / period) % cycles\n            phase = t % period / period\n            x = axes.c2p(t % (cycles * period), 0)[0]\n            if phase < 0.05:\n                progress = phase / 0.05\n                y = axes.c2p(0, v_low + smooth(progress) * (v_high - v_low))[1]\n            elif phase < 0.45:\n                y = axes.c2p(0, v_high)[1]\n            elif phase < 0.5:\n                progress = (phase - 0.45) / 0.05\n                y = axes.c2p(0, v_high - smooth(progress) * (v_high - v_low))[1]\n            else:\n                y = axes.c2p(0, v_low)[1]\n            mob.move_to([x, y, 0])\n        tracker_dot.add_updater(update_tracker)\n        self.wait(6)\n        tracker_dot.remove_updater(update_tracker)\n        self.play(FadeOut(trail))\n\n    def show_period_frequency(self, axes, period):\n        \"\"\"Show period and frequency with visual emphasis\"\"\"\n        elements_to_hide = [self.info_bg, self.time_display, self.voltage_display, self.tracker_dot]\n        self.play(*[mob.animate.set_opacity(0.2) for mob in elements_to_hide], run_time=0.5)\n        period_line = Line(axes.c2p(0, -0.3), axes.c2p(period, -0.3), color=YELLOW, stroke_width=3)\n        period_arrows = VGroup(Arrow(axes.c2p(0, -0.3), axes.c2p(0, -0.1), buff=0, color=YELLOW), Arrow(axes.c2p(period, -0.3), axes.c2p(period, -0.1), buff=0, color=YELLOW))\n        period_label = VGroup(Text(self.t('period'), font_size=24, color=YELLOW), Text(f\"{period} {self.t('time_unit')}\", font_size=32, color=WHITE)).arrange(DOWN, buff=0.1)\n        period_label.next_to(period_line, DOWN, buff=0.3)\n        freq_formula = MathTex(f'f = \\\\frac{{1}}{{T}} = \\\\frac{{1}}{{{period}\\\\text{{ ns}}}} = {1000 / period:.0f}\\\\text{{ MHz}}', font_size=28)\n        freq_formula.next_to(period_label, DOWN, buff=0.5)\n        self.play(Create(period_line), Create(period_arrows))\n        self.play(Write(period_label))\n        self.play(Write(freq_formula))\n        cpu_info = VGroup(Text(f\"{self.t('modern_cpu')}: 3-5 {self.t('freq_unit')}\", font_size=24), Text(f\"= 3-5 {self.t('cycles_per_second')}\", font_size=20, color=GRAY)).arrange(DOWN, buff=0.1)\n        cpu_info.next_to(freq_formula, DOWN, buff=0.5)\n        self.play(FadeIn(cpu_info, shift=UP))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in [period_line, period_arrows, period_label, freq_formula, cpu_info]], run_time=1.5)\n        self.play(*[mob.animate.set_opacity(1) for mob in elements_to_hide], run_time=0.5)\n\n    def demonstrate_edges(self, axes, period, v_high, v_low):\n        \"\"\"Demonstrate rising and falling edges\"\"\"\n        focus_rect = Rectangle(width=1.5, height=4.5, stroke_color=YELLOW, stroke_width=2, fill_opacity=0).move_to(axes.c2p(0, v_high / 2))\n        self.play(Create(focus_rect))\n        rising_arrow = Arrow(axes.c2p(0, v_low), axes.c2p(0, v_high), color=GREEN, stroke_width=4, max_tip_length_to_length_ratio=0.15)\n        rising_label = Text(self.t('rising_edge'), font_size=28, color=GREEN)\n        rising_label.next_to(rising_arrow, RIGHT, buff=0.3)\n        trigger_pulse = Circle(radius=0.3, color=GREEN)\n        trigger_pulse.move_to(axes.c2p(0, v_high / 2))\n        self.play(GrowArrow(rising_arrow))\n        self.play(Write(rising_label))\n        self.play(Create(trigger_pulse), trigger_pulse.animate.scale(3).set_opacity(0), run_time=1)\n        edge_info = Text(self.t('edge_trigger'), font_size=20, color=WHITE).next_to(rising_label, DOWN, buff=0.3)\n        self.play(FadeIn(edge_info))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in [rising_arrow, rising_label, edge_info, focus_rect]], run_time=1)\n        focus_rect2 = Rectangle(width=1.5, height=4.5, stroke_color=YELLOW, stroke_width=2, fill_opacity=0).move_to(axes.c2p(period / 2, v_high / 2))\n        self.play(Create(focus_rect2))\n        falling_arrow = Arrow(axes.c2p(period / 2, v_high), axes.c2p(period / 2, v_low), color=RED, stroke_width=4, max_tip_length_to_length_ratio=0.15)\n        falling_label = Text(self.t('falling_edge'), font_size=28, color=RED)\n        falling_label.next_to(falling_arrow, RIGHT, buff=0.3)\n        self.play(GrowArrow(falling_arrow))\n        self.play(Write(falling_label))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in [falling_arrow, falling_label, focus_rect2]], run_time=1)"}]}
{"messages": [{"role": "user", "content": "Create a visual representation of the Producer-Consumer problem with a buffer, showing items being produced and consumed over multiple cycles."}, {"role": "assistant", "content": "from manim import *\nimport random\n\nclass ProducerConsumerBase(Scene):\n    \"\"\"Base class for Producer-Consumer animation\"\"\"\n\n    def __init__(self, language='en', **kwargs):\n        super().__init__(**kwargs)\n        self.language = language\n        self.setup_translations()\n\n    def setup_translations(self):\n        \"\"\"Set up text translations based on language\"\"\"\n        if self.language == 'tr':\n            self.texts = {'title': '\u00dcretici-T\u00fcketici Mekanizmas\u0131', 'producer': '\u00dcretici', 'consumer': 'T\u00fcketici', 'buffer': 'Tampon', 'buffer_size': 'Tampon Boyutu: {}', 'current_size': 'Mevcut: {}', 'producing': '\u00dcretiliyor...', 'consuming': 'T\u00fcketiliyor...', 'waiting': 'Bekliyor...', 'cycle': 'D\u00f6ng\u00fc {}/8', 'end_text': 'D\u00f6ng\u00fc Tamamland\u0131!'}\n        else:\n            self.texts = {'title': 'Producer-Consumer Mechanism', 'producer': 'Producer', 'consumer': 'Consumer', 'buffer': 'Buffer', 'buffer_size': 'Buffer Size: {}', 'current_size': 'Current: {}', 'producing': 'Producing...', 'consuming': 'Consuming...', 'waiting': 'Waiting...', 'cycle': 'Cycle {}/8', 'end_text': 'Cycle Complete!'}\n\n    def construct(self):\n        self.camera.background_color = '#1a1a1a'\n        title = Text(self.texts['title'], font_size=48, weight=BOLD, color=WHITE).to_edge(UP, buff=0.3)\n        lang_text = 'TR | T\u00fcrk\u00e7e' if self.language == 'tr' else 'EN | English'\n        lang_indicator = Text(lang_text, font_size=16, weight=BOLD, color=WHITE)\n        lang_box = RoundedRectangle(width=lang_indicator.width + 0.4, height=lang_indicator.height + 0.2, corner_radius=0.1, color=GOLD, fill_color=GOLD, fill_opacity=0.2, stroke_width=2)\n        lang_group = VGroup(lang_box, lang_indicator).arrange(ORIGIN)\n        lang_group.to_corner(UR, buff=0.2)\n        self.play(Write(title), FadeIn(lang_group))\n        self.wait(0.5)\n        main_y = 0.8\n        producer_box = RoundedRectangle(corner_radius=0.15, width=3, height=2.5, color=BLUE, fill_color=BLUE, fill_opacity=0.1, stroke_width=3)\n        producer_text = Text(self.texts['producer'], color=BLUE, font_size=32, weight=BOLD)\n        producer_group = VGroup(producer_text, producer_box).arrange(DOWN, buff=0.2)\n        producer_group.move_to(LEFT * 4.5 + UP * main_y)\n        buffer_box = RoundedRectangle(corner_radius=0.15, width=3.5, height=3.5, color=GREEN, fill_color=GREEN, fill_opacity=0.1, stroke_width=3)\n        buffer_text = Text(self.texts['buffer'], color=GREEN, font_size=32, weight=BOLD)\n        buffer_size_text = Text(self.texts['buffer_size'].format(5), font_size=20, color=GRAY_B)\n        buffer_current_text = Text(self.texts['current_size'].format(0), font_size=24, color=YELLOW, weight=BOLD)\n        buffer_info = VGroup(buffer_size_text, buffer_current_text).arrange(DOWN, buff=0.1)\n        buffer_group = VGroup(buffer_text, buffer_box).arrange(DOWN, buff=0.2)\n        buffer_group.move_to(UP * main_y)\n        buffer_info.next_to(buffer_box, DOWN, buff=0.2)\n        consumer_box = RoundedRectangle(corner_radius=0.15, width=3, height=2.5, color=RED, fill_color=RED, fill_opacity=0.1, stroke_width=3)\n        consumer_text = Text(self.texts['consumer'], color=RED, font_size=32, weight=BOLD)\n        consumer_group = VGroup(consumer_text, consumer_box).arrange(DOWN, buff=0.2)\n        consumer_group.move_to(RIGHT * 4.5 + UP * main_y)\n        self.play(Create(producer_group), run_time=1.5)\n        self.wait(0.3)\n        self.play(Create(buffer_group), Write(buffer_info), run_time=1.5)\n        self.wait(0.3)\n        self.play(Create(consumer_group), run_time=1.5)\n        self.wait(0.5)\n        arrow_y_offset = -0.3\n        arrow_p_to_b = Arrow(producer_box.get_right() + UP * arrow_y_offset, buffer_box.get_left() + UP * arrow_y_offset, color=YELLOW, stroke_width=4, buff=0.1, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.3)\n        arrow_b_to_c = Arrow(buffer_box.get_right() + UP * arrow_y_offset, consumer_box.get_left() + UP * arrow_y_offset, color=YELLOW, stroke_width=4, buff=0.1, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.3)\n        self.play(Create(arrow_p_to_b), Create(arrow_b_to_c))\n        self.wait(1)\n        buffer_items = []\n        max_buffer_size = 5\n        producer_status = Text(self.texts['producing'], color=BLUE, font_size=28, weight=BOLD)\n        producer_status.next_to(producer_group, UP, buff=0.3)\n        consumer_status = Text(self.texts['waiting'], color=RED, font_size=28, weight=BOLD)\n        consumer_status.next_to(consumer_group, UP, buff=0.3)\n        for cycle in range(8):\n            cycle_text = Text(self.texts['cycle'].format(cycle + 1), font_size=28, weight=BOLD, color=GOLD)\n            cycle_text.to_edge(DOWN, buff=0.5)\n            self.play(Write(cycle_text), run_time=0.5)\n            if len(buffer_items) < max_buffer_size:\n                self.play(Write(producer_status), run_time=0.5)\n                data_value = random.randint(1, 99)\n                data_item = Circle(radius=0.25, color=BLUE_C, fill_opacity=0.8, stroke_width=2)\n                data_text = Text(str(data_value), font_size=20, color=WHITE, weight=BOLD)\n                data_text.move_to(data_item.get_center())\n                data_group = VGroup(data_item, data_text)\n                data_group.move_to(producer_box.get_center())\n                self.play(Create(data_group), run_time=0.4)\n                rows = 2\n                cols = 3\n                index = len(buffer_items)\n                row = index // cols\n                col = index % cols\n                x_offset = (col - 1) * 0.7\n                y_offset = (0.5 - row) * 0.7\n                target_pos = buffer_box.get_center() + RIGHT * x_offset + UP * y_offset\n                self.play(data_group.animate.move_to(target_pos), run_time=0.6)\n                buffer_items.append(data_group)\n                new_count_text = Text(self.texts['current_size'].format(len(buffer_items)), font_size=24, color=YELLOW, weight=BOLD)\n                new_count_text.move_to(buffer_current_text.get_center())\n                self.play(Transform(buffer_current_text, new_count_text), run_time=0.3)\n                self.play(FadeOut(producer_status), run_time=0.3)\n            else:\n                wait_text = Text(self.texts['waiting'], color=ORANGE, font_size=28, weight=BOLD)\n                wait_text.next_to(producer_group, UP, buff=0.3)\n                self.play(Write(wait_text), run_time=0.5)\n                self.wait(0.5)\n                self.play(FadeOut(wait_text), run_time=0.3)\n            if len(buffer_items) > 0 and cycle % 2 == 1:\n                consumer_status_active = Text(self.texts['consuming'], color=RED, font_size=28, weight=BOLD)\n                consumer_status_active.next_to(consumer_group, UP, buff=0.3)\n                self.play(Write(consumer_status_active), run_time=0.5)\n                data_to_consume = buffer_items.pop(0)\n                self.play(data_to_consume.animate.move_to(consumer_box.get_center()), run_time=0.6)\n                self.play(FadeOut(data_to_consume), run_time=0.4)\n                for i, item in enumerate(buffer_items):\n                    row = i // cols\n                    col = i % cols\n                    x_offset = (col - 1) * 0.7\n                    y_offset = (0.5 - row) * 0.7\n                    new_pos = buffer_box.get_center() + RIGHT * x_offset + UP * y_offset\n                    self.play(item.animate.move_to(new_pos), run_time=0.3)\n                new_count_text = Text(self.texts['current_size'].format(len(buffer_items)), font_size=24, color=YELLOW, weight=BOLD)\n                new_count_text.move_to(buffer_current_text.get_center())\n                self.play(Transform(buffer_current_text, new_count_text), run_time=0.3)\n                self.play(FadeOut(consumer_status_active), run_time=0.3)\n            self.play(FadeOut(cycle_text), run_time=0.3)\n            self.wait(0.3)\n        end_text = Text(self.texts['end_text'], font_size=40, color=GOLD, weight=BOLD)\n        end_text.to_edge(DOWN, buff=1)\n        self.play(Write(end_text))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate a neural network visualization of the producer-consumer problem, demonstrating data flow, buffer management, and a system upgrade to improve efficiency."}, {"role": "assistant", "content": "from manim import *\nfrom manim_ml.neural_network.layers import FeedForwardLayer\nfrom manim_ml.neural_network.neural_network import NeuralNetwork\nimport random\nimport numpy as np\n\nclass NeuralProducerConsumerBase(Scene):\n    \"\"\"Neural network style Producer-Consumer animation with multiple agents\"\"\"\n\n    def __init__(self, language='en', **kwargs):\n        super().__init__(**kwargs)\n        self.language = language\n        self.setup_translations()\n\n    def setup_translations(self):\n        \"\"\"Set up text translations based on language\"\"\"\n        if self.language == 'tr':\n            self.texts = {'title': '\u00c7oklu \u00dcretici-T\u00fcketici A\u011f\u0131', 'producers': '\u00dcreticiler', 'consumers': 'T\u00fcketiciler', 'buffer_layer': 'Tampon Katman\u0131', 'garbage_collector': '\u00c7\u00f6p Toplay\u0131c\u0131', 'data_flow': 'Veri Ak\u0131\u015f\u0131', 'processing': '\u0130\u015fleniyor...', 'waiting': 'Bekliyor...', 'dropped': 'D\u00fc\u015f\u00fcr\u00fcld\u00fc: {}', 'cycle': 'D\u00f6ng\u00fc {}/10', 'buffer_added': 'Yeni Buffer Eklendi!', 'system_upgraded': 'Sistem G\u00fcncellendi', 'neural_title': 'Sinir A\u011f\u0131 Tarz\u0131nda \u00dcretici-T\u00fcketici Modeli', 'end_text': 'A\u011f Sim\u00fclasyonu Tamamland\u0131!'}\n        else:\n            self.texts = {'title': 'Multi-Producer Consumer Network', 'producers': 'Producers', 'consumers': 'Consumers', 'buffer_layer': 'Buffer Layer', 'garbage_collector': 'Garbage Collector', 'data_flow': 'Data Flow', 'processing': 'Processing...', 'waiting': 'Waiting...', 'dropped': 'Dropped: {}', 'cycle': 'Cycle {}/10', 'buffer_added': 'New Buffer Added!', 'system_upgraded': 'System Upgraded', 'neural_title': 'Neural Network Style Producer-Consumer Model', 'end_text': 'Network Simulation Complete!'}\n\n    def create_neural_network_fallback(self):\n        \"\"\"Create a fallback neural network visualization when manim-ml is not available\"\"\"\n        producer_nodes = []\n        for i in range(4):\n            node = Circle(radius=0.3, color=BLUE, fill_opacity=0.8)\n            node.move_to(LEFT * 5 + UP * (1.5 - i * 1))\n            producer_nodes.append(node)\n        buffer_nodes = []\n        for i in range(4):\n            node = Circle(radius=0.25, color=GREEN, fill_opacity=0.6)\n            node.move_to(UP * (1.5 - i * 1))\n            buffer_nodes.append(node)\n        consumer_nodes = []\n        for i in range(3):\n            node = Circle(radius=0.3, color=RED, fill_opacity=0.8)\n            node.move_to(RIGHT * 5 + UP * (1 - i * 1))\n            consumer_nodes.append(node)\n        connections = []\n        for p_node in producer_nodes:\n            for b_node in buffer_nodes:\n                line = Line(p_node.get_center(), b_node.get_center(), color=GRAY, stroke_width=1, stroke_opacity=0.3)\n                connections.append(line)\n        for b_node in buffer_nodes:\n            for c_node in consumer_nodes:\n                line = Line(b_node.get_center(), c_node.get_center(), color=GRAY, stroke_width=1, stroke_opacity=0.3)\n                connections.append(line)\n        garbage_collector = RoundedRectangle(width=2.5, height=1.5, corner_radius=0.2, color=DARK_GRAY, fill_color=DARK_GRAY, fill_opacity=0.7)\n        garbage_collector.move_to(DOWN * 3)\n        trash_icon = Text('GC', font_size=30, color=WHITE, weight=BOLD)\n        trash_icon.move_to(garbage_collector.get_center())\n        garbage_group = VGroup(garbage_collector, trash_icon)\n        return (producer_nodes, buffer_nodes, consumer_nodes, connections, garbage_group)\n\n    def create_data_packet(self, value, color=PURPLE):\n        \"\"\"Create a data packet visualization\"\"\"\n        packet = Circle(radius=0.25, color=color, fill_opacity=0.9, stroke_width=2)\n        text = Text(str(value), font_size=18, color=WHITE, weight=BOLD)\n        text.move_to(packet.get_center())\n        return VGroup(packet, text)\n\n    def construct(self):\n        self.camera.background_color = '#0f0f0f'\n        title = Text(self.texts['neural_title'], font_size=40, weight=BOLD, color=WHITE)\n        title.to_edge(UP, buff=0.3)\n        lang_text = 'TR | T\u00fcrk\u00e7e' if self.language == 'tr' else 'EN | English'\n        lang_indicator = Text(lang_text, font_size=14, weight=BOLD, color=WHITE)\n        lang_box = RoundedRectangle(width=lang_indicator.width + 0.3, height=lang_indicator.height + 0.15, corner_radius=0.08, color=GOLD, fill_color=GOLD, fill_opacity=0.2, stroke_width=2)\n        lang_group = VGroup(lang_box, lang_indicator).arrange(ORIGIN)\n        lang_group.to_corner(UR, buff=0.2)\n        self.play(Write(title), FadeIn(lang_group))\n        self.wait(1)\n        if MANIM_ML_AVAILABLE:\n            try:\n                input_layer = FeedForwardLayer(4, rectangle_color=BLUE, rectangle_fill_color=BLUE)\n                hidden_layer = FeedForwardLayer(4, rectangle_color=GREEN, rectangle_fill_color=GREEN)\n                output_layer = FeedForwardLayer(3, rectangle_color=RED, rectangle_fill_color=RED)\n                nn = NeuralNetwork([input_layer, hidden_layer, output_layer], layer_spacing=3)\n                nn.move_to(ORIGIN)\n                producer_nodes = input_layer.neurons\n                buffer_nodes = hidden_layer.neurons\n                consumer_nodes = output_layer.neurons\n                connections = nn.connections\n                network_group = VGroup(nn)\n            except Exception as e:\n                print(f'manim-ml error: {e}. Using fallback.')\n                producer_nodes, buffer_nodes, consumer_nodes, connections, garbage_group = self.create_neural_network_fallback()\n                network_group = VGroup(*producer_nodes, *buffer_nodes, *consumer_nodes, *connections)\n        else:\n            producer_nodes, buffer_nodes, consumer_nodes, connections, garbage_group = self.create_neural_network_fallback()\n            network_group = VGroup(*producer_nodes, *buffer_nodes, *consumer_nodes, *connections)\n        if MANIM_ML_AVAILABLE and 'garbage_group' not in locals():\n            garbage_collector = RoundedRectangle(width=2.5, height=1.5, corner_radius=0.2, color=DARK_GRAY, fill_color=DARK_GRAY, fill_opacity=0.7)\n            garbage_collector.move_to(DOWN * 3)\n            trash_icon = Text('GC', font_size=30, color=WHITE, weight=BOLD)\n            trash_icon.move_to(garbage_collector.get_center())\n            garbage_group = VGroup(garbage_collector, trash_icon)\n        producer_label = Text(self.texts['producers'], font_size=24, color=BLUE, weight=BOLD)\n        producer_label.next_to(producer_nodes[0], LEFT, buff=0.5)\n        buffer_label = Text(self.texts['buffer_layer'], font_size=24, color=GREEN, weight=BOLD)\n        buffer_label.next_to(buffer_nodes[1], UP, buff=0.5)\n        consumer_label = Text(self.texts['consumers'], font_size=24, color=RED, weight=BOLD)\n        consumer_label.next_to(consumer_nodes[0], RIGHT, buff=0.5)\n        garbage_label = Text(self.texts['garbage_collector'], font_size=20, color=DARK_GRAY, weight=BOLD)\n        garbage_label.next_to(garbage_group, DOWN, buff=0.3)\n        self.play(Create(network_group), Write(producer_label), Write(buffer_label), Write(consumer_label), Create(garbage_group), Write(garbage_label), run_time=2)\n        self.wait(1)\n        buffer_states = [0] * len(buffer_nodes)\n        buffer_capacity = 1\n        buffer_counts = [0] * len(buffer_nodes)\n        active_packets = []\n        buffer_visual_packets = {}\n        dropped_count = 0\n        dropped_before_upgrade = 0\n        garbage_collector = garbage_group[0]\n        new_buffer_added = False\n        for cycle in range(10):\n            cycle_text = Text(self.texts['cycle'].format(cycle + 1), font_size=24, weight=BOLD, color=GOLD)\n            cycle_text.to_edge(DOWN, buff=0.3)\n            self.play(Write(cycle_text), run_time=0.3)\n            animations = []\n            active_producers = random.sample(range(len(producer_nodes)), k=random.randint(2, 4))\n            active_consumers = []\n            if active_packets and random.random() > 0.3:\n                active_consumers = random.sample(range(len(consumer_nodes)), k=min(len(active_packets), random.randint(1, 3)))\n            producer_packets = []\n            for p_idx in active_producers:\n                data_value = random.randint(10, 99)\n                packet = self.create_data_packet(data_value)\n                packet.move_to(producer_nodes[p_idx].get_center())\n                producer_packets.append((packet, p_idx, data_value))\n                animations.append(Create(packet))\n                animations.append(producer_nodes[p_idx].animate.set_fill(BLUE, opacity=1))\n            packets_to_consume = []\n            for c_idx in active_consumers:\n                if not active_packets:\n                    break\n                available_packets = [(i, packet, b_idx, value) for i, (packet, b_idx, value) in enumerate(active_packets) if buffer_counts[b_idx] > 0]\n                if available_packets:\n                    packet_idx, packet, b_idx, value = random.choice(available_packets)\n                    packets_to_consume.append((c_idx, packet_idx, packet, b_idx, value))\n                    animations.append(consumer_nodes[c_idx].animate.set_fill(RED, opacity=1))\n            if animations:\n                self.play(*animations, run_time=0.3)\n            movement_animations = []\n            for packet, p_idx, value in producer_packets:\n                available_buffers = [i for i, count in enumerate(buffer_counts) if count < buffer_capacity]\n                if available_buffers:\n                    b_idx = random.choice(available_buffers)\n                    if b_idx not in buffer_visual_packets:\n                        buffer_visual_packets[b_idx] = []\n                    target_pos = buffer_nodes[b_idx].get_center()\n                    movement_animations.append(packet.animate.scale(0.7).move_to(target_pos))\n                    buffer_counts[b_idx] += 1\n                    active_packets.append((packet, b_idx, value))\n                    buffer_visual_packets[b_idx].append(packet)\n                else:\n                    movement_animations.append(packet.animate.move_to(garbage_collector.get_center()))\n                    dropped_count += 1\n            packets_to_remove = []\n            for c_idx, packet_idx, packet, b_idx, value in packets_to_consume:\n                movement_animations.append(packet.animate.scale(1 / 0.7).move_to(consumer_nodes[c_idx].get_center()))\n                buffer_counts[b_idx] -= 1\n                packets_to_remove.append(packet_idx)\n                if packet in buffer_visual_packets[b_idx]:\n                    buffer_visual_packets[b_idx].remove(packet)\n            if movement_animations:\n                self.play(*movement_animations, run_time=0.7)\n            fade_animations = []\n            for c_idx, packet_idx, packet, b_idx, value in packets_to_consume:\n                fade_animations.append(FadeOut(packet))\n            for packet, p_idx, value in producer_packets:\n                available_buffers = [i for i, count in enumerate(buffer_counts) if count < buffer_capacity + 1]\n                if not available_buffers:\n                    fade_animations.append(FadeOut(packet))\n            for idx in sorted(packets_to_remove, reverse=True):\n                if idx < len(active_packets):\n                    active_packets.pop(idx)\n            buffer_updates = []\n            for i, node in enumerate(buffer_nodes):\n                new_opacity = 0.6 + 0.4 * buffer_counts[i] / buffer_capacity\n                buffer_updates.append(node.animate.set_fill(GREEN, opacity=new_opacity))\n            reset_animations = []\n            for p_idx in active_producers:\n                reset_animations.append(producer_nodes[p_idx].animate.set_fill(BLUE, opacity=0.8))\n            for c_idx in active_consumers:\n                reset_animations.append(consumer_nodes[c_idx].animate.set_fill(RED, opacity=0.8))\n            all_cleanup = fade_animations + buffer_updates + reset_animations\n            if all_cleanup:\n                self.play(*all_cleanup, run_time=0.3)\n            self.play(FadeOut(cycle_text), run_time=0.3)\n            if cycle == 4 and (not new_buffer_added):\n                self.wait(0.5)\n                upgrade_text = Text(self.texts['system_upgraded'], font_size=32, color=YELLOW, weight=BOLD)\n                upgrade_text.move_to(UP * 3.5)\n                new_buffer = Circle(radius=0.25, color=GREEN, fill_opacity=0.6)\n                new_buffer_pos = DOWN * 2.5\n                new_buffer.move_to(new_buffer_pos)\n                new_producer_connections = []\n                for p_node in producer_nodes:\n                    line = Line(p_node.get_center(), new_buffer.get_center(), color=GRAY, stroke_width=1, stroke_opacity=0.3)\n                    new_producer_connections.append(line)\n                new_consumer_connections = []\n                for c_node in consumer_nodes:\n                    line = Line(new_buffer.get_center(), c_node.get_center(), color=GRAY, stroke_width=1, stroke_opacity=0.3)\n                    new_consumer_connections.append(line)\n                self.play(Write(upgrade_text), Create(new_buffer), *[Create(conn) for conn in new_producer_connections], *[Create(conn) for conn in new_consumer_connections], run_time=2)\n                buffer_added_text = Text(self.texts['buffer_added'], font_size=24, color=GREEN, weight=BOLD)\n                buffer_added_text.next_to(new_buffer, DOWN, buff=0.3)\n                self.play(Write(buffer_added_text), run_time=0.5)\n                buffer_nodes.append(new_buffer)\n                connections.extend(new_producer_connections)\n                connections.extend(new_consumer_connections)\n                buffer_counts.append(0)\n                buffer_visual_packets[len(buffer_nodes) - 1] = []\n                new_buffer_added = True\n                dropped_before_upgrade = dropped_count\n                self.play(buffer_label.animate.next_to(buffer_nodes[2], UP, buff=0.5), run_time=0.5)\n                self.wait(1)\n                self.play(FadeOut(upgrade_text), FadeOut(buffer_added_text), run_time=0.5)\n            self.wait(0.5)\n        remaining_packets = []\n        for b_idx, packets in buffer_visual_packets.items():\n            remaining_packets.extend(packets)\n        if remaining_packets:\n            self.play(*[FadeOut(packet) for packet in remaining_packets], run_time=0.5)\n        if dropped_count > 0:\n            if new_buffer_added:\n                stats_before = Text(f'\u0130lk 5 d\u00f6ng\u00fc: {dropped_before_upgrade} paket d\u00fc\u015f\u00fcr\u00fcld\u00fc' if self.language == 'tr' else f'First 5 cycles: {dropped_before_upgrade} packets dropped', font_size=22, color=ORANGE, weight=BOLD)\n                stats_after = Text(f'Son 5 d\u00f6ng\u00fc: {dropped_count - dropped_before_upgrade} paket d\u00fc\u015f\u00fcr\u00fcld\u00fc' if self.language == 'tr' else f'Last 5 cycles: {dropped_count - dropped_before_upgrade} packets dropped', font_size=22, color=GREEN, weight=BOLD)\n                improvement = Text(f'Buffer eklenerek veri kayb\u0131 azalt\u0131ld\u0131!' if self.language == 'tr' else f'Buffer addition reduced data loss!', font_size=26, color=YELLOW, weight=BOLD)\n                stats_group = VGroup(stats_before, stats_after, improvement).arrange(DOWN, buff=0.3)\n                stats_group.move_to(ORIGIN)\n                self.play(Write(stats_group), run_time=1.5)\n                self.wait(2)\n                self.play(FadeOut(stats_group))\n            else:\n                stats_text = Text(f\"{self.texts['dropped'].format(dropped_count)} packets\", font_size=24, color=ORANGE, weight=BOLD)\n                stats_text.next_to(garbage_group, UP, buff=0.5)\n                self.play(Write(stats_text))\n                self.wait(1)\n                self.play(FadeOut(stats_text))\n        end_text = Text(self.texts['end_text'], font_size=36, color=GOLD, weight=BOLD)\n        end_text.to_edge(DOWN, buff=0.5)\n        for node_group in [producer_nodes, buffer_nodes, consumer_nodes]:\n            for node in node_group:\n                self.play(node.animate.scale(1.2).set_stroke(GOLD, width=3), run_time=0.1)\n                self.play(node.animate.scale(1 / 1.2).set_stroke(node.color, width=1), run_time=0.1)\n        self.play(Write(end_text))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Load fireballs from a text file, display each image with a bounding box and confidence score, and hold each image for a set duration."}, {"role": "assistant", "content": "import os\nfrom pathlib import Path\nimport numpy as np\nfrom manim import *\nfrom skimage import io\n\nclass GoodFireballs(Scene):\n\n    def construct(self):\n        with open(Path('good_fireballs', 'fireballs.txt')) as file:\n            lines = file.readlines()\n            for line in lines:\n                parts = line.strip().split()\n                image = ImageMobject(io.imread(Path('good_fireballs', parts[0])))\n                image.width = 14.3\n                self.add(image)\n                self.wait(10)\n                conf, x0, y0, x1, y1 = map(float, parts[1:])\n                rect = Rectangle(RED_E, (y1 - y0) / 4912 * 9.35, (x1 - x0) / 7360 * 14)\n                rect.move_to(image.get_corner(UL), aligned_edge=UL)\n                rect.shift(x0 / 7360 * 14.3 * RIGHT + y0 / 4912 * 9.5436957 * DOWN)\n                text = Text(f'{conf:.2f}', color=RED_E, font_size=16, weight=BOLD)\n                text.move_to(rect.get_corner(UL))\n                text.shift(0.15 * UP + 0.25 * RIGHT)\n                self.play(Create(rect), Write(text), run_time=2)\n                self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Visualize the process of fireball detection from an image by showing its tiling, discarding irrelevant tiles, highlighting detected tiles, displaying confidence scores, and finally overlaying merged bounding boxes on the original image."}, {"role": "assistant", "content": "import os\nfrom pathlib import Path\nimport numpy as np\nfrom manim import *\nfrom skimage import io\n\nclass FireballDetectionMethodology(Scene):\n\n    def construct(self):\n        image_path = Path('methodology', '57_2016-06-17_182058_S_DSC_1189.thumb.jpg')\n        image_array = io.imread(image_path)\n        main_image = ImageMobject(image_array)\n        main_image.height = 8\n        self.add(main_image)\n        heading_input = Text('7360x4912 Input Image', weight=BOLD, font_size=32)\n        heading_input.move_to(np.array([0, 4.5, 0]))\n        self.play(FadeIn(main_image))\n        self.play(Write(heading_input))\n        self.wait(1)\n        self.play(FadeOut(main_image))\n        main_image.scale_to_fit_height(3.65)\n        self.play(FadeIn(main_image))\n        self.wait(2)\n        heading_tiling = Text('Splitting into 400x400 Tiles with 50% Overlap', weight=BOLD, font_size=32)\n        heading_tiling.move_to(np.array([0, 4.5, 0]))\n        self.play(Transform(heading_input, heading_tiling, replace_mobject_with_target_in_scene=True))\n        self.play(ShrinkToCenter(main_image))\n        coordinates = []\n        with open(Path('methodology', 'coordinates.txt')) as file:\n            lines = file.readlines()\n            for line in lines:\n                parts = line.strip().split()\n                x, y = map(int, parts)\n                coordinates.append((x, y))\n        square_size = 400\n        sub_images = Group()\n        tiles = {}\n        for coord in coordinates:\n            x, y = coord\n            sub_image = ImageMobject(image_array[y:y + square_size, x:x + square_size])\n            sub_image.height = 0.25\n            sub_images.add(sub_image)\n            tiles[coord] = sub_image\n        sub_images.arrange_in_grid(rows=24, cols=36, buff=0.1)\n        sub_images.shift(0.25 * DOWN)\n        self.add(sub_images)\n        self.play(GrowFromCenter(sub_images))\n        self.wait(3)\n        discarded_coordinates = set()\n        with open(Path('methodology', 'discarded.txt')) as file:\n            lines = file.readlines()\n            for line in lines:\n                parts = line.strip().split()\n                x, y = map(int, parts)\n                discarded_coordinates.add((x, y))\n        included_images = []\n        discarded_images = []\n        for coord, image in tiles.items():\n            if coord in discarded_coordinates:\n                discarded_images.append(image)\n            else:\n                included_images.append(image)\n        heading_discard = Text('Discarding Outside Tiles', weight=BOLD, font_size=32)\n        heading_discard.move_to(np.array([0, 4.5, 0]))\n        self.play(Transform(heading_tiling, heading_discard, replace_mobject_with_target_in_scene=True))\n        self.wait(0.5)\n        self.play(*[ShrinkToCenter(mobject, rate_func=rate_functions.ease_in_back) for mobject in discarded_images])\n        for tile in discarded_images:\n            sub_images.remove(tile)\n        self.wait(3)\n        heading_yolo = Text('Detecting with a Custom-Trained YOLOv8 Model', weight=BOLD, font_size=32)\n        heading_yolo.move_to(np.array([0, 4.5, 0]))\n        self.play(Transform(heading_discard, heading_yolo, replace_mobject_with_target_in_scene=True))\n        self.play(*[Circumscribe(mobject, stroke_width=DEFAULT_STROKE_WIDTH / 5, buff=0, run_time=4) for mobject in included_images])\n        self.wait(1)\n        detected_tiles = []\n        with open(Path('methodology', 'detected_tiles.txt')) as file:\n            lines = file.readlines()\n            for line in lines:\n                parts = line.strip().split()\n                x, y = map(int, parts)\n                detected_tiles.append(tiles[x, y])\n        self.play(*[Indicate(mobject) for mobject in detected_tiles])\n        self.wait(1)\n        confidences: list[float] = []\n        tile_predictions: list[Rectangle] = []\n        with open(Path('methodology', 'tile_predictions.txt')) as file:\n            lines = file.readlines()\n            for line in lines:\n                parts = line.strip().split()\n                x, y = map(int, parts[:2])\n                conf = float(parts[2])\n                confidences.append(conf)\n                dim = tuple(map(float, parts[3:]))\n                tile: Mobject = tiles[x, y]\n                rect = Rectangle(RED_E, (dim[3] - dim[1]) / 400 * 0.25, (dim[2] - dim[0]) / 400 * 0.25)\n                rect.set_stroke(width=DEFAULT_STROKE_WIDTH / 3)\n                rect.move_to(tile.get_corner(UL), aligned_edge=UL)\n                rect.shift(dim[0] / 400 * 0.25 * RIGHT + dim[1] / 400 * 0.25 * DOWN)\n                tile_predictions.append(rect)\n        conf_texts = [Text(f'{num:.2f}', font_size=16, color=RED_E) for num in confidences]\n        column = VGroup(*conf_texts).arrange(DOWN, buff=0.1)\n        column.move_to(np.array([-6.6, -0.25, 0]))\n        self.play(*[Create(mobject) for mobject in tile_predictions], run_time=2)\n        self.wait(0.5)\n        self.play(LaggedStart(*[Create(num_text) for num_text in column], lag_ratio=0.5), run_time=2)\n        self.wait(3)\n        heading_convert = Text('Positioning Bounding Boxes on Original Image', weight=BOLD, font_size=32)\n        heading_convert.move_to(np.array([0, 4.5, 0]))\n        sub_images.add(*tile_predictions)\n        self.play(Transform(heading_yolo, heading_convert, replace_mobject_with_target_in_scene=True))\n        self.play(ShrinkToCenter(sub_images))\n        self.remove(sub_images)\n        main_image = ImageMobject(image_array)\n        main_image.height = 3.65\n        self.add(main_image)\n        predictions = Group()\n        with open(Path('methodology', 'tile_predictions.txt')) as file:\n            lines = file.readlines()\n            for line in lines:\n                parts = line.strip().split()\n                x, y = map(int, parts[:2])\n                conf = float(parts[2])\n                dim = tuple(map(float, parts[3:]))\n                rect = Rectangle(RED_E, (dim[3] - dim[1]) / 4912 * main_image.height, (dim[2] - dim[0]) / 7360 * main_image.width)\n                rect.set_stroke(width=DEFAULT_STROKE_WIDTH / 3)\n                rect.move_to(main_image.get_corner(UL), aligned_edge=UL)\n                rect.shift((x + dim[0]) / 7360 * main_image.width * RIGHT + (y + dim[1]) / 4912 * main_image.height * DOWN)\n                predictions.add(rect)\n        self.add(predictions)\n        self.play(GrowFromCenter(main_image), GrowFromPoint(predictions, np.array([0, 0, 0])))\n        self.wait(2)\n        self.play(FadeOut(main_image), FadeOut(predictions))\n        main_image.scale(2.2)\n        main_image.shift(0.25 * DOWN)\n        predictions.scale(2.2, about_point=ORIGIN)\n        predictions.shift(0.25 * DOWN)\n        self.play(FadeIn(main_image), FadeIn(predictions))\n        self.wait(3)\n        with open(Path('methodology', 'fireball.txt')) as file:\n            parts = list(map(float, file.readline().strip().split()))\n            box = Rectangle(RED_E, (parts[4] - parts[2]) / 4912 * main_image.height, (parts[3] - parts[1]) / 7360 * main_image.width)\n            box.move_to(main_image.get_corner(UL), aligned_edge=UL)\n            box.shift(parts[1] / 7360 * main_image.width * RIGHT + parts[2] / 4912 * main_image.height * DOWN)\n        max_text: Text = column[confidences.index(max(confidences))]\n        bold_max_text: Text = Text(max_text.text, font_size=16, color=RED_E, weight=BOLD)\n        bold_max_text.move_to(max_text)\n        self.bring_to_front(max_text)\n\n        def text_transform(o: Mobject):\n            o.move_to(max_text.get_center())\n            o.fade(1)\n            return o\n        heading_merge = Text('Merging Intersecting Bounding Boxes', weight=BOLD, font_size=32)\n        heading_merge.move_to(np.array([0, 4.5, 0]))\n        self.play(Transform(heading_convert, heading_merge, replace_mobject_with_target_in_scene=True))\n        self.wait(0.5)\n        self.play(Transform(max_text, bold_max_text, replace_mobject_with_target_in_scene=True))\n        self.play(Transform(predictions, box, replace_mobject_with_target_in_scene=True), *[ApplyFunction(text_transform, text) for text in column if text != max_text])\n        self.wait(2)\n        heading_final = Text('Final Prediction', weight=BOLD, font_size=32)\n        heading_final.move_to(np.array([0, 4.5, 0]))\n        self.play(bold_max_text.animate.move_to(box.get_corner(UL) + 0.15 * UP + 0.25 * RIGHT).set(run_time=2), Transform(heading_merge, heading_final, replace_mobject_with_target_in_scene=True))\n        self.wait(5)\n        self.play(FadeOut(main_image, box, bold_max_text, heading_final))"}]}
{"messages": [{"role": "user", "content": "Display a sequence of images with corresponding bounding boxes and confidence scores."}, {"role": "assistant", "content": "import os\nfrom pathlib import Path\nimport numpy as np\nfrom manim import *\nfrom skimage import io\n\nclass FireballFails(Scene):\n\n    def construct(self):\n        image_files = [file for file in os.listdir(Path('fireball_fails')) if file.endswith('.jpg')]\n        for image_file in image_files:\n            image = ImageMobject(io.imread(Path('fireball_fails', image_file)))\n            image.width = 14.3\n            self.add(image)\n            self.wait(5)\n            rects = []\n            texts = []\n            with open(Path('fireball_fails', image_file.split('.')[0] + '.txt')) as file:\n                lines = file.readlines()\n                for line in lines:\n                    correct, conf, x0, y0, x1, y1 = map(float, line.strip().split())\n                    colour = GREEN_E if correct else RED_E\n                    rect = Rectangle(colour, (y1 - y0) / 4912 * 9.35, (x1 - x0) / 7360 * 14)\n                    rect.move_to(image.get_corner(UL), aligned_edge=UL)\n                    rect.shift(x0 / 7360 * 14.3 * RIGHT + y0 / 4912 * 9.5436957 * DOWN)\n                    rects.append(rect)\n                    text = Text(f'{conf:.2f}', color=colour, font_size=16, weight=BOLD)\n                    if y0 > 100:\n                        text.move_to(rect.get_corner(UL))\n                        text.shift(0.15 * UP + 0.25 * RIGHT)\n                    else:\n                        text.move_to(rect.get_corner(DL))\n                        text.shift(0.15 * DOWN + 0.25 * RIGHT)\n                    texts.append(text)\n            self.play(*[Create(rect) for rect in rects], *[Write(text) for text in texts], run_time=2)\n            self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Display a flashcard with a graph of frequency-modulated waves and a cheat sheet of different wave types."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nimport os\n\nclass FlashcardLayout(Scene):\n    \"\"\"\n    Gera o flashcard selecionado via FLASHCARD_NUMBER (1-10)\n    \"\"\"\n\n    def construct(self):\n        number = int(os.environ.get('FLASHCARD_NUMBER', 1))\n        data = FLASHCARDS[number]\n        code = data['code']\n        answer = data['answer']\n        config.output_file = f'bilhete_flashcard_{number}'\n        config.media_dir = 'media/bilhete_flashcard'\n        config.save_last_frame = True\n        config.preview = False\n        self.camera.background_color = WHITE\n        title = Text(str(number), font_size=48, color=BLACK)\n        title.to_edge(UL, buff=0.5)\n        axes_width = config.frame_width * 0.85\n        axes_height = config.frame_height * 0.5\n        axes = Axes(x_range=[0, 6, 1], y_range=[-1.5, 1.5, 0.5], x_length=axes_width, y_length=axes_height, axis_config={'include_numbers': False, 'include_tip': False, 'stroke_color': GREY_A, 'stroke_width': 1, 'color': GREY_A}, tips=False)\n        axes.next_to(title, DOWN, buff=0.8)\n        axes.center()\n        axes.to_edge(UP, buff=1.2)\n        x_lines = VGroup(*[Line(axes.c2p(i, -1.5), axes.c2p(i, 1.5), stroke_width=0.5, stroke_color=GREY_C, stroke_opacity=1) for i in np.arange(0, 6.1, 1)])\n        y_lines = VGroup(*[Line(axes.c2p(0, i), axes.c2p(6, i), stroke_width=0.5, stroke_color=GREY_C, stroke_opacity=1) for i in np.arange(-1.5, 1.6, 0.5)])\n        line_styles = [{'stroke_width': 2}, {'stroke_width': 2}, {'stroke_width': 2}, {'stroke_width': 2}, {'stroke_width': 2}, {'stroke_width': 2}]\n        dash_patterns = [None, [0.1, 0.1], [0.2, 0.2], None, [0.3, 0.2, 0.05, 0.2], None]\n        base_freqs = {1: 8.0, 2: 6.0, 3: 4.6, 4: 4.0, 5: 3.0, 6: 2.5}\n        frequencies = [base_freqs[d] for d in code]\n\n        def smooth_transition(x, freq1, freq2, transition_point, width=0.1):\n            sigmoid = 1 / (1 + np.exp(-(x - transition_point) / width))\n            return freq1 * (1 - sigmoid) + freq2 * sigmoid\n\n        def frequency_at_x(x):\n            segment = int(x)\n            if segment >= 6:\n                return frequencies[5]\n            elif segment < 0:\n                return frequencies[0]\n            if segment == 5:\n                return frequencies[5]\n            transition_width = 0.05\n            if x % 1 > 1 - transition_width:\n                return smooth_transition(x, frequencies[segment], frequencies[segment + 1], segment + 1 - transition_width / 2, transition_width)\n            return frequencies[segment]\n\n        def phase_at_x(x, step=0.01):\n            points = np.arange(0, x + step, step)\n            phases = [0]\n            for i in range(1, len(points)):\n                dx = points[i] - points[i - 1]\n                f1 = frequency_at_x(points[i - 1]) * PI\n                f2 = frequency_at_x(points[i]) * PI\n                phases.append(phases[-1] + (f1 + f2) / 2 * dx)\n            return phases[-1]\n\n        def fm_wave(x):\n            return np.sin(phase_at_x(x))\n        segment_plots = VGroup()\n        for i in range(6):\n            wave_type_in_segment = code[i]\n            style_index_for_segment = wave_type_in_segment - 1\n            segment_plot = axes.plot(fm_wave, x_range=[i, i + 1, 0.01], color=BLACK, **line_styles[style_index_for_segment])\n            if dash_patterns[style_index_for_segment] is not None:\n                segment_plot.set_dash_pattern(dash_patterns[style_index_for_segment])\n            segment_plots.add(segment_plot)\n        one_segment_screen_width = axes_width / 6.0\n        cheat_sheet_wave_types_ordered = [1, 2, 3, 4, 5, 6]\n        wave_internal_padding = 0.05\n        drawable_mini_wave_width = one_segment_screen_width - 2 * wave_internal_padding\n        new_bg_width = one_segment_screen_width\n        cheat_sheet_entries = VGroup()\n        gap_between_items = 0.2\n        total_width_of_all_items_and_gaps = 6 * new_bg_width + 5 * gap_between_items\n        start_x_position = -total_width_of_all_items_and_gaps / 2.0 + new_bg_width / 2.0\n        current_x_position = start_x_position\n        for cheat_wave_type in cheat_sheet_wave_types_ordered:\n            entry = VGroup()\n            style_index_for_cheat_item = cheat_wave_type - 1\n            bg = Rectangle(width=new_bg_width, height=1.6, stroke_color=BLACK, stroke_width=1, fill_opacity=0)\n            bg.move_to(RIGHT * current_x_position + DOWN * 3.5)\n            number = Text(f'{cheat_wave_type}', font_size=20, color=BLACK)\n            number.move_to(bg.get_top() + DOWN * 0.3)\n            current_mini_freq_val = base_freqs[cheat_wave_type]\n            freq_text = Text(f'{current_mini_freq_val:.1f} Hz', font_size=14, color=BLACK)\n            freq_text.move_to(bg.get_bottom() + UP * 0.2)\n            mini_wave = VMobject()\n            t_local_mini = np.linspace(0, 1, 100)\n            y_vals_mini = [np.sin(x_l * current_mini_freq_val * PI) for x_l in t_local_mini]\n            wave_y_center_mini = bg.get_center()[1]\n            x_center_bg = bg.get_center()[0]\n            x0_mini = x_center_bg - drawable_mini_wave_width / 2\n            x1_mini = x_center_bg + drawable_mini_wave_width / 2\n            wave_points_mini = []\n            y_min_val_mini = -1\n            y_max_val_mini = 1\n            for idx_mini, x_local_val_mini in enumerate(t_local_mini):\n                x_screen = x0_mini + (x1_mini - x0_mini) * x_local_val_mini\n                current_y_val_mini = y_vals_mini[idx_mini]\n                y_norm_factor_mini = (current_y_val_mini - y_min_val_mini) / (y_max_val_mini - y_min_val_mini)\n                y_screen = wave_y_center_mini + (y_norm_factor_mini - 0.5) * (bg.height * 0.4)\n                wave_points_mini.append([x_screen, y_screen, 0])\n            if wave_points_mini:\n                mini_wave.set_points_as_corners(wave_points_mini)\n            mini_wave.set_stroke(width=line_styles[style_index_for_cheat_item]['stroke_width'], color=BLACK)\n            if dash_patterns[style_index_for_cheat_item] is not None:\n                mini_wave.set_dash_pattern(dash_patterns[style_index_for_cheat_item])\n            entry.add(bg, number, mini_wave, freq_text)\n            cheat_sheet_entries.add(entry)\n            current_x_position += new_bg_width + gap_between_items\n        self.add(title)\n        self.add(axes)\n        self.add(x_lines, y_lines)\n        self.add(segment_plots)\n        self.add(cheat_sheet_entries)\n        answer_str = ''.join(map(str, code))\n        answer_text = Text(answer_str, font_size=24, color=GREY_D)\n        answer_text.scale(0.5)\n        answer_text.to_edge(UR, buff=0.25)\n        self.add(answer_text)\n        frame_rect = Rectangle(width=config.frame_width * 0.98, height=config.frame_height * 0.98, stroke_color=BLACK, stroke_width=0.5)\n        self.add(frame_rect)"}]}
{"messages": [{"role": "user", "content": "Create a flashcard layout with a title, a segmented sine wave plot, and a cheat sheet displaying segment frequencies and mini sine waves."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\n\nclass FlashcardLayout(Scene):\n    \"\"\"\n    Generates a static layout for a flashcard with a title,\n    segmented sine wave plot in a grid, and a cheat sheet.\n    \"\"\"\n\n    def construct(self):\n        self.camera.background_color = WHITE\n        title = Text('Bilhete 1/4', font_size=48, color=BLACK)\n        title.to_edge(UL, buff=0.5)\n        axes_width = config.frame_width * 0.85\n        axes_height = config.frame_height * 0.5\n        axes = Axes(x_range=[0, 6, 1], y_range=[-1.5, 1.5, 0.5], x_length=axes_width, y_length=axes_height, axis_config={'include_numbers': False, 'include_tip': False, 'stroke_color': GREY_A, 'stroke_width': 1, 'color': GREY_A}, tips=False)\n        axes.next_to(title, DOWN, buff=0.8)\n        axes.center()\n        axes.to_edge(UP, buff=1.2)\n        x_lines = VGroup(*[Line(axes.c2p(i, -1.5), axes.c2p(i, 1.5), stroke_width=0.5, stroke_color=GREY_C, stroke_opacity=1) for i in np.arange(0, 6.1, 1)])\n        y_lines = VGroup(*[Line(axes.c2p(0, i), axes.c2p(6, i), stroke_width=0.5, stroke_color=GREY_C, stroke_opacity=1) for i in np.arange(-1.5, 1.6, 0.5)])\n        line_styles = [{'stroke_width': 2}, {'stroke_width': 2}, {'stroke_width': 2}, {'stroke_width': 3}, {'stroke_width': 2}, {'stroke_width': 1.5}]\n        dash_patterns = [None, [0.2, 0.2], [0.1, 0.1], None, [0.3, 0.2, 0.05, 0.2], None]\n        frequencies = [1.5, 3.6, 5.0, 2.0, 6.0, 3.0]\n\n        def smooth_transition(x, freq1, freq2, transition_point, width=0.1):\n            \"\"\"Cria uma transi\u00e7\u00e3o suave entre freq1 e freq2 usando uma fun\u00e7\u00e3o sigmoid\"\"\"\n            sigmoid = 1 / (1 + np.exp(-(x - transition_point) / width))\n            return freq1 * (1 - sigmoid) + freq2 * sigmoid\n\n        def frequency_at_x(x):\n            \"\"\"Retorna a frequ\u00eancia em qualquer ponto x, com transi\u00e7\u00f5es suaves\"\"\"\n            segment = int(x)\n            if segment >= 6:\n                return frequencies[5]\n            elif segment < 0:\n                return frequencies[0]\n            if segment == 5:\n                return frequencies[5]\n            transition_width = 0.05\n            if x % 1 > 1 - transition_width:\n                return smooth_transition(x, frequencies[segment], frequencies[segment + 1], segment + 1 - transition_width / 2, transition_width)\n            return frequencies[segment]\n\n        def phase_at_x(x, step=0.01):\n            \"\"\"Calcula a fase em x integrando numericamente a frequ\u00eancia\"\"\"\n            points = np.arange(0, x + step, step)\n            phases = [0]\n            for i in range(1, len(points)):\n                dx = points[i] - points[i - 1]\n                f1 = frequency_at_x(points[i - 1]) * PI\n                f2 = frequency_at_x(points[i]) * PI\n                phases.append(phases[-1] + (f1 + f2) / 2 * dx)\n            return phases[-1]\n\n        def fm_wave(x):\n            \"\"\"Calcula o valor da onda modulada em frequ\u00eancia em um ponto x\"\"\"\n            return np.sin(phase_at_x(x))\n        fm_plot = axes.plot(fm_wave, x_range=[0, 6, 0.01], color=BLACK, stroke_width=2)\n        segment_plots = VGroup()\n        for i in range(6):\n            segment_plot = axes.plot(fm_wave, x_range=[i, i + 1, 0.01], color=BLACK, **line_styles[i])\n            if dash_patterns[i] is not None:\n                segment_plot.set_dash_pattern(dash_patterns[i])\n            segment_plots.add(segment_plot)\n        cheat_sheet_entries = VGroup()\n        for i in range(6):\n            entry = VGroup()\n            bg = Rectangle(width=2.2, height=1.4, stroke_color=BLACK, stroke_width=1, fill_opacity=0)\n            number = Text(f'{i + 1}', font_size=20, color=BLACK)\n            number.move_to(bg.get_corner(UL) + RIGHT * 0.3 + DOWN * 0.3)\n            freq_text = Text(f'{frequencies[i]:.1f}\u03c0 Hz', font_size=14, color=BLACK)\n            freq_text.move_to(bg.get_bottom() + UP * 0.2)\n            mini_wave = VMobject()\n            t = np.linspace(0, 1, 100)\n            wave_points = []\n            wave_y_center = bg.get_center()[1] + 0.1\n            for ti in t:\n                x = bg.get_left()[0] + 0.2 + ti * 1.8\n                y = wave_y_center + 0.3 * np.sin(frequencies[i] * PI * ti * 3)\n                wave_points.append([x, y, 0])\n            mini_wave.set_points_as_corners(wave_points)\n            mini_wave.set_stroke(width=line_styles[i]['stroke_width'], color=BLACK)\n            if dash_patterns[i] is not None:\n                mini_wave.set_dash_pattern(dash_patterns[i])\n            entry.add(bg, number, mini_wave, freq_text)\n            entry.shift(RIGHT * (i * 2.6 - 6.5))\n            entry.shift(DOWN * 3.5)\n            cheat_sheet_entries.add(entry)\n        self.add(title)\n        self.add(axes)\n        self.add(x_lines, y_lines)\n        self.add(segment_plots)\n        self.add(cheat_sheet_entries)\n        frame_rect = Rectangle(width=config.frame_width * 0.98, height=config.frame_height * 0.98, stroke_color=BLACK, stroke_width=0.5)\n        self.add(frame_rect)"}]}
{"messages": [{"role": "user", "content": "Display a flashcard with a title, axes, grid lines, and a cheat sheet of different waves, then animate the creation of six distinct wave segments on the axes and play a waiting animation."}, {"role": "assistant", "content": "from manim import Scene, Text, Rectangle, Axes, VGroup, Line, VMobject, WHITE, BLACK, GREY_A, GREY_C, GREY_D, UP, DOWN, RIGHT, UL, UR, Create, linear, PI\nfrom manim import config\nimport numpy as np\n\nclass FlashcardAnimation(Scene):\n    \"\"\"\n    Anima\u00e7\u00e3o do flashcard 1, com c\u00f3digo 152314 (usando l\u00f3gica e estilos do bilhete_flashcard.py)\n    \"\"\"\n\n    def construct(self):\n        self.camera.background_color = WHITE\n        title = Text('Bilhete 1/4', font_size=48, color=BLACK)\n        title.to_edge(UL, buff=0.5)\n        axes_width = config.frame_width * 0.85\n        axes_height = config.frame_height * 0.5\n        axes = Axes(x_range=[0, 6, 1], y_range=[-1.5, 1.5, 0.5], x_length=axes_width, y_length=axes_height, axis_config={'include_numbers': False, 'include_tip': False, 'stroke_color': GREY_A, 'stroke_width': 1, 'color': GREY_A}, tips=False)\n        axes.next_to(title, DOWN, buff=0.8)\n        axes.center()\n        axes.to_edge(UP, buff=1.2)\n        x_lines = VGroup(*[Line(axes.c2p(i, -1.5), axes.c2p(i, 1.5), stroke_width=0.5, stroke_color=GREY_C, stroke_opacity=1) for i in np.arange(0, 6.1, 1)])\n        y_lines = VGroup(*[Line(axes.c2p(0, i), axes.c2p(6, i), stroke_width=0.5, stroke_color=GREY_C, stroke_opacity=1) for i in np.arange(-1.5, 1.6, 0.5)])\n        frame_rect = Rectangle(width=config.frame_width * 0.98, height=config.frame_height * 0.98, stroke_color=BLACK, stroke_width=0.5)\n        line_styles = [{'stroke_width': 2}, {'stroke_width': 2}, {'stroke_width': 2}, {'stroke_width': 2}, {'stroke_width': 2}, {'stroke_width': 2}]\n        dash_patterns = [None, [0.1, 0.1], [0.2, 0.2], None, [0.3, 0.2, 0.05, 0.2], None]\n        base_freqs = {1: 8.0, 2: 6.0, 3: 4.6, 4: 4.0, 5: 3.0, 6: 2.5}\n        code = FLASHCARDS[1]['code']\n        frequencies = [base_freqs[d] for d in code]\n\n        def smooth_transition(x, freq1, freq2, transition_point, width=0.1):\n            sigmoid = 1 / (1 + np.exp(-(x - transition_point) / width))\n            return freq1 * (1 - sigmoid) + freq2 * sigmoid\n\n        def frequency_at_x(x):\n            segment = int(x)\n            if segment >= 6:\n                return frequencies[5]\n            elif segment < 0:\n                return frequencies[0]\n            if segment == 5:\n                return frequencies[5]\n            transition_width = 0.05\n            if x % 1 > 1 - transition_width:\n                return smooth_transition(x, frequencies[segment], frequencies[segment + 1], segment + 1 - transition_width / 2, transition_width)\n            return frequencies[segment]\n\n        def phase_at_x(x, step=0.01):\n            points = np.arange(0, x + step, step)\n            phases = [0]\n            for i in range(1, len(points)):\n                dx = points[i] - points[i - 1]\n                f1 = frequency_at_x(points[i - 1]) * PI\n                f2 = frequency_at_x(points[i]) * PI\n                phases.append(phases[-1] + (f1 + f2) / 2 * dx)\n            return phases[-1]\n\n        def fm_wave(x):\n            return np.sin(phase_at_x(x))\n        segment_plots = []\n        for i in range(6):\n            wave_type_in_segment = code[i]\n            style_index_for_segment = wave_type_in_segment - 1\n            segment_plot = axes.plot(fm_wave, x_range=[i, i + 1, 0.01], color=BLACK, **line_styles[style_index_for_segment])\n            if dash_patterns[style_index_for_segment] is not None:\n                segment_plot.set_dash_pattern(dash_patterns[style_index_for_segment])\n            segment_plots.append(segment_plot)\n        one_segment_screen_width = axes_width / 6.0\n        cheat_sheet_wave_types_ordered = [1, 2, 3, 4, 5, 6]\n        wave_internal_padding = 0.05\n        drawable_mini_wave_width = one_segment_screen_width - 2 * wave_internal_padding\n        new_bg_width = one_segment_screen_width\n        cheat_sheet_entries = VGroup()\n        gap_between_items = 0.2\n        total_width_of_all_items_and_gaps = 6 * new_bg_width + 5 * gap_between_items\n        start_x_position = -total_width_of_all_items_and_gaps / 2.0 + new_bg_width / 2.0\n        current_x_position = start_x_position\n        mini_waves = VGroup()\n        for cheat_wave_type in cheat_sheet_wave_types_ordered:\n            entry = VGroup()\n            style_index_for_cheat_item = cheat_wave_type - 1\n            bg = Rectangle(width=new_bg_width, height=1.6, stroke_color=BLACK, stroke_width=1, fill_opacity=0)\n            bg.move_to(RIGHT * current_x_position + DOWN * 3.5)\n            number = Text(f'{cheat_wave_type}', font_size=20, color=BLACK)\n            number.move_to(bg.get_top() + DOWN * 0.3)\n            current_mini_freq_val = base_freqs[cheat_wave_type]\n            freq_text = Text(f'{current_mini_freq_val:.1f} Hz', font_size=14, color=BLACK)\n            freq_text.move_to(bg.get_bottom() + UP * 0.2)\n            mini_wave = VMobject()\n            t_local_mini = np.linspace(0, 1, 100)\n            y_vals_mini = [np.sin(x_l * current_mini_freq_val * PI) for x_l in t_local_mini]\n            wave_y_center_mini = bg.get_center()[1]\n            x_center_bg = bg.get_center()[0]\n            x0_mini = x_center_bg - drawable_mini_wave_width / 2\n            x1_mini = x_center_bg + drawable_mini_wave_width / 2\n            wave_points_mini = []\n            y_min_val_mini = -1\n            y_max_val_mini = 1\n            for idx_mini, x_local_val_mini in enumerate(t_local_mini):\n                x_screen = x0_mini + (x1_mini - x0_mini) * x_local_val_mini\n                current_y_val_mini = y_vals_mini[idx_mini]\n                y_norm_factor_mini = (current_y_val_mini - y_min_val_mini) / (y_max_val_mini - y_min_val_mini)\n                y_screen = wave_y_center_mini + (y_norm_factor_mini - 0.5) * (bg.height * 0.4)\n                wave_points_mini.append([x_screen, y_screen, 0])\n            if wave_points_mini:\n                mini_wave.set_points_as_corners(wave_points_mini)\n            mini_wave.set_stroke(width=line_styles[style_index_for_cheat_item]['stroke_width'], color=BLACK)\n            if dash_patterns[style_index_for_cheat_item] is not None:\n                mini_wave.set_dash_pattern(dash_patterns[style_index_for_cheat_item])\n            entry.add(bg, number, mini_wave, freq_text)\n            cheat_sheet_entries.add(entry)\n            mini_waves.add(mini_wave)\n            current_x_position += new_bg_width + gap_between_items\n\n        def create_wave_animation(wave_mob, freq):\n\n            def wave_updater(mob):\n                t = self.renderer.time * 2\n                original_points = mob.get_points_defining_boundary()\n                if len(original_points) == 0:\n                    return\n                x_min = min((p[0] for p in original_points))\n                x_max = max((p[0] for p in original_points))\n                y_center = mob.get_center()[1]\n                points = np.linspace(0, 1, 100)\n                wave_points = []\n                for p in points:\n                    x = x_min + p * (x_max - x_min)\n                    y = y_center + 0.3 * np.sin(freq * PI * p + t * freq)\n                    wave_points.append([x, y, 0])\n                mob.set_points_as_corners(wave_points)\n            return wave_updater\n        self.add(title)\n        self.add(axes)\n        self.add(x_lines, y_lines)\n        self.add(cheat_sheet_entries)\n        self.add(frame_rect)\n        for i, wave in enumerate(mini_waves):\n            freq = base_freqs[cheat_sheet_wave_types_ordered[i]]\n            wave.add_updater(create_wave_animation(wave, freq))\n        segment_time = 5 / 6\n        for i, segment in enumerate(segment_plots):\n            self.play(Create(segment), run_time=segment_time, rate_func=linear)\n        self.wait(5)\n        for wave in mini_waves:\n            wave.clear_updaters()"}]}
{"messages": [{"role": "user", "content": "Create an animation depicting a series of colored circles interacting with a moving dot, followed by a rhythm game simulation with falling colored notes."}, {"role": "assistant", "content": "from manim import *\n\nclass Index(Scene):\n\n    def construct(self):\n        congthuc = Dot(color=YELLOW)\n        self.play(FadeIn(congthuc))\n        circle1 = Circle(radius=0.6, color=WHITE).shift(LEFT * 3 + UP * 3).set_fill(PINK, opacity=0.5)\n        circle2 = Circle(radius=0.6, color=WHITE).shift(RIGHT * 2 + UP * 2).set_fill(PINK, opacity=0.5)\n        circle3 = Circle(radius=0.6, color=WHITE).shift(LEFT * 3 + UP * 1).set_fill(PINK, opacity=0.5)\n        circle4 = Circle(radius=0.6, color=WHITE).shift(RIGHT * 2).set_fill(PINK, opacity=0.5)\n        circle5 = Circle(radius=0.6, color=WHITE).shift(LEFT * 3 + DOWN * 1).set_fill(PINK, opacity=0.5)\n        circle6 = Circle(radius=0.6, color=WHITE).shift(RIGHT * 2 + DOWN * 2).set_fill(PINK, opacity=0.5)\n        self.play(FadeIn(circle1, circle2, circle3, circle4, circle5, circle6))\n        self.play(congthuc.animate.move_to(circle1, LEFT + RIGHT + UP + DOWN), run_time=0.5)\n        self.play(congthuc.animate.move_to(circle2, LEFT + RIGHT + UP + DOWN), circle1.animate.set_fill(BLUE, opacity=0.5), run_time=0.5)\n        self.play(congthuc.animate.move_to(circle3, LEFT + RIGHT + UP + DOWN), circle2.animate.set_fill(BLUE, opacity=0.5), run_time=0.5)\n        self.play(congthuc.animate.move_to(circle4, LEFT + RIGHT + UP + DOWN), circle3.animate.set_fill(BLUE, opacity=0.5), run_time=0.5)\n        self.play(congthuc.animate.move_to(circle5, LEFT + RIGHT + UP + DOWN), circle4.animate.set_fill(BLUE, opacity=0.5), run_time=0.5)\n        self.play(congthuc.animate.move_to(circle6, LEFT + RIGHT + UP + DOWN), circle5.animate.set_fill(BLUE, opacity=0.5), run_time=0.5)\n        self.play(circle6.animate.set_fill(BLUE, opacity=0.5), run_time=0.5)\n        self.play(FadeOut(congthuc))\n        catch = Group(Rectangle(width=1.5, height=0.1), Rectangle(width=0.85, height=0.05).shift(DOWN * 0.1)).shift(DOWN * (4 - 0.15) + LEFT * 8)\n        self.play(FadeIn(catch))\n        self.play(catch.animate.shift(RIGHT * 10))\n        self.wait(0.5)\n        self.play(circle6.animate.shift(DOWN * 5), run_time=1)\n        self.play(catch.animate.shift(LEFT * 5))\n        self.wait(0.5)\n        self.play(circle5.animate.shift(DOWN * 6), run_time=1)\n        self.play(catch.animate.shift(RIGHT * 5))\n        self.wait(0.5)\n        self.play(circle4.animate.shift(DOWN * 6), run_time=1)\n        self.play(catch.animate.shift(LEFT * 5))\n        self.wait(0.5)\n        self.play(circle3.animate.shift(DOWN * 7), run_time=1)\n        self.play(catch.animate.shift(RIGHT * 5))\n        self.wait(0.5)\n        self.play(circle2.animate.shift(DOWN * 7), run_time=1)\n        self.play(catch.animate.shift(LEFT * 5))\n        self.wait(0.5)\n        self.play(circle1.animate.shift(DOWN * 8), run_time=1)\n        self.wait(0.5)\n        self.play(catch.animate.shift(RIGHT * 11))\n        self.wait(3)\n        line2 = Line([-12, 0, 0], [12, 0, 0]).shift(UP * 3)\n        line3 = Line([-12, 0, 0], [12, 0, 0]).shift(UP * 1)\n        clickcircle = Circle(radius=0.7, color=GRAY).shift(UP * 2 + LEFT * 5)\n        self.play(Create(line2), Create(line3), FadeIn(clickcircle))\n        taiko1 = Circle(radius=0.7, color=WHITE).shift(UP * 2 + RIGHT * 12).set_fill(RED, opacity=1)\n        taiko2 = Circle(radius=0.5, color=WHITE).shift(UP * 2 + RIGHT * 12).set_fill(RED, opacity=1)\n        taiko3 = Circle(radius=0.5, color=WHITE).shift(UP * 2 + RIGHT * 12).set_fill(BLUE, opacity=1)\n        taiko4 = Circle(radius=0.5, color=WHITE).shift(UP * 2 + RIGHT * 12).set_fill(RED, opacity=1)\n        taiko5 = Circle(radius=0.7, color=WHITE).shift(UP * 2 + RIGHT * 12).set_fill(BLUE, opacity=1)\n        taiko6 = Circle(radius=0.7, color=WHITE).shift(UP * 2 + RIGHT * 12).set_fill(BLUE, opacity=1)\n        self.play(FadeIn(taiko1, taiko2, taiko3, taiko4, taiko5, taiko6))\n        self.play(taiko1.animate.shift(LEFT * 17))\n        self.play(clickcircle.animate.set_fill(RED, opacity=0.4), run_time=0.1)\n        self.play(taiko1.animate.shift(UP * 7), run_time=0.3)\n        self.play(clickcircle.animate.set_fill(RED, opacity=0), run_time=0.1)\n        self.play(taiko2.animate.shift(LEFT * 17))\n        self.play(clickcircle.animate.set_fill(RED, opacity=0.4), run_time=0.1)\n        self.play(taiko2.animate.shift(UP * 7), run_time=0.3)\n        self.play(clickcircle.animate.set_fill(RED, opacity=0), run_time=0.1)\n        self.play(taiko3.animate.shift(LEFT * 17))\n        self.play(clickcircle.animate.set_fill(BLUE, opacity=0.4), run_time=0.1)\n        self.play(taiko3.animate.shift(UP * 7), run_time=0.3)\n        self.play(clickcircle.animate.set_fill(BLUE, opacity=0), run_time=0.1)\n        self.play(taiko4.animate.shift(LEFT * 17))\n        self.play(clickcircle.animate.set_fill(RED, opacity=0.4), run_time=0.1)\n        self.play(taiko4.animate.shift(UP * 7), run_time=0.3)\n        self.play(clickcircle.animate.set_fill(RED, opacity=0), run_time=0.1)\n        self.play(taiko5.animate.shift(LEFT * 17))\n        self.play(clickcircle.animate.set_fill(BLUE, opacity=0.4), run_time=0.1)\n        self.play(taiko5.animate.shift(UP * 7), run_time=0.3)\n        self.play(clickcircle.animate.set_fill(BLUE, opacity=0), run_time=0.1)\n        self.play(taiko6.animate.shift(LEFT * 17))\n        self.play(clickcircle.animate.set_fill(BLUE_D, opacity=0.4), run_time=0.1)\n        self.play(taiko6.animate.shift(UP * 7), run_time=0.3)\n        self.play(clickcircle.animate.set_fill(BLUE, opacity=0), run_time=0.1)\n        self.wait(1)\n        self.play(FadeOut(clickcircle, line2, line3))\n        self.wait(3)\n        mania1 = Rectangle(width=1, height=0.35).set_fill(PINK, 0.7).shift(UP * 7 + RIGHT * 3)\n        mania2 = Rectangle(width=1, height=0.35).set_fill(WHITE, 0.7).shift(UP * 7 + RIGHT * 2)\n        mania3 = Rectangle(width=1, height=0.35).set_fill(PINK, 0.7).shift(UP * 7 + RIGHT)\n        mania4 = Rectangle(width=1, height=0.35).set_fill(PINK, 0.7).shift(UP * 7 + LEFT)\n        mania5 = Rectangle(width=1, height=0.35).set_fill(PINK, 0.7).shift(UP * 7 + 3 * LEFT)\n        mania6 = Rectangle(width=1, height=0.35).set_fill(YELLOW, 0.7).shift(UP * 7)\n        mania7 = Rectangle(width=1, height=0.35).set_fill(WHITE, 0.7).shift(UP * 7 + RIGHT * 2)\n        mania8 = Rectangle(width=1, height=0.35).set_fill(PINK, 0.7).shift(UP * 7 + RIGHT)\n        mania9 = Rectangle(width=1, height=0.35).set_fill(YELLOW, 0.7).shift(UP * 7)\n        mania10 = Rectangle(width=1, height=0.35).set_fill(PINK, 0.7).shift(UP * 7 + RIGHT * 3)\n        mania11 = Rectangle(width=1, height=0.35).set_fill(WHITE, 0.7).shift(UP * 7 + 2 * LEFT)\n        mania12 = Rectangle(width=1, height=0.35).set_fill(PINK, 0.7).shift(UP * 7 + 3 * LEFT)\n        mania13 = Rectangle(width=1, height=0.35).set_fill(PINK, 0.7).shift(UP * 7 + RIGHT)\n        mania14 = Rectangle(width=1, height=0.35).set_fill(WHITE, 0.7).shift(UP * 7 + 2 * LEFT)\n        maniaclick1 = Rectangle(width=1, height=2).set_fill(PINK, 1).shift(DOWN * 7)\n        maniaclick2 = Rectangle(width=1, height=2).set_fill(WHITE, 1).shift(DOWN * 7)\n        maniaclick3 = Rectangle(width=1, height=2).set_fill(PINK, 1).shift(DOWN * 7)\n        maniaclick4 = Rectangle(width=1, height=2).set_fill(YELLOW, 1).shift(DOWN * 7)\n        maniaclick5 = Rectangle(width=1, height=2).set_fill(PINK, 1).shift(DOWN * 7)\n        maniaclick6 = Rectangle(width=1, height=2).set_fill(WHITE, 1).shift(DOWN * 7)\n        maniaclick7 = Rectangle(width=1, height=2).set_fill(PINK, 1).shift(DOWN * 7)\n        line4 = Line([0, 10, 0], [0, -10, 0]).shift(LEFT * 3.5)\n        line5 = Line([0, 10, 0], [0, -10, 0]).shift(RIGHT * 3.5)\n        image = gradientWhiteColor(256).rotate(-PI / 2)\n        image.width = 3\n        image.height = 1\n        light1 = image.copy().shift(DOWN * 2.5 + LEFT * 3)\n        light2 = image.copy().shift(DOWN * 2.5 + LEFT * 2)\n        light3 = image.copy().shift(DOWN * 2.5 + LEFT * 1)\n        light4 = image.copy().shift(DOWN * 2.5)\n        light5 = image.copy().shift(DOWN * 2.5 + RIGHT * 1)\n        light6 = image.copy().shift(DOWN * 2.5 + RIGHT * 2)\n        light7 = image.copy().shift(DOWN * 2.5 + RIGHT * 3)\n        self.play(FadeIn(maniaclick1, maniaclick2, maniaclick3, maniaclick4, maniaclick5, maniaclick6, maniaclick7))\n        self.play(maniaclick1.animate.shift(UP * 3), maniaclick2.animate.shift(UP * 3), maniaclick3.animate.shift(UP * 3), maniaclick4.animate.shift(UP * 3), maniaclick5.animate.shift(UP * 3), maniaclick6.animate.shift(UP * 3), maniaclick7.animate.shift(UP * 3))\n        self.play(maniaclick1.animate.shift(LEFT * 3), maniaclick2.animate.shift(LEFT * 2), maniaclick3.animate.shift(LEFT), maniaclick5.animate.shift(RIGHT), maniaclick6.animate.shift(RIGHT * 2), maniaclick7.animate.shift(RIGHT * 3))\n        self.play(Create(line4), Create(line5))\n        self.play(mania1.animate.next_to(maniaclick7, DOWN), FadeIn(light7), run_time=0.5)\n        self.play(mania2.animate.next_to(maniaclick6, DOWN), FadeIn(light6), FadeOut(light7), run_time=0.5)\n        self.play(mania3.animate.next_to(maniaclick5, DOWN), FadeIn(light5), FadeOut(light6), run_time=0.5)\n        self.play(mania4.animate.next_to(maniaclick3, DOWN), FadeIn(light3), FadeOut(light5), run_time=0.5)\n        self.play(mania5.animate.next_to(maniaclick1, DOWN), FadeIn(light1), FadeOut(light3), run_time=0.5)\n        self.play(mania6.animate.next_to(maniaclick4, DOWN), FadeIn(light4), FadeOut(light1), run_time=0.5)\n        self.play(mania7.animate.next_to(maniaclick6, DOWN), FadeIn(light6), FadeOut(light4), run_time=0.5)\n        self.play(mania8.animate.next_to(maniaclick5, DOWN), FadeIn(light5), FadeOut(light6), run_time=0.5)\n        self.play(mania9.animate.next_to(maniaclick4, DOWN), FadeIn(light4), FadeOut(light5), run_time=0.5)\n        self.play(mania10.animate.next_to(maniaclick7, DOWN), FadeIn(light7), FadeOut(light4), run_time=0.5)\n        self.play(mania11.animate.next_to(maniaclick2, DOWN), FadeIn(light2), FadeOut(light7), run_time=0.5)\n        self.play(mania12.animate.next_to(maniaclick1, DOWN), FadeIn(light1), FadeOut(light2), run_time=0.5)\n        self.play(mania13.animate.next_to(maniaclick5, DOWN), FadeIn(light5), FadeOut(light1), run_time=0.5)\n        self.play(mania14.animate.next_to(maniaclick2, DOWN), FadeIn(light2), FadeOut(light5), run_time=0.5)\n        self.play(FadeOut(light2), run_time=0.5)\n        self.wait(2)\n        self.play(FadeOut(line4, line5))\n        self.play(maniaclick1.animate.shift(RIGHT * 3), maniaclick2.animate.shift(RIGHT * 2), maniaclick3.animate.shift(RIGHT), maniaclick5.animate.shift(LEFT), maniaclick6.animate.shift(LEFT * 2), maniaclick7.animate.shift(LEFT * 3))\n        self.play(maniaclick1.animate.shift(DOWN * 3), maniaclick2.animate.shift(DOWN * 3), maniaclick3.animate.shift(DOWN * 3), maniaclick4.animate.shift(DOWN * 3), maniaclick5.animate.shift(DOWN * 3), maniaclick6.animate.shift(DOWN * 3), maniaclick7.animate.shift(DOWN * 3))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Display a line graph of amounts over time with labeled axes and a number line indicating dates."}, {"role": "assistant", "content": "from manim import *\n\nclass Chart(Scene):\n\n    def construct(self):\n        Text.set_default(font_size=20)\n        axes = Axes(x_range=[1, 800, 79], y_range=[0, 1248539, 124853], axis_config={'include_tip': False}, y_axis_config={'include_numbers': True, 'font_size': 20})\n        labels = axes.get_axis_labels(x_label='Days', y_label='Amount').set_color(MAROON)\n        line_graph = axes.plot_line_graph(x_values=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 33, 34, 35, 36, 37, 38, 39, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 450, 451, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 550, 551, 552, 553, 554, 555, 558, 559, 560, 562, 563, 565, 566, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 622, 623, 624, 625, 627, 629, 634, 635, 636, 637, 639, 640, 641, 642, 643, 644, 645, 646, 648, 649, 650, 652, 653, 654, 655, 656, 659, 670, 671, 672, 674, 675, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 692, 694, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 725, 726, 727, 728, 729, 730, 731, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800], y_values=[2891, 6790, 7164, 5884, 166986, 104860, 74210, 47118, 2319, 45467, 25848, 77395, 27846, 11207, 7854, 6380, 11550, 91442, 486, 1527, 82, 496, 210, 383, 4, 753, 878, 265, 248, 1552, 500, 573, 6757, 872, 14825, 1543, 2, 444, 30648, 37912, 117971, 187106, 63716, 37067, 239599, 288678, 256545, 100849, 170782, 174185, 119968, 149196, 114334, 169818, 171621, 113037, 44815, 146845, 254725, 8284, 91795, 78095, 136231, 260238, 460955, 358531, 643305, 329873, 318625, 535524, 27142, 13761, 36769, 4779, 9041, 26003, 818, 5107, 1885, 24161, 4450, 5700, 89408, 32357, 168442, 53614, 45547, 10715, 20560, 1145, 12118, 2251, 3054, 255, 5252, 46775, 3321, 583, 3, 2988, 3564, 2197, 3413, 1415, 2399, 7994, 6217, 8562, 5920, 78835, 45796, 6224, 1805, 7457, 85088, 4724, 2843, 4776, 8265, 13665, 177548, 345242, 176088, 304869, 158493, 247649, 382902, 293371, 459695, 324600, 730014, 452371, 160533, 375526, 122934, 536096, 823471, 688149, 451928, 586633, 185617, 136302, 22520, 21912, 30351, 10677, 10271, 2509, 2719, 67521, 7226, 2346, 10665, 11216, 3190, 7318, 4625, 412, 1674, 91, 201, 72, 6551, 99, 4437, 39, 124, 115, 328, 187, 3365, 7257, 1430, 3050, 3069, 3937, 826, 1054, 436, 898, 135, 935, 673, 24691, 265904, 1222, 1289, 994, 6511, 726, 1284, 372, 8493, 588, 2618, 2441, 1081, 5054, 2732, 1995, 74007, 2332, 68485, 548676, 348018, 1550, 80975, 11647, 10664, 7330, 38478, 18434, 453305, 427530, 2771, 910, 1769, 5374, 23044, 22307, 15977, 15318, 6253, 3648, 9159, 43600, 547, 201, 21, 1134, 2329, 558, 65053, 119561, 103740, 230028, 58110, 118409, 91739, 78032, 13451, 1411, 5225, 14011, 4316, 7379, 10793, 86585, 20369, 99016, 38051, 80446, 110493, 421382, 882676, 668038, 477949, 568023, 402208, 774780, 627242, 798786, 337657, 379991, 11823, 33032, 1771, 17979, 210, 2338, 1142, 1291, 7023, 2783, 1258, 4072, 3517, 2500, 2409, 765, 230, 183, 454, 860, 697, 450, 3825, 3392, 1279, 230, 44, 186, 4367, 755, 8477, 28917, 5718, 38987, 39885, 46275, 245551, 85883, 259575, 227221, 134959, 45721, 20137, 34371, 18095, 69534, 122932, 255285, 131460, 161687, 132201, 86388, 105374, 10647, 270713, 41454, 131856, 168678, 77432, 107925, 135778, 26953, 8989, 25483, 1271, 1884, 6674, 6210, 36515, 101080, 176893, 129308, 5585, 2890, 392, 30734, 101642, 36299, 48424, 3927, 26359, 4093, 20693, 7435, 8072, 4065, 2892, 868, 2564, 75, 1779, 2863, 3605, 2141, 20579, 111537, 271939, 47893, 84487, 30151, 16410, 1970, 2157, 755, 335, 1418, 6282, 29362, 5254, 664, 882, 395, 1129, 581, 1193, 1613, 681, 1403, 77, 296, 6229, 967, 8589, 10819, 4584, 144, 30, 608, 4444, 14766, 3265, 5000, 533, 1, 11, 5005, 6208, 594, 22, 38, 77, 23, 1, 177, 1996, 9, 195917, 1248538, 250587, 226286, 903226, 830843, 1005769, 1057668, 1037363, 983318, 871250, 779663, 663680, 499728, 531137, 374964, 441116, 771, 2522, 27807, 23290, 264, 2582, 16417, 117, 4030, 744, 925, 1441, 3080, 142, 22, 466, 3677, 4655, 7609, 11460, 647, 233, 2325, 192, 2665, 3859, 9297, 890, 1145, 1775, 1157, 3695, 4078, 1266, 135448, 15, 1275, 268, 577, 107, 1, 11, 53, 399, 4061, 1152, 1470, 41528, 26, 452, 11025, 6056, 1992, 891, 927, 223, 40, 47669, 30248, 5001, 1002, 11975, 9934, 6540, 23842, 18083, 20140, 31567, 21298, 107661, 11787, 7459, 20316, 525, 2001, 1206, 4, 95, 18, 1, 3894, 575, 36, 711, 576, 159, 628, 113, 15, 84, 7157, 18206, 11345, 6136, 1651, 9144, 3857, 4668, 2948, 6201, 2045, 21636, 27, 13484, 6056, 9031, 4835, 29364, 3, 5563, 2353, 971, 3, 1, 18, 37, 418, 2060, 26, 81904, 42474, 149529, 85893, 114842, 25908, 154080, 69423, 170073, 232871, 372157, 286892, 308805, 447223, 531938, 434767, 275820, 29592, 31515, 85848, 7083, 101089, 136540, 61929, 311811, 243889, 109838, 698675, 392241, 50747, 332522, 505588, 1081751, 172131, 534937, 219508, 443546, 102736, 107905, 22327, 197334, 273683, 145621, 427, 2759, 2098, 3176, 70, 37, 7, 4, 1, 6, 23269, 72, 5636, 337, 15018, 8907, 206, 430, 601, 162, 162, 418, 578, 169, 1356, 368, 388, 326, 479, 2, 1, 118, 2, 19, 7, 285, 347, 101, 84, 90, 396, 1689, 716, 1799, 2470, 3137, 7210, 65235, 7, 19, 2227, 13487, 3956, 442, 2887, 710, 1096, 136, 3800, 32725, 2283, 14390, 299, 1661, 2389, 75, 1554, 594, 1921, 457, 437, 78, 867, 264, 291, 98, 29, 135, 55, 62, 14, 23, 433, 48, 193, 225, 99, 5372, 3, 11, 4, 17, 3467, 64, 57, 78, 428, 385, 12425, 360, 728, 565, 140, 620, 6, 16420, 2687, 62329, 314369, 98302, 2775, 94585, 13706, 4, 26780, 4244, 674, 123, 344, 469, 692, 280, 117, 349, 169, 904, 490, 7859, 4191, 179813, 72485, 440655, 3453, 722, 370, 12, 10, 316887, 161986, 295023, 14051, 451371, 163113, 245451, 458007, 209388, 532169, 426610, 920167, 280464, 519762], line_color=GREEN, add_vertex_dots=False)\n        numberLine = NumberLine(x_range=[1, 10, 1], length=12).set_color(BLACK).shift(3 * DOWN)\n        lables2 = numberLine.add_labels(dict_values={1: '29.04.2020', 2: '26.07.2020', 3: '22.10.2020', 4: '18.01.2021', 5: '16.04.2021', 6: '13.07.2021', 7: '09.10.2021', 8: '05.01.2022', 9: '03.04.2022', 10: '30.06.2022'}, font_size=20)\n        self.play(Write(lables2, lag_ratio=0.01, run_time=1), Write(axes, lag_ratio=0.01, run_time=1))\n        self.play(Write(labels, run_time=0.4), Write(line_graph, run_time=5))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the bubble sort algorithm with bars representing numbers and highlight swaps with red."}, {"role": "assistant", "content": "from math import floor, log2\nfrom manim import Rectangle, Tex, Scene, Write, UP, DR, UL, DL, LEFT, GREEN, DARK_BLUE, ORIGIN, RIGHT, VGroup, RED, YELLOW_D, Unwrite, BLUE, BLUE_B, BLUE_E, Arrow, DOWN, WHITE, Text, BraceBetweenPoints, Point, PI, Graph, ManimColor, Transform, Circle, BLACK, UR\nfrom collections import deque, defaultdict\nfrom classes import Element, GapIndicator, Node, RNGenerator, arrElement\nimport constants\n\nclass BubbleSort(Scene):\n    \"\"\"Manim Scene Class\n    \"\"\"\n\n    def construct(self):\n        n = constants.N\n        rn = RNGenerator(n)\n        shifting = 0.1\n        bar_width = (self.camera.frame_width - 3) / (n + shifting * n)\n        text = Tex('Bubble Sort $O(n^2)$', font_size=55).to_edge(DOWN)\n        self.play(Write(text))\n        githubName = generateName()\n        self.play(Write(githubName))\n        array = [Element(idx, bar_width) for idx in range(n)]\n        for i in range(0, n):\n            array[i].stretch_to_fit_height(rn.next() / (n * 1.0) * self.camera.frame_height * 0.5)\n            array[i].shift(RIGHT * (bar_width + shifting) * i)\n            array[i].align_to((0, 0, 0), DOWN)\n        group = VGroup(*array)\n        group.move_to(ORIGIN)\n        group.set_fill(WHITE, opacity=1)\n        self.play(*[Write(o) for o in array])\n        for i in range(n):\n            for j in range(n - i - 1):\n                if array[j] > array[j + 1]:\n                    self.play(array[j].animate.set_fill(RED), array[j + 1].animate.set_fill(RED), array[j].animate.set_color(RED), array[j + 1].animate.set_color(RED), run_time=0.1)\n                    swap(array[j], array[j + 1], self)\n                    array[j], array[j + 1] = (array[j + 1], array[j])\n                    array[j].set_fill(WHITE)\n                    array[j].set_color(WHITE)\n                    array[j + 1].set_color(WHITE)\n                    if j + 1 == n - i - 1:\n                        array[j + 1].set_fill(GREEN)\n        ordered_group = VGroup(*array)\n        self.play(ordered_group.animate(lag_ratio=0.3).set_fill(GREEN), ordered_group.animate(lag_ratio=0.3).set_color(GREEN))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Visualize the selection sort algorithm with bars representing array elements, highlighting comparisons and swaps."}, {"role": "assistant", "content": "from math import floor, log2\nfrom manim import Rectangle, Tex, Scene, Write, UP, DR, UL, DL, LEFT, GREEN, DARK_BLUE, ORIGIN, RIGHT, VGroup, RED, YELLOW_D, Unwrite, BLUE, BLUE_B, BLUE_E, Arrow, DOWN, WHITE, Text, BraceBetweenPoints, Point, PI, Graph, ManimColor, Transform, Circle, BLACK, UR\nfrom collections import deque, defaultdict\nfrom classes import Element, GapIndicator, Node, RNGenerator, arrElement\nimport constants\n\nclass SelectionSort(Scene):\n    \"\"\"Manim Scene Class\n    \"\"\"\n\n    def construct(self):\n        n = constants.N\n        rn = RNGenerator(n)\n        shifting = 0.1\n        bar_width = (self.camera.frame_width - shifting * n - 3) / n\n        text = Tex('Selection Sort $O(n^2)$', font_size=55).to_edge(DOWN)\n        self.play(Write(text))\n        githubName = generateName()\n        self.play(Write(githubName))\n        array = [Element(idx, bar_width) for idx in range(n)]\n        for i in range(0, n):\n            array[i].stretch_to_fit_height(rn.next() / (n * 1.0) * self.camera.frame_height * 0.5)\n            array[i].shift(RIGHT * (bar_width + shifting) * i)\n            array[i].align_to((0, 0, 0), DOWN)\n        group = VGroup(*array)\n        group.move_to(ORIGIN)\n        group.set_fill(WHITE, opacity=1)\n        self.play(*[Write(o) for o in array])\n        for i in range(n):\n            curr_min = i\n            self.play(array[i].animate.set_fill(RED), run_time=0.1)\n            for j in range(i + 1, n):\n                curr_item = j\n                self.play(array[curr_item].animate.set_fill(YELLOW_D), run_time=0.07)\n                if array[curr_item] < array[curr_min]:\n                    self.play(array[curr_min].animate.set_fill(WHITE), array[curr_min].animate.set_color(WHITE), run_time=0.1)\n                    curr_min = curr_item\n                    self.play(array[curr_min].animate.set_fill(RED), run_time=0.1)\n                    continue\n                self.play(array[curr_item].animate.set_fill(WHITE), array[curr_item].animate.set_color(WHITE), run_time=0.07)\n            swap(array[i], array[curr_min], self)\n            array[i], array[curr_min] = (array[curr_min], array[i])\n            self.play(array[i].animate.set_fill(GREEN), run_time=0.07)\n        ordered_group = VGroup(*array)\n        self.play(ordered_group.animate(lag_ratio=0.3).set_color(GREEN))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Visualize the heap sort algorithm, showing the array transformation into a max heap and then sorting."}, {"role": "assistant", "content": "from math import floor, log2\nfrom manim import Rectangle, Tex, Scene, Write, UP, DR, UL, DL, LEFT, GREEN, DARK_BLUE, ORIGIN, RIGHT, VGroup, RED, YELLOW_D, Unwrite, BLUE, BLUE_B, BLUE_E, Arrow, DOWN, WHITE, Text, BraceBetweenPoints, Point, PI, Graph, ManimColor, Transform, Circle, BLACK, UR\nfrom collections import deque, defaultdict\nfrom classes import Element, GapIndicator, Node, RNGenerator, arrElement\nimport constants\n\nclass HeapSort(Scene):\n    \"\"\"Manim Scene Class\"\"\"\n    LAYOUT_CONFIG = {'vertex_spacing': (-1, 1)}\n    VERTEX_TYPE = Node\n    VERTEX_CONF = {'radius': 0.25, 'color': BLUE_B, 'fill_opacity': 0.1, 'stroke_color': WHITE, 'z_index': 2, 'text': '0'}\n\n    def construct(self):\n        self.n = 7\n        rn = RNGenerator(9)\n        elementWidth = 0.8 * (self.camera.frame_width - 3) / 10\n        self.array = [arrElement(width=elementWidth, height=elementWidth, value=rn.next()) for _ in range(self.n)]\n        title = Tex('Heap Sort $O(n \\\\log(n))$', font_size=55).to_edge(DOWN)\n        githubName = generateName()\n        self.play(Write(githubName), Write(title))\n        steps = Tex('Turn the array into a binary tree.', font_size=34).next_to(ORIGIN, DOWN * 3.5, buff=0.5)\n        group = VGroup(*self.array).arrange(DOWN, buff=0).to_edge(LEFT)\n        self.play(Write(group), githubName.animate.to_corner(DR), title.animate.to_corner(UR))\n        self.play(Write(steps))\n        self.VERTEX_CONF['text'] = str(self.array[0].value)\n        self.q = deque(['0'])\n        self.nodes = ['0']\n        heap = Graph(['0'], [], vertex_type=self.VERTEX_TYPE, vertex_config=self.VERTEX_CONF)\n        self.play(Write(heap))\n        for i in range(1, self.n):\n            e: arrElement = group[i]\n            self.play(e.animate.set_fill(GREEN, 0.5), e.submobjects[0].animate.set_opacity(1), run_time=0.25)\n            self.add_node_to_tree(heap, str(e.value))\n            self.play(e.animate.set_fill(GREEN, 0), e.submobjects[0].animate.set_opacity(1), run_time=0.25)\n            self.wait(0.25)\n        self.display_message(steps, 'Convert the binary tree into a max heap.', True)\n        self.display_message(steps, 'We use the heapify algorithm on the non-leaf nodes.')\n        self.max_heapify(heap)\n        self.display_message(steps, 'Now that we have a max heap, we can start sorting.', True)\n        self.display_message(steps, 'We know that the root is the largest element in the heap.')\n        self.wait(2)\n        self.play(heap.vertices['0'].submobjects[0][0].animate.set_color(DARK_BLUE), run_time=0.25)\n        self.display_message(steps, 'We can pop that element and place it at the end of the array.', True)\n        self.display_message(steps, 'We swap it with the last element and remove it from the heap.', True)\n        self.swapVerts(heap, '0', self.nodes[-1])\n        self.wait(3)\n        self.remove_node_from_tree(heap, self.nodes[-1])\n        self.nodes.pop()\n        self.wait(3)\n        self.display_message(steps, 'Now the binary tree violates the max-heap property.', True)\n        self.display_message(steps, 'We can fix this by calling heapify on the root.', True)\n        self.max_heapify(heap)\n        self.display_message(steps, 'We repeat the previous steps until the heap is empty.', True)\n        for i in range(self.n - 1):\n            self.swapVerts(heap, '0', self.nodes[-1])\n            self.remove_node_from_tree(heap, self.nodes[-1])\n            self.nodes.pop()\n            if self.nodes:\n                self.max_heapify(heap)\n        self.display_message(steps, 'The array is now sorted.', True)\n        sorted_array = VGroup(*self.array)\n        self.play(sorted_array.animate.arrange(RIGHT, buff=0).move_to(ORIGIN), Unwrite(steps), githubName.animate.next_to(sorted_array.copy().arrange(RIGHT, buff=0).move_to(ORIGIN), UP), title.animate.next_to(sorted_array.copy().arrange(RIGHT, buff=0).move_to(ORIGIN), DOWN), run_time=1)\n        self.play(sorted_array.animate(lag_ratio=0.3).set_color(GREEN), run_time=1)\n        self.wait(5)\n\n    def max_heapify(self, heap: Graph):\n\n        def heapify_down(heap, node):\n            left_child = f'{node}/0'\n            right_child = f'{node}/1'\n            largest = node\n            if left_child in heap.vertices and int(heap.vertices[left_child].submobjects[0][1].tex_string) > int(heap.vertices[largest].submobjects[0][1].tex_string):\n                largest = left_child\n            if right_child in heap.vertices and int(heap.vertices[right_child].submobjects[0][1].tex_string) > int(heap.vertices[largest].submobjects[0][1].tex_string):\n                largest = right_child\n            if largest != node:\n                self.play(heap.vertices[node].submobjects[0][0].animate.set_color(ManimColor('#9A3020')), run_time=0.25)\n                self.swapVerts(heap, node, largest)\n                heapify_down(heap, largest)\n        for i in self.nodes[len(self.nodes) // 2 - 1::-1]:\n            heapify_down(heap, str(i))\n\n    def display_message(self, mobject: Tex, text, wait=False):\n        to = Tex(text, font_size=34).move_to(mobject.get_center())\n        self.play(Transform(mobject, to), run_time=0.5)\n        if wait:\n            self.wait(3)\n\n    def swapVerts(self, heap, a, b):\n        swap(self.array[self.vertex_to_index(a)], self.array[self.vertex_to_index(b)], self, 0.25)\n        self.array[self.vertex_to_index(a)], self.array[self.vertex_to_index(b)] = (self.array[self.vertex_to_index(b)], self.array[self.vertex_to_index(a)])\n        a = heap.vertices[a]\n        b = heap.vertices[b]\n        temp = b.submobjects[0][1].copy()\n        a.submobjects[0][1].tex_string, b.submobjects[0][1].tex_string = (b.submobjects[0][1].tex_string, a.submobjects[0][1].tex_string)\n        self.play(a.submobjects[0][0].animate.set_color(BLACK), Transform(b.submobjects[0][1], a.submobjects[0][1].copy().move_to(b.submobjects[0][1].get_center())), Transform(a.submobjects[0][1], temp.move_to(a.submobjects[0][1].get_center())))\n\n    @staticmethod\n    def vertex_to_index(vertex_id):\n        if vertex_id == '0':\n            return 0\n        ids = vertex_id.split('/')\n        idx = 0\n        for i in range(1, len(ids)):\n            idx = idx * 2 + (1 + int(ids[i]))\n        return idx\n\n    def add_node_to_tree(self, g: Graph, text: str):\n        last_vertex_id = self.q[0]\n        if f'{last_vertex_id}/0' not in g.vertices:\n            new_vertex_id = f'{last_vertex_id}/0'\n        else:\n            new_vertex_id = f'{last_vertex_id}/1'\n            self.q.popleft()\n        self.q.append(new_vertex_id)\n        self.nodes.append(new_vertex_id)\n        g.add_edges((last_vertex_id, new_vertex_id), vertex_type=self.VERTEX_TYPE, vertex_config={**self.VERTEX_CONF, 'text': text}, positions={new_vertex_id: g.vertices[last_vertex_id].get_center()})\n        self.play(g.animate.change_layout('tree', root_vertex='0', layout_config=self.LAYOUT_CONFIG), run_time=0.5)\n\n    def remove_node_from_tree(self, g: Graph, node_id):\n        if node_id == '0':\n            self.play(g.animate.remove_vertices(node_id), run_time=0.5)\n            return\n        self.play(g.animate.remove_vertices(node_id), g.animate.change_layout('tree', root_vertex='0', layout_config=self.LAYOUT_CONFIG), run_time=0.5)"}]}
{"messages": [{"role": "user", "content": "Animate the Merge Sort algorithm with a visual representation of the array and highlighting during the merging process."}, {"role": "assistant", "content": "from math import floor, log2\nfrom manim import Rectangle, Tex, Scene, Write, UP, DR, UL, DL, LEFT, GREEN, DARK_BLUE, ORIGIN, RIGHT, VGroup, RED, YELLOW_D, Unwrite, BLUE, BLUE_B, BLUE_E, Arrow, DOWN, WHITE, Text, BraceBetweenPoints, Point, PI, Graph, ManimColor, Transform, Circle, BLACK, UR\nfrom collections import deque, defaultdict\nfrom classes import Element, GapIndicator, Node, RNGenerator, arrElement\nimport constants\n\nclass MergeSort(Scene):\n    \"\"\"Manim Scene Class\n    \"\"\"\n\n    def construct(self):\n        n = constants.N\n        rn = RNGenerator(n)\n        shifting = 0.1\n        bar_width = (self.camera.frame_width - shifting * n - 3) / n\n        text = Tex('Merge Sort $O(n \\\\log(n))$', font_size=55).to_edge(DOWN)\n        self.play(Write(text))\n        githubName = generateName()\n        self.play(Write(githubName))\n        array = [Element(idx, bar_width) for idx in range(n)]\n        for i in range(0, n):\n            array[i].stretch_to_fit_height(rn.next() / (n * 1.0) * self.camera.frame_height * 0.5)\n            array[i].shift(RIGHT * (bar_width + shifting) * i)\n            array[i].align_to((0, 0, 0), DOWN)\n        group = VGroup(*array)\n        group.move_to(ORIGIN)\n        group.set_fill(WHITE, opacity=1)\n        self.play(*[Write(o) for o in array])\n\n        def merge(a: deque[Element], b: deque[Element]):\n            merged = deque([])\n            c = list(a + b)\n            curr_pos = a[0].index\n            mergedVGroup = VGroup(*c)\n            self.play(mergedVGroup.animate.set_fill(BLUE), run_time=0.1)\n            while a and b:\n                self.play(b[0].animate.set_fill(RED), a[0].animate.set_fill(RED), run_time=0.1)\n                if a[0].height < b[0].height:\n                    swap(array[curr_pos], array[a[0].index], self)\n                    a[0].index, array[curr_pos].index = (array[curr_pos].index, a[0].index)\n                    array[array[curr_pos].index], array[a[0].index] = (array[a[0].index], array[array[curr_pos].index])\n                    curr_pos += 1\n                    self.play(b[0].animate.set_fill(BLUE), a[0].animate.set_fill(BLUE), run_time=0.1)\n                    merged.append(a[0])\n                    a.popleft()\n                else:\n                    swap(array[curr_pos], array[b[0].index], self)\n                    b[0].index, array[curr_pos].index = (array[curr_pos].index, b[0].index)\n                    array[array[curr_pos].index], array[b[0].index] = (array[b[0].index], array[array[curr_pos].index])\n                    curr_pos += 1\n                    self.play(b[0].animate.set_fill(BLUE), a[0].animate.set_fill(BLUE), run_time=0.1)\n                    merged.append(b[0])\n                    b.popleft()\n            while a:\n                swap(array[curr_pos], array[a[0].index], self)\n                a[0].index, array[curr_pos].index = (array[curr_pos].index, a[0].index)\n                array[array[curr_pos].index], array[a[0].index] = (array[a[0].index], array[array[curr_pos].index])\n                curr_pos += 1\n                merged.append(a[0])\n                a.popleft()\n            while b:\n                swap(array[curr_pos], array[b[0].index], self)\n                b[0].index, array[curr_pos].index = (array[curr_pos].index, b[0].index)\n                array[array[curr_pos].index], array[b[0].index] = (array[b[0].index], array[array[curr_pos].index])\n                curr_pos += 1\n                merged.append(b[0])\n                b.popleft()\n            self.play(mergedVGroup.animate.set_fill(WHITE), run_time=0.1)\n            return merged\n\n        def mergeSort(array) -> deque[Rectangle]:\n            if len(array) == 1:\n                return deque(array)\n            arr1 = array[:len(array) // 2]\n            arr2 = array[len(array) // 2:]\n            arr1 = mergeSort(arr1)\n            arr2 = mergeSort(arr2)\n            return merge(arr1, arr2)\n        list(mergeSort(array))\n        ordered_group = VGroup(*array)\n        self.play(ordered_group.animate(lag_ratio=0.2).set_color(GREEN))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Visualize the Quick Sort algorithm, demonstrating the partitioning process with highlighted elements and a pivot, followed by an indication of the sorted array."}, {"role": "assistant", "content": "from math import floor, log2\nfrom manim import Rectangle, Tex, Scene, Write, UP, DR, UL, DL, LEFT, GREEN, DARK_BLUE, ORIGIN, RIGHT, VGroup, RED, YELLOW_D, Unwrite, BLUE, BLUE_B, BLUE_E, Arrow, DOWN, WHITE, Text, BraceBetweenPoints, Point, PI, Graph, ManimColor, Transform, Circle, BLACK, UR\nfrom collections import deque, defaultdict\nfrom classes import Element, GapIndicator, Node, RNGenerator, arrElement\nimport constants\n\nclass QuickSort(Scene):\n    \"\"\"Manim Scene Class\n    \"\"\"\n\n    def construct(self):\n        n = constants.N\n        rn = RNGenerator(n)\n        shifting = 0.1\n        bar_width = (self.camera.frame_width - shifting * n - 3) / n\n        title = Tex('Quick Sort $O(n \\\\log(n))$', font_size=55).to_edge(DOWN)\n        self.play(Write(title))\n        githubName = generateName()\n        self.play(Write(githubName))\n        array = [Rectangle(width=bar_width) for _ in range(n)]\n        for i in range(0, n):\n            array[i].stretch_to_fit_height(rn.next() / (n * 1.0) * self.camera.frame_height * 0.5)\n            array[i].shift(RIGHT * (bar_width + shifting) * i)\n            array[i].align_to((0, 0, 0), DOWN)\n        group = VGroup(*array)\n        group.move_to(ORIGIN)\n        group.set_fill(WHITE, opacity=1)\n        self.play(*[Write(o) for o in array])\n        self.play(title.animate.to_edge(UP + RIGHT), run_time=0.5)\n\n        def partition(arr: list[Rectangle], low: int, high: int):\n            helper = [low, (high + low + 1) // 2, high]\n            medianOfThree = [arr[low].height, arr[(high + 1 + low) // 2].height, arr[high].height]\n            for i in range(2):\n                for j in range(2 - i):\n                    if medianOfThree[j] > medianOfThree[j + 1]:\n                        medianOfThree[j], medianOfThree[j + 1] = (medianOfThree[j + 1], medianOfThree[j])\n                        arr[helper[j]], arr[helper[j + 1]] = (arr[helper[j + 1]], arr[helper[j]])\n                        swap(arr[helper[j]], arr[helper[j + 1]], self, 0.1)\n            self.wait(0.25)\n            if high - low <= 2:\n                self.play(arr[low].animate.set_fill(GREEN), arr[(high + 1 + low) // 2].animate.set_fill(GREEN), arr[high].animate.set_fill(GREEN), run_time=0.13)\n                return (high + 1 + low) // 2\n            pivot_pos = (high + 1 + low) // 2\n            l_idx = low\n            l_idx_indicator = VGroup()\n            l_idx_arrow = Arrow(start=arr[l_idx].get_bottom() + 1.4 * DOWN, end=arr[l_idx].get_bottom() + 0.4 * DOWN, color=WHITE)\n            l_idx_indicator.add(l_idx_arrow)\n            l_idx_indicator.add(Text('l_idx', font_size=20, color=BLUE_B).next_to(l_idx_arrow, DOWN))\n            r_idx = high - 1\n            r_idx_indicator = VGroup()\n            r_idx_arrow = Arrow(start=arr[r_idx].get_bottom() + 1.4 * DOWN, end=arr[r_idx].get_bottom() + 0.4 * DOWN, color=WHITE)\n            r_idx_indicator.add(r_idx_arrow)\n            r_idx_indicator.add(Text('r_idx', font_size=20, color=RED).next_to(r_idx_arrow, DOWN))\n            pivot_title = Text('Pivot', font_size=25).move_to(arr[pivot_pos].get_bottom() + 0.4 * DOWN)\n            self.play(arr[pivot_pos].animate.set_fill(YELLOW_D), Write(pivot_title), run_time=0.15)\n            self.wait(0.5)\n            pj = arr[pivot_pos].get_bottom()\n            pj1 = arr[high].get_bottom()\n            self.play(arr[pivot_pos].animate.shift(pj1 - pj), arr[high].animate.shift(pj - pj1), pivot_title.animate.shift(pj1 - pj), run_time=0.5)\n            arr[high], arr[pivot_pos] = (arr[pivot_pos], arr[high])\n            pivot_arrow_1 = Arrow(start=arr[l_idx].get_bottom() + 1.3 * DOWN, end=arr[l_idx].get_bottom(), color=WHITE, buff=0).align_to(pivot_title.get_center(), UP)\n            pivot_arrow_2 = Arrow(start=pivot_arrow_1.get_start(), end=[pivot_title.get_x(), pivot_arrow_1.get_bottom()[1], pivot_arrow_1.get_z()], stroke_width=6, max_stroke_width_to_length_ratio=float('inf'), color=WHITE, buff=0, max_tip_length_to_length_ratio=0)\n            pivot_arrow_2.shift(UP * 0.02)\n            pivot_arrow_3 = Arrow(start=pivot_arrow_2.get_end(), end=pivot_title.get_bottom() + 0.1 * DOWN, color=WHITE, buff=0, max_tip_length_to_length_ratio=0)\n            self.play(Write(l_idx_indicator), Write(r_idx_indicator), run_time=0.2)\n            while l_idx <= r_idx:\n                while arr[l_idx].height < arr[high].height:\n                    l_idx += 1\n                    self.play(l_idx_indicator.animate.move_to([arr[l_idx].get_x(), l_idx_indicator.get_y(), 0]), run_time=0.1)\n                while arr[r_idx].height > arr[high].height:\n                    r_idx -= 1\n                    self.play(r_idx_indicator.animate.move_to([arr[r_idx].get_x(), r_idx_indicator.get_y(), 0]), run_time=0.1)\n                if l_idx <= r_idx:\n                    self.play(arr[l_idx].animate.set_fill(BLUE), arr[r_idx].animate.set_fill(BLUE), run_time=0.1)\n                    self.wait(0.3)\n                    swap(arr[l_idx], arr[r_idx], self, 0.1)\n                    self.play(arr[l_idx].animate.set_fill(WHITE), arr[r_idx].animate.set_fill(WHITE), run_time=0.1)\n                    arr[r_idx], arr[l_idx] = (arr[l_idx], arr[r_idx])\n            self.wait(0.4)\n            self.play(Unwrite(l_idx_indicator), Unwrite(r_idx_indicator), run_time=0.2)\n            pivot_arrow_1.move_to([arr[l_idx].get_x(), pivot_arrow_1.get_y(), 0])\n            pivot_arrow_2.put_start_and_end_on(start=[arr[l_idx].get_x(), pivot_arrow_2.get_y(), 0], end=pivot_arrow_2.get_end())\n            if l_idx != high:\n                self.play(Write(pivot_arrow_1), Write(pivot_arrow_2), Write(pivot_arrow_3), run_time=0.13)\n                self.wait(0.5)\n                swap(arr[l_idx], arr[high], self, 0.1)\n                arr[l_idx], arr[high] = (arr[high], arr[l_idx])\n            self.play(Unwrite(pivot_title), Unwrite(pivot_arrow_1), Unwrite(pivot_arrow_2), Unwrite(pivot_arrow_3), arr[l_idx].animate.set_fill(GREEN), run_time=0.13)\n            return l_idx\n\n        def quick_sort(arr, low, high):\n            if low < high:\n                partition_index = partition(arr, low, high)\n                quick_sort(arr, low, partition_index - 1)\n                quick_sort(arr, partition_index + 1, high)\n        quick_sort(array, 0, len(array) - 1)\n        ordered_group = VGroup(*array)\n        self.play(ordered_group.animate(lag_ratio=0.2).set_color(GREEN))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Visualize the Radix Sort algorithm with animated array elements, buckets, and digit highlighting."}, {"role": "assistant", "content": "from math import floor, log2\nfrom manim import Rectangle, Tex, Scene, Write, UP, DR, UL, DL, LEFT, GREEN, DARK_BLUE, ORIGIN, RIGHT, VGroup, RED, YELLOW_D, Unwrite, BLUE, BLUE_B, BLUE_E, Arrow, DOWN, WHITE, Text, BraceBetweenPoints, Point, PI, Graph, ManimColor, Transform, Circle, BLACK, UR\nfrom collections import deque, defaultdict\nfrom classes import Element, GapIndicator, Node, RNGenerator, arrElement\nimport constants\n\nclass RadixSort(Scene):\n    \"\"\"Manim Scene Class\n    \"\"\"\n\n    def construct(self):\n        n = constants.N_RADIX\n        max_num = 10 ** constants.DIGITS_RADIX - 1\n        rn = RNGenerator(max_num)\n        box_width = (self.camera.frame_width - 3) / (10 if n <= 10 else n)\n        text = Tex('Radix Sort $O(n * d)$', font_size=55).to_edge(DOWN)\n        self.play(Write(text))\n        githubName = generateName()\n        self.play(Write(githubName))\n        array = [Rectangle(width=box_width, height=box_width) for _ in range(n)]\n        positions = defaultdict(int)\n        for i in range(len(array)):\n            rn_num = rn.next()\n            number = Tex(*[a for a in str(rn_num)]).scale_to_fit_height(box_width - 0.6 * box_width)\n            number.move_to(array[i])\n            array[i] = VGroup(array[i], number)\n            array[i].shift(RIGHT * box_width * i)\n            positions[rn_num] = i\n            array[i].align_to((0, 0, 0), DOWN)\n        group = VGroup(*array)\n        group.move_to(ORIGIN)\n        self.play(Write(group))\n        self.play(group.animate.to_edge(UL).scale(0.8), githubName.animate.scale(0.75).to_corner(DR, buff=0.25), Unwrite(text))\n        bucket_width = 0.8 * (self.camera.frame_width - 3) / 10\n        buckets = [Rectangle(width=bucket_width, height=bucket_width).set_color(BLUE_E).set_fill(BLUE_E, opacity=1) for _ in range(10)]\n        for i in range(10):\n            number = Tex(f'${i}$').scale_to_fit_height(bucket_width - 0.5 * bucket_width)\n            number.move_to(buckets[i])\n            buckets[i] = VGroup(buckets[i], number)\n            buckets[i].shift(DOWN * (bucket_width + 0.3) * (i % 5))\n            buckets[i].align_to((0, 0, 0), LEFT)\n            if i > 4:\n                buckets[i].align_to(((self.camera.frame_width - bucket_width) / 2, 0, 0), LEFT)\n        b_group = VGroup(*buckets)\n        b_group.to_corner(DL)\n        self.play(Write(b_group))\n        for d in range(constants.DIGITS_RADIX):\n            buckets_map = defaultdict(deque)\n            for i in range(len(array)):\n                number = int(array[i][1].tex_string)\n                b_index = number % 10 ** (d + 1) // 10 ** d\n                copy_rect = array[i].copy()\n                buckets_map[b_index].append(copy_rect)\n                digit_highlight = None\n                try:\n                    digit_highlight = copy_rect[1][-(1 + d)]\n                    self.play(digit_highlight.animate.set_color(GREEN), run_time=0.2)\n                    self.play(VGroup(*buckets_map[b_index]).animate.arrange().next_to(buckets[b_index]))\n                except:\n                    self.play(VGroup(*buckets_map[b_index]).animate.arrange().next_to(buckets[b_index]))\n            swap_pointer = 0\n            for n in range(10):\n                self.play(buckets[n][0].animate.set_color(GREEN), run_time=0.15)\n                for element in list(buckets_map[n]):\n                    number = int(element[1].tex_string)\n                    num_index = positions[number]\n                    num_2 = int(array[swap_pointer][1].tex_string)\n                    array[num_index], array[swap_pointer] = (array[swap_pointer], array[num_index])\n                    swap(array[num_index], array[swap_pointer], self, 0.3, radix=True)\n                    self.play(Unwrite(element), array[swap_pointer].animate.set_color(BLUE), run_time=0.1)\n                    positions[num_2] = positions[number]\n                    positions[number] = swap_pointer\n                    swap_pointer += 1\n                self.play(buckets[n][0].animate.set_color(BLUE_E), run_time=0.15)\n            self.play(group.animate.set_color(WHITE), run_time=0.2)\n        ordered_group = VGroup(*array)\n        self.play(Unwrite(b_group), run_time=0.1)\n        self.play(ordered_group.animate.move_to(ORIGIN).scale(1.25))\n        self.play(githubName.animate.scale(1 / 0.75 + 0.2).next_to(ordered_group, UP), Write(Tex('Radix Sort $O(n * d)$', font_size=55).next_to(ordered_group, DOWN)))\n        self.play(ordered_group.animate(lag_ratio=0.3).set_fill(GREEN).set_color(GREEN))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Visualize the insertion sort algorithm with bars representing array elements and highlight comparisons and swaps."}, {"role": "assistant", "content": "from math import floor, log2\nfrom manim import Rectangle, Tex, Scene, Write, UP, DR, UL, DL, LEFT, GREEN, DARK_BLUE, ORIGIN, RIGHT, VGroup, RED, YELLOW_D, Unwrite, BLUE, BLUE_B, BLUE_E, Arrow, DOWN, WHITE, Text, BraceBetweenPoints, Point, PI, Graph, ManimColor, Transform, Circle, BLACK, UR\nfrom collections import deque, defaultdict\nfrom classes import Element, GapIndicator, Node, RNGenerator, arrElement\nimport constants\n\nclass InsertionSort(Scene):\n    \"\"\"Manim Scene Class\n    \"\"\"\n\n    def construct(self):\n        n = min(15, constants.N)\n        rn = RNGenerator(n)\n        shifting = 0.1\n        bar_width = (self.camera.frame_width - shifting * n - 3) / n\n        title = Tex('Insertion Sort $O(n^{2})$', font_size=55).to_edge(DOWN)\n        githubName = generateName()\n        self.play(Write(githubName), Write(title))\n        array = [Rectangle(width=bar_width) for _ in range(n)]\n        for i in range(0, n):\n            array[i].stretch_to_fit_height(rn.next() / (n * 1.0) * self.camera.frame_height * 0.4)\n            array[i].shift(RIGHT * (bar_width + shifting) * i)\n            array[i].align_to((0, 0, 0), DOWN)\n        group = VGroup(*array)\n        group.move_to(ORIGIN)\n        group.set_fill(WHITE, opacity=1)\n        self.play(*[Write(o) for o in array])\n        gt = Text('<', font_size=35, weight='BOLD').rotate(PI / 2).save_state()\n        lt = Text('<', font_size=35, weight='BOLD').rotate(-PI / 2).save_state()\n        w = lt.width\n        self.play(title.animate.to_edge(UP + RIGHT), run_time=0.25)\n        for i in range(1, len(array)):\n            temp = array[i]\n            temp_in = temp.get_bottom()\n            j = i\n            c = i\n            gapped: list[Rectangle] = []\n            while c >= 1:\n                gapped.append(array[c - 1])\n                c -= 1\n            highlight = list(map(lambda x: x.animate.set_fill(BLUE_E), gapped))\n            highlight.append(temp.animate.shift(DOWN * (temp.height + w + 4 * shifting)).set_fill(YELLOW_D))\n            play(self, *highlight, run_time=0.5)\n            while j >= 1:\n                self.play(temp.animate.shift(array[j - 1].get_bottom() - temp_in), run_time=0.25)\n                if array[j - 1].height > temp.height:\n                    gt.restore().move_to(array[j - 1].get_bottom() + (w + shifting) * DOWN)\n                    self.play(Write(gt), run_time=0.25)\n                    self.play(Unwrite(gt), run_time=0.25)\n                    new_temp_in = array[j - 1].get_bottom()\n                    self.play(array[j - 1].animate.shift(temp_in - array[j - 1].get_bottom()).set_fill(RED), run_time=0.25)\n                    temp_in = new_temp_in\n                    array[j] = array[j - 1]\n                    j -= 1\n                else:\n                    lt.restore().move_to(array[j - 1].get_bottom() + (w + shifting) * DOWN)\n                    self.play(Write(lt), run_time=0.25)\n                    self.play(Unwrite(lt), run_time=0.25)\n                    self.play(temp.animate.shift(temp_in - array[j - 1].get_bottom()), array[j - 1].animate.set_fill(GREEN), run_time=0.25)\n                    break\n            array[j] = temp\n            remove_highlight = list(map(lambda x: x.animate.set_fill(WHITE), gapped))\n            remove_highlight.append(temp.animate.shift(UP * (temp.height + w + 4 * shifting)).set_fill(WHITE))\n            play(self, *remove_highlight, run_time=0.5)\n        self.play(VGroup(*array).animate.set_color(GREEN), run_time=1, lag_ratio=0.3)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize the Shell Sort algorithm, highlighting element comparisons and swaps for each gap interval and concluding with a sorted array visualization."}, {"role": "assistant", "content": "from math import floor, log2\nfrom manim import Rectangle, Tex, Scene, Write, UP, DR, UL, DL, LEFT, GREEN, DARK_BLUE, ORIGIN, RIGHT, VGroup, RED, YELLOW_D, Unwrite, BLUE, BLUE_B, BLUE_E, Arrow, DOWN, WHITE, Text, BraceBetweenPoints, Point, PI, Graph, ManimColor, Transform, Circle, BLACK, UR\nfrom collections import deque, defaultdict\nfrom classes import Element, GapIndicator, Node, RNGenerator, arrElement\nimport constants\n\nclass ShellSort(Scene):\n    \"\"\"Manim Scene Class\n    \"\"\"\n\n    def construct(self):\n        n = min(15, constants.N)\n        rn = RNGenerator(n)\n        shifting = 0.1\n        bar_width = (self.camera.frame_width - shifting * n - 3) / n\n        title = Tex('Shell Sort $O(n^{\\\\frac{4}{3}})$', font_size=55).to_edge(DOWN)\n        githubName = generateName()\n        self.play(Write(githubName), Write(title))\n        array = [Rectangle(width=bar_width) for _ in range(n)]\n        for i in range(0, n):\n            array[i].stretch_to_fit_height(rn.next() / (n * 1.0) * self.camera.frame_height * 0.4)\n            array[i].shift(RIGHT * (bar_width + shifting) * i)\n            array[i].align_to((0, 0, 0), DOWN)\n        group = VGroup(*array)\n        group.move_to(ORIGIN + DOWN)\n        group.set_fill(WHITE, opacity=1)\n        self.play(*[Write(o) for o in array])\n        gt = Text('<', font_size=35, weight='BOLD').rotate(PI / 2).save_state()\n        lt = Text('<', font_size=35, weight='BOLD').rotate(-PI / 2).save_state()\n        w = lt.width\n        self.play(title.animate.to_edge(UP + RIGHT), run_time=0.25)\n        gaps = [2 ** i - 1 for i in range(floor(log2(len(array))), 0, -1)]\n        for gap in gaps:\n            if gap == 1:\n                inssort = Text('Ordinary Insertion Sort', font_size=35).next_to(group, UP)\n                self.play(Write(inssort), run_time=0.5)\n            gapIndicator = GapIndicator(gap, n, bar_width + shifting, [array[0].get_x(), self.camera.frame_height * 0.2, 0] + DOWN, self)\n            gapIndicator.createIndicator()\n            for i in range(gap, len(array)):\n                temp = array[i]\n                temp_in = temp.get_bottom()\n                j = i\n                c = i\n                gapped: list[Rectangle] = []\n                while c >= gap:\n                    gapped.append(array[c - gap])\n                    c -= gap\n                highlight = list(map(lambda x: x.animate.set_fill(BLUE_E), gapped))\n                highlight.append(temp.animate.shift(DOWN * (temp.height + w + 4 * shifting)).set_fill(YELLOW_D))\n                play(self, *highlight, run_time=0.5)\n                while j >= gap:\n                    self.play(temp.animate.shift(array[j - gap].get_bottom() - temp_in), run_time=0.25)\n                    if array[j - gap].height > temp.height:\n                        gt.restore().move_to(array[j - gap].get_bottom() + (w + shifting) * DOWN)\n                        self.play(Write(gt), run_time=0.25)\n                        self.play(Unwrite(gt), run_time=0.25)\n                        new_temp_in = array[j - gap].get_bottom()\n                        self.play(array[j - gap].animate.shift(temp_in - array[j - gap].get_bottom()).set_fill(RED), run_time=0.25)\n                        temp_in = new_temp_in\n                        array[j] = array[j - gap]\n                        j -= gap\n                    else:\n                        lt.restore().move_to(array[j - gap].get_bottom() + (w + shifting) * DOWN)\n                        self.play(Write(lt), run_time=0.25)\n                        self.play(Unwrite(lt), run_time=0.25)\n                        self.play(temp.animate.shift(temp_in - array[j - gap].get_bottom()), array[j - gap].animate.set_fill(GREEN), run_time=0.25)\n                        break\n                array[j] = temp\n                remove_highlight = list(map(lambda x: x.animate.set_fill(WHITE), gapped))\n                remove_highlight.append(temp.animate.shift(UP * (temp.height + w + 4 * shifting)).set_fill(WHITE))\n                play(self, *remove_highlight, run_time=0.5)\n                if i < len(array) - 1:\n                    gapIndicator.moveIndicators()\n            del gapIndicator\n            if gap == 1:\n                self.play(Unwrite(inssort), run_time=0.75)\n        self.play(VGroup(*array).animate.set_color(GREEN), run_time=1, lag_ratio=0.3)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display the first 100 characters of a script as text, then wait for 2 seconds."}, {"role": "assistant", "content": "from manim import *\nimport tempfile\nimport os\nimport sys\nimport subprocess\nimport py_compile\nfrom dotenv import load_dotenv\nfrom langchain_core.messages import HumanMessage, SystemMessage\nfrom langchain_google_genai import ChatGoogleGenerativeAI\nimport shutil\nimport re\n\nclass MyScene(Scene):\n\n    def construct(self):\n        text = Text(script[:100] + '...' if len(script) > 100 else script)\n        self.play(Write(text))\n        self.wait(2)"}]}
