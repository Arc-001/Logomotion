{"messages": [{"role": "user", "content": "Display a 3D representation of a magnetic field generated by a circular wire."}, {"role": "assistant", "content": "from manim_physics import *\n\nclass MagneticFieldExample(ThreeDScene):\n\n    def construct(self):\n        wire = Wire(Circle(2).rotate(PI / 2, UP))\n        mag_field = MagneticField(wire)\n        self.set_camera_orientation(PI / 3, PI / 4)\n        self.add(wire, mag_field)"}]}
{"messages": [{"role": "user", "content": "Display four different icons arranged horizontally."}, {"role": "assistant", "content": "from manim import *\nfrom manim_editor import EditorBanner, IconCompleteLoop, IconLoop, IconNormal, IconSkip, PresentationSectionType\n\nclass IconTest(Scene):\n\n    def construct(self):\n        self.add(VGroup(IconNormal(), IconSkip(), IconLoop(), IconCompleteLoop()).arrange(RIGHT))"}]}
{"messages": [{"role": "user", "content": "Create a scene that adds a circle, then a square, removes the circle, and finally removes the square."}, {"role": "assistant", "content": "from manim import *\nfrom manim_editor import EditorBanner, IconCompleteLoop, IconLoop, IconNormal, IconSkip, PresentationSectionType\n\nclass Test(Scene):\n\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        self.add(circle)\n        self.wait()\n        self.next_section()\n        self.add(square)\n        self.wait()\n        self.next_section()\n        self.remove(circle)\n        self.wait()\n        self.next_section()\n        self.remove(square)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a dot moving sequentially to different points while demonstrating presentation section types."}, {"role": "assistant", "content": "from manim import *\nfrom manim_editor import EditorBanner, IconCompleteLoop, IconLoop, IconNormal, IconSkip, PresentationSectionType\n\nclass MinimalPresentationExample(Scene):\n\n    def construct(self):\n        dots, moving_dot, path = make_elements()\n        self.add(dots, moving_dot, path)\n        self.next_section('A', PresentationSectionType.NORMAL)\n        self.play(moving_dot.animate.move_to(dots[1]), rate_func=linear)\n        self.next_section('A.1', PresentationSectionType.SUB_NORMAL)\n        self.play(moving_dot.animate.move_to(dots[2]), rate_func=linear)\n        self.next_section('B', PresentationSectionType.SKIP)\n        self.play(moving_dot.animate.move_to(dots[3]), rate_func=linear)\n        self.next_section('C', PresentationSectionType.LOOP)\n        self.play(moving_dot.animate.move_to(dots[4]), rate_func=linear)\n        self.next_section('D', PresentationSectionType.COMPLETE_LOOP)\n        self.play(moving_dot.animate.move_to(dots[5]), rate_func=linear)\n        self.next_section('E', PresentationSectionType.NORMAL)\n        self.play(moving_dot.animate.move_to(dots[6]), rate_func=linear)"}]}
{"messages": [{"role": "user", "content": "Demonstrate Manim's `PresentationSectionType` by cycling through examples of NORMAL, SKIP, LOOP, and COMPLETE_LOOP sections with visual cues and explanatory text."}, {"role": "assistant", "content": "from manim import *\nfrom manim_editor import EditorBanner, IconCompleteLoop, IconLoop, IconNormal, IconSkip, PresentationSectionType\n\nclass Tutorial(Scene):\n\n    def construct(self):\n        dots, icons, moving_dot, l, path, slider_number = setup_slider()\n        self.add(icons, moving_dot, l, path, slider_number, dots)\n        self.next_section('A', PresentationSectionType.NORMAL, skip_animations=False)\n        slider_number.set_value(1)\n        moving_dot.x0 = dots[0].get_x()\n        moving_dot.x1 = dots[1].get_x()\n        moving_dot.FRACTION = 0\n        moving_dot.run_time = 8\n        banner = EditorBanner().scale(1.2)\n        self.play(FadeIn(banner, scale=1.5, shift=DOWN))\n        self.play(banner.animate.shift(2.5 * UP))\n        A1 = 'Welcome! This presentation will guide you through the 4 provided section types.'\n        A1 = Text(A1).scale(0.5)\n        A2 = IconArray().scale(0.7)\n        A2.add(SurroundingRectangle(A2, stroke_color=BLUE, corner_radius=0.1, buff=0.2))\n        VGroup(A1, A2).arrange(DOWN).next_to(banner, DOWN)\n        self.play(Write(A1), run_time=2)\n        self.play(FadeIn(A2))\n        self.wait(3)\n        self.remove(banner, A1, A2)\n        self.next_section('B', PresentationSectionType.NORMAL, skip_animations=False)\n        slider_number.set_value(2)\n        moving_dot.x0 = dots[1].get_x()\n        moving_dot.x1 = dots[2].get_x()\n        moving_dot.FRACTION = 0\n        moving_dot.run_time = 4\n        line = TitleLine()\n        t1 = Text('Introducing:')\n        t2 = IconArray()[0]\n        t2.add(SurroundingRectangle(t2, stroke_color=BLUE, corner_radius=0.1, buff=0.2))\n        t12 = VGroup(t1, t2).arrange(RIGHT)\n        t12.next_to(line, UP)\n        t3 = VGroup(Text('Press any of the usual \"next slide\"-keys'), Text('like RightArrow or PageUp'), Text('to go to the next section.'), Text('You can also use the controls on the right.')).arrange(DOWN).scale(0.7).next_to(line, DOWN, buff=0.7)\n        self.add(line, t12, t3)\n        self.wait(4)\n        self.remove(t12, t3)\n        self.next_section('C', PresentationSectionType.SKIP, skip_animations=False)\n        slider_number.set_value(3)\n        moving_dot.x0 = dots[2].get_x()\n        moving_dot.x1 = dots[3].get_x()\n        moving_dot.FRACTION = 0\n        moving_dot.run_time = 4\n        t1 = Text('Introducing:')\n        t2 = IconArray()[1]\n        t2.add(SurroundingRectangle(t2, stroke_color=BLUE, corner_radius=0.1, buff=0.2))\n        t12 = VGroup(t1, t2).arrange(RIGHT)\n        t12.next_to(line, UP)\n        t3 = VGroup(Text('When the video of the skip section has finished '), Text('it automatically continues with the next.'), Text('No user input required.')).arrange(DOWN).scale(0.7).next_to(line, DOWN, buff=0.7)\n        self.add(t12, t3)\n        self.wait(2)\n        wind = IconSkip().set_style(fill_opacity=0).shift(2 * LEFT).scale(1.9)\n        wind.my_opactiy = 0\n        wind.coming = True\n\n        def wind_updater(mobj, dt):\n            if wind.coming:\n                if mobj.my_opactiy < 0.4:\n                    mobj.my_opactiy += dt\n            if not wind.coming:\n                if mobj.my_opactiy > 0:\n                    mobj.my_opactiy -= dt\n            mobj.set_style(fill_opacity=mobj.my_opactiy)\n        wind.add_updater(wind_updater)\n        wind.add_updater(lambda x: x.shift(0.02 * RIGHT))\n        self.add(wind)\n        self.wait(2)\n        self.next_section('D', PresentationSectionType.NORMAL, skip_animations=False)\n        slider_number.set_value(4)\n        moving_dot.x0 = dots[3].get_x()\n        moving_dot.x1 = dots[4].get_x()\n        moving_dot.FRACTION = 0\n        moving_dot.run_time = 3\n        self.wait(1)\n        wind.coming = False\n        self.wait(2)\n        wind.clear_updaters()\n        self.remove(wind)\n        self.remove(t12, t3)\n        self.next_section('E', PresentationSectionType.LOOP, skip_animations=False)\n        slider_number.set_value(5)\n        moving_dot.x0 = dots[4].get_x()\n        moving_dot.x1 = dots[5].get_x()\n        moving_dot.FRACTION = 0\n        moving_dot.run_time = 3\n        t1 = Text('Introducing:')\n        t2 = IconArray()[2]\n        t2.add(SurroundingRectangle(t2, stroke_color=BLUE, corner_radius=0.1, buff=0.2))\n        t12 = VGroup(t1, t2).arrange(RIGHT)\n        t12.next_to(line, UP)\n        t3 = VGroup(Text('Its looping!')).arrange(DOWN).scale(0.7).next_to(line, DOWN, buff=0.7)\n        self.add(t12, t3)\n        iconloop = IconLoop().set_style(fill_opacity=0.8)\n        iconloop.stroke_opacity = 0.8\n        iconloop.add_updater(lambda x, dt: x.rotate(-dt / 3 * TAU, about_point=ORIGIN - 0.16 * UP))\n        self.add(iconloop)\n        self.wait(3)\n        self.next_section('F', PresentationSectionType.NORMAL, skip_animations=False)\n        slider_number.set_value(6)\n        moving_dot.x0 = dots[5].get_x()\n        moving_dot.x1 = dots[6].get_x()\n        moving_dot.FRACTION = 0\n        moving_dot.run_time = 6\n        t3b = VGroup(Text(\"There won't be any smooth transitions\"), Text('when continuing to the next section though.')).arrange(DOWN).scale(0.7).next_to(line, DOWN, buff=0.7)\n        t3.become(t3b)\n        self.wait(0.5)\n        iconloop.add_updater(lambda x, dt: x.set_opacity(x.stroke_opacity - dt))\n        self.wait(2)\n        t4 = VGroup(Text('This is where Complete Loop Sections come in.')).scale(0.7).next_to(t3, DOWN, buff=0.7)\n        self.add(t4)\n        self.wait(3.5)\n        self.remove(t12, t3, t4)\n        self.next_section('G', PresentationSectionType.COMPLETE_LOOP, skip_animations=False)\n        slider_number.set_value(7)\n        moving_dot.x0 = dots[6].get_x()\n        moving_dot.x1 = dots[7].get_x()\n        moving_dot.FRACTION = 0\n        moving_dot.run_time = 3\n        t1 = Text('Introducing:')\n        t2 = IconArray()[3]\n        t2.add(SurroundingRectangle(t2, stroke_color=BLUE, corner_radius=0.1, buff=0.2))\n        t12 = VGroup(t1, t2).arrange(RIGHT)\n        t12.next_to(line, UP)\n        t3 = VGroup(Text('When continuing to the next section,'), Text('all animations of this section finish first.'), Text('Enjoy some smooth transitions!')).arrange(DOWN).scale(0.7).next_to(line, DOWN, buff=0.7)\n        self.add(t12, t3)\n        iconcompleteloop = IconCompleteLoop().set_style(fill_opacity=0.8)\n        iconcompleteloop.stroke_opacity = 0.8\n        iconcompleteloop.add_updater(lambda x, dt: x.rotate(-dt / 3 * TAU))\n        self.add(iconcompleteloop)\n        self.wait(3)\n        self.next_section('H', PresentationSectionType.NORMAL, skip_animations=False)\n        slider_number.set_value(8)\n        moving_dot.x0 = dots[7].get_x()\n        moving_dot.x1 = dots[8].get_x()\n        moving_dot.FRACTION = 0\n        moving_dot.run_time = 8\n        iconcompleteloop.add_updater(lambda x, dt: x.set_opacity(x.stroke_opacity - dt))\n        self.wait(2)\n        iconcompleteloop.clear_updaters()\n        self.play(Unwrite(VGroup(t3, t12, line)), run_time=1)\n        self.play(Write(Text('THE END').scale(4)), run_time=2)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Animate a growing rectangle from bottom center, representing the law of large numbers."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport math\nfrom random import *\n\nclass LawLarge(Scene):\n\n    def construct(self):\n        rect = Rectangle(width=1, height=0, color=GOLD_B, fill_opacity=1)\n        rect.to_edge(DOWN)\n        tracker = ValueTracker(0)\n        rect.add_updater(lambda x: x.become(self.get_rect(tracker.get_value())))\n        self.play(Write(rect))\n        for _ in range(6):\n            self.play(tracker.increment_value, 1, rate_func=linear)\n            self.wait()\n\n    def get_rect(self, value):\n        return Rectangle(width=1, height=value, color=GOLD_B, fill_opacity=1).to_edge(DOWN)"}]}
{"messages": [{"role": "user", "content": "Animate a simulation of coin flips, visually representing the cumulative counts of heads and tails with growing rectangles."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport math\nfrom random import *\n\nclass Prob(Scene):\n\n    def construct(self):\n        throws = int(input('How many throws?: '))\n        rectstarthead = Rectangle(fill_color=GOLD_B, fill_opacity=1, height=0, width=1, color=GOLD_B)\n        rectstarthead.to_edge(DOWN)\n        rectstarthead.shift(2 * LEFT)\n        self.play(ShowCreation(rectstarthead))\n        rectstarttails = Rectangle(fill_color=BLUE_B, fill_opacity=1, height=0, width=1, color=BLUE_B)\n        rectstarttails.to_edge(DOWN)\n        rectstarttails.shift(2 * RIGHT)\n        self.play(ShowCreation(rectstarttails))\n        t = 1\n        heads = 0\n        tails = 0\n        HeightAdjust = 2 / throws\n        CounterHeadsTxt = TextMobject('Heads:')\n        CounterTailsTxt = TextMobject('Tails:')\n        CounterHeadsTxt.to_edge(UP)\n        CounterTailsTxt.to_edge(UP)\n        CounterHeadsTxt.shift(2 * LEFT)\n        CounterTailsTxt.shift(2 * RIGHT)\n        self.play(Write(CounterHeadsTxt))\n        self.play(Write(CounterTailsTxt))\n        CounterHeads = TextMobject('0')\n        CounterHeads.next_to(CounterHeadsTxt, RIGHT)\n        CounterTails = TextMobject('0')\n        CounterTails.next_to(CounterTailsTxt, RIGHT)\n        while t < throws + 1:\n            ht = randint(0, 1)\n            if ht == 0:\n                heads = heads + 1\n                CounterHeadsNew = TextMobject(heads)\n                recttailsbefore = Rectangle(fill_color=GOLD_B, fill_opacity=1, height=(heads - 1) * HeightAdjust, width=1, color=GOLD_B)\n                recttailsnew = Rectangle(fill_color=GOLD_B, fill_opacity=1, height=heads * HeightAdjust, width=1, color=GOLD_B)\n                recttailsbefore.to_edge(DOWN)\n                recttailsnew.to_edge(DOWN)\n                recttailsnew.shift(2 * LEFT)\n                recttailsbefore.shift(2 * LEFT)\n                CounterHeadsNew.next_to(CounterHeadsTxt, RIGHT)\n                self.play(Transform(recttailsbefore, recttailsnew), Transform(CounterHeads, CounterHeadsNew))\n            elif ht == 1:\n                tails = tails + 1\n                CounterTailsNew = TextMobject(tails)\n                rectheadbefore = Rectangle(fill_color=BLUE_B, fill_opacity=1, height=(tails - 1) * HeightAdjust, width=1, color=BLUE_B)\n                rectheadnew = Rectangle(fill_color=BLUE_B, fill_opacity=1, height=tails * HeightAdjust, width=1, color=BLUE_B)\n                rectheadbefore.to_edge(DOWN)\n                rectheadnew.to_edge(DOWN)\n                rectheadnew.shift(2 * RIGHT)\n                rectheadbefore.shift(2 * RIGHT)\n                CounterTailsNew.next_to(CounterTailsTxt, RIGHT)\n                self.play(Transform(rectheadbefore, rectheadnew), Transform(CounterTails, CounterTailsNew))\n            t = t + 1"}]}
{"messages": [{"role": "user", "content": "Create a Manim scene for visualizing a normal distribution."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass NormalDistrib(Scene):\n\n    def construct(self):\n        pass"}]}
{"messages": [{"role": "user", "content": "Introduce Green's Theorem with a title and screen rectangle, then transition to the Divergence Theorem."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        title = TextMobject(\"Green's Theorem\")\n        title.scale(1.5)\n        title.to_edge(UP)\n        rect = ScreenRectangle(height=6)\n        rect.next_to(title, DOWN)\n        eq = TexMobject('\\\\oiint_S \\\\vec{F} \\\\cdot d \\\\vec{S} = \\\\iiint_V \\\\nabla \\\\times \\\\vec{F} \\\\,dV', tex_to_color_map={'S': BLUE, '\\\\vec{F}': YELLOW, '\\\\nabla': RED, 'V': GREEN})\n        eq.scale(1.5)\n        title2 = TextMobject('Divergence Theorem', color=PURPLE)\n        title2.scale(1.5)\n        title2.shift(3 * UP)\n        self.play(FadeInFromDown(title), Write(rect))\n        self.wait()\n        self.play(Uncreate(rect), Uncreate(title))\n        self.play(Write(eq), Write(title2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the concept of a flux integral by animating the transformation of a flux integral equation into a flow rate equation, illustrating the underlying vector field and curve."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass FluxIntegral(Scene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        eq1 = TexMobject('\\\\int_C \\\\vec{F} \\\\cdot \\\\hat{n} \\\\ \\\\text{d}s')\n        eq1.scale(1.5)\n        t1 = TextMobject('Flux Integral', color=BLUE)\n        t1.scale(1.5)\n        t1.shift(3 * UP)\n        eq2 = TexMobject('\\\\int_C \\\\vec{F} \\\\cdot \\\\hat{n} \\\\ \\\\text{d}s')\n        eq2.shift(3 * UP)\n        axes = Axes(x_min=-5, x_max=5, y_min=-5, y_max=5, number_line_config={'include_tip': False})\n        f = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0) for x in np.arange(-5, 6, 1) for y in np.arange(-5, 6, 1)])\n        n = VGroup(*[self.n(t) for t in np.arange(-1.9, 2.001, 0.5)])\n        field = VGroup(axes, f)\n        lbl = TexMobject('\\\\hat{n}')\n        lv = Vector([0, 1, 0], color=GREEN)\n        lv.center()\n        lbl.shift(0.25 * RIGHT)\n        lv.shift(0.25 * LEFT)\n        lr = Rectangle(height=1.5, width=1.5)\n        nll = VGroup(lr, lv, lbl)\n        nll.shift(5 * RIGHT + 3 * UP)\n        axes2 = Axes(x_min=-5, x_max=5, y_min=-5, y_max=5, number_line_config={'include_tip': False})\n        f2 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0) for x in np.arange(-5, 6, 1) for y in np.arange(-5, 6, 1)])\n        field2 = VGroup(axes2, f2)\n        field2.set_fill(opacity=0.5)\n        field2.set_stroke(opacity=0.5)\n        axes3 = Axes(x_min=-5, x_max=5, y_min=-5, y_max=5, number_line_config={'include_tip': False})\n        f3 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0) for x in np.arange(-5, 6, 1) for y in np.arange(-5, 6, 1)])\n        field3 = VGroup(axes3, f3)\n        field3.set_fill(opacity=0.5)\n        field3.set_stroke(opacity=0.5)\n        curve = ParametricFunction(self.func, t_min=-2, t_max=2, color=YELLOW_E)\n        a = 9.6\n        c1 = ParametricFunction(lambda t: np.array([a * (1 - 2 * t ** 2 - 0.4), a * (t ** 3 - 4 * t - 2.03), 0]), t_min=-0.6, t_max=-0.5, color=YELLOW_E)\n        c2 = ParametricFunction(self.func2, t_min=-0.58, t_max=-0.51, color=YELLOW_E)\n        b = Brace(c2, LEFT)\n        b.rotate(0.6187171549725232)\n        b.shift(0.75 * RIGHT)\n        t = b.get_tex('\\\\Delta s')\n        p1 = self.func2(-0.58)\n        p2 = self.func2(-0.52)\n        v1 = Vector(np.array([0.5, 0.75, 0]), color=RED).shift(p1[0] * RIGHT + p1[1] * UP)\n        v2 = Vector(np.array([0.5, 0.75, 0]), color=RED).shift(p2[0] * RIGHT + p2[1] * UP)\n        r = Rectangle(height=3, width=4, fill_color=BLACK, fill_opacity=1, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        p = Polygon(np.array([0.5, 0.75, 0]) + p1[0] * RIGHT + p1[1] * UP, np.array([0.5, 0.75, 0]) + p2[0] * RIGHT + p2[1] * UP, p2[0] * RIGHT + p2[1] * UP, p1[0] * RIGHT + p1[1] * UP, color=BLUE, fill_opacity=0.75, stroke_opacity=0.75)\n        ll1 = VGroup(p, v1, v2)\n        ll2 = VGroup(r, c1, b, t)\n        r1 = VGroup(ll2, ll1)\n        r1.shift(2.5 * RIGHT + 1.5 * DOWN)\n        point = 2 * UP + 2.474606757 * RIGHT\n        p1 = 0.125 * UP + 0.125 * RIGHT\n        p2 = 0.125 * UP + 0.125 * LEFT\n        l1 = Line(0.5 * RIGHT, point - p1, stroke_width=1 * DEFAULT_STROKE_WIDTH)\n        l2 = Line(4.5 * RIGHT, point - p2, stroke_width=1 * DEFAULT_STROKE_WIDTH)\n        r2 = Rectangle(height=0.25, width=0.25, fill_color=BLACK, fill_opacity=0, stroke_width=1 * DEFAULT_STROKE_WIDTH)\n        r2.shift(point)\n        zoom = VGroup(r2, l1, l2, r1)\n        self.play(Write(eq1), Write(t1))\n        self.wait()\n        self.play(Uncreate(t1), Transform(eq1, eq2))\n        self.play(ShowCreation(field), Uncreate(eq1))\n        self.wait()\n        self.play(Transform(field, field2), Write(curve))\n        self.wait()\n        self.play(Write(n), Uncreate(field), Write(nll))\n        self.wait()\n        self.play(ShowCreation(field3), Uncreate(nll))\n        self.wait()\n        self.play(Write(zoom))\n        self.wait()\n        self.play(ApplyMethod(ll1.rotate, -0.6187171549725232 + PI / 2), Uncreate(b), Uncreate(t))\n\n        def focus(opacity=0.1):\n            for i in self.mobjects:\n                i.set_stroke(opacity=opacity)\n            v1.set_stroke(opacity=1)\n            v2.set_stroke(opacity=1)\n            field3.set_fill(opacity=opacity)\n            n.set_fill(opacity=opacity)\n        focus()\n        self.play(ll1.move_to, ORIGIN)\n        self.play(ApplyMethod(ll1.scale, 3))\n        self.wait()\n        w = ll1.get_width()\n        h = ll1.get_height()\n        line1 = Line((w / 2 - 1) * LEFT, w / 2 * RIGHT, color=YELLOW, stroke_width=6).shift(h / 2 * DOWN)\n        lbl1 = TexMobject('\\\\Delta s')\n        lbl1.shift((h / 2 + 1) * DOWN)\n        lbl1.scale(1.5)\n        lbl2 = TexMobject('F \\\\Delta t')\n        lbl2.shift((w / 2 + 1) * LEFT)\n        lbl2.scale(1.5)\n        lbv = Vector([0, h, 0], color=GREEN).shift(h / 2 * DOWN + w / 2 * RIGHT)\n        lbl3 = TexMobject('F \\\\Delta t \\\\cdot \\\\hat{n}')\n        lbl3.shift((w / 2 + 1.5) * RIGHT)\n        lbl3.scale(1.5)\n        hhead = TexMobject('\\\\text{Area} = (F \\\\cdot \\\\hat{n})(\\\\Delta t)(\\\\Delta s)')\n        rhead = BackgroundRectangle(hhead, color=BLACK, fill_opacity=1)\n        head = VGroup(rhead, hhead)\n        head.scale(1.5)\n        head.shift(3 * UP)\n        hhead2 = TexMobject('\\\\text{Area per unit time} = (F \\\\cdot \\\\hat{n})(\\\\Delta s)')\n        rhead2 = BackgroundRectangle(hhead2, color=BLACK, fill_opacity=1)\n        head2 = VGroup(rhead2, hhead2)\n        head2.scale(1.5)\n        head2.shift(3 * UP)\n        self.play(ShowCreation(line1), Write(lbl1))\n        self.wait()\n        self.play(Write(lbl2))\n        self.wait()\n        self.play(TransformFromCopy(v2, lbv))\n        self.play(Write(lbl3))\n        self.wait()\n        self.play(Write(head))\n        self.wait()\n        self.play(Transform(head, head2))\n        self.wait()\n        a = VGroup(*self.mobjects)\n        self.play(Uncreate(a))\n        feq = TexMobject('\\\\text{Flow rate over C} = \\\\int_C (\\\\vec{F} \\\\cdot \\\\hat{n}) \\\\ ds', tex_to_color_map={'\\\\text{Flow rate over C}': BLUE}).scale(2)\n        feq2 = TexMobject('\\\\text{Flux} = \\\\int_C (\\\\vec{F} \\\\cdot \\\\hat{n}) \\\\ ds', tex_to_color_map={'\\\\text{Flux}': BLUE}).scale(2)\n        self.play(Write(feq))\n        self.wait()\n        self.play(Transform(feq, feq2))\n        self.wait()\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n        return v\n\n    @staticmethod\n    def vect(x, y):\n        return np.array([x * y + x, x + y, 0])\n\n    @staticmethod\n    def func(t):\n        return np.array([1 - 2 * t ** 2 + 2, t ** 3 - 4 * t, 0])\n\n    def n(self, t):\n        vect = np.array([-3 * t ** 2 + 4, -4 * t, 0])\n        mag = math.sqrt(vect[0] ** 2 + vect[1] ** 2)\n        v = Vector(1 / mag * vect, color=GREEN).shift(self.func(t)[0] * RIGHT + self.func(t)[1] * UP)\n        return v\n\n    @staticmethod\n    def func2(t, a=9.6):\n        return np.array([a * (1 - 2 * t ** 2 - 0.4), a * (t ** 3 - 4 * t - 2.03), 0])"}]}
{"messages": [{"role": "user", "content": "Visualize a vector field and a curve, then animate the derivation of a line integral formula with changing equations."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass FluxExample(Scene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        axes = Axes(x_min=-5, x_max=5, y_min=-3, y_max=3, number_line_config={'include_tip': False})\n        f = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0) for x in np.arange(-5, 6, 1) for y in np.arange(-3, 4, 1)])\n        field = VGroup(axes, f)\n        c = ParametricFunction(self.func, t_min=0, t_max=2 * PI, stroke_width=1.5 * DEFAULT_STROKE_WIDTH)\n        curve = c\n        field.set_fill(opacity=0.75)\n        field.set_stroke(opacity=0.75)\n        rect = Rectangle(height=8, width=12)\n        grp = VGroup(field, curve, rect)\n        grp.scale(0.35)\n        grp.shift(3 * LEFT + 2.3 * UP)\n        eq1 = TexMobject('\\\\text{Find} \\\\int_C (\\\\vec{F} \\\\cdot \\\\hat{n}) \\\\ ds')\n        eq1.shift(3 * RIGHT + 3 * UP)\n        eq2 = TexMobject('F = \\\\langle xy + x, x + y \\\\rangle')\n        eq2.shift(3 * RIGHT + 2 * UP)\n        eq3 = TexMobject('C = \\\\langle \\\\cos(t), \\\\sin(t) \\\\rangle')\n        eq3.shift(3 * RIGHT + 1 * UP)\n        eq4 = TexMobject(\"\\\\int_C \\\\vec{F} \\\\cdot d\\\\vec{r} = \\\\int_a^b F(r(t)) \\\\ || r'(t) || \\\\ dt\")\n        eq4.shift(0 * UP)\n        eq5 = TexMobject(\"\\\\int_C (\\\\vec{F} \\\\cdot \\\\hat{n}) \\\\ ds = \\\\int_a^b (F(r(t)) \\\\cdot \\\\hat{n}(r(t)) )\\\\ || r'(t) || \\\\ dt\")\n        eq5.shift(1.5 * DOWN)\n        eq6 = TexMobject('\\\\int_C (\\\\vec{F} \\\\cdot \\\\hat{n}) \\\\ ds = \\\\int_0^{2\\\\pi} ' + '\\\\begin{bmatrix}\\\\cos(t)\\\\sin(t) + \\\\cos(t) \\\\\\\\ \\\\cos(t) + ' + '\\\\sin(t) \\\\end{bmatrix} \\\\cdot \\\\begin{bmatrix}\\\\cos(t) \\\\\\\\ \\\\sin(t)\\\\end{bmatrix} \\\\text{d}t')\n        eq6.shift(1.5 * DOWN)\n        eq7 = TexMobject('= 2 \\\\pi')\n        eq7.shift(3 * DOWN)\n        r1 = Rectangle(height=1, width=2, color=YELLOW)\n        r1.shift(3 * DOWN)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(eq2), Write(eq3))\n        self.play(ShowCreation(field), Write(rect))\n        self.play(Write(curve))\n        self.wait()\n        self.play(Write(eq4))\n        self.wait()\n        self.play(Write(eq5))\n        self.wait()\n        self.play(Transform(eq5, eq6))\n        self.wait()\n        self.play(Write(eq7))\n        self.play(Write(r1))\n        self.wait()\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n        return v\n\n    @staticmethod\n    def vect(x, y):\n        return np.array([x * y + x, x + y, 0])\n\n    @staticmethod\n    def func(t):\n        return np.array([math.cos(t), math.sin(t), 0])"}]}
{"messages": [{"role": "user", "content": "Display the 2D Divergence Theorem formula with colored terms and a title."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DivTwoEq(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\oint_C (\\\\vec{F} \\\\cdot \\\\hat{n}) \\\\ ds = \\\\iint_R \\\\nabla \\\\cdot \\\\vec{F} \\\\ dA', tex_to_color_map={'\\\\vec{F}': YELLOW, 'C': GREEN, 'R': BLUE, '\\\\nabla': RED})\n        eq.scale(1.5)\n        title = TextMobject('2D Divergence Theorem', color=PURPLE)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        self.play(Write(eq), Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display three vector fields and their corresponding divergence equations, transitioning between them."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DivDemo(Scene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0.1}\n\n    def construct(self):\n        axes_config = {'x_min': -5, 'x_max': 5, 'y_min': -4, 'y_max': 4, 'number_line_config': {'include_tip': False}}\n        axes = Axes(**axes_config)\n        f1 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.field1, prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-4, 5, 1)])\n        c = Circle(fill_color=RED, fill_opacity=0.25, color=WHITE, radius=1)\n        field1 = VGroup(axes, f1, c)\n        field1.scale(0.6)\n        axes = Axes(**axes_config)\n        f2 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.field2, prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-4, 5, 1)])\n        c = Circle(fill_color=RED, fill_opacity=0.25, color=WHITE, radius=1)\n        field2 = VGroup(axes, f2, c)\n        field2.scale(0.6)\n        axes = Axes(**axes_config)\n        f3 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.field3, prop=0) for x in np.arange(-5, 6, 1) for y in np.arange(-4, 5, 1)])\n        c = Circle(fill_color=RED, fill_opacity=0.25, color=WHITE, radius=1)\n        field3 = VGroup(axes, f3, c)\n        field3.scale(0.6)\n        t1 = TexMobject('\\\\nabla \\\\cdot \\\\textbf{F} > 0', tex_to_color_map={'>': YELLOW})\n        t1.shift(3 * UP)\n        b1 = BackgroundRectangle(t1, color=BLACK, fill_opacity=1)\n        text1 = VGroup(b1, t1)\n        t2 = TexMobject('\\\\nabla \\\\cdot \\\\textbf{F} < 0', tex_to_color_map={'<': YELLOW})\n        t2.shift(3 * UP)\n        b2 = BackgroundRectangle(t2, color=BLACK, fill_opacity=1)\n        text2 = VGroup(b2, t2)\n        t3 = TexMobject('\\\\nabla \\\\cdot \\\\textbf{F} > 0', tex_to_color_map={'>': YELLOW})\n        t3.shift(3 * UP)\n        b3 = BackgroundRectangle(t3, color=BLACK, fill_opacity=1)\n        text3 = VGroup(b3, t3)\n        self.play(Write(field1))\n        self.wait()\n        self.play(Write(text1))\n        self.wait()\n        self.play(Transform(field1, field2), Transform(text1, text2))\n        self.wait()\n        self.play(Transform(field1, field3), Transform(text1, text3))\n        self.wait()\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n        return v\n\n    @staticmethod\n    def field1(x, y):\n        return np.array([x, y])\n\n    @staticmethod\n    def field2(x, y):\n        return np.array([-x, -y])\n\n    @staticmethod\n    def field3(x, y):\n        return np.array([x + 6, 0])"}]}
{"messages": [{"role": "user", "content": "Visualize a vector field and demonstrate the divergence theorem by transforming a line integral along a curve into a surface integral."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DivTwoVisual(Scene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        axes_config = {'x_min': -5, 'x_max': 5, 'y_min': -5, 'y_max': 5, 'number_line_config': {'include_tip': False}}\n        axes = Axes(**axes_config)\n        f = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        field = VGroup(axes, f)\n        n = VGroup(*[self.n(t) for t in np.arange(-1.9, 2.001, 0.5)])\n        axes2 = Axes(**axes_config)\n        f2 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        f2.set_fill(opacity=0.5)\n        f2.set_stroke(opacity=0.5)\n        field2 = VGroup(axes, f2)\n        c = ParametricFunction(self.func, t_min=-2, t_max=2)\n        c.set_stroke(opacity=0.75)\n        label = TextMobject('C')\n        label.shift(3 * LEFT)\n        label.scale(2)\n        surface = ParametricSurface(self.surface, u_min=-2, u_max=2, v_min=-1, v_max=1, fill_color=BLUE, checkerboard_colors=[BLUE, BLUE], stroke_color=BLUE).set_fill(opacity=0.5)\n        surface.set_stroke(opacity=0.5)\n        curve = VGroup(label, c)\n        eq0 = self.getEq('\\\\int_C (\\\\vec{\\\\text{F}} \\\\cdot \\\\hat{n}) \\\\ ds')\n        eq1 = self.getEq('\\\\int_C (\\\\vec{\\\\text{F}} \\\\cdot \\\\hat{n}) \\\\ ds = ' + '\\\\int_{C_1} (\\\\vec{\\\\text{F}} \\\\cdot \\\\hat{n}) \\\\ ds + ' + '\\\\int_{C_2} (\\\\vec{\\\\text{F}} \\\\cdot \\\\hat{n}) \\\\ ds', tex_map={'{C_1}': RED, '{C_2}': GREEN})\n        eq2 = self.getEq('\\\\int_{C_r} (\\\\vec{\\\\text{F}} \\\\cdot \\\\hat{n}) \\\\ ds \\\\approx \\\\nabla \\\\cdot \\\\vec{\\\\text{F}} |r|')\n        eqf = self.getEq('\\\\int_C (\\\\vec{\\\\text{F}} \\\\cdot \\\\hat{n}) \\\\ ds = \\\\iint_D \\\\nabla \\\\cdot \\\\vec{\\\\text{F}} \\\\ \\\\text{dA}')\n        t1 = [1.225]\n        c1 = VGroup(*[Line(-self.func(t)[1] * UP, self.func(t)[1] * UP, color=RED, stroke_width=DEFAULT_STROKE_WIDTH * 2).shift(self.func(t)[0] * RIGHT) for t in t1], ParametricFunction(self.func, t_min=1.22, t_max=2, color=RED, stroke_width=DEFAULT_STROKE_WIDTH * 2), ParametricFunction(self.func, t_min=-2, t_max=-1.22, color=RED, stroke_width=DEFAULT_STROKE_WIDTH * 2), TexMobject('\\\\text{C}_1', color=RED).shift(2 * LEFT + 1.5 * UP).scale(1.5))\n        c2 = VGroup(*[Line(-self.func(t)[1] * UP, self.func(t)[1] * UP, color=GREEN, stroke_width=DEFAULT_STROKE_WIDTH * 2).shift(self.func(t)[0] * RIGHT) for t in t1], ParametricFunction(self.func, t_min=-1.22, t_max=1.22, color=GREEN, stroke_width=DEFAULT_STROKE_WIDTH * 2), TexMobject('\\\\text{C}_2', color=GREEN).shift(2 * RIGHT + 1.5 * UP).scale(1.5))\n        table2 = VGroup()\n        for t in np.arange(0, 2, 0.05):\n            y = self.func(t)[1]\n            x = self.func(t)[0]\n            roots = [i for i in np.roots([1, 0, -4, -x]) if 2 >= i.real >= -2 and i.imag == 0]\n            l1 = Line(-y * UP, y * UP, color=RED).shift(x * RIGHT)\n            if len(roots) >= 2:\n                l2 = Line(self.func(roots[0])[0] * RIGHT, self.func(roots[1])[0] * RIGHT, color=RED).shift(self.func(roots[0])[1] * UP)\n            table2.add(l1, l2)\n        self.play(ShowCreation(field))\n        self.wait()\n        self.play(Write(curve))\n        self.wait()\n        self.play(Write(n))\n        self.wait()\n        self.play(Transform(field, field2))\n        self.wait()\n        self.play(Write(eq0))\n        self.wait()\n        self.play(Uncreate(eq0), Write(c1))\n        self.wait()\n        self.play(Write(c2))\n        self.wait()\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Uncreate(eq1), Uncreate(c1), Uncreate(c2), Write(table2))\n        self.wait()\n        self.play(Write(eq2))\n        self.wait()\n        self.play(Uncreate(table2), Uncreate(eq2), Write(surface))\n        self.wait()\n        self.play(Write(eqf))\n        self.wait()\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n        return v\n\n    @staticmethod\n    def func(t):\n        return np.array([1 - 2 * t ** 2 + 2, t ** 3 - 4 * t, 0])\n\n    @staticmethod\n    def surface(t, v):\n        return np.array([1 - 2 * t ** 2 + 2, v * (t ** 3 - 4 * t), 0])\n\n    def getEq(self, eq, tex_map={}):\n        eq1 = TexMobject(eq, tex_to_color_map=tex_map)\n        back = BackgroundRectangle(eq1, color=BLACK, fill_opacity=1)\n        eq0 = VGroup(back, eq1)\n        eq0.shift(3 * UP)\n        return eq0\n\n    @staticmethod\n    def vect(x, y):\n        return np.array([x * y + x, x + y, 0])\n\n    def n(self, t):\n        vect = np.array([-3 * t ** 2 + 4, -4 * t, 0])\n        mag = math.sqrt(vect[0] ** 2 + vect[1] ** 2)\n        v = Vector(1 / mag * vect, color=GREEN).shift(self.func(t)[0] * RIGHT + self.func(t)[1] * UP)\n        return v"}]}
{"messages": [{"role": "user", "content": "Display the 3D Divergence Theorem and its alternative name, Gauss' Theorem, with specific color highlighting for mathematical symbols."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DivThreeEq(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\oiint_S \\\\vec{F} \\\\cdot d \\\\vec{S} = \\\\iiint_V \\\\nabla \\\\cdot \\\\vec{F} \\\\,dV', tex_to_color_map={'\\\\vec{F}': YELLOW, 'S': GREEN, 'V': BLUE, '\\\\nabla': RED})\n        eq.scale(1.5)\n        title = TextMobject('3D Divergence Theorem', color=PURPLE)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        title2 = TextMobject(\"Gauss' Theorem\", color=ORANGE)\n        title2.shift(2 * UP)\n        self.play(Write(eq), Write(title), Write(title2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a 3D animation showcasing a sphere with a vector field and a grid of colored vectors originating from its surface."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass IntP2(ThreeDScene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        s = Sphere()\n        n = VGroup(*[self.n(*self.func(u, v)) for u in np.arange(0, PI, 0.2) for v in np.arange(0, TAU, 0.2)])\n        axes = ThreeDAxes(number_line_config={'color': LIGHT_GREY, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        surface = VGroup(axes, s)\n        surface.scale(2)\n        f = VGroup(*[self.calc_field_color(x * RIGHT + y * UP + z * OUT, self.vect, prop=0, opacity=0.5) for x in np.arange(-5, 6, 1) for y in np.arange(-5, 6, 1) for z in np.arange(-3, 4, 1)])\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.play(Write(surface))\n        self.play(Write(f))\n        self.play(Write(n))\n        self.begin_ambient_camera_rotation()\n        self.wait(10)\n\n    def func(self, u, v):\n        return [np.cos(v) * np.sin(u), np.sin(v) * np.sin(u), np.cos(u)]\n\n    def vect(self, x, y, z):\n        return np.array([y, x, z])\n\n    def n(self, x, y, z):\n        vect = np.array([x, y, z])\n        mag = math.sqrt(vect[0] ** 2 + vect[1] ** 2 + vect[2] ** 2)\n        v = Vector(0.5 / mag * vect, color=GREEN, stroke_width=DEFAULT_STROKE_WIDTH).shift(2 * x * RIGHT + 2 * y * UP + 2 * z * OUT)\n        return v\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y, z = point[:]\n        func = f(x, y, z)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2 + func[2] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n            v.set_stroke(opacity=opacity)\n        return v"}]}
{"messages": [{"role": "user", "content": "Render a 3D parametric surface with a vector field colored by magnitude."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass IntP3(ThreeDScene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        s = ParametricSurface(self.func, u_min=0, u_max=TAU, v_min=0, v_max=TAU)\n        axes = ThreeDAxes(number_line_config={'color': LIGHT_GREY, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        surface = VGroup(axes, s)\n        surface.scale(2)\n        f = VGroup(*[self.calc_field_color(x * RIGHT + y * UP + z * OUT, self.vect, prop=0, opacity=0.5) for x in np.arange(-5, 6, 1) for y in np.arange(-5, 6, 1) for z in np.arange(-3, 4, 1)])\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.play(Write(surface))\n        self.play(Write(f))\n        self.begin_ambient_camera_rotation()\n        self.wait(10)\n\n    def func(self, u, v):\n        return [np.cos(v) * np.sin(u), np.sin(v) * np.cos(u), np.cos(u)]\n\n    def vect(self, x, y, z):\n        return np.array([y, x, z])\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y, z = point[:]\n        func = f(x, y, z)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2 + func[2] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n            v.set_stroke(opacity=opacity)\n        return v"}]}
{"messages": [{"role": "user", "content": "Present definitions for Electric Flux and Magnetic Flux with their respective formulas."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass EMFlux(Scene):\n\n    def construct(self):\n        t1 = TextMobject('Electric Flux', color=YELLOW).scale(1.5)\n        eq1 = TexMobject('\\\\phi_E = \\\\iint_S \\\\vec{E} \\\\cdot dS', tex_to_color_map={'E': YELLOW, 'S': PURPLE}).scale(1.5)\n        t1.shift(3 * UP)\n        eq1.shift(1 * UP)\n        self.play(Write(t1), Write(eq1))\n        self.wait()\n        t2 = TextMobject('Magnetic Flux', color=BLUE).scale(1.5)\n        eq2 = TexMobject('\\\\phi_B = \\\\iint_S \\\\vec{B} \\\\cdot dS', tex_to_color_map={'B': BLUE, 'S': PURPLE}).scale(1.5)\n        t2.shift(1 * DOWN)\n        eq2.shift(3 * DOWN)\n        self.play(Write(t2), Write(eq2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the mathematical definition of divergence, including its symbolic representation and component-wise expansion, with a title."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Div(Scene):\n\n    def construct(self):\n        title = TexMobject('\\\\text{div} \\\\textbf{F}', color=YELLOW).scale(1.5).shift(2.5 * UP)\n        eq = TexMobject(' = \\\\nabla \\\\cdot \\\\vec{F} = \\\\frac{\\\\partial F_x}{\\\\partial x} + \\\\frac{\\\\partial F_y}{\\\\partial y}').scale(1.5)\n        self.play(Write(eq), Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Write text animation of \"Divergence Theorem in 3D\" in blue."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DivThreeTitle(Scene):\n\n    def construct(self):\n        title = TextMobject('Divergence Theorem in 3D', color=BLUE)\n        title.scale(1.5)\n        self.play(Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a unit normal vector along the y-axis with a label and a bounding box."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Nhat(Scene):\n\n    def construct(self):\n        lbl = TexMobject('\\\\hat{n}')\n        lv = Vector([0, 1, 0], color=GREEN)\n        lv.center()\n        lbl.shift(0.25 * RIGHT)\n        lv.shift(0.25 * LEFT)\n        lr = Rectangle(height=1.5, width=1.5)\n        nll = VGroup(lr, lv, lbl)\n        self.play(Write(nll))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present Maxwell's Equations with a title and accompanying arrow."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass MaxWell(Scene):\n\n    def construct(self):\n        title = TextMobject(\"Maxwell's Equations\", color=YELLOW).scale(1.5).shift(3.5 * UP)\n        eq1 = TexMobject('\\\\nabla \\\\cdot \\\\vec{E} = \\\\frac{p}{\\\\epsilon_0}').shift(2 * UP)\n        a = Arrow(0.5 * UP, 0.5 * DOWN, color=GREEN).shift(1 * UP)\n        eq2 = TexMobject('\\\\oiint \\\\vec{E} \\\\cdot dS = \\\\frac{q}{\\\\epsilon_0}').shift(0 * DOWN)\n        self.play(Write(title))\n        self.play(Write(eq1), Write(a), Write(eq2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a complex plane with a unit circle traced by a parametric function, showing its position vector and velocity vector."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ECircle(Scene):\n\n    def construct(self):\n        plane = ComplexPlane()\n        plane.add(plane.get_coordinate_labels())\n        plane.scale(2, about_point=ORIGIN)\n        curve = ParametricFunction(function=self.r, t_min=0, t_max=0.01, color=YELLOW)\n        rtex = TexMobject('r(t) = e^{it}')\n        rtex.scale(1.5)\n        rb = BackgroundRectangle(rtex, fill_opacity=1, stroke_opacity=1)\n        rtitle = VGroup(rb, rtex)\n        rtitle.shift(3 * UP)\n        r0 = Vector(self.r(0), color=RED)\n        v0 = Vector(self.v(0), color=GREEN).shift(self.r(0))\n        r0tex = TexMobject('r(0) = 1+0i')\n        r0tex.scale(1.5)\n        r0b = BackgroundRectangle(r0tex, fill_opacity=1, stroke_opacity=1)\n        r0title = VGroup(r0b, r0tex)\n        r0title.shift(3 * RIGHT)\n        self.play(Write(plane))\n        self.wait()\n        self.play(Write(rtitle))\n        self.wait()\n        self.play(Write(r0), Write(curve), Write(v0))\n        self.wait()\n        self.play(UpdateFromAlphaFunc(r0, self.update_position), UpdateFromAlphaFunc(curve, self.update_curve), UpdateFromAlphaFunc(v0, self.update_velocity), rate_func=linear, run_time=2)\n        self.wait()\n\n    def r(self, t, a=2):\n        return a * np.array([np.cos(t), np.sin(t), 0])\n\n    def v(self, t, a=2):\n        return a * np.array([-np.sin(t), np.cos(t), 0])\n\n    def update_position(self, c, dt):\n        a = interpolate(0, 2 * PI, dt)\n        c1 = Vector(self.r(a), color=RED)\n        c.become(c1)\n\n    def update_curve(self, c, dt):\n        a = interpolate(0.01, 2 * PI, dt)\n        curve2 = ParametricFunction(function=self.r, t_min=0, t_max=a, color=YELLOW)\n        c.become(curve2)\n\n    def update_velocity(self, c, dt):\n        a = interpolate(0, 2 * PI, dt)\n        c1 = Vector(self.v(a), color=GREEN).shift(self.r(a))\n        c.become(c1)"}]}
{"messages": [{"role": "user", "content": "Create a blank Manim scene."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        pass"}]}
{"messages": [{"role": "user", "content": "Display four card images, then a brace labeling a line with 'N', and finally transform a question about drawing cards into one about expected value."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        cards = VGroup()\n        m = [5, 2, -2, -5]\n        for i in range(1, 5):\n            cards.add(ImageMobject(f'./img/card{i}.jpg').shift(m[i - 1] * LEFT).scale(1.5))\n        cards.add(TexMobject('...').scale(2))\n        cards.shift(1 * UP)\n        for i in range(0, 4):\n            self.play(FadeInFromDown(cards[i]), run_time=0.5)\n        self.play(Write(cards[4]))\n        l = Line(6.1 * LEFT, 6.1 * RIGHT).shift(0.75 * DOWN)\n        b = Brace(l)\n        lbl = b.get_tex('N').scale(1.5).shift(0.25 * DOWN).set_color(TEAL)\n        brace = VGroup(b, lbl)\n        cards.add(brace)\n        self.play(Write(brace))\n        self.wait()\n        self.play(cards.shift, 1 * UP)\n        q = TextMobject('How many draws to get all \\\\( N \\\\) cards?', tex_to_color_map={'\\\\( N \\\\)': TEAL})\n        q.scale(1.5)\n        q.shift(2.5 * DOWN)\n        self.play(Write(q))\n        self.wait()\n        q2 = TextMobject('Expected value of number of draws to get all \\\\( N \\\\) cards', tex_to_color_map={'Expected value': GOLD, '\\\\( N \\\\)': TEAL})\n        q2.scale(1.1)\n        q2.shift(2.5 * DOWN)\n        self.play(Transform(q, q2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the calculation of expected value with a title, a probability tree, labeled outcomes and probabilities, and the final formula."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ExpectedValue(Scene):\n\n    def construct(self):\n        title = TextMobject('Expected value', color=GOLD)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        title2 = TextMobject('Expected value', '= predicted outcome', tex_to_color_map={'Expected value': GOLD})\n        title2.scale(1.5)\n        title2.shift(3 * UP)\n        self.play(FadeInFromDown(title))\n        self.wait()\n        self.play(Transform(title, title2[0]))\n        self.play(FadeInFromDown(title2[1]))\n        srect = ScreenRectangle(height=5, width=7).shift(0.5 * DOWN)\n        self.play(Write(srect))\n        self.wait()\n        tree = TreeMobject([1, 2])\n        tree.add_labels(1, ['\\\\text{H}', '\\\\text{T}'])\n        tree.scale(3)\n        tree.shift(4 * LEFT + 0 * DOWN)\n        lbl1 = TexMobject('x_1 = + \\\\$ 10', '\\\\cdot p_1 = 0.5', tex_to_color_map={'x_1': BLUE, '+ \\\\$ 10': GREEN, 'p_1': ORANGE, '0.5': GREEN})\n        lbl1.scale(1)\n        lbl1.shift(1 * UP + 1 * RIGHT)\n        lbl2 = TexMobject('x_2 = - \\\\$ 5', '\\\\cdot p_2 = 0.5', tex_to_color_map={'x_2': BLUE, '- \\\\$ 5': GREEN, 'p_2': ORANGE, '0.5': GREEN})\n        lbl2.scale(1)\n        lbl2.shift(1 * DOWN + 1 * RIGHT)\n        self.play(Uncreate(srect))\n        self.play(Write(tree))\n        self.wait()\n        self.play(FadeInFromDown(lbl1))\n        self.play(FadeInFromDown(lbl2))\n        self.wait()\n        ans1 = TextMobject('\\\\( = 5 \\\\)', alignment='').scale(1.5)\n        ans2 = TextMobject('\\\\( = -2.5 \\\\)', alignment='').scale(1.5)\n        ans1.shift(1 * UP + 4.4 * RIGHT)\n        ans2.shift(1 * DOWN + 5 * RIGHT)\n        self.play(Write(ans1))\n        self.play(Write(ans2))\n        self.wait()\n        line = Line(3.5 * RIGHT, 6.5 * RIGHT)\n        line.shift(2 * DOWN)\n        self.play(Write(line))\n        ans = TexMobject('E[{x}] = \\\\sum x_i p_i = ', '2.5', tex_to_color_map={'E': GOLD, '{x}': BLUE, 'x_i': BLUE, 'p_i': ORANGE}).scale(1.5)\n        ans.shift(3 * DOWN + 2.1 * RIGHT)\n        self.play(Write(ans[-1]))\n        brect = BackgroundRectangle(ans[-1], color=YELLOW, buff=0.2, fill_opacity=0, stroke_opacity=1, stroke_width=4)\n        self.play(Write(brect))\n        self.wait()\n        self.play(FadeInFromDown(ans[:-1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show three pairs of coin flips, color two pairs red and orange and the third yellow and gold, label the first two as \"tails\" and the third as \"heads\" with braces, and then reveal the probability of getting tails three times in a row as 1/8."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Tails(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\left ( \\\\frac{1}{2} \\\\right )', '\\\\left ( \\\\frac{1}{2} \\\\right )', '\\\\left ( \\\\frac{1}{2} \\\\right )').scale(2)\n        eq1[:2].set_color_by_gradient(RED, ORANGE)\n        eq1[2].set_color(YELLOW, GOLD)\n        b1 = Brace(eq1[:2])\n        l1 = b1.get_tex('\\\\text{tails}')\n        brace1 = VGroup(b1, l1)\n        b2 = Brace(eq1[-1])\n        l2 = b2.get_tex('\\\\text{heads}')\n        brace2 = VGroup(b2, l2)\n        self.play(Write(eq1))\n        self.play(Write(brace1), Write(brace2))\n        self.wait()\n        ans = TexMobject('=  \\\\frac{1}{8}')\n        ans.scale(2)\n        ans.shift(3.2 * RIGHT)\n        self.play(ApplyMethod(eq1.shift, 1.3 * LEFT), ApplyMethod(brace1.shift, 1.3 * LEFT), ApplyMethod(brace2.shift, 1.3 * LEFT))\n        self.play(FadeInFromDown(ans))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present the definition of a Bernoulli trial with a title and bullet points, then sequentially highlight each point before resetting the display."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Bernoulli(Scene):\n\n    def construct(self):\n        title = TextMobject('Bernoulli Trial', color=TEAL)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        b = BulletedList('Trial is independent', 'Trial has two outcomes', \"Probability of success doesn't change\", dot_scale_factor=5).scale(1.5)\n        self.play(Write(title))\n        self.play(Write(b))\n        self.wait()\n        for i in range(0, 3):\n            self.play(b.fade_all_but, i)\n            self.wait()\n        self.play(b.reset)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Simulate a rolling die showing a random sequence of values before landing on a specific outcome."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ExpectBern(Scene):\n\n    def construct(self):\n        self.d = RollingDice()\n        self.add(self.d)\n        self.roll(5)\n        self.wait()\n\n    def roll(self, value=None, time=2, a=2):\n        value = random.randint(1, 6) if value is None else value\n        t = 0.01\n        while t < time:\n            v = random.randint(1, 6)\n            self.d.set_value(v)\n            self.wait(t)\n            t *= a\n        self.d.set_value(value)"}]}
{"messages": [{"role": "user", "content": "Show the expected value formula for a single die roll, then substitute the probability and highlight the result."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DiceExp(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('E[x] = \\\\frac{1}{p}', tex_to_color_map={'E': GOLD, 'p': GREEN, 'x': TEAL})\n        eq1.scale(1.5)\n        eq1.shift(2.5 * UP)\n        self.play(Write(eq1))\n        self.wait()\n        eq2 = TexMobject('p = \\\\frac{1}{6}', tex_to_color_map={'p': GREEN})\n        eq2.scale(1.5)\n        eq3 = TexMobject('E[x] = \\\\frac{1}{1/6} = ', '6', tex_to_color_map={'E': GOLD, 'x': TEAL})\n        eq3.scale(1.5)\n        eq3.shift(2.5 * DOWN)\n        rect = BackgroundRectangle(eq3[-1], stroke_opacity=1, stroke_width=4, fill_opacity=0, color=YELLOW, buff=0.2)\n        self.play(Write(eq2))\n        self.play(Write(eq3))\n        self.play(Write(rect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the coupon collector's problem by displaying coupons and transforming mathematical formulas to show the expected number of coupons needed."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass CouponCalc(Scene):\n\n    def construct(self):\n        have = VGroup()\n        for i in range(1, 6):\n            have.add(NumberedCoupon(i).scale(0.5).shift((3 - 1.5 * (i - 1)) * RIGHT))\n        have.shift(2.5 * UP + 0.5 * RIGHT)\n        dont = VGroup()\n        for i in range(1, 6):\n            dont.add(NumberedCoupon(i, color=GREEN).scale(0.5).shift((3 - 1.5 * (i - 1)) * RIGHT))\n        dont.shift(0.5 * RIGHT)\n        t1 = TextMobject(\"Don't Have:\", alignment='', color=YELLOW)\n        t1.scale(1)\n        t1.shift(2.5 * UP + 5 * LEFT)\n        t2 = TextMobject('Have:', color=GREEN)\n        t2.scale(1)\n        t2.shift(5.6 * LEFT)\n        eq1 = TexMobject('\\\\text{P}(\\\\text{new coupon}) = {', '5', '\\\\over 5} = 1.00', tex_to_color_map={'\\\\text{P}': TEAL, '\\\\text{new coupon}': ORANGE})\n        eq1.scale(1.5)\n        eq1.shift(2.5 * DOWN)\n        eq1[-2].set_color(GOLD)\n        self.play(Write(have), Write(dont), Write(t1), Write(t2))\n        self.play(Write(eq1))\n        self.wait()\n        a = [3, 0, 1, 2, 4]\n        val = list(range(4, -1, -1))\n        for i in range(5):\n            eq = TexMobject('\\\\text{P}(\\\\text{new coupon}) = {', str(val[i]), '\\\\over 5} = ' + '{0:.2f}'.format(val[i] / 5), tex_to_color_map={'\\\\text{P}(\\\\text{new coupon})': TEAL})\n            eq[-2].set_color(GOLD)\n            eq.scale(1.5)\n            eq.shift(2.5 * DOWN)\n            self.play(Transform(have[a[i]], dont[a[i]]))\n            self.play(Transform(eq1[-2], eq[-2]), Transform(eq1[-1], eq[-1]))\n            self.wait()\n        self.play(Uncreate(dont), Uncreate(have), Uncreate(eq1[4:]), Uncreate(t1), Uncreate(t2))\n        self.play(eq1[:4].shift, 5 * UP)\n        self.wait()\n        eq2 = TexMobject('\\\\frac{5-i}{5}')\n        eq2.scale(1.5)\n        eq2.shift(2.5 * UP + 2.5 * RIGHT)\n        self.play(Write(eq2))\n        self.wait()\n        eq3 = TexMobject('{N-i \\\\over N}', tex_to_color_map={'N': GREEN, 'i': YELLOW})\n        eq4 = TexMobject('p_i = ', tex_to_color_map={'p': TEAL, 'i': YELLOW})\n        eq3.scale(1.5)\n        eq4.scale(1.5)\n        eq3.shift(2.5 * UP + 1 * RIGHT)\n        eq4.shift(2.5 * UP + 1 * LEFT)\n        self.play(Transform(eq2, eq3), Transform(eq1[:4], eq4))\n        self.wait()\n        eq5 = TexMobject('E[i^{\\\\text{th}}\\\\text{ new coupon}] =', '{1 \\\\over {{p} _{ i }} } ', tex_to_color_map={'i': YELLOW, 'E': GOLD, '\\\\text{ new coupon}': ORANGE})\n        eq5.scale(1.5)\n        self.play(Write(eq5))\n        self.wait()\n        eq6 = TexMobject('{N \\\\over N-i}', tex_to_color_map={'N': GREEN, 'i': YELLOW})\n        eq6.scale(1.5)\n        eq6.shift(4 * RIGHT)\n        self.play(Transform(eq5[6:], eq6))\n        self.wait()\n        self.play(Uncreate(eq2), Uncreate(eq1), ApplyMethod(VGroup(*self.mobjects).shift, 2.5 * UP))\n        eq7 = TexMobject('E[n] = E[n-1] + {{1} \\\\over {p_{n-1}}', tex_to_color_map={'n': YELLOW, 'E': GOLD})\n        eq7.scale(1.5)\n        self.play(Write(eq7))\n        self.wait()\n        eq8 = TexMobject('E[n] = E[n-2] + \\\\frac{1}{p_{n-1}}', '+ \\\\frac{1}{p_{n-2}}', tex_to_color_map={'n': YELLOW, 'E': GOLD})\n        eq8.scale(1.5)\n        self.play(Transform(eq7, eq8))\n        self.wait()\n        eq9 = TexMobject('E[n] = E[n-3] + \\\\frac{1}{p_{n-1}}', '+ \\\\frac{1}{p_{n-2}}', '+ \\\\frac{1}{p_{n-2}}', tex_to_color_map={'n': YELLOW, 'E': GOLD})\n        eq9.scale(1.5)\n        self.play(Transform(eq7, eq9))\n        self.wait()\n        eq10 = TexMobject('E[n] = \\\\frac{1}{p_{0}}', '+ \\\\frac{1}{p_{1}} + ...', '+ \\\\frac{1}{p_{n-1}}', tex_to_color_map={'n': YELLOW, 'E': GOLD})\n        eq10.scale(1.5)\n        self.play(Transform(eq7, eq10))\n        self.wait()\n        eq11 = TexMobject('E[n] = {{N} \\\\over {N}}', '+ {{N} \\\\over { N - 1 }} + ...', '+ {{N} \\\\over {1}}', tex_to_color_map={'n': YELLOW, 'E': GOLD})\n        eq11.scale(1.5)\n        self.play(Transform(eq7, eq11))\n        self.wait()\n        eq11 = TexMobject('E[n] = {N} \\\\left ( {{1} \\\\over {N}} + {{1} \\\\over { N - 1 }} + ... + {{1} \\\\over {1}} \\\\right )', tex_to_color_map={'n': YELLOW, 'E': GOLD})\n        eq11.scale(1.5)\n        self.play(Transform(eq7, eq11))\n        self.wait()\n        eq12 = TexMobject('E[n] = N \\\\left ( {{1} \\\\over {1}} + {{1} \\\\over {2}} + ... + {{1} \\\\over {N}} \\\\right )', tex_to_color_map={'n': YELLOW, 'E': GOLD})\n        eq12.scale(1.5)\n        self.play(Transform(eq7, eq12))\n        self.wait()\n        eq13 = TexMobject('E[n] = N \\\\cdot H_N', tex_to_color_map={'n': YELLOW, 'E': GOLD, 'N': GREEN, 'H': PURPLE})\n        eq13.scale(1.5)\n        self.play(Transform(eq7, eq13))\n        rect = BackgroundRectangle(eq13, buff=0.2, color=YELLOW, stroke_opacity=1, fill_opacity=0, stroke_width=4)\n        self.play(Write(rect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render a series of gradient-colored rectangles representing a function's values with labels at the bottom."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Asymptote(Scene):\n    CONFIG = {'max_n': 77, 'skip': 4, 'x_min': -6, 'x_max': 6, 'buff': 0.4}\n\n    def construct(self):\n        rects = VGroup()\n        width = (abs(self.x_min) + abs(self.x_max)) / (self.max_n / self.skip)\n        for i in range(int(self.max_n / self.skip)):\n            height = 0.1 * coupon(i)\n            lbl = TexMobject(str(self.skip * i))\n            rects.add(Rectangle(width=width - self.buff, height=0.1 * coupon(i), fill_opacity=1).shift([i * width + self.x_min, -4 + height / 2, 0]).set_color_by_gradient(RED, BLUE))\n            rects.add(lbl.next_to(rects[-1], DOWN))\n        rects.shift(1 * UP)\n        self.play(Write(rects))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize domino tilings of a grid and demonstrate transformations between different tiling permutations, labeling the grid dimensions as M and N and concluding with a statement about their product."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Tilings(Scene):\n\n    def construct(self):\n        grid = DominoGrid(4, 4, s_width=1.5, s_length=1.5)\n        rects1 = grid.get_perm((4, 1, 9, 3, 12, 6, 14, 11))\n        rects2 = grid.get_perm((0, 1, 6, 3, 4, 9, 12, 11))[1:]\n        rects2.add(grid.get_rect(14, 15))\n        rects2.add(grid.get_rect(0, 1).shift(1.5 * LEFT))\n        rects3 = grid.get_perm((4, 1, 9, 3, 12, 6, 14, 11))\n        rects4 = grid.get_perm((1, 3, 9, 11, 4, 6, 12, 14))\n        rects5 = grid.get_perm((1, 3, 4, 6, 9, 11, 12, 14))\n        m = TexMobject('M')\n        m.shift(4 * LEFT)\n        m.scale(1.5)\n        n = TexMobject('N')\n        n.shift(3.5 * DOWN)\n        n.scale(1.5)\n        cross = VGroup()\n        cross.add(Line(3.5 * UP + 3.5 * RIGHT, 3.5 * DOWN + 3.5 * LEFT, color=RED, stroke_width=8))\n        cross.add(Line(3.5 * UP + 3.5 * LEFT, 3.5 * DOWN + 3.5 * RIGHT, color=RED, stroke_width=8))\n        self.play(ShowCreation(grid))\n        self.play(FadeInFromDown(m), FadeInFromDown(n))\n        self.wait()\n        self.play(Write(rects1))\n        self.wait()\n        self.play(Transform(rects1, rects2))\n        self.play(ShowCreation(cross))\n        self.wait()\n        self.play(Uncreate(cross))\n        self.play(Transform(rects1, rects3))\n        self.wait()\n        self.play(Transform(rects1, rects4))\n        self.wait()\n        self.play(Transform(rects1, rects5))\n        self.wait()\n        group = VGroup(grid, rects1, m, n)\n        self.play(group.shift, 2 * LEFT)\n        eq = TexMobject('M \\\\cdot N \\\\text{ is even}', tex_to_color_map={'M \\\\cdot N': BLUE})\n        eq.scale(1.5)\n        eq.shift(4 * RIGHT)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the generation of the Fibonacci sequence, showing the numbers appearing and the formula at the end."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Recursion(Scene):\n\n    def construct(self):\n        title = TextMobject('Fibonacci Sequence', color=TEAL)\n        title.scale(2)\n        title.shift(3 * UP)\n        n1 = TexMobject('1').scale(3)\n        n2 = TexMobject('1').scale(3)\n        n1.shift(3 * LEFT)\n        n2.shift(0 * LEFT)\n        grp = VGroup(n1, n2)\n        n3 = TexMobject('2').scale(3)\n        n3.shift(3 * RIGHT)\n        self.play(Write(title))\n        self.play(Write(grp))\n        self.wait()\n        self.play(TransformFromCopy(grp, n3))\n        self.wait()\n        grp.add(n3)\n        self.play(Uncreate(n1))\n        self.play(grp.shift, 3 * LEFT)\n        n4 = TexMobject('3').scale(3)\n        n4.shift(3 * RIGHT)\n        self.play(TransformFromCopy(grp, n4))\n        self.wait()\n        grp.add(n4)\n        self.play(Uncreate(n2))\n        self.play(grp.shift, 3 * LEFT)\n        n5 = TexMobject('5').scale(3)\n        n5.shift(3 * RIGHT)\n        self.play(TransformFromCopy(grp, n5))\n        self.wait()\n        grp.add(n5)\n        self.play(Uncreate(grp))\n        eq = TexMobject('F_n = F_{n-1} + F_{n-2}')\n        eq.scale(2.5)\n        self.play(FadeInFromDown(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a 5x2 domino grid and then write a group of vertical purple rectangles above and below the grid."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TwoByNExample(Scene):\n\n    def construct(self):\n        grid = DominoGrid(5, 2, s_width=1.5, s_length=1.5)\n        rects = VGroup()\n        for i in np.arange(-3, 3.1, 1.5):\n            rect = Rectangle(width=1, height=2.5, fill_opacity=1, stroke_color=WHITE, color=PURPLE).shift(i * RIGHT)\n            rects.add(rect)\n        self.play(ShowCreation(grid))\n        self.wait()\n        self.play(Write(rects))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show the equation \"T(m, n)\" with colored m and n, an arrow, and text describing it as the number of ways to tile M x N."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Tmn(Scene):\n\n    def construct(self):\n        eq = TexMobject('T(m, n)', tex_to_color_map={'m': RED, 'n': GREEN})\n        eq.scale(2)\n        eq.shift(3 * LEFT)\n        arrow = Arrow(LEFT, RIGHT, color=TEAL)\n        text = TextMobject('Number of ways \\\\\\\\ to tile M x N', tex_to_color_map={'M': RED, ' N': GREEN})\n        text.scale(1.25)\n        text.shift(3.5 * RIGHT)\n        self.play(FadeInFromDown(eq))\n        self.play(FadeInFromDown(arrow))\n        self.play(FadeInFromDown(text))"}]}
{"messages": [{"role": "user", "content": "Visualize the recurrence relation for tiling a 2xn grid with dominoes, transforming the visualization as the relation is presented."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TwoByN(Scene):\n\n    def construct(self):\n        eq = TexMobject('T(2, n)', '= T(2, n-1)', '+ T(2, n-2)', tex_to_color_map={'-2': RED, '-1': RED, 'n': GREEN})\n        eq.scale(1.5)\n        eq.shift(3 * UP)\n        grid = DominoGrid(5, 2, s_width=1.5, s_length=1.5)\n        rect = Rectangle(width=1, height=2.5, fill_opacity=1, stroke_color=WHITE, color=PURPLE).shift(3 * RIGHT)\n        rect2 = Rectangle(width=5.5, height=2.5, fill_opacity=1, stroke_color=WHITE, color=GRAY).shift(0.75 * LEFT)\n        self.play(FadeInFromDown(eq[:3]))\n        self.play(Write(grid))\n        self.wait()\n        self.play(Write(rect))\n        self.play(Write(rect2))\n        self.wait()\n        text1 = TexMobject('T(2, n-1)')\n        text1.scale(1.5)\n        text1.shift(0.75 * LEFT)\n        self.play(FadeInFromDown(text1))\n        self.play(FadeInFromDown(eq[3:7]))\n        self.wait()\n        rects = VGroup(Rectangle(width=2.5, height=1, fill_opacity=1, stroke_color=WHITE, color=PURPLE).shift(2.25 * RIGHT + 0.75 * UP), Rectangle(width=2.5, height=1, fill_opacity=1, stroke_color=WHITE, color=PURPLE).shift(2.25 * RIGHT - 0.75 * UP))\n        self.play(Uncreate(rect2), Uncreate(text1))\n        self.play(Transform(rect, rects))\n        rect3 = Rectangle(width=4, height=2.5, fill_opacity=1, stroke_color=WHITE, color=GRAY).shift(1.5 * LEFT)\n        text2 = TexMobject('T(2, n-2)')\n        text2.scale(1.5)\n        text2.shift(1.5 * LEFT)\n        self.play(Write(rect3))\n        self.play(FadeInFromDown(text2))\n        self.play(FadeInFromDown(eq[7:]))\n        self.wait()\n        fib = TexMobject('T(2, n) = F_{n + 1}', tex_to_color_map={'n': GREEN, 'F': TEAL})\n        fib.scale(1.5)\n        fib.shift(2.5 * DOWN)\n        rect = BackgroundRectangle(fib, buff=MED_SMALL_BUFF, color=YELLOW, stroke_opacity=1, stroke_width=6, fill_opacity=0)\n        self.play(FadeInFromDown(fib))\n        self.play(Write(rect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a scene showing a binary tree, a matrix, and two text labels, \"Graph Theory\" and \"Linear Algebra,\" arranged with the tree and matrix on opposite sides above the text labels."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass NewTopics(Scene):\n\n    def construct(self):\n        tree = TreeMobject((1, 2, 4))\n        tree.rotate(PI / 2, axis=IN)\n        tree.shift(3 * LEFT + UP)\n        g = TextMobject('Graph Theory')\n        g.scale(1.25)\n        g.shift(3 * LEFT + 2 * DOWN)\n        l = TextMobject('Linear Algebra')\n        l.scale(1.25)\n        l.shift(3 * RIGHT + 2 * DOWN)\n        matrix = TexMobject('\\\\begin{bmatrix} 1 & 2 & 3\\\\\\\\ 4 & 5 & 6 \\\\end{bmatrix}')\n        matrix.scale(1.5)\n        matrix.shift(3 * RIGHT + UP)\n        self.play(Write(tree), Write(matrix))\n        self.play(FadeInFromDown(g), FadeInFromDown(l))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a 4x4 grid transforming into a graph, then animate the rearrangement of edges within that graph."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass GridGraphIntro(Scene):\n\n    def construct(self):\n        g = GridGraph(4, 4, s_width=1.5)\n        g2 = GridGraph(4, 4, s_width=1.5)\n        g2.set_stroke(opacity=0.2)\n        grid = Grid(4, 4, s_width=1.5, s_length=1.5)\n        grid1 = Grid(4, 4, s_width=1.5, s_length=1.5)\n        grid1.set_stroke(opacity=0.1)\n        self.play(Write(grid))\n        self.wait()\n        self.play(Transform(grid, grid1))\n        self.play(Write(g))\n        self.wait()\n        edges1 = g.get_perm((4, 1, 9, 3, 12, 6, 14, 11))\n        edges2 = g.get_perm((1, 3, 9, 11, 4, 6, 12, 14))\n        edges3 = g.get_perm((1, 3, 4, 6, 9, 11, 12, 14))\n        self.play(Uncreate(grid))\n        self.play(Transform(g, g2))\n        self.play(Write(edges1))\n        self.wait()\n        self.play(Transform(edges1, edges2))\n        self.wait()\n        self.play(Transform(edges1, edges3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display two perfect bipartite graphs side-by-side with a title above them."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass BipartiteGraphs(Scene):\n\n    def construct(self):\n        b1 = PerfectBipartiteGraph()\n        b1.add_perm([[0, 1, 2] for i in range(3)])\n        b2 = PerfectBipartiteGraph()\n        b2.add_perm([[1], [2], [0]])\n        b1.shift(2.5 * LEFT)\n        b2.shift(2.5 * RIGHT)\n        title = TextMobject('Bipartite Graphs', color=GOLD)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        self.play(FadeInFromDown(title))\n        self.play(Write(b1), Write(b2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a grid graph transforming into a black and white version, then into a slightly faded black and white version with labels appearing."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass GridGraphBipartite(Scene):\n\n    def construct(self):\n        g = GridGraph(4, 4, s_width=1.5)\n        g2 = GridGraph(4, 4, s_width=1.5)\n        g2.set_black_white()\n        g3 = GridGraph(4, 4, s_width=1.5)\n        g3.set_black_white()\n        g3.lines.set_opacity(0.3)\n        self.play(Write(g))\n        self.wait()\n        self.play(Transform(g, g2))\n        self.wait()\n        labels = g3.get_labels()\n        self.play(Transform(g, g3))\n        self.play(FadeInFromDown(labels))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create an adjacency matrix animation that visualizes a graph, highlights its matrix representation, and connects the matrix to the graph."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass AdjacencyMatrix(Scene):\n\n    def construct(self):\n        title = TextMobject('Adjacency Matrix', color=TEAL)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        vals = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n        mat = Matrix(vals)\n        mat.shift(3 * RIGHT)\n        graph = PerfectBipartiteGraph()\n        graph.add_perm([[1], [2], [0]])\n        rect = BackgroundRectangle(mat.nums[0], buff=0.2, stroke_opacity=1, stroke_width=6, fill_opacity=0, color=YELLOW)\n        line = graph.get_edge(0, 4).set_stroke(width=8, color=YELLOW).shift(3 * LEFT)\n        self.play(FadeInFromDown(title))\n        self.wait()\n        self.play(Write(graph))\n        self.wait()\n        self.play(graph.shift, 3 * LEFT)\n        self.play(Write(mat))\n        self.wait()\n        self.play(Write(rect))\n        self.wait()\n        self.play(ApplyMethod(rect.shift, 1 * RIGHT), Write(line))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display an adjacency matrix named 'A' within the scene."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass AdjScene(Scene):\n    CONFIG = {'mat': 'A=\\\\left[\\\\begin{array}{llllllll} \\\\\\n            1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\\\\ \\\\\\n            1 & 1 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\\\\ \\\\\\n            0 & 1 & 1 & 0 & 0 & 1 & 0 & 0 \\\\\\\\ \\\\\\n            1 & 0 & 1 & 1 & 1 & 0 & 0 & 0 \\\\\\\\ \\\\\\n            0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 \\\\\\\\ \\\\\\n            0 & 0 & 1 & 0 & 1 & 1 & 1 & 0 \\\\\\\\ \\\\\\n            0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\\\\ \\\\\\n            0 & 0 & 0 & 0 & 1 & 0 & 1 & 1 \\\\\\n            \\\\end{array}\\\\right]'}"}]}
{"messages": [{"role": "user", "content": "Display three lines of text explaining a matrix problem, with specific words colored differently, and animate the text appearing from the bottom."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass NewQuestion(Scene):\n\n    def construct(self):\n        eqn = TexMobject('\\\\text{Given adjacency matrix } A', tex_to_color_map={'A': RED})\n        eq1 = TexMobject('\\\\text{Find some matrix } \\\\hat{A} \\\\text{ such that}', tex_to_color_map={'A': RED})\n        eq2 = TexMobject('| \\\\text{det}( \\\\hat{A} ) |  = \\\\text{per}(A)', ' = T(m, n)', tex_to_color_map={'\\\\text{per}': GOLD, '\\\\text{det}': BLUE, 'A': RED, 'm': RED, 'n': GREEN})\n        eqn.shift(2 * UP)\n        eq1.shift(1 * UP)\n        eq2.shift(1 * DOWN)\n        eq2.scale(2)\n        grp = VGroup(eqn, eq1)\n        self.play(FadeInFromDown(grp))\n        self.play(FadeInFromDown(eq2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a grid graph and associated mathematical expressions related to the Kastelyn signing, culminating in a calculation of the determinant."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SigningIntro(Scene):\n\n    def construct(self):\n        graph = GridGraph(3, 2, s_width=1.5)\n        graph.set_black_white()\n        graph.lines.set_stroke(opacity=0.5)\n        labels = graph.get_labels()\n        g = VGroup(graph, labels)\n        g.center()\n        e = TexMobject('\\\\text{Edge } e', tex_to_color_map={'\\\\text{Edge }': RED}).scale(1.5)\n        s = TexMobject('\\\\sigma', color=YELLOW).scale(2)\n        o = TexMobject('\\\\pm 1', color=BLUE).scale(1.5)\n        a1 = Arrow(1.5 * LEFT, 0.5 * LEFT, buff=10, color=PURPLE).shift(3 * UP)\n        a2 = Arrow(0.5 * RIGHT, 1.5 * RIGHT, buff=10, color=PURPLE).shift(3 * UP)\n        e.shift(3 * LEFT + 3 * UP)\n        o.shift(2.5 * RIGHT + 3 * UP)\n        s.shift(3 * UP)\n        grp = VGroup(e, s, o, a1, a2)\n        weights = VGroup()\n        n = 1\n        for x in [-0.75, 0.75]:\n            for y in [-0.75, 0.75]:\n                l = TexMobject('1', color=BLUE).shift([x, y, 0]).scale(0.75)\n                weights.add(l)\n                n = -n\n        weights.add(TexMobject('-1', color=BLUE).shift([-1.8, 0, 0]).scale(0.75), TexMobject('-1', color=BLUE).shift([1.8, 0, 0]).scale(0.75), TexMobject('1', color=BLUE).shift([0.3, 0, 0]).scale(0.75))\n        grp2 = VGroup(g, weights)\n        grp2.scale(1.5)\n        self.play(FadeInFromDown(grp), FadeInFromDown(g), FadeInFromDown(weights))\n        self.wait()\n        mat = TexMobject('A^{\\\\sigma}=\\\\left[\\\\begin{array}{ccc} \\\\\\n            1 & 0 & -1 \\\\\\\\ \\\\\\n            1 & -1 & 0 \\\\\\\\ \\\\\\n            1 & 1 & 1 \\\\\\n            \\\\end{array}\\\\right]')\n        mat.shift(3.5 * RIGHT)\n        eq2 = TexMobject('| \\\\text{det}( A^{\\\\sigma} ) |  = \\\\text{per}(A)', tex_to_color_map={'\\\\text{per}': GOLD, '\\\\text{det}': BLUE, 'A': RED})\n        eq2.shift(3 * DOWN + 3 * LEFT)\n        arrow = Arrow(LEFT, RIGHT, color=PURPLE).shift(3 * DOWN)\n        self.play(ApplyMethod(grp2.shift, 3.5 * LEFT), FadeInFromDown(mat))\n        self.wait()\n        kastelyn = TextMobject('Kastelyn Signing', color=YELLOW)\n        kastelyn.shift(3 * DOWN + 3 * RIGHT)\n        self.play(Write(eq2), Write(arrow))\n        self.play(FadeInFromDown(kastelyn))\n        self.wait()\n        self.play(Uncreate(grp), Uncreate(VGroup(kastelyn, arrow, eq2)))\n        self.play(ApplyMethod(grp2.scale, 0.75), ApplyMethod(mat.scale, 0.75))\n        self.play(ApplyMethod(grp2.shift, 2 * UP), ApplyMethod(mat.shift, 2 * UP))\n        self.wait()\n        eq3 = TexMobject('T(2, 3)', ' = F_{4}', ' = 3', '= \\\\text{per}(A)', tex_to_color_map={'\\\\text{per}': GOLD, 'F': BLUE, 'A': RED})\n        eq3.scale(1.4)\n        eq3.shift(1 * DOWN)\n        for a, b in [(0, 1), (1, 4), (4, 5), (5, len(eq3))]:\n            self.play(FadeInFromDown(eq3[a:b]))\n            self.wait(0.5)\n        eq4 = TexMobject('| \\\\text{det} (A^{\\\\sigma}) | = 3', tex_to_color_map={'\\\\text{det}': BLUE, 'A^{\\\\sigma}': RED})\n        eq4.scale(1.4)\n        eq4.shift(2.5 * DOWN)\n        self.play(FadeInFromDown(eq4))\n        self.wait(0.5)\n        self.play(Uncreate(eq3[:5]))\n        self.play(eq4.shift, 1.5 * UP + 1 * LEFT)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display two bipartite graphs, one labeled \"Planar Graph\" and the other \"Not Planar Graph\", with the latter having a more complex edge configuration."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass PlanarIntro(Scene):\n\n    def construct(self):\n        graph1 = PerfectBipartiteGraph()\n        graph1.add_perm([[0], [0, 1, 2], [2]])\n        graph1.shift(2.5 * LEFT + 1 * UP)\n        graph2 = PerfectBipartiteGraph()\n        graph2.add_perm([[0, 1, 2], [0, 1, 2], [0, 1, 2]])\n        graph2.shift(2.5 * RIGHT + 1 * UP)\n        lbl1 = TextMobject('Planar Graph', color=GOLD).shift(2.5 * LEFT + 2 * DOWN)\n        lbl2 = TextMobject('Not Planar Graph', color=GOLD).shift(2.5 * RIGHT + 2 * DOWN)\n        self.play(Write(graph1), FadeInFromDown(lbl1))\n        self.play(Write(graph2), FadeInFromDown(lbl2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present a grid graph and highlight a cycle within it, then transition to two modified grid graphs with associated labels and signs to illustrate concepts of graph cycles."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass CycleIntro(Scene):\n\n    def construct(self):\n        title = TextMobject('Cycle of a Graph', color=YELLOW)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        graph = GridGraph(4, 4, s_width=1.5)\n        lines = graph.lines\n        lines.set_opacity(0.5)\n        cycle = [0, 1, 5, 6, 10, 9, 8, 4, 0]\n        edges = VGroup()\n        for i in range(1, len(cycle)):\n            edges.add(graph.get_edge(cycle[i - 1], cycle[i]))\n        graph.shift(0.5 * DOWN)\n        edges.shift(0.5 * DOWN)\n        self.play(Write(graph), FadeInFromDown(title))\n        self.wait()\n        for i in edges:\n            self.bring_to_back(i)\n            self.bring_to_back(lines)\n            self.play(Write(i))\n        self.wait()\n        self.play(Uncreate(title))\n        self.play(ApplyMethod(graph.shift, 3 * LEFT + 1 * UP), ApplyMethod(edges.shift, 3 * LEFT + 1 * UP))\n        self.bring_to_back(edges)\n        self.bring_to_back(lines)\n        lbl1 = TextMobject('Evenly-Spaced', color=GOLD).shift(3 * LEFT + 3 * DOWN)\n        lbl1.scale(1.25)\n        lbl2 = TextMobject('Not Evenly-Spaced', color=GOLD).shift(3 * RIGHT + 3 * DOWN)\n        lbl2.scale(1.25)\n        self.play(FadeInFromDown(lbl1))\n        graph2 = GridGraph(4, 4, s_width=1.5)\n        cycle2 = [0, 1, 2, 6, 7, 11, 10, 9, 13, 12, 8, 4, 0]\n        edges2 = VGroup(*[graph.get_edge(cycle2[i - 1], cycle2[i]) for i in range(len(cycle2))])\n        graph2.shift(3 * RIGHT + 0.5 * UP)\n        edges2.shift(3 * RIGHT + 0.5 * UP)\n        graph2.lines.set_opacity(0.5)\n        g2 = VGroup(graph2.lines, edges2, graph2.circles)\n        self.play(Write(g2), FadeInFromDown(lbl2))\n        self.wait()\n        signs1 = VGroup()\n        edges1_signs = [-1, 1, 1, -1, 1, -1, 1, 1]\n        edges1_direc = [UP, RIGHT, UP, RIGHT, UP, UP, LEFT, LEFT]\n        for n, i in enumerate(edges):\n            lbl = TexMobject('-1' if edges1_signs[n] < 0 else '+1', color=BLUE)\n            lbl.move_to(i)\n            lbl.scale(0.75)\n            lbl.shift(edges1_direc[n] * 0.3)\n            signs1.add(lbl)\n        signs2 = VGroup()\n        edges2_signs = [*[-1 for i in range(8)], *[1 for i in range(4)]]\n        edges2_direc = [UP, UP, RIGHT, UP, RIGHT, UP, UP, LEFT, DOWN, LEFT, LEFT, LEFT]\n        for n, i in enumerate(edges2[1:]):\n            lbl = TexMobject('-1' if edges2_signs[n] < 0 else '+1', color=BLUE)\n            lbl.move_to(i)\n            lbl.scale(0.75)\n            lbl.shift(edges2_direc[n] * 0.3)\n            signs2.add(lbl)\n        title1 = TextMobject('Properly-Signed', color=GREEN)\n        title2 = TextMobject('Not Properly-Signed', color=GREEN)\n        title2.shift(3 * RIGHT + 3.5 * UP)\n        title1.shift(3 * LEFT + 3.5 * UP)\n        self.play(Write(signs1), Write(signs2))\n        self.play(FadeInFromDown(title1), FadeInFromDown(title2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display two facts on the screen, with each fact's title appearing from below and its content being written out."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Facts(Scene):\n\n    def construct(self):\n        l = 5.5\n        pad = 1.5\n        f1 = TextMobject('Fact 1:')\n        f1.shift(l * LEFT + (pad + 0.75) * UP)\n        f1.scale(1.25)\n        f2 = TextMobject('Fact 2:')\n        f2.shift(l * LEFT + (pad - 0.75) * DOWN)\n        f2.scale(1.25)\n        fact1 = TextMobject('If every evenly-placed cycle in a \\\\\\\\ \\\\\\n                graph is perfectly-signed, then \\\\( \\\\sigma \\\\) \\\\\\\\ \\\\\\n                    is a Kastelyn signing of the graph', tex_to_color_map={'evenly-placed': GREEN, 'perfectly-signed': GOLD, ' \\\\( \\\\sigma \\\\)': RED, 'Kastelyn signing': TEAL}, alignment='')\n        fact2 = TextMobject('If every boundary cycle in a \\\\\\\\ \\\\\\n                grid graph is perfectly-signed, then \\\\( \\\\sigma \\\\) \\\\\\\\ \\\\\\n                    is a Kastelyn signing of the graph', tex_to_color_map={'boundary': PURPLE, 'perfectly-signed': GOLD, ' \\\\( \\\\sigma \\\\)': RED, 'Kastelyn signing': TEAL}, alignment='')\n        fact1.shift(pad * UP + 1 * RIGHT)\n        fact1.scale(1.25)\n        fact2.shift(pad * DOWN + 1.45 * RIGHT)\n        fact2.scale(1.25)\n        self.play(FadeInFromDown(f1))\n        self.play(Write(fact1))\n        self.wait()\n        self.play(FadeInFromDown(f2))\n        self.play(Write(fact2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render a 4x4 grid graph and its faces labeled F1 through F16 and F_outer, then display Euler's formula with color-coded variables."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass PlanarGraphProperty(Scene):\n\n    def construct(self):\n        graph = GridGraph(4, 4, s_width=1.5)\n        graph.lines.set_opacity(0.75)\n        graph.shift(0.5 * UP)\n        flbl = VGroup()\n        i = 1\n        for y in np.arange(2, -1.1, -1.5):\n            for x in np.arange(-1.5, 1.6, 1.5):\n                flbl.add(TexMobject(f'F_\\\\text{{ {i} }}').shift([x, y, 0]))\n                i += 1\n        flbl.add(TexMobject('F_\\\\text{outer}').shift(4 * LEFT))\n        self.play(Write(graph))\n        self.play(Write(flbl))\n        self.wait()\n        euler = TexMobject('V + F - E = 2', tex_to_color_map={'V': GREEN, 'F': YELLOW, 'E': RED})\n        euler.shift(3 * DOWN)\n        euler.scale(1.5)\n        self.play(FadeInFromDown(euler))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize graph transformations and then compute a determinant of a matrix representing a graph property."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Example(Scene):\n\n    def construct(self):\n        graph1 = GridGraph(4, 4, s_width=1.5)\n        graph1.lines.set_opacity(0.75)\n        flbl1 = self.get_faces()\n        g1 = VGroup(graph1, flbl1)\n        g1.shift(0.5 * UP)\n        gl1 = TextMobject('G', color=YELLOW).shift(3 * DOWN).scale(1.5)\n        self.play(Write(g1))\n        self.play(FadeInFromDown(gl1))\n        self.wait()\n        grp1 = VGroup(g1, gl1)\n        graph2 = GridGraph(4, 4, s_width=1.5)\n        graph2.lines.set_opacity(0.75)\n        flbl2 = self.get_faces()\n        g2 = VGroup(graph2, flbl2)\n        g2.shift(0.5 * UP + 3.5 * RIGHT)\n        gl2 = TexMobject('\\\\text{G}_1', color=YELLOW).shift(3 * DOWN + 3.5 * RIGHT).scale(1.5)\n        e1 = graph2.get_edge(8, 12, color=BLACK).shift(3.5 * RIGHT + 0.5 * UP)\n        self.play(grp1.shift, 3.5 * LEFT)\n        self.play(Write(g2), FadeInFromDown(gl2))\n        self.bring_to_back(e1)\n        self.bring_to_back(graph2.lines)\n        self.play(Write(e1), Uncreate(flbl2[6]))\n        self.wait()\n        rme = VGroup(e1)\n        graph2.add(e1)\n        graph2.add(graph2.circles)\n        self.play(Uncreate(grp1))\n        self.play(ApplyMethod(g2.shift, 3.5 * LEFT), ApplyMethod(gl2.shift, 3.5 * LEFT))\n        gl = TexMobject('\\\\text{G}_i', color=YELLOW).shift(3 * DOWN).scale(1.5)\n        self.play(Transform(gl2, gl))\n        for y in range(3, 0, -1):\n            for x in range(0, 3):\n                if y == 3 and x == 0:\n                    continue\n                ei = graph2.get_edge(4 * y + x, 4 * (y - 1) + x, color=BLACK)\n                ei.shift(0.5 * UP)\n                rme.add(ei)\n                self.bring_to_back(ei)\n                self.bring_to_back(graph2.lines)\n                self.play(Write(ei), Uncreate(flbl2[3 * y - 1 - (2 - x)]))\n                self.wait(0.5)\n        rect = Rectangle(height=3, width=2.5)\n        l1 = Line(LEFT, ORIGIN, stroke_width=6, color=BLUE).shift(0.625 * UP)\n        lbl1 = TexMobject('+1').scale(1.25).shift(0.625 * UP + 0.625 * RIGHT)\n        l2 = Line(LEFT, ORIGIN, stroke_width=6, color=RED).shift(0.625 * DOWN)\n        lbl2 = TexMobject('-1').scale(1.25).shift(0.625 * DOWN + 0.625 * RIGHT)\n        legend = VGroup(rect, l1, lbl1, l2, lbl2)\n        legend.scale(0.75)\n        legend.shift(5 * LEFT + 0.5 * UP)\n        self.play(Write(legend))\n        self.play(graph2.lines.set_color, BLUE)\n        self.wait()\n        for n, i in enumerate(rme):\n            i.set_color(RED if n % 3 == 0 or n % 3 == 2 else BLUE)\n            i.set_stroke(width=6 if n % 3 == 0 or n % 3 == 2 else 4)\n            self.play(Write(i))\n            self.wait(0.5)\n        self.wait()\n        graph2.add(rme)\n        graph2.add(graph2.circles)\n        self.play(Uncreate(legend), Uncreate(gl2), ApplyMethod(graph2.scale, 0.5))\n        self.play(ApplyMethod(graph2.shift, 4 * LEFT))\n        mat = TexMobject('A^{\\\\sigma}=\\\\left[\\\\begin{array}{cccccccc} \\\\\\n                            1 & 0 & 0 & -1 & 0 & 0 & 0 & 0 \\\\\\\\ \\\\\\n                            1 & 1 & -1 & 0 & 0 & 0 & 0 & 0 \\\\\\\\ \\\\\\n                            0 & 1 & 1 & 0 & 0 & 1 & 0 & 0 \\\\\\\\ \\\\\\n                            1 & 0 & 1 & 1 & 1 & 0 & 0 & 0 \\\\\\\\ \\\\\\n                            0 & 0 & 0 & -1 & 1 & 0 & 0 & -1 \\\\\\\\ \\\\\\n                            0 & 0 & -1 & 0 & 1 & 1 & -1 & 0 \\\\\\\\ \\\\\\n                            0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\\\\\\\ \\\\\\n                            0 & 0 & 0 & 0 & 1 & 0 & 1 & 1 \\\\\\n                            \\\\end{array}\\\\right]')\n        mat.scale(0.5)\n        mat.shift(2 * RIGHT + 2 * UP)\n        self.play(Write(mat))\n        self.wait()\n        ans = TexMobject('T(4,4) = \\\\text{det}(A^{\\\\sigma}) = ', '36', tex_to_color_map={'\\\\text{det}': GOLD, 'A^{\\\\sigma}': RED, '4': BLUE, 'T': GREEN})\n        ans.scale(1.5)\n        ans.shift(2 * RIGHT + 2 * DOWN)\n        rect = BackgroundRectangle(ans[-1], color=YELLOW, stroke_opacity=1, stroke_width=6, fill_opacity=0, buff=0.2)\n        self.play(Write(ans[:-1]))\n        self.play(FadeInFromDown(ans[-1]))\n        self.play(Write(rect))\n        self.wait()\n\n    def get_faces(self):\n        flbl = VGroup()\n        i = 1\n        for y in np.arange(1.5, -1.6, -1.5):\n            for x in np.arange(-1.5, 1.6, 1.5):\n                flbl.add(TexMobject(f'F_\\\\text{{ {i} }}').shift([x, y, 0]))\n                i += 1\n        return flbl"}]}
{"messages": [{"role": "user", "content": "Display a title and then write a mathematical equation representing a closed-form solution."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ClosedForm(Scene):\n\n    def construct(self):\n        title = TextMobject('Closed Form', color=GOLD)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        eq = TexMobject('\\\\begin{aligned} \\\\\\n            T(m, n) &=\\\\prod_{k=1}^{m} \\\\prod_{\\\\ell=1}^{n}\\\\left|2 \\\\cos \\\\frac{k \\\\pi}{m+1}+2 \\\\mathrm{i} \\\\cos \\\\frac{\\\\ell \\\\pi}{n+1}\\\\right| \\\\\\\\ \\\\\\n            &=\\\\prod_{k=1}^{m} \\\\prod_{\\\\ell=1}^{n}\\\\left(4 \\\\cos ^{2} \\\\frac{k \\\\pi}{m+1}+4 \\\\cos ^{2} \\\\frac{\\\\ell \\\\pi}{n+1}\\\\right)^{1 / 2} \\\\\\n            \\\\end{aligned}')\n        eq.scale(1.1)\n        self.play(FadeInFromDown(title))\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a scene displaying \"Part X\" and a title below it, both fading in."}, {"role": "assistant", "content": "from manimlib import *\n\nclass PartScene(Scene):\n    CONFIG = {'n': 1, 'title': '', 'title_color': RED}\n\n    def construct(self):\n        part = TexText(f'Part {self.n}')\n        part.scale(1.5)\n        part.shift(2 * UP)\n        title = TexText(self.title, color=self.title_color)\n        title.scale(1.5)\n        self.play(Write(part))\n        self.play(Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the tangent line to a function, its slope value, and its corresponding point on the graph as the point moves along the curve."}, {"role": "assistant", "content": "from manimlib import *\n\nclass NormalDerivative(Scene):\n    LINE_COLOR = YELLOW_Z\n\n    def construct(self):\n        axes = Axes(x_range=(-2, 5), y_range=(0, 5))\n        self.axes = axes\n        func = axes.get_graph(self.func, color=BLUE)\n        label = axes.get_graph_label(func, label='f(x)')\n        line_kwargs = {'color': self.LINE_COLOR}\n        eq_kwargs = {}\n        dot_kwargs = {'color': self.LINE_COLOR}\n        self.len_of_line = 2\n        v = ValueTracker(-1)\n        l = self.get_line(-1, **line_kwargs)\n        eq = self.get_eq(-1, **eq_kwargs)\n        d = self.get_point(-1, **dot_kwargs)\n        l.add_updater(lambda l: l.become(self.get_line(v.get_value(), **line_kwargs)))\n        eq.add_updater(lambda e: e.become(self.get_eq(v.get_value(), **eq_kwargs)))\n        d.add_updater(lambda d: d.become(self.get_point(v.get_value(), **dot_kwargs)))\n        self.play(Write(axes), Write(func), Write(label))\n        self.play(Write(l), Write(eq), Write(d))\n        self.wait()\n        self.play(v.increment_value, 5, run_time=10, rate_func=linear)\n        self.wait()\n        self.embed()\n\n    def get_eq(self, t, **kwargs):\n        f_prime = '{:.2f}'.format(round(self.deriv(t), 2))\n        eq = Tex('{{d}f \\\\over {d}x} = ', tex_to_color_map={'f': BLUE, 'x': A_PINK}, **kwargs)\n        n = DecimalNumber(float(f_prime), color=self.LINE_COLOR)\n        n.scale(1.5)\n        n.shift(2.5 * UP + 2 * RIGHT)\n        eq.scale(1.5)\n        eq.shift(2.5 * UP)\n        return VGroup(eq, n)\n\n    def get_point(self, t, **kwargs):\n        return Dot(self.axes.c2p(*np.array([t, self.func(t), 0])), **kwargs)\n\n    def get_line(self, t, **kwargs):\n        f_prime = self.deriv(t)\n        theta = np.arctan(f_prime)\n        center = np.array([t, self.func(t), 0])\n        p1 = self.len_of_line / 2 * np.array([np.cos(theta), np.sin(theta), 0]) + center\n        p2 = -self.len_of_line / 2 * np.array([np.cos(theta), np.sin(theta), 0]) + center\n        return Line(self.axes.c2p(*p1), self.axes.c2p(*p2), **kwargs)\n\n    def func(self, x):\n        x -= 1\n        return 0.1 * (x ** 4 - x ** 3 - 6 * x ** 2) + 2.5\n\n    def deriv(self, x):\n        return 0.5 + 0.6 * x - 1.5 * x ** 2 + 0.4 * x ** 3"}]}
{"messages": [{"role": "user", "content": "Display two complex planes side-by-side, labeled \"Input Space\" and \"Output Space\", and animate a point moving in the input plane and its corresponding transformation in the output plane."}, {"role": "assistant", "content": "from manimlib import *\n\nclass IntroduceComplexFunction(Scene):\n    plane_opacity = 0.65\n\n    def construct(self):\n        c = ComplexPlane()\n        c.add_coordinate_labels()\n        complex_kwargs = {'background_line_style': {'stroke_opacity': self.plane_opacity}}\n        c1 = ComplexPlane(x_range=(-3, 3), y_range=(-3, 3), **complex_kwargs)\n        c1.add_coordinate_labels()\n        c1.coordinate_labels.set_opacity(self.plane_opacity)\n        c1.axes.set_opacity(self.plane_opacity)\n        c1.shift(FRAME_WIDTH / 4 * LEFT + 0.5 * DOWN)\n        c2 = ComplexPlane(x_range=(-3, 3), y_range=(-3, 3), **complex_kwargs)\n        c2.add_coordinate_labels()\n        c2.coordinate_labels.set_opacity(self.plane_opacity)\n        c2.axes.set_opacity(self.plane_opacity)\n        c2.shift(FRAME_WIDTH / 4 * RIGHT + 0.5 * DOWN)\n        input_text = TexText('Input Space', color=YELLOW_Z)\n        input_text.scale(1.5)\n        input_text.shift(-FRAME_WIDTH / 4 * RIGHT + 3.25 * UP)\n        output_text = TexText('Output Space', color=YELLOW_Z)\n        output_text.scale(1.5)\n        output_text.shift(FRAME_WIDTH / 4 * RIGHT + 3.25 * UP)\n        input_dot = Dot(c1.c2p(1, 1), color=PURPLE)\n        input_dot.set_color(A_PINK)\n        input_dot_text = Tex('z', color=A_PINK)\n        input_dot_text.add_background_rectangle()\n        input_dot_text.add_updater(lambda t: t.become(t.next_to(input_dot, DOWN)))\n        output_dot = Dot(c2.c2p(0.75, 2), color=A_GREEN)\n        output_dot_text = Tex('f(z)', tex_to_color_map={'z': A_PINK, 'f': A_GREEN})\n        output_dot_text.add_background_rectangle()\n        output_dot_text.add_updater(lambda t: t.become(t.next_to(output_dot, DOWN)))\n        self.play(Write(c))\n        self.wait(1)\n        self.play(Transform(c, c1), Write(input_text))\n        self.play(Write(c2), Write(output_text))\n        self.wait()\n        self.play(Write(input_dot), Write(input_dot_text))\n        self.play(Write(output_dot), Write(output_dot_text))\n        self.wait()\n\n    def func(self, z):\n        r = abs(z)\n        t = PI / 2 if z.real == 0 else np.arctan(z.imag / z.real)\n        new_t = 3 * t ** 2 + t + 2\n        new_r = 3 * np.sin(r + 6) ** 2 * np.cos(3 * r + 2)\n        return new_r * (np.cos(new_t) + np.sin(new_t) * 1j)"}]}
{"messages": [{"role": "user", "content": "Animate a 3D parametric surface representing a sine wave multiplied by a linear component, viewed from a rotating camera."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ComplexGraph1_1(Scene):\n\n    def construct(self):\n        frame = self.camera.frame\n        frame.set_phi(PI / 4)\n        frame.set_theta(PI / 4)\n        axes = ThreeDAxes()\n        surf = ParametricSurface(self.func, u_range=(-4, 4), v_range=(-4, 4), color=PURPLE, opacity=0.75)\n        self.play(Write(axes), ShowCreation(surf))\n        frame.add_updater(lambda f, dt: f.increment_theta(0.2 * dt))\n        self.wait(10)\n        self.embed()\n\n    def func(self, u, v):\n        return [u, v, np.sin(u) * v]"}]}
{"messages": [{"role": "user", "content": "Render a 3D parametric surface of a function, rotating it while simultaneously showing its axes."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ComplexGraph1_2(Scene):\n\n    def construct(self):\n        frame = self.camera.frame\n        frame.set_phi(PI / 4)\n        frame.set_theta(3 * PI / 4)\n        axes = ThreeDAxes()\n        surf = ParametricSurface(self.func, u_range=(-4, 4), v_range=(-4, 4), color=GREEN, opacity=0.75)\n        self.play(Write(axes), ShowCreation(surf))\n        frame.add_updater(lambda f, dt: f.increment_theta(0.2 * dt))\n        self.embed()\n        self.wait(10)\n\n    def func(self, u, v):\n        return [u, v, 0.5 * ((0.5 * v) ** 2 + (0.5 * u) ** 3)]"}]}
{"messages": [{"role": "user", "content": "Display a vertical line and two colored mathematical text labels, one on the left and one on the right, above the line."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ComplexGraphScene1(Scene):\n\n    def construct(self):\n        l = Line(10 * UP, 10 * DOWN)\n        title1 = Tex('\\\\mathrm{Re}(f(z))', tex_to_color_map={'\\\\mathrm{Re}': A_ORANGE, 'f': A_GREEN, 'z': A_PINK})\n        title1.scale(1.5)\n        title1.shift(FRAME_WIDTH / 4 * LEFT + 3.25 * UP)\n        title2 = Tex('\\\\mathrm{Im}(f(z))', tex_to_color_map={'\\\\mathrm{Im}': A_ORANGE, 'f': A_GREEN, 'z': A_PINK})\n        title2.scale(1.5)\n        title2.shift(FRAME_WIDTH / 4 * RIGHT + 3.25 * UP)\n        self.play(Write(title1), Write(title2), Write(l))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a complex vector field on a number plane with its corresponding equation."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ComplexGraph2(Scene):\n\n    def construct(self):\n        n = NumberPlane(background_line_style={'stroke_opacity': 0.5})\n        n.axes.set_opacity(0.5)\n        v = VectorField(lambda x, y: [np.cos(x) * np.sin(y), np.sin(y) + np.cos(x), 0], n)\n        eq = Tex('f(x+y{i}) = \\\\cos(x) \\\\sin(y) + [\\\\sin(y) + \\\\cos(x)]{i}', tex_to_color_map={'{i}': BLUE})\n        beq = BackgroundRectangle(eq, buff=0.2, opacity=1)\n        grp = VGroup(beq, eq)\n        grp.scale(1.25)\n        grp.shift(3 * UP)\n        self.play(Write(n))\n        self.play(Write(v), Write(grp))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display a 3D parametric surface representing a complex function with animated camera rotation."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ComplexGraph3(Scene):\n\n    def construct(self):\n        axes = ThreeDAxes()\n        surf = ParametricSurface(lambda u, v: [u, v, abs(0.5 * (u + v * 1j) ** 2)], u_range=(-4, 4), v_range=(-4, 4))\n        surf.set_opacity(0.75)\n        t_surf = TexturedSurface(surf, 'img/z_squared.png')\n        frame = self.camera.frame\n        frame.add_updater(lambda f, dt: f.increment_theta(0.2 * dt))\n        frame.set_theta(5.084)\n        frame.set_phi(1.018)\n        self.play(Write(axes), ShowCreation(t_surf))\n        self.wait(15)"}]}
{"messages": [{"role": "user", "content": "Visualize a number line, display a cloud of pink dots representing a linear function, transform it into a cloud of green dots representing a steeper linear function, and then revert it back to the original pink dots."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ZoomRealScene(Scene):\n    CONFIG = {'f_deriv': 2, 'n_points': 12, 'x_color': A_PINK, 'y_color': A_GREEN, 'run_time': 7, 'radius': 10 * DEFAULT_DOT_RADIUS}\n\n    def construct(self):\n        n = NumberLine(include_ticks=False, stroke_width=16)\n        s = np.linspace(-FRAME_WIDTH / 2, FRAME_WIDTH / 2, self.n_points)\n        x_vals = [n.n2p(i) for i in s]\n        y_vals = [n.n2p(self.f_deriv * i) for i in s]\n        x_dot = DotCloud(x_vals, color=self.x_color, radius=self.radius)\n        cp = x_dot.copy()\n        y_dot = DotCloud(y_vals, color=self.y_color, radius=self.radius)\n        self.play(Write(n), ShowCreation(x_dot))\n        self.wait()\n        self.play(Transform(x_dot, y_dot), run_time=self.run_time)\n        self.wait()\n        self.play(Transform(x_dot, cp))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of complex differentiation by showing a point moving along a path in the input complex plane and its corresponding transformation in the output complex plane, demonstrating how the derivative relates infinitesimal changes."}, {"role": "assistant", "content": "from manimlib import *\n\nclass IntroComplexDeriv(Scene):\n    CONFIG = {'plane_opacity': 0.65, 'x': 1.5, 'y': 2, 'vec_opacity': 0.75}\n\n    def construct(self):\n        complex_kwargs = {'background_line_style': {'stroke_opacity': self.plane_opacity}}\n        c1 = ComplexPlane(x_range=(-3, 3), y_range=(-3, 3), **complex_kwargs)\n        c1.add_coordinate_labels()\n        c1.coordinate_labels.set_opacity(self.plane_opacity)\n        c1.axes.set_opacity(self.plane_opacity)\n        c1.shift(FRAME_WIDTH / 4 * LEFT + 0.5 * DOWN)\n        c2 = ComplexPlane(x_range=(-3, 3), y_range=(-3, 3), **complex_kwargs)\n        c2.add_coordinate_labels()\n        c2.coordinate_labels.set_opacity(self.plane_opacity)\n        c2.axes.set_opacity(self.plane_opacity)\n        c2.shift(FRAME_WIDTH / 4 * RIGHT + 0.5 * DOWN)\n        input_text = TexText('Input Space', color=YELLOW_Z)\n        input_text.scale(1.5)\n        input_text.shift(-FRAME_WIDTH / 4 * RIGHT + 3.25 * UP)\n        output_text = TexText('Output Space', color=YELLOW_Z)\n        output_text.scale(1.5)\n        output_text.shift(FRAME_WIDTH / 4 * RIGHT + 3.25 * UP)\n        input_dot = Dot(c1.c2p(self.x, self.y), color=PURPLE)\n        input_dot.set_color(A_PINK)\n        input_dot_text = Tex('z', color=A_PINK)\n        input_dot_text.add_background_rectangle()\n        input_dot_text.add_updater(lambda t: t.become(t.next_to(input_dot, DOWN)))\n        output_dot = Dot(c2.c2p(0, 0), color=A_GREEN)\n\n        def dot_updater(d):\n            input_coors = c1.p2c(input_dot.get_center())\n            output_coors = self.func(input_coors[0] + input_coors[1] * 1j)\n            return d.become(Dot(c2.c2p(output_coors.real, output_coors.imag, 0), color=A_GREEN))\n        output_dot.add_updater(dot_updater)\n        output_dot_text = Tex('f(z)', tex_to_color_map={'z': A_PINK, 'f': A_GREEN})\n        output_dot_text.add_background_rectangle()\n        output_dot_text.add_updater(lambda t: t.become(t.next_to(output_dot, DOWN)))\n        self.play(Write(c1), Write(input_text))\n        self.play(Write(c2), Write(output_text))\n        self.wait()\n        self.play(Write(input_dot), Write(input_dot_text))\n        self.play(Write(output_dot), Write(output_dot_text))\n        self.wait()\n\n        def path_func(t):\n            return c1.c2p(1.5 * np.sin(3 * PI / 4 * t), -t)\n        path = ParametricCurve(path_func, t_range=(-2, 2))\n        self.play(MoveAlongPath(input_dot, path), run_time=10, rate_func=there_and_back)\n        self.wait()\n        z = [self.x, self.y]\n        z_deriv = self.f_deriv(self.x + self.y * 1j)\n        f_z = self.func(self.x + self.y * 1j)\n        f_z = [f_z.real, f_z.imag]\n        img_vecs = VGroup()\n        vecs = VGroup()\n        for t in np.linspace(0, 2 * PI, 15)[:-1]:\n            z_0 = np.exp(t * 1j)\n            x_0, y_0 = (0.75 * z_0.real, 0.75 * z_0.imag)\n            f_z0 = 0.5 * z_0 * z_deriv\n            f_x0, f_y0 = (f_z0.real, f_z0.imag)\n            v_0 = self.get_vec(c1, [x_0, y_0], stroke_color=A_PINK, stroke_opacity=self.vec_opacity)\n            f_v0 = self.get_vec(c2, [f_x0, f_y0], stroke_color=A_GREEN, stroke_opacity=self.vec_opacity)\n            v_0.move_to(c1.c2p(*z), aligned_edge=[-x_0, -y_0, 0])\n            f_v0.move_to(c2.c2p(*f_z), aligned_edge=[-f_x0, -f_y0, 0])\n            vecs.add(v_0)\n            img_vecs.add(f_v0)\n        vecs_cp = vecs.copy()\n        img_vecs_cp = img_vecs.copy()\n        input_dot_text.non_time_updaters, output_dot_text.non_time_updaters = ([], [])\n        self.bring_to_front(input_dot_text)\n        self.play(Write(vecs), ApplyMethod(input_dot_text.shift, 0.5 * DOWN))\n        self.bring_to_front(input_dot_text)\n        self.wait()\n        self.bring_to_front(output_dot_text)\n        self.play(TransformFromCopy(vecs, img_vecs), ApplyMethod(output_dot_text.shift, 0.3 * DOWN), run_time=7)\n        self.bring_to_front(output_dot_text)\n        self.wait()\n        self.play(Uncreate(vecs[:4]), Uncreate(vecs[5:]), Uncreate(img_vecs[:4]), Uncreate(img_vecs[5:]), ApplyMethod(vecs[4].set_opacity, 1), ApplyMethod(img_vecs[4].set_opacity, 1), ApplyMethod(output_dot_text.shift, 0.3 * UP), ApplyMethod(input_dot_text.shift, 0.5 * UP))\n        dz_label = Tex('dz', tex_to_color_map={'z': A_PINK})\n        dz_label.add_background_rectangle()\n        dz_label.move_to(vecs[4], UP)\n        dz_label.shift(0.5 * RIGHT)\n        df_label = Tex('df', tex_to_color_map={'f': A_GREEN})\n        df_label.add_background_rectangle()\n        df_label.move_to(img_vecs[4])\n        df_label.shift(0.6 * UP)\n        self.play(Write(dz_label), Write(df_label))\n        self.wait()\n        eq = Tex(\"df = f'(z) \\\\cdot dz\", tex_to_color_map={'f': A_GREEN, 'z': A_PINK, \"'\": A_GREEN})\n        eq.add_background_rectangle()\n        eq.scale(1.5)\n        eq.shift(2.75 * DOWN)\n        cp = img_vecs[4].copy()\n        self.play(Write(eq))\n        self.wait()\n        self.play(TransformFromCopy(vecs[4], cp), run_time=5)\n        self.remove(cp)\n        self.wait()\n        self.bring_to_front(dz_label, input_dot_text)\n        self.play(Write(vecs_cp), Uncreate(vecs), ApplyMethod(dz_label.shift, [0.5, 0.25, 0]), ApplyMethod(input_dot_text.shift, 0.5 * DOWN))\n        self.bring_to_front(dz_label, input_dot_text)\n        self.wait()\n        self.bring_to_front(output_dot_text, df_label)\n        self.play(TransformFromCopy(vecs_cp, img_vecs_cp), Uncreate(img_vecs), ApplyMethod(df_label.shift, 0.1 * UP), ApplyMethod(output_dot_text.shift, 0.3 * DOWN), run_time=5)\n        self.bring_to_front(output_dot_text, df_label)\n        self.wait()\n        eq2 = Tex(\"f'(z) = 1.15 e^{\\\\frac{2 \\\\pi}{5} i}\", tex_to_color_map={\"f'\": A_GREEN, 'z': A_PINK, '\\\\frac{2 \\\\pi}{5}': YELLOW_Z, '1.15': YELLOW_Z})\n        eq2.scale(1.5)\n        eq2.add_background_rectangle()\n        eq2.shift(2.75 * DOWN)\n        self.play(ApplyMethod(eq.shift, 1.25 * UP), Write(eq2))\n        self.wait()\n        eq3 = Tex(\"f'(z) = 0.38 - 1.09i\", tex_to_color_map={\"f'\": A_GREEN, 'z': A_PINK, '0.38': YELLOW_Z, '1.09': YELLOW_Z})\n        eq3.add_background_rectangle()\n        eq3.scale(1.5)\n        eq3.shift(2.75 * DOWN)\n        self.play(Transform(eq2, eq3))\n        self.wait()\n        self.play(Uncreate(eq2), ApplyMethod(eq.shift, 1.25 * DOWN))\n        self.wait()\n        img_vecs2 = VGroup()\n        f_M = np.array([[1 / 2, -np.sqrt(3)], [np.sqrt(3) / 2, 1]])\n        for t in np.linspace(0, 2 * PI, 15)[:-1]:\n            z_0 = np.exp(t * 1j)\n            x_0, y_0 = (0.75 * z_0.real, 0.75 * z_0.imag)\n            f_z0 = np.dot(f_M, np.array([[x_0], [y_0]]))\n            f_x0, f_y0 = (f_z0[0][0], f_z0[1][0])\n            f_v0 = self.get_vec(c2, [f_x0, f_y0], stroke_color=A_GREEN, stroke_opacity=self.vec_opacity)\n            f_v0.move_to(c2.c2p(1, 1), aligned_edge=[-f_x0, -f_y0, 0])\n            img_vecs2.add(f_v0)\n        output_dot.non_time_updaters = []\n        eq_g = Tex(\"dg = g'(z) \\\\cdot dz\", tex_to_color_map={'g': A_GREEN, 'z': A_PINK, \"'\": A_GREEN})\n        eq_g.add_background_rectangle()\n        eq_g.scale(1.5)\n        eq_g.shift(2.75 * DOWN)\n        g_dot_text = Tex('g(z)', tex_to_color_map={'z': A_PINK, 'g': A_GREEN})\n        g_dot_text.add_background_rectangle()\n        g_dot_text.move_to(output_dot_text.get_center() + c2.c2p(1, 1) - c2.c2p(*f_z) + 0.4 * DOWN)\n        dg_label = Tex('dg', tex_to_color_map={'g': A_GREEN})\n        dg_label.add_background_rectangle()\n        dg_label.move_to(df_label.get_center() + c2.c2p(1, 1) - c2.c2p(*f_z) + 0.3 * UP)\n        self.play(Uncreate(img_vecs_cp), ApplyMethod(output_dot.move_to, c2.c2p(1, 1)), Transform(output_dot_text, g_dot_text), Transform(df_label, dg_label), Transform(eq, eq_g))\n        self.wait(0.5)\n        self.play(TransformFromCopy(vecs_cp, img_vecs2), run_time=5)\n        self.wait()\n        self.play(Indicate(vecs_cp[0], scale_factor=2), Indicate(img_vecs2[0], scale_factor=2), run_time=3)\n        self.wait()\n        self.play(Indicate(vecs_cp[4], scale_factor=2), Indicate(img_vecs2[4], scale_factor=2), run_time=3)\n        self.wait()\n        self.embed()\n\n    def get_vec(self, plane, coors, **kwargs):\n        x, y = (coors[0], coors[1])\n        z = plane.c2p(x, y)\n        return Arrow(plane.c2p(0, 0), z, buff=0, **kwargs)\n\n    def f_deriv(self, z, dz=1e-06 + 1e-06 * 1j):\n        return (self.func(z + dz) - self.func(z)) / dz\n\n    def func(self, z):\n        return (1 * z + np.sin(z)) * 0.3 - 1"}]}
{"messages": [{"role": "user", "content": "Visualize the multiplication of two complex numbers by showing their polar form and the resulting complex number with its angle."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ComplexMul(Scene):\n\n    def construct(self):\n        plane = ComplexPlane(faded_line_ratio=2, background_line_style={'stroke_opacity': 0.65})\n        plane.axes.set_opacity(0.65)\n        plane.add_coordinate_labels()\n        v_0 = 0.7 * np.array([3, 1, 0])\n        v0 = 0.7 * (3 + 1j)\n        theta1 = np.arctan2(1, 3)\n        w_0 = 0.7 * np.array([-2, 2, 0])\n        w0 = 0.7 * (-2 + 2j)\n        theta2 = np.arctan2(2, -2)\n        v = Line(ORIGIN, v_0, color=A_GREEN)\n        v_dot = Dot(v_0, color=A_GREEN)\n        angle1 = Arc(0, theta1, color=A_YELLOW)\n        v_label = Tex('z', color=A_GREEN)\n        v_label.add_background_rectangle()\n        v_label.move_to(v, v_0)\n        v_label.shift([0.45, 0.15, 0])\n        w = Line(ORIGIN, w_0, color=A_VIOLET)\n        w_dot = Dot(w_0, color=A_VIOLET)\n        angle2 = Arc(0, theta2, radius=0.75, color=A_YELLOW)\n        w_label = Tex('w', color=A_VIOLET)\n        w_label.add_background_rectangle()\n        w_label.move_to(w, w_0)\n        w_label.shift([-0.5, 0.5, 0])\n        r1_label = Tex('r_1', color=A_GREEN)\n        r1_label.add_background_rectangle()\n        r1_label.move_to(v, UP)\n        r1_label.shift([0.3, 0.3, 0])\n        r2_label = Tex('r_2', color=A_VIOLET)\n        r2_label.add_background_rectangle()\n        r2_label.move_to(w, UP)\n        eq1 = Tex('z = r_1 e^{i \\\\theta_1}', tex_to_color_map={'z': A_GREEN, 'r_1': A_GREEN, '\\\\theta_1': A_YELLOW})\n        eq1.add_background_rectangle()\n        eq1.scale(1.5)\n        eq1.move_to([-FRAME_WIDTH / 4, -4 / 3, 0])\n        eq2 = Tex('w = r_2 e^{i \\\\theta_2}', tex_to_color_map={'w': A_VIOLET, 'r_2': A_VIOLET, '\\\\theta_2': A_YELLOW})\n        eq2.add_background_rectangle()\n        eq2.scale(1.5)\n        eq2.move_to([-FRAME_WIDTH / 4, -8 / 3, 0])\n        eq3 = Tex('z \\\\cdot w = r_1 r_2 e^{i (\\\\theta_1 + \\\\theta_2)}', tex_to_color_map={'z': A_GREEN, 'r_1': A_GREEN, 'w': A_VIOLET, 'r_2': A_VIOLET, '\\\\theta_1': A_YELLOW, '\\\\theta_2': A_YELLOW})\n        eq3.add_background_rectangle()\n        eq3.scale(1.5)\n        eq3.move_to([FRAME_WIDTH / 4, -2, 0])\n        t1_label = Tex('\\\\theta_1', color=A_YELLOW)\n        t1_label.add_background_rectangle()\n        t1_label.move_to(angle1)\n        t1_label.shift(0.5 * RIGHT)\n        t2_label = Tex('\\\\theta_2', color=A_YELLOW)\n        t2_label.add_background_rectangle()\n        t2_label.shift(1.25 * UP)\n        v0 = 2.1 + 0.7 * 1j\n        w0 = -1.4 + 1.4 * 1j\n        vw0 = v0 * w0\n        vw = Line(ORIGIN, [-3.92, 1.96, 0], color=A_AQUA)\n        vw_dot = Dot([-3.92, 1.96, 0], color=A_AQUA)\n        vw_label = Tex('z \\\\cdot w', tex_to_color_map={'z': A_GREEN, 'w': A_VIOLET})\n        vw_label.add_background_rectangle()\n        vw_label.move_to(vw, [-3.92, 1.96, 0])\n        vw_label.shift(0.3 * np.array([-3.92, 1.96, 0]))\n        dtheta = Arc(theta2, theta1, color=A_RED, radius=0.75)\n        self.play(Write(plane))\n        self.play(Write(v), Write(v_label), Write(v_dot), Write(w), Write(w_label), Write(w_dot))\n        self.wait()\n        self.play(Write(eq1), Write(r1_label), Write(angle1), Write(t1_label))\n        self.wait()\n        self.play(Write(eq2), Write(r2_label), Write(angle2), Write(t2_label))\n        self.wait()\n        self.play(Write(eq3))\n        self.wait()\n        self.play(TransformFromCopy(angle1, dtheta))\n        self.play(Write(vw), Write(vw_dot), Write(vw_label))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the mapping of a point on a complex plane to another complex plane under the function f(z) = e^z, showing tangent vectors transforming accordingly."}, {"role": "assistant", "content": "from manimlib import *\n\nclass Holomorphic(Scene):\n    CONFIG = {'plane_opacity': 0.65, 'x': 0.7, 'y': 2, 'vec_opacity': 0.75}\n\n    def construct(self):\n        complex_kwargs = {'background_line_style': {'stroke_opacity': self.plane_opacity}}\n        c1 = ComplexPlane(x_range=(-3, 3), y_range=(0, 3), **complex_kwargs)\n        c1.add_coordinate_labels()\n        c1.coordinate_labels.set_opacity(self.plane_opacity)\n        c1.axes.set_opacity(self.plane_opacity)\n        c1.shift(FRAME_WIDTH / 4 * LEFT + 0.5 * DOWN)\n        c2 = ComplexPlane(x_range=(-3, 3), y_range=(0, 3), **complex_kwargs)\n        c2.add_coordinate_labels()\n        c2.coordinate_labels.set_opacity(self.plane_opacity)\n        c2.axes.set_opacity(self.plane_opacity)\n        c2.shift(FRAME_WIDTH / 4 * RIGHT + 0.5 * DOWN)\n        input_dot = Dot(c1.c2p(self.x, self.y), color=PURPLE)\n        input_dot.set_color(A_PINK)\n        input_dot_text = Tex('z', color=A_PINK)\n        input_dot_text.add_background_rectangle()\n        input_dot_text.next_to(input_dot, DOWN)\n        input_dot_text.shift(0.5 * DOWN)\n        f_z = self.func(self.x + self.y * 1j)\n        f_z = np.array([f_z.real, f_z.imag, 0])\n        output_dot = Dot(c2.c2p(*f_z), color=A_GREEN)\n        output_dot_text = Tex('f(z)', tex_to_color_map={'z': A_PINK, 'f': A_GREEN})\n        output_dot_text.add_background_rectangle()\n        output_dot_text.next_to(output_dot, DOWN)\n        z = [self.x, self.y]\n        z_deriv = self.f_deriv(self.x + self.y * 1j)\n        f_z = self.func(self.x + self.y * 1j)\n        f_z = [f_z.real, f_z.imag]\n        img_vecs = VGroup()\n        vecs = VGroup()\n        for t in np.linspace(0, 2 * PI, 15)[:-1]:\n            z_0 = np.exp(t * 1j)\n            x_0, y_0 = (0.75 * z_0.real, 0.75 * z_0.imag)\n            f_z0 = 0.5 * z_0 * z_deriv\n            f_x0, f_y0 = (f_z0.real, f_z0.imag)\n            v_0 = self.get_vec(c1, [x_0, y_0], stroke_color=A_PINK, stroke_opacity=self.vec_opacity)\n            f_v0 = self.get_vec(c2, [f_x0, f_y0], stroke_color=A_GREEN, stroke_opacity=self.vec_opacity)\n            v_0.move_to(c1.c2p(*z), aligned_edge=[-x_0, -y_0, 0])\n            f_v0.move_to(c2.c2p(*f_z), aligned_edge=[-f_x0, -f_y0, 0])\n            vecs.add(v_0)\n            img_vecs.add(f_v0)\n        grp = VGroup(c1, c2, input_dot, vecs, output_dot, img_vecs, input_dot_text, output_dot_text)\n        grp.shift(DOWN)\n        eq = Tex('f(z) = e^z', tex_to_color_map={'f': A_GREEN, 'z': A_PINK, 'e': YELLOW_Z})\n        eq.scale(1.5)\n        eq.shift(UP)\n        text1 = TexText('Complex Differentiable', color=A_GREY)\n        text1.scale(1.5)\n        text1.move_to(2.5 * UP + 3 * LEFT)\n        text2 = TexText('Holomorphic', color=A_GREY)\n        text2.scale(1.5)\n        text2.move_to(2.5 * UP + 4.5 * RIGHT)\n        d = Line(ORIGIN, RIGHT, color=RED, stroke_width=6)\n        d.add_tip()\n        d.add_tip(at_start=True)\n        d.move_to(2.5 * UP + 1.55 * RIGHT)\n        self.play(Write(text1))\n        self.play(Write(d), Write(text2))\n        self.wait()\n        self.play(Write(eq))\n        self.play(Write(c1), Write(c2), Write(input_dot), Write(input_dot_text), Write(output_dot), Write(output_dot_text), Write(vecs))\n        self.play(TransformFromCopy(vecs, img_vecs), ApplyMethod(output_dot_text.shift, 0.8 * DOWN), run_time=5)\n        self.wait()\n        self.embed()\n\n    def get_vec(self, plane, coors, **kwargs):\n        x, y = (coors[0], coors[1])\n        z = plane.c2p(x, y)\n        return Arrow(plane.c2p(0, 0), z, buff=0, **kwargs)\n\n    def f_deriv(self, z, dz=1e-06 + 1e-06 * 1j):\n        return (self.func(z + dz) - self.func(z)) / dz\n\n    def func(self, z):\n        return np.exp(z)"}]}
{"messages": [{"role": "user", "content": "Visualize the transformation of a complex plane under a specific mathematical function."}, {"role": "assistant", "content": "from manimlib import *\n\nclass IntroTransformVis(Scene):\n\n    def construct(self):\n        n = ComplexPlane()\n        n.add_coordinate_labels()\n        self.play(Write(n))\n        self.wait()\n        self.play(Uncreate(n.coordinate_labels))\n        n.prepare_for_nonlinear_transform()\n        self.play(ApplyMethod(n.apply_complex_function, self.func), run_time=7)\n        self.wait()\n        self.embed()\n\n    def func(self, z):\n        return (1 * z + np.sin(z)) * 0.3"}]}
{"messages": [{"role": "user", "content": "Visualize complex function transformations by showing a complex plane, applying different functions, and highlighting specific points and their transformations with labels."}, {"role": "assistant", "content": "from manimlib import *\n\nclass TransformationVisual(Scene):\n\n    def construct(self):\n        n, _n = (ComplexPlane(), ComplexPlane())\n        n.add_coordinate_labels()\n        _n.apply_complex_function(self.func1)\n        _n.add_coordinate_labels()\n        _n.coordinate_labels[:10].shift(0.1 * np.array([-np.sqrt(3), 1, 0]))\n        eq = Tex('f(z) = (1 + \\\\sqrt{3} i) z', tex_to_color_map={'f': A_GREEN, 'z': A_PINK, '1': YELLOW_Z, '\\\\sqrt{3}': YELLOW_Z})\n        eq.add_background_rectangle(buff=0.25)\n        eq.scale(1.5)\n        eq.shift(3 * UP)\n        d = Dot(RIGHT, color=RED)\n        d_lbl = Tex('1', color=A_RED)\n        d_lbl.add_background_rectangle(buff=0.15)\n        d_lbl.next_to(d, DOWN)\n        d2 = Dot([1, np.sqrt(3), 0], color=RED)\n        d_lbl2 = Tex('1 + \\\\sqrt{3}i', color=A_RED)\n        d_lbl2.add_background_rectangle(buff=0.15)\n        d_lbl2.next_to(d2, DOWN)\n        self.play(Write(n), Write(eq))\n        self.play(Write(d), Write(d_lbl))\n        self.wait()\n        self.play(Uncreate(n.coordinate_labels))\n        self.bring_to_back(n)\n        self.play(ApplyMethod(n.apply_complex_function, self.func1, foreground_mobjects=[eq]), Transform(d, d2), FadeTransform(d_lbl, d_lbl2), run_time=7)\n        self.bring_to_back(n)\n        self.wait()\n        eq2 = Tex('f(z) = (2e^{\\\\frac{\\\\pi}{3}i}) z', tex_to_color_map={'f': A_GREEN, 'z': A_PINK, '2': YELLOW_Z, '\\\\frac{\\\\pi}{3}': YELLOW_Z})\n        eq2.scale(1.5)\n        eq2.shift(3 * UP)\n        eq2.add_background_rectangle()\n        self.play(Transform(eq, eq2))\n        self.wait()\n        n2 = ComplexPlane()\n        eq3 = Tex('f(z) = z^2', tex_to_color_map={'f': A_GREEN, 'z': A_PINK})\n        eq3.scale(1.5)\n        eq3.shift(3 * UP)\n        eq3.add_background_rectangle()\n        self.bring_to_back(n)\n        self.play(Uncreate(d), Uncreate(d_lbl2), Transform(eq, eq3), Transform(n, n2))\n        self.bring_to_back(n)\n\n        def g(z):\n            return z ** 2\n        n.prepare_for_nonlinear_transform()\n        d1 = Dot([1, 0, 0], color=RED)\n        d1_c = d1.copy()\n        d1_lbl = Tex('1', color=RED)\n        d1_lbl.add_background_rectangle(buff=0.15)\n        d1_lbl.next_to(d1, DOWN)\n        d1_lbl_c = d1_lbl.copy()\n        d2 = Dot([0, 1, 0], color=RED)\n        d2_c = d2.copy()\n        d2_lbl = Tex('i', color=RED)\n        d2_lbl.add_background_rectangle(buff=0.15)\n        d2_lbl.next_to(d2, DOWN)\n        d2_lbl_c = d2_lbl.copy()\n        d3 = Dot([2, 0, 0], color=RED)\n        d3_c = d3.copy()\n        d3_lbl = Tex('2', color=RED)\n        d3_lbl.add_background_rectangle(buff=0.15)\n        d3_lbl.next_to(d3, DOWN)\n        d3_lbl_c = d3_lbl.copy()\n        d1_n = Dot([1, 0, 0], color=RED)\n        d1_n_lbl = Tex('1', color=RED)\n        d1_n_lbl.add_background_rectangle(buff=0.15)\n        d1_n_lbl.next_to(d1_n, DOWN)\n        d2_n = Dot([-1, 0, 0], color=RED)\n        d2_n_lbl = Tex('-1', color=RED)\n        d2_n_lbl.add_background_rectangle(buff=0.15)\n        d2_n_lbl.next_to(d2_n, DOWN)\n        d3_n = Dot([4, 0, 0], color=RED)\n        d3_n_lbl = Tex('4', color=RED)\n        d3_n_lbl.add_background_rectangle(buff=0.15)\n        d3_n_lbl.next_to(d3_n, DOWN)\n        self.play(Write(d1), Write(d1_lbl), Write(d2), Write(d2_lbl), Write(d3), Write(d3_lbl))\n        self.wait()\n        self.bring_to_back(n)\n        self.play(ApplyMethod(n.apply_complex_function, g), Transform(d1, d1_n), FadeTransform(d1_lbl, d1_n_lbl), Transform(d2, d2_n), FadeTransform(d2_lbl, d2_n_lbl), Transform(d3, d3_n), FadeTransform(d3_lbl, d3_n_lbl), run_time=7)\n        self.bring_to_back(n)\n        n_ = ComplexPlane()\n        self.play(Transform(n, n_), Transform(d1, d1_c), FadeTransform(d1_n_lbl, d1_lbl_c), Transform(d2, d2_c), FadeTransform(d2_n_lbl, d2_lbl_c), Transform(d3, d3_c), FadeTransform(d3_n_lbl, d3_lbl_c), run_time=3)\n        self.bring_to_back(n)\n        self.wait(2)\n        self.play(ApplyMethod(n.apply_complex_function, g), Transform(d1, d1_n), FadeTransform(d1_lbl_c, d1_n_lbl), Transform(d2, d2_n), FadeTransform(d2_lbl_c, d2_n_lbl), Transform(d3, d3_n), FadeTransform(d3_lbl_c, d3_n_lbl), run_time=5)\n        self.bring_to_back(n)\n        self.wait()\n        self.play(Transform(n, n_), Uncreate(d1), Uncreate(d1_n_lbl), Uncreate(d2), Uncreate(d2_n_lbl), Uncreate(d3), Uncreate(d3_n_lbl), run_time=2)\n        self.wait(0.5)\n        r = Rectangle(height=3, width=4, fill_color=BLACK, fill_opacity=1, stroke_color=A_ORANGE)\n        r.move_to([4, 2, 0])\n        eq4 = Tex(\"f'(z) = 2z\", tex_to_color_map={\"f'\": A_GREEN, 'z': A_PINK})\n        eq4.move_to([-5.5, 2.5, 0])\n        br2 = Rectangle(height=2, width=12, fill_opacity=0.75, color=BLACK)\n        br2.move_to([-5, 3, 0])\n        br = Rectangle(height=2, width=3, fill_opacity=0.75, color=BLACK)\n        br.move_to([-5.5, 3, 0])\n        z_rect = Rectangle(height=0.2, width=0.2, color=A_ORANGE)\n        z_rect.move_to([-1, 2, 0])\n        f_rect = Rectangle(height=0.2, width=0.2, color=A_ORANGE)\n        f_rect.move_to([-3, -4, 0])\n        obj = VMobject()\n        for i in eq:\n            if i is not eq.background_rectangle:\n                obj.add(i)\n        eq5 = Tex('f(-1+2i) = -3-4i', tex_to_color_map={'1': YELLOW_Z, '2': YELLOW_Z, '3': YELLOW_Z, '4': YELLOW_Z, 'f': A_GREEN})\n        eq5.move_to([-1.5, 3.5, 0])\n        eq6 = Tex(\"f'(-1+2i) = -2+4i\", tex_to_color_map={'1': YELLOW_Z, '2': YELLOW_Z, '4': YELLOW_Z, \"f'\": A_GREEN})\n        eq6.move_to([-1.5, 2.5, 0])\n        z_lbl = Tex('-1+2i', color=A_ORANGE)\n        z_lbl.add_background_rectangle(buff=0.15)\n        z_lbl.next_to(z_rect, LEFT + DOWN)\n        z_lbl2 = Tex('-3-4i', color=A_ORANGE)\n        z_lbl2.add_background_rectangle(buff=0.15)\n        z_lbl2.next_to(f_rect, LEFT + UP)\n        z_rect_points = z_rect.get_vertices()\n        f_rect_points = f_rect.get_vertices()\n        r_points = deepcopy(r.get_vertices())\n        dash_1 = DashedLine(z_rect_points[0], r_points[1])\n        dash_2 = DashedLine(z_rect_points[3], r_points[2])\n        dash_1f = DashedLine(f_rect_points[0], r_points[1])\n        dash_2f = DashedLine(f_rect_points[3], r_points[2])\n        self.play(Write(br), ApplyMethod(obj.scale, 1 / 1.5), Uncreate(eq.background_rectangle))\n        self.bring_to_front(eq)\n        self.play(ApplyMethod(eq.move_to, 5.5 * LEFT + 3.5 * UP), Write(eq4))\n        self.play(Write(r), Write(z_rect), Write(dash_1), Write(dash_2))\n        self.play(Write(z_lbl))\n        self.bring_to_front(br)\n        self.bring_to_front(eq, eq4)\n        self.wait()\n        self.play(Transform(br, br2))\n        self.play(Write(eq5), Write(eq6))\n        self.wait()\n        self.play(ApplyMethod(n.apply_complex_function, g), Transform(z_rect, f_rect), FadeTransform(z_lbl, z_lbl2), Transform(dash_1, dash_1f), Transform(dash_2, dash_2f), run_time=10)\n        self.wait()\n        eq7 = Tex('f(1+i) = 2i', tex_to_color_map={'1': YELLOW_Z, '2': YELLOW_Z, 'f': A_GREEN})\n        eq7.move_to([-1.5, 3.5, 0])\n        eq8 = Tex(\"f'(1+i) = 2+2i\", tex_to_color_map={'1': YELLOW_Z, '2': YELLOW_Z, \"f'\": A_GREEN})\n        eq8.move_to([-1.5, 2.5, 0])\n        z_rect2 = Rectangle(height=0.2, width=0.2, color=A_ORANGE)\n        z_rect2.move_to([1, 1, 0])\n        z_rect_points2 = z_rect2.get_vertices()\n        f_rect2 = Rectangle(height=0.2, width=0.2, color=A_ORANGE)\n        f_rect2.move_to([0, 2, 0])\n        f_rect_points2 = f_rect2.get_vertices()\n        dash1_2 = DashedLine(z_rect_points2[0], r_points[1])\n        dash2_2 = DashedLine(z_rect_points2[3], r_points[2])\n        dash1f_2 = DashedLine(f_rect_points2[0], r_points[1])\n        dash2f_2 = DashedLine(f_rect_points2[3], r_points[2])\n        z2_lbl = Tex('1+i', color=A_ORANGE)\n        z2_lbl.add_background_rectangle(buff=0.15)\n        z2_lbl.next_to(z_rect2, LEFT + DOWN)\n        z2_lbl2 = Tex('2i', color=A_ORANGE)\n        z2_lbl2.add_background_rectangle(buff=0.15)\n        z2_lbl2.next_to(f_rect2, LEFT + DOWN)\n        self.play(Transform(n, n_), Transform(dash_1, dash1_2), Transform(dash_2, dash2_2), Transform(z_rect, z_rect2), Transform(eq5, eq7), Transform(eq6, eq8), FadeTransform(z_lbl2, z2_lbl), run_time=2)\n        self.wait()\n        self.play(ApplyMethod(n.apply_complex_function, g), Transform(z_rect, f_rect2), FadeTransform(z2_lbl, z2_lbl2), Transform(dash_1, dash1f_2), Transform(dash_2, dash2f_2), run_time=10)\n        self.wait()\n        eq9 = Tex('f({{z}}) = \\\\bar{z}^2 \\\\cdot \\\\sin{({{z}})}', tex_to_color_map={'\\\\bar{z}': A_PINK, '{{z}}': A_PINK, 'f': A_GREEN})\n        eq9.add_background_rectangle(buff=0.15)\n        eq9.scale(1.5)\n        eq9.move_to([-4.25, 3.25, 0])\n        f_rect3 = Rectangle(height=0.2, width=0.2, color=A_ORANGE)\n        f_rect3.move_to([1.26992, -2.59691, 0])\n        f_rect_points3 = f_rect3.get_vertices()\n        z3_lbl = Tex('1+i', color=A_ORANGE)\n        z3_lbl.add_background_rectangle(buff=0.15)\n        z3_lbl.next_to(z_rect2, LEFT)\n        z3_lbl2 = Tex('1.27 - 2.59i', color=A_ORANGE)\n        z3_lbl2.add_background_rectangle(buff=0.15)\n        z3_lbl2.next_to(f_rect3, LEFT)\n        dash1f_3 = DashedLine(f_rect_points3[0], r_points[1])\n        dash2f_3 = DashedLine(f_rect_points3[3], r_points[2])\n        self.play(Uncreate(VGroup(eq, eq4, eq5, eq6, br)), Transform(n, n_), Transform(z_rect, z_rect2), Transform(dash_1, dash1_2), Transform(dash_2, dash2_2), FadeTransform(z2_lbl2, z3_lbl))\n        self.play(Write(eq9))\n        self.embed()\n        n.prepare_for_nonlinear_transform()\n        self.play(ApplyMethod(n.apply_complex_function, self.func2), Transform(z_rect, f_rect3), Transform(dash_1, dash1f_3), Transform(dash_2, dash2f_3), FadeTransform(z3_lbl, z3_lbl2), run_time=10)\n        self.embed()\n\n    def func1(self, z):\n        return (1 + np.sqrt(3) * 1j) * z\n\n    def func2(self, z):\n        return z.conjugate() ** 2 * np.sin(z)\n\n    def lin_func(self, z, dz=1e-06):\n        x = 1 + 1j\n        return (self.func2(z * dz + x) - self.func2(x)) / dz"}]}
{"messages": [{"role": "user", "content": "Visualize a complex plane with a zoom effect applied to its function."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ZoomComplexScene(Scene):\n    CONFIG = {'f_deriv': 1, 'plane_color': A_LAVENDER, 'start_run_time': 10, 'end_run_time': 2, 'radius': 10 * DEFAULT_DOT_RADIUS}\n\n    def construct(self):\n        c = ComplexPlane(background_line_style={'stroke_color': self.plane_color, 'stroke_width': 8, 'stroke_opacity': 1}, faded_line_ratio=4, x_range=[-16, 16, 2], y_range=[-16, 16, 2])\n        cp = c.copy()\n        self.play(Write(c))\n        self.wait()\n        self.play(ApplyMethod(c.apply_complex_function, self.func), run_time=self.start_run_time)\n        self.wait()\n        self.play(Transform(c, cp), run_time=self.end_run_time)\n        self.wait()\n\n    def func(self, z):\n        return self.f_deriv * z"}]}
{"messages": [{"role": "user", "content": "Illustrate the Cauchy-Riemann equations by transforming complex number multiplication into partial derivatives and then demonstrate the equations with two examples of complex functions."}, {"role": "assistant", "content": "from manimlib import *\n\nclass MatrixComplex(Scene):\n\n    def construct(self):\n        eq = Tex('(a+bi)(x+yi)', tex_to_color_map={'f': A_GREEN, 'x': A_ORANGE, 'y': A_ORANGE, 'a': A_YELLOW, 'b': A_YELLOW})\n        eq.scale(1.5)\n        eq.move_to(3 * UP + 2 * LEFT)\n        color_map = {'f': A_GREEN, 'x': A_ORANGE, 'y': A_ORANGE, 'a': A_YELLOW, 'b': A_YELLOW}\n        eq2 = Tex('(ax-by)', ' + ', '(bx+ay)i', tex_to_color_map=color_map)\n        eq2.scale(1.5)\n        eq2.move_to(eq, LEFT)\n        eq2.shift(1.5 * DOWN)\n        equals = Tex('=')\n        equals.scale(1.5)\n        equals.next_to(eq2, LEFT)\n        m1 = Matrix([['a', '-b'], ['b', 'a']], element_to_mobject=lambda m: Tex(m, tex_to_color_map=color_map))\n        m1 = Matrix([['a', '-b'], ['b', 'a']], element_to_mobject=lambda m: Tex(m, tex_to_color_map={'a': A_YELLOW, 'b': A_YELLOW}))\n        m1.scale(1.5)\n        m1.shift(0.75 * DOWN + 2.5 * LEFT)\n        m2 = Matrix([['x'], ['y']], element_to_mobject=lambda m: Tex(m, color=A_ORANGE))\n        m2.scale(1.5)\n        m2.move_to(m1)\n        m2.shift(2.75 * RIGHT)\n        self.play(Write(eq))\n        self.wait()\n        self.play(Write(equals), Write(eq2))\n        self.wait()\n        self.play(TransformFromCopy(eq2[1], m1[0][0]), TransformFromCopy(eq2[3:5], m1[0][1]))\n        self.play(TransformFromCopy(eq2[9], m1[0][2]), TransformFromCopy(eq2[12], m1[0][3]))\n        self.play(Write(m1.brackets))\n        self.wait()\n        self.play(TransformFromCopy(VGroup(eq2[2], eq2[10]), m2[0][0]))\n        self.play(TransformFromCopy(VGroup(eq2[6], eq2[13]), m2[0][1]))\n        self.play(Write(m2.brackets))\n        self.wait()\n        J = Matrix([['{\\\\partial {' + i + '} \\\\over \\\\partial {' + j + '}}' for j in ['x', 'y']] for i in ['u', 'v']], element_to_mobject=lambda m: Tex(m, tex_to_color_map={'{v}': A_YELLOW, '{u}': A_YELLOW, '{x}': A_ORANGE, '{y}': A_ORANGE}), v_buff=1.25)\n        J.move_to(2 * UP + 3 * RIGHT)\n        equals2 = Tex('=')\n        equals2.scale(1.5)\n        equals2.shift(2 * UP)\n        self.play(Uncreate(VGroup(m2, eq, equals, eq2)))\n        self.play(ApplyMethod(m1.move_to, 2 * UP + 3 * LEFT))\n        self.play(Write(J))\n        self.play(Write(equals2))\n        self.wait()\n        self.play(*[Indicate(obj, scale_factor=1.5) for obj in [m1[0][0], m1[0][3], J[0][0], J[0][3]]])\n        self.wait()\n        eq3 = Tex('{\\\\partial {u} \\\\over \\\\partial {x}}', '=', '{\\\\partial {v} \\\\over \\\\partial {y}}', tex_to_color_map={'{v}': A_YELLOW, '{u}': A_YELLOW, '{x}': A_ORANGE, '{y}': A_ORANGE})\n        eq3.scale(1.5)\n        eq3.shift(0.5 * DOWN)\n        self.play(TransformFromCopy(J[0][0], eq3[:4]))\n        self.play(Write(eq3[4]))\n        self.play(TransformFromCopy(J[0][3], eq3[5:]))\n        self.wait()\n        eq4 = Tex('{\\\\partial {u} \\\\over \\\\partial {y}}', '=', ' -', '{\\\\partial {v} \\\\over \\\\partial {x}}', tex_to_color_map={'{v}': A_YELLOW, '{u}': A_YELLOW, '{x}': A_ORANGE, '{y}': A_ORANGE})\n        eq4.scale(1.5)\n        eq4.shift(2.5 * DOWN)\n        self.play(*[Indicate(obj, scale_factor=1.5) for obj in [m1[0][1], m1[0][2], J[0][1], J[0][2]]])\n        self.wait()\n        self.play(TransformFromCopy(J[0][1], eq4[:4]))\n        self.play(Write(eq4[4]))\n        self.play(TransformFromCopy(J[0][2], eq4[6:]), Write(eq4[5]))\n        self.wait()\n        title = TexText('Cauchy-Riemann Equations', color=A_RED)\n        title.scale(1.5)\n        title.move_to(3 * UP)\n        self.play(Uncreate(VGroup(equals2, m1, J)), ApplyMethod(VGroup(eq3, eq4).center))\n        self.play(Write(title))\n        self.wait()\n        eqs = VGroup(eq3, eq4)\n        l = Line(10 * UP, 10 * DOWN)\n        self.play(Uncreate(title), ApplyMethod(eqs.move_to, FRAME_WIDTH / 4 * RIGHT), Write(l))\n        self.wait()\n        eq1 = Tex('f(z) = z^2', tex_to_color_map={'f': A_GREEN, 'z': A_PINK})\n        eq1.move_to(5.65 * LEFT + 3 * UP)\n        eq2 = Tex('f(x+yi) = ', '(x^2 - y^2)', '+', '(2xy)', 'i', tex_to_color_map={'f': A_GREEN, 'x': A_ORANGE, 'y': A_ORANGE, '2': A_YELLOW})\n        eq2.shift(3.5 * LEFT + 2 * UP)\n        b1 = Brace(eq2[6:13])\n        bt1 = Tex('u', color=A_YELLOW)\n        b1.put_at_tip(bt1)\n        b2 = Brace(eq2[14:19])\n        bt2 = Tex('v', color=A_YELLOW)\n        b2.put_at_tip(bt2)\n        color_map2 = {'{v}': A_YELLOW, '{u}': A_YELLOW, '{x}': A_ORANGE, '{y}': A_ORANGE}\n        eq3 = Tex('{\\\\partial {u} \\\\over \\\\partial {x}} = 2{x}', tex_to_color_map=color_map2)\n        eq3.move_to(5.75 * LEFT + 0.5 * DOWN)\n        eq4 = Tex('{\\\\partial {v} \\\\over \\\\partial {y}} = 2{x}', tex_to_color_map=color_map2)\n        eq4.move_to(5.75 * LEFT + 2.5 * DOWN)\n        eq5 = Tex('{\\\\partial {u} \\\\over \\\\partial {y}} = -2{y}', tex_to_color_map=color_map2)\n        eq5.move_to(2.25 * LEFT + 0.5 * DOWN)\n        eq6 = Tex('{\\\\partial {v} \\\\over \\\\partial {x}} = 2{y}', tex_to_color_map=color_map2)\n        eq6.move_to(2.25 * LEFT + 2.5 * DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        self.play(Write(eq2))\n        self.play(Write(VGroup(b1, bt1)), Write(VGroup(b2, bt2)))\n        self.wait()\n        self.play(Write(eq3))\n        self.wait(1)\n        self.play(Write(eq4))\n        self.wait(1)\n        self.play(Write(eq5))\n        self.wait(1)\n        self.play(Write(eq6))\n        self.wait()\n        self.play(Uncreate(VGroup(eq1, eq2, eq3, eq4, eq5, eq6, b1, bt1, b2, bt2)))\n        self.wait()\n        eq1 = Tex('f(z) = \\\\bar{z}', tex_to_color_map={'f': A_GREEN, 'z': A_PINK})\n        eq1.move_to(5.65 * LEFT + 3 * UP)\n        eq2 = Tex('f(x+yi) = ', 'x', '-', 'y', 'i', tex_to_color_map={'f': A_GREEN, 'x': A_ORANGE, 'y': A_ORANGE, '2': A_YELLOW})\n        eq2.shift(4.7 * LEFT + 2 * UP)\n        b1 = Brace(eq2[6])\n        bt1 = Tex('u', color=A_YELLOW)\n        b1.put_at_tip(bt1)\n        b2 = Brace(eq2[7:9])\n        bt2 = Tex('v', color=A_YELLOW)\n        b2.put_at_tip(bt2)\n        color_map2 = {'{v}': A_YELLOW, '{u}': A_YELLOW, '{x}': A_ORANGE, '{y}': A_ORANGE}\n        eq3 = Tex('{\\\\partial {u} \\\\over \\\\partial {x}} = 1', tex_to_color_map=color_map2)\n        eq3.move_to(5.75 * LEFT + 0.5 * DOWN)\n        eq4 = Tex('{\\\\partial {v} \\\\over \\\\partial {y}} = -1', tex_to_color_map=color_map2)\n        eq4.move_to(5.75 * LEFT + 2.5 * DOWN)\n        eq5 = Tex('{\\\\partial {u} \\\\over \\\\partial {y}} = 0', tex_to_color_map=color_map2)\n        eq5.move_to(2.25 * LEFT + 0.5 * DOWN)\n        eq6 = Tex('{\\\\partial {v} \\\\over \\\\partial {x}} = 0', tex_to_color_map=color_map2)\n        eq6.move_to(2.25 * LEFT + 2.5 * DOWN)\n        self.play(Write(eq1))\n        self.wait(1)\n        self.play(Write(eq2))\n        self.play(Write(VGroup(b1, bt1)), Write(VGroup(b2, bt2)))\n        self.wait()\n        self.play(Write(eq3))\n        self.wait(1)\n        self.play(Write(eq4))\n        self.wait(1)\n        self.play(Write(eq5))\n        self.wait(1)\n        self.play(Write(eq6))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display a complex plane with a rectangle and a point labeled \"1+1i\", then animate the exponential function's transformation of the point and rectangle to \"1.47+2.29i\" within the complex plane."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ExpDeriv(Scene):\n\n    def construct(self):\n        c = ComplexPlane()\n        c.add_coordinate_labels()\n        c.prepare_for_nonlinear_transform()\n        r = Rectangle(height=3, width=4, fill_color=BLACK, fill_opacity=1, stroke_color=A_ORANGE)\n        r.move_to([-4, 2, 0])\n        z_rect = Rectangle(width=0.2, height=0.2, stroke_color=A_ORANGE)\n        z_rect.move_to([1, 1, 0])\n        z_lbl = Tex('1+1i', color=A_ORANGE)\n        z_lbl.add_background_rectangle(buff=0.15)\n        z_lbl.next_to(z_rect, DOWN)\n        f_rect = Rectangle(width=0.2, height=0.2, stroke_color=A_ORANGE)\n        f_rect.move_to([1.47, 2.29, 0])\n        f_lbl = Tex('1.47+2.29i', color=A_ORANGE)\n        f_lbl.add_background_rectangle(buff=0.15)\n        f_lbl.next_to(f_rect, DOWN)\n        r_vertices = r.get_vertices()\n        f_vertices = f_rect.get_vertices()\n        z_vertices = z_rect.get_vertices()\n        l1 = DashedLine(r_vertices[0], z_vertices[1])\n        l2 = DashedLine(r_vertices[3], z_vertices[2])\n        l1_f = DashedLine(r_vertices[0], f_vertices[1])\n        l2_f = DashedLine(r_vertices[3], f_vertices[2])\n        self.play(Write(c))\n        self.play(Write(z_rect), Write(l1), Write(l2), Write(r))\n        self.play(Write(z_lbl))\n        self.wait()\n        self.play(Uncreate(c.coordinate_labels))\n        self.bring_to_back(c)\n        self.play(ApplyMethod(c.apply_complex_function, np.exp), Transform(z_rect, f_rect), FadeTransform(z_lbl, f_lbl), Transform(l1, l1_f), Transform(l2, l2_f), run_time=10)\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display the title \"Complex Differentiation\" and three different differentiation rules with corresponding color-coded terms."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ComplexDiffRules(Scene):\n\n    def construct(self):\n        color_map = {'z': A_PINK, \"f'\": A_GREEN, \"g'\": A_AQUA, 'f': A_GREEN, 'g': A_AQUA, '{1}': A_YELLOW, '{n}': A_YELLOW}\n        eq1 = Tex(\"[f(g(z))]' = f'(g(z)) \\\\cdot g'(z)\", tex_to_color_map=color_map)\n        eq1.scale(1.5)\n        eq1.shift(1.5 * UP)\n        eq2 = Tex(\"[f(z)g(z)]' = f'(z)g(z) + f(z)g'(z)\", tex_to_color_map=color_map)\n        eq2.scale(1.5)\n        eq3 = Tex(\"[z^{n}]' = {z^{n} {}^{+} {}^{1} \\\\over {n}+{1}}\", tex_to_color_map=color_map)\n        eq3.scale(1.5)\n        eq3.move_to(2 * DOWN)\n        title = TexText('Complex Differentiation', color=A_LAVENDER)\n        title.scale(1.5)\n        title.move_to(3 * UP)\n        self.play(Write(title))\n        self.play(Write(eq1), Write(eq2), Write(eq3))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Create a scene with a solid background rectangle and animate a title appearing at the top with a screen rectangle below it."}, {"role": "assistant", "content": "from manimlib import *\n\nclass TitleScene(Scene):\n    CONFIG = {'color': None, 'text': None}\n\n    def construct(self):\n        if self.text is None:\n            raise NotImplementedError\n        brect = Rectangle(height=FRAME_HEIGHT, width=FRAME_WIDTH, fill_opacity=1, color=self.color)\n        title = TexText(self.text)\n        title.scale(1.5)\n        title.to_edge(UP)\n        rect = ScreenRectangle(height=6)\n        rect.next_to(title, DOWN)\n        self.add(brect)\n        self.play(FadeIn(rect, DOWN), Write(title), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the transformation of complex numbers using two complex planes, showing input and output points and vectors along with their labels."}, {"role": "assistant", "content": "from manimlib import *\n\nclass Thumbnail(Scene):\n    CONFIG = {'plane_opacity': 0.65, 'x': 0.5, 'y': 0.5, 'vec_opacity': 1}\n\n    def construct(self):\n        NumberPlane\n        complex_kwargs = {'background_line_style': {'stroke_opacity': self.plane_opacity, 'stroke_width': 8}}\n        c1 = ComplexPlane(x_range=(-3, 3), y_range=(-3, 3), **complex_kwargs)\n        c1.axes.set_opacity(self.plane_opacity)\n        c1.shift(FRAME_WIDTH / 4 * LEFT)\n        c2 = ComplexPlane(x_range=(-3, 3), y_range=(-3, 3), **complex_kwargs)\n        c2.shift(FRAME_WIDTH / 4 * RIGHT)\n        input_dot = Dot(c1.c2p(-self.x, self.y), color=PURPLE)\n        input_dot.set_color(A_PINK)\n        input_dot_text = Tex('z', color=A_PINK)\n        input_dot_text.add_background_rectangle()\n        input_dot_text.next_to(input_dot, DOWN)\n        input_dot_text.shift(0.5 * DOWN)\n        f_z = self.func(self.x + self.y * 1j)\n        f_z = np.array([f_z.real, f_z.imag, 0])\n        output_dot = Dot(c2.c2p(*f_z), color=A_GREEN)\n        output_dot_text = Tex('f(z)', tex_to_color_map={'z': A_PINK, 'f': A_GREEN})\n        output_dot_text.add_background_rectangle()\n        output_dot_text.next_to(output_dot, DOWN)\n        z = [-self.x, self.y]\n        z_deriv = self.f_deriv(self.x + self.y * 1j)\n        f_z = self.func(self.x + self.y * 1j)\n        f_z = [f_z.real, f_z.imag]\n        img_vecs = VGroup()\n        vecs = VGroup()\n        for t in np.linspace(0, 2 * PI, 15)[:-1]:\n            z_0 = np.exp(t * 1j)\n            x_0, y_0 = (0.75 * z_0.real, 0.75 * z_0.imag)\n            f_z0 = 0.5 * z_0 * z_deriv\n            f_x0, f_y0 = (f_z0.real, f_z0.imag)\n            v_0 = self.get_vec(c1, [x_0, y_0], stroke_color=A_PINK, stroke_opacity=self.vec_opacity, stroke_width=10, width_to_tip_len=0.0075 * 4)\n            f_v0 = self.get_vec(c2, [f_x0, f_y0], stroke_color=A_GREEN, stroke_opacity=self.vec_opacity, stroke_width=10, width_to_tip_len=0.0075 * 4)\n            v_0.move_to(c1.c2p(*z), aligned_edge=[-x_0, -y_0, 0])\n            f_v0.move_to(c2.c2p(*f_z), aligned_edge=[-f_x0, -f_y0, 0])\n            vecs.add(v_0)\n            img_vecs.add(f_v0)\n        vecs.scale(3)\n        img_vecs.scale(5)\n        dz_lbl = Tex('dz', tex_to_color_map={'z': A_PINK})\n        dz_lbl.add_background_rectangle(buff=0.1)\n        dz_lbl.scale(2)\n        dz_lbl.next_to(vecs, DOWN)\n        df_lbl = Tex('df', tex_to_color_map={'f': A_GREEN})\n        df_lbl.add_background_rectangle(buff=0.1)\n        df_lbl.scale(2)\n        df_lbl.next_to(img_vecs, DOWN)\n        c2.prepare_for_nonlinear_transform()\n        c2.apply_complex_function(self.func)\n        c2.shift(FRAME_WIDTH / 4 * RIGHT)\n        self.add(c1, c2, input_dot, output_dot, vecs, img_vecs, dz_lbl, df_lbl)\n        grp1 = VGroup(c1, input_dot, vecs, dz_lbl)\n        grp1.scale(0.5)\n        grp1.scale(1 / 0.5)\n        grp1.scale(0.85)\n        grp2 = VGroup(c2, output_dot, img_vecs, df_lbl)\n        grp2.scale(0.85)\n        grp2.move_to(FRAME_WIDTH / 4 * RIGHT)\n        grp1.center()\n        grp2.center()\n        grp1.shift(FRAME_WIDTH / 4 * LEFT)\n        grp2.shift(FRAME_WIDTH / 4 * RIGHT)\n        n = NumberPlane(axis_config={'stroke_opacity': 0.35}, background_line_style={'stroke_color': GREY, 'stroke_opacity': 0.35}, faded_line_style={'stroke_width': 0})\n        self.bring_to_back(n)\n        self.wait(1)\n        self.embed()\n\n    def get_vec(self, plane, coors, **kwargs):\n        x, y = (coors[0], coors[1])\n        z = plane.c2p(x, y)\n        return Arrow(plane.c2p(0, 0), z, buff=0, **kwargs)\n\n    def f_deriv(self, z, dz=1e-06 + 1e-06 * 1j):\n        return (self.func(z + dz) - self.func(z)) / dz\n\n    def func(self, z):\n        return (1 * z + np.sin(z)) * 0.3 - 1"}]}
{"messages": [{"role": "user", "content": "Show a textured sphere orbiting a camera that pans and rotates, then transform it into a textured parametric surface."}, {"role": "assistant", "content": "from manimlib import *\n\nclass BrilliantAnim(Scene):\n\n    def construct(self):\n        p = Sphere(radius=2)\n        p.shift(3 * OUT)\n        p2 = ParametricSurface(self.func2, u_range=(0, 2 * PI), v_range=(0, 1), fill_opacity=1, resolution=(101, 101))\n        sp = TexturedSurface(p, 'img/earth_texture.jpeg')\n        sp2 = TexturedSurface(p2, 'img/earth_texture.jpeg')\n        self.camera.frame.shift(2 * OUT)\n        self.camera.frame.set_euler_angles(-9.96354167, 1.35, 0)\n        self.camera.frame.add_updater(lambda f, dt: f.become(f.increment_theta(0.2 * dt)))\n        self.play(ShowCreation(sp))\n        self.wait(2)\n        self.play(TransformFromCopy(sp, sp2), run_time=7)\n        self.wait(10)\n\n    def func2(self, u, v):\n        x, y, z = 2 * np.array([np.cos(u) * np.sin(v), np.sin(u) * np.sin(v), np.cos(v)])\n        return np.array([x / (1 - z), y / (1 - z), 0])"}]}
{"messages": [{"role": "user", "content": "Create an interactive Manim scene that continuously updates the frame until interrupted."}, {"role": "assistant", "content": "from manimlib import *\nimport itertools\n\nclass Scene(Scene):\n\n    def interact(self):\n        self.quit_interaction = False\n        self.lock_static_mobject_data()\n        try:\n            while True:\n                self.update_frame()\n        except KeyboardInterrupt:\n            self.unlock_mobject_data()"}]}
{"messages": [{"role": "user", "content": "Visualize a lattice grid of dots on a number plane and an embedded torus."}, {"role": "assistant", "content": "from manimlib import *\nimport itertools\n\nclass LatticeTorus(Scene):\n\n    def construct(self):\n        f_plane_kwargs = {'x_range': (-4, 4), 'y_range': (-3, 3)}\n        points = VGroup()\n        plane2 = NumberPlane(**f_plane_kwargs)\n        for x, y in itertools.product(*[np.arange(args[0], args[1] + 1, args[2]) for args in plane2.get_all_ranges()]):\n            points.add(Dot([x, y, 0]))\n        self.add(plane2, points)\n        self.embed()\n\n    def cyln(self, u, v):\n        return np.array([np.cos(u), np.sin(u), v])"}]}
{"messages": [{"role": "user", "content": "Present the words \"Single Variable\" and \"Multivariable\" separated by a vertical line and fade them in."}, {"role": "assistant", "content": "from manimlib import *\nfrom manimlib.once_useful_constructs.graph_scene import GraphScene\n\nclass Intro(Scene):\n\n    def construct(self):\n        self.interact()\n        l = Line(10 * UP, 10 * DOWN)\n        title1 = TexText('Single Variable')\n        title1.scale(1.5)\n        title1.move_to(FRAME_WIDTH / 4 * LEFT + 3.5 * UP, UP)\n        title2 = TexText('Multivariable')\n        title2.scale(1.5)\n        title2.move_to(FRAME_WIDTH / 4 * RIGHT + 3.5 * UP, UP)\n        self.play(FadeIn(title1, DOWN), FadeIn(title2, DOWN), Write(l))\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Show a Manim scene with an embedded debugger."}, {"role": "assistant", "content": "from manimlib import *\nfrom manimlib.once_useful_constructs.graph_scene import GraphScene\n\nclass IntroGraphRight(Scene):\n\n    def construct(self):\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Enter an interactive debugging session for a Manim scene."}, {"role": "assistant", "content": "from manimlib import *\nfrom manimlib.once_useful_constructs.graph_scene import GraphScene\n\nclass PartialExample(Scene):\n\n    def construct(self):\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Animate a plane flying towards a hotel."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        hotel = SVGMobject(file_name='files/hotel.svg')\n        plane = SVGMobject(file_name='files/black-plane.svg')\n        hotel.move_to(3 * RIGHT)\n        plane.move_to(3 * LEFT)\n        self.play(Write(plane))\n        self.play(Write(hotel), ApplyMethod(plane.shift, 3.5 * RIGHT))"}]}
{"messages": [{"role": "user", "content": "Display a Wi-Fi logo."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Wifi(Scene):\n\n    def construct(self):\n        wifi = SVGMobject(file_name='files/wifi.svg')\n        self.play(Write(wifi))"}]}
{"messages": [{"role": "user", "content": "Display the word \"Reconnaissance\" in blue, animate it shifting up, and then display its definition below."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Reconnaissance(Scene):\n\n    def construct(self):\n        r = TextMobject('Reconnaissance', color=BLUE)\n        r.scale(3)\n        self.play(Write(r))\n        self.wait(2)\n        self.play(ApplyMethod(r.shift, 1 * UP))\n        t = TextMobject('Act of information gathering')\n        t.shift(1 * DOWN)\n        t.scale(1.5)\n        self.play(Write(t))"}]}
{"messages": [{"role": "user", "content": "Display the text \"Defining The Problem\" in red and scaled up."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Defining(Scene):\n\n    def construct(self):\n        d = TextMobject('Defining The Problem', color=RED)\n        d.scale(2)\n        self.play(Write(d))"}]}
{"messages": [{"role": "user", "content": "Demonstrate the time it takes to brute-force passwords of increasing character lengths."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass BruteForce(Scene):\n\n    def construct(self):\n        b = TextMobject('Brute Force', color=YELLOW)\n        h1 = TextMobject('4 Characters')\n        h12 = TextMobject('4 Characters:')\n        t1 = TexMobject('256^4')\n        t2 = TexMobject('4294967296')\n        t3 = TextMobject('136 Years')\n        h12.scale(1.25)\n        h1.scale(1.5)\n        t1.scale(1.5)\n        t2.scale(1.5)\n        t3.scale(1.5)\n        b.scale(2)\n        self.play(Write(b))\n        self.play(ApplyMethod(b.shift, 3 * UP))\n        self.play(Write(h1))\n        self.play(Transform(h1, t1))\n        self.play(Transform(h1, t2))\n        self.play(Transform(h1, t3))\n        self.wait(1)\n        self.play(ApplyMethod(h1.shift, 1 * UP))\n        h12.next_to(h1, 2 * LEFT)\n        self.play(Write(h12))\n        h11 = TextMobject('6 Characters')\n        h13 = TextMobject('6 Characters:')\n        t1 = TexMobject('256^6')\n        t2 = TexMobject('28147498' + '0' * 7)\n        t3 = TextMobject('900000 Years')\n        h13.scale(1.25)\n        h11.move_to(1 * DOWN)\n        h11.scale(1.5)\n        t1.scale(1.5)\n        t2.scale(1.5)\n        t3.scale(1.5)\n        t1.move_to(1 * DOWN)\n        t2.move_to(1 * DOWN)\n        t3.move_to(1 * DOWN)\n        self.play(Write(h11))\n        self.play(Transform(h11, t1))\n        self.play(Transform(h11, t2))\n        self.play(Transform(h11, t3))\n        h13.next_to(h11, 2 * LEFT)\n        self.play(Write(h13))"}]}
{"messages": [{"role": "user", "content": "Show icons for HTML, JavaScript, Python, and a database, connected by arrows to represent a program structure."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ProgramStructure(Scene):\n\n    def construct(self):\n        html = SVGMobject('files/html.svg', color=ORANGE)\n        py = SVGMobject('files/python.svg', color=YELLOW)\n        js = SVGMobject('files/js.svg', color=YELLOW)\n        db = SVGMobject('files/database.svg')\n        html.move_to(3.5 * LEFT + 1 * UP)\n        js.move_to(3.5 * LEFT + 1 * DOWN)\n        html.scale(0.75)\n        js.scale(0.75)\n        py.scale(0.75)\n        db.scale(0.75)\n        db.move_to(3.5 * RIGHT)\n        a1 = Arrow(ORIGIN, 2 * RIGHT, color=BLUE)\n        a1.next_to(html, 1 * DOWN + 1 * RIGHT)\n        a2 = Arrow(ORIGIN, 2 * RIGHT, color=BLUE)\n        a2.next_to(py, 1 * RIGHT)\n        self.play(Write(html), Write(js))\n        self.play(Write(a1))\n        self.play(Write(py))\n        self.play(Write(a2))\n        self.play(Write(db))"}]}
{"messages": [{"role": "user", "content": "Create a visual representation of a database table with room numbers and codes, accompanied by a database icon and text."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Database(Scene):\n\n    def construct(self):\n        l1 = Line(2 * UP, 2 * DOWN)\n        l2 = Line(2 * UP, 2 * UP + 4 * RIGHT)\n        l3 = Line(1 * UP, 1 * UP + 4 * RIGHT)\n        l4 = Line(ORIGIN, ORIGIN + 4 * RIGHT)\n        l5 = Line(1 * DOWN, 1 * DOWN + 4 * RIGHT)\n        l6 = Line(2 * DOWN, 2 * DOWN + 4 * RIGHT)\n        l7 = Line(2 * UP + 2 * RIGHT, 2 * DOWN + 2 * RIGHT)\n        l8 = Line(2 * UP + 4 * RIGHT, 2 * DOWN + 4 * RIGHT)\n        t1 = TextMobject('Room Number')\n        t2 = TextMobject('Code')\n        t3 = TextMobject('703')\n        t4 = TextMobject('192')\n        t5 = TextMobject('214')\n        t6 = TextMobject('1XFF')\n        t7 = TextMobject('2OD1')\n        t8 = TextMobject('1OAB')\n        t1.move_to(1.5 * UP + 1 * RIGHT)\n        t1.scale(0.5)\n        t2.move_to(1.5 * UP + 3 * RIGHT)\n        t2.scale(0.5)\n        t3.move_to(0.5 * UP + 1 * RIGHT)\n        t4.move_to(0.5 * DOWN + 1 * RIGHT)\n        t5.move_to(1.5 * DOWN + 1 * RIGHT)\n        t6.move_to(0.5 * UP + 3 * RIGHT)\n        t7.move_to(0.5 * DOWN + 3 * RIGHT)\n        t8.move_to(1.5 * DOWN + 3 * RIGHT)\n        head = TextMobject('Table: Codes', color=RED)\n        head.move_to(3 * UP + 2 * RIGHT)\n        head.scale(1.25)\n        db = SVGMobject('files/database.svg')\n        db_text = TextMobject('Database')\n        db_text.scale(1.5)\n        db.scale(0.75)\n        db.move_to(3.5 * LEFT + 1 * DOWN)\n        db_text.move_to(3.5 * LEFT + 1 * UP)\n        self.play(Write(l1))\n        self.play(Write(l2), Write(l3), Write(l4), Write(l5), Write(l6))\n        self.play(Write(l7), Write(l8))\n        self.play(Write(t1), Write(t2))\n        self.play(Write(t3), Write(t4), Write(t5))\n        self.play(Write(t6), Write(t7), Write(t8))\n        self.play(Write(head))\n        self.play(Write(db), Write(db_text))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate the creation of a SQL table and then demonstrate inserting data into it."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass CreateTable(Scene):\n\n    def construct(self):\n        color_map = {'select'.upper(): ORANGE, 'from'.upper(): ORANGE, 'where'.upper(): ORANGE, 'insert into'.upper(): ORANGE, 'create table'.upper(): ORANGE}\n        s1 = TextMobject('CREATE TABLE `Codes` (', tex_to_color_map={**color_map, **{'`Codes`': RED}})\n        s1.move_to(3 * LEFT + 1.5 * UP)\n        s2 = TextMobject('`Room Number` INTEGER,', tex_to_color_map={**color_map, **{'`Room Number`': RED}})\n        s3 = TextMobject('`Code` TEXT(4)', tex_to_color_map={**color_map, **{'`Code`': RED, 'TEXT': BLUE}})\n        s4 = TextMobject(');', tex_to_color_map={**color_map})\n        s2.next_to(s1.get_corner(DOWN + LEFT), 1 * DOWN + RIGHT)\n        s3.next_to(s2.get_corner(DOWN + LEFT), 1 * DOWN + RIGHT)\n        s4.next_to(s3.get_corner(DOWN + LEFT), 1 * DOWN + RIGHT)\n        l1 = Line(2 * UP + 1 * RIGHT, 2 * DOWN + 1 * RIGHT)\n        l2 = Line(2 * UP + 1 * RIGHT, 2 * UP + 5 * RIGHT)\n        l3 = Line(1 * UP + 1 * RIGHT, 1 * UP + 5 * RIGHT)\n        l4 = Line(1 * RIGHT, 5 * RIGHT)\n        l5 = Line(1 * DOWN + 1 * RIGHT, 1 * DOWN + 5 * RIGHT)\n        l6 = Line(2 * DOWN + 1 * RIGHT, 2 * DOWN + 5 * RIGHT)\n        l7 = Line(2 * UP + 3 * RIGHT, 2 * DOWN + 3 * RIGHT)\n        l8 = Line(2 * UP + 5 * RIGHT, 2 * DOWN + 5 * RIGHT)\n        t1 = TextMobject('Room Number')\n        t2 = TextMobject('Code')\n        t3 = TextMobject('703')\n        t4 = TextMobject('192')\n        t5 = TextMobject('214')\n        t6 = TextMobject('1XFF')\n        t7 = TextMobject('2OD1')\n        t8 = TextMobject('1OAB')\n        t1.move_to(1.5 * UP + 2 * RIGHT)\n        t1.scale(0.5)\n        t2.move_to(1.5 * UP + 4 * RIGHT)\n        t2.scale(0.5)\n        t3.move_to(0.5 * UP + 2 * RIGHT)\n        t4.move_to(0.5 * DOWN + 2 * RIGHT)\n        t5.move_to(1.5 * DOWN + 2 * RIGHT)\n        t6.move_to(0.5 * UP + 4 * RIGHT)\n        t7.move_to(0.5 * DOWN + 4 * RIGHT)\n        t8.move_to(1.5 * DOWN + 4 * RIGHT)\n        head = TextMobject('Table: Codes', color=RED)\n        head.move_to(3 * UP + 3 * RIGHT)\n        head.scale(1.25)\n        self.play(Write(s1), Write(s2), Write(s3), Write(s4))\n        self.play(Write(l1))\n        self.play(Write(l2), Write(l3), Write(l4), Write(l5), Write(l6))\n        self.play(Write(l7), Write(l8))\n        self.play(Write(head))\n        self.play(Write(t1), Write(t2))\n        self.wait(2)\n        i1 = TextMobject('INSERT INTO `Codes`', tex_to_color_map={**color_map, **{'`Codes`': RED}})\n        i1.move_to(3 * LEFT + 1.5 * UP)\n        i2 = TextMobject('values(', tex_to_color_map={**color_map, **{'values': BLUE}})\n        i3 = TextMobject('703, `1XFF`', tex_to_color_map={**color_map, **{'703': RED, '`1XFF`': RED}})\n        i4 = TextMobject(');', tex_to_color_map={**color_map})\n        i2.next_to(i1.get_corner(DOWN + LEFT), 1 * DOWN + RIGHT)\n        i3.next_to(i2.get_corner(DOWN + LEFT), 1 * DOWN + RIGHT)\n        i4.next_to(i3.get_corner(DOWN + LEFT), 1 * DOWN + RIGHT)\n        i5 = TextMobject('192, `2OD1`', tex_to_color_map={**color_map, **{'192': RED, '`2OD1`': RED}})\n        i5.next_to(i2.get_corner(DOWN + LEFT), 1 * DOWN + RIGHT)\n        i6 = TextMobject('214, `1OAB`', tex_to_color_map={**color_map, **{'214': RED, '`1OAB`': RED}})\n        i6.next_to(i2.get_corner(DOWN + LEFT), 1 * DOWN + RIGHT)\n        self.play(Transform(s1, i1), Transform(s2, i2), Transform(s3, i3), Transform(s4, i4))\n        self.play(Write(t3), Write(t6))\n        self.play(Transform(s3, i5), Write(t4), Write(t7))\n        self.play(Transform(s3, i6), Write(t5), Write(t8))"}]}
{"messages": [{"role": "user", "content": "Animate the construction of a database table with selected data from a SQL query."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Select(Scene):\n\n    def construct(self):\n        color_map = {'select'.upper(): ORANGE, 'from'.upper(): ORANGE, 'where'.upper(): ORANGE, 'insert into'.upper(): ORANGE, 'create table'.upper(): ORANGE}\n        s1 = TextMobject('SELECT * FROM Codes;', tex_to_color_map={**color_map, **{'Codes': RED}})\n        s1.move_to(3 * LEFT)\n        l1 = Line(2 * UP + 1 * RIGHT, 2 * DOWN + 1 * RIGHT)\n        l2 = Line(2 * UP + 1 * RIGHT, 2 * UP + 5 * RIGHT)\n        l3 = Line(1 * UP + 1 * RIGHT, 1 * UP + 5 * RIGHT)\n        l4 = Line(1 * RIGHT, 5 * RIGHT)\n        l5 = Line(1 * DOWN + 1 * RIGHT, 1 * DOWN + 5 * RIGHT)\n        l6 = Line(2 * DOWN + 1 * RIGHT, 2 * DOWN + 5 * RIGHT)\n        l7 = Line(2 * UP + 3 * RIGHT, 2 * DOWN + 3 * RIGHT)\n        l8 = Line(2 * UP + 5 * RIGHT, 2 * DOWN + 5 * RIGHT)\n        t1 = TextMobject('Room Number')\n        t2 = TextMobject('Code')\n        t3 = TextMobject('703')\n        t4 = TextMobject('192')\n        t5 = TextMobject('214')\n        t6 = TextMobject('1XFF')\n        t7 = TextMobject('2OD1')\n        t8 = TextMobject('1OAB')\n        t1.move_to(1.5 * UP + 2 * RIGHT)\n        t1.scale(0.5)\n        t2.move_to(1.5 * UP + 4 * RIGHT)\n        t2.scale(0.5)\n        t3.move_to(0.5 * UP + 2 * RIGHT)\n        t4.move_to(0.5 * DOWN + 2 * RIGHT)\n        t5.move_to(1.5 * DOWN + 2 * RIGHT)\n        t6.move_to(0.5 * UP + 4 * RIGHT)\n        t7.move_to(0.5 * DOWN + 4 * RIGHT)\n        t8.move_to(1.5 * DOWN + 4 * RIGHT)\n        head = TextMobject('Table: Codes', color=RED)\n        head.move_to(3 * UP + 3 * RIGHT)\n        head.scale(1.25)\n        s = TextMobject('SELECT * FROM Codes', tex_to_color_map={**color_map, **{'Codes': RED}})\n        s.move_to(3 * LEFT + 1 * UP)\n        s2 = TextMobject('WHERE Code=`1XFF`;', tex_to_color_map={**color_map, **{'`1XFF`': RED}})\n        s2.next_to(s1.get_corner(DOWN + LEFT), 1 * DOWN + RIGHT)\n        ll1 = Line(2 * UP + 1 * RIGHT, 1 * RIGHT)\n        ll2 = Line(2 * UP + 1 * RIGHT, 2 * UP + 5 * RIGHT)\n        ll3 = Line(1 * RIGHT, 5 * RIGHT)\n        ll4 = Line(1 * UP + 1 * RIGHT, 1 * UP + 5 * RIGHT)\n        ll7 = Line(2 * UP + 3 * RIGHT, 3 * RIGHT)\n        ll8 = Line(2 * UP + 5 * RIGHT, 5 * RIGHT)\n        self.play(Write(s1))\n        self.play(Write(l1))\n        self.play(Write(l2), Write(l3), Write(l4), Write(l5), Write(l6))\n        self.play(Write(l7), Write(l8))\n        self.play(Write(head), Write(t1), Write(t2), Write(t3), Write(t6), Write(t4), Write(t7), Write(t5), Write(t8))\n        self.play(Transform(s1, s), Write(s2))\n        self.play(Transform(l1, ll1), Transform(l2, ll2), Transform(l3, ll3), Transform(l4, ll4), Transform(l5, ll2), Transform(l6, ll3), Transform(l7, ll7), Transform(l8, ll8), Transform(t7, t6), Transform(t8, t6), Transform(t5, t3), Transform(t4, t3))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Demonstrate an SQL injection vulnerability by transforming SQL queries and displaying explanatory text and data tables."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Injection(Scene):\n\n    def construct(self):\n        color_map = {'select'.upper(): ORANGE, 'from'.upper(): ORANGE, 'where'.upper(): ORANGE, 'insert into'.upper(): ORANGE, 'create table'.upper(): ORANGE}\n        s1 = TextMobject('SELECT * FROM Codes WHERE Code=`1XFF`;', tex_to_color_map={**color_map, **{'Codes': RED, '`1XFF`': RED}})\n        s2 = TextMobject('SELECT * FROM Codes WHERE Code=`2DDA`;', tex_to_color_map={**color_map, **{'Codes': RED, '`2DDA`': RED}})\n        s3 = TextMobject('SELECT * FROM Codes WHERE Code=`WHAT`;', tex_to_color_map={**color_map, **{'Codes': RED, '`WHAT`': RED}})\n        s4 = TextMobject('SELECT * FROM Codes WHERE Code=```;', tex_to_color_map={**color_map, **{'Codes': RED, '```': RED}})\n        text1 = TextMobject('Test for vulnerability', color=BLUE)\n        text1.scale(2)\n        text1.move_to(2.5 * UP)\n        text2 = TextMobject('This will always return something', color=BLUE)\n        text2.scale(1.25)\n        text2.move_to(2.5 * UP)\n        self.play(Write(s1))\n        self.play(Transform(s1, s2))\n        self.play(Transform(s1, s3))\n        self.play(Write(text1))\n        self.play(Transform(s1, s4))\n        self.wait(2)\n        st1 = TextMobject('SELECT * FROM Codes', tex_to_color_map={**color_map, **{'`Codes`': RED}})\n        st1.move_to(3 * LEFT + 0.5 * UP)\n        st2 = TextMobject('WHERE 1=1', tex_to_color_map={**color_map})\n        st2.move_to(3 * LEFT + 0.5 * DOWN)\n        l1 = Line(2 * UP + 1 * RIGHT, 2 * DOWN + 1 * RIGHT)\n        l2 = Line(2 * UP + 1 * RIGHT, 2 * UP + 5 * RIGHT)\n        l3 = Line(1 * UP + 1 * RIGHT, 1 * UP + 5 * RIGHT)\n        l4 = Line(1 * RIGHT, 5 * RIGHT)\n        l5 = Line(1 * DOWN + 1 * RIGHT, 1 * DOWN + 5 * RIGHT)\n        l6 = Line(2 * DOWN + 1 * RIGHT, 2 * DOWN + 5 * RIGHT)\n        l7 = Line(2 * UP + 3 * RIGHT, 2 * DOWN + 3 * RIGHT)\n        l8 = Line(2 * UP + 5 * RIGHT, 2 * DOWN + 5 * RIGHT)\n        t1 = TextMobject('Room Number')\n        t2 = TextMobject('Code')\n        t3 = TextMobject('703')\n        t4 = TextMobject('192')\n        t5 = TextMobject('214')\n        t6 = TextMobject('1XFF')\n        t7 = TextMobject('2OD1')\n        t8 = TextMobject('1OAB')\n        t1.move_to(1.5 * UP + 2 * RIGHT)\n        t1.scale(0.5)\n        t2.move_to(1.5 * UP + 4 * RIGHT)\n        t2.scale(0.5)\n        t3.move_to(0.5 * UP + 2 * RIGHT)\n        t4.move_to(0.5 * DOWN + 2 * RIGHT)\n        t5.move_to(1.5 * DOWN + 2 * RIGHT)\n        t6.move_to(0.5 * UP + 4 * RIGHT)\n        t7.move_to(0.5 * DOWN + 4 * RIGHT)\n        t8.move_to(1.5 * DOWN + 4 * RIGHT)\n        self.play(Transform(s1, st1), Write(st2))\n        self.play(Write(l1), Write(l2), Write(l3), Write(l4), Write(l5), Write(l6), Write(l7), Write(l8), Transform(text1, text2))\n        self.play(Write(t1), Write(t2), Write(t3), Write(t4), Write(t5), Write(t6), Write(t7), Write(t8))\n        self.wait(2)\n        text3 = TextMobject('SQL Injection', color=BLUE)\n        text3.scale(1.25)\n        text3.move_to(2.5 * UP)\n        r2 = TextMobject('WHERE', tex_to_color_map={**color_map})\n        r2.move_to(3 * LEFT + 0.5 * DOWN)\n        r4 = TextMobject('`Room Number`=`a` OR 1=1 OR `b`', tex_to_color_map={'OR': BLUE})\n        r4.move_to(3 * LEFT + 1.5 * DOWN)\n        r4.scale(0.75)\n        r3 = TextMobject('WHERE Code=101 OR 1=1', tex_to_color_map={**color_map})\n        r3.move_to(3 * LEFT + 0.5 * DOWN)\n        self.play(Transform(st2, r2), Transform(text1, text3))\n        self.play(Write(r4))\n        self.wait(2)\n        self.play(Transform(st2, r3), Transform(r4, r3))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize a machine learning model's input, features, and output classifier with connecting lines and a scatter plot."}, {"role": "assistant", "content": "from manimlib import *\nfrom manim_fonts import *\n\nclass Ghostbuster(Scene):\n\n    def construct(self):\n        brect = Rectangle(height=FRAME_HEIGHT, width=FRAME_WIDTH, color=WHITE, fill_opacity=1)\n        self.add(brect)\n        inp_rect = Rectangle(height=3.75, width=3.0, fill_color='#f3f3f3', fill_opacity=1, stroke_color=BLACK)\n        inp_rect.move_to(5.5 * LEFT)\n        model_rects = VGroup()\n        for i in range(4):\n            model_rects.add(Rectangle(height=1.0, width=2.0, fill_opacity=1, fill_color='#d9d2e9', stroke_color=BLACK).move_to(1.5 * i * DOWN))\n        model_rects.move_to(2.5 * LEFT)\n        features = ['max(ada / davinci + ada)', 'var(davinci / ada - davinci)', 'var(unigram * davinci)', 'avg(unigram - ada > davinci)', None, 'avg(unigram + trigram < davinci)']\n        feature_rects = VGroup()\n        for i in range(len(features)):\n            if i == len(features) - 2:\n                dots = Tex('\\\\vdots', color=BLACK)\n                dots.scale(1.5)\n                feature_rects.add(dots)\n            else:\n                r = Rectangle(width=3.75, height=0.5, fill_opacity=1, fill_color='#d0e2f3', stroke_color=BLACK)\n                feature_rects.add(r)\n                text = Text(features[i], color=BLACK)\n                text.scale(0.45)\n                text.move_to(r)\n                r.add(text)\n            feature_rects[-1].shift(0.75 * i * DOWN)\n        feature_rects.move_to(0.5 * LEFT, aligned_edge=LEFT)\n        lr_rect = Rectangle(width=3.0, height=4.0, fill_opacity=1, fill_color='#fce5cd', stroke_color=BLACK)\n        lr_rect.move_to(5.5 * RIGHT)\n        VGroup(inp_rect, model_rects, feature_rects, lr_rect).scale(0.95).center()\n        inp_text_raw = 'It was a typical\\nFriday night, and I\\nhad decided to\\nspend it at home,\\nbrowsing the\\ninternet and\\ncatching up on some\\nof my favorite\\nshows. My roommate\\nhad gone...\\n'\n        with RegisterFont('Ubuntu') as fonts:\n            inp_text = Text(inp_text_raw, font=fonts[0], color=BLACK)\n            inp_text.scale(0.55)\n        inp_text.move_to(inp_rect)\n        with RegisterFont('Ubuntu') as fonts:\n            for i in range(len(model_rects)):\n                model_rects[i].add(Text(['Unigram', 'Trigram', 'GPT-3 Ada', 'GPT-3 Davinci'][i], font=fonts[0], color=BLACK).scale(0.55).move_to(model_rects[i]))\n            lr_text = Text('Logistic\\nRegression\\nClassifier', font=fonts[0], color=BLACK)\n            lr_text.scale(0.55)\n            lr_text.move_to(lr_rect, UP)\n            lr_text.shift(0.25 * DOWN)\n            old_center = lr_text[0:8].get_center()\n            lr_text[0:8].move_to([lr_rect.get_center()[0], old_center[1], 0])\n            old_center = lr_text[9:22].get_center()\n            lr_text[9:22].move_to([lr_rect.get_center()[0], old_center[1], 0])\n            old_center = lr_text[22:].get_center()\n            lr_text[22:].move_to([lr_rect.get_center()[0], old_center[1], 0])\n        inp_model_conn = VGroup()\n        for i in range(len(model_rects)):\n            inp_model_conn.add(Line(inp_rect.get_right(), model_rects[i].get_left(), stroke_color=GREY_D, stroke_opacity=0.75))\n        model_feature_conn, feature_lr_conn = (VGroup(), VGroup())\n        for i in range(len(feature_rects)):\n            if not features[i]:\n                model_feature_conn.add(VGroup())\n                continue\n            curr_lines = VGroup()\n            if 'unigram' in features[i]:\n                curr_lines.add(Line(model_rects[0].get_right(), feature_rects[i].get_left(), color=GREY_D, stroke_opacity=0.75))\n            if 'trigram' in features[i]:\n                curr_lines.add(Line(model_rects[1].get_right(), feature_rects[i].get_left(), color=GREY_D, stroke_opacity=0.75))\n            if 'ada' in features[i]:\n                curr_lines.add(Line(model_rects[2].get_right(), feature_rects[i].get_left(), color=GREY_D, stroke_opacity=0.75))\n            if 'davinci' in features[i]:\n                curr_lines.add(Line(model_rects[3].get_right(), feature_rects[i].get_left(), color=GREY_D, stroke_opacity=0.75))\n            model_feature_conn.add(curr_lines)\n            feature_lr_conn.add(Line(feature_rects[i].get_right(), lr_rect.get_left(), color=GREY_D, stroke_opacity=0.75))\n        axes = Axes(x_range=(0, 5), y_range=(0, 5), height=2.25, width=2.25, axis_config={'include_tip': False, 'color': BLACK, 'tick_size': 0.05})\n        axes.move_to(lr_rect)\n        axes.shift(0.5 * DOWN)\n        dots = VGroup()\n        np.random.seed(0)\n        for _ in range(100):\n            x, y = (np.random.uniform(0, 5), np.random.uniform(0, 5))\n            dots.add(Dot(axes.c2p(x, y), radius=0.025, color=MAROON_E if x > y else GREEN_E))\n        line = Line(axes.c2p(0, 0), axes.c2p(5, 5), color=GREY, stroke_width=2.5)\n        self.play(Write(inp_rect), Write(inp_text))\n        self.wait()\n        for i in range(len(model_rects)):\n            self.play(ShowCreation(inp_model_conn[i]), GrowFromCenter(model_rects[i]))\n        self.wait()\n        for i in range(len(features)):\n            if not features[i]:\n                self.play(GrowFromCenter(feature_rects[i]))\n            else:\n                self.play(ShowCreation(model_feature_conn[i]), GrowFromCenter(feature_rects[i]))\n        self.wait()\n        self.play(ShowCreation(feature_lr_conn))\n        self.play(Write(lr_rect), Write(lr_text))\n        self.play(Write(axes), Write(dots), Write(line))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Visualize a neural network architecture, from input to output, with intermediate layer representations and data flow connections."}, {"role": "assistant", "content": "from manimlib import *\nfrom manim_fonts import *\n\nclass GhostbusterFigure(Scene):\n\n    def construct(self):\n        brect = Rectangle(height=FRAME_HEIGHT, width=FRAME_WIDTH, color=WHITE, fill_opacity=1)\n        self.add(brect)\n        inp_rect = Rectangle(height=3.75, width=3.0, fill_color='#f3f3f3', fill_opacity=1, stroke_color=BLACK)\n        inp_rect.move_to(5.5 * LEFT)\n        model_rects = VGroup()\n        for i in range(3):\n            model_rects.add(Rectangle(height=1.0, width=2.0, fill_opacity=1, fill_color='#d9d2e9', stroke_color=BLACK).move_to(2.25 * LEFT + (1.5 - i * 1.5) * UP))\n        vector_rect = Rectangle(width=1.5, height=4.5, fill_opacity=1, fill_color='#a0c5e8', stroke_color=BLACK)\n        vector_rect.move_to(0.25 * RIGHT)\n        scalar_rect = Rectangle(width=1.5, height=4.5, fill_opacity=1, fill_color='#70a8dc', stroke_color=BLACK)\n        scalar_rect.move_to(2.5 * RIGHT)\n        lr_rect = Rectangle(width=3.0, height=4.0, fill_opacity=1, fill_color='#fce5cd', stroke_color=BLACK)\n        lr_rect.move_to(5.5 * RIGHT)\n        VGroup(inp_rect, model_rects, vector_rect, scalar_rect, lr_rect).scale(0.95).center()\n        inp_text_raw = 'It was a typical\\nFriday night, and I\\nhad decided to\\nspend it at home,\\nbrowsing the\\ninternet and\\ncatching up on some\\nof my favorite\\nshows. My roommate\\nhad gone...\\n'\n        with RegisterFont('Ubuntu') as fonts:\n            inp_text = Text(inp_text_raw, font=fonts[0], color=BLACK)\n            inp_text.scale(0.55)\n        inp_text.move_to(inp_rect)\n        model_text = VGroup()\n        with RegisterFont('Ubuntu') as fonts:\n            for i in range(3):\n                model_text.add(Text(['Unigram', 'Trigram', 'GPT-3'][i], font=fonts[0], color=BLACK).scale(0.55).move_to(model_rects[i]))\n        with RegisterFont('Ubuntu') as fonts:\n            vector_text = Text('Vector\\nFunctions', font=fonts[0], color=BLACK)\n            vector_text.scale(0.55)\n            vector_text.move_to(vector_rect, UP)\n            vector_text.shift(0.25 * DOWN)\n            old_center = vector_text[0:6].get_center()\n            vector_text[0:6].move_to([vector_rect.get_center()[0], old_center[1], 0])\n            scalar_text = Text('Scalar\\nFunctions', font=fonts[0], color=BLACK)\n            scalar_text.scale(0.55)\n            scalar_text.move_to(scalar_rect, UP)\n            scalar_text.shift(0.25 * DOWN)\n            old_center = scalar_text[0:6].get_center()\n            scalar_text[0:6].move_to([scalar_rect.get_center()[0], old_center[1], 0])\n            lr_text = Text('Logisitic\\nRegression\\nClassifier', font=fonts[0], color=BLACK)\n            lr_text.scale(0.55)\n            lr_text.move_to(lr_rect, UP)\n            lr_text.shift(0.25 * DOWN)\n            old_center = lr_text[0:9].get_center()\n            lr_text[0:9].move_to([lr_rect.get_center()[0], old_center[1], 0])\n            old_center = lr_text[9:22].get_center()\n            lr_text[9:22].move_to([lr_rect.get_center()[0], old_center[1], 0])\n            old_center = lr_text[23:].get_center()\n            lr_text[23:].move_to([lr_rect.get_center()[0], old_center[1], 0])\n        inp_model_conn, model_vector_conn = (VGroup(), VGroup())\n        for i in range(3):\n            inp_model_conn.add(CurvedConnector(inp_rect, model_rects[i], color=BLACK))\n            model_vector_conn.add(CurvedConnector(model_rects[i], vector_rect, color=BLACK))\n        vector_scalar_conn = CurvedConnector(vector_rect, scalar_rect, color=BLACK)\n        scalar_lr_conn = VGroup()\n        for i in range(3):\n            scalar_lr_conn.add(CurvedConnector(scalar_rect.copy().shift(1.5 * (i - 1) * UP), lr_rect, color=BLACK))\n        vector_circles = VGroup()\n        vector_tex = ['+', '\\\\cross', '>']\n        for i in range(3):\n            vector_circles.add(Circle(radius=0.45, stroke_color=BLACK, fill_color='#d0e2f3', fill_opacity=1).shift(1.1 * i * UP))\n            vector_circles.add(Tex(vector_tex[i], color=BLACK).scale(0.75).move_to(vector_circles[-1]))\n        vector_circles.move_to(vector_rect)\n        vector_circles.shift(0.375 * DOWN)\n        scalar_circles = VGroup()\n        scalar_tex = ['||x||_2', '\\\\max', '\\\\mathrm{var}']\n        for i in range(3):\n            scalar_circles.add(Circle(radius=0.45, stroke_color=BLACK, fill_color='#d0e2f3', fill_opacity=1).shift(1.1 * i * UP))\n            scalar_circles.add(Tex(scalar_tex[i], color=BLACK).scale(0.75).move_to(scalar_circles[-1]))\n        scalar_circles.move_to(scalar_rect)\n        scalar_circles.shift(0.375 * DOWN)\n        axes = Axes(x_range=(0, 5), y_range=(0, 5), height=2.25, width=2.25, axis_config={'include_tip': False, 'color': BLACK, 'tick_size': 0.05})\n        axes.move_to(lr_rect)\n        axes.shift(0.5 * DOWN)\n        dots = VGroup()\n        np.random.seed(0)\n        for _ in range(100):\n            x, y = (np.random.uniform(0, 5), np.random.uniform(0, 5))\n            dots.add(Dot(axes.c2p(x, y), radius=0.025, color=MAROON_E if x > y else GREEN_E))\n        line = Line(axes.c2p(0, 0), axes.c2p(5, 5), color=GREY, stroke_width=2.5)\n        self.play(Write(inp_rect), Write(inp_text), run_time=1)\n        self.play(Write(inp_model_conn[0]), Write(model_rects[0]), Write(model_text[0]), run_time=1)\n        word_len = list(map(len, inp_text_raw.split()))\n        for i in range(5):\n            self.play(TransformFromCopy(inp_text[sum(word_len[:i]) + i:sum(word_len[:i + 1]) + i], inp_text[sum(word_len[:i]) + i:sum(word_len[:i + 1]) + i].copy().move_to(model_text[0]).set_opacity(0)), run_time=0.5)\n        self.play(Write(inp_model_conn[1]), Write(model_rects[1]), Write(model_text[1]), run_time=1)\n        for i in range(5):\n            self.play(TransformFromCopy(inp_text[sum(word_len[:i]) + i:sum(word_len[:i + 3]) + 3], inp_text[sum(word_len[:i]) + i:sum(word_len[:i + 3]) + 3].copy().move_to(model_text[1]).set_opacity(0)), run_time=0.5)\n        self.play(Write(inp_model_conn[2]), Write(model_rects[2]), Write(model_text[2]), run_time=1)\n        self.play(TransformFromCopy(inp_text, inp_text.copy().move_to(model_text[2]).set_opacity(0)), run_time=0.5)\n        self.play(Write(model_vector_conn), Write(vector_rect), Write(vector_text), Write(vector_circles), run_time=1)\n        self.play(Write(vector_scalar_conn), Write(scalar_rect), Write(scalar_text), Write(scalar_circles), run_time=1)\n        self.play(Write(scalar_lr_conn), Write(lr_rect), Write(lr_text), run_time=1)\n        self.play(Write(axes), Write(dots), Write(line), run_time=1)\n        with RegisterFont('Ubuntu') as fonts:\n            feature_one_raw = 'var(Unigram + GPT-3)'\n            feature_one = Text(feature_one_raw, font=fonts[0], color=BLACK)\n            feature_one.scale(1.25)\n            feature_one.shift(3 * UP)\n        feature_one_grp = VGroup(model_text[0], model_text[2], vector_circles[1], scalar_circles[-1])\n        self.play(*[Indicate(i, color=YELLOW_D) for i in feature_one_grp])\n        self.wait()\n        self.play(TransformFromCopy(feature_one_grp[0], feature_one[feature_one_raw.find('Unigram'):feature_one_raw.find('Unigram') + 7]))\n        self.play(TransformFromCopy(feature_one_grp[1], feature_one[feature_one_raw.find('GPT-3'):feature_one_raw.find('GPT-3') + 5]))\n        self.play(TransformFromCopy(feature_one_grp[2], feature_one[feature_one_raw.find('+'):feature_one_raw.find('+') + 1]))\n        self.play(TransformFromCopy(feature_one_grp[3], feature_one[feature_one_raw.find('var'):feature_one_raw.find('var') + 3]))\n        self.play(Write(feature_one[feature_one_raw.find('(')]), Write(feature_one[feature_one_raw.find(')')]))\n        self.wait()\n        self.play(Transform(feature_one, Dot().move_to(lr_rect).set_opacity(0)))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Animate the graph of a Gaussian function with its Riemann sum approximation and display the integral of the Gaussian function."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        f = ParametricFunction(function=self.func, t_min=-3, t_max=3, color=BLUE)\n        axes = Axes(x_min=-3, x_max=3, y_min=0, y_max=2, number_line_config={'color': LIGHT_GREY, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        rect = self.get_riemann_sums(self.func)\n        rect.scale(1.95)\n        rect.shift(2.4 * DOWN)\n        func = VGroup(axes, f)\n        func.scale(2)\n        func.shift(2 * DOWN)\n        eq1 = TexMobject('f(x) = e^{-x^2}')\n        eq1.scale(1.5)\n        eq1.shift(3 * UP)\n        eq2 = TexMobject('\\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} \\\\ dx = \\\\sqrt{\\\\pi}')\n        eq2.scale(1.5)\n        eq2.shift(3 * UP)\n        self.play(Write(func))\n        self.wait()\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(rect), Transform(eq1, eq2))\n        self.wait()\n\n    @staticmethod\n    def get_riemann_sums(func, dx=0.01, x=(-3, 3), color=RED):\n        rects = VGroup()\n        for i in np.arange(x[0], x[1], dx):\n            h = func(i)[1]\n            rect = Rectangle(height=h, width=dx, color=color, stroke_opacity=0.3, fill_opacity=0.3)\n            rect.shift(i * RIGHT + h / 2 * UP)\n            rects.add(rect)\n        return rects\n\n    def func(self, t):\n        return np.array([t, np.exp(-t ** 2), 0])"}]}
{"messages": [{"role": "user", "content": "Illustrate the definite integral of x squared from 1 to 2 using Riemann sums and show the step-by-step evaluation of the integral."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DefiniteIntegral(Scene):\n\n    def construct(self):\n        graph = ParametricFunction(function=lambda t: np.array([t, t ** 2, 0]), t_min=-1, t_max=2, color=RED)\n        axes = Axes(x_min=-1, x_max=3, y_min=0, y_max=4)\n        rects = self.get_riemann_sums(lambda t: np.array([t, t ** 2, 0]))\n        func = VGroup(graph, axes, rects)\n        func.shift(3.5 * LEFT + 2 * DOWN)\n        eq1 = TexMobject('\\\\int_1^2 x^2 dx')\n        eq1.shift(1.5 * RIGHT + 3 * UP)\n        eq2 = TexMobject('= \\\\frac{x^3}{3} \\\\Big|_1^2')\n        eq2.shift(1.5 * RIGHT + 1 * UP)\n        eq3 = TexMobject('= \\\\frac{2^3}{3} - \\\\frac{1^3}{3}')\n        eq3.shift(1.5 * RIGHT + 1 * DOWN)\n        eq4 = TexMobject('= \\\\frac{7}{3}')\n        eq4.shift(1.5 * RIGHT + 3 * DOWN)\n        self.play(Write(eq1), Write(func))\n        self.play(Write(eq2))\n        self.play(Write(eq3))\n        self.play(Write(eq4))\n        self.wait()\n\n    @staticmethod\n    def get_riemann_sums(func, dx=0.01, x=(1, 2), color=GREEN):\n        rects = VGroup()\n        for i in np.arange(x[0], x[1], dx):\n            h = func(i)[1]\n            rect = Rectangle(height=h - dx, width=dx, color=color, stroke_opacity=0.3, fill_opacity=0.3)\n            rect.shift(i * RIGHT + h / 2 * UP)\n            rects.add(rect)\n        return rects"}]}
{"messages": [{"role": "user", "content": "Display an integral expression, label it with a brace as \"???\", then transform the label to \"Nonelementary\"."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Nonelem(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\int e^{-x^2} dx')\n        eq.scale(2)\n        brace = Brace(eq)\n        text2 = brace.get_text('Nonelementary')\n        text1 = brace.get_text('???')\n        self.play(Write(eq))\n        self.play(Write(brace), Write(text1))\n        self.play(Transform(text1, text2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Derive the Gaussian integral formula by transforming mathematical expressions and illustrating intermediate steps with braces."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Gaussian(Scene):\n\n    def construct(self):\n        func = TexMobject('f(x,y) = e^{-(x^2+y^2)}', tex_to_color_map={})\n        func.shift(3 * UP)\n        func.scale(1.5)\n        eq1 = TexMobject('I = \\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} dx', tex_to_color_map={'I': YELLOW})\n        eq1.shift(ORIGIN)\n        eq1.scale(2)\n        eq2 = TexMobject('\\\\iint_{\\\\Bbb R ^ 2} e^{-(x^2 + y^2)} \\\\ dy dx')\n        eq2.shift(ORIGIN)\n        eq2.scale(2)\n        eq3 = TexMobject('\\\\int_{-\\\\infty}^{\\\\infty}\\\\int_{-\\\\infty}^{\\\\infty} e^{-(x^2 + y^2)}  \\\\ dy dx')\n        eq3.shift(ORIGIN)\n        eq3.scale(2)\n        eq4 = TexMobject('\\\\int_{-\\\\infty}^{\\\\infty}\\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} \\\\bullet e^{-y^2}  \\\\ dy dx')\n        eq4.shift(ORIGIN)\n        eq4.scale(2)\n        circ = Circle(color=RED, radius=1.2)\n        circ.shift(0.5 * LEFT)\n        eq5 = TexMobject('\\\\int_{-\\\\infty}^{\\\\infty}e^{-x^2}\\\\int_{-\\\\infty}^{\\\\infty} e^{-y^2}  \\\\ dy dx')\n        eq5.shift(ORIGIN)\n        eq5.scale(2)\n        eq6 = TexMobject('\\\\int_{-\\\\infty}^{\\\\infty}e^{-x^2} \\\\ dx', '\\\\int_{-\\\\infty}^{\\\\infty} e^{-y^2}  \\\\ dy')\n        eq6.shift(ORIGIN)\n        eq6.scale(2)\n        eq7 = TexMobject('\\\\iint_{\\\\Bbb R^2} e^{-(x^2 + y^2)} \\\\ dy dx = I^2', tex_to_color_map={'I': YELLOW})\n        eq7.shift(ORIGIN)\n        eq7.scale(2)\n        eq8 = TexMobject('I = \\\\sqrt{\\\\iint_{\\\\Bbb R^2} e^{-(x^2 + y^2)} \\\\ dy dx}', tex_to_color_map={'I': YELLOW})\n        eq8.shift(ORIGIN)\n        eq8.scale(2)\n        br1 = Brace(eq6[0])\n        t1 = br1.get_text('I').scale(2)\n        t1.set_color(YELLOW)\n        b1 = VGroup(br1, t1)\n        br2 = Brace(eq6[1])\n        t2 = br2.get_text('I').scale(2)\n        t2.set_color(YELLOW)\n        b2 = VGroup(br2, t2)\n        self.play(Write(func))\n        self.wait()\n        self.play(Write(eq1))\n        self.wait()\n        self.play(ApplyMethod(eq1.scale, 0.5))\n        self.play(ApplyMethod(eq1.shift, 4 * LEFT + 3 * UP), ApplyMethod(func.shift, 2 * RIGHT))\n        self.wait()\n        self.play(Write(eq2))\n        self.wait()\n        self.play(Transform(eq2, eq3))\n        self.wait()\n        self.play(Transform(eq2, eq4))\n        self.wait()\n        self.play(Write(circ))\n        self.wait()\n        self.play(Uncreate(circ))\n        self.play(Transform(eq2, eq5))\n        self.wait()\n        self.play(Transform(eq2, eq6))\n        self.wait()\n        self.play(Write(b1), Write(b2))\n        self.wait()\n        self.play(Uncreate(b1), Uncreate(b2), Transform(eq2, eq7))\n        self.wait()\n        self.play(Transform(eq2, eq8))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a 3D parametric surface representing a Gaussian function with animated ambient camera rotation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ThreeFunc(ThreeDScene):\n\n    def construct(self):\n        s = ParametricSurface(self.func, u_min=-2, u_max=2, v_min=-2, v_max=2)\n        axes = ThreeDAxes(number_line_config={'color': LIGHT_GREY, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        conf = {'fill_color': ORANGE, 'fill_opacity': 1.0, 'checkerboard_colors': [ORANGE, RED], 'stroke_color': RED, 'stroke_width': 0.5}\n        surface = VGroup(axes, s)\n        surface.scale(2)\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.play(Write(surface))\n        self.wait()\n        self.begin_ambient_camera_rotation()\n        self.wait(15)\n\n    def func(self, u, v):\n        return np.array([u, v, np.exp(-(u ** 2 + v ** 2))])"}]}
{"messages": [{"role": "user", "content": "Visualize a 3D Gaussian function and its related components, transitioning from a surface to a cylindrical representation with labels."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass GaussianVisualOld(ThreeDScene):\n\n    def construct(self):\n        s = ParametricSurface(self.func, u_min=-2, u_max=2, v_min=-2, v_max=2)\n        axes = ThreeDAxes(number_line_config={'color': LIGHT_GREY, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        conf = {'fill_color': ORANGE, 'fill_opacity': 1.0, 'checkerboard_colors': [ORANGE, RED], 'stroke_color': RED, 'stroke_width': 0.5}\n        const = self.func(0, 1)[-1]\n        cyln = ParametricSurface(self.cyln, u_min=0, u_max=2 * PI, v_min=0, v_max=const, **conf).scale(2)\n        surface = VGroup(axes, s)\n        surface.scale(2)\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        rect = VGroup(Rectangle(stroke_color=RED, fill_color=RED_A, fill_opacity=1))\n        for i in np.arange(0, 1, 0.1):\n            rec = Rectangle(stroke_color=RED, fill_color=RED_A, fill_opacity=1).shift(i * OUT)\n            rect.add(rec)\n        b1 = Brace(rect, UP)\n        t1 = b1.get_tex('2\\\\pi r')\n        b2 = Brace(rect, LEFT)\n        t2 = b2.get_tex('e^{-r^2}')\n        rec = VGroup(rect, b1, t1, b2, t2)\n        rec.rotate(np.pi / 2, axis=X_AXIS)\n        self.play(Write(surface))\n        self.wait()\n        self.begin_ambient_camera_rotation()\n        self.wait(5)\n        s.set_style(fill_opacity=0.25, stroke_opacity=0.25)\n        self.play(Write(cyln))\n        self.wait()\n        self.begin_ambient_camera_rotation()\n        self.wait(5)\n        self.move_camera(np.pi / 2, -np.pi / 2)\n        self.play(ReplacementTransform(cyln, rect), Uncreate(surface))\n        self.play(Write(rec))\n        self.wait()\n        self.move_camera(np.pi / 2, -np.pi / 2 + 0.5)\n        self.wait()\n\n    def func(self, u, v):\n        return np.array([u, v, np.exp(-(u ** 2 + v ** 2))])\n\n    def cyln(self, u, v):\n        return np.array([np.cos(u), np.sin(u), v])"}]}
{"messages": [{"role": "user", "content": "Show the derivation of the Gaussian integral using a series of equations and substitutions, culminating in the result $\\sqrt{\\pi}$."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Volume(Scene):\n\n    def construct(self):\n        head = TextMobject('Total Volume:')\n        head.scale(1.5)\n        head.shift(2 * UP)\n        eq1 = TexMobject('\\\\int_{0}^{\\\\infty}2\\\\pi r e^{-r^2} dr', tex_to_color_map={'e': RED, '{0}^{\\\\infty}': GREEN, 'r': YELLOW})\n        eq1.scale(2)\n        eq2 = TexMobject('\\\\int_{0}^{\\\\infty}\\\\pi e^{-u} du', tex_to_color_map={'e': RED, '{0}^{\\\\infty}': GREEN, 'u': YELLOW})\n        eq2.scale(2)\n        eq3 = TexMobject('\\\\pi \\\\int_{0}^{\\\\infty} e^{-u} du', tex_to_color_map={'e': RED, '{0}^{\\\\infty}': GREEN, 'u': YELLOW})\n        eq3.scale(2)\n        eq4 = TexMobject('= \\\\pi \\\\Big(-e^{-u} \\\\Big|_{0}^{\\\\infty}\\\\Big)', tex_to_color_map={'e': RED, '{0}^{\\\\infty}': GREEN, 'u': YELLOW})\n        eq4.scale(2)\n        eq5 = TexMobject('= \\\\pi')\n        eq5.scale(2)\n        eq5.shift(2.5 * DOWN)\n        eq6 = TexMobject('\\\\text{Volume} = I^2 = \\\\pi', tex_to_color_map={'I': YELLOW})\n        eq6.scale(2)\n        eq7 = TexMobject('I = \\\\sqrt{\\\\pi}', tex_to_color_map={'I': YELLOW})\n        eq7.scale(2)\n        eq8 = TexMobject('\\\\int_{-\\\\infty}^{\\\\infty} e^{-x^2} \\\\ dx = \\\\sqrt{\\\\pi}', tex_to_color_map={'I': YELLOW})\n        eq8.scale(2)\n        rect = Rectangle(height=2, width=3, color=RED)\n        rect.shift(5 * RIGHT + 2.5 * UP)\n        text1 = TexMobject('u=r^2')\n        text1.shift(5 * RIGHT + 3 * UP)\n        text2 = TexMobject('du = 2r \\\\ dr')\n        text2.shift(5 * RIGHT + 2 * UP)\n        sub = VGroup(rect, text1, text2)\n        self.play(Write(eq1), Write(head))\n        self.wait()\n        self.play(Uncreate(head), Write(sub))\n        self.wait()\n        self.play(Transform(eq1, eq2))\n        self.wait()\n        self.play(Transform(eq1, eq3))\n        self.wait()\n        self.play(ApplyMethod(eq1.shift, 2.5 * UP))\n        self.play(Write(eq4))\n        self.wait()\n        self.play(Write(eq5))\n        self.wait()\n        self.play(Uncreate(eq1), Uncreate(sub), Uncreate(eq4))\n        self.play(ApplyMethod(eq5.shift, 2.5 * UP))\n        self.wait()\n        self.play(Transform(eq5, eq6))\n        self.wait()\n        self.play(Transform(eq5, eq7))\n        self.wait()\n        self.play(Transform(eq5, eq8))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the graph of the error function along with its integral definition."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Erf(Scene):\n\n    def construct(self):\n        f = ParametricFunction(function=lambda t: np.array([t, math.erf(t), 0]), t_min=-3, t_max=3, color=GREEN)\n        axes = Axes(x_min=-3, x_max=3, y_min=-1, y_max=1, number_line_config={'color': LIGHT_GREY, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        func = VGroup(axes, f)\n        func.scale(2)\n        func.shift(1.25 * DOWN)\n        eq1 = TexMobject('\\\\text{erf}(x) = \\\\frac{1}{\\\\sqrt{\\\\pi}} \\\\int_{-x}^{x} e^{-t^2} dt')\n        eq1.scale(1.5)\n        eq1.shift(3 * UP)\n        self.play(Write(func))\n        self.wait()\n        self.play(Write(eq1))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Write the equation $f(x,y) = e^{-(x^2+y^2)}$ on the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Eq(Scene):\n\n    def construct(self):\n        eq = TexMobject('f(x,y) = e^{-(x^2+y^2)}').scale(2)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the formula for shell volume with specific parts colored."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ShellVolume(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\text{Volume} = 2 \\\\pi r \\\\cdot e^{-r^2} \\\\cdot \\\\text{dr}', tex_to_color_map={'2 \\\\pi r': YELLOW, 'e^{-r^2}': GREEN}).scale(2)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Write \"Carl Friedrich Gauss\" in large text."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Gauss(Scene):\n\n    def construct(self):\n        eq = TextMobject('Carl Friedrich Gauss').scale(1.5).shift(2.5 * DOWN)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Plot a Gaussian function and its Riemann sum approximation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Thumb(Scene):\n\n    def construct(self):\n        f = ParametricFunction(function=self.func, t_min=-3, t_max=3, color=BLUE)\n        axes = Axes(x_min=-3, x_max=3, y_min=0, y_max=2, number_line_config={'color': LIGHT_GREY, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        rect = self.get_riemann_sums(self.func)\n        func = VGroup(axes, f, rect)\n        func.scale(2)\n        self.play(Write(func))\n        self.play(Write(rect))\n\n    @staticmethod\n    def get_riemann_sums(func, dx=0.01, x=(-3, 3), color=RED):\n        rects = VGroup()\n        for i in np.arange(x[0], x[1], dx):\n            h = func(i)[1]\n            rect = Rectangle(height=h, width=dx, color=color, stroke_opacity=0.3, fill_opacity=0.3)\n            rect.shift(i * RIGHT + h / 2 * UP)\n            rects.add(rect)\n        return rects\n\n    def func(self, t):\n        return np.array([t, np.exp(-t ** 2), 0])"}]}
{"messages": [{"role": "user", "content": "Write a line integral equation, move it up, and then display a title and rectangle below it."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\int_C \\\\vec{\\\\text{F}} \\\\bullet \\\\text{d}\\\\vec{\\\\text{r}} = \\\\iint_D \\\\nabla \\\\times \\\\vec{\\\\text{F}} \\\\ \\\\text{dA}')\n        eq.scale(1)\n        title = TextMobject('Line Integral')\n        title.scale(1)\n        title.to_edge(UP)\n        rect = ScreenRectangle(height=4)\n        rect.next_to(title, DOWN)\n        title.shift(2 * DOWN)\n        rect.shift(2 * DOWN)\n        self.play(Write(eq))\n        self.wait()\n        self.play(ApplyMethod(eq.shift, 3 * UP))\n        self.wait()\n        self.play(FadeInFromDown(title), Write(rect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate a 3D animation showing a vector field evolving, a parametric curve labeled 'C', and a parametric surface labeled 'R'."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Setup(Scene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        axes_config = {'x_min': -5, 'x_max': 5, 'y_min': -5, 'y_max': 5, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        axes = Axes(**axes_config)\n        f = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        field = VGroup(axes, f)\n        axes2 = Axes(**axes_config)\n        f2 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0).set_fill(opacity=0.5) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        field2 = VGroup(axes, f2)\n        c = ParametricFunction(self.func, t_min=-2, t_max=2)\n        c.set_stroke(opacity=0.75)\n        label = TextMobject('C')\n        label.shift(3 * LEFT)\n        label.scale(2)\n        s = ParametricSurface(self.surface, u_min=-2, u_max=2, v_min=-1, v_max=1, fill_color=BLUE, checkerboard_colors=[BLUE, BLUE], stroke_color=BLUE).set_fill(opacity=0.5)\n        r = TextMobject('R', color=BLUE)\n        r.scale(1.5)\n        r.shift(2 * RIGHT + 3.5 * UP)\n        curve = VGroup(label, c)\n        surface = VGroup(r, s)\n        self.play(ShowCreation(field))\n        self.wait()\n        self.play(Write(curve))\n        self.wait()\n        self.play(Transform(field, field2))\n        self.wait()\n        self.play(Write(surface))\n        self.wait()\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n        return v\n\n    @staticmethod\n    def vect(x, y):\n        return np.array([y, x, 0])\n\n    @staticmethod\n    def func(t):\n        return np.array([1 - 2 * t ** 2 + 2, t ** 3 - 4 * t, 0])\n\n    @staticmethod\n    def surface(t, v):\n        return np.array([1 - 2 * t ** 2 + 2, v * (t ** 3 - 4 * t), 0])"}]}
{"messages": [{"role": "user", "content": "Write the integral form of Green's Theorem in green and display it."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass GreenEquation(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\int_C \\\\vec{\\\\text{F}} \\\\bullet \\\\text{d}\\\\vec{\\\\text{r}} = \\\\iint_D \\\\nabla \\\\times \\\\vec{\\\\text{F}} \\\\ \\\\text{dA}')\n        eq.scale(1.5)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize vector fields with changing curl properties and their corresponding text indicators."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass CurlDemo(Scene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0.1}\n\n    def construct(self):\n        axes_config = {'x_min': -5, 'x_max': 5, 'y_min': -5, 'y_max': 5, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        axes = Axes(**axes_config)\n        f1 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.field1, prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        c = Circle(fill_color=RED, fill_opacity=0.25, color=WHITE, radius=1)\n        field1 = VGroup(axes, f1, c)\n        field1.scale(0.6)\n        axes = Axes(**axes_config)\n        f2 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.field2, prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        c = Circle(fill_color=RED, fill_opacity=0.25, color=WHITE, radius=1)\n        field2 = VGroup(axes, f2, c)\n        field2.scale(0.6)\n        axes = Axes(**axes_config)\n        f3 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.field3, prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        c = Circle(fill_color=RED, fill_opacity=0.25, color=WHITE, radius=1)\n        field3 = VGroup(axes, f3, c)\n        field3.scale(0.6)\n        text1 = TexMobject('\\\\text{curl}\\\\textbf{F} > 0', tex_to_color_map={'>': YELLOW})\n        text1.shift(3 * UP)\n        text2 = TexMobject('\\\\text{curl}\\\\textbf{F} < 0', tex_to_color_map={'<': YELLOW})\n        text2.shift(3 * UP)\n        self.play(Write(field1))\n        self.wait()\n        self.play(Write(text1))\n        self.wait()\n        self.play(Transform(field1, field2), Transform(text1, text2))\n        self.wait()\n        self.play(Transform(field1, field3))\n        self.wait()\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n        return v\n\n    @staticmethod\n    def field1(x, y):\n        return np.array([-y, x])\n\n    @staticmethod\n    def field2(x, y):\n        return np.array([y, -x])\n\n    @staticmethod\n    def field3(x, y):\n        return np.array([max(0.1, y), 0])"}]}
{"messages": [{"role": "user", "content": "Show the gradient operator, shift it up, and then write the curl equation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass CurlEquation(Scene):\n\n    def construct(self):\n        ddel = TexMobject('\\\\nabla = \\\\begin{bmatrix} \\\\\\n                \\\\frac{\\\\partial}{\\\\partial x} \\\\\\\\ \\\\\\n                \\\\frac{\\\\partial}{\\\\partial y} \\\\\\n                \\\\end{bmatrix}', tex_to_color_map={'\\\\nabla': RED})\n        ddel.scale(1.5)\n        curl = TexMobject('\\\\text{curl}\\\\textbf{F} = \\\\nabla \\\\times \\\\vec{\\\\text{F}}', tex_to_color_map={'F': YELLOW, '\\\\nabla': RED})\n        curl.scale(1.5)\n        curl.shift(1.5 * DOWN)\n        self.play(Write(ddel))\n        self.wait()\n        self.play(ApplyMethod(ddel.shift, 1.5 * UP))\n        self.play(Write(curl))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize Green's Theorem by showing a vector field, a curve, and then transitioning to a surface with corresponding equations."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass GreenTheoremVisual(Scene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        axes_config = {'x_min': -5, 'x_max': 5, 'y_min': -5, 'y_max': 5, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        axes = Axes(**axes_config)\n        f = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        field = VGroup(axes, f)\n        axes2 = Axes(**axes_config)\n        f2 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0).set_fill(opacity=0.5) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        field2 = VGroup(axes, f2)\n        c = ParametricFunction(self.func, t_min=-2, t_max=2)\n        c.set_stroke(opacity=0.75)\n        label = TextMobject('C')\n        label.shift(3 * LEFT)\n        label.scale(2)\n        surface = ParametricSurface(self.surface, u_min=-2, u_max=2, v_min=-1, v_max=1, fill_color=BLUE, checkerboard_colors=[BLUE, BLUE], stroke_color=BLUE).set_fill(opacity=0.5)\n        curve = VGroup(label, c)\n        D = UP\n        eq = TexMobject('\\\\int_C \\\\vec{\\\\text{F}} \\\\bullet \\\\text{d}\\\\vec{\\\\text{r}}')\n        back = BackgroundRectangle(eq, color=BLACK, fill_opacity=1)\n        eq0 = VGroup(back, eq)\n        eq0.shift(3 * D)\n        eq = TexMobject('\\\\int_C \\\\vec{\\\\text{F}} \\\\bullet \\\\text{d}\\\\vec{\\\\text{r}} = \\\\int_{C_1} \\\\vec{\\\\text{F}} \\\\bullet \\\\text{d}\\\\vec{\\\\text{r}} + \\\\int_{C_2} \\\\vec{\\\\text{F}} \\\\bullet \\\\text{d}\\\\vec{\\\\text{r}}')\n        back = BackgroundRectangle(eq, color=BLACK, fill_opacity=1)\n        eq1 = VGroup(back, eq)\n        eq1.shift(3 * D)\n        eq = TexMobject('\\\\int_{C_r} \\\\vec{\\\\text{F}} \\\\bullet \\\\text{d}\\\\vec{\\\\text{r}} \\\\approx \\\\nabla \\\\times \\\\vec{\\\\text{F}} |r|')\n        back = BackgroundRectangle(eq, color=BLACK, fill_opacity=1)\n        eq2 = VGroup(back, eq)\n        eq2.shift(3 * D)\n        eq = TexMobject('\\\\int_C \\\\vec{\\\\text{F}} \\\\bullet \\\\text{d}\\\\vec{\\\\text{r}} = \\\\iint_D \\\\nabla \\\\times \\\\vec{\\\\text{F}} \\\\ \\\\text{dA}')\n        back = BackgroundRectangle(eq, color=BLACK, fill_opacity=1)\n        eqf = VGroup(back, eq)\n        eqf.shift(3 * D)\n        t1 = [1.225]\n        c1 = VGroup(*[Line(-self.func(t)[1] * UP, self.func(t)[1] * UP, color=RED, stroke_width=DEFAULT_STROKE_WIDTH * 2).shift(self.func(t)[0] * RIGHT) for t in t1], ParametricFunction(self.func, t_min=1.22, t_max=2, color=RED, stroke_width=DEFAULT_STROKE_WIDTH * 2), ParametricFunction(self.func, t_min=-2, t_max=-1.22, color=RED, stroke_width=DEFAULT_STROKE_WIDTH * 2), TexMobject('\\\\text{C}_1', color=RED).shift(2 * LEFT + 1.5 * UP).scale(1.5))\n        c2 = VGroup(*[Line(-self.func(t)[1] * UP, self.func(t)[1] * UP, color=GREEN, stroke_width=DEFAULT_STROKE_WIDTH * 2).shift(self.func(t)[0] * RIGHT) for t in t1], ParametricFunction(self.func, t_min=-1.22, t_max=1.22, color=GREEN, stroke_width=DEFAULT_STROKE_WIDTH * 2), TexMobject('\\\\text{C}_2', color=GREEN).shift(2 * RIGHT + 1.5 * UP).scale(1.5))\n        table2 = VGroup()\n        for t in np.arange(0, 2, 0.05):\n            y = self.func(t)[1]\n            x = self.func(t)[0]\n            roots = [i for i in np.roots([1, 0, -4, -x]) if 2 >= i.real >= -2 and i.imag == 0]\n            l1 = Line(-y * UP, y * UP, color=RED).shift(x * RIGHT)\n            if len(roots) >= 2:\n                l2 = Line(self.func(roots[0])[0] * RIGHT, self.func(roots[1])[0] * RIGHT, color=RED).shift(self.func(roots[0])[1] * UP)\n            table2.add(l1, l2)\n        self.play(ShowCreation(field))\n        self.wait()\n        self.play(Write(curve))\n        self.wait()\n        self.play(Transform(field, field2))\n        self.wait()\n        self.play(Write(eq0))\n        self.wait()\n        self.play(Uncreate(eq0), Write(c1))\n        self.wait()\n        self.play(Write(c2))\n        self.wait()\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Uncreate(eq1), Uncreate(c1), Uncreate(c2), Write(table2))\n        self.wait()\n        self.play(Write(eq2))\n        self.wait()\n        self.play(Uncreate(table2), Uncreate(eq2), Write(surface))\n        self.wait()\n        self.play(Write(eqf))\n        self.wait()\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n        return v\n\n    @staticmethod\n    def func(t):\n        return np.array([1 - 2 * t ** 2 + 2, t ** 3 - 4 * t, 0])\n\n    @staticmethod\n    def surface(t, v):\n        return np.array([1 - 2 * t ** 2 + 2, v * (t ** 3 - 4 * t), 0])\n\n    @staticmethod\n    def vect(x, y):\n        return np.array([y, x, 0])"}]}
{"messages": [{"role": "user", "content": "Animate the calculation of a line integral using Green's Theorem, showing the vector field, the region of integration, and each step of the calculation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Example(Scene):\n\n    def construct(self):\n        c1 = ParametricFunction(lambda t: np.array([t, 3 - t, 0]), t_min=-1, t_max=1, color=RED)\n        c2 = ParametricFunction(lambda t: np.array([t, -1, 0]), t_min=-1, t_max=1, color=RED)\n        c3 = ParametricFunction(lambda t: np.array([-1, t, 0]), t_min=-1, t_max=4, color=RED)\n        c4 = ParametricFunction(lambda t: np.array([1, t, 0]), t_min=-1, t_max=2, color=RED)\n        axes = Axes(x_min=-2, x_max=2, y_min=-2, y_max=4, number_line_config={'color': LIGHT_GREY, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        C = VGroup(c1, c2, c3, c4, axes)\n        C.shift(3 * LEFT + 1 * DOWN)\n        f = TexMobject('\\\\text{F} = \\\\langle 6y-9x, -yx + x^3 \\\\rangle', tex_to_color_map={'\\\\text{F}': YELLOW})\n        f.shift(2.5 * RIGHT + 3 * UP)\n        green = TexMobject('\\\\int_C \\\\vec{\\\\text{F}} \\\\bullet \\\\text{d}\\\\vec{\\\\text{r}} = \\\\iint_D \\\\nabla \\\\times \\\\vec{\\\\text{F}} \\\\ \\\\text{dA}', tex_to_color_map={'F': YELLOW, '\\\\nabla': RED, 'D': BLUE, 'C': GREEN})\n        green.shift(2.5 * RIGHT + 0.5 * UP)\n        step1 = TexMobject('\\\\nabla \\\\times \\\\vec{\\\\text{F}} = x-9', tex_to_color_map={'F': YELLOW, '\\\\nabla': RED})\n        step1.shift(2.5 * RIGHT + 2 * UP)\n        step2a = TexMobject('\\\\iint_D \\\\nabla \\\\times \\\\vec{\\\\text{F}} \\\\ \\\\text{dA}', tex_to_color_map={'F': YELLOW, '\\\\nabla': RED, 'D': BLUE, 'C': GREEN})\n        step2a.shift(2.5 * RIGHT + 1 * DOWN)\n        step2b = TexMobject('\\\\int_{-1}^{1} \\\\int_{-1}^{3-x} x-9 \\\\ \\\\text{dy} \\\\ \\\\text{dx}', tex_to_color_map={})\n        step2b.shift(2.5 * RIGHT + 1 * DOWN)\n        step3 = TexMobject('= \\\\frac{-218}{3}', tex_to_color_map={'=': YELLOW})\n        step3.shift(2.5 * RIGHT + 2.5 * DOWN)\n        self.play(Write(f))\n        self.wait()\n        self.play(Write(C))\n        self.wait()\n        self.play(Write(step1))\n        self.wait()\n        self.play(Write(green))\n        self.wait()\n        self.play(Write(step2a))\n        self.wait()\n        self.play(Transform(step2a, step2b))\n        self.wait()\n        self.play(Write(step3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a plot of a parametric function and animate the transformation of a derivative notation along with a line that follows the curve."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass Intro(Scene):\n\n    def construct(self):\n        f = ParametricFunction(self.func, t_min=0, t_max=1.75, color=GREEN)\n        curve = ParametricFunction(self.func, t_min=0.1, t_max=0.9, color=RED, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        axes = Axes(x_min=0, x_max=2, y_min=0, y_max=2, number_line_config={'include_tip': False})\n        line = Line(ORIGIN + 0.01 * UP, 1 * RIGHT + 0.01 * UP, stroke_width=DEFAULT_STROKE_WIDTH * 1.25, color=RED)\n        line.shift(1.3125 * UP)\n        fun = VGroup(axes, f)\n        func = VGroup(fun, line, curve)\n        func.scale(2.5)\n        func.shift(2 * LEFT + 1 * DOWN)\n        eq1 = TexMobject('\\\\frac{dy}{dx}')\n        eq1.scale(2)\n        eq1.shift(4 * RIGHT)\n        eq2 = TexMobject('\\\\frac{d^2y}{dx^2}')\n        eq2.scale(2)\n        eq2.shift(4 * RIGHT)\n        self.play(Write(fun))\n        self.wait()\n        self.play(Write(eq1), Write(line))\n        self.wait()\n        self.play(Transform(eq1, eq2), Transform(line, curve))\n        self.wait()\n\n    @staticmethod\n    def func(t):\n        return np.array([t, t ** 4 - 2 * t ** 3 + t + 1, 0])"}]}
{"messages": [{"role": "user", "content": "Show the nth derivative notation transforming into a repeated derivative operator and then indicate it's for positive integers."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass NDeriv(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\frac{d^nf}{dx^n}')\n        eq1.scale(2)\n        eq2 = TexMobject('\\\\left (\\\\frac{d}{dx} ... \\\\frac{d}{dx}\\\\right )', 'f')\n        eq2.scale(2)\n        b = Brace(eq2[0])\n        t = b.get_text('n times').scale(1.5)\n        t1 = TextMobject('Only for positive integers', tex_to_color_map={'integers': YELLOW})\n        t1.scale(1.5)\n        t1.shift(3 * UP)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Transform(eq1, eq2), Write(b), Write(t))\n        self.wait()\n        self.play(Write(t1))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a question about a fractional derivative."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass FracConfus(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\frac{d^{\\\\frac{1}{2}}f}{dx^{{\\\\frac{1}{2}}}} =  \\\\ ?')\n        eq.scale(3)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Explain the meaning of the nth derivative by showing the product rule and illustrating the derivative of a function with two different parametric curves."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass MultipleDeriv(Scene):\n\n    def construct(self):\n        title = TexMobject('\\\\text{What does } \\\\frac{d^nf}{dx^n} \\\\text{ mean?}', tex_to_color_map={'\\\\frac{d^nf}{dx^n}': YELLOW})\n        title.scale(2)\n        title2 = TexMobject('\\\\text{What does } \\\\frac{d^nf}{dx^n} \\\\text{ mean?}', tex_to_color_map={'\\\\frac{d^nf}{dx^n}': YELLOW})\n        title2.shift(3 * UP)\n        eq = TexMobject('\\\\frac{d^nf}{dx^n}=', '\\\\left (\\\\frac{d}{dx} ... \\\\frac{d}{dx}\\\\right )', 'f')\n        eq.scale(1.5)\n        b = Brace(eq[1])\n        t = b.get_text('n times').scale(1.5)\n        eq1 = VGroup(eq, b, t)\n        f1 = ParametricFunction(lambda t: np.array([t, t ** 2, 0]), t_min=0, t_max=math.sqrt(2), color=RED, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        a1 = Axes(x_min=0, x_max=2, y_min=0, y_max=2, number_line_config={'include_tip': False})\n        func1 = VGroup(a1, f1)\n        func1.scale(1.5)\n        func1.shift(4.5 * LEFT + 1 * DOWN)\n        f2 = ParametricFunction(lambda t: np.array([t, 2 * t, 0]), t_min=0, t_max=1, color=BLUE, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        a2 = Axes(x_min=0, x_max=2, y_min=0, y_max=2, number_line_config={'include_tip': False})\n        func2 = VGroup(a2, f2)\n        func2.scale(1.5)\n        func2.shift(3 * RIGHT + 1 * DOWN)\n        a = Arrow(1 * LEFT, 1 * RIGHT, color=GREEN)\n        a.scale(1.5)\n        t = TexMobject('\\\\frac{d}{dx}')\n        t.shift(1 * UP)\n        arr = VGroup(a, t)\n        self.play(Write(title))\n        self.wait()\n        self.play(Transform(title, title2))\n        self.wait()\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Uncreate(eq1))\n        self.play(Write(func1))\n        self.wait()\n        self.play(Write(arr))\n        self.play(TransformFromCopy(func1, func2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the process of repeated integration by transforming graphs and mathematical notation."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass MultipleInt(Scene):\n\n    def construct(self):\n        a = 20\n        eq1 = TexMobject('If(x) = \\\\int_0^x f(t) dt')\n        eq1.scale(1.25)\n        eq1.shift(2.5 * UP)\n        eq2 = TexMobject('(I^3f)(x)=\\\\int_0^x\\\\left[\\\\int_0^t \\\\left(\\\\int_0^s f(u)\\\\,du\\\\right)\\\\, ds \\\\right]\\\\,dt')\n        eq2.scale(1.25)\n        eq2.shift(2.5 * UP)\n        f1 = ParametricFunction(lambda t: np.array([t, a * t ** 2, 0]), t_min=-0.205, t_max=0.205, color=RED, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        a1 = Axes(x_min=-1, x_max=1, y_min=-1, y_max=1, number_line_config={'include_tip': False})\n        func1 = VGroup(a1, f1)\n        func1.scale(1.5)\n        func1.shift(3 * LEFT + 1 * DOWN)\n        f2 = ParametricFunction(lambda t: np.array([t, a * t ** 3 / 3, 0]), t_min=-0.5, t_max=0.5, color=BLUE, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        a2 = Axes(x_min=-1, x_max=1, y_min=-1, y_max=1, number_line_config={'include_tip': False})\n        func2 = VGroup(a2, f2)\n        func2.scale(1.5)\n        func2.shift(3 * RIGHT + 1 * DOWN)\n        f3 = ParametricFunction(lambda t: np.array([t, a * t ** 5 / (5 * 4 * 3), 0]), t_min=-1, t_max=1, color=YELLOW, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        a3 = Axes(x_min=-1, x_max=1, y_min=-1, y_max=1, number_line_config={'include_tip': False})\n        func3 = VGroup(a3, f3)\n        func3.scale(1.5)\n        func3.shift(3 * RIGHT + 1 * DOWN)\n        a = Arrow(0.5 * LEFT, 0.5 * RIGHT, color=GREEN).scale(1.5)\n        a.shift(1 * DOWN)\n        t = TexMobject('\\\\int')\n        t2 = TexMobject('\\\\iiint')\n        arr = VGroup(a, t)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(func1))\n        self.wait()\n        self.play(Write(arr))\n        self.play(TransformFromCopy(func1, func2))\n        self.wait()\n        self.play(Transform(eq1, eq2), Uncreate(func2), Transform(t, t2))\n        self.wait()\n        self.play(TransformFromCopy(func1, func3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Derive Cauchy's formula for repeated integration by transforming equations and highlighting key steps with rectangles and text."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass CauchyFormula(Scene):\n\n    def construct(self):\n        title = TextMobject(\"Cauchy's formula for repeated integration\", color=GREEN)\n        title.scale(1.25)\n        title.shift(2.5 * UP)\n        eq = TexMobject('I^n f(x) = \\\\frac{1}{(n-1)!} \\\\int_{a}^{x} (x-t)^{n-1} f(t) dt')\n        eq.scale(1.5)\n        eq1 = TexMobject('I^n f(x) = \\\\frac{1}{(n-1)!} \\\\int_{a}^{x} (x-t)^{n-1} f(t) dt')\n        eq1.shift(2.5 * UP + 1.5 * LEFT)\n        eq2 = TexMobject('g(x) = \\\\int_0^x (x-t) f(t) dt')\n        eq2.scale(1.5)\n        eq3 = TexMobject('g(x) = x\\\\int_0^x f(t)\\\\,dt - \\\\int_0^x tf(t)\\\\, dt')\n        eq3.scale(1.5)\n        eq4 = TexMobject(\"g'(x) = \\\\left[\\\\int_0^x f(t)\\\\,dt +xf(x)\\\\right]- xf(x)\")\n        eq4.scale(1.5)\n        eq5 = TexMobject(\"g'(x) = \\\\int_0^x f(t)\\\\,dt\")\n        eq5.scale(1.5)\n        eq6 = TexMobject(\"g'(x) = If(x)\")\n        eq6.scale(1.5)\n        eq7 = TexMobject('g(x) = g(x) - g(0)')\n        eq7.scale(1.5)\n        eq8 = TexMobject(\"g(x) = \\\\int_0^x g'(t)\\\\,dt\")\n        eq8.scale(1.5)\n        eq9 = TexMobject('g(x) = I^2f(x)')\n        eq9.scale(1.5)\n        r = Rectangle(height=2, width=5, color=YELLOW, stroke_width=2 * DEFAULT_STROKE_WIDTH)\n        t1 = TexMobject('n=2')\n        r1 = Rectangle(height=1, width=2, color=RED)\n        t = VGroup(t1, r1)\n        t.shift(5 * RIGHT + 2.5 * UP)\n        t2 = TexMobject('n=2').shift(0.5 * UP)\n        t3 = TexMobject('g(0) = 0').shift(0.5 * DOWN)\n        r2 = Rectangle(height=2, width=2, color=RED)\n        tt = VGroup(t3, r2, t2)\n        tt.shift(5 * RIGHT + 2.5 * UP)\n        self.play(Write(title), Write(eq))\n        self.wait()\n        self.play(Uncreate(title), Transform(eq, eq1))\n        self.play(Write(t))\n        self.wait()\n        self.play(Write(eq2))\n        self.wait()\n        self.play(Transform(eq2, eq3))\n        self.wait()\n        self.play(Transform(eq2, eq4))\n        self.wait()\n        self.play(Transform(eq2, eq5))\n        self.wait()\n        self.play(Transform(eq2, eq6))\n        self.wait()\n        self.play(ApplyMethod(eq2.shift, 3 * DOWN))\n        self.play(Transform(t, tt), Write(eq7))\n        self.wait()\n        self.play(Transform(eq7, eq8))\n        self.wait()\n        self.play(Transform(eq7, eq9))\n        self.wait()\n        self.play(Write(r))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present the integral form of repeated integration and provide hints using the binomial theorem."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass Challenge(Scene):\n\n    def construct(self):\n        title = TextMobject('Challenge', color=GREEN)\n        title.scale(2)\n        title.shift(3.5 * UP)\n        eq1 = TexMobject('\\\\text{Show that}')\n        eq2 = TexMobject('I^n f(x) = \\\\frac{1}{(n-1)!} \\\\int_{a}^{x} (x-t)^{n-1} f(t) dt')\n        eq3 = TexMobject('\\\\text{for } n \\\\in \\\\mathbb{N}')\n        hint1 = TexMobject('\\\\text{Hint: Use Binomial Theorem}')\n        hint2 = TexMobject('(x+y)^n = \\\\sum_{k=0}^{k=n} \\\\left ( ^n_k \\\\right ) x^{n-k}y^k')\n        hint1.shift(1 * DOWN)\n        hint2.shift(2.5 * DOWN)\n        eq1.shift(2 * UP)\n        eq2.shift(1 * UP)\n        eq3.shift(0 * DOWN)\n        self.add(title)\n        self.add(eq1)\n        self.add(eq2)\n        self.add(eq3)\n        self.add(hint1)\n        self.add(hint2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the Gamma function graph and then present the definition of the Gamma function for natural numbers with hints."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass GammaFunc(Scene):\n    CONFIG = {'g_color': RED, 'g_width': DEFAULT_STROKE_WIDTH * 1.25, 'p_color': YELLOW, 'p_width': 0.1}\n\n    def construct(self):\n        f1 = ParametricFunction(self.func, t_min=-4.99, t_max=-4.01, color=self.g_color, stroke_width=self.g_width)\n        f2 = ParametricFunction(self.func, t_min=-3.99, t_max=-3.01, color=self.g_color, stroke_width=self.g_width)\n        f3 = ParametricFunction(self.func, t_min=-2.99, t_max=-2.01, color=self.g_color, stroke_width=self.g_width)\n        f6 = ParametricFunction(self.func, t_min=-1.99, t_max=-1.01, color=self.g_color, stroke_width=self.g_width)\n        f4 = ParametricFunction(self.func, t_min=-0.99, t_max=-0.01, color=self.g_color, stroke_width=self.g_width)\n        f5 = ParametricFunction(self.func, t_min=0.01, t_max=4, color=self.g_color, stroke_width=self.g_width)\n        a1 = Axes(x_min=-5, x_max=5, y_min=-4, y_max=4, number_line_config={'include_tip': False})\n        p1 = Circle(radius=self.p_width, color=self.p_color, fill_opacity=1).shift(1 * RIGHT + 1 * UP)\n        p2 = Circle(radius=self.p_width, color=self.p_color, fill_opacity=1).shift(2 * RIGHT + 1 * UP)\n        p3 = Circle(radius=self.p_width, color=self.p_color, fill_opacity=1).shift(3 * RIGHT + 2 * UP)\n        p = VGroup(p1, p2, p3)\n        rect = Rectangle(height=8, width=10.5, stroke_width=self.g_width)\n        gfunc = VGroup(a1, f1, f2, f3, f4, f5, f6, rect)\n        g = VGroup(p, gfunc)\n        g.scale(0.8)\n        g.shift(0.7 * DOWN)\n        title = TexMobject('\\\\text{Gamma Function }\\\\Gamma (x)', color=GREEN)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        title2 = TextMobject('Challenge 2', color=GREEN)\n        title2.scale(1.5)\n        title2.shift(3 * UP)\n        eq1 = TextMobject('Show that')\n        eq2 = TexMobject('\\\\Gamma(n) = \\\\int_0^{\\\\infty} e^{-t}t^{n-1} dt')\n        eq2.scale(1.5)\n        eq3 = TexMobject('\\\\text{for } n \\\\in \\\\mathbb{N}')\n        hint1 = TexMobject('\\\\text{Hint: Integration by parts}')\n        hint1.shift(3 * DOWN)\n        eq1.shift(2 * UP)\n        eq2.shift(2 * LEFT)\n        eq3.shift(2 * DOWN)\n        self.play(Write(gfunc), Write(title))\n        self.wait()\n        self.play(Write(p))\n        self.wait()\n        self.play(ApplyMethod(gfunc.scale, 0.4), Uncreate(p))\n        self.play(ApplyMethod(gfunc.shift, 0.7 * UP + 4 * RIGHT))\n        self.play(Write(eq2))\n        self.wait()\n        self.play(Transform(title, title2))\n        self.play(Write(eq1), Write(eq3), Write(hint1))\n        self.wait()\n\n    @staticmethod\n    def func(t):\n        val = float(scipy.special.gamma(t))\n        if val < 0:\n            val = np.maximum(val, -4)\n        elif val > 0:\n            val = np.minimum(val, 4)\n        else:\n            val = 0\n        return np.array([t, val, 0], dtype=float)"}]}
{"messages": [{"role": "user", "content": "Show the definition of the Riemann-Liouville fractional integral and transform it into its generalized form."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass FractionalIntegral(Scene):\n\n    def construct(self):\n        title = TextMobject('Fractional Integrals', color=YELLOW)\n        title.scale(1.25)\n        title.shift(2.5 * UP)\n        title2 = TextMobject('Riemann-Liouville Fractional Integral', color=YELLOW)\n        title2.scale(1.25)\n        title2.shift(2.5 * UP)\n        eq1 = TexMobject('I^n f(x) = \\\\frac{1}{(n-1)!} \\\\int_{a}^{x} (x-t)^{n-1} f(t) dt')\n        eq1.scale(1.5)\n        eq2 = TexMobject('I^n f(x) = \\\\frac{1}{\\\\Gamma(n)} \\\\int_{a}^{x} (x-t)^{n-1} f(t) dt', tex_to_color_map={'\\\\Gamma(n)': BLUE})\n        eq2.scale(1.5)\n        eq3 = TexMobject('\\\\text{for } n \\\\in \\\\mathbb{C}, \\\\text{Re}(n) > 0')\n        eq3.shift(2 * DOWN)\n        eq3.scale(1.5)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(title), Transform(eq1, eq2))\n        self.wait()\n        self.play(Write(eq3))\n        self.wait()\n        self.play(Transform(title, title2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a graph with three parametric functions and a legend explaining their derivatives and integrals."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass DifferIntegralOLD(Scene):\n    CONFIG = {'g_color': RED, 'g_width': DEFAULT_STROKE_WIDTH * 1}\n\n    def construct(self):\n        f1 = ParametricFunction(lambda t: np.array([t, 0.5 * t ** 2, 0]), t_min=0, t_max=math.sqrt(6), color=PINK, stroke_width=self.g_width)\n        f2 = ParametricFunction(lambda t: np.array([t, 1, 0]), t_min=0, t_max=4, color=RED, stroke_width=self.g_width)\n        a1 = Axes(x_min=0, x_max=4, y_min=0, y_max=3, number_line_config={'include_tip': False})\n        f = ParametricFunction(lambda t: np.array([t, t, 0]), t_min=0, t_max=3, color=GREEN, stroke_width=self.g_width)\n        fs = VGroup(a1, f1, f2, f)\n        fs.scale(1.5)\n        fs.shift(1.5 * DOWN + 2.5 * LEFT)\n        line1 = Line(1 * LEFT, 0 * RIGHT, color=PINK, stroke_width=self.g_width).shift(1 * UP + 1.5 * LEFT)\n        line2 = Line(1 * LEFT, 0 * RIGHT, color=GREEN, stroke_width=self.g_width).shift(0 * UP + 1.5 * LEFT)\n        line3 = Line(1 * LEFT, 0 * RIGHT, color=RED, stroke_width=self.g_width).shift(1 * DOWN + 1.5 * LEFT)\n        t1 = TexMobject('\\\\int f(x)dx = \\\\frac{1}{2}x^2').shift(1 * UP + 0.5 * RIGHT)\n        t2 = TexMobject('f(x) = x').shift(0.5 * RIGHT)\n        t3 = TexMobject('\\\\frac{d}{dx} f(x) = 1').shift(1 * DOWN + 0.5 * RIGHT)\n        rect = Rectangle(height=4, width=6)\n        legend = VGroup(line1, line2, line3, t1, t2, t3, rect).scale(0.5)\n        legend.shift(2.5 * UP + 5 * RIGHT)\n        self.play(Write(fs))\n        self.play(Write(legend))\n        self.wait()\n        self.play(ShowCreation(f))\n        self.wait()\n        self.play(UpdateFromAlphaFunc(f, self.f_update), rate_func=there_and_back, run_time=4)\n        self.wait()\n\n    @staticmethod\n    def _func(t):\n        return t\n\n    def func(self, t):\n        return np.array([t, self._func(t), 0])\n\n    def f_update(self, ff, dt):\n        a = interpolate(-1, 1, dt)\n        f = ParametricFunction(lambda t: np.array([t, self.dint(t, a), 0]), t_min=0, t_max=math.sqrt(6), color=GREEN, stroke_width=self.g_width)\n        point = 1.5 * DOWN + 2.5 * LEFT\n        f.shift(point)\n        f.scale(1.5, about_point=point)\n        ff.become(f)\n\n    def dint(self, x, a, k=1):\n        return scipy.special.gamma(k + 1) / scipy.special.gamma(k - a + 1) * x ** (k - a)"}]}
{"messages": [{"role": "user", "content": "Display the properties of R-L integrals with corresponding explanations and a bounding box."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass RLProperty(Scene):\n\n    def construct(self):\n        title = TextMobject('Properties of R-L Integrals', color=GREEN)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        eq1 = TexMobject('1. I^{a+b} = I^aI^bf')\n        eq1.scale(1.5)\n        eq1.shift(1 * UP)\n        eq2 = TexMobject('2. \\\\frac{d}{dx} I^{a+1} = I^a')\n        eq2.scale(1.5)\n        eq2.shift(1.5 * DOWN)\n        eq3 = TextMobject('1st fundamental theorem of calculus', color=RED)\n        eq3.shift(3 * DOWN)\n        rect = Rectangle(width=5, height=2, color=YELLOW, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        rect.shift(1.5 * DOWN)\n        self.play(Write(eq1), Write(eq2), Write(title))\n        self.wait()\n        self.play(Write(rect))\n        self.play(Write(eq3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Plot the ceiling function and illustrate examples of its evaluation."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass CeilFunc(Scene):\n\n    def construct(self):\n        func = VGroup(FunctionGraph(lambda x: math.ceil(x), x_min=0, x_max=0.99), FunctionGraph(lambda x: math.ceil(x), x_min=1.01, x_max=1.99), FunctionGraph(lambda x: math.ceil(x), x_min=2.01, x_max=2.99), FunctionGraph(lambda x: math.ceil(x), x_min=3.01, x_max=3.99), Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(1 * UP + 0 * RIGHT), Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(1 * UP + 1 * RIGHT), Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(2 * UP + 1 * RIGHT), Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(2 * UP + 2 * RIGHT), Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(3 * UP + 2 * RIGHT), Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(3 * UP + 3 * RIGHT), Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(4 * UP + 3 * RIGHT), Circle(radius=0.1, color=WHITE, fill_opacity=1).shift(4 * UP + 4 * RIGHT))\n        axes = Axes(x_min=0, x_max=4, y_min=0, y_max=4, number_line_config={'include_tip': False})\n        f = VGroup(axes, func)\n        f.scale(1.25)\n        f.center()\n        f.shift(0.5 * DOWN)\n        title = TexMobject('\\\\text{ceil}(x) = \\\\lceil x \\\\rceil', color=GREEN)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        examples = TexMobject('\\\\text{ceil}(4.1) = 5 \\\\\\\\', '\\\\text{ceil}(4.6) = 5 \\\\\\\\', '\\\\text{ceil}(4.0) = 4 \\\\\\\\', tex_to_color_map={'\\\\text{ceil}': GREEN})\n        examples.scale(1.5)\n        examples.shift(3.5 * RIGHT)\n        self.play(Write(f), Write(title))\n        self.wait()\n        self.play(ApplyMethod(title.shift, 2 * LEFT), ApplyMethod(f.shift, 2 * LEFT))\n        self.play(Write(examples))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a mathematical expression for a derivative, overlay it with a red cross, and then display text explaining that the Gamma function is undefined for negative integers."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass FracNo(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\frac{d^n}{dx^n} = I^{-n}')\n        eq.scale(1.5)\n        c = VGroup(Line(UP + LEFT, DOWN + RIGHT, color=RED), Line(UP + RIGHT, DOWN + LEFT, color=RED))\n        e = VGroup(eq, c)\n        er = TexMobject('\\\\Gamma(x) \\\\text{ is not defined for }n < 0', color=RED)\n        er.scale(1.5)\n        er.shift(2 * DOWN)\n        self.play(Write(eq))\n        self.wait()\n        self.play(Write(c))\n        self.play(Write(er))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a title for fractional derivatives, then display the general definition and transform it into the Riemann-Liouville definition."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass FracDeriv(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\frac{d^nf}{dx^n}(I^nf(t)) = f(t)')\n        eq1.scale(1.5)\n        rect = Rectangle(width=7, height=2, color=YELLOW, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        t1 = TexMobject('\\\\text{We are trying to preserve this}', color=RED)\n        t1.scale(1.5)\n        t1.shift(2 * DOWN)\n        eq2 = TexMobject('D^n f = \\\\frac{d^{\\\\lceil n \\\\rceil}}{dx^{\\\\lceil n \\\\rceil}} \\\\left(I^{\\\\lceil n \\\\rceil - n} f \\\\right)')\n        eq2.scale(1.5)\n        eq3 = TexMobject('D^n f(x) = \\\\frac{1}{\\\\Gamma(\\\\lceil n \\\\rceil - n)} \\\\frac{d}{dx^{\\\\lceil n \\\\rceil}} \\\\int_{a}^{x} (x-t)^{\\\\lceil n \\\\rceil - n -1} f(t) dt}')\n        eq3.scale(1)\n        title1 = TextMobject('Fractional Derivative', color=BLUE)\n        title1.scale(1.5)\n        title1.shift(2 * UP)\n        title2 = TextMobject('Left Riemann-Liouville Fractional Derivative', color=BLUE)\n        title2.scale(1)\n        title2.shift(2 * UP)\n        self.play(Write(eq1))\n        self.play(Write(rect), Write(t1))\n        self.wait()\n        self.play(Uncreate(eq1), Uncreate(rect), Uncreate(t1))\n        self.play(Write(eq2), Write(title1))\n        self.wait()\n        self.play(Transform(eq2, eq3), Transform(title1, title2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present the differintegral operator definition with conditional cases and a title."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass DifferEquation(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('D^a f').shift(1 * UP)\n        eq2 = TexMobject('f').shift(0 * UP)\n        eq3 = TexMobject('I^{|a|}').shift(-1 * UP)\n        eq1.align_to(eq2, LEFT)\n        eq3.align_to(eq2, LEFT)\n        t1 = TexMobject('\\\\text{if } a > 0').shift(1 * UP + 2 * RIGHT)\n        t2 = TexMobject('\\\\text{if } a = 0').shift(0 * UP + 2 * RIGHT)\n        t3 = TexMobject('\\\\text{if } a < 0').shift(-1 * UP + 2 * RIGHT)\n        t1.align_to(t2, LEFT)\n        t3.align_to(t2, LEFT)\n        e = VGroup(eq1, eq2, eq3)\n        t = VGroup(t1, t2, t3)\n        et = VGroup(e, t)\n        b = Brace(et, LEFT)\n        bt = b.get_tex('J^af = ')\n        eq = VGroup(et, b, bt)\n        eq.scale(1.5)\n        eq.center()\n        eq.shift(0.5 * DOWN)\n        title = TextMobject('Differintegral Operator', color=YELLOW)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        self.play(Write(eq), Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a mathematical formula for nonlocality with two red rectangles, a title, and an explanatory text."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass Nonlocality(Scene):\n\n    def construct(self):\n        title1 = TextMobject('Nonlocality', color=YELLOW)\n        title1.scale(2)\n        title1.shift(3 * UP)\n        exp1 = TexMobject('D^n \\\\text{ also depends on }a')\n        exp1.scale(1.25)\n        exp1.shift(2 * DOWN)\n        eq1 = TexMobject('D^n_a f(x) = \\\\frac{1}{\\\\Gamma(\\\\lceil n \\\\rceil - n)} \\\\frac{d}{dx^{\\\\lceil n \\\\rceil}} \\\\int_{a}^{x} (x-t)^{\\\\lceil n \\\\rceil - n -1} f(t) dt}')\n        eq1.scale(1)\n        rect1 = Rectangle(height=0.3, width=0.3, color=RED, stroke_width=DEFAULT_STROKE_WIDTH * 1.25)\n        rect1.shift(5.175 * LEFT + 0.15 * DOWN)\n        rect2 = Rectangle(height=0.3, width=0.3, color=RED, stroke_width=DEFAULT_STROKE_WIDTH * 1.25)\n        rect2.shift(0.85 * RIGHT + 0.5 * DOWN)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(rect1), Write(rect2))\n        self.play(Write(title1), Write(exp1))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate the concept of \"Locality\" by showing a derivative operator transforming one function into another on separate graph axes."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass Locality(Scene):\n\n    def construct(self):\n        title = TexMobject('\\\\frac{d^nf}{dx^n} \\\\text{ only depends on } x', tex_to_color_map={'\\\\frac{d^nf}{dx^n}': YELLOW})\n        title.shift(3 * UP)\n        title2 = TexMobject('\\\\frac{d^nf}{dx^n} \\\\text{ has Locality}', color=RED)\n        title2.shift(3 * DOWN)\n        title2.scale(1.25)\n        f1 = ParametricFunction(lambda t: np.array([t, t ** 2, 0]), t_min=0, t_max=math.sqrt(2), color=RED, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        a1 = Axes(x_min=0, x_max=2, y_min=0, y_max=2, number_line_config={'include_tip': False})\n        func1 = VGroup(a1, f1)\n        func1.scale(1.5)\n        func1.shift(4.5 * LEFT + 1 * DOWN)\n        f2 = ParametricFunction(lambda t: np.array([t, 2 * t, 0]), t_min=0, t_max=1, color=BLUE, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        a2 = Axes(x_min=0, x_max=2, y_min=0, y_max=2, number_line_config={'include_tip': False})\n        func2 = VGroup(a2, f2)\n        func2.scale(1.5)\n        func2.shift(3 * RIGHT + 1 * DOWN)\n        a = Arrow(1 * LEFT, 1 * RIGHT, color=GREEN)\n        a.scale(1.5)\n        t = TexMobject('\\\\frac{d}{dx}')\n        t.shift(1 * UP)\n        arr = VGroup(a, t)\n        self.play(Write(title))\n        self.wait()\n        self.play(Write(func1))\n        self.wait()\n        self.play(Write(arr))\n        self.play(TransformFromCopy(func1, func2))\n        self.wait()\n        self.play(Write(title2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display several mathematical formulas related to fractional calculus, one by one."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass Formulas(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('D^a(x^n) = \\\\frac{\\\\Gamma(n+1)}{\\\\Gamma(n+1-a)}x^{n-a}')\n        eq1.scale(1)\n        eq1.shift(3 * UP)\n        eq2 = TexMobject('D^{\\\\frac{1}{2}} (1) = \\\\frac{1}{\\\\sqrt{\\\\pi x}}')\n        eq2.scale(1)\n        eq2.shift(1 * UP)\n        eq3 = TexMobject('D^{a} (\\\\sin(x)) = \\\\sin \\\\left ( x + \\\\frac{a \\\\pi}{2} \\\\right )')\n        eq3.scale(1)\n        eq3.shift(1 * DOWN)\n        eq4 = TexMobject('D^{a} (e^{kx}) = k^{a}e^{kx}')\n        eq4.scale(1)\n        eq4.shift(3 * DOWN)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(eq2))\n        self.wait()\n        self.play(Write(eq3))\n        self.wait()\n        self.play(Write(eq4))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the tautochrone problem by displaying a cycloid with moving points, transforming mathematical equations related to the problem, and highlighting specific parts of the equations."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass TChroneAnim(Scene):\n\n    def construct(self):\n        title = TextMobject('Tautochrone problem', color=GREEN)\n        title.shift(3 * UP)\n        title.scale(1.5)\n        self.cyc = Cycloid(stroke_width=1.25 * DEFAULT_STROKE_WIDTH, color=GRAY)\n        c1 = Circle(radius=0.2, color=BLUE, fill_opacity=1, stroke_color=WHITE)\n        c1.shift(3 * LEFT + 2 * UP)\n        c2 = Circle(radius=0.2, color=RED, fill_opacity=1, stroke_color=WHITE)\n        pos = self.cyc.pos_func(0.5)\n        c2.move_to(pos[0] * RIGHT + pos[1] * UP)\n        c3 = Circle(radius=0.2, color=GREEN, fill_opacity=1, stroke_color=WHITE)\n        pos = self.cyc.pos_func(0.75)\n        c3.move_to(pos[0] * RIGHT + pos[1] * UP)\n        l1 = Line(3 * LEFT + 2 * UP, 3 * LEFT + 2 * DOWN, color=GRAY, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        l2 = Line(3 * LEFT + 2 * DOWN, 3 * RIGHT + 2 * DOWN, color=GRAY, stroke_width=1.25 * DEFAULT_STROKE_WIDTH)\n        eq1 = TexMobject('T(y_0) = \\\\frac{1}{\\\\sqrt{2g}} \\\\int_0^{y_0} \\\\frac{1}{\\\\sqrt{y_0-y}} \\\\frac{ds}{dy} dy')\n        eq1.scale(1.25)\n        eq1.shift(2 * DOWN)\n        eq2 = TexMobject('\\\\frac{T(y_0)}{\\\\sqrt{\\\\pi}} = \\\\frac{1}{\\\\sqrt{2g}}', '\\\\frac{1}{\\\\Gamma(1/2)} \\\\int_0^{y_0} \\\\frac{1}{\\\\sqrt{y_0-y}} \\\\frac{ds}{dy} dy')\n        eq2.scale(1.25)\n        eq3 = TexMobject('\\\\sqrt{\\\\frac{2g}{\\\\pi}}} T_0 = I^{\\\\frac{1}{2}} \\\\left ( \\\\frac{ds}{dy} \\\\right )')\n        eq3.scale(1.25)\n        eq4 = TexMobject('\\\\frac{ds}{dy} = D^{\\\\frac{1}{2}} \\\\left ( \\\\sqrt{\\\\frac{2g}{\\\\pi}} T_0 \\\\right )')\n        eq4.scale(1.25)\n        eq5 = TexMobject('= \\\\frac{\\\\sqrt{2g}}{\\\\pi} \\\\frac{T_0}{\\\\sqrt{y}}')\n        eq5.scale(1.25)\n        eq5.shift(1.5 * DOWN)\n        r1 = Rectangle(height=2, width=7, color=RED)\n        r1.move_to(eq2[1])\n        r2 = Rectangle(height=2, width=3, color=RED)\n        r2.move_to(eq5)\n        fa = TextMobject('Cycloid', color=YELLOW)\n        fa.scale(1.5)\n        fa.move_to(eq5)\n        fa.shift(4 * RIGHT)\n        a1 = Arrow(0 * UP, 1 * DOWN, color=GREEN)\n        a1.move_to(eq2[1])\n        a1.shift(1.25 * DOWN)\n        e1 = TexMobject('I^{\\\\frac{1}{2}}')\n        e1.scale(2)\n        e1.move_to(a1)\n        e1.shift(1 * DOWN)\n        self.play(Write(self.cyc), Write(l1), Write(l2), Write(title))\n        self.play(Write(c1), Write(c2), Write(c3))\n        self.wait()\n        self.play(UpdateFromAlphaFunc(c1, lambda c, dt: self.update(c, dt, start=0)), UpdateFromAlphaFunc(c2, lambda c, dt: self.update(c, dt, start=0.5)), UpdateFromAlphaFunc(c3, lambda c, dt: self.update(c, dt, start=0.75)), rate_func=linear, run_time=2)\n        grp = VGroup(l1, l2, self.cyc, c1, c2, c3)\n        self.wait()\n        self.play(ApplyMethod(grp.shift, 1.5 * UP), Uncreate(title))\n        self.play(Write(eq1))\n        self.wait()\n        self.play(ApplyMethod(grp.scale, 0.25))\n        self.play(ApplyMethod(grp.shift, 1.75 * UP + 5 * RIGHT), ApplyMethod(eq1.center))\n        self.wait()\n        self.play(Transform(eq1, eq2))\n        self.wait()\n        self.play(Write(r1))\n        self.play(Write(a1), Write(e1))\n        self.wait()\n        self.play(Transform(eq1, eq3), Uncreate(e1), Uncreate(r1), Uncreate(a1))\n        self.wait()\n        self.play(Transform(eq1, eq4))\n        self.wait()\n        self.play(eq1.shift, 1.5 * UP)\n        self.play(Write(eq5))\n        self.wait()\n        self.play(Write(r2), Write(fa))\n        self.wait()\n\n    def update(self, c, dt, start=0):\n        a = interpolate(start, 1, dt)\n        pos = self.cyc.pos_func(a)\n        c.move_to(pos[0] * RIGHT + pos[1] * UP)"}]}
{"messages": [{"role": "user", "content": "Animate a circle rolling along a cycloid path, drawing the cycloid as it moves, and then rolling back to the start."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass CycloidScene(Scene):\n    CONFIG = {'point_a': 6 * LEFT + 3 * UP, 'radius': 2, 'end_theta': 2 * np.pi}\n\n    def construct(self):\n        self.generate_cycloid()\n        self.generate_circle()\n        self.generate_ceiling()\n\n    def grow_parts(self):\n        self.play(*[ShowCreation(mob) for mob in (self.circle, self.ceiling)])\n\n    def generate_cycloid(self):\n        self.cycloid = Cycloid(point_a=self.point_a, radius=self.radius, end_theta=self.end_theta)\n\n    def generate_circle(self, **kwargs):\n        self.circle = Circle(radius=self.radius, **kwargs)\n        self.circle.shift(self.point_a - self.circle.get_top())\n        radial_line = Line(self.circle.get_center(), self.point_a)\n        self.circle.add(radial_line)\n\n    def generate_ceiling(self):\n        self.ceiling = Line(FRAME_X_RADIUS * LEFT, FRAME_X_RADIUS * RIGHT)\n        self.ceiling.shift(self.cycloid.get_top()[1] * UP)\n\n    def draw_cycloid(self, run_time=3, *anims, **kwargs):\n        kwargs['run_time'] = run_time\n        self.play(RollAlongVector(self.circle, self.cycloid.points[-1] - self.cycloid.points[0], **kwargs), ShowCreation(self.cycloid, **kwargs), *anims)\n\n    def roll_back(self, run_time=3, *anims, **kwargs):\n        kwargs['run_time'] = run_time\n        self.play(RollAlongVector(self.circle, self.cycloid.points[0] - self.cycloid.points[-1], rotation_vector=IN, **kwargs), ShowCreation(self.cycloid, rate_func=lambda t: smooth(1 - t), **kwargs), *anims)\n        self.generate_cycloid()"}]}
{"messages": [{"role": "user", "content": "Present a two-line quote followed by the author's name."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass IntroQuote(Scene):\n\n    def construct(self):\n        quote = TextMobject('[Fractional derivatives] will lead to a paradox, ')\n        quote2 = TextMobject('from which one day useful consequences will be drawn.')\n        author = TextMobject('-Gottfried Leibniz', color=YELLOW)\n        author.shift(1 * DOWN + 1 * RIGHT)\n        quote.shift(2 * UP)\n        quote2.shift(UP)\n        self.play(Write(quote), Write(quote2))\n        self.play(Write(author))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the text \"Part 1\" above \"Fractional Integration\" and then fade both out."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass PartOneTitle(Scene):\n\n    def construct(self):\n        part = TextMobject('Part 1')\n        part.scale(1.5)\n        part.shift(2 * UP)\n        title = TextMobject('Fractional Integration', color=RED)\n        title.scale(2)\n        self.play(Write(part))\n        self.play(Write(title))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display the Gamma function's first three values sequentially."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass GammaPlug(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\Gamma(1) = (1-1)! = 1')\n        eq1.shift(1 * UP)\n        eq2 = TexMobject('\\\\Gamma(2) = (2-1)! = 1')\n        eq3 = TexMobject('\\\\Gamma(3) = (3-1)! = 2')\n        eq3.shift(1 * DOWN)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(eq2))\n        self.wait()\n        self.play(Write(eq3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Write the title \"Part 2\" and then the title \"The Left R-L Fractional Derivative\" in green."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass PartTwoTitle(Scene):\n\n    def construct(self):\n        part = TextMobject('Part 2')\n        part.scale(1.5)\n        part.shift(2 * UP)\n        title = TextMobject('The Left R-L Fractional Derivative', color=GREEN)\n        title.scale(1.75)\n        self.play(Write(part))\n        self.play(Write(title))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display two calculus rules, one for function composition and one for the product rule, and then indicate that they are incorrect."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass ChainProduct(Scene):\n\n    def construct(self):\n        eq1 = TexMobject(\"\\\\frac{d}{dx} f(g(x)) = f'(g(x)) g'(x)\")\n        eq1.shift(1 * UP)\n        eq1.scale(1.5)\n        eq2 = TexMobject(\"\\\\frac{d}{dx} f(x)g(x) = f'(x)g(x) + g'(x)f(x)\")\n        eq2.scale(1.5)\n        eq2.shift(1 * DOWN)\n        text = TextMobject(\"These don't work\", color=RED)\n        text.scale(1.5)\n        text.shift(3 * DOWN)\n        self.play(Write(eq1), Write(eq2))\n        self.wait()\n        self.play(Write(text))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Write out the text \"Part 3\" and then \"Tautochrone Problem\" with the second title in purple."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport scipy.special\n\nclass PartThreeTitle(Scene):\n\n    def construct(self):\n        part = TextMobject('Part 3')\n        part.scale(1.5)\n        part.shift(2 * UP)\n        title = TextMobject('Tautochrone Problem', color=PURPLE)\n        title.scale(2)\n        self.play(Write(part))\n        self.play(Write(title))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display \"v^3(x)\" with the \"v^3\" part in red and \"x\" in cyan, then show \"vcubingx\" below it."}, {"role": "assistant", "content": "from manimlib import *\n\nclass IntroSmooth(Scene):\n\n    def construct(self):\n        h1 = '#ff5757'\n        h2 = '#5ce1e6'\n        text = Tex('\\\\textbf{\\\\text{v}} ^3} \\\\textbf{(}\\\\textbf{\\\\text{x}}}\\\\textbf{)}', tex_to_color_map={'\\\\textbf{\\\\text{v}} ^3': h1, '\\\\textbf{\\\\text{x}}': h2}, font_size=48 * 4)\n        vc = TexText('vcubingx')\n        vc.scale(1.5)\n        vc.shift(2 * DOWN)\n        self.play(Write(text), run_time=2)\n        self.play(FadeIn(vc))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Present a quote about the Riemann integral followed by its author and then fade them out."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass IntroQuote(Scene):\n\n    def construct(self):\n        quote = TextMobject('\\n        I have to pay a certain sum, which I have collected in my pocket.\\n        I take the bills and coins out of my pocket and give them to the \\n        creditor in the order I find them until I have reached the total \\n        sum. This is the Riemann integral. But I can proceed differently. \\n        After I have taken all the money out of my pocket I order the bills \\n        and coins according to identical values and then I pay the \\n        several heaps one after the other to the creditor. This is my integral.')\n        quote.scale(0.75)\n        author = TextMobject('- Henri Lebesgue', color=YELLOW)\n        author.shift(2 * DOWN + 3 * RIGHT)\n        self.play(Write(quote))\n        self.play(Write(author))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Present a title about Riemann integration problems and sequentially highlight bullet points of related issues."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Problems(Scene):\n\n    def construct(self):\n        title = TextMobject('Problems with Riemann Integration', color=PURPLE)\n        title.scale(1.25)\n        title.shift(3 * UP)\n        l = BulletedList('Higher Dimensions', 'Continuity', dot_color=BLUE, buff=0.75 * LARGE_BUFF)\n        l.scale(1.5)\n        l.shift(0.25 * DOWN)\n        self.play(FadeInFromDown(title))\n        self.play(Write(l))\n        self.wait()\n        self.play(l.fade_all_but, 0)\n        self.wait()\n        self.play(l.fade_all_but, 1)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a 3D plot of the sine and cosine function using interconnected prisms on three axes, with a rotating camera."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass HigherDim(ThreeDScene):\n\n    def construct(self):\n        axis_config = {'x_min': -5, 'x_max': 5, 'y_min': -5, 'y_max': 5, 'z_min': -3.5, 'z_max': 3.5}\n        axes = ThreeDAxes(**axis_config)\n        cubes = VGroup()\n        for x in np.arange(-5, 5.1, 0.5):\n            for y in np.arange(-5, 5.1, 0.5):\n                z = np.sin(x) + np.cos(y)\n                p = Prism(dimensions=[0.5, 0.5, z])\n                p.shift([x, y, z / 2])\n                cubes.add(p)\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.play(Write(axes))\n        self.play(Write(cubes))\n        self.begin_ambient_camera_rotation(rate=0.08)\n        self.wait(30)"}]}
{"messages": [{"role": "user", "content": "Display a piecewise function with animated Riemann sums and a growing rectangle."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass PieceWise(Scene):\n\n    def construct(self):\n        axes = Axes(x_min=-1, x_max=5, y_min=-1, y_max=5, axis_config={'include_tip': False})\n        f = VGroup(FunctionGraph(lambda x: 2, x_min=0, x_max=2.5), FunctionGraph(lambda x: 4, x_min=2.5, x_max=5))\n        r1 = self.get_riemann_sums(lambda x: 2)\n        grp = VGroup(axes, f, r1)\n        grp.center()\n        self.play(Write(axes), Write(f))\n        self.wait()\n        colors = color_gradient([BLUE, GREEN], 3)\n        for i in range(2):\n            r1[i].set_fill(color=colors[i])\n        self.play(Write(r1))\n        self.wait()\n        r = Rectangle(height=1.9, width=1, stroke_opacity=1, fill_opacity=1, stroke_color=BLACK, fill_color=colors[-1])\n        r.next_to(r1[-1], RIGHT).shift(0.25 * LEFT)\n        h = ValueTracker(1.9)\n\n        def update(rect):\n            r = Rectangle(height=h.get_value(), width=1, stroke_opacity=1, fill_opacity=1, stroke_color=BLACK, fill_color=colors[-1])\n            r.next_to(r1[-1], RIGHT).shift(0.25 * LEFT + (h.get_value() - 1.9) / 2 * UP)\n            rect.become(r)\n        r.add_updater(update)\n        self.play(Write(r))\n        self.play(h.increment_value, 2, rate_func=there_and_back, run_time=3)\n        self.wait()\n\n    def get_riemann_sums(self, func, dx=1, x=(0.5, 2.5), color=RED):\n        rects = VGroup()\n        for i in np.arange(x[0], x[1], dx):\n            h = func(i)\n            rect = Rectangle(height=h - 0.1, width=dx, stroke_color=BLACK, fill_color=BLACK, stroke_opacity=1, fill_opacity=1)\n            rect.shift(i * RIGHT + h / 2 * UP)\n            rects.add(rect)\n        return rects"}]}
{"messages": [{"role": "user", "content": "Display the definition of the Dirichlet function and then scale and move it upwards."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass IRFunc(Scene):\n\n    def construct(self):\n        eq = TexMobject('f(x) = \\\\begin{cases} 0 & x \\\\text{ is rational} \\\\\\\\ 1 & x \\\\text{ is irrational} \\\\end{cases}')\n        eq.scale(1.5)\n        self.play(Write(eq))\n        self.wait()\n        self.play(eq.scale, 0.5)\n        self.play(eq.shift, 3 * UP)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the text \"0.123123...\" with an accompanying brace explaining it as a geometric series, then display the corresponding function graph and limit equation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass IRExp(Scene):\n\n    def construct(self):\n        num = TexMobject('0.', '123', '123123...')\n        num.scale(3)\n        self.play(FadeInFromDown(num[0]))\n        self.wait()\n        self.play(FadeInFromDown(num[1]))\n        self.wait()\n        b = Brace(num[2], color=YELLOW)\n        t = b.get_tex('P = (0.1)^n')\n        br = VGroup(b, t)\n        self.play(Write(num[2]))\n        self.play(Write(br))\n        self.wait()\n        axes = Axes(x_min=-1, x_max=1, y_min=0, y_max=1, axis_config={'include_tip': False})\n        f = FunctionGraph(lambda x: 0.1 * math.pow(0.1, x), x_min=-1, x_max=1, color=TEAL)\n        func = VGroup(axes, f)\n        func.shift(2 * UP + 3 * LEFT)\n        func.scale(2)\n        eq = TexMobject('\\\\lim_{n \\\\rightarrow \\\\infty} 0.1^n = 0')\n        eq.scale(1.5)\n        eq.shift(2 * UP + 3 * RIGHT)\n        self.play(Write(func))\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the display of the integral equation \"\u222b\u2080\u00b9 f(x) dx = 1\"."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Integ2(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\int_0^1 f(x) dx = 1')\n        eq.scale(2)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the title \"Lebesgue Integration\" in gold text."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LebesguePart(Scene):\n\n    def construct(self):\n        title = TextMobject('Lebesgue Integration', color=GOLD)\n        title.scale(2)\n        self.play(Write(title), run_time=3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display an image of Henri Lebesgue with his name written below it."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass HenriLebesgue(Scene):\n\n    def construct(self):\n        img = ImageMobject('./img/henri.jpg')\n        img.scale(2.5)\n        img.shift(1 * UP)\n        eq = TextMobject('Henri Lebesgue').scale(1.5).shift(2.5 * DOWN)\n        self.play(FadeInFromDown(img))\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the Lebesgue integral by showing a function graph and animating approximating rectangles that progressively refine."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LebesgueIntegral(Scene):\n    CONFIG = {'func': lambda x: -0.9 * (x - 2.5) ** 2 + 2.5}\n\n    def construct(self):\n        axes = Axes(x_min=0, x_max=5, y_min=0, y_max=3, axis_config={'include_tip': False})\n        f = FunctionGraph(self.func, x_min=0.833, x_max=4.167, color=WHITE, stroke_width=2)\n        rects = VGroup(*[self.get_lebesgue_rectangles(dx=dx) for dx in np.arange(0.5, 0.1, -0.1)])\n        grp = VGroup(axes, f, rects)\n        grp.center()\n        grp.scale(2)\n        self.play(Write(axes), Write(f))\n        self.play(Write(rects[0]))\n        self.wait(1)\n        for rect in rects[1:]:\n            self.play(Transform(rects[0], rect))\n            self.wait(1)\n\n    def get_lebesgue_rectangles(self, dx=0.2, y=(0, 2.4)):\n        rects = VGroup()\n        y_range = np.arange(y[0], y[1], dx)\n        colors = color_gradient([BLUE, GREEN], len(y_range))\n        for color, y in zip(colors, y_range):\n            x = abs(2.5 - (((y + dx - 2.5) / -0.9) ** (1 / 2) + 2.5))\n            rect = Rectangle(height=dx, width=2 * x, stroke_color=BLACK, fill_color=color, stroke_opacity=1, fill_opacity=1, stroke_width=2 * dx)\n            rect.shift([2.5, y + dx / 2, 0])\n            rects.add(rect)\n        return rects"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of the Lebesgue integral by showing a function defined on [0,1], its partition into rational and irrational sets, and the subsequent integration."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass IRLebesgue(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('f(x), x \\\\in [0, 1]')\n        eq1.scale(1.5)\n        eq1.shift(3.25 * UP)\n        arr1 = Arrow(2.75 * UP, 2 * UP + 4 * LEFT, color=YELLOW)\n        arr2 = Arrow(2.75 * UP, 2 * UP + 4 * RIGHT, color=YELLOW)\n        a0 = TexMobject('A_0', color=BLUE)\n        a0.scale(1.5)\n        a0.shift(1.25 * UP + 4 * LEFT)\n        a1 = TexMobject('A_1', color=BLUE)\n        a1.scale(1.5)\n        a1.shift(1.25 * UP + 4 * RIGHT)\n        eq2 = TextMobject('\\\\(f(x) = 0 \\\\) \\\\\\\\ \\\\(x\\\\) is rational', tex_to_color_map={'rational': GREEN})\n        eq2.shift(0 * UP + 4 * LEFT)\n        eq3 = TextMobject('\\\\( f(x) = 1 \\\\) \\\\\\\\ \\\\(x\\\\) is irrational', tex_to_color_map={'irrational': GREEN})\n        eq3.shift(0 * UP + 4 * RIGHT)\n        integ = TexMobject('\\\\int_0^1 f(x) \\\\mathrm{d}\\\\mu = 0 \\\\cdot \\\\mu (A_0) + 1 \\\\cdot \\\\mu (A_1)', tex_to_color_map={'A_0': BLUE, 'A_1': BLUE, '\\\\mu': GOLD})\n        integ.shift(2 * DOWN)\n        integ.scale(1.5)\n        self.play(Write(eq1))\n        self.play(Write(arr1), Write(arr2))\n        self.play(Write(a0), Write(eq2))\n        self.play(Write(a1), Write(eq3))\n        self.wait()\n        self.play(Write(integ))\n        self.wait()\n        self.play(Uncreate(VGroup(eq1, arr1, arr2, a0, eq2, a1, eq3)))\n        self.play(integ.shift, 3 * UP)\n        self.wait()\n        soln = TexMobject('= 0 \\\\cdot 0 + 1 \\\\cdot 1 = ', '1')\n        soln.scale(1.5)\n        soln.shift(1 * DOWN + 1 * RIGHT)\n        brect = BackgroundRectangle(soln[-1], color=YELLOW, fill_opacity=0, stroke_width=4, stroke_opacity=1, buff=0.25)\n        self.play(Write(soln))\n        self.play(Write(brect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Introduce the title \"Lebesgue Integral\" and then display two equations related to Lebesgue integration, highlighting specific terms."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LebesgueEq(Scene):\n\n    def construct(self):\n        title = TextMobject('Lebesgue Integral', color=PURPLE)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        self.play(FadeInFromDown(title))\n        self.wait()\n        eq1 = TexMobject('\\\\int_{a}^{b} f(x) \\\\mathrm{d} \\\\mu =\\\\sum_{i=1}^{n} y_{i} \\\\cdot \\\\mu \\\\left(A_{y_{i}}\\\\right)', tex_to_color_map={'A_{y_{i}}': BLUE, '\\\\mu': GOLD})\n        eq1.scale(1.5)\n        eq1.shift(1 * UP)\n        self.play(Write(eq1))\n        self.wait()\n        eq2 = TexMobject('\\\\int_{a}^{b} f(x) d \\\\mu =\\\\lim _{n \\\\rightarrow \\\\infty} \\\\int_{a}^{b} f_{n}(x) d \\\\mu', tex_to_color_map={'f_{n}': BLUE, '\\\\mu': GOLD})\n        eq2.scale(1.5)\n        eq2.shift(2 * DOWN)\n        self.play(Write(eq2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a graph representing electric current with labeled axes and a descriptive title."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Electric(Scene):\n\n    def construct(self):\n        f = FunctionGraph(self.func, color=RED, x_min=-6)\n        axes = Axes(x_min=0, x_max=15, y_min=-2, y_max=2, axis_config={'include_tip': False})\n        lbl = TextMobject('Electric Current \\\\( E(t) \\\\)')\n        lbl.shift([-4, 3, 0])\n        axes.shift(6 * LEFT)\n        self.play(Write(axes), Write(lbl))\n        self.play(Write(f), rate_func=smooth, run_time=4)\n        self.wait()\n\n    def func(self, x):\n        if -4 <= x <= -2.5 or 0 <= x <= 1.5 or x >= 4:\n            return 1\n        return 0"}]}
{"messages": [{"role": "user", "content": "Display a graph of the function $e^{-t^2}$ with Riemann sums and the expected value integral formula."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ExpectedProb(Scene):\n\n    def construct(self):\n        f = ParametricFunction(function=self.func, t_min=-3, t_max=3, color=WHITE)\n        axes = Axes(x_min=-3, x_max=3, y_min=0, y_max=2, number_line_config={'color': LIGHT_GREY, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        rect = self.get_riemann_sums(self.func)\n        rect.scale(1.95)\n        rect.shift(2.4 * DOWN)\n        func = VGroup(axes, f)\n        func.scale(2)\n        func.shift(2 * DOWN)\n        eq2 = TexMobject('E[x] = \\\\int_{-\\\\infty}^{\\\\infty} P(x) \\\\mathrm{d} x')\n        eq2.scale(1.5)\n        eq2.shift(2.5 * UP)\n        self.play(Write(func))\n        self.wait()\n        self.play(Write(eq2))\n        self.play(Write(rect))\n        self.wait()\n\n    @staticmethod\n    def get_riemann_sums(func, dx=0.01, x=(-3, 3), color=RED):\n        rects = VGroup()\n        x_range = np.arange(x[0], x[1], dx)\n        for i in x_range:\n            h = func(i)[1]\n            rect = Rectangle(height=h, width=dx, color=BLACK, stroke_width=0, stroke_opacity=0, fill_opacity=1)\n            rect.shift(i * RIGHT + h / 2 * UP)\n            rects.add(rect)\n        colors = color_gradient([BLUE, PURPLE], len(x_range))\n        for i in range(len(x_range)):\n            rects[i].set_fill(color=colors[i])\n        return rects\n\n    def func(self, t):\n        return np.array([t, np.exp(-t ** 2), 0])"}]}
{"messages": [{"role": "user", "content": "Display the expected value formula with colored terms."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Expected(Scene):\n\n    def construct(self):\n        eq = TexMobject('E[x] = \\\\int X \\\\mathrm{d} P', tex_to_color_map={'E': GOLD, 'x': BLUE, 'P': YELLOW})\n        eq.scale(2)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the integral of f(x) with respect to mu, coloring f red, x blue, and mu gold."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass T2(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\int f(x) d \\\\mu', tex_to_color_map={'\\\\mu': GOLD, 'x': BLUE, 'f': RED})\n        eq.scale(4)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate a scene illustrating a parabolic function with animated Lebesgue rectangles."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Thumbnail(Scene):\n    CONFIG = {'func': lambda x: -0.9 * (x - 2.5) ** 2 + 2.5}\n\n    def construct(self):\n        axes = Axes(x_min=-10, x_max=12, y_min=-123, y_max=122, axis_config={'include_tip': False})\n        f = FunctionGraph(self.func, x_min=0.833, x_max=4.167, color=WHITE, stroke_width=2)\n        rects = self.get_lebesgue_rectangles(dx=0.3)\n        grp = VGroup(axes, f, rects)\n        grp.scale(1.75)\n        grp.shift(3.5 * LEFT + 3.5 * DOWN)\n        self.play(Write(axes), Write(f))\n        self.play(Write(rects))\n        self.wait(1)\n\n    def get_lebesgue_rectangles(self, dx=0.2, y=(0, 2.4)):\n        rects = VGroup()\n        y_range = np.arange(y[0], y[1], dx)\n        colors = color_gradient([BLUE, GREEN], len(y_range))\n        for color, y in zip(colors, y_range):\n            x = abs(2.5 - (((y + dx - 2.5) / -0.9) ** (1 / 2) + 2.5))\n            rect = Rectangle(height=dx, width=2 * x, stroke_color=BLACK, fill_color=color, stroke_opacity=1, fill_opacity=1, stroke_width=2 * dx)\n            rect.shift([2.5, y + dx / 2, 0])\n            rects.add(rect)\n        return rects"}]}
{"messages": [{"role": "user", "content": "Draw a parametric curve on a Cartesian plane."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass NumberLineTest(Scene):\n\n    def construct(self):\n        a = Axes(x_min=-3, x_max=3, y_min=-3, y_max=3, axis_config={'include_tip': False})\n        f = ParametricFunction(self.func, t_min=0, t_max=2 * PI, color=BLUE)\n        self.add(a, f)\n\n    def func(self, t):\n        return [2 * math.sin(t), math.cos(t), 0]"}]}
{"messages": [{"role": "user", "content": "Render a 3D parabolic surface with animated camera rotation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ThreeDGraph(ThreeDScene):\n\n    def construct(self):\n        axis_config = {'x_min': -5.5, 'x_max': 5.5, 'y_min': -5.5, 'y_max': 5.5, 'z_min': -3.5, 'z_max': 3.5}\n        a = ThreeDAxes(**axis_config)\n        surface = ParametricSurface(self.sur, u_min=-3, u_max=3, v_min=-3, v_max=3)\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.add(a, surface)\n        self.begin_ambient_camera_rotation(rate=0.04)\n        self.wait(10)\n\n    def sur(self, u, v):\n        return [u, v, u ** 2 + v ** 2]"}]}
{"messages": [{"role": "user", "content": "Generate a scatter plot of noisy data points and overlay a red linear regression line with axis labels and the regression equation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.optimize import curve_fit\n\nclass LinReg(Scene):\n\n    def construct(self):\n        xdata = np.linspace(0.25, 5.75, 15)\n        ydata = [self.func(i) + 2 * (np.random.random() - 0.5) for i in xdata]\n\n        def f(x, a, b):\n            return a * x + b\n        theta, _ = curve_fit(f, xdata, ydata)\n        axes = Axes(x_min=0, x_max=6, y_min=0, y_max=5, axis_config={'include_tip': False})\n        points = VGroup(*[Dot([xdata[i], ydata[i], 0], color=BLUE, radius=0.75 * DEFAULT_DOT_RADIUS) for i in range(15)])\n        line = FunctionGraph(lambda x: f(x, *theta), x_min=0, x_max=6, color=RED)\n        dlines = VGroup(DashedLine(2.9 * RIGHT, f(2.9, *theta) * UP + 2.9 * RIGHT), DashedLine(f(2.9, *theta) * UP, f(2.9, *theta) * UP + 2.9 * RIGHT))\n        grp1 = VGroup(axes, points, line)\n        grp = VGroup(grp1, dlines)\n        grp.center()\n        self.play(Write(axes))\n        self.play(Write(points), Write(line))\n        self.wait()\n        xlbl = TextMobject('Plot Size (ft\\\\(^2\\\\))')\n        xlbl.shift(3 * DOWN)\n        ylbl = TextMobject('Market Price (\\\\$)')\n        ylbl.rotate(PI / 2)\n        ylbl.shift(4 * LEFT + 0.5 * UP)\n        self.play(grp1.shift, 0.5 * UP)\n        dlines.shift(0.5 * UP)\n        self.play(FadeInFromDown(xlbl), FadeInFromDown(ylbl))\n        lbl = TexMobject(f'\\\\hat{{ \\\\text{{price}}}} = {round(theta[0], 2)} + {round(theta[1], 2)} \\\\ \\\\text{{size}}', color=RED)\n        lbl.shift(5 * RIGHT + 2 * UP)\n        lbl.scale(0.75)\n        ypoint = Dot([0, 0.32, 0], color=YELLOW, radius=0.08)\n        self.play(points.set_opacity, 0.5)\n        self.play(Write(lbl), Write(dlines), Write(ypoint))\n        self.wait()\n\n    @staticmethod\n    def func(x):\n        return 0.425 * x + 0.785"}]}
{"messages": [{"role": "user", "content": "Visualize a scatter plot with two distinct color-coded regions separated by a line, then transition to displaying and explaining the sigmoid function used in logistic regression."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.optimize import curve_fit\n\nclass LogReg(Scene):\n\n    def construct(self):\n        n = 100\n        points = []\n        colors = []\n        c1 = '#99EDCC'\n        c2 = '#B85C8C'\n        for _ in range(n):\n            point = np.random.random(2) * 5.5 + 0.25\n            points.append(point)\n            colors.append(1 if point[0] > point[1] else 0)\n        pointg = VGroup(*[Dot([points[i][0], points[i][1], 0], color=c1 if colors[i] else c2) for i in range(len(colors))])\n        axes = Axes(x_min=0, x_max=6, y_min=0, y_max=6, axis_config={'include_tip': False})\n        line = FunctionGraph(lambda x: x, x_min=0, x_max=6)\n        grp = VGroup(axes, pointg, line)\n        grp.center()\n        self.play(Write(axes))\n        self.play(Write(pointg))\n        self.wait()\n        self.play(ApplyMethod(pointg.set_opacity, 0.5), Write(line))\n        self.wait()\n        self.play(grp.shift, 3 * LEFT)\n        eq1 = TexMobject('\\\\hat{y} = ', '\\\\sigma ( ', 'b_0 + b_1 x ', ')', tex_to_color_map={'x': GREEN, 'y': GOLD, '\\\\sigma': YELLOW})\n        eq1.scale(1.5)\n        eq1.shift(3.5 * RIGHT)\n        self.play(Write(VGroup(eq1[:3], eq1[5:7])))\n        self.wait()\n        self.play(FadeInFromDown(VGroup(eq1[3:5], eq1[7])))\n        self.wait()\n        eq2 = TexMobject('\\\\sigma ( x ) = \\\\frac{1}{1 + e^{-x}}', tex_to_color_map={'\\\\sigma': YELLOW})\n        eq2.scale(1.5)\n        eq2.shift(2.75 * UP)\n        self.play(Uncreate(grp))\n        self.play(TransformFromCopy(eq1[3], eq2[0]))\n        self.play(Write(eq2[1:]))\n        self.play(Uncreate(VGroup(eq1)))\n        self.wait()\n        axes = Axes(x_min=-3, x_max=3, y_min=0, y_max=2, axis_config={'include_tip': False})\n        eq = FunctionGraph(lambda x: 2 / (1 + np.exp(-2 * x)), x_min=-3, x_max=3, color=GOLD)\n        grp2 = VGroup(axes, eq)\n        grp2.scale(2)\n        grp2.center()\n        grp2.shift(DOWN)\n        lbls = VGroup(TexMobject('0.5').shift(DOWN), TexMobject('1.0').shift(UP)).shift(0.75 * LEFT + 0.2 * UP)\n        self.play(Write(grp2))\n        self.wait()\n        self.play(Write(lbls))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a neural network and its corresponding linear equation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.optimize import curve_fit\n\nclass LayerToLayer(Scene):\n\n    def construct(self):\n        nn = NeuralNetworkMobject([5, 1], 0.2)\n        nn.scale(2)\n        nn.add_input_labels()\n        nn.add_y()\n        nn.add_weight_labels()\n        nn.shift(0.75 * UP)\n        eq = TexMobject('y = \\\\sigma (b_0 + b_1x_1 + b_2x_2 + b_3x_3 + b_4x_4)')\n        eq.scale(1.5)\n        eq.shift(3 * DOWN)\n        self.play(Write(nn))\n        self.play(Write(eq))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Illustrate a neural network with labels explaining its components."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.optimize import curve_fit\n\nclass NeuralNetwork(Scene):\n\n    def construct(self):\n        network = NeuralNetworkMobject([3, 4, 3], 0.15)\n        network.scale(2.5)\n        neuron_arrow = Arrow(ORIGIN, 1 * UP)\n        neuron_arrow.next_to(network, 1 * UP)\n        neuron_text = TextMobject('Each of these circles is a model')\n        neuron_text.next_to(neuron_arrow, 1 * UP)\n        self.play(Write(network))\n        self.play(Write(neuron_arrow), Write(neuron_text))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of neuroevolution by displaying a neural network with scores, showing transformations between generations and indicating a cycle of repetition."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.optimize import curve_fit\n\nclass NeuroEvolution(Scene):\n\n    def construct(self):\n        n = 3\n        m = 1\n        shift = [m * UP + n * LEFT, m * UP, m * UP + n * RIGHT, m * DOWN + n * LEFT, m * DOWN, m * DOWN + n * RIGHT]\n        scores = ['312', '434', '145', '254', '332', '521']\n        scores2 = ['624', '512', '765', '432', '332', '521']\n        head = TextMobject('Neuroevolution', color=RED)\n        head.scale(2)\n        head2 = TextMobject('Neuroevolution', color=RED)\n        head2.scale(2)\n        head2.shift(3 * UP)\n        rep = TextMobject('This process is repeated', color=BLUE)\n        rep.scale(2)\n        one = TextMobject('1994', color=RED)\n        one.scale(2)\n        survival = TextMobject('Survival of the fittest')\n        survival.scale(1.5)\n        survival.shift(2 * DOWN)\n        net_group = VGroup()\n        text_group = VGroup()\n        text_group2 = VGroup()\n        circle1 = Circle(color=GREEN)\n        circle1.shift(shift[5])\n        circle2 = Circle(color=GREEN)\n        circle2.shift(shift[1])\n        circle3 = Circle(color=GREEN)\n        circle3.shift(shift[0])\n        circle4 = Circle(color=GREEN)\n        circle4.shift(shift[2])\n        for i in range(6):\n            net = NeuralNetworkMobject([2, 3, 2])\n            net.shift(shift[i])\n            net_group.add(net)\n            text = TextMobject(scores[i])\n            text.shift(shift[i])\n            text.scale(1.5)\n            text_group.add(text)\n            text2 = TextMobject(scores2[i])\n            text2.shift(shift[i])\n            text2.scale(1.5)\n            text_group2.add(text2)\n        self.play(Write(one))\n        self.play(Transform(one, head))\n        self.play(Write(survival))\n        self.wait(0.25)\n        self.play(ApplyMethod(one.shift, 3 * UP), Transform(survival, head2))\n        self.play(Write(net_group))\n        self.wait(0.25)\n        self.play(Write(text_group))\n        self.wait(0.25)\n        self.play(Write(circle1), Write(circle2))\n        self.wait(0.25)\n        self.play(Transform(circle1, net_group), Uncreate(circle2), Uncreate(text_group), Uncreate(net_group))\n        self.wait(0.25)\n        self.play(Write(text_group2))\n        self.play(Write(circle3), Write(circle4))\n        self.wait(0.25)\n        self.play(Uncreate(circle1), Uncreate(text_group2), Uncreate(circle3), Uncreate(circle4), Write(rep))\n        self.wait(0.25)"}]}
{"messages": [{"role": "user", "content": "Display \"Part 1\" above the red title \"Building on From Linear Regresssion\"."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.optimize import curve_fit\n\nclass PartOneTitle(Scene):\n\n    def construct(self):\n        part = TextMobject('Part 1')\n        part.scale(1.5)\n        part.shift(2 * UP)\n        title = TextMobject('Building on From Linear Regresssion', color=RED)\n        title.scale(1.5)\n        self.play(Write(part))\n        self.play(Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display \"Part 2\" and then \"Still too simple :(\" on the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.optimize import curve_fit\n\nclass PartTwoTitle(Scene):\n\n    def construct(self):\n        part = TextMobject('Part 2')\n        part.scale(1.5)\n        part.shift(2 * UP)\n        title = TextMobject('Still too simple :(', color=PURPLE)\n        title.scale(1.5)\n        self.play(Write(part))\n        self.play(Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display \"Part 3\" above \"Applications of NEAT\" in blue."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.optimize import curve_fit\n\nclass PartThreeTitle(Scene):\n\n    def construct(self):\n        part = TextMobject('Part 3')\n        part.scale(1.5)\n        part.shift(2 * UP)\n        title = TextMobject('Applications of NEAT', color=BLUE)\n        title.scale(1.5)\n        self.play(Write(part))\n        self.play(Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the transformation of the complex plane by multiplying each point by (1 + sqrt(3)i) and display the text \"v^3(x)\"."}, {"role": "assistant", "content": "from manimlib import *\n\nclass Hoodie2(Scene):\n\n    def construct(self):\n        text = Tex('\\\\textbf{\\\\text{v}} ^3 \\\\textbf{\\\\text{(}}\\\\textbf{\\\\text{x}}\\\\textbf{\\\\text{)}}}', tex_to_color_map={'\\\\textbf{\\\\text{v}} ^3': h1, '\\\\textbf{\\\\text{x}}': h2}, color=BLACK)\n        text.scale(4)\n\n        def func(z):\n            return (1 + np.sqrt(3) * 1j) * z\n        complex_kwargs = {'background_line_style': {'stroke_opacity': 0.85, 'stroke_width': 6}}\n        c = ComplexPlane(**complex_kwargs)\n        c.prepare_for_nonlinear_transform()\n        c.apply_complex_function(lambda z: (1 + np.sqrt(3) * 1j) * z)\n        self.add(c)\n        self.add(text)\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Render the text \"v^3(x)\" scaled and transformed by a complex function."}, {"role": "assistant", "content": "from manimlib import *\n\nclass LogoTransparent(Scene):\n\n    def construct(self):\n        text = Tex('\\\\textbf{\\\\text{v}} ^3 \\\\textbf{\\\\text{(}}\\\\textbf{\\\\text{x}}\\\\textbf{\\\\text{)}}}', tex_to_color_map={'\\\\textbf{\\\\text{v}} ^3': h1, '\\\\textbf{\\\\text{x}}': h2}, color=WHITE)\n        text.scale(4)\n\n        def func(z):\n            return (1 + np.sqrt(3) * 1j) * z\n        text.apply_complex_function(func)\n        text.scale(0.5)\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Animate a complex plane with a nonlinear transformation and display a scaled text object that also undergoes the same complex function transformation."}, {"role": "assistant", "content": "from manimlib import *\n\nclass Hoodie3(Scene):\n    CONFIG = {'plane_opacity': 0.85, 'x': 0.5, 'y': 0.5, 'vec_opacity': 1}\n\n    def construct(self):\n        complex_kwargs = {'background_line_style': {'stroke_opacity': self.plane_opacity, 'stroke_color': BLUE_E, 'stroke_width': 6}}\n        text = Tex('\\\\textbf{\\\\text{v}} ^3 \\\\textbf{\\\\text{(}}\\\\textbf{\\\\text{x}}\\\\textbf{\\\\text{)}}}', tex_to_color_map={'\\\\textbf{\\\\text{v}} ^3': h1, '\\\\textbf{\\\\text{x}}': h2}, color=WHITE)\n        text.scale(4)\n        c2 = ComplexPlane(x_range=(-3, 3), y_range=(-3, 3), **complex_kwargs)\n        c2.shift(FRAME_WIDTH / 4 * RIGHT)\n        c2.prepare_for_nonlinear_transform()\n        c2.apply_complex_function(self.func)\n\n        def func(z):\n            return (1 + np.sqrt(3) * 1j) * z\n        text.apply_complex_function(func)\n        text.scale(0.5)\n        self.add(c2)\n        self.embed()\n\n    def get_vec(self, plane, coors, **kwargs):\n        x, y = (coors[0], coors[1])\n        z = plane.c2p(x, y)\n        return Arrow(plane.c2p(0, 0), z, buff=0, **kwargs)\n\n    def f_deriv(self, z, dz=1e-06 + 1e-06 * 1j):\n        return (self.func(z + dz) - self.func(z)) / dz\n\n    def func(self, z):\n        return (1 * z + np.sin(z)) * 0.3 - 1"}]}
{"messages": [{"role": "user", "content": "Display the text \"f'(z) = 1 + \\sqrt{3}i\" scaled to be large and in black."}, {"role": "assistant", "content": "from manimlib import *\n\nclass HText(Scene):\n\n    def construct(self):\n        t = Tex(\"f'(z) = 1 + \\\\sqrt{3}i\", color=BLACK)\n        t.scale(4)\n        self.add(t)"}]}
{"messages": [{"role": "user", "content": "Introduce a scene with the text \"Why do we use Mean Squared Error?\" with \"Mean Squared Error\" highlighted in yellow."}, {"role": "assistant", "content": "from manim import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        text = TextMobject('Why do we use Mean Squared Error?', tex_to_color_map={'Mean Squared Error': YELLOW})\n        text.scale(1.5)\n        self.play(Write(text))"}]}
{"messages": [{"role": "user", "content": "Display \"Cost Function\" transforming into a squared error formula, followed by \"not\" and a absolute error formula."}, {"role": "assistant", "content": "from manim import *\n\nclass CostFunction(Scene):\n\n    def construct(self):\n        text = TextMobject('Cost Function', color=YELLOW)\n        text2 = TextMobject('not', color=RED)\n        eq2 = TextMobject('$\\\\frac{1}{2m} \\\\sum_{i=1}^{m} |h_\\\\theta (x^{(i)}) - y^{(i)}| $')\n        eq1 = TextMobject('$\\\\frac{1}{2m} \\\\sum_{i=1}^{m} (h_\\\\theta (x^{(i)}) - y^{(i)})^2 $')\n        text.scale(2)\n        eq1.scale(2.5)\n        eq2.scale(2.5)\n        text2.scale(2)\n        eq2.move_to(3 * DOWN)\n        text.move_to(3 * UP)\n        self.play(Write(text))\n        self.play(Transform(text, eq1))\n        self.play(ApplyMethod(text.shift, 3 * UP))\n        self.play(Write(text2))\n        self.play(Write(eq2))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Present the title \"Gradient Descent\" followed by two gradient descent update rules and a definition of the learning rate."}, {"role": "assistant", "content": "from manim import *\n\nclass GradientDescent(Scene):\n\n    def construct(self):\n        g = TextMobject('Gradient Descent', color=YELLOW)\n        g1 = TextMobject('$\\\\Theta_0 = \\\\Theta_0 - \\\\alpha \\\\frac{\\\\partial}{\\\\partial \\\\Theta_0} J(\\\\Theta_0, \\\\Theta_1)$')\n        g2 = TextMobject('$\\\\Theta_1 = \\\\Theta_1 - \\\\alpha \\\\frac{\\\\partial}{\\\\partial \\\\Theta_1} J(\\\\Theta_0, \\\\Theta_1)$')\n        text = TextMobject('$\\\\alpha$ is the learning rate')\n        text.move_to(3 * DOWN)\n        g1.move_to(1 * UP)\n        g2.move_to(1 * DOWN)\n        g1.scale(2)\n        g2.scale(2)\n        g.scale(2.5)\n        self.play(Write(g))\n        self.play(ApplyMethod(g.shift, 3.5 * UP))\n        self.play(Write(g1))\n        self.play(Write(g2))\n        self.play(Write(text))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Show that estimators and variance are linear by displaying a general statement and two specific mathematical properties."}, {"role": "assistant", "content": "from manim import *\n\nclass Linear(Scene):\n\n    def construct(self):\n        g = TextMobject('Estimator and Variance are Linear', color=GREEN)\n        g1 = TextMobject('$V(x+y)=V(x) + V(y)$')\n        g2 = TextMobject('$V(\\\\alpha x) = \\\\alpha V(x)$')\n        g1.move_to(1 * UP)\n        g2.move_to(1 * DOWN)\n        g1.scale(2)\n        g2.scale(2)\n        g.scale(1.5)\n        self.play(Write(g))\n        self.play(ApplyMethod(g.shift, 3.5 * UP))\n        self.play(Write(g1))\n        self.play(Write(g2))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display two vectors, project one onto the other, and then animate the transformation of both vectors to represent the result."}, {"role": "assistant", "content": "from manim import *\n\nclass InnerProduct(Scene):\n    CONFIG = {'plane_kwargs': {'color': RED_B}, 'point_charge_loc': 0.5 * RIGHT - 1.5 * UP}\n\n    def construct(self):\n        plane = NumberPlane(**self.plane_kwargs)\n        plane.main_lines.fade(0.9)\n        plane.add(plane.get_axis_labels())\n        self.add(plane)\n        vector = Vector(1 * UP + 3 * RIGHT, color=RED)\n        vector2 = Vector(2 * UP + 1 * RIGHT, color=BLUE)\n        projected = Vector(1.73768398521 * RIGHT + 0.57922769775 * UP, color=GREEN)\n        full_projected = Vector(4.73768398521 * RIGHT + 1.57922769775 * UP, color=BLUE)\n        self.wait(0.25)\n        self.play(ShowCreation(vector))\n        self.play(ShowCreation(vector2))\n        self.wait(2)\n        self.play(Transform(vector2, projected))\n        self.play(ApplyMethod(vector2.shift, 1 * UP, 3 * RIGHT))\n        self.wait(2)\n        self.play(Transform(vector2, full_projected), Transform(vector, full_projected))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Present the definition of an inner product and its properties using text and braces."}, {"role": "assistant", "content": "from manim import *\n\nclass InnerProperties(Scene):\n\n    def construct(self):\n        g = TextMobject('Inner Product = $<x, y>$', color=BLUE)\n        g1 = TextMobject('$<x, y> = \\\\overline{<y, x>}$').scale(1.5)\n        g2 = TextMobject('$<x+y, y> = <x, y> + <y, y>$').scale(1.5)\n        g3 = TextMobject('$<\\\\alpha x, y> = \\\\alpha<x,y>$').scale(1.5)\n        g4 = TextMobject('$<x, x> \\\\geq 0$').scale(1.5)\n        g5 = TextMobject('$<x, x> = 0 \\\\Longleftrightarrow x = 0$').scale(1.5)\n        g1.move_to(2.5 * UP)\n        g2.move_to(1.25 * UP + 1.5 * RIGHT)\n        g3.move_to(1.5 * RIGHT)\n        g4.move_to(1.25 * DOWN + 2 * RIGHT)\n        g5.move_to(2.5 * DOWN + 2 * RIGHT)\n        g.scale(1.5)\n        b1 = Brace(VGroup(g2, g3), LEFT)\n        b2 = Brace(VGroup(g4, g5), LEFT)\n        t1 = b1.get_text('Linearity')\n        t2 = b2.get_text('Positive-definiteness')\n        self.play(Write(g))\n        self.play(ApplyMethod(g.shift, 3.5 * UP))\n        self.play(Write(g1))\n        self.play(Write(b1), Write(g2), Write(g3), Write(t1))\n        self.play(Write(b2), Write(g4), Write(g5), Write(t2))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display the text \"Thanks for Watching\" and hold it on screen for ten seconds."}, {"role": "assistant", "content": "from manim import *\n\nclass Outro(Scene):\n\n    def construct(self):\n        text = TextMobject('Thanks for Watching').scale(2)\n        text.move_to(3 * UP)\n        self.play(Write(text))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Create an empty Manim scene named Intro."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport time\n\nclass Intro(Scene):\n\n    def construct(self):\n        pass"}]}
{"messages": [{"role": "user", "content": "Display Maxwell's equations, separated into differential and integral forms, with a title and dividing line."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport time\n\nclass Equations(Scene):\n\n    def construct(self):\n        title = TextMobject(\"Maxwell's Equations\", color=BLUE)\n        title.scale(1.25)\n        title.shift(3.5 * UP)\n        l = Line(6 * LEFT, 6 * RIGHT, stroke_width=0.5 * DEFAULT_STROKE_WIDTH).shift(3 * UP)\n        self.play(Write(title), Write(l))\n        self.wait()\n        l2 = Line(4 * DOWN, 3 * UP, stroke_widt=0.5 * DEFAULT_STROKE_WIDTH)\n        c_color = GOLD\n        color_map = {'\\\\phi': ORANGE, '\\\\nabla': RED, '\\\\textbf{B}': M_COLOR, '\\\\textbf{E}': E_COLOR, '\\\\cdot': GREEN, '\\\\cross': GREEN, '\\\\textbf{J}': PURPLE, '\\\\textbf{I}': PURPLE, '\\\\mu_0': c_color, '\\\\epsilon_0': c_color, '\\\\frac{1}{c^2}': MAROON}\n        eq1 = TexMobject('\\\\nabla \\\\cdot \\\\textbf{E} = \\\\frac{\\\\rho}{\\\\epsilon_0}', tex_to_color_map=color_map)\n        eq2 = TexMobject('\\\\nabla \\\\cdot \\\\textbf{B} = 0', tex_to_color_map=color_map)\n        eq3 = TexMobject('\\\\nabla \\\\cross \\\\textbf{E} = - {{\\\\partial \\\\textbf{B}} \\\\over {\\\\partial t}}', tex_to_color_map=color_map)\n        eq4 = TexMobject('\\\\nabla \\\\cross \\\\textbf{B} = \\\\mu_0 \\\\textbf{J} + \\\\frac{1}{c^2} {{\\\\partial \\\\textbf{E} } \\\\over {\\\\partial t}}', tex_to_color_map=color_map)\n        i1 = TexMobject('\\\\oint \\\\textbf{E} \\\\cdot d \\\\vec{S} = \\\\frac{Q}{\\\\epsilon_0}', tex_to_color_map=color_map)\n        i2 = TexMobject('\\\\oint \\\\textbf{B} \\\\cdot d \\\\vec{S} = 0', tex_to_color_map=color_map)\n        i3 = TexMobject('\\\\oint \\\\textbf{E} \\\\cdot d \\\\vec{l} = -{{d \\\\phi_{\\\\textbf{B}}} \\\\over {dt}}', tex_to_color_map=color_map)\n        i4 = TexMobject('\\\\oint \\\\textbf{B} \\\\cdot d \\\\vec{l} = \\\\mu_0 \\\\textbf{I} + \\\\frac{1}{c^2} {{d \\\\phi_{\\\\textbf{E}}} \\\\over {dt}}', tex_to_color_map=color_map)\n        eq1.shift(2 * UP)\n        eq2.shift(0.5 * UP)\n        eq3.shift(1 * DOWN)\n        eq4.shift(2.5 * DOWN)\n        i1.shift(2 * UP)\n        i2.shift(0.5 * UP)\n        i3.shift(1 * DOWN)\n        i4.shift(2.5 * DOWN)\n        diff = VGroup(eq1, eq2, eq3, eq4)\n        integ = VGroup(i1, i2, i3, i4)\n        diff.shift(3.5 * LEFT)\n        integ.shift(3.5 * RIGHT)\n        self.play(Write(l2))\n        self.play(FadeInFromDown(diff), FadeInFromDown(integ))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate an electromagnetic wave in a 3D space, showing its progression over time."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport time\n\nclass EMTest(ThreeDScene):\n\n    def construct(self):\n        wave = EMWave()\n        self.add(wave)\n        self.move_camera(0.4 * np.pi / 2, -PI / 2)\n        self.play(wave.tracker.increment_value, 4 * PI, run_time=4, rate_func=linear)"}]}
{"messages": [{"role": "user", "content": "Animate a three-dimensional representation of alternating current with charges moving to form a wave."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport time\n\nclass ACWave(ThreeDScene):\n\n    def construct(self):\n        self.pos = VGroup()\n        self.neg = VGroup()\n        self.update = False\n        shift = 6 * LEFT\n        for i in range(1, 4):\n            charge = Charge()\n            charge.shift(i * UP + 0.5 * RIGHT)\n            self.pos.add(charge)\n            charge = Charge(sign='-', color=BLUE, fill_color=BLUE)\n            charge.shift(i * DOWN + 0.5 * RIGHT)\n            self.neg.add(charge)\n        gen = VGroup()\n        rect = Rectangle(height=1, width=1, color=GREEN)\n        rect2 = Rectangle(height=0.35, width=0.75, color=RED)\n        gen.add(rect)\n        gen.add(rect2)\n        gen.add(TextMobject('120V').scale(0.5))\n        gen.add(Line(0.5 * UP, 3 * UP))\n        gen.add(Line(0.5 * DOWN, 3 * DOWN))\n        gen.shift(shift)\n        self.neg.shift(shift)\n        self.pos.shift(shift)\n        self.neg2 = self.neg.copy()\n        self.neg2.shift(4 * UP)\n        self.pos2 = self.pos.copy()\n        self.pos2.shift(4 * DOWN)\n        self.neg3 = self.neg.copy()\n        self.pos3 = self.pos.copy()\n        self.play(Write(gen))\n        self.play(Write(self.pos), Write(self.neg))\n        wave = EMWave(frequency=1 / 3)\n        self.add(wave)\n        self.move_camera(0.4 * np.pi / 2, -PI / 2)\n        for i in range(3):\n            self._update()\n\n    def continual_update(self, *args, **kwargs):\n        Scene.continual_update(self, *args, **kwargs)\n        if self.update:\n            pass\n\n    def _update(self):\n        self.play(Transform(self.pos, self.neg2), Transform(self.neg, self.pos2))\n        self.wait(0.5)\n        self.play(Transform(self.pos, self.pos3), Transform(self.neg, self.neg3))\n        self.wait(0.5)"}]}
{"messages": [{"role": "user", "content": "Introduce the concept of line integrals by displaying its name, then showing three different mathematical representations sequentially before listing its applications."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        li = TextMobject('Line Integral', color=BLUE)\n        li.scale(2)\n        int2 = TexMobject('\\\\int_C\\\\overrightarrow{\\\\textbf{F}} \\\\bullet \\\\textbf{d} \\\\overrightarrow{\\\\textbf{r}}')\n        int2.scale(1.5)\n        int1 = TexMobject('\\\\int_C f(x,y) ds')\n        int1.scale(1.5)\n        int3 = TexMobject('\\\\int_C \\\\textbf{P}dx + \\\\textbf{Q}dy')\n        int3.scale(1.5)\n        uses = BulletedList('Work', 'Center of mass', \"Faraday's Law\", \"Ampere's Law\", '...')\n        self.play(Write(li))\n        self.wait()\n        self.play(ApplyMethod(li.shift, 3 * UP))\n        self.play(Write(int1))\n        self.wait()\n        self.play(Transform(int1, int2))\n        self.wait()\n        self.play(Transform(int1, int3))\n        self.wait()\n        self.play(Uncreate(int1))\n        self.play(Write(uses))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Render a 3D scalar field with axes and then rotate the camera around it."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ScalarField(ThreeDScene):\n\n    def construct(self):\n        t_config = {'x_min': -1, 'x_max': 1, 'y_min': -1, 'y_max': 1, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        title = TextMobject('Scalar Fields', color=ORANGE)\n        title.scale(2)\n        axes = ThreeDAxes(**t_config)\n        func = ParametricSurface(self.func, resulution=(16, 24), u_min=-1, u_max=1, v_min=-1, v_max=1, fill_color=YELLOW, checkerboard_colors=[YELLOW, ORANGE])\n        func.scale(2)\n        axes.scale(2)\n        self.play(Write(title))\n        self.wait()\n        self.play(Uncreate(title))\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.play(ShowCreation(axes), ShowCreation(func))\n        self.begin_ambient_camera_rotation()\n        self.wait(30)\n\n    @staticmethod\n    def func(u, v):\n        return np.array([u, v, u ** 2 + v ** 2])"}]}
{"messages": [{"role": "user", "content": "Write the equation \"f(x,y) = x^2+y^2\" to the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Equation(Scene):\n\n    def construct(self):\n        eq = TexMobject('f(x,y) = x^2+y^2')\n        eq.scale(2)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the arc length of a parametric curve by showing the coordinate axes, the curve, and then illustrating the Pythagorean theorem with incremental deltas for x, y, and the arc length."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ArcLength(Scene):\n\n    def construct(self):\n        g_config = {'propagate_style_to_family': True, 'three_d': False, 'number_line_config': {'color': LIGHT_GREY, 'include_tip': True}, 'x_axis_config': {}, 'y_axis_config': {'label_direction': LEFT}, 'x_min': 0, 'x_max': 2, 'y_min': 0, 'y_max': 2, 'default_num_graph_points': 100}\n        curve = ParametricFunction(self.func, t_min=0, t_max=2, color=BLUE)\n        axes = Axes(**g_config)\n        heading = TextMobject('Arc Length', color=YELLOW)\n        heading.scale(2)\n        text = TexMobject('\\\\langle x(t), y(t) \\\\rangle')\n        text.shift(2.5 * RIGHT + 2 * UP)\n        text.scale(0.5)\n        func = VGroup(axes, curve, text)\n        func.scale(2)\n        func.move_to(ORIGIN)\n        t1 = Line(0.5 * LEFT + 1 * DOWN, 1 * DOWN + 1.25 * LEFT, color=GREEN)\n        t2 = Line(0.5 * LEFT + 1 * DOWN, 0.5 * LEFT + 3.25 * UP, color=RED)\n        t3 = Line(1 * DOWN + 1.25 * LEFT, 0.5 * LEFT + 3.25 * UP, color=YELLOW)\n        b1 = Brace(VGroup(t1), DOWN, color=GREEN)\n        dx = b1.get_tex('\\\\Delta x')\n        b2 = Brace(VGroup(t2), RIGHT, color=RED)\n        dy = b2.get_tex('\\\\Delta y')\n        b3 = Brace(VGroup(t3), np.array([-0.99388, 0.16, 0]))\n        d = b3.get_tex('\\\\Delta s')\n        self.play(Write(heading))\n        self.wait()\n        self.play(ApplyMethod(heading.shift, 3.5 * UP))\n        self.play(ShowCreation(func))\n        self.wait()\n        self.play(ApplyMethod(func.scale, 4), Uncreate(heading))\n        self.wait()\n        self.play(ShowCreation(t1), ShowCreation(t2))\n        self.wait()\n        self.play(ShowCreation(b1), ShowCreation(dx))\n        self.wait()\n        self.play(ShowCreation(b2), ShowCreation(dy))\n        self.wait()\n        self.play(ShowCreation(t3), ShowCreation(b3), ShowCreation(d))\n        self.wait()\n\n    @staticmethod\n    def func(t):\n        return np.array([t, np.sin(5 * t) * t + 1, 0])"}]}
{"messages": [{"role": "user", "content": "Derive the arc length formula step-by-step, showing each transformation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ArcExp(Scene):\n\n    def construct(self):\n        step1 = TexMobject('\\\\Delta s = \\\\sqrt{{\\\\Delta x}^2 + {\\\\Delta y}^2}}')\n        step1.scale(1.5)\n        step2 = TexMobject('\\\\sum_{i=1}^{n}{\\\\sqrt{{\\\\Delta x_i}^2 + {\\\\Delta y_i}^2}}}')\n        step2.scale(1.5)\n        step3 = TexMobject('\\\\lim_{n \\\\rightarrow \\\\infty} \\\\sum_{i=1}^{n}{\\\\sqrt{{\\\\Delta x_i}^2 + {\\\\Delta y_i}^2}}}')\n        step3.scale(1.5)\n        step4 = TexMobject('\\\\lim_{n \\\\rightarrow \\\\infty} \\\\sum_{i=1}^{n}{\\\\sqrt{(\\\\frac{\\\\Delta x_i}{\\\\Delta t})^2 +(\\\\frac{\\\\Delta y_i}{\\\\Delta t})^2} \\\\Delta t}}')\n        step4.scale(1.5)\n        step5 = TexMobject('\\\\int_a^b {\\\\sqrt{(\\\\frac{dx}{dt})^2 +(\\\\frac{dy}{dt})^2}dt}}')\n        step5.scale(1.5)\n        step6 = TexMobject('\\\\int_a^b ds')\n        step6.scale(1.5)\n        step6.shift(2 * DOWN)\n        equal = TexMobject('=')\n        equal.scale(1.5)\n        self.play(Write(step1))\n        self.wait()\n        self.play(Transform(step1, step2))\n        self.wait()\n        self.play(Transform(step1, step3))\n        self.wait()\n        self.play(Transform(step1, step4))\n        self.wait()\n        self.play(Transform(step1, step5))\n        self.wait()\n        self.play(ApplyMethod(step1.shift, 2 * UP), Write(step6), Write(equal))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a surface and a curve in 3D space, then show Riemann sums and transform the curve to its projection before finally transforming an integral formula."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LineIntegralScalar(ThreeDScene):\n\n    def construct(self):\n        t_config = {'x_min': -1, 'x_max': 1, 'y_min': -1, 'y_max': 1, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        integral = TexMobject('\\\\int_C f(x,y) ds')\n        integral.scale(2)\n        integral2 = TexMobject('\\\\int_C f(x,y) ds')\n        integral2.scale(2)\n        sol = TexMobject('\\\\int_a^b f(x(t), y(t)) \\\\sqrt{(\\\\frac{dx}{dt})^2+(\\\\frac{dy}{dt})^2}dt')\n        sol.scale(1.5)\n        surface = ParametricSurface(self.func, resulution=(16, 24), u_min=-1, u_max=1, v_min=-1, v_max=1, fill_color=RED, checkerboard_colors=[RED, ORANGE])\n        curve = ParametricFunction(self.c, t_min=-1, t_max=1)\n        curve_p = ParametricFunction(self.c_project, t_min=-1, t_max=1)\n        surface.scale(2)\n        axes = ThreeDAxes(**t_config)\n        axes.scale(2.5)\n        point1 = Point(self.c(-1))\n        point2 = Point(self.c(1))\n        text = TextMobject('C')\n        text.scale(1.5)\n        text.move_to(curve, 4 * RIGHT + 3 * DOWN)\n        area = self.get_riemann_sums(self.c_project, dx=0.005)\n        self.play(Write(integral))\n        self.play(ApplyMethod(integral.scale, 0.5))\n        self.play(ApplyMethod(integral.shift, 3 * UP))\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(surface))\n        self.play(ShowCreation(curve), Write(text))\n        self.play(Uncreate(integral), Uncreate(text))\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.begin_ambient_camera_rotation()\n        self.wait(6)\n        self.stop_ambient_camera_rotation()\n        self.move_camera(np.pi / 2, -np.pi / 2)\n        self.play(Transform(curve, curve_p), Uncreate(surface))\n        self.play(ShowCreation(area), ShowCreation(curve_p))\n        self.wait(3)\n        self.move_camera(0, -np.pi / 2)\n        self.play(Uncreate(axes), Uncreate(curve), Uncreate(area), Uncreate(curve_p))\n        self.play(Write(integral2))\n        self.wait()\n        self.play(Transform(integral2, sol))\n        self.wait(6)\n\n    @staticmethod\n    def func(x, y):\n        return np.array([x, y, 0.5 * (math.cos(5 * x) + math.sin(5 * y))])\n\n    def c(self, t):\n        return np.array([t, t ** 3, self.func(t, t ** 3)[-1]])\n\n    def c_project(self, t):\n        return np.array([t, 0, self.func(t, t ** 3)[-1]])\n\n    @staticmethod\n    def get_riemann_sums(func, dx=0.2, x=(-1, 1), color=RED):\n        rects = VGroup()\n        for i in np.arange(x[0], x[1], dx):\n            h = func(i)[-1]\n            rect = Rectangle(height=h, width=dx, color=color)\n            rect.shift(i * RIGHT + h / 2 * OUT)\n            rect.rotate(np.pi / 2, axis=X_AXIS)\n            rect.rotate(-np.pi / 2, axis=Z_AXIS)\n            rects.add(rect)\n        return rects"}]}
{"messages": [{"role": "user", "content": "Present a calculus problem about line integrals, show its parametric representation and intermediate steps, and finally reveal the answer."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Example(Scene):\n\n    def construct(self):\n        axes_config = {'x_min': 0, 'x_max': 3, 'y_min': -1, 'y_max': 6, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        axes = Axes(**axes_config)\n        curve = ParametricFunction(self.func, t_min=0, t_max=1, color=RED)\n        func = VGroup(axes, curve)\n        func.move_to(ORIGIN + 3 * LEFT)\n        func.scale(0.75)\n        question = TextMobject('Evaluate $\\\\int_C (3x^2 - 2y) ds$ \\\\\\\\where C is the line segment \\\\\\\\from $(3,6)$ to $(1,\u22121)$.')\n        question.scale(1.5)\n        step1 = TexMobject('C = \\\\langle 3 - 2t, 6-7t \\\\rangle \\\\ 0 \\\\leq t \\\\leq 1')\n        step1.move_to(2 * RIGHT + 1.5 * UP)\n        step1.scale(0.75)\n        step2 = TexMobject('\\\\frac{dx}{dt} = -2, \\\\frac{dy}{dt} = -7')\n        step2.move_to(2 * RIGHT + 0.5 * UP)\n        step2.scale(0.75)\n        step3 = TexMobject('ds = \\\\sqrt{(-2)^2 + (-7)^2} dt = \\\\sqrt{53} \\\\ dt')\n        step3.move_to(2 * RIGHT + 0.5 * DOWN)\n        step3.scale(0.75)\n        step4 = TexMobject('\\\\int_C (3x^2 - 2y) \\\\ ds')\n        step4.move_to(2 * RIGHT + 1.5 * DOWN)\n        step4.scale(0.75)\n        equal = TexMobject('=')\n        equal.move_to(2 * RIGHT + 2 * DOWN)\n        equal.scale(0.5)\n        step5 = TexMobject('\\\\int_0^1 (3(3 - 2t)^2 - 2(6 - 7t)^2) \\\\sqrt{53} \\\\ dt')\n        step5.move_to(2 * RIGHT + 3 * DOWN)\n        step5.scale(0.75)\n        ans = TexMobject('8 \\\\sqrt{53}')\n        ans.move_to(2 * RIGHT + 3 * DOWN)\n        self.play(Write(question))\n        self.wait()\n        self.play(ApplyMethod(question.scale, 0.5))\n        self.play(ApplyMethod(question.shift, 3 * UP + 2 * RIGHT))\n        self.wait()\n        self.play(ShowCreation(func))\n        self.wait()\n        self.play(Write(step1))\n        self.wait()\n        self.play(Write(step2))\n        self.wait()\n        self.play(Write(step3))\n        self.wait()\n        self.play(Write(step4))\n        self.play(Write(equal))\n        self.wait()\n        self.play(Write(step5))\n        self.wait()\n        self.play(Transform(step5, ans))\n        self.wait()\n\n    @staticmethod\n    def func(t):\n        return np.array([3 - 2 * t, 6 - 7 * t, 0])"}]}
{"messages": [{"role": "user", "content": "Visualize three different vector fields on a coordinate plane with their corresponding equations, transitioning between them."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass VectorField(Scene):\n    CONFIG = {'plane_kwargs': {'color': RED_B}, 'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        plane = NumberPlane(**self.plane_kwargs)\n        plane.main_lines.fade(0.9)\n        plane.add(plane.get_axis_labels())\n        f1 = lambda x, y: np.array([x, y])\n        f2 = lambda x, y: np.array([math.cos(x), math.sin(y)])\n        f3 = lambda x, y: np.array([y, x])\n        field = VGroup(*[self.calc_field(x * RIGHT + y * UP) for x in np.arange(-9, 9, 1) for y in np.arange(-5, 5, 1)])\n        field_color = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, f1) for x in np.arange(-9, 9, 1) for y in np.arange(-5, 5, 1)])\n        field2 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, f2, prop=0) for x in np.arange(-9, 9, 1) for y in np.arange(-5, 5, 1)])\n        field3 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, f3, prop=0) for x in np.arange(-9, 9, 1) for y in np.arange(-5, 5, 1)])\n        head = TextMobject('Vector Field', color=RED)\n        head.scale(2)\n        back = BackgroundRectangle(head, fill_opacity=1)\n        heading = VGroup(back, head)\n        eq = TexMobject('\\\\overrightarrow{\\\\textbf{F}}(x, y) = \\\\langle x, y \\\\rangle', color=WHITE)\n        eq.scale(2)\n        eq_back = BackgroundRectangle(eq, fill_opacity=1)\n        equation = VGroup(eq_back, eq)\n        equation.scale(0.75)\n        equation.shift(3 * DOWN)\n        eq2 = TexMobject('\\\\overrightarrow{\\\\textbf{F}}(x, y) = \\\\langle cos(x), sin(y) \\\\rangle', color=WHITE)\n        eq2.scale(2)\n        eq_back2 = BackgroundRectangle(eq2, fill_opacity=1)\n        equation2 = VGroup(eq_back2, eq2)\n        equation2.scale(0.75)\n        equation2.shift(3 * DOWN)\n        eq3 = TexMobject('\\\\overrightarrow{\\\\textbf{F}}(x, y) = \\\\langle y, x \\\\rangle', color=WHITE)\n        eq3.scale(2)\n        eq_back3 = BackgroundRectangle(eq3, fill_opacity=1)\n        equation3 = VGroup(eq_back3, eq3)\n        equation3.scale(0.75)\n        equation3.shift(3 * DOWN)\n        self.play(Write(heading))\n        self.wait()\n        self.play(ApplyMethod(heading.shift, 3 * UP))\n        self.wait()\n        self.bring_to_back(plane)\n        self.play(ShowCreation(plane))\n        self.bring_to_back(field)\n        self.play(ShowCreation(field))\n        self.wait()\n        self.play(Transform(field, field_color))\n        self.wait()\n        self.play(Write(equation))\n        self.wait()\n        self.play(Transform(equation, equation2), Transform(field, field2))\n        self.wait()\n        self.play(Transform(equation, equation3), Transform(field, field3))\n        self.wait()\n\n    def calc_field_color(self, point, f, prop=0.0):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        return Vector(func, color=c).shift(point)\n\n    @staticmethod\n    def calc_field(point):\n        x, y = point[:2]\n        func = np.array([x, y])\n        return Vector(func).shift(point)"}]}
{"messages": [{"role": "user", "content": "Illustrate the line integral of a vector field along a curve, showing the vector field, the curve, and the integral formula step-by-step."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LineIntegralVector(Scene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        axes_config = {'x_min': -5, 'x_max': 5, 'y_min': -5, 'y_max': 5, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        r_config = {'x_min': -3, 'x_max': 3, 'y_min': 0, 'y_max': 0.01, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        axes = Axes(**axes_config)\n        f = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, lambda x, y: np.array([y, x]), prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        f2 = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, lambda x, y: np.array([y, x]), prop=0, opacity=0.5) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        f2.scale(0.6)\n        f2.shift(1 * UP)\n        field = VGroup(axes, f)\n        field.scale(0.6)\n        eq = TexMobject('\\\\int_C\\\\overrightarrow{\\\\textbf{F}} \\\\bullet \\\\textbf{d} \\\\overrightarrow{\\\\textbf{r}}')\n        eq.scale(1.5)\n        eq_back = BackgroundRectangle(eq, fill_opacity=1)\n        integral = VGroup(eq_back, eq)\n        c = ParametricFunction(self.func, t_min=-3, t_max=3)\n        c.set_stroke(opacity=0.75)\n        label = TextMobject('C')\n        label.shift(2 * LEFT)\n        label.scale(2)\n        curve = VGroup(label, c)\n        curve.scale(0.6)\n        r_axes = Axes(**r_config)\n        c2 = ParametricFunction(self.line_evaluated, t_min=-3, t_max=3, color=RED)\n        func = VGroup(r_axes)\n        func.shift(3 * DOWN + 2 * LEFT)\n        c_o = 2.5 * DOWN + 3 * RIGHT\n        circle = Circle(color=WHITE)\n        circle.move_to(c_o)\n        v = self.r_prime(-3) * 0.6\n        v = Vector(v)\n        v.move_to(self.func(-3)[0] * 0.6 * RIGHT + (-3 * 0.6 + 1.29) * UP)\n        self.v2 = self.r_prime(-3) * 0.25\n        self.v2 = Vector(self.v2, color=RED)\n        self.v2.shift(c_o)\n        self.fr = self.f_r(-3) * 0.25\n        self.fr = Vector(self.fr, color=GREEN)\n        self.fr.shift(c_o)\n        label_fr = TexMobject('= \\\\overrightarrow{\\\\textbf{F}} ( \\\\overrightarrow{r} (t) )').scale(0.75)\n        label_r = TexMobject(\"= \\\\overrightarrow{r}'(t)\").scale(0.75)\n        arrow1 = Vector([0, 1], color=GREEN)\n        arrow2 = Vector([0, 1], color=RED)\n        arrow1.shift(2 * UP + 4 * RIGHT)\n        arrow2.shift(4 * RIGHT)\n        label_fr.move_to(arrow1)\n        label_fr.shift(1.25 * RIGHT)\n        label_r.move_to(arrow2)\n        label_r.shift(1 * RIGHT)\n        l1 = VGroup(arrow1, label_fr)\n        l2 = VGroup(arrow2, label_r)\n        dot = TexMobject(\"\\\\overrightarrow{\\\\textbf{F}} ( \\\\overrightarrow{r} (t) ) \\\\bullet \\\\overrightarrow{r}'(t)\")\n        dot.scale(0.75)\n        dot.shift(3.5 * DOWN)\n        r_label = TexMobject(\"\\\\overrightarrow{r}'(t)\")\n        r_label.move_to(v)\n        r_label.shift(1 * LEFT)\n        r = VGroup(r_label, v)\n        s1 = TexMobject('\\\\int_C \\\\overrightarrow{\\\\textbf{F}} \\\\bullet \\\\textbf{d} \\\\overrightarrow{r}')\n        s2 = TexMobject(\"\\\\int_a^b \\\\overrightarrow{\\\\textbf{F}} ( \\\\overrightarrow{r} (t) ) \\\\bullet \\\\overrightarrow{r}'(t)\")\n        self.f = VGroup()\n        self.a = VGroup()\n        self.play(Write(integral))\n        self.play(ApplyMethod(integral.scale, 0.5))\n        self.play(ApplyMethod(integral.shift, 3 * UP))\n        self.bring_to_back(field)\n        self.play(ShowCreation(field))\n        self.wait()\n        self.play(Write(curve))\n        self.wait()\n        self.play(Uncreate(integral), ApplyMethod(field.shift, 1 * UP), ApplyMethod(curve.shift, 1 * UP))\n        self.wait()\n        self.play(Transform(f, f2))\n        self.play(Write(r))\n        self.wait()\n        self.play(ShowCreation(func))\n        self.wait()\n        self.play(Write(circle), Write(self.v2), Write(self.fr), Write(l1), Write(l2))\n        self.wait()\n        self.play(Write(dot))\n        self.r = r\n        self.r_ = v\n        self.t = -3\n        self.always_continually_update = True\n        self.wait(10)\n        self.play(Uncreate(dot), Uncreate(self.v2), Uncreate(self.fr), Uncreate(l1), Uncreate(l2), Uncreate(func), Uncreate(r), Uncreate(field), Uncreate(curve), Uncreate(circle), Uncreate(self.f), Uncreate(self.a))\n        self.play(Write(s1))\n        self.wait()\n        self.play(Transform(s1, s2))\n        self.wait()\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n        return v\n\n    @staticmethod\n    def func(t):\n        return np.array([2 * np.arctan(t), t, 0])\n\n    def f_r(self, t):\n        r = self.func(t)\n        return np.array([r[1], r[0], 0])\n\n    @staticmethod\n    def line_evaluated(x):\n        r_derivative = np.array([2 / (1 + x ** 2), 1])\n        f_r = np.array([x, 2 * np.arctan(x)])\n        return np.array([x, 0.25 * np.dot(f_r, r_derivative), 0])\n\n    @staticmethod\n    def r_prime(x):\n        r_d = np.array([2 / (1 + x ** 2), 1, 0])\n        return r_d\n\n    def continual_update(self, *args, **kwargs):\n        Scene.continual_update(self, *args, **kwargs)\n        if hasattr(self, 'r'):\n            dt = self.frame_duration\n            t = self.t\n            d_point = (self.func(t + dt) - self.func(t)) * 0.6 * RIGHT + dt * 0.6 * UP\n            self.r.shift(d_point)\n            self.r_.put_start_and_end_on(self.r_.get_start(), self.r_prime(t) * 0.6 + self.r_.get_start())\n            self.fr.put_start_and_end_on(self.fr.get_start(), self.f_r(t) * 0.25 + self.fr.get_start())\n            self.v2.put_start_and_end_on(self.v2.get_start(), self.func(t) * 0.25 + self.v2.get_start())\n            l2 = Line((3 - self.line_evaluated(t)[1]) * DOWN + (2 - t) * LEFT, 3 * DOWN + (2 - t) * LEFT, color=YELLOW, stroke_width=dt)\n            self.a.add(l2)\n            self.add(l2)\n            l1 = Line((3 - self.line_evaluated(t)[1]) * DOWN + (2 - t) * LEFT, (3 - self.line_evaluated(t + dt)[1]) * DOWN + (2 - t - dt) * LEFT, color=RED, stroke_width=8)\n            self.f.add(l1)\n            self.add(l1)\n            if self.t >= 3:\n                del self.r\n            self.t = self.t + dt"}]}
{"messages": [{"role": "user", "content": "Visualize the steps of solving a line integral problem with a parametric curve and vector field."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass VectorExample(Scene):\n\n    def construct(self):\n        axes_config = {'x_min': 0, 'x_max': 3, 'y_min': 0, 'y_max': 6, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        axes = Axes(**axes_config)\n        curve = ParametricFunction(self.func, t_min=0, t_max=1, color=RED)\n        func = VGroup(axes, curve)\n        func.move_to(ORIGIN + 3 * LEFT)\n        func.scale(0.75)\n        question = TextMobject('Evaluate $\\\\int_C \\\\overrightarrow{\\\\textbf{F}} \\\\bullet \\\\textbf{d} \\\\overrightarrow{r}$ \\\\\\\\where C is the line segment \\\\\\\\from $(3,7)$ to $(0,12)$ and \\\\\\\\ $\\\\overrightarrow{\\\\textbf{F}}$= $\\\\langle y^2, 3x-6y \\\\rangle$.')\n        question.scale(1.5)\n        step1 = TexMobject('C = \\\\langle 3 - 3t, 7 + 5t \\\\rangle \\\\ 0 \\\\leq t \\\\leq 1')\n        step1.move_to(2 * RIGHT + 1.5 * UP)\n        step1.scale(0.75)\n        step2 = TexMobject('\\\\overrightarrow{\\\\textbf{F}} ( \\\\overrightarrow{r} (t) ) = \\\\langle (7 + 5t)^2, -33 -39t \\\\rangle')\n        step2.move_to(2 * RIGHT + 0.5 * UP)\n        step2.scale(0.75)\n        step3 = TexMobject(\"\\\\overrightarrow{r}'(t) = \\\\langle -3, 5 \\\\rangle\")\n        step3.move_to(2 * RIGHT + 0.5 * DOWN)\n        step3.scale(0.75)\n        step4 = TexMobject('\\\\int_C \\\\overrightarrow{\\\\textbf{F}} \\\\bullet \\\\textbf{d} \\\\overrightarrow{r}')\n        step4.move_to(2 * RIGHT + 1.5 * DOWN)\n        step4.scale(0.75)\n        step42 = TexMobject(\"\\\\int_0^1 \\\\overrightarrow{\\\\textbf{F}} ( \\\\overrightarrow{r} (t) )\\\\bullet \\\\overrightarrow{r}'(t)\")\n        step42.move_to(2 * RIGHT + 1.5 * DOWN)\n        step42.scale(0.75)\n        equal = TexMobject('=')\n        equal.move_to(2 * RIGHT + 2 * DOWN)\n        equal.scale(0.5)\n        step5 = TexMobject('\\\\int_0^1 \u22123(7+5t)^2\u22125(33+39t) \\\\ dt')\n        step5.move_to(2 * RIGHT + 3 * DOWN)\n        step5.scale(0.75)\n        ans = TexMobject('-539.5')\n        ans.move_to(2 * RIGHT + 3 * DOWN)\n        self.play(Write(question))\n        self.wait()\n        self.play(ApplyMethod(question.scale, 0.5))\n        self.play(ApplyMethod(question.shift, 3 * UP + 2 * RIGHT))\n        self.wait()\n        self.play(ShowCreation(func))\n        self.wait()\n        self.play(Write(step1))\n        self.wait()\n        self.play(Write(step2))\n        self.wait()\n        self.play(Write(step3))\n        self.wait()\n        self.play(Write(step4))\n        self.wait()\n        self.play(Transform(step4, step42))\n        self.wait()\n        self.play(Write(equal))\n        self.play(Write(step5))\n        self.wait()\n        self.play(Transform(step5, ans))\n        self.wait()\n\n    @staticmethod\n    def func(t):\n        return np.array([3 - 3 * t, 3.5 + 2.5 * t, 0])"}]}
{"messages": [{"role": "user", "content": "Display two screen rectangles side-by-side, each with a title above it indicating \"Scalar Field\" and \"Vector Field\"."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Ending(Scene):\n\n    def construct(self):\n        rect1 = ScreenRectangle(height=3)\n        rect2 = ScreenRectangle(height=3)\n        title1 = TextMobject('Scalar Field')\n        title2 = TextMobject('Vector Field')\n        title1.scale(1.5)\n        title2.scale(1.5)\n        rect1.shift(3 * LEFT)\n        rect2.shift(3 * RIGHT)\n        title1.shift(3 * LEFT + 3 * UP)\n        title2.shift(3 * RIGHT + 3 * UP)\n        self.play(Write(rect1), Write(rect2), Write(title1), Write(title2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display two positrons with accompanying text explaining the concept of work."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Charge(Scene):\n\n    def construct(self):\n        charge1 = Positron()\n        charge2 = Positron()\n        charge1.shift(2 * LEFT)\n        charge2.shift(2 * RIGHT)\n        work = TextMobject('Work = $\\\\int_C \\\\overrightarrow{\\\\textbf{F}} \\\\bullet \\\\textbf{d}\\\\overrightarrow{\\\\textbf{r}}$')\n        work.shift(2 * UP)\n        self.play(Write(charge1), Write(charge2))\n        self.play(Write(work))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render the Mandelbrot set on a complex plane."}, {"role": "assistant", "content": "from manimlib import *\n\nclass MandelbrotTest(Scene):\n\n    def construct(self):\n        c = ComplexPlane()\n        t = MandelbrotSet(c)\n        self.add(t)\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Render a Mandelbrot set, gradually increasing its detail over time."}, {"role": "assistant", "content": "from manimlib import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        c = ComplexPlane(x_range=(-3, 2), y_range=(-1, 1))\n        c.scale(4)\n        m = MandelbrotSet(c, opacity=0.75)\n        v = ValueTracker(1)\n\n        def m_updater(m, v=v, c=c):\n            m_ = MandelbrotSet(c, opacity=0.75, num_steps=v.get_value())\n            m.become(m_)\n        m.add_updater(m_updater)\n        self.add(c, m)\n        self.wait(1)\n        self.play(v.increment_value, 100, run_time=5)\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Generate an animation demonstrating the Mandelbrot set calculation with visual representations of complex number iterations and convergence."}, {"role": "assistant", "content": "from manimlib import *\n\nclass MandelbrotIntro(Scene):\n    CONFIG = {'color_map': {**{str(i): A_YELLOW for i in range(10)}, 'i': A_YELLOW, '-': A_YELLOW, '.': A_YELLOW, 'f': A_GREEN, 'z': A_PINK, '\\\\epsilon': A_LAVENDER}}\n\n    def construct(self):\n        c1 = ComplexPlane()\n        c1.add_coordinate_labels()\n        c1.remove(c1.coordinate_labels)\n        c2 = ComplexPlane()\n        c2.scale(3)\n        c2.add_coordinate_labels()\n        c2.remove(c2.coordinate_labels)\n        c3 = ComplexPlane()\n        c3.scale(3)\n        c3.shift(2.25 * LEFT)\n        c3.add_coordinate_labels()\n        self.play(Write(c1), Write(c1.coordinate_labels))\n        self.wait()\n        self.play(Uncreate(c1.coordinate_labels), Transform(c1, c2))\n        self.play(Write(c2.coordinate_labels))\n        c2.add(c2.coordinate_labels)\n        self.remove(c1)\n        self.add(c2)\n        rect = Polygon([0.77, FRAME_HEIGHT / 2, 0], [FRAME_WIDTH / 2, FRAME_HEIGHT / 2, 0], [FRAME_WIDTH / 2, -FRAME_HEIGHT / 2, 0], [0.77, -FRAME_HEIGHT / 2, 0], fill_opacity=1, stroke_width=0, fill_color=BLACK)\n        c = ComplexPlane(x_range=(-2, 1), y_range=(-2, 2))\n        c.scale(3)\n        c.shift(3.75 * LEFT)\n        c.add_coordinate_labels()\n        self.play(Transform(c2, c3))\n        self.play(FadeIn(rect))\n        m = MandelbrotSet(c, opacity=0.75, color_style=1)\n        l = Line(10 * UP, 10 * DOWN).shift(c.n2p(1))\n        self.play(Write(l))\n        self.play(FadeIn(m))\n        self.wait()\n        eq1 = Tex('f(z) = z^2 + c', tex_to_color_map={'2': A_YELLOW, 'f': A_GREEN, 'z': A_PINK, 'c': A_YELLOW})\n        eq2 = Tex('f(z) = z^2 + ', '(', '-1+i', ')', tex_to_color_map={'f': A_GREEN, 'z': A_PINK, '1': A_YELLOW, 'i': A_YELLOW, '2': A_YELLOW, '-': A_YELLOW})\n        eq2.scale(1.25)\n        eq1.scale(1.25)\n        eq1.move_to(3 * UP + 3.93 * RIGHT)\n        eq2.move_to(3 * UP + 3.93 * RIGHT)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Transform(eq1[:-1], eq2[:-6]), Uncreate(eq1[-1]))\n        self.play(Write(eq2[-6:]))\n        self.remove(eq1)\n        self.add(eq2)\n        self.wait()\n        vals = []\n        curr = 0\n        for _ in range(10):\n            vals.append(curr)\n            curr = (lambda z: z ** 2 + (-1 + 1j))(curr)\n        steps = VGroup()\n        for i in range(4):\n            eq = Tex('f(', c_to_str(vals[i]), ')', '=', c_to_str(vals[i + 1]), tex_to_color_map={**self.color_map, 'f': A_GREEN})\n            eq.scale(1.25)\n            eq.move_to(eq2, LEFT)\n            eq.shift((i + 1) * 1.25 * DOWN)\n            steps.add(eq)\n        d = [self.get_dot_grp(z, c) for z in vals[:6]]\n        self.play(Write(d[0]))\n        self.wait()\n        self.play(Write(steps[0]))\n        self.play(TransformFromCopy(steps[0][-5:], d[1][1]))\n        self.play(Transform(d[0][0], d[1][0]), Uncreate(d[0][1]))\n        self.wait()\n        for i in range(3):\n            self.play(TransformFromCopy(steps[i][-5:], steps[i + 1][2:7]), Write(steps[i + 1][:2]), Write(steps[i + 1][7]))\n            self.play(Write(steps[i + 1][8:]))\n            self.play(TransformFromCopy(steps[i + 1][-5:], d[i + 2][1]))\n            if i < 2:\n                self.play(Transform(d[0][0], d[i + 2][0]), Uncreate(d[i + 1][1]))\n                self.wait()\n        vdots = Tex('\\\\vdots').scale(1.25)\n        vdots.move_to(steps[-1])\n        vdots.shift(1.25 * DOWN)\n        self.play(Write(vdots))\n        self.wait()\n        eq3 = Tex('f(z) = z^2 + ', '(', '-0.25+0.25i', ')', tex_to_color_map={'f': A_GREEN, 'z': A_PINK, '0.25': A_YELLOW, 'i': A_YELLOW, '2': A_YELLOW, '-': A_YELLOW})\n        eq3.move_to(eq2)\n        self.play(FadeOut(VGroup(steps, vdots), DOWN))\n        self.play(TransformMatchingTex(eq2, eq3))\n        self.wait()\n        mandel1 = self.get_mandel_lines(-0.25 + 0.25j, c)\n        steps2 = VGroup()\n        curr, prev = (-0.25 + 0.25j, 0)\n        for i in range(5):\n            eq = Tex('f(', c_to_str(prev, conv=lambda x: f'{x:.2f}'), ')', '=', c_to_str(curr, conv=lambda x: f'{x:.2f}'), tex_to_color_map={**self.color_map, 'f': A_GREEN})\n            eq.scale(0.85)\n            eq.move_to(eq3, LEFT)\n            eq.shift((i + 1) * 1 * DOWN)\n            steps2.add(eq)\n            curr, prev = ((lambda z: z ** 2 + (-0.25 + 0.25j))(curr), curr)\n        vdots = Tex('\\\\vdots').scale(1.25)\n        vdots.move_to(steps2[4]).shift(1.1 * DOWN)\n        self.play(TransformFromCopy(eq3, mandel1))\n        for i in steps2:\n            self.play(FadeIn(i, DOWN))\n        self.play(Write(vdots))\n        self.wait()\n        self.play(Uncreate(mandel1), FadeOut(steps2, UP), FadeOut(vdots, UP))\n        d = self.get_dot_grp(-0.75, c, conv=lambda s: f'{s:.2f}', color=A_RED)\n        eq4 = Tex('f(z) = z^2 + (-0.75)', tex_to_color_map=self.color_map)\n        eq4.move_to(eq3, LEFT)\n        self.play(Write(d))\n        self.play(FocusOn(d))\n        self.play(Uncreate(eq3[8:]), Write(eq4[-1]))\n        self.play(TransformFromCopy(d[1], eq4[7:12]))\n        self.remove(self.mobjects[-1], eq3)\n        self.add(eq4)\n        self.play(eq4.move_to, 3 * UP + 3.93 * RIGHT)\n        self.wait()\n        v = ValueTracker(0)\n\n        def dot_updater(d):\n            d_ = self.get_dot_grp(-0.75 + v.get_value() * 1j, c, conv=lambda s: f'{s:.2f}', color=A_RED)\n            d.become(d_)\n\n        def m_updater(m):\n            m_ = self.get_mandel_lines(-0.75 + v.get_value() * 1j, c)\n            m.become(m_)\n            self.bring_to_front(d)\n        m1 = self.get_mandel_lines(-0.75, c)\n        m1.add_updater(m_updater)\n        d.add_updater(dot_updater)\n        self.play(Write(m1))\n        self.play(v.increment_value, 1, run_time=7.5)\n        self.wait()\n        h1 = Tex('\\\\epsilon', color=A_LAVENDER)\n        h1.scale(1.5)\n        h1.move_to(2.34 * RIGHT + 1.75 * UP)\n        h_eq = Tex('f(z) = z^2 + (-0.75 + \\\\epsilon i)', tex_to_color_map=self.color_map)\n        h_text = Text('# of steps till\\n\\nreaches a magnitude of 2')\n        h2 = VGroup(h_text, h_eq)\n        h2.scale(0.5)\n        h2.move_to(5.52 * RIGHT + 1.75 * UP)\n        l1 = Line(2.25 * UP, 5 * DOWN).shift(3.93 * RIGHT)\n        l2 = Line(0.75 * RIGHT, 7 * RIGHT).shift(1.25 * UP)\n        self.play(Write(l1), Write(l2))\n        self.play(Write(h1), Write(h2))\n        num_steps = ['3', '33', '315', '3143', '31417', '314160', '3141593', '31415928']\n        epsilon = ['1.0', *[f\"0.{'0' * i}1\" for i in range(9)]]\n        tab = VGroup()\n        for i in range(8):\n            t1 = Tex(epsilon[i]).move_to(h1).scale(0.75).shift(0.65 * (i + 1) * DOWN)\n            t2 = Tex(num_steps[i]).move_to(h2).scale(0.75).shift(0.65 * (i + 1) * DOWN)\n            tab.add(t1, t2)\n        tab.shift(0.2 * DOWN)\n        for i in range(2):\n            t_temp = Tex(epsilon[i], color=A_YELLOW).move_to(d[1][-5:-1])\n            self.add(t_temp)\n            self.play(Transform(t_temp, tab[2 * i]))\n            self.play(TransformFromCopy(m1[0], tab[2 * i + 1]))\n            self.play(v.set_value, 1 / 10 ** (i + 1))\n        t_temp = Tex(epsilon[2], color=A_YELLOW).move_to(d[1][-5:-1])\n        self.add(t_temp)\n        self.play(Transform(t_temp, tab[2 * 2]))\n        self.play(TransformFromCopy(m1[0], tab[2 * 2 + 1]))\n        for i in range(3, 8):\n            self.play(FadeIn(tab[2 * i], DOWN), FadeIn(tab[2 * i + 1], DOWN))\n        self.wait()\n        self.embed()\n\n    def get_dot_grp(self, z, c, conv=int, c_str_func=c_to_str, color=A_ORANGE, tex_to_color_map=None, radius=0.1):\n        if tex_to_color_map is None:\n            tex_to_color_map = self.color_map\n        d_ = Dot(c.n2p(z), color=color, radius=radius)\n        return VGroup(d_, Tex(c_str_func(z, conv), tex_to_color_map=tex_to_color_map).next_to(d_, DOWN).add_background_rectangle(buff=0.075))\n\n    def get_mandel_lines(self, point, c, steps=15, max_arg=10000):\n        curr, prev = (point, 0)\n        grp = VGroup()\n        for i in range(steps):\n            grp.add_to_back(Line(c.n2p(curr), c.n2p(prev), stroke_opacity=0.5))\n            grp.add(Dot(c.n2p(prev), color=A_ORANGE))\n            if abs(curr) < max_arg:\n                curr, prev = ((lambda z: z ** 2 + point)(curr), curr)\n            else:\n                break\n        return grp"}]}
{"messages": [{"role": "user", "content": "Animate two names appearing on screen, with the first name transforming into the second."}, {"role": "assistant", "content": "from manimlib import *\n\nclass TitleA(Scene):\n\n    def construct(self):\n        brect = Rectangle(height=FRAME_HEIGHT, width=FRAME_WIDTH, fill_opacity=1, color=GREY)\n        title1 = TexText('Dave Boll')\n        title1.scale(1.5)\n        title1.to_edge(UP)\n        title2 = TexText('Aaron Klebanoff')\n        title2.scale(1.5)\n        title2.to_edge(UP)\n        rect = ScreenRectangle(height=6)\n        rect.next_to(title1, DOWN)\n        self.add(brect)\n        self.play(FadeIn(rect, DOWN), Write(title1), run_time=2)\n        self.wait()\n        self.play(Transform(title1, title2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate an animation of the Mandelbrot set with a scaled complex plane and an arrow pointing towards the origin."}, {"role": "assistant", "content": "from manimlib import *\n\nclass Thumb(Scene):\n\n    def construct(self):\n        c = ComplexPlane()\n        c.scale(3)\n        c.shift(LEFT)\n        m = MandelbrotSet(c, color_style=1)\n        a = Arrow(3 * RIGHT, ORIGIN, stroke_width=16, stroke_color=A_RED)\n        self.add(m)\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Draw a linear equation on a set of axes."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LinEQ(Scene):\n\n    def construct(self):\n        axes = Axes(x_min=-3, x_max=3, y_min=-3, y_max=3, number_line_config={'include_tip': False})\n        f = FunctionGraph(lambda x: 0.5 * x + 1, x_min=-3, x_max=3)\n        func = VGroup(axes, f)\n        self.play(Write(func))"}]}
{"messages": [{"role": "user", "content": "Display a logo loaded from an SVG file."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        logo = SVGMobject('files/logo_t.svg')\n        self.play(Write(logo))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a 3D representation of an electric field with a series of lines and an arrow, then transform the lines to indicate a process of analysis."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ElectricField(ThreeDScene):\n\n    def construct(self):\n        OPACITY = 0.1\n        line0 = Line(3 * DOWN + 0.5 * LEFT, 2 * DOWN + 0.5 * LEFT, stroke_width=8)\n        line1 = Line(2 * DOWN + 0.5 * LEFT, 2 * DOWN + 2 * LEFT, stroke_width=8)\n        line3 = Line(2 * UP + 2 * LEFT, 2 * UP + 2 * RIGHT, stroke_width=8)\n        line4 = Line(2 * UP + 2 * RIGHT, 2 * DOWN + 2 * RIGHT, stroke_width=8)\n        line2 = Line(2 * DOWN + 2 * LEFT, 2 * UP + 2 * LEFT, stroke_width=8)\n        line5 = Line(2 * DOWN + 2 * RIGHT, 2 * DOWN + 0.5 * RIGHT, stroke_width=8)\n        line6 = Line(2 * DOWN + 0.5 * RIGHT, 3 * DOWN + 0.5 * RIGHT, stroke_width=8)\n        line02 = Line(3 * DOWN + 0.5 * LEFT, 2 * DOWN + 0.5 * LEFT, stroke_width=8)\n        line12 = Line(2 * DOWN + 0.5 * LEFT, 2 * DOWN + 2 * LEFT, stroke_width=8)\n        line32 = Line(2 * UP + 2 * LEFT, 2 * UP + 2 * RIGHT, stroke_width=8)\n        line42 = Line(2 * UP + 2 * RIGHT, 2 * DOWN + 2 * RIGHT, stroke_width=8)\n        line22 = Line(2 * DOWN + 2 * LEFT, 2 * UP + 2 * LEFT, stroke_width=8)\n        line52 = Line(2 * DOWN + 2 * RIGHT, 2 * DOWN + 0.5 * RIGHT, stroke_width=8)\n        line62 = Line(2 * DOWN + 0.5 * RIGHT, 3 * DOWN + 0.5 * RIGHT, stroke_width=8)\n        line00 = Line(3 * DOWN + 0.5 * LEFT, 2 * DOWN + 0.5 * LEFT, stroke_opacity=OPACITY)\n        line10 = Line(2 * DOWN + 0.5 * LEFT, 2 * DOWN + 2 * LEFT, stroke_opacity=OPACITY)\n        line30 = Line(2 * UP + 2 * LEFT, 2 * UP + 2 * RIGHT, stroke_opacity=OPACITY)\n        line40 = Line(2 * UP + 2 * RIGHT, 2 * DOWN + 2 * RIGHT, stroke_opacity=OPACITY)\n        line20 = Line(2 * DOWN + 2 * LEFT, 2 * UP + 2 * LEFT, stroke_opacity=OPACITY)\n        line50 = Line(2 * DOWN + 2 * RIGHT, 2 * DOWN + 0.5 * RIGHT, stroke_opacity=OPACITY)\n        line60 = Line(2 * DOWN + 0.5 * RIGHT, 3 * DOWN + 0.5 * RIGHT, stroke_opacity=OPACITY)\n        arrow = Arrow(ORIGIN, 1 * UP, color=RED)\n        arrow.move_to(line2, 1 * LEFT)\n        circle = Circle()\n        circle.rotate(np.pi / 4, axis=X_AXIS)\n        circle.shift(2 * LEFT)\n        head = TextMobject('Isolate segment 1', color=BLUE)\n        head.scale(1.25)\n        head.shift(3 * UP)\n        head3 = TextMobject('Do the same for every other segment', color=BLUE)\n        head3.scale(1.25)\n        head3.shift(3 * UP)\n        head2 = TextMobject('Find the direction of magnetic field at A, B, C, D\\\\\\\\only using this current', color=GREEN)\n        head2.scale(1.25)\n        head2.shift(3 * DOWN)\n        self.play(Write(line0))\n        self.play(Write(line1))\n        self.play(Write(line2))\n        self.play(Write(line3))\n        self.play(Write(line4))\n        self.play(Write(line5))\n        self.play(Write(line6))\n        self.wait()\n        self.play(Write(arrow))\n        self.play(Write(circle))\n        self.wait()\n        self.play(Write(head))\n        self.play(Transform(line0, line00), Transform(line1, line10), Transform(line3, line30), Transform(line4, line40), Transform(line5, line50), Transform(line6, line60))\n        self.wait()\n        self.play(Write(head2))\n        self.wait()\n        self.play(Transform(head, head3))\n        self.wait()\n        self.play(Transform(line0, line00), Transform(line1, line10), Transform(line2, line20), Transform(line3, line32), Transform(line4, line40), Transform(line5, line50), Transform(line6, line60))\n        self.wait()\n        self.play(Transform(line0, line00), Transform(line1, line10), Transform(line2, line20), Transform(line3, line30), Transform(line4, line42), Transform(line5, line50), Transform(line6, line60))\n        self.wait()\n        self.play(Transform(line0, line00), Transform(line1, line10), Transform(line2, line20), Transform(line3, line30), Transform(line4, line40), Transform(line5, line52), Transform(line6, line60))\n        self.wait()\n        self.play(Transform(line0, line00), Transform(line1, line10), Transform(line2, line20), Transform(line3, line30), Transform(line4, line40), Transform(line5, line50), Transform(line6, line62))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate two sine waves transforming back and forth between a positive and negative sine function."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Test(Scene):\n\n    def construct(self):\n        sin1 = ParametricFunction(lambda t: np.array([t, np.sin(t), 0]), t_min=0, t_max=6 * PI, color=GREEN)\n        sin1.shift(7 * LEFT)\n        sin2 = ParametricFunction(lambda t: np.array([t, -np.sin(t), 0]), t_min=0, t_max=6 * PI, color=GREEN)\n        sin2.shift(7 * LEFT)\n        sin11 = ParametricFunction(lambda t: np.array([t, np.sin(t), 0]), t_min=0, t_max=6 * PI, color=GREEN)\n        sin11.shift(7 * LEFT)\n        self.play(Write(sin1))\n        for i in range(5):\n            self.play(Transform(sin1, sin2))\n            self.play(Transform(sin1, sin11))"}]}
{"messages": [{"role": "user", "content": "Visualize a vector field and a parametric curve representing multivariable calculus."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass BannerE(Scene):\n    CONFIG = {'color_list': ['#e22b2b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        axes_config = {'x_min': -5, 'x_max': 5, 'y_min': -5, 'y_max': 5, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        axes = Axes(**axes_config)\n        f = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, lambda x, y: np.array([y, x]), prop=0) for x in np.arange(-5, 6, 1) for y in np.arange(-5, 6, 1)])\n        field = VGroup(axes, f)\n        c = ParametricFunction(self.func, t_min=-3, t_max=3)\n        c.set_stroke(opacity=0.75)\n        label = TextMobject('C')\n        label.shift(2 * LEFT)\n        label.scale(2)\n        curve = VGroup(c)\n        everything = VGroup(field, curve)\n        everything.scale(0.7)\n        text = TextMobject('Multivariable Calculus')\n        text.scale(2.5)\n        rect = BackgroundRectangle(text, buff=MED_LARGE_BUFF, color=BLACK, fill_opacity=1, stroke_opacity=1)\n        t = VGroup(rect, text)\n        self.play(Write(everything))\n        self.wait()\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.5\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c, stroke_width=30).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n        return v\n\n    @staticmethod\n    def func(t):\n        return np.array([2 * np.arctan(t), t, 0])\n\n        def f_r(self, t):\n            r = self.func(t)\n        return np.array([r[1], r[0], 0])\n\n    @staticmethod\n    def line_evaluated(x):\n        r_derivative = np.array([2 / (1 + x ** 2), 1])\n        f_r = np.array([x, 2 * np.arctan(x)])\n        return np.array([x, 0.25 * np.dot(f_r, r_derivative), 0])\n\n    @staticmethod\n    def r_prime(x):\n        r_d = np.array([2 / (1 + x ** 2), 1, 0])\n        return r_d"}]}
{"messages": [{"role": "user", "content": "Display the words \"Animated\" and \"Math and CS\" on the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TypeT(Scene):\n\n    def construct(self):\n        text1 = TextMobject('Animated').scale(3).shift(0.75 * UP)\n        text2 = TextMobject('Math and CS').scale(1.5).shift(0.75 * DOWN)\n        self.play(Write(text1), Write(text2))"}]}
{"messages": [{"role": "user", "content": "Display the sigmoid equation and hold it for ten seconds."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SigmoidEq(Scene):\n\n    def construct(self):\n        text = TexMobject('\\\\sigma (x) = \\\\frac{1}{1 + e^{-x}}', tex_to_color_map={'Mean Squared Error': YELLOW})\n        text.scale(4)\n        self.play(Write(text))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Show a \"Thanks for Watching\" message along with social media icons and usernames."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Outro(Scene):\n    CONFIG = {'s': 0.5}\n\n    def construct(self):\n        text = TextMobject('Thanks for Watching').scale(2)\n        ghub = ImageMobject('img/github.png')\n        ghub.shift(5 * LEFT + 2.5 * DOWN)\n        ghub.scale(self.s)\n        ghub_text = TextMobject('/vivek3141')\n        ghub_text.shift(3 * LEFT + 2.5 * DOWN)\n        insta = ImageMobject('img/instagram.png')\n        insta.shift(1 * RIGHT + 2.5 * DOWN)\n        insta.scale(self.s)\n        twitter = ImageMobject('img/twitter.png')\n        twitter.shift(2.5 * RIGHT + 2.5 * DOWN)\n        twitter.scale(self.s)\n        text2 = TextMobject('/vcubingx')\n        text2.shift(2.5 * DOWN + 4.5 * RIGHT)\n        text.move_to(3 * UP)\n        self.play(Write(text), ShowCreation(ghub), ShowCreation(twitter), ShowCreation(insta), Write(ghub_text), Write(text2))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Animate a red circle fading out over four seconds using an update function."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass UpdateOpacity(Scene):\n\n    def construct(self):\n        circle = Circle(color=RED, fill_opacity=1, radius=2)\n        self.play(Write(circle))\n        self.play(UpdateFromAlphaFunc(circle, self.update), rate_func=smooth, run_time=4)\n\n        def update(self, circle, dt):\n            opacity = interpolate(1, 0, dt)\n        new_circ = Circle(color=RED, fill_opacity=opacity, radius=2)\n        circle.become(new_circ)"}]}
{"messages": [{"role": "user", "content": "Write the text \"v^3(x)\" with the \"v^3\" colored red and \"x\" colored cyan, then fade in \"vcubingx\" below it."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass NewIntro(Scene):\n\n    def construct(self):\n        h1 = '#ff5757'\n        h2 = '#5ce1e6'\n        text = TexMobject('\\\\textbf{\\\\text{v}} ^3 \\\\textbf{\\\\text{(}}\\\\textbf{\\\\text{x}}\\\\textbf{\\\\text{)}}}', tex_to_color_map={'\\\\textbf{\\\\text{v}} ^3': h1, '\\\\textbf{\\\\text{x}}': h2})\n        text.scale(4)\n        vc = TextMobject('vcubingx')\n        vc.scale(1.5)\n        vc.shift(2 * DOWN)\n        self.play(Write(text), run_time=2)\n        self.play(FadeIn(vc))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a scene that writes a mathematical expression with colored text, fades in accompanying text below it, and then simultaneously writes a vertical line and a logo to the right of the original text."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass IntroFlam(Scene):\n\n    def construct(self):\n        h1 = '#ff5757'\n        h2 = '#5ce1e6'\n        text = TexMobject('\\\\textbf{\\\\text{v}} ^3 \\\\textbf{\\\\text{(}}\\\\textbf{\\\\text{x}}\\\\textbf{\\\\text{)}}}', tex_to_color_map={'\\\\textbf{\\\\text{v}} ^3': h1, '\\\\textbf{\\\\text{x}}': h2})\n        text.scale(2.5)\n        vc = TextMobject('vcubingx')\n        vc.scale(1)\n        vc.shift(2 * DOWN)\n        VGroup(text, vc).center()\n        logo = SVGMobject('./img/flam.svg')\n        logo.scale(2)\n        logo[-2:].set_color('#fe3a3b')\n        logo.shift(3 * LEFT)\n        logo.scale(0.75)\n        line = Line(2 * UP, 2 * DOWN)\n        self.play(Write(text))\n        self.play(FadeIn(vc))\n        self.play(ApplyMethod(VGroup(*self.mobjects).shift, 3 * RIGHT), Write(line), Write(logo))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Introduce a mathematical expression with colored text, followed by text and a Discord logo."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass NewIntroD(Scene):\n\n    def construct(self):\n        h1 = '#ff5757'\n        h2 = '#5ce1e6'\n        text = TexMobject('\\\\textbf{\\\\text{v}} ^3 \\\\textbf{\\\\text{(}}\\\\textbf{\\\\text{x}}\\\\textbf{\\\\text{)}}}', tex_to_color_map={'\\\\textbf{\\\\text{v}} ^3': h1, '\\\\textbf{\\\\text{x}}': h2})\n        text.scale(4)\n        vc = TextMobject('vcubingx')\n        vc.scale(1.5)\n        vc.shift(2 * DOWN)\n        text2 = TextMobject('Join my dicord server!')\n        text2.shift(3 * DOWN + 0.7 * RIGHT)\n        logo = ImageMobject('./img/discord.png').scale(0.5)\n        logo.shift(3 * DOWN + 2.3 * LEFT)\n        text.shift(UP)\n        vc.shift(UP)\n        self.play(Write(text), run_time=1)\n        self.play(FadeIn(vc), FadeIn(text2), FadeIn(logo))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a large integral symbol appearing on screen."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Integral(Scene):\n\n    def construct(self):\n        self.play(Write(TexMobject('\\\\int').scale(5)))"}]}
{"messages": [{"role": "user", "content": "Display the text \"vcubingx\" scaled up."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Textt(Scene):\n\n    def construct(self):\n        self.play(Write(TextMobject('vcubingx').scale(7)))"}]}
{"messages": [{"role": "user", "content": "Write the words \"Q and A\" scaled up and animate their appearance."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass QandA(Scene):\n\n    def construct(self):\n        text = TextMobject('Q and A')\n        text.scale(3)\n        self.play(Write(text))"}]}
{"messages": [{"role": "user", "content": "Create a custom axes object with specific range and without tips or ticks."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SpecialAxes(Scene):\n    CONFIG = {'x_max': 6, 'x_min': 0, 'y_min': 0, 'y_max': 6, 'tip_scale_factor': 0.25}\n\n    def construct(self):\n        axes = Axes(x_min=self.x_min, x_max=self.x_max, y_min=self.y_min, y_max=self.y_max, axis_config={'include_tip': False, 'include_ticks': False})\n        NumberLine\n        tip = VGroup(*[Line([self.x_max, 0, 0], np.array([self.x_max, 0, 0]) + self.tip_scale_factor * np.array([-np.sqrt(2) / 2, i * np.sqrt(2) / 2, 0]), color=LIGHT_GRAY) for i in [-1, 1]], *[Line([0, self.y_max, 0], np.array([0, self.y_max, 0]) + self.tip_scale_factor * np.array([i * np.sqrt(2) / 2, -np.sqrt(2) / 2, 0]), color=LIGHT_GRAY) for i in [-1, 1]])\n        axes = VGroup(axes, tip)\n        axes.center()\n        self.add(axes)"}]}
{"messages": [{"role": "user", "content": "Create an empty Manim scene named \"Intro\" for a reinforcement learning introduction."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport gym\n\nclass Intro(Scene):\n\n    def construct(self):\n        pass"}]}
{"messages": [{"role": "user", "content": "Write the title \"Q-Learning\" in blue and enlarged on the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport gym\n\nclass QTitle(Scene):\n\n    def construct(self):\n        title = TextMobject('Q-Learning', color=BLUE)\n        title.scale(2)\n        self.play(Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a Q-Table with labeled states and actions."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport gym\n\nclass QTable(Scene):\n\n    def construct(self):\n        table = Rectangle(height=3.5, width=3.5)\n        b1 = Brace(table, LEFT)\n        text = b1.get_text('State')\n        b2 = Brace(table, UP)\n        text2 = b2.get_text('Action')\n        title = TextMobject('Q-Table', color=RED)\n        title.scale(2)\n        title.shift(2.5 * DOWN)\n        self.play(Write(table))\n        self.play(Write(b1), Write(b2), Write(text), Write(text2))\n        self.wait()\n        self.play(Write(title))"}]}
{"messages": [{"role": "user", "content": "Present the title \"Markov Decision Process\" and then introduce the concepts of \"State\", \"Action\", and \"Reward\" one by one."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport gym\n\nclass MDP(Scene):\n\n    def construct(self):\n        mdp = TextMobject('Markov Descision Process', color=RED)\n        mdp.scale(1.5)\n        b1 = TextMobject('State')\n        b1.scale(1.5)\n        b1.shift(2 * LEFT + 1.5 * UP)\n        b2 = TextMobject('Action')\n        b2.scale(1.5)\n        b2.shift(2 * LEFT + 0.5 * DOWN)\n        b3 = TextMobject('Reward')\n        b3.scale(1.5)\n        b3.shift(2 * LEFT + 2.5 * DOWN)\n        self.play(Write(mdp))\n        self.wait()\n        self.play(ApplyMethod(mdp.shift, 2.5 * UP))\n        self.wait()\n        self.play(Write(b1))\n        self.wait()\n        self.play(Write(b2))\n        self.wait()\n        self.play(Write(b3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the Q-learning algorithm's iterative process by highlighting each step of its flowchart sequentially."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport gym\n\nclass QLearning(Scene):\n\n    def construct(self):\n        flow = BulletedList('Initialize Q Table', 'Choose an action a', 'Perform an action', 'Measure Reward', 'Update Q', 'GOTO 1')\n        self.play(Write(flow))\n        self.wait()\n        for i in range(0, 6):\n            self.play(ApplyMethod(flow.fade_all_but, i))\n            self.wait()"}]}
{"messages": [{"role": "user", "content": "Display two titles, \"Option 1\" and \"Option 2\", alongside a 3x3 grid of zeros and Python code for initializing a Counter object."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport gym\n\nclass Initialize(Scene):\n\n    def construct(self):\n        table1 = VGroup(Rectangle(height=3, width=3), Line(0.5 * RIGHT + 1.5 * UP, 0.5 * RIGHT + 1.5 * DOWN), Line(0.5 * LEFT + 1.5 * UP, 0.5 * LEFT + 1.5 * DOWN), Line(1.5 * LEFT + 0.5 * UP, 1.5 * RIGHT + 0.5 * UP), Line(1.5 * LEFT + 0.5 * DOWN, 1.5 * RIGHT + 0.5 * DOWN), *[TextMobject('0').shift(z * UP + i * RIGHT) for i in range(-1, 2) for z in range(-1, 2)])\n        table1.shift(2.5 * LEFT)\n        title1 = TextMobject('Option 1', color=YELLOW)\n        title1.scale(1.5)\n        title1.shift(2.5 * UP + 2.5 * LEFT)\n        title2 = TextMobject('Option 2', color=RED)\n        title2.scale(1.5)\n        title2.shift(2.5 * UP + 2.5 * RIGHT)\n        colc = VGroup(TextMobject('from collections import Counter', tex_to_color_map={'from': PURPLE, 'import': PURPLE}).shift(0.5 * UP), TextMobject('qtable = Counter()', tex_to_color_map={'Counter': BLUE, '=': PURPLE}).shift(0.5 * DOWN))\n        colc.scale(0.75)\n        colc.shift(2.5 * RIGHT)\n        self.play(Write(table1), Write(title1))\n        self.wait()\n        self.play(Write(title2), Write(colc))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the Q-learning update equation and annotate each component with a descriptive label using braces."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport gym\n\nclass QUpdate(Scene):\n\n    def construct(self):\n        equation = TexMobject('\\\\text{New}Q(s,a)', ' = ', 'Q(s,a)', ' + ', '\\\\alpha', '[R(s,a)', ' + \\\\gamma', \"\\\\text{max}Q'(s',a')-Q(s,a)]\")\n        li = equation.break_up_tex_strings(['\\\\text{New}Q(s,a)', 'Q(s,a)', '\\\\alpha[R(s,a)', \"\\\\gamma\\\\text{max}Q'(s',a')-Q(s,a)\"])\n        texts = ['Learning Rate', 'Reward', 'Discount Rate', 'Maximum expected future reward']\n\n        def get_brace(obj, text, scale=0.5):\n            brace = Brace(obj)\n            t = brace.get_text(text)\n            t.scale(scale)\n            return [brace, t]\n        braces = VGroup(*get_brace(equation[0], 'New Q Value'), *get_brace(equation[2], 'Current Q Value'), *[get_brace(i, n) for n, i in zip(texts, equation[4:])])\n        self.play(Write(equation))\n        self.wait()\n        self.play(Write(braces))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the Taxi-v2 gym environment with its grid, destinations, and taxi, then animate the training and testing process."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport gym\n\nclass Taxi(Scene):\n    MAP = ['+---------+', '|R: | : :G|', '| : : : : |', '| : : : : |', '| | : | : |', '|Y| : |B: |', '+---------+']\n\n    def construct(self):\n        env = gym.make('Taxi-v2')\n        self.q = np.zeros([env.observation_space.n, env.action_space.n])\n        self.env = env\n        self.continual = False\n        r = TextMobject('R')\n        r.shift(3 * LEFT + (3 - 6 / 10) * UP)\n        r.scale(1.5)\n        g = TextMobject('G')\n        g.shift(3 * RIGHT + (3 - 6 / 10) * UP)\n        g.scale(1.5)\n        b = TextMobject('B')\n        b.shift(3 * LEFT + (3 - 6 / 10) * DOWN)\n        b.scale(1.5)\n        y = TextMobject('Y')\n        y.shift(1 * RIGHT + (3 - 6 / 10) * DOWN)\n        y.scale(1.5)\n        rows = VGroup(*[Line(i * UP - 4 * RIGHT, i * UP + 4 * RIGHT) for i in np.arange(-3, 4, 6 / 5)])\n        rows.set_fill(opacity=0.25)\n        columns = VGroup(*[Line(3 * UP + i * RIGHT, 3 * DOWN + i * RIGHT) for i in range(-4, 6, 2)])\n        columns.set_fill(opacity=0.25)\n        rr = np.arange(-3, 4, 6 / 5)\n        cc = range(-4, 6, 2)\n        taxi = Rectangle(color=YELLOW)\n        borders = VGroup(Line(3 * UP + -4 * RIGHT, 3 * DOWN + -4 * RIGHT, color=RED, stroke_width=8), Line(3 * UP + 4 * RIGHT, 3 * DOWN + 4 * RIGHT, color=RED, stroke_width=8), Line(3 * UP - 4 * RIGHT, 3 * UP + 4 * RIGHT, color=RED, stroke_width=8), Line(-3 * UP - 4 * RIGHT, -3 * UP + 4 * RIGHT, color=RED, stroke_width=8), Line(3 * UP + -4 * RIGHT, 3 * DOWN + -4 * RIGHT, color=RED, stroke_width=8), Line((3 - 12 / 5) * DOWN + -2 * RIGHT, 3 * DOWN + -2 * RIGHT, color=RED, stroke_width=8), Line((3 - 12 / 5) * DOWN + 2 * RIGHT, 3 * DOWN + 2 * RIGHT, color=RED, stroke_width=8), Line(3 * UP + 0 * RIGHT, (3 - 6 / 5) * UP + 0 * RIGHT, color=RED, stroke_width=8))\n        self.play(Write(rows))\n        self.play(Write(columns))\n        self.play(Write(borders))\n        self.wait()\n        self.play(Write(r), Write(g), Write(y), Write(b))\n        self.wait()\n\n    def continual_update(self, dt):\n        if self.continual:\n            pass\n\n    def train(self, num_episodes=2000, learning_rate=0.618, gamma=1, to_print=True, interval=50, to_render=True):\n        if to_print:\n            print('Training...\\n')\n        for i in range(num_episodes):\n            done = False\n            total_reward = 0\n            s = self.env.reset()\n            while not done:\n                action = np.argmax(self.q[s])\n                state, reward, done, info = self.env.step(action)\n                self.q[s, action] = learning_rate * (reward + gamma * np.max(self.q[state]))\n                s = state\n                total_reward += reward\n                if to_render:\n                    self.env.render()\n            if i % interval == 0 and to_print:\n                print(f'Episode: {i + 1}, Reward{total_reward}')\n\n    def test(self, num_episodes=5, to_print=True, to_render=True):\n        if to_print:\n            print('Testing...\\n')\n        for i in range(num_episodes):\n            done = False\n            total_reward = 0\n            state = self.env.reset()\n            while not done:\n                state, reward, done, info = self.env.step(np.argmax(self.q[state]))\n                total_reward += reward\n                if to_render:\n                    self.env.render()\n            if to_print:\n                print(f'Episode {i + 1}, Reward {total_reward}')\n\n    @staticmethod\n    def decode(i):\n        out = []\n        out.append(i % 4)\n        i = i // 4\n        out.append(i % 5)\n        i = i // 5\n        out.append(i % 5)\n        i = i // 5\n        out.append(i)\n        assert 0 <= i < 5\n        return reversed(out)"}]}
{"messages": [{"role": "user", "content": "Write the title \"Deep Q Learning\" and then \"Live Streamer AI\" over a screen rectangle."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport gym\n\nclass DQL(Scene):\n\n    def construct(self):\n        title = TextMobject('Deep Q Learning', color=GREEN)\n        title.scale(2)\n        t2 = TextMobject('Live Streamer AI')\n        t2.scale(1.5)\n        t2.shift(3 * UP)\n        rect = ScreenRectangle(height=5)\n        self.play(Write(title))\n        self.wait()\n        self.play(Uncreate(title))\n        self.wait()\n        self.play(Write(t2), Write(rect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display two screen rectangles and a title text above them."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport gym\n\nclass TwoStuff(Scene):\n\n    def construct(self):\n        sc1 = ScreenRectangle(height=3)\n        sc1.shift(3 * LEFT)\n        sc2 = ScreenRectangle(height=3)\n        sc2.shift(3 * RIGHT)\n        title = TextMobject('Applying NEAT', color=BLUE)\n        title.scale(1.5)\n        title.shift(2.5 * UP)\n        self.play(Write(sc1), Write(sc2), Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a scene with \"Part X\" and a customizable title."}, {"role": "assistant", "content": "from manimlib import *\n\nclass PartScene(Scene):\n    CONFIG = {'n': 1, 'title': '', 'title_color': RED}\n\n    def construct(self):\n        if not self.title:\n            raise NotImplementedError('Please set the title of the scene')\n        part = TexText(f'Part {self.n}')\n        part.scale(1.5)\n        part.shift(2 * UP)\n        title = TexText(self.title, color=self.title_color)\n        title.scale(1.5)\n        self.play(Write(part))\n        self.play(Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a series of colored number squares, highlight the third square, then transform the squares and add a brace with a label to the last two."}, {"role": "assistant", "content": "from manimlib import *\n\nclass RS(Scene):\n\n    def construct(self):\n        shades = ['#fc998e', '#fb8d80', '#fb8072', '#e27367', '#c9665b']\n        numbers = [2, 4, 3, 1, '?', '?']\n        numbers2 = [2, 4, 3, 1, 0, '?']\n        c = [2, 4, 0, 4, 1, 3]\n        pos = (FRAME_WIDTH / 2 - 4.25) / 2 + 4.25\n        r1 = Rectangle(height=2.5, width=2.5).shift(pos * LEFT)\n        r2 = Rectangle(height=2.5, width=2.5).shift(pos * RIGHT)\n        t1 = TexText('Vivek (Me)').move_to(r1).shift(2 * DOWN)\n        t2 = TexText('Tony').move_to(r2).shift(2 * DOWN)\n        s = VGroup()\n        for i in range(4):\n            s_i = NumberSquare(numbers[i], shades[c[i]], side_length=1.5, num_scale=2)\n            s.add(s_i.shift(2 * i * RIGHT))\n        s.center()\n        self.play(Write(s), Write(r1), Write(r2), Write(t1), Write(t2))\n        self.wait()\n        r = BackgroundRectangle(s[2], buff=0.15)\n        self.play(ShowCreation(r))\n        self.wait()\n        self.play(Uncreate(r))\n        s2 = VGroup()\n        for i in range(6):\n            s_i = NumberSquare(numbers[i], shades[c[i]], side_length=1, num_scale=1.5)\n            s2.add(s_i.shift(1.5 * i * RIGHT))\n        s2.center()\n        b1 = Brace(s2[-2:])\n        t1 = b1.get_tex('k = 2', tex_to_color_map={'k': A_YELLOW, '2': A_ORANGE})\n        t1.scale(1.5)\n        t1.shift(0.25 * DOWN)\n        self.play(ReplacementTransform(s, s2[:5]), Write(s2[5:]))\n        self.wait()\n        self.play(GrowFromCenter(b1), Write(t1))\n        self.wait()\n        r1 = BackgroundRectangle(s2[2], buff=0.15)\n        r2 = BackgroundRectangle(s2[-1], buff=0.15)\n        self.play(ShowCreation(r1), ShowCreation(r2))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display a title \"Reed-Solomon Codes\" followed by three images, a QR code, a barcode, and a CD, arranged in a triangle formation."}, {"role": "assistant", "content": "from manimlib import *\n\nclass RSAppl(Scene):\n\n    def construct(self):\n        title = TexText('Reed-Solomon Codes', color=A_YELLOW)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        self.play(Write(title))\n        img1 = ImageMobject('img/qr.jpeg')\n        img1.scale(0.5)\n        img1.shift(3 * LEFT + UP)\n        img2 = ImageMobject('img/barcode.png')\n        img2.scale(0.5)\n        img2.shift(3 * RIGHT + UP)\n        img3 = ImageMobject('img/cd.png')\n        img3.scale(0.75)\n        img3.shift(2 * DOWN)\n        self.play(FadeIn(img1), FadeIn(img2), FadeIn(img3))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Introduce modular arithmetic with examples of addition and multiplication, illustrating properties like associativity, commutativity, and inverses."}, {"role": "assistant", "content": "from manimlib import *\n\nclass ModularIntro(Scene):\n\n    def construct(self):\n        title = TexText('Modular Arithmetic', color=A_YELLOW)\n        title.shift(3 * UP)\n        title.scale(1.5)\n        self.play(Write(title))\n        self.wait()\n        s = Text('{0, 1, 2, 3, 4}', t2c={str(i): A_ORANGE for i in range(5)})\n        s.scale(1.5)\n        s.move_to(1.5 * UP)\n        ff = Tex('(+, -, \\\\cross, \\\\olddiv) \\\\mod {p}', tex_to_color_map={'{p}': A_AQUA})\n        ff.scale(1.5)\n        self.play(title.shift, 3.5 * LEFT)\n        ff.next_to(title, RIGHT)\n        ff.shift(0.5 * RIGHT)\n        self.play(Write(ff))\n        self.wait()\n        eq = Tex('a \\\\equiv b \\\\mod p', tex_to_color_map={'a': A_ORANGE, 'b': A_ORANGE, 'p': A_AQUA})\n        eq.scale(2.5)\n        self.play(Write(eq))\n        self.wait()\n        b1 = Brace(eq[1])\n        b2 = Brace(eq[3:])\n        t1 = b1.get_text('Congruent')\n        t2 = b2.get_text('Same Remainder')\n        t1.shift(0.25 * DOWN)\n        t2.shift(0.25 * DOWN)\n        self.play(GrowFromCenter(b1), Write(t1))\n        self.play(GrowFromCenter(b2), Write(t2))\n        self.wait()\n        eq0 = Tex('1 \\\\equiv 6 \\\\mod 5', tex_to_color_map={'1': A_ORANGE, '6': A_ORANGE, '5': A_AQUA})\n        eq0.scale(2.5)\n        eq0.shift(0.25 * UP)\n        self.play(TransformMatchingTex(eq, eq0))\n        self.wait()\n        self.play(Uncreate(b1), Uncreate(b2), Uncreate(t1), Uncreate(t2), Uncreate(eq0))\n        self.wait()\n        self.play(Write(s))\n        self.wait()\n        eq1 = Tex('3 + 3 = 6', tex_to_color_map={'3': A_ORANGE, '6': A_ORANGE, '5': A_AQUA})\n        eq1.scale(1.5)\n        eq2 = Tex('3 + 3 \\\\equiv 1 \\\\mod 5', tex_to_color_map={'3': A_ORANGE, '1': A_ORANGE, '5': A_AQUA})\n        eq2.scale(1.5)\n        eq2.move_to(0 * UP + 0.5 * LEFT, RIGHT)\n        eq1.move_to(eq2, LEFT)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(TransformMatchingTex(eq1, eq2))\n        self.wait()\n        self.play(Indicate(eq2[3], scale_factor=1.5))\n        self.wait()\n        self.play(s.move_to, 4 * RIGHT + 1.5 * UP)\n        c = Circle(radius=2, stroke_color=A_GREY)\n        c.next_to(s, DOWN)\n        c_nums = VGroup()\n        for i, t in enumerate(np.linspace(PI / 2, PI / 2 - 2 * PI, 6)[:-1]):\n            x, y = (1.5 * np.cos(t), 1.5 * np.sin(t))\n            t = Tex(str(i), color=A_ORANGE)\n            t.scale(1.5)\n            t.move_to(c.get_center())\n            t.shift(x * RIGHT + y * UP)\n            c_nums.add(t)\n        self.play(Write(c))\n        anims = []\n        s_num = range(1, 14, 3)\n        for i in range(5):\n            anims.append(TransformFromCopy(s[s_num[i]], c_nums[i]))\n        self.play(*anims, run_time=5)\n        self.wait()\n        self.play(Uncreate(s), ApplyMethod(VGroup(c, c_nums).move_to, 4 * RIGHT + 0.5 * DOWN))\n        eq3 = Tex('4 + 3 \\\\equiv 2 \\\\mod 5', tex_to_color_map={'2': A_ORANGE, '3': A_ORANGE, '4': A_ORANGE, '5': A_AQUA})\n        eq3.scale(1.5)\n        eq3.move_to(eq2, LEFT)\n        self.play(FadeOut(eq2, UP), FadeIn(eq3, UP))\n        b_rects = VGroup()\n        for num in c_nums:\n            b = SurroundingRectangle(num, color='#f5fd62', buff=0.15)\n            b_rects.add(b)\n        b1 = SurroundingRectangle(eq3[0], color='#f5fd62', buff=0.15)\n        self.play(Write(b1))\n        self.wait()\n        for i in range(4, 8):\n            self.play(Transform(b1, b_rects[i % 5]))\n            self.wait(0.5)\n        self.wait(1)\n        eq4 = Tex('1 - 3 \\\\equiv 3 \\\\mod 5', tex_to_color_map={'1': A_ORANGE, '3': A_ORANGE, '5': A_AQUA})\n        eq4.scale(1.5)\n        eq4.move_to(eq3, LEFT)\n        self.play(FadeOut(eq3, UP), FadeIn(eq4, UP), Uncreate(b1))\n        self.wait()\n        b1 = SurroundingRectangle(eq4[0], color='#f5fd62', buff=0.15)\n        self.play(Write(b1))\n        self.wait()\n        for i in range(6, 2, -1):\n            self.play(Transform(b1, b_rects[i % 5]))\n            self.wait(0.5)\n        self.wait(1)\n        self.play(Uncreate(b1))\n        self.wait()\n        eq5 = Tex('1 + (-3) \\\\equiv 3 \\\\mod 5', tex_to_color_map={'1': A_ORANGE, '3': A_ORANGE, '5': A_AQUA})\n        eq5.scale(1.5)\n        eq5.move_to(eq4, LEFT)\n        self.play(TransformMatchingTex(eq4, eq5))\n        self.wait()\n        eq6 = Tex('a', '+', '(-a)', '=', '0', tex_to_color_map={'a': A_PINK})\n        eq6.scale(1.5)\n        eq6.move_to(eq5, LEFT)\n        eq6.shift(DOWN)\n        b = Brace(eq6[2:5])\n        t_b = b.get_text('Additive inverse', color=A_GREEN)\n        t_b.scale(1.5)\n        t_b.shift(0.25 * DOWN)\n        eq7 = Tex('a', '+', '(-a)', '\\\\equiv', '0', '\\\\mod 5', tex_to_color_map={'a': A_PINK, '5': A_AQUA})\n        eq7.scale(1.5)\n        eq7.move_to(eq6, LEFT)\n        self.play(ApplyMethod(eq5.shift, UP))\n        self.play(Write(eq6))\n        self.wait()\n        self.play(Write(b), Write(t_b))\n        self.wait()\n        self.play(TransformMatchingTex(eq6, eq7))\n        self.wait()\n        eq8 = Tex('3', '+', '(-3)', '\\\\equiv', '0 \\\\mod 5', tex_to_color_map={'3': A_ORANGE, '5': A_AQUA})\n        eq8.scale(1.5)\n        eq8.move_to(eq7, LEFT)\n        eq9 = Tex('3', '+', '2', '\\\\equiv', '0 \\\\mod 5', tex_to_color_map={'3': A_ORANGE, '2': A_ORANGE, '5': A_AQUA})\n        eq9.scale(1.5)\n        eq9.move_to(eq7, LEFT)\n        n = Tex('2', color=A_ORANGE)\n        n.scale(1.5)\n        n.move_to([-4.09011112, -0.94835368, 0])\n        self.play(FadeOut(VGroup(eq7, t_b, b), DOWN))\n        self.wait()\n        grp = VGroup(eq5[1][2], eq5[2])\n        grp2 = VGroup(eq8[2][1], eq8[3])\n        eq8_2 = eq8[2]\n        eq8.remove(eq8[2], eq8[3])\n        self.play(TransformFromCopy(grp, grp2))\n        self.wait()\n        self.play(Write(VGroup(eq8_2[0], eq8)))\n        self.wait()\n        self.play(Transform(grp2, n))\n        self.wait()\n        cp = n.copy()\n        cp.move_to(grp)\n        self.play(Transform(grp, cp), TransformFromCopy(n, cp))\n        self.play(Uncreate(VGroup(eq8, grp2, eq8_2)), ApplyMethod(VGroup(eq5, cp).shift, DOWN))\n        self.wait()\n        self.play(FadeOut(VGroup(eq5, cp), UP))\n        self.wait()\n        eq10 = Tex('2 \\\\cdot 3 = 6', tex_to_color_map={'2': A_ORANGE, '3': A_ORANGE, '6': A_ORANGE, '5': A_AQUA})\n        eq10.scale(1.5)\n        eq11 = Tex('2 \\\\cdot 3 \\\\equiv 1 \\\\mod 5', tex_to_color_map={'2': A_ORANGE, '3': A_ORANGE, '1': A_ORANGE, '5': A_AQUA})\n        eq11.scale(1.5)\n        eq11.move_to(0 * UP + 0.5 * LEFT, RIGHT)\n        eq10.move_to(eq11, LEFT)\n        self.play(Write(eq10))\n        self.wait()\n        self.play(TransformMatchingTex(eq10, eq11))\n        self.wait()\n        eq12 = Tex('2+2+2 \\\\equiv 1 \\\\mod 5', tex_to_color_map={'2': A_ORANGE, '1': A_ORANGE, '5': A_AQUA})\n        eq12.scale(1.5)\n        eq12.move_to(eq11, LEFT)\n        eq12.shift(1.5 * DOWN)\n        self.play(ApplyMethod(eq11.shift, 0.5 * UP))\n        self.wait(0.5)\n        b1 = SurroundingRectangle(eq11[0], color='#f5fd62', buff=0.15)\n        self.play(TransformFromCopy(eq11[0:3], eq12[:5]), Write(eq12[5:]))\n        self.wait()\n        self.play(Write(b1))\n        self.wait()\n        self.play(Indicate(eq12[0], scale_factor=1.5))\n        self.play(Transform(b1, b_rects[2]))\n        for i in range(1, 3):\n            self.play(Indicate(eq12[2 * (i - 1) + 1:2 * i + 1], scale_factor=1.5))\n            for j in range(3):\n                self.play(Transform(b1, b_rects[(2 * i + j) % 5]))\n            self.wait()\n        self.play(Uncreate(VGroup(b1, eq11, eq12)))\n        self.wait()\n        eq13 = Tex('a', ' \\\\cdot ', 'a^{-1} ', '\\\\equiv 1 \\\\mod 5', tex_to_color_map={'a': A_PINK, '5': A_AQUA, '1': A_ORANGE})\n        eq13.scale(1.5)\n        eq13.move_to(0.25 * LEFT, RIGHT)\n        b = Brace(eq13[2:5])\n        b_t = b.get_text('Multiplicative Inverse', color=A_GREEN)\n        b_t.scale(1.25)\n        b_t.shift(0.5 * DOWN + 1.5 * RIGHT)\n        self.play(Write(eq13))\n        self.wait()\n        self.play(Write(b), Write(b_t))\n        self.wait()\n        self.play(ApplyMethod(VGroup(eq13, b, b_t).shift, DOWN))\n        self.wait()\n        eq14 = Tex('4', ' \\\\olddiv', '2 \\\\equiv 4 \\\\cdot 2^{-1} \\\\mod 5', tex_to_color_map={'5': A_AQUA, '4': A_ORANGE, '2': A_ORANGE, '1': A_ORANGE})\n        eq14.scale(1.5)\n        eq14.move_to(eq13, LEFT)\n        eq14.shift(2 * UP)\n        eq15 = Tex('4', ' \\\\olddiv', '2 \\\\equiv 4 \\\\cdot 3 \\\\mod 5', tex_to_color_map={'5': A_AQUA, '4': A_ORANGE, '2': A_ORANGE, '3': A_ORANGE})\n        eq15.scale(1.5)\n        eq15.move_to(eq14, LEFT)\n        eq15.shift(0.07 * DOWN)\n        eq16 = Tex('4', ' \\\\olddiv', '2 \\\\equiv 2 \\\\mod 5', tex_to_color_map={'5': A_AQUA, '4': A_ORANGE, '2': A_ORANGE, '3': A_ORANGE})\n        eq16.scale(1.5)\n        eq16.move_to(eq15, LEFT)\n        self.play(Write(eq14))\n        self.wait()\n        self.play(Transform(eq14[5:], eq15[5:]))\n        self.wait()\n        self.play(Transform(eq14[4:], eq16[4:]))\n        self.wait()\n        self.play(Uncreate(VGroup(c, eq14, b, b_t, eq13, c, c_nums)))\n        self.wait()\n        l1 = Line(10 * LEFT, 10 * RIGHT)\n        l1.move_to(2 * UP)\n        l2 = Line(2 * UP, 10 * DOWN)\n        l3 = Line(10 * LEFT, 10 * RIGHT)\n        l3.move_to(0.75 * UP)\n        title1 = TexText('Addition', color=A_GREEN)\n        title1.scale(1.25)\n        title1.move_to(FRAME_WIDTH / 4 * LEFT + 1.375 * UP)\n        title2 = TexText('Multiplication', color=A_GREEN)\n        title2.scale(1.25)\n        title2.move_to(FRAME_WIDTH / 4 * RIGHT + 1.3 * UP)\n        m = {'a': A_PINK, 'b': A_PINK, 'p': A_AQUA}\n\n        def create_eq(eq, n, direction):\n            return Tex(eq, tex_to_color_map=m if n < 3 else {**m, 'c': A_PINK}).shift(FRAME_WIDTH / 4 * direction + (n - 1) * 0.75 * DOWN)\n        add_eqs = VGroup()\n        add_tex = ['(a + b) + c \\\\equiv a + (b + c)', 'a + b \\\\equiv b + a', 'a(b+c) \\\\equiv ab+ac', 'a + 0 \\\\equiv a \\\\equiv 0 + a', 'a + (-a) \\\\equiv 0 \\\\equiv (-a) + a']\n        mul_eqs = VGroup()\n        mul_tex = ['(ab)c \\\\equiv a(bc)', 'ab \\\\equiv ba', '(a+b)c \\\\equiv ac + bc', 'a \\\\cdot 1 \\\\equiv a \\\\equiv 1 \\\\cdot a', 'aa^{-1} \\\\equiv 1 \\\\equiv a^{-1} a; a \\\\neq 0']\n        for i in range(5):\n            add_eqs.add(create_eq(add_tex[i] + ' \\\\mod p', i + 1, LEFT))\n            mul_eqs.add(create_eq(mul_tex[i] + ' \\\\mod p', i + 1, RIGHT))\n        self.play(Write(l1), Write(l2), Write(l3))\n        self.play(Write(title1))\n        self.play(Write(add_eqs))\n        self.play(Write(title2))\n        self.play(Write(mul_eqs))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Animate the construction of a Lagrange interpolating polynomial by displaying data points, showing individual basis polynomials, and then combining them to form the final interpolating polynomial."}, {"role": "assistant", "content": "from manimlib import *\n\nclass LagrangeIntro(Scene):\n    CONFIG = {'fade_opacity': 0.15, 'curve_opacity': 1}\n\n    def construct(self):\n        x_vals = [1, 3, 4]\n        y_vals = [2, 2, -1]\n        coors = [(x_vals[i], y_vals[i]) for i in range(3)]\n        colors = [A_RED, A_YELLOW, A_BLUE]\n        curve_kwargs = {'stroke_width': 6, 'stroke_opacity': self.curve_opacity}\n        axes = Axes(x_range=(0, 5), y_range=(-3, 3), axis_config={'include_tip': False}, x_axis_config={'stroke_width': 6}, y_axis_config={'stroke_width': 6})\n        points = VGroup()\n        labels = VGroup()\n        offsets = [0.5 * RIGHT, 0.5 * LEFT, 0.75 * LEFT]\n        for i, (x, y) in enumerate(coors):\n            d = Dot(axes.c2p(x, y), radius=2 * DEFAULT_DOT_RADIUS, color=A_GREEN)\n            t = Tex(f'({x}, {y})')\n            t.next_to(d, DOWN)\n            t.shift(offsets[i])\n            points.add(d)\n            labels.add(t)\n        labels_cp = labels.copy()\n        c = ParametricCurve(lambda t: axes.c2p(t, self.func(t)), t_range=(0, 5), stroke_width=6, color=A_GREEN)\n        eq = Tex('p(x) = -x^2 + 4x - 1', tex_to_color_map={'p': A_GREEN, 'x': A_PINK})\n        eq.scale(1.5)\n        eq.shift(3.25 * UP)\n        grp = VGroup(axes, c, points, labels)\n        self.play(Write(axes), Write(points), Write(labels))\n        self.wait()\n        self.play(Write(c))\n        self.wait()\n        self.play(ApplyMethod(grp.shift, 0.5 * DOWN))\n        self.play(Write(eq))\n        self.wait()\n        self.play(FadeOut(VGroup(eq, c)), ApplyMethod(grp.shift, 0.5 * UP))\n\n        def l1(x):\n            return (x - 3) * (x - 4) / 6\n        l1_c = ParametricCurve(lambda t: axes.c2p(t, l1(t)), t_range=(0, 5), color=colors[0], stroke_width=6, stroke_opacity=self.curve_opacity)\n        l1_cp = l1_c.copy()\n        l1_cp.set_stroke(opacity=self.fade_opacity)\n\n        def l2(x):\n            return (x - 1) * (x - 4) / -2\n        l2_c = ParametricCurve(lambda t: axes.c2p(t, l2(t)), t_range=(0, 5), color=colors[1], stroke_width=6, stroke_opacity=self.curve_opacity)\n        l2_cp = l2_c.copy()\n        l2_cp.set_stroke(opacity=self.fade_opacity)\n\n        def l3(x):\n            return (x - 1) * (x - 3) / 3\n        l3_c = ParametricCurve(lambda t: axes.c2p(t, l3(t)), t_range=(0, 5), color=colors[2], stroke_width=6, stroke_opacity=self.curve_opacity)\n        l3_cp = l3_c.copy()\n        l3_cp.set_stroke(opacity=self.fade_opacity)\n        l_c = VGroup(l1_c, l2_c, l3_c)\n        l_cp = l_c.deepcopy()\n        l_faded = VGroup(l1_cp, l2_cp, l3_cp)\n        self.play(Write(l_c))\n        self.wait()\n\n        def hide_all_but(idx):\n            anims = []\n            for i in range(3):\n                if i != idx:\n                    anims.append(Transform(l_c[i], l_faded[i]))\n            self.play(*anims)\n\n        def show_all():\n            anims = []\n            for i in range(3):\n                anims.append(Transform(l_c[i], l_cp[i]))\n            self.play(*anims)\n\n        def one_hot(x_val, curve_index):\n            return 1 if x_val == x_vals[curve_index] else 0\n\n        def show_curve(curve_index):\n            points.set_opacity(self.fade_opacity)\n            hide_all_but(curve_index)\n            points_0 = VGroup()\n            for x in x_vals:\n                points_0.add(Dot(axes.c2p(x, one_hot(x, curve_index)), radius=0.1, color=colors[curve_index]))\n            labels_0 = VGroup()\n            for i in range(3):\n                labels_0.add(Tex(f'({x_vals[i]}, {one_hot(x_vals[i], curve_index)})').next_to(points_0[i], UP))\n            self.play(Write(points_0), Transform(labels, labels_0))\n            self.wait()\n            self.play(Indicate(labels[curve_index]))\n            self.wait()\n            self.play(Transform(labels, labels_cp), ApplyMethod(points.set_opacity, 1), Uncreate(points_0))\n            show_all()\n            self.wait()\n        show_curve(0)\n        show_curve(1)\n        show_curve(2)\n        eq1 = Tex('l_1(x)', '=', '(x-3)', '(x-4)', tex_to_color_map={'x': A_PINK, 'l_1': A_RED, '3': A_ORANGE, '4': A_ORANGE})\n        eq1.scale(1.5)\n        eq1.shift(3 * UP)\n        eq2 = Tex('l_1(x)', '=', '{{1} \\\\over {6}}', '(x-3)', '(x-4)', tex_to_color_map={'x': A_PINK, 'l_1': A_RED, '{1}': A_ORANGE, '{6}': A_ORANGE, '3': A_ORANGE, '4': A_ORANGE})\n        eq2.scale(1.5)\n        eq2.shift(3 * UP)\n\n        def p(x):\n            return 2 * l1(x) + 2 * l2(x) - 1 * l3(x)\n        eq3 = Tex('p(x) =', ' 2 \\\\cdot l_1(x)', ' + 2 \\\\cdot ', 'l_2(x)', ' + (-1) \\\\cdot ', 'l_3(x)', tex_to_color_map={'l_1': A_RED, 'l_2': A_YELLOW, 'l_3': A_BLUE, 'x': A_PINK, 'p': A_GREEN})\n        eq3.shift(3.25 * UP)\n        eq3.scale(1.5)\n\n        def func(t):\n            return axes.c2p(t, p(t))\n        self.play(Uncreate(l_c))\n        self.wait()\n        self.play(Write(eq1))\n        self.wait()\n        self.play(TransformMatchingTex(eq1, eq2))\n        self.wait()\n        self.play(TransformFromCopy(eq2, l_cp[0]))\n        self.wait()\n        self.play(FadeOut(VGroup(eq2[4:], l_cp[0], l_c[0])))\n        grp2 = VGroup(axes, points, labels)\n        c.shift(0.5 * DOWN)\n        l_cp.shift(0.5 * DOWN)\n        self.play(ApplyMethod(grp2.shift, 0.5 * DOWN), ReplacementTransform(eq2[:4], eq3[5:9]))\n\n        def func_lc_1(t):\n            return axes.c2p(t, 2 * l1(t))\n\n        def func_lc_2(t):\n            return axes.c2p(t, 2 * l1(t) + 2 * l2(t))\n\n        def func_lc_3(t):\n            return axes.c2p(t, 2 * l1(t) + 2 * l2(t) + -1 * l3(t))\n        color_avg = rgb_to_hex((hex_to_rgb(A_RED) + hex_to_rgb(A_YELLOW)) / 2)\n        lc_1 = ParametricCurve(func_lc_1, t_range=(0, 5), color=colors[0], **curve_kwargs)\n        lc_2 = ParametricCurve(func_lc_2, t_range=(0, 5), color=color_avg, **curve_kwargs)\n        lc_3 = ParametricCurve(func_lc_3, t_range=(0, 5), color=A_GREEN, **curve_kwargs)\n        self.play(Write(eq3[:4]))\n        self.wait()\n        self.play(TransformFromCopy(eq3[5:9], l_cp[0]))\n        self.wait()\n        self.play(Write(eq3[4]))\n        self.bring_to_front(eq3[:9], points, labels)\n        self.play(Indicate(eq3[4]))\n        self.play(Transform(l_cp[0], lc_1), ApplyMethod(points[0].set_color, A_RED), run_time=3.5)\n        self.wait()\n        self.play(Write(eq3[9:14]))\n        self.play(Indicate(eq3[9:14]))\n        self.play(Transform(l_cp[0], lc_2), ApplyMethod(points[:2].set_color, color_avg), run_time=3.5)\n        self.wait()\n        self.play(Write(eq3[14:]))\n        self.play(Indicate(eq3[14:]))\n        self.play(Transform(l_cp[0], lc_3), ApplyMethod(points.set_color, A_GREEN), run_time=3.5)\n        self.wait()\n        self.play(TransformMatchingTex(eq3, eq))\n        self.wait()\n        self.embed()\n\n    def func(self, x):\n        return -x ** 2 + 4 * x - 1"}]}
{"messages": [{"role": "user", "content": "Visualize a scatter plot of points with labels, then transform it into a symbolic representation of polynomial interpolation, demonstrating degree reduction and conditions."}, {"role": "assistant", "content": "from manimlib import *\n\nclass LagrangeUnique(Scene):\n\n    def construct(self):\n        dots = Tex('.\\\\\\\\.\\\\\\\\.\\\\\\\\')\n        p1 = Tex('(x_{1}, y_{1})', tex_to_color_map={'1': A_ORANGE, 'x': A_PINK, 'y': A_GREEN})\n        p1.scale(1.5)\n        p1.shift(1.75 * UP)\n        p2 = Tex('(x_{n}, y_{n})', tex_to_color_map={'n': A_ORANGE, 'x': A_PINK, 'y': A_GREEN})\n        p2.scale(1.5)\n        p2.shift(1.5 * DOWN)\n        axes = Axes(x_range=(0, 5), y_range=(-3, 3), axis_config={'include_tip': False}, x_axis_config={'stroke_width': 6}, y_axis_config={'stroke_width': 6})\n        coors = [[i + np.random.random(), 6 * np.random.random() - 3] for i in range(5)]\n        points = VGroup()\n        labels = VGroup()\n        for i, (x, y) in enumerate(coors):\n            points.add(Dot(axes.c2p(x, y), color=A_ORANGE, radius=2 * DEFAULT_DOT_RADIUS))\n            labels.add(Tex(f'(x_{{{i + 1}}}, y_{{{i + 1}}})', tex_to_color_map={str(i + 1): A_ORANGE, 'x': A_PINK, 'y': A_GREEN}).next_to(points[i], DOWN))\n        self.play(Write(axes))\n        self.play(Write(points), Write(labels))\n        self.wait()\n        grp1 = VGroup(axes, points, labels)\n        grp2 = VGroup(dots, p1, p2)\n        grp2.shift(4 * RIGHT)\n        l = Line(10 * UP, 10 * DOWN)\n        l.shift(2 * RIGHT)\n        self.play(Transform(grp1, grp2))\n        self.play(Write(l))\n        self.wait()\n        l1 = Line(10 * LEFT, 2 * RIGHT)\n        l1.shift(2.25 * UP)\n        l2 = Line(10 * LEFT, 2 * RIGHT)\n        l2.shift(0.7 * DOWN)\n        eq1 = Tex('p(x_i)', '=', 'q(x_i)', '= y_i', tex_to_color_map={'p': A_LAVENDER, 'q': A_AQUA, 'y': A_GREEN, 'i': A_ORANGE, 'x': A_PINK})\n        eq1.scale(1.5)\n        eq1.move_to(2.5 * LEFT + 3 * UP)\n        eq2 = Tex('r(x)', '=', 'p(x)', '-', 'q(x)', tex_to_color_map={'x': A_PINK, 'p': A_LAVENDER, 'q': A_AQUA, 'r': A_RED})\n        eq2.scale(1.5)\n        eq2.next_to(eq1, DOWN).shift(0.5 * DOWN)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(TransformFromCopy(eq1[:4], eq2[5:9]), TransformFromCopy(eq1[6:10], eq2[10:]), Write(eq2[:5]), Write(eq2[9]), run_time=2)\n        self.play(Write(l1))\n        self.wait()\n        eq3 = Tex('\\\\mathrm{deg} \\\\ r(x)', '\\\\leq n-1', tex_to_color_map={'r': A_RED, 'x': A_PINK, '\\\\mathrm{deg}': A_YELLOW, 'n': A_ORANGE, '1': A_ORANGE})\n        eq3.scale(1.5)\n        eq3.next_to(eq2, DOWN).shift(0.5 * DOWN)\n        self.play(TransformFromCopy(eq2[:4], eq3[1:5]), Write(eq3[0]), Write(eq3[5:]), run_time=2)\n        self.wait()\n        eq4 = Tex('r(x_i) = p(x_i) - q(x_i)', tex_to_color_map={'i': A_ORANGE, 'p': A_LAVENDER, 'q': A_AQUA, 'x': A_PINK, 'y': A_GREEN, 'r': A_RED})\n        eq4.scale(1.5)\n        eq4.next_to(eq3, DOWN).shift(0.65 * DOWN)\n        eq4_1 = Tex('r(x_i)', '= 0', tex_to_color_map={'i': A_ORANGE, 'r': A_RED, 'x': A_PINK})\n        eq4_1.scale(1.5)\n        eq4_1.move_to(eq4, LEFT)\n        self.play(Write(l2))\n        self.play(Write(eq4))\n        self.wait()\n        self.play(Transform(eq4[5:], eq4_1[5]))\n        self.play(ApplyMethod(eq4.shift, (eq3.get_center()[1] - eq4.get_center()[1]) * RIGHT))\n        self.wait()\n        eq5 = Tex('\\\\mathrm{deg} \\\\ r(x)', '=n', tex_to_color_map={'r': A_RED, 'x': A_PINK, '\\\\mathrm{deg}': A_YELLOW, 'n': A_ORANGE, '1': A_ORANGE})\n        eq5.scale(1.5)\n        eq5.next_to(eq4, DOWN).shift(0.5 * DOWN)\n        self.play(Write(eq5))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display a polynomial equation and its graph with colored coordinates and points representing its values modulo 5."}, {"role": "assistant", "content": "from manimlib import *\n\nclass FinitePoly(Scene):\n\n    def construct(self):\n        eq = Tex('f(x) = x^2 + 2 \\\\mod 5', tex_to_color_map={'5': A_ORANGE, '2': A_YELLOW, 'x': A_PINK, 'f': A_GREEN})\n        eq.scale(1.5)\n        eq.shift(3.25 * UP)\n        axes = Axes(x_range=(0, 4), y_range=(0, 4), axis_config={'include_tip': False}, x_axis_config={'stroke_width': 6}, y_axis_config={'stroke_width': 6})\n        axes.add_coordinate_labels()\n        self.play(Write(eq))\n        self.play(Write(axes))\n        self.wait()\n        points = VGroup()\n        for x in range(0, 5):\n            y = (x ** 2 + 2) % 5\n            obj = Dot(axes.c2p(x, y), color=A_RED, radius=2 * DEFAULT_DOT_RADIUS)\n            points.add(obj)\n        self.play(Write(points))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Visualize the process of calculating function values modulo 5 for a cubic polynomial and display the corresponding points on a graph."}, {"role": "assistant", "content": "from manimlib import *\n\nclass RSCodes(Scene):\n\n    def construct(self):\n        shades = ['#fc998e', '#fb8d80', '#fb8072', '#e27367', '#c9665b']\n        numbers = [2, 4, 3, 1, '?', '?']\n        numbers2 = [2, 4, 3, 1, 0, '?']\n        pos = (FRAME_WIDTH / 2 - 4.25) / 2 + 4.25\n        r1 = Rectangle(height=2.5, width=2.5).shift(pos * LEFT)\n        r2 = Rectangle(height=2.5, width=2.5).shift(pos * RIGHT)\n        tt1 = TexText('Vivek (Me)').move_to(r1).shift(2 * DOWN)\n        tt2 = TexText('Tony').move_to(r2).shift(2 * DOWN)\n        c = [2, 4, 0, 4, 1, 3]\n        s = VGroup()\n        for i in range(4):\n            s_i = NumberSquare(numbers[i], shades[c[i]], side_length=1.5, num_scale=2)\n            s.add(s_i.shift(2 * i * RIGHT))\n        s.center()\n        self.play(Write(s))\n        self.play(Write(r1), Write(tt1), Write(r2), Write(tt2))\n        self.wait()\n        s2 = VGroup()\n        for i in range(6):\n            s_i = NumberSquare(numbers[i], shades[c[i]], side_length=1, num_scale=1.5)\n            s2.add(s_i.shift(1.5 * i * RIGHT))\n        s2.center()\n        b1 = Brace(s2[-2:])\n        t1 = b1.get_tex('k = 2', tex_to_color_map={'k': A_YELLOW, '2': A_ORANGE})\n        t1.scale(1.5)\n        t1.shift(0.25 * DOWN)\n        self.play(ReplacementTransform(s, s2[:5]), Write(s2[5:]))\n        self.play(GrowFromCenter(b1), Write(t1))\n        self.wait()\n        labels = VGroup()\n        for i, obj in enumerate(s2):\n            t = Tex(str(i + 1), color=A_YELLOW)\n            t.next_to(obj, UP)\n            t.scale(1.25)\n            labels.add(t)\n        labels.shift(0.25 * UP)\n        labels2 = VGroup()\n        for i, obj in enumerate(s2):\n            t = Tex(f'm_{str(i + 1)}', tex_to_color_map={str(i + 1): A_YELLOW, 'm': A_PINK})\n            t.next_to(obj, UP)\n            t.scale(1.25)\n            labels2.add(t)\n        labels2.shift(0.25 * UP)\n        labels2_cp = labels2.deepcopy()\n        self.play(Write(labels))\n        self.wait()\n        self.play(Transform(labels, labels2))\n        self.wait()\n        b2 = Brace(labels, UP)\n        t2 = b2.get_tex('p > m_i', tex_to_color_map={'p': A_GREEN, 'm': A_PINK, 'i': A_YELLOW})\n        self.play(GrowFromCenter(b2), Write(t2))\n        self.wait()\n        self.play(Uncreate(b2), Uncreate(t2))\n        self.wait()\n        s_cp, s_cp2 = (s2.deepcopy(), s2.deepcopy())\n        for i, x in enumerate(np.linspace(3, -3, 6)):\n            s_cp[i].move_to(x * UP)\n        s_cp.shift(3 * RIGHT)\n        eqs = VGroup()\n        for i, x in enumerate(np.linspace(3, -3, 6)):\n            t = Tex(f'f({i}) = m_{i + 1}' if i < 4 else f'm_{i + 1} = f({i})', tex_to_color_map={'f': A_GREEN, 'x': A_PINK, 'm': A_PINK, str(i): A_YELLOW, str(i + 1): A_YELLOW})\n            t.move_to(x * UP)\n            t.scale(1.25)\n            eqs.add(t)\n        self.play(Uncreate(VGroup(b1, t1, labels[-1], labels[-2], r1, r2, tt1, tt2)))\n        self.play(Transform(s2, s_cp), ReplacementTransform(labels[:-2], VGroup(*[eq[-2:] for eq in eqs])[:-2]))\n        self.play(Write(VGroup(*[eq[:-2] for eq in eqs[:-2]])))\n        self.wait()\n        axes = Axes(x_range=(0, 4), y_range=(-2, 6), axis_config={'include_tip': False}, width=6, x_axis_config={'stroke_width': 3}, y_axis_config={'stroke_width': 3})\n        axes.shift(3 * RIGHT)\n        curve = ParametricCurve(lambda t: axes.c2p(t, self.f(t)), t_range=(0, 5), color=A_GREEN)\n        dots = VGroup()\n        point_lbl = VGroup()\n        for i in range(4):\n            dots.add(Dot(axes.c2p(i, numbers[i]), color=A_GREEN))\n            point_lbl.add(Tex(f'({i}, {numbers[i]})', tex_to_color_map={str(i): A_ORANGE, str(numbers[i]): A_ORANGE}).move_to(dots[i], DOWN).add_background_rectangle(buff=0.1))\n        point_lbl.shift(0.75 * DOWN)\n        eqs[-2:].shift(5 * LEFT)\n        self.play(VGroup(eqs[:-2], s2).shift, 5 * LEFT)\n        self.play(Write(axes))\n        self.wait()\n        self.play(TransformFromCopy(eqs[:-2], dots))\n        self.play(Write(point_lbl))\n        self.wait()\n        self.bring_to_front(point_lbl)\n        self.play(Write(curve))\n        self.bring_to_front(point_lbl)\n        self.wait()\n        self.play(Write(eqs[-2:]))\n        self.wait()\n        self.play(Uncreate(VGroup(axes, curve, point_lbl, dots)))\n        s_cp2.shift(2 * RIGHT)\n        t1, t2 = (Tex('f(4)'), Tex('f(5)'))\n        t1.move_to(s_cp2[-2])\n        t2.move_to(s_cp2[-1])\n        s_cp2[-1].remove(s_cp2[-1].num)\n        s_cp2[-2].remove(s_cp2[-2].num)\n        s_cp2[-1].num = t2\n        s_cp2[-1].add(s_cp2[-1].num)\n        s_cp2[-2].num = t1\n        s_cp2[-2].add(s_cp2[-2].num)\n        labels2_cp.shift(2 * RIGHT)\n        l = Line(10 * UP, 10 * DOWN)\n        l.shift(3 * LEFT)\n        self.play(Transform(s2, s_cp2), Write(labels2_cp), Write(l))\n        r1 = BackgroundRectangle(VGroup(labels2_cp[-2], s_cp2[-2]), buff=0.15)\n        r2 = BackgroundRectangle(VGroup(labels2_cp[1], s_cp2[1]), buff=0.15)\n        self.play(ShowCreation(r1), ShowCreation(r2))\n        self.wait()\n        self.play(Uncreate(VGroup(eqs, l)))\n        s_cp, labels2_cp2 = (s2.deepcopy(), labels2_cp.deepcopy())\n        for i, x in enumerate(np.linspace(3, -3, 6)):\n            labels2_cp2[i].move_to(x * UP)\n            s_cp[i].move_to(x * UP)\n        s_cp.shift(6 * LEFT)\n        labels2_cp2.shift(4.5 * LEFT)\n        axes = Axes(x_range=(0, 6), y_range=(-2, 6), axis_config={'include_tip': False}, x_axis_config={'stroke_width': 3}, y_axis_config={'stroke_width': 3}, width=9)\n        axes.shift(2 * RIGHT)\n        Indicate\n        r1_2 = BackgroundRectangle(VGroup(labels2_cp2[-2], s_cp[-2]), buff=0.15)\n        r2_2 = BackgroundRectangle(VGroup(labels2_cp2[1], s_cp[1]), buff=0.15)\n        self.play(Transform(s2, s_cp), Transform(labels2_cp, labels2_cp2), Transform(r1, r1_2), Transform(r2, r2_2))\n        coors = [(0, 2), (2, 3), (3, 1), (5, 2)]\n        dots, labels = (VGroup(), VGroup())\n        for x, y in coors:\n            dots.add(Dot(axes.c2p(x, y), color=A_GREEN))\n            labels.add(Tex(f'({x}, {y})', tex_to_color_map={str(x): A_ORANGE, str(y): A_ORANGE}).move_to(dots[-1], DOWN).shift(0.25 * DOWN).add_background_rectangle(buff=0.1))\n        labels.shift(0.5 * DOWN)\n        curve = ParametricCurve(lambda t: axes.c2p(t, self.f(t)), t_range=(0, 6), color=A_GREEN)\n        self.play(Write(axes))\n        left = [0, 2, 3, 5]\n        grp = VGroup(*self.get_indices(labels2_cp, left))\n        self.play(TransformFromCopy(grp, dots))\n        self.play(Write(labels))\n        self.wait()\n        self.play(Write(curve))\n        self.bring_to_front(labels)\n        x = ValueTracker(0)\n        d = Dot(radius=2 * DEFAULT_DOT_RADIUS, color=A_YELLOW)\n        d.move_to(axes.c2p(x.get_value(), self.f(x.get_value())))\n\n        def point_updater(point):\n            new_point = point.move_to(axes.c2p(x.get_value(), self.f(x.get_value())))\n            point.become(new_point)\n        l1 = Line()\n\n        def dash_updater_x(line):\n            point = axes.c2p(x.get_value(), self.f(x.get_value()))\n            new_line = Line(axes.c2p(0, self.f(x.get_value())), point, stroke_opacity=0.5)\n            line.become(new_line)\n            self.bring_to_back(line)\n        l2 = Line()\n\n        def dash_updater_y(line):\n            point = axes.c2p(x.get_value(), self.f(x.get_value()))\n            new_line = Line(axes.c2p(x.get_value(), 0), point, stroke_opacity=0.5)\n            line.become(new_line)\n            self.bring_to_back(line)\n        self.play(Write(d))\n        d.add_updater(point_updater)\n        l1.add_updater(dash_updater_x)\n        l2.add_updater(dash_updater_y)\n        self.wait()\n        lbl = Tex(f'(1, 4)', tex_to_color_map={'1': A_ORANGE, '4': A_ORANGE}).move_to(Point(axes.c2p(1, 4)), DOWN).shift(0.25 * UP).add_background_rectangle(buff=0.1)\n        self.play(Indicate(VGroup(d, labels[0][1:])))\n        self.play(TransformFromCopy(d, s_cp[0]))\n        self.wait()\n        self.play(x.increment_value, 1, run_time=3)\n        self.play(Write(lbl))\n        self.play(Indicate(VGroup(d, lbl[1:])))\n        self.play(TransformFromCopy(d, s_cp[1]), Uncreate(r2))\n        self.wait()\n        self.play(x.increment_value, 1, run_time=3)\n        self.play(Indicate(VGroup(d, labels[1][1:])))\n        self.play(TransformFromCopy(d, s_cp[2]))\n        self.wait()\n        self.play(x.increment_value, 1, run_time=3)\n        self.play(Indicate(VGroup(d, labels[2][1:])))\n        self.play(TransformFromCopy(d, s_cp[3]))\n        s = VGroup()\n        for i in range(4):\n            s_i = NumberSquare(numbers[i], shades[c[i]], side_length=1, num_scale=1.5)\n            s.add(s_i.shift(1.5 * i * RIGHT))\n        s.center()\n        s.move_to(3 * UP)\n        m = {'{5}': A_ORANGE, **{str(i): A_YELLOW for i in list(range(5)) + list(range(6, 10)) + [56]}, 'f': A_GREEN, 'x': A_PINK}\n        eq = Tex('f(x) = 2x^3 + 2 \\\\mod {{5}}', tex_to_color_map=m)\n        eq.scale(1.5)\n        eq.shift(1.5 * UP)\n        eqs, eqs2 = (VGroup(), VGroup())\n        for i, y in enumerate(numbers[:-2]):\n            mod_eq = Tex(f'f({i}) = {2 * i ** 3 + 2} \\\\mod {{5}}', tex_to_color_map=m)\n            mod_eq.scale(1.5)\n            mod_eq.move_to(6 * LEFT, LEFT)\n            mod_eq.shift(i * DOWN)\n            eqs.add(mod_eq)\n            mod_eq2 = Tex(f'f({i}) = {(2 * i ** 3 + 2) % 5} \\\\mod {{5}}', tex_to_color_map=m)\n            mod_eq2.scale(1.5)\n            mod_eq2.move_to(6 * LEFT, LEFT)\n            mod_eq2.shift(i * DOWN)\n            eqs2.add(mod_eq2)\n        remove_grp = VGroup(axes, d, curve, dots, lbl, labels2_cp2, labels, labels2_cp, s_cp, *s2[-2:], l1, l2)\n        self.play(FadeOut(remove_grp))\n        self.remove(*self.mobjects[:2])\n        self.wait()\n        self.play(Transform(s2[:-2], s))\n        self.wait()\n        self.play(Write(eq))\n        self.wait()\n        self.play(Write(eqs[0]))\n        self.wait(1)\n        self.play(Write(eqs[1]))\n        self.wait(1)\n        self.play(Write(eqs[2]))\n        self.play(TransformMatchingTex(eqs[2], eqs2[2]))\n        self.wait(1)\n        self.play(Write(eqs[3]))\n        self.play(TransformMatchingTex(eqs[3], eqs2[3]))\n        self.wait(1)\n        eqs_right1 = Tex('f(4) = 0 \\\\mod 5', tex_to_color_map={'5': A_ORANGE, '0': A_YELLOW, '4': A_YELLOW, 'f': A_GREEN})\n        eqs_right1.scale(1.5)\n        eqs_right1.move_to(6 * LEFT + FRAME_WIDTH / 2 * RIGHT, LEFT)\n        eqs_right2 = Tex('f(5) = 2 \\\\mod {{5}}', tex_to_color_map={'5': A_YELLOW, '{5}': A_ORANGE, '2': A_YELLOW, '4': A_YELLOW, 'f': A_GREEN})\n        eqs_right2.scale(1.5)\n        eqs_right2.move_to(6 * LEFT + FRAME_WIDTH / 2 * RIGHT + 1 * DOWN, LEFT)\n        s_11 = VGroup()\n        for i in range(5):\n            s_i = NumberSquare(numbers[i], shades[c[i]], side_length=1, num_scale=1.5)\n            s_11.add(s_i.shift(1.5 * i * RIGHT))\n        s_11.center()\n        s_11.shift(3 * UP)\n        s = s2[:-2]\n        self.play(Transform(s, s_11[:-1]), Write(s_11[-1]))\n        self.wait()\n        s_12 = NumberSquare(0, shades[c[4]], side_length=1, num_scale=1.5)\n        s_12.move_to(s_11[-1])\n        self.play(Write(eqs_right1))\n        self.play(TransformFromCopy(eqs_right1[4], s_12), Uncreate(s_11[-1]))\n        self.wait()\n        s_21 = VGroup()\n        for i in range(6):\n            s_i = NumberSquare(numbers2[i], shades[c[i]], side_length=1, num_scale=1.5)\n            s_21.add(s_i.shift(1.5 * i * RIGHT))\n        s_21.center()\n        s_21.shift(3 * UP)\n        s_22 = NumberSquare(2, shades[c[5]], side_length=1, num_scale=1.5)\n        s_22.move_to(s_21[-1])\n        self.play(Transform(s, s_21[:-2]), ApplyMethod(s_12.move_to, s_21[-2]), Write(s_21[-1]))\n        self.wait()\n        self.play(Write(eqs_right2))\n        self.play(TransformFromCopy(eqs_right2[4], s_22), Uncreate(s_21[-1]))\n        self.wait()\n        self.play(FadeOut(eq))\n        r1 = BackgroundRectangle(s_21[0], buff=0.15, fill_opacity=0.85)\n        r2 = BackgroundRectangle(s_22, buff=0.15, fill_opacity=0.85)\n        r3 = BackgroundRectangle(eqs[0], buff=0.15, fill_opacity=0.85)\n        r4 = BackgroundRectangle(eqs_right2, buff=0.15, fill_opacity=0.85)\n        self.play(Write(VGroup(r1, r3)))\n        self.play(Write(VGroup(r2, r4)))\n        self.wait()\n        self.play(TransformFromCopy(VGroup(eqs[1:], eqs_right1), eq))\n        self.wait()\n        self.play(TransformFromCopy(eq, s_21[0]))\n        self.play(Uncreate(r3))\n        self.wait()\n        self.embed()\n\n    @staticmethod\n    def get_indices(arr, indices):\n        return [arr[i] for i in indices]\n\n    @staticmethod\n    def f(x):\n        return 1 / 3 * x ** 3 - 5 / 2 * x ** 2 + 25 / 6 * x + 2"}]}
{"messages": [{"role": "user", "content": "Create a visual representation of binary code with a sequence of numbered colored squares overlaid."}, {"role": "assistant", "content": "from manimlib import *\n\nclass Thumbnail(Scene):\n\n    def construct(self):\n        grp = VGroup()\n        for i, x in enumerate(np.linspace(-FRAME_WIDTH / 2, FRAME_WIDTH / 2, 50)):\n            grp.add(TexText(''.join([str(random.randint(0, 1)) for i in range(200)]), color=GREY, stroke_opaicity=0.5, fill_opacity=0.5))\n            grp[i].move_to(x * UP).scale(0.5)\n        shades = ['#ca7a72', '#c97066', '#c9665b', '#b55c52', '#a15249']\n        numbers = [2, 4, 3, 1, '?', '?']\n        c = [2, 4, 0, 4, 1, 3]\n        s2 = VGroup()\n        for i in range(5):\n            s_i = NumberSquare(numbers[i], shades[c[i]], side_length=1, num_scale=1.5, opacity=1)\n            s2.add(s_i.shift(1.5 * i * RIGHT))\n        s2.scale(1.875)\n        s2.center()\n        self.add(grp, s2)\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Animate a paint bucket SVG and accompanying text indicating a variable in a real number set."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        bucket = SVGMobject(file_name='files/paint-bucket.svg', color=YELLOW)\n        bucket.scale(1.3)\n        tex = TexMobject('V \\\\in R')\n        tex.scale(1.5)\n        tex.shift(2 * UP)\n        self.play(Write(bucket))\n        self.play(Write(tex))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a 3D animation of the function y=1/x revolved around the x-axis."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Revolution(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes()\n        f1 = FunctionGraph(lambda x: 1 / x, x_min=0.1)\n        f2 = FunctionGraph(lambda x: 1 / x, x_max=-0.1, x_min=-10)\n        func = VGroup(f1, f2)\n        func2 = FunctionGraph(lambda x: 1 / x, x_min=1)\n        surface = ParametricSurface(self.surface, u_min=1, u_max=10, v_min=0, v_max=0.001, checkerboard_colors=[eval(key) for key in COLOR_MAP.keys()], fill_color=YELLOW, stroke_color=YELLOW)\n        self.play(Write(func), Write(axes))\n        self.wait()\n        self.play(Transform(f1, func2), Uncreate(f2), Write(surface))\n        self.wait()\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.remove(f1)\n        self.begin_ambient_camera_rotation(rate=0.04)\n        self.play(UpdateFromAlphaFunc(surface, self.update_f), rate_func=linear, run_time=2)\n        self.play(Uncreate(axes), surface.center)\n        self.wait(5)\n\n    def update_f(self, c, dt):\n        a = interpolate(0.1, 2 * PI, dt)\n        s = ParametricSurface(self.surface, u_min=1, u_max=10, v_min=0, v_max=a, checkerboard_colors=[eval(key) for key in COLOR_MAP.keys()], color=YELLOW, fill_color=YELLOW)\n        c.become(s)\n\n    @staticmethod\n    def surface(u, v):\n        return np.array([u, 1 / u * np.cos(v), 1 / u * np.sin(v)])"}]}
{"messages": [{"role": "user", "content": "Visualize a parametric surface, then a disk transforming into a different disk, and finally a circle."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Volume(ThreeDScene):\n\n    def construct(self):\n        surface = ParametricSurface(self.func, u_min=1, u_max=10, v_min=0, v_max=2 * PI, checkerboard_colors=[eval(key) for key in COLOR_MAP.keys()])\n        surface.center()\n        disk = ParametricSurface(self.disk, u_min=0, u_max=2 * PI, v_min=-1 / 3, v_max=1 / 3, checkerboard_colors=[RED, ORANGE])\n        disk2 = ParametricSurface(self.disk2, u_min=0, u_max=2 * PI, v_min=-2.5, v_max=2.5, checkerboard_colors=[RED, ORANGE])\n        circle = VGroup(ParametricFunction(self.circle, t_min=0, t_max=2 * PI, color=YELLOW, stroke_width=0.5 * DEFAULT_STROKE_WIDTH), ParametricFunction(lambda t: np.array([0, 0, t]), t_min=0, t_max=2.5, color=YELLOW, stroke_width=2 * DEFAULT_STROKE_WIDTH))\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.play(Write(surface))\n        self.begin_ambient_camera_rotation()\n        self.wait()\n        surface.set_fill(opacity=0.5)\n        surface.set_stroke(opacity=0.5)\n        self.wait()\n        self.play(Write(disk))\n        self.wait()\n        self.stop_ambient_camera_rotation()\n        self.play(Uncreate(surface))\n        self.move_camera(phi=90 * DEGREES, theta=0 * DEGREES)\n        self.play(Transform(disk, disk2))\n        self.wait()\n        self.play(Write(circle))\n        self.wait()\n\n    @staticmethod\n    def func(u, v):\n        return np.array([u, 1 / u * np.cos(v), 1 / u * np.sin(v)])\n\n    @staticmethod\n    def disk(u, v):\n        return np.array([-2, v * np.cos(u), v * np.sin(u)])\n\n    @staticmethod\n    def disk2(u, v):\n        return np.array([0, v * np.cos(u), v * np.sin(u)])\n\n    @staticmethod\n    def circle(t, r=2.5):\n        return r * np.array([0, np.cos(t), np.sin(t)])"}]}
{"messages": [{"role": "user", "content": "Show the evaluation of an improper integral by transforming the integral expression through its steps and highlighting the final answer with a box."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass VolumeEval(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\int_1^{\\\\infty} \\\\pi \\\\left( \\\\frac{1}{x} \\\\right)^2 dx', tex_to_color_map={'\\\\left( \\\\frac{1}{x} \\\\right)^2': RED, '\\\\pi': GREEN, '_1^t': BLUE})\n        eq1.scale(1.5)\n        eq2 = TexMobject('\\\\lim_{t \\\\rightarrow \\\\infty} \\\\int_1^{t} \\\\pi \\\\left( \\\\frac{1}{x} \\\\right)^2 dx', tex_to_color_map={'\\\\left( \\\\frac{1}{x} \\\\right)^2': RED, '\\\\pi': GREEN, '_1^{t}': BLUE})\n        eq2.scale(1.5)\n        eq3 = TexMobject('= \\\\pi \\\\lim_{t \\\\rightarrow \\\\infty} \\\\left ( \\\\frac{-1}{x} \\\\right ) \\\\Big |_1^t', tex_to_color_map={'\\\\left ( \\\\frac{-1}{x} \\\\right )': RED, '\\\\pi': GREEN, '_1^t': BLUE})\n        eq3.scale(1.5)\n        eq4 = TexMobject('= \\\\pi \\\\lim_{t \\\\rightarrow \\\\infty} \\\\frac{-1}{t} + 1', tex_to_color_map={'\\\\left( \\\\frac{1}{x} \\\\right)^2': RED, '\\\\pi': GREEN, '_1^t': BLUE})\n        eq4.scale(1.5)\n        eq4.shift(2.5 * DOWN)\n        ans = TexMobject('\\\\pi')\n        ans.scale(1.5)\n        ans.shift(2.5 * DOWN)\n        rect = Rectangle(height=1, width=1, color=YELLOW)\n        rect.shift(2.5 * DOWN)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Transform(eq1, eq2))\n        self.wait()\n        self.play(eq1.shift, 2.5 * UP)\n        self.wait()\n        self.play(Write(eq3))\n        self.wait()\n        self.play(Write(eq4))\n        self.wait()\n        self.play(Transform(eq4, ans), Write(rect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render a horn and frustum 3D surfaces, animating their creation, transformation, and destruction while adding labels for coordinate axes."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SurfaceArea(ThreeDScene):\n\n    def construct(self):\n        frustum = ParametricSurface(self.frustum, u_min=0, u_max=2 * PI, v_min=1, v_max=3, checkerboard_colors=[])\n        horn = ParametricSurface(self.horn, u_min=1, u_max=10, v_min=0, v_max=2 * PI, checkerboard_colors=[eval(key) for key in COLOR_MAP.keys()], stroke_opacity=0)\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.begin_ambient_camera_rotation()\n        self.play(Write(horn))\n        self.wait()\n        self.play(Write(frustum))\n        self.wait()\n        self.play(Uncreate(horn))\n        self.play(frustum.center)\n        self.play(frustum.rotate, 0)\n        self.wait()\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES)\n        self.play(frustum.scale, 2)\n        self.wait()\n        l = Line(2.2 * LEFT, 2 * RIGHT, color=YELLOW, stroke_width=1.5 * DEFAULT_STROKE_WIDTH).shift(0.667 * UP)\n        lbl1 = TexMobject('dx')\n        lbl1.move_to(l)\n        lbl1.shift(0.5 * DOWN)\n        l2 = Line(0.667 * UP, 2.1 * UP, color=RED, stroke_width=1.5 * DEFAULT_STROKE_WIDTH).shift(2.2 * LEFT)\n        lbl2 = TexMobject('dy')\n        lbl2.move_to(l2)\n        lbl2.shift(0.5 * LEFT)\n        l3 = Line(2 * RIGHT + 0.667 * UP, 2.2 * LEFT + 2.1 * UP, color=PURPLE, stroke_width=1.5 * DEFAULT_STROKE_WIDTH)\n        lbl3 = TexMobject('ds')\n        lbl3.move_to(l3)\n        lbl3.shift(0.5 * UP)\n        self.play(Write(l))\n        self.play(Write(lbl1))\n        self.wait()\n        self.play(Write(l2))\n        self.play(Write(lbl2))\n        self.wait()\n        self.play(Write(l3))\n        self.play(Write(lbl3))\n        self.wait()\n\n    @staticmethod\n    def frustum(u, v, r=1 / 3):\n        return np.array([-v - 1, r * v * np.cos(u), r * v * np.sin(u)])\n\n    @staticmethod\n    def horn(u, v):\n        return np.array([u - 5, 1 / u * np.cos(v), 1 / u * np.sin(v)])"}]}
{"messages": [{"role": "user", "content": "Display a series of mathematical expressions transforming one into another, illustrating a calculus integral evaluation, culminating in the answer infinity."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SurfaceEval(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\int_{1}^{\\\\infty} 2\\\\pi\\\\frac{1}{x}ds', tex_to_color_map={'\\\\frac{1}{x}': RED, 'ds': YELLOW, '2\\\\pi': GREEN, '_1^t': BLUE})\n        eq1.scale(1.5)\n        eq1b = TexMobject('\\\\int_{1}^{\\\\infty} 2\\\\pi\\\\frac{1}{x} \\\\sqrt{1+\\\\left ( \\\\frac{-1}{x^2} \\\\right )^2} dx', tex_to_color_map={'\\\\frac{1}{x}': RED, '2\\\\pi': GREEN, '_1^t': BLUE, '\\\\sqrt{1+\\\\left ( \\\\frac{-1}{x^2} \\\\right )^2}': YELLOW})\n        eq1b.scale(1.5)\n        eq2 = TexMobject('\\\\int_{1}^{\\\\infty} 2\\\\pi\\\\frac{1}{x} \\\\sqrt{1+\\\\left ( \\\\frac{-1}{x^2} \\\\right )^2} dx \\\\geq \\\\int_{1}^{\\\\infty} 2\\\\pi\\\\frac{1}{x}dx', tex_to_color_map={'\\\\frac{1}{x}': RED, '2\\\\pi': GREEN, '_1^t': BLUE, '\\\\sqrt{1+\\\\left ( \\\\frac{-1}{x^2} \\\\right )^2}': YELLOW})\n        eq2.scale(1.5)\n        eq2b = TexMobject('\\\\int_{1}^{\\\\infty} 2\\\\pi\\\\frac{1}{x}dx', tex_to_color_map={'\\\\frac{1}{x}': RED, '2\\\\pi': GREEN, '_1^t': BLUE, '\\\\sqrt{1+\\\\left ( \\\\frac{-1}{x^2} \\\\right )^2}': YELLOW})\n        eq2b.scale(1.5)\n        eq2c = TexMobject('\\\\lim_{t \\\\rightarrow \\\\infty} \\\\int_{1}^{t} 2\\\\pi\\\\frac{1}{x}dx', tex_to_color_map={'\\\\frac{1}{x}': RED, '2\\\\pi': GREEN, '_{1}^{t}': BLUE, '\\\\sqrt{1+\\\\left ( \\\\frac{-1}{x^2} \\\\right )^2}': YELLOW})\n        eq2c.scale(1.5)\n        eq3 = TexMobject('= 2\\\\pi \\\\lim_{t \\\\rightarrow \\\\infty} \\\\ln(x) \\\\Big |_1^t', tex_to_color_map={'\\\\left ( \\\\frac{-1}{x} \\\\right )': RED, '2\\\\pi': GREEN, '_1^t': BLUE})\n        eq3.scale(1.5)\n        eq4 = TexMobject('= 2\\\\pi \\\\lim_{t \\\\rightarrow \\\\infty} \\\\ln(t)', tex_to_color_map={'\\\\left( \\\\frac{1}{x} \\\\right)^2': RED, '2\\\\pi': GREEN, '_1^t': BLUE})\n        eq4.scale(1.5)\n        eq4.shift(2.5 * DOWN)\n        ans = TexMobject('\\\\infty')\n        ans.scale(1.5)\n        ans.shift(2.5 * DOWN)\n        rect = Rectangle(height=1, width=1, color=YELLOW)\n        rect.shift(2.5 * DOWN)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Transform(eq1, eq1b))\n        self.wait()\n        self.play(Transform(eq1, eq2))\n        self.wait()\n        self.play(Transform(eq1, eq2b))\n        self.wait()\n        self.play(Transform(eq1, eq2c))\n        self.wait()\n        self.play(eq1.shift, 2.5 * UP)\n        self.wait()\n        self.play(Write(eq3))\n        self.wait()\n        self.play(Write(eq4))\n        self.wait()\n        self.play(Transform(eq4, ans), Write(rect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the convergence of a geometric series on a number line and show its sum."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TwoConverge(Scene):\n\n    def construct(self):\n        line = NumberLine(include_numbers=True, x_min=-5, x_max=10, unit_size=6, tick_frequency=0.25, decimal_number_config={'num_decimal_places': 1}, scale_factor=0.5)\n        line.numbers = [DecimalNumber(number=i.number * 0.5) for i in line.numbers]\n        line.add_numbers()\n        line.shift(6 * LEFT)\n        s = Line(6 * LEFT, ORIGIN, stroke_width=2 * DEFAULT_STROKE_WIDTH, color=YELLOW)\n        eq1 = TexMobject('\\\\sum_{n=1}^{\\\\infty} \\\\frac{1}{2^n}')\n        eq1.shift(2 * UP)\n        eq1.scale(1.5)\n        eq2 = TexMobject('\\\\sum_{n=1}^{\\\\infty} \\\\frac{1}{2^n} = 1')\n        eq2.shift(2 * UP)\n        eq2.scale(1.5)\n        self.play(Write(line))\n        self.play(Write(eq1))\n        for i in range(1, 10):\n            val = sum([1 / 2 ** n for n in range(i)])\n            s = Line(6 * LEFT, 6 * LEFT + 6 * val * RIGHT, stroke_width=2 * DEFAULT_STROKE_WIDTH, color=YELLOW)\n            self.add(s)\n            self.wait(0.5)\n        self.wait()\n        self.play(Transform(eq1, eq2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate a 3D parametric surface resembling a horn, animate its creation, and then rotate the camera around it."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Horn(ThreeDScene):\n\n    def construct(self):\n        surface = ParametricSurface(self.func, u_min=1, u_max=10, v_min=0, v_max=2 * PI, checkerboard_colors=[eval(key) for key in COLOR_MAP.keys()], stroke_opacity=0)\n        surface.center()\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.play(Write(surface))\n        self.begin_ambient_camera_rotation(rate=0.04)\n        self.wait(20)\n\n    @staticmethod\n    def func(u, v):\n        return np.array([u, 1 / u * np.cos(v), 1 / u * np.sin(v)])"}]}
{"messages": [{"role": "user", "content": "Display the text \"Evangelista Torricelli\" scaled up and write it to the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Torricelli(Scene):\n\n    def construct(self):\n        text = TextMobject('Evangelista Torricelli')\n        text.scale(2)\n        self.play(Write(text))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a given text with a larger font size and fade it in."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TextScene(Scene):\n\n    def construct(self):\n        text = TexMobject(self.text)\n        text.scale(2)\n        self.play(Write(text))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show the arc length formula transforming from its initial form to a simplified version."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Ds(Scene):\n\n    def construct(self):\n        text = TexMobject('ds = \\\\sqrt{dx^2 + dy^2}')\n        text.scale(2)\n        text2 = TexMobject('ds = \\\\sqrt{1 + (dy/dx)^2 }')\n        text2.scale(2)\n        self.play(Write(text))\n        self.wait()\n        self.play(Transform(text, text2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate a pentagonal fractal by sequentially transforming it to higher orders."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass FractalCreation(Scene):\n    CONFIG = {'fractal_class': PentagonalFractal, 'max_order': 5, 'transform_kwargs': {'path_arc': np.pi / 6, 'lag_ratio': 0.5, 'run_time': 2}, 'fractal_kwargs': {}}\n\n    def construct(self):\n        fractal = self.fractal_class(order=0, **self.fractal_kwargs)\n        self.play(FadeIn(fractal))\n        for order in range(1, self.max_order + 1):\n            new_fractal = self.fractal_class(order=order, **self.fractal_kwargs)\n            fractal.align_data(new_fractal)\n            self.play(Transform(fractal, new_fractal, **self.transform_kwargs))\n            self.wait()\n        self.wait()\n        self.fractal = fractal"}]}
{"messages": [{"role": "user", "content": "Animate a parametric surface representing a tube-like shape with checkerboard coloring, orbiting the camera."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Thumb(ThreeDScene):\n\n    def construct(self):\n        surface = ParametricSurface(self.func, u_min=1, u_max=10, v_min=0, v_max=2 * PI, checkerboard_colors=[eval(key) for key in COLOR_MAP.keys()], stroke_opacity=0)\n        surface.center()\n        self.move_camera(0.9 * np.pi / 2, -0.45 * np.pi)\n        self.play(Write(surface))\n        self.begin_ambient_camera_rotation(rate=-0.04)\n        self.wait(20)\n\n    @staticmethod\n    def func(u, v):\n        return np.array([u, 1 / u * np.cos(v), 1 / u * np.sin(v)])"}]}
{"messages": [{"role": "user", "content": "Display a horizontal line, then write \"Brought to you by\", show a Patreon logo and Twitter/Instagram logos with usernames, followed by a scrolling list of patron names."}, {"role": "assistant", "content": "from manimlib import *\n\nclass Outro(Scene):\n\n    def construct(self):\n        line = Line(12 * UP, 12 * DOWN)\n        btxt = TexText('Brought to you by', color=RED)\n        btxt.scale(1.25)\n        btxt.shift(FRAME_WIDTH / 4 * LEFT + 0.5 * RIGHT + 3.25 * UP)\n        plogo = SVGMobject('./img/Patreon_logomark.svg')\n        plogo.scale(0.3)\n        plogo.shift(3.25 * UP + 6.25 * LEFT)\n        plogo[-2].set_color('#f86754')\n        plogo[-1].set_color(BLUE_E)\n        t = ImageMobject('img/twitter.png')\n        t.scale(0.35)\n        t.shift(3 * DOWN + 1.5 * RIGHT)\n        i = ImageMobject('img/instagram.png')\n        i.scale(0.35)\n        i.next_to(t, RIGHT)\n        t_text = TexText('@vcubingx')\n        t_text.next_to(i, RIGHT)\n        self.play(Write(line))\n        self.play(Write(btxt), Write(plogo), FadeIn(t), FadeIn(i), Write(t_text))\n        old_patreons = None\n        list_of_patreons = open('patreon.txt').read().split('\\n')\n        for i in split_into(list_of_patreons, 20):\n            patreons = VGroup()\n            for name, pos in zip(i, np.linspace(FRAME_HEIGHT / 2 - 0.5, -FRAME_HEIGHT / 2 + 0.5, num=20)):\n                patreons.add(TexText(name, tex_to_color_map={} if name != '3blue1brown' else {'blue': BLUE, 'brown': '#CD853F'}).move_to([0, pos, 0]).scale(0.65))\n            patreons.center()\n            patreons.shift(FRAME_WIDTH / 4 * LEFT + 0.5 * DOWN)\n            if not old_patreons:\n                self.play(Write(patreons))\n                old_patreons = patreons\n            else:\n                self.play(Transform(old_patreons, patreons))\n            self.wait(5)\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display a large colored mathematical expression followed by a smaller text label below it."}, {"role": "assistant", "content": "from manimlib import *\n\nclass NewIntro(Scene):\n\n    def construct(self):\n        h1 = '#ff5757'\n        h2 = '#5ce1e6'\n        text = Tex('\\\\textbf{\\\\text{v}} ^3 \\\\textbf{\\\\text{(}}\\\\textbf{\\\\text{x}}\\\\textbf{\\\\text{)}}}', tex_to_color_map={'\\\\textbf{\\\\text{v}} ^3': h1, '\\\\textbf{\\\\text{x}}': h2})\n        text.scale(4)\n        vc = TexText('vcubingx')\n        vc.scale(1.5)\n        vc.shift(2 * DOWN)\n        self.play(Write(text), run_time=2)\n        self.play(FadeIn(vc))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display a Wren logo and the text \"Sponsored by\" on the screen."}, {"role": "assistant", "content": "from manimlib import *\n\nclass IntroW(Scene):\n\n    def construct(self):\n        wren = SVGMobject('img/wren-logo.svg')\n        wren.rotate(180 * DEGREES)\n        wren.shift(DOWN)\n        text = TexText('Sponsored by')\n        text.shift(UP)\n        text.scale(3)\n        text.stretch(-1, 0)\n        self.play(Write(wren), Write(text))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Create a grid of purple upward-pointing vectors."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        v = VGroup(*[Vector([0, 1, 0], color=PURPLE).shift([x, y, 0]) for x in np.arange(-9, 8, 0.75) for y in np.arange(-4, 4, 1.5)])\n        self.play(Write(v))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the Navier-Stokes equations with a title and write them on screen."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Equations(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\nabla \\\\cdot {u} = 0', tex_to_color_map=color_map)\n        eq1.scale(1.5)\n        eq1.shift(1 * UP)\n        eq2 = TexMobject('\\\\rho {{d {u} } \\\\over {d {t} }} = -\\\\nabla {p} + \\\\mu \\\\nabla^2 {u} + \\\\textbf{F}', tex_to_color_map=color_map)\n        eq2.scale(1.5)\n        eq2.shift(1 * DOWN)\n        title = Text('Navier-Stokes Equations', color=GREEN)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        self.play(FadeInFromDown(title))\n        self.play(Write(eq1))\n        self.play(Write(eq2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present the Millenium Prize Problems title and list, then sequentially fade out all but the first three problems."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass MilleniumPrize(Scene):\n\n    def construct(self):\n        title = Text('Millenium Prize Problems', color=PURPLE)\n        title.scale(1.25)\n        title.shift(3 * UP)\n        l = NumberedList(*'Yang\u2013Mills and Mass Gap\\nRiemann Hypothesis\\nP vs NP Problem\\nExistence and smoothness of the Navier-Stokes equation\\nHodge Conjecture\\nPoincare Conjecture\\nBirch and Swinnerton-Dyer Conjecture'.split('\\n'))\n        l.scale(0.75)\n        l.shift(0.5 * DOWN)\n        self.play(FadeInFromDown(title))\n        self.play(Write(l))\n        self.wait()\n        self.play(l.fade_all_but, 3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display three screen rectangles in a triangular arrangement, revealing them one by one."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ApplicationsOne(Scene):\n\n    def construct(self):\n        rect1 = ScreenRectangle(height=3.5)\n        rect2 = ScreenRectangle(height=3.5)\n        rect3 = ScreenRectangle(height=3.5)\n        rect1.shift(2 * UP + 3.5 * LEFT)\n        rect2.shift(2 * UP + 3.5 * RIGHT)\n        rect3.shift(2 * DOWN)\n        self.play(Write(rect1))\n        self.wait()\n        self.play(Write(rect2))\n        self.wait()\n        self.play(Write(rect3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present a title and a bulleted list of assumptions, then sequentially highlight each assumption."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Assumptions(Scene):\n\n    def construct(self):\n        title = Text('Assumptions for this video', color=PURPLE)\n        title.scale(1.25)\n        title.shift(3 * UP)\n        l = BulletedList('Newtonian', 'Incompressible', 'Isothermal', dot_color=BLUE, buff=0.75 * LARGE_BUFF)\n        l.scale(1.5)\n        l.shift(0.25 * DOWN)\n        self.play(FadeInFromDown(title))\n        self.play(Write(l))\n        self.wait()\n        self.play(l.fade_all_but, 0)\n        self.wait()\n        self.play(l.fade_all_but, 1)\n        self.wait()\n        self.play(l.fade_all_but, 2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the difference between Newtonian and non-Newtonian fluids by plotting their respective viscosity curves on a graph."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Newtonian(Scene):\n\n    def construct(self):\n        title = Text('Newtonian Fluid', color=GOLD)\n        title.scale(1.5)\n        title.shift(3.25 * UP)\n        axes = Axes(x_min=0, x_max=6, y_min=0, y_max=5, axis_config={'include_tip': False})\n        f1 = FunctionGraph(self.f1, x_min=0, x_max=6, color=TEAL)\n        f2 = FunctionGraph(self.f2, x_min=1 / 25, x_max=6, color=RED)\n        xlbl = Text('Shear Rate')\n        xlbl.shift(3 * DOWN)\n        grpp = VGroup(axes, f1, f2)\n        grpp.center()\n        f2.shift(2.75 * LEFT)\n        grp = VGroup(axes, f1)\n        ylbl = Text('Viscosity')\n        ylbl.rotate(PI / 2)\n        ylbl.shift(3.5 * LEFT + 0 * UP)\n        grp1 = VGroup(grp, xlbl, ylbl)\n        grp1.shift(0.25 * DOWN)\n        lbl1 = Text('Newtonian', color=TEAL)\n        lbl1.scale(0.75)\n        lbl1.move_to(f1, RIGHT)\n        lbl1.shift(3 * LEFT + 0.5 * UP)\n        lbl2 = Text('Non-Newtonian', color=RED)\n        lbl2.scale(0.75)\n        lbl2.shift(1.5 * DOWN + 1 * LEFT)\n        self.play(FadeInFromDown(title))\n        self.play(Write(axes), FadeInFromDown(xlbl), FadeInFromDown(ylbl))\n        self.play(Write(f1), FadeInFromDown(lbl1))\n        self.wait()\n        self.play(grp1.shift, 2.75 * LEFT)\n        rect = ScreenRectangle(height=5, aspect_ratio=1)\n        rect.shift(3.75 * RIGHT + 0.15 * DOWN)\n        self.play(Write(rect))\n        self.bring_to_back(f2)\n        self.play(Write(f2), FadeInFromDown(lbl2))\n        self.wait()\n\n    @staticmethod\n    def f1(x):\n        return 3\n\n    @staticmethod\n    def f2(x):\n        return x ** (-0.5)"}]}
{"messages": [{"role": "user", "content": "Animate a title \"Incompressible\" and then show a water level rising and falling within a container."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Incompressible(Scene):\n\n    def construct(self):\n        title = Text('Incompressible', color=PURPLE)\n        title.scale(1.5)\n        title.shift(3.25 * UP)\n        self.play(FadeInFromDown(title))\n        s_width = 8\n        obj = VGroup(*[*[Line([i, 2, 0], [i, -2, 0], stroke_width=s_width) for i in [2, -2]], Line([-2, -2, 0], [2, -2, 0], stroke_width=s_width)])\n        t = ValueTracker(1)\n        obj2 = VGroup(*[Line([-2, 1, 0], [2, 1, 0], stroke_width=s_width), Line([0, 1, 0], [0, 2, 0], stroke_width=s_width), Rectangle(height=0.25, width=0.75, fill_opacity=1, color=YELLOW, stroke_width=s_width).shift([0, 2, 0])])\n        t2 = ValueTracker(1)\n        water = Polygon([-2, t.get_value(), 0], [2, t.get_value(), 0], [2, -2, 0], [-2, -2, 0], color=BLUE_E, fill_opacity=1)\n\n        def update_vgroup(grp):\n            grp.move_to(water, UP)\n            grp.shift(1.125 * UP)\n        obj2.add_updater(update_vgroup)\n\n        def update_func_water(water):\n            water2 = Polygon([-2, t.get_value(), 0], [2, t.get_value(), 0], [2, -2, 0], [-2, -2, 0], color=BLUE_E, fill_opacity=1)\n            water.become(water2)\n        water.add_updater(update_func_water)\n        self.play(Write(water), Write(obj), Write(obj2))\n        self.play(t.increment_value, -1, rate_func=there_and_back)\n        self.wait()\n        self.play(t.increment_value, -1, rate_func=there_and_back)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the text \"Incompressible\" appearing with an orange color and a screen rectangle being written."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Isothermal(Scene):\n\n    def construct(self):\n        title = Text('Incompressible', color=ORANGE)\n        title.scale(1.5)\n        title.shift(3.25 * UP)\n        rect = ScreenRectangle(height=5).shift(0.15 * DOWN)\n        self.play(FadeInFromDown(title))\n        self.play(Write(rect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the Navier-Stokes equations, remove one equation and the title, center and scale the remaining equation, separate its components, and then add braces and text labels to specific parts of the equation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Divergence(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\nabla', '\\\\cdot', '{u}', '=', '0', tex_to_color_map=color_map)\n        eq1.scale(1.5)\n        eq1.shift(1 * UP)\n        eq2 = TexMobject('\\\\rho {{d {u} } \\\\over {d {t} }} = -\\\\nabla {p} + \\\\mu \\\\nabla^2 {u} + \\\\textbf{F}', tex_to_color_map=color_map)\n        eq2.scale(1.5)\n        eq2.shift(1 * DOWN)\n        title = Text('Navier-Stokes Equations', color=GREEN)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        self.add(title, eq1, eq2)\n        self.wait()\n        self.play(Uncreate(title), Uncreate(eq2), ApplyMethod(eq1.center))\n        self.play(eq1.scale, 1.5)\n        self.play(*[ApplyMethod(eq1[i].move_to, [(i - 2) * 2, 0, 0]) for i in range(5)])\n        self.wait()\n        b1 = Brace(eq1[:2])\n        t1 = b1.get_text('Divergence')\n        b2 = Brace(eq1[2], direction=UP)\n        t2 = b2.get_text('Velocity Vector Field')\n        self.play(Write(VGroup(b1, t1)))\n        self.play(Write(VGroup(b2, t2)))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a vector field and its labels over a number plane with a title."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass VectorFieldDemo(Scene):\n\n    def construct(self):\n        plane = NumberPlane()\n        plane.set_opacity(0.5)\n        plane.add(plane.get_axis_labels())\n        field1 = VectorField(lambda t: 1.5 * np.array([np.cos(t[0]), np.sin(t[1]), 0]))\n        title = Text('Vector Field')\n        title.scale(2)\n        title.to_edge(UP)\n        title.add_background_rectangle()\n        self.play(ShowCreation(plane))\n        self.play(ShowCreation(field1))\n        self.play(Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate positive and negative divergence by transforming a vector field and its accompanying title."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DivergenceDemo(Scene):\n\n    def construct(self):\n        field = VectorField(lambda t: t / 3)\n        title = TexMobject('\\\\text{div} \\\\vec{\\\\text{F}} > 0', tex_to_color_map={'\\\\text{div}': YELLOW})\n        title.scale(2)\n        title.to_edge(UP)\n        title.add_background_rectangle()\n        self.play(Write(field))\n        self.wait()\n        self.play(Write(title))\n        self.wait()\n        field2 = VectorField(lambda t: -t / 3)\n        title2 = TexMobject('\\\\text{div} \\\\vec{\\\\text{F}} < 0', tex_to_color_map={'\\\\text{div}': YELLOW})\n        title2.scale(2)\n        title2.to_edge(UP)\n        title2.add_background_rectangle()\n        self.play(Transform(field, field2), Transform(title, title2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Write out the divergence theorem equation with specific terms highlighted."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DivergenceEq(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\n        \\\\text{div} \\\\vec{\\\\text{F}} = \\\\nabla \\\\cdot \\\\vec{\\\\text{F}} = \\n        \\\\begin{bmatrix}\\n        \\\\frac{\\\\partial}{\\\\partial x} \\\\\\\\\\n        \\\\frac{\\\\partial}{\\\\partial y} \\\\\\\\\\n        \\\\frac{\\\\partial}{\\\\partial z} \\\\\\\\\\n        \\\\end{bmatrix} \\\\cdot \\\\vec{\\\\text{F}}\\n        ', tex_to_color_map={'\\\\text{div}': YELLOW, '\\\\nabla': RED})\n        eq.scale(2)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display and animate the Navier-Stokes equations, introducing Newton's second law and labeling terms with explanations."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SecondEq(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\nabla', '\\\\cdot', '{u}', '=', '0', tex_to_color_map=color_map)\n        eq1.scale(1.5)\n        eq1.shift(1 * UP)\n        eq2 = TexMobject('\\\\rho {{d {u} } \\\\over {d {t} }} = ', '-\\\\nabla {p}', ' + ', '\\\\mu \\\\nabla^2 {u}', ' + ', '\\\\textbf{F}', tex_to_color_map=color_map)\n        eq2.scale(1.5)\n        eq2.shift(1 * DOWN)\n        title = Text('Navier-Stokes Equations', color=GREEN, font='Berlin Sans FB')\n        title.scale(1.5)\n        title.shift(3 * UP)\n        self.add(title, eq1, eq2)\n        self.wait()\n        eq3 = TexMobject('\\\\text{m}', '{a}', '=', '\\\\Sigma F', tex_to_color_map={'F': YELLOW, '{a}': GREEN})\n        eq3.scale(1.5)\n        eq3.shift(1.5 * UP + 2.07 * LEFT)\n        self.play(Uncreate(title), Uncreate(eq1))\n        self.play(ApplyMethod(eq2.shift, 0.5 * DOWN), Write(eq3))\n        self.wait()\n        eq2cp = TexMobject('\\\\rho {{d {u} } \\\\over {d {t} }}', ' = ', '-\\\\nabla {p} + \\\\mu \\\\nabla^2 {u} + ', '\\\\textbf{F}', tex_to_color_map=color_map)\n        eq2cp.scale(1.5)\n        eq2cp.shift(1.5 * UP)\n        eq2cp2 = TexMobject('\\\\rho {{d {u} } \\\\over {d {t} }}', ' = ', '-\\\\nabla {p} + \\\\mu \\\\nabla^2 {u} + ', '\\\\rho {g}', tex_to_color_map=color_map)\n        eq2cp2.scale(1.5)\n        eq2cp2.shift(1.5 * UP)\n        self.play(Transform(eq3[0], eq2cp[0]))\n        self.wait()\n        self.play(Transform(eq3[1], eq2cp[1:4]))\n        self.wait()\n        legend = Rectangle(height=2, width=5, color=RED)\n        eqq = TexMobject('{{d {u} } \\\\over {d {t} }} = ', '{{\\\\partial {u} } \\\\over {\\\\partial {t} }}', ' + {u} \\\\cdot \\\\nabla {u}', tex_to_color_map=color_map)\n        grp = VGroup(legend, eqq)\n        grp.shift(3 * RIGHT + 1.5 * UP)\n        self.play(Write(grp))\n        self.wait()\n        self.play(FadeOut(grp))\n        self.wait()\n        br_config = {'buff': 0.1875, 'fill_opacity': 0, 'stroke_opacity': 1, 'stroke_width': 4, 'color': TEAL}\n        r1 = BackgroundRectangle(eq2[4:6], **br_config)\n        t1 = Text('Pressure', color=TEAL)\n        t1.move_to(r1, aligned_edge=DOWN)\n        t1.shift(0.7 * DOWN)\n        self.play(Write(r1))\n        self.play(FadeInFromDown(t1))\n        self.play(ApplyMethod(eq3[3:].shift, 2.5 * RIGHT), TransformFromCopy(eq2[4:7], eq2cp[5:8]))\n        self.wait()\n        r2 = BackgroundRectangle(eq2[7:10], **br_config)\n        t2 = Text('Friction', color=TEAL)\n        t2.move_to(r2, aligned_edge=DOWN)\n        t2.shift(0.7 * DOWN)\n        self.play(Transform(r1, r2), Transform(t1, t2))\n        self.play(ApplyMethod(eq3[3:].shift, 2.75 * RIGHT), TransformFromCopy(eq2[7:11], eq2cp[8:12]))\n        self.wait()\n        r3 = BackgroundRectangle(eq2[11:], **br_config)\n        t3 = Text('External', color=TEAL)\n        t3.move_to(r3, aligned_edge=DOWN)\n        t3.shift(0.7 * DOWN)\n        self.play(Transform(r1, r3), Transform(t1, t3))\n        self.play(Transform(eq3[3:], eq2cp[12:]))\n        self.wait()\n        self.play(Uncreate(r1), Uncreate(t1))\n        self.wait()\n        self.play(Transform(eq3[3:], eq2cp2[12:]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a smooth function graph with a title and two animated dots connected by a moving line."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Smooth(MovingCameraScene):\n    CONFIG = {'x1': -0.4, 'x2': -4, 'down': 0}\n\n    def construct(self):\n        plane = NumberPlane()\n        plane.set_opacity(0.25)\n        f = FunctionGraph(lambda x: self.f_s(x) - self.down, color=GOLD, stroke_opacity=0.8)\n        self.add(plane)\n        title = Text('Smooth Solution')\n        title.scale(2)\n        title.to_edge(UP)\n        title.add_background_rectangle()\n        self.play(Write(f), FadeInFromDown(title))\n        self.wait()\n        p1 = Dot(fill_opacity=1, color=YELLOW)\n        p1.shift([self.x1, self.f_s(self.x1) - self.down, 0])\n        t = ValueTracker(self.x2)\n        p2 = Dot(fill_opacity=1, color=YELLOW)\n        p2.shift([t.get_value(), self.f_s(t.get_value()) - self.down, 0])\n        p2.add_updater(lambda x: x.become(Dot(fill_opacity=1, color=YELLOW).shift([t.get_value(), self.f_s(t.get_value()) - self.down, 0])))\n        line = Line([self.x1, self.f_s(self.x1) - self.down, 0], [t.get_value(), self.f_s(t.get_value()) - self.down, 0])\n        line.scale(100)\n\n        def line_update(l):\n            line = Line([self.x1, self.f_s(self.x1) - self.down, 0], [t.get_value(), self.f_s(t.get_value()) - self.down, 0])\n            line.scale(100)\n            l.become(line)\n        line.add_updater(line_update)\n        self.play(Write(line), Write(p1), Write(p2))\n        self.wait()\n        self.play(t.increment_value, self.x1 - self.x2 - 0.1, run_time=3, rate_func=linear)\n        self.wait()\n\n    def f_s(self, x, scale=17):\n        return -0.3 * x ** 2 + 1.5"}]}
{"messages": [{"role": "user", "content": "Display a title, part number, main text, and subtitle, all in different positions and colors."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass PartScene(Scene):\n\n    def construct(self):\n        grp = VGroup()\n        if hasattr(self, 'title'):\n            title = TextMobject(self.title, color=PURPLE)\n            title.scale(1.5)\n            title.shift(1.5 * UP)\n            grp.add(title)\n        if hasattr(self, 'num'):\n            title = TextMobject(f'Part {str(self.num)}', color=PURPLE)\n            title.scale(1.5)\n            title.shift(1.5 * UP)\n            grp.add(title)\n        if hasattr(self, 'text'):\n            text = TextMobject(self.text)\n            text.scale(2)\n            grp.add(text)\n        if hasattr(self, 'subt'):\n            subt = TextMobject(self.subt)\n            subt.shift(1.5 * DOWN)\n            grp.add(subt)\n        self.play(Write(grp))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a quote about prime number distribution and its author."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass IntroQuote(Scene):\n\n    def construct(self):\n        quote = TextMobject('It is evident that the primes are randomly distributed but,')\n        quote2 = TextMobject(\"unfortunately, we don't know what 'random' means.\")\n        author = TextMobject('-R. C. Vaughan', color=YELLOW)\n        author.shift(1 * DOWN + 1 * RIGHT)\n        quote.shift(2 * UP)\n        quote2.shift(UP)\n        self.play(Write(quote), Write(quote2))\n        self.play(Write(author))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Introduce a scene with a title asking the viewer to continue a prime number sequence."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass Intro(Scene):\n\n    def construct(self):\n        title = TextMobject('Continue the Following Sequence:', color=BLUE)\n        title.scale(1.5)\n        title.shift(2 * UP)\n        seq = TexMobject('2, 3, 5, 7, 11, 13, 17, 19, ...')\n        seq.scale(1.5)\n        self.play(Write(title))\n        self.play(Write(seq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a dollar sign icon next to the Riemann zeta function equation and then write both on screen."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass Money(Scene):\n\n    def construct(self):\n        icon = SVGMobject('./files/price.svg', color=YELLOW)\n        icon.shift(1.5 * LEFT)\n        eq = TexMobject('\\\\zeta(s) = 0')\n        eq.scale(1.5)\n        eq.shift(1.5 * RIGHT)\n        self.play(Write(icon))\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show the number 30 transforming into its prime factorization 3 * 2 * 5."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass Factorization(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('30')\n        eq1.scale(2.5)\n        eq2 = TexMobject('30 =')\n        eq2.scale(2.5)\n        eq2.shift(2.5 * LEFT)\n        eq3 = TexMobject('3 \\\\cdot 2 \\\\cdot 5')\n        eq3.scale(2.5)\n        eq3.shift(1 * RIGHT)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(TransformFromCopy(eq1, eq2))\n        self.wait()\n        self.play(Transform(eq1, eq3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate Euclid's theorem proving the infinitude of primes by presenting the argument step-by-step with supporting text and visual cues."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass EuclidTheorem(Scene):\n\n    def construct(self):\n        title = TextMobject(\"Euclid's Theorem\", color=BLUE)\n        title.scale(1.5)\n        title.shift(2 * UP)\n        desc = TextMobject('There are an infinite number of primes')\n        desc.scale(1.25)\n        self.play(Write(title), Write(desc))\n        self.wait()\n        self.play(Uncreate(desc), ApplyMethod(title.scale, 2 / 3))\n        self.play(ApplyMethod(title.shift, 1.5 * UP))\n        l = Line(6 * LEFT, 6 * RIGHT, stroke_width=0.5 * DEFAULT_STROKE_WIDTH).shift(3 * UP)\n        self.play(Write(l))\n        self.wait()\n        p1 = TexMobject('\\\\text{Let }P \\\\text{ be the product of every single prime number}', tex_to_color_map={'P': YELLOW})\n        p1.shift(2 * UP)\n        p2 = TexMobject('\\\\text{Let }Q = P + 1', tex_to_color_map={'P': YELLOW, 'Q': PURPLE})\n        p2.shift(1 * UP)\n        b1 = Circle(fill_opacity=1, radius=0.1, color=BLUE).shift(6 * LEFT + 0.5 * DOWN)\n        p3 = TexMobject('\\\\text{If }Q \\\\text{ is prime, then contradiction}', tex_to_color_map={'Q': PURPLE})\n        p3.move_to(b1, LEFT).shift(0.5 * RIGHT)\n        b2 = Circle(fill_opacity=1, radius=0.1, color=BLUE).shift(6 * LEFT + 1.5 * DOWN)\n        p4_1 = TexMobject(\"\\\\text{If }Q \\\\text{ isn't prime, then one of its prime factors } p\", tex_to_color_map={'Q': PURPLE, '} p': RED})\n        p4_1.move_to(b2, LEFT).shift(0.5 * RIGHT)\n        p4_2 = TexMobject('\\\\text{ must divide }P-Q=1 \\\\text{, contradiction}', tex_to_color_map={'Q': PURPLE, 'P': YELLOW})\n        p4_2.move_to(b2, LEFT).shift(0.5 * RIGHT + 1 * DOWN)\n        self.play(Write(p1))\n        self.wait()\n        self.play(Write(p2))\n        self.wait()\n        self.play(Write(p3), Write(b1))\n        self.wait()\n        self.play(Write(p4_1), Write(b2), Write(p4_2))"}]}
{"messages": [{"role": "user", "content": "Display the harmonic series and then transform it into the definition of the Riemann zeta function, indicating convergence for p>1."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass Series(Scene):\n\n    def construct(self):\n        title = TextMobject('Series', color=RED)\n        title.scale(2)\n        title.shift(3 * UP)\n        eq1 = TexMobject('\\\\sum_{n=1}^{\\\\infty} \\\\frac{1}{n} = 1 + \\\\frac{1}{2} + \\\\frac{1}{3} + \\\\frac{1}{4} + ... ').scale(1.5)\n        self.play(Write(title))\n        self.wait()\n        self.play(Write(eq1))\n        self.wait()\n        eq2 = TexMobject('\\\\sum_{n=1}^{\\\\infty} \\\\frac{1}{n^p}', ' = 1 + \\\\frac{1}{2^p} + \\\\frac{1}{3^p} + \\\\frac{1}{4^p} + ... ', tex_to_color_map={'^p}': YELLOW})\n        eq2.scale(1.5)\n        self.play(Transform(eq1, eq2))\n        self.wait()\n        conv = TexMobject('\\\\text{Coverges for } p > 1', tex_to_color_map={'p': YELLOW})\n        conv.shift(2 * DOWN)\n        conv2 = TexMobject('\\\\text{Coverges for } s > 1', tex_to_color_map={'} s': YELLOW})\n        conv2.shift(2 * DOWN)\n        self.play(Write(conv))\n        self.wait()\n        zeta = TexMobject('\\\\zeta (s) =')\n        zeta.scale(1.5)\n        zeta.shift(1 * LEFT)\n        eq3 = TexMobject('\\\\sum_{n=1}^{\\\\infty} \\\\frac{1}{n^s}', tex_to_color_map={'^s}': YELLOW})\n        eq3.scale(1.5)\n        eq3.shift(1.5 * RIGHT)\n        self.play(Uncreate(eq1[2:]), ApplyMethod(eq1[:2].shift, -eq1[:2].get_center() + 1.5 * RIGHT))\n        self.play(Transform(eq1[:2], eq3), FadeInFromDown(zeta), Transform(conv, conv2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the derivation of the Euler product formula by transforming a series representation of the Riemann zeta function into its product form, then displaying a title and bounding box."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass EulerProductFormula(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\zeta(s) = 1 + \\\\frac{1}{2^s} + \\\\frac{1}{3^s} + \\\\frac{1}{4^s} + \\\\frac{1}{5^s}... ')\n        eq1.scale(1.5)\n        eq2 = TexMobject('\\\\frac{1}{2^s} \\\\zeta(s) = \\\\frac{1}{2^s} + \\\\frac{1}{4^s} + \\\\frac{1}{6^s} + \\\\frac{1}{8^s} + \\\\frac{1}{10^s}... ')\n        eq2.scale(1.5)\n        eq3 = TexMobject('(1 - \\\\frac{1}{2^s}) \\\\zeta(s) = 1 + \\\\frac{1}{3^s} + \\\\frac{1}{5^s} + \\\\frac{1}{7^s} + \\\\frac{1}{9^s}... ')\n        eq3.scale(1.5)\n        eq4 = TexMobject('\\\\frac{1}{3^s} (1 - \\\\frac{1}{2^s}) \\\\zeta(s) = \\\\frac{1}{3^s} + \\\\frac{1}{9^s} + \\\\frac{1}{15^s} + \\\\frac{1}{21^s} + \\\\frac{1}{27^s}... ')\n        eq4.scale(1.25)\n        eq5 = TexMobject('(1 - \\\\frac{1}{3^s}) (1 - \\\\frac{1}{2^s}) \\\\zeta(s) =1+ \\\\frac{1}{5^s} + \\\\frac{1}{7^s} + \\\\frac{1}{11^s} + \\\\frac{1}{13^s}... ')\n        eq5.scale(1.2)\n        eq6 = TexMobject('...(1 - \\\\frac{1}{11^s})(1 - \\\\frac{1}{7^s})(1 - \\\\frac{1}{5^s})(1 - \\\\frac{1}{3^s}) (1 - \\\\frac{1}{2^s}) \\\\zeta(s) =1')\n        eq6.scale(1.15)\n        eq7 = TexMobject('\\\\sum_{n \\\\in \\\\mathbb{N}} \\\\frac{1}{n^s} = \\\\prod_{p \\\\text{ prime}} \\\\frac{1}{1-p^{-s}}')\n        eq7.scale(1.5)\n        box = Rectangle(height=3, width=10, color=YELLOW)\n        text = TextMobject('Euler Product Formula', color=GREEN)\n        text.shift(3 * UP)\n        text.scale(1.5)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Transform(eq1, eq2))\n        self.wait()\n        self.play(Transform(eq1, eq3))\n        self.wait()\n        self.play(Transform(eq1, eq4))\n        self.wait()\n        self.play(Transform(eq1, eq5))\n        self.wait()\n        self.play(Transform(eq1, eq6))\n        self.wait()\n        self.play(Transform(eq1, eq7))\n        self.wait()\n        self.play(Write(box), Write(text))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the prime counting function by displaying and animating its notation for different inputs with corresponding answers."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass PrimeFunc(Scene, PrimeMethods):\n\n    def construct(self):\n        title = TextMobject('Prime Counting Function', color=YELLOW)\n        title.scale(1.5)\n        self.play(Write(title))\n        self.wait()\n        self.play(title.shift, 3 * UP)\n        self.wait()\n        n = 2.5\n        eq1 = TexMobject('\\\\pi(5)')\n        eq1.scale(1.5)\n        eq2 = TexMobject('\\\\pi(10)')\n        eq2.scale(1.5)\n        eq2.shift(-0.5 * UP + n * LEFT)\n        eq1.move_to(eq2, LEFT).shift(1.5 * UP)\n        eq3 = TexMobject('\\\\pi(20)')\n        eq3.scale(1.5)\n        eq3.shift(2 * DOWN + n * LEFT)\n        arr = VGroup(*[Arrow(1 * LEFT, 1 * RIGHT, color=RED).shift(i * UP + 0 * LEFT) for i in np.arange(-2, 2, 1.5)[::-1]])\n        ans = VGroup(*[TexMobject([8, 4, 3][int((i + 2) / 1.5)]).shift(i * UP + 2 * RIGHT).scale(1.5) for i in np.arange(-2, 2, 1.5)[::-1]])\n        self.play(FadeInFromDown(eq1), FadeInFromDown(eq2), FadeInFromDown(eq3))\n        self.play(Write(arr), FadeInFromDown(ans))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the Prime Number Theorem equation and its title."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass PNTEq(Scene):\n\n    def construct(self):\n        eq = TexMobject('\\\\lim_{x \\\\rightarrow \\\\infty} \\\\frac{\\\\pi(x)}{x/\\\\ln(x)} = 1')\n        eq.scale(2)\n        title = TextMobject('Prime Number Theorem', color=RED)\n        title.shift(2.5 * UP)\n        title.scale(1.5)\n        self.play(Write(title), Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present the logarithmic integral function definition with its integral and explanatory title."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass LiEq(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\int', '_2^x', '\\\\frac{dx}{\\\\ln(x)}', tex_to_color_map={'_2^x': YELLOW})\n        eq1.scale(1.5)\n        liEq = TexMobject('\\\\text{Li}(x) =')\n        liEq.scale(1.5)\n        liEq.shift(3 * LEFT)\n        title = TextMobject('Logarithmic Integral Function', color=ORANGE)\n        title.scale(1.5)\n        title.shift(2 * UP)\n        self.play(Write(VGroup(eq1[0], eq1[2])))\n        self.wait()\n        self.play(FadeInFromDown(liEq), FadeInFromDown(eq1[1]), Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display an image of Bernhard Riemann with his name, then move them and reveal his fields of study: Analysis, Number Theory, and Differential Geometry."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass Riemann(Scene):\n\n    def construct(self):\n        r = ImageMobject('./files/riemann.jpg', height=4)\n        r.shift(1 * UP)\n        subt = TextMobject('Bernhard Riemann')\n        subt.scale(1.25)\n        subt.shift(2 * DOWN)\n        f = ['Analysis', 'Number Theory', 'Differential Geometry']\n        fields = VGroup()\n        for i in range(0, 3):\n            b = Circle(radius=0.1, fill_opacity=1, color=ORANGE)\n            b.shift(i * UP + 1 * RIGHT)\n            t = TextMobject(f[i]).move_to(b, LEFT)\n            t.shift(0.5 * RIGHT)\n            fields.add(b, t)\n        self.play(FadeInFromDown(r), Write(subt))\n        self.wait()\n        self.play(ApplyMethod(r.shift, 2 * LEFT), ApplyMethod(subt.shift, 2 * LEFT))\n        self.play(FadeInFromDown(fields))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Introduce the Riemann Zeta Function by 3b1b with a title and screen rectangle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass ReferenceVideo(Scene):\n\n    def construct(self):\n        title = TextMobject('Riemann Zeta Function by 3b1b')\n        title.scale(1.5)\n        title.to_edge(UP)\n        rect = ScreenRectangle(height=6)\n        rect.next_to(title, DOWN)\n        self.play(FadeInFromDown(title), Write(rect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the convergence of the Riemann zeta function with a complex plane and highlighted regions."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass RiemannZeta(Scene):\n\n    def construct(self):\n        p = ComplexPlane()\n        plane = VGroup(p, p.get_coordinate_labels())\n        plane.scale(1.5)\n        self.play(Write(plane))\n        self.wait()\n        r1 = Rectangle(width=8, height=20, fill_opacity=0.5, color=RED).shift(5.5 * RIGHT)\n        t1 = TexMobject('\\\\zeta(s) \\\\text{ converges}')\n        t1.scale(1.25)\n        t1.shift(1.5 * 3 * RIGHT + 1 * UP)\n        b1 = BackgroundRectangle(t1)\n        r2 = Rectangle(width=1.5, height=20, fill_opacity=0.5, color=GREEN).shift(0.75 * RIGHT)\n        self.play(Write(r1))\n        self.play(Write(b1), Write(t1))\n        self.wait()\n        self.play(Write(r2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show the expansion of the Riemann zeta function's first term and transform it to highlight the complex exponential part."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass ComplexExponent(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('\\\\zeta(a + bi) = 1 + ', '\\\\left ( \\\\frac{1}{2} \\\\right )^{a + bi} + ...', tex_to_color_map={'a + bi': ORANGE})\n        eq1.scale(1.5)\n        self.play(Write(eq1))\n        self.wait()\n        b1 = BackgroundRectangle(eq1[3:5], stroke_width=DEFAULT_STROKE_WIDTH, stroke_opacity=1, fill_opacity=0, buff=0.2, color=YELLOW)\n        self.play(Write(b1))\n        self.wait()\n        self.play(FadeOut(eq1[0:3]), FadeOut(eq1[5:]), ApplyMethod(eq1[3:5].center), ApplyMethod(b1.center))\n        self.wait()\n        eq2 = TexMobject('\\\\left ( \\\\frac{1}{2} \\\\right )^{a} \\\\left ( \\\\frac{1}{2} \\\\right )^{bi}', tex_to_color_map={'{a}': ORANGE, '{bi}': ORANGE})\n        eq2.scale(1.5)\n        self.play(Uncreate(b1), Transform(eq1[3:5], eq2))\n        self.wait()\n        b2 = BackgroundRectangle(eq2[2:], stroke_width=DEFAULT_STROKE_WIDTH, stroke_opacity=1, fill_opacity=0, buff=0.2, color=BLUE)\n        self.play(Write(b2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the motion of a point on the complex plane while dynamically updating a mathematical expression involving an imaginary exponent."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass CExpPlane(Scene):\n\n    def construct(self):\n        p = ComplexPlane()\n        plane = VGroup(p, p.get_coordinate_labels())\n        plane.scale(1.5, about_point=p.get_center())\n        c = Circle(radius=0.15, fill_opacity=1, color=YELLOW)\n        c.shift(1.5 * RIGHT)\n        t1 = TexMobject('\\\\left ( \\\\frac{1}{2} \\\\right )^{0i}')\n        t1.scale(1.25)\n        t1.shift(2.75 * UP)\n        b1 = BackgroundRectangle(t1, color=BLACK, fill_opacity=1, buff=0.1)\n        self.play(Write(plane))\n        self.play(Write(c), Write(b1), Write(t1))\n        self.wait()\n        self.play(UpdateFromAlphaFunc(c, self.update), UpdateFromAlphaFunc(t1, self.update2), rate_func=linear, run_time=3)\n        self.wait()\n        circ = Circle(radius=1.5, color=RED)\n        self.bring_to_back(circ)\n        self.play(Write(circ))\n        self.wait()\n\n    def update(self, point, dt):\n        p = interpolate(0, 9.0647, dt)\n        new_p = 0.5 ** (p * 1j)\n        c = Circle(radius=0.15, fill_opacity=1, color=YELLOW)\n        c.shift(1.5 * RIGHT)\n        c.center()\n        c.shift(new_p.real * 1.5 * RIGHT + new_p.imag * 1.5 * UP)\n        point.become(c)\n\n    def update2(self, text, dt):\n        p = interpolate(0, 9.0647, dt)\n        t1 = TexMobject('\\\\left ( \\\\frac{1}{2} \\\\right )^{ ' + str(round(float(p), 2)) + 'i}')\n        t1.scale(1.25)\n        t1.shift(2.75 * UP)\n        text.become(t1)"}]}
{"messages": [{"role": "user", "content": "Generate a graph of the real part of the Riemann zeta function with axes and labels."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass RealZetaGraph(Scene):\n\n    def construct(self):\n        N = 125\n        axes = Axes(x_min=-12, x_max=1, y_max=3, y_min=-3)\n        axes.center()\n        labels = axes.get_x_axis().get_number_mobjects(*[-2 * x for x in range(1, 6)])\n        brects = VGroup()\n        for i in labels:\n            b = BackgroundRectangle(i, fill_opacity=1, color=BLACK, buff=0.1)\n            brects.add(b)\n        graph = FunctionGraph(lambda x: 3 * N * float(zeta(complex(x, 0)).real), x_min=-12, x_max=0)\n        graph.shift(5.5 * RIGHT)\n        l1 = TexMobject('\\\\zeta(s)').shift(3.5 * UP + 5.5 * RIGHT)\n        l2 = TexMobject('x').shift(6.75 * RIGHT)\n        self.play(Write(axes), Write(graph), Write(brects), Write(labels), Write(l1), Write(l2))\n        self.wait()\n\n    def riemann_zeta(self, x):\n        return 2 ** x * PI ** (x - 1) * math.sin(PI * x / 2) * gamma(1 - x) * zeta(1 - x)"}]}
{"messages": [{"role": "user", "content": "Display the Riemann zeta function formula and sequentially highlight its terms with colored background rectangles, while also presenting a text about its zeros."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass RiemannZeros(Scene):\n\n    def construct(self):\n        func = TexMobject('\\\\zeta (s)=2^{s}\\\\pi ^{s-1} \\\\ ', '\\\\sin \\\\left({\\\\frac {\\\\pi s}{2}}\\\\right)\\\\ ', ' \\\\Gamma (1-s)\\\\ ', ' \\\\zeta (1-s)')\n        func.scale(1.5)\n        b1 = BackgroundRectangle(func[2], stroke_width=DEFAULT_STROKE_WIDTH, stroke_opacity=1, fill_opacity=0, buff=0.2, color=YELLOW)\n        self.play(Write(func))\n        self.wait()\n        self.play(Write(b1))\n        self.wait()\n        self.play(Uncreate(b1))\n        self.wait()\n        b2 = BackgroundRectangle(func[1], stroke_width=DEFAULT_STROKE_WIDTH, stroke_opacity=1, fill_opacity=0, buff=0.2, color=RED)\n        t1 = TexMobject('\\\\zeta(s) = 0 \\\\text{ when Re} (s) = -2n', tex_to_color_map={'\\\\zeta(s) = 0': GREEN, 'Re} (s) = -2n': RED})\n        t1.shift(2 * DOWN)\n        self.play(Write(b2))\n        self.play(Write(t1))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the real and imaginary parts of the Riemann zeta function as 3D surfaces with axes and a ground plane."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass RiemannZerosGraph(ThreeDScene):\n\n    def construct(self):\n        f1 = ParametricSurface(lambda u, v: [u, v, float(zeta(complex(u, v)).real)], u_min=-5, u_max=5, v_min=-5, v_max=5)\n        f2 = ParametricSurface(lambda u, v: [u, v, float(zeta(complex(u, v)).imag)], u_min=-5, u_max=5, v_min=-5, v_max=5, checkerboard_colors=[RED, ORANGE])\n        axes = ThreeDAxes()\n        plane = ParametricSurface(lambda u, v: [u, v, 0], u_min=-5, u_max=5, v_min=-5, v_max=5, checkerboard_colors=[YELLOW, YELLOW])\n        self.move_camera(0.8 * np.pi / 2, -0.45 * np.pi)\n        self.play(Write(axes), Write(f1), Write(f2))\n        self.begin_ambient_camera_rotation(rate=0.06)\n        self.wait(5)\n        f2.set_fill(opacity=0.5)\n        f1.set_fill(opacity=0.5)\n        self.play(Write(plane))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Present the explicit Riemann explicit formula with a write animation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass RiemannExplicitEq(Scene):\n\n    def construct(self):\n        eq = TexMobject('{\\\\displaystyle \\\\pi(x)=\\\\operatorname {li} (x)-\\\\sum _{\\\\rho }\\\\operatorname {li} (x^{\\\\rho })-\\\\log(2)+\\\\int _{x}^{\\\\infty }{\\\\frac {dt}{t(t^{2}-1)\\\\log(t)}}}')\n        eq.scale(1.15)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize level curves of the Riemann zeta function on a complex plane."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.special import expi\nfrom scipy.integrate import quad\nfrom mpmath import *\nfrom mpmath.libmp.libintmath import moebius\n\nclass RiemannLevelCurves(Scene):\n\n    def construct(self):\n        f = []\n        p = ComplexPlane()\n        plane = VGroup(p, p.get_coordinate_labels())\n        for x in np.arange(-5, 5, 0.1):\n            for y in np.arange(-20, 20, 0.1):\n                if self.pass_real(x, y):\n                    f.append([x, y, 0])\n        p = Polygon(*f)\n        self.play(Write(plane), Write(p))\n        self.wait()\n\n    def pass_real(self, x, y):\n        if -0.05 < float(zeta(complex(x, y)).imag) < 0.05:\n            return True\n        return False"}]}
{"messages": [{"role": "user", "content": "Create an introductory scene with the text \"Super Mario NEAT\" and a screen rectangle."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        title = TextMobject('Super Mario NEAT')\n        title.scale(1.5)\n        title.to_edge(UP)\n        rect = ScreenRectangle(height=6)\n        rect.next_to(title, DOWN)\n        self.play(FadeInFromDown(title), Write(rect))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Show Mario moving left with an arrow pointing to a neural network, followed by text labels for \"Artificial Neural Network\" and \"Recommender System\" appearing above and below the network."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass InputANN(Scene):\n\n    def construct(self):\n        mario = SVGMobject('files/mario.svg')\n        a = Arrow(LEFT, RIGHT, color=RED)\n        nn = SVGMobject('files/nn.svg')\n        nn.move_to(2.5 * RIGHT)\n        head = TextMobject('Artificial Neural Network', color=BLUE)\n        head.move_to(2 * UP)\n        head.scale(1.5)\n        foot = TextMobject('Recommender System', color=RED)\n        foot.move_to(2 * DOWN)\n        foot.scale(1.5)\n        self.play(Write(mario))\n        self.play(ApplyMethod(mario.shift, 2.5 * LEFT), Write(a))\n        self.play(Write(nn))\n        self.wait(2)\n        self.play(Write(head))\n        self.wait(2)\n        self.play(Write(foot))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize a neural network with labeled inputs, outputs, neurons, and weights, including a brace indicating bias."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass NeuralNetwork(Scene):\n\n    def construct(self):\n        network = NeuralNetworkMobject([3, 4, 3], 0.15)\n        network.scale(2.5)\n        neuron_arrow = Arrow(ORIGIN, 1 * UP)\n        neuron_arrow.next_to(network, 1 * UP)\n        neuron_text = TextMobject('Neurons')\n        neuron_text.next_to(neuron_arrow, 1 * UP)\n        input_arrow = Arrow(1 * LEFT, ORIGIN, color=BLUE)\n        input_arrow.next_to(network, 2 * LEFT)\n        input_text = TextMobject('Inputs', color=BLUE)\n        input_text.next_to(input_arrow, 1 * UP)\n        output_arrow = Arrow(ORIGIN, 1 * RIGHT, color=RED)\n        output_arrow.next_to(network, 2 * RIGHT)\n        output_text = TextMobject('Outputs', color=RED)\n        output_text.next_to(output_arrow, 1 * UP)\n        weight_arrow = Arrow(2 * LEFT, 2 * LEFT + 2 * DOWN)\n        weight_text = TextMobject('Weights')\n        weight_text.next_to(weight_arrow, 1 * DOWN)\n        brace = Brace(VGroup(network), DOWN)\n        text = brace.get_text('Bias')\n        self.play(Write(network))\n        self.play(Write(neuron_arrow), Write(neuron_text))\n        self.play(Write(input_arrow), Write(input_text))\n        self.play(Write(output_arrow), Write(output_text))\n        self.play(Write(weight_arrow), Write(weight_text))\n        self.play(Write(brace), Write(text))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render a neural network diagram with its corresponding equation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LayerToLayer(Scene):\n\n    def construct(self):\n        nn = NeuralNetworkMobject([5, 1], 0.2)\n        nn.scale(2)\n        nn.add_input_labels()\n        nn.add_y()\n        nn.add_weight_labels()\n        nn.shift(0.75 * UP)\n        eq = TexMobject('y = \\\\sigma (w_1x_1 + w_2x_2 + w_3x_3 + w_4x_4 + b)')\n        eq.scale(1.5)\n        eq.shift(3 * DOWN)\n        self.play(Write(nn))\n        self.play(Write(eq))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Show a neural network with backpropagation highlighted by an arrow and text."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass BackProp(Scene):\n\n    def construct(self):\n        network = NeuralNetworkMobject([3, 4, 3])\n        network.scale(2)\n        back = Arrow(2.5 * UP + 1 * RIGHT, 2.5 * UP + 1 * LEFT, color=RED)\n        text = TextMobject('Backpropagation')\n        text.shift(3 * UP)\n        self.play(Write(network))\n        self.play(Write(back), Write(text))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize a neuroevolution process starting with a year, transforming into a title, and then demonstrating neural networks with scores and circles, followed by transformations and fading."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass NeuroEvolution(Scene):\n\n    def construct(self):\n        n = 3\n        m = 1\n        shift = [m * UP + n * LEFT, m * UP, m * UP + n * RIGHT, m * DOWN + n * LEFT, m * DOWN, m * DOWN + n * RIGHT]\n        scores = ['312', '434', '145', '254', '332', '521']\n        scores2 = ['624', '512', '765', '432', '332', '521']\n        head = TextMobject('Neuroevolution', color=RED)\n        head.scale(2)\n        head2 = TextMobject('Neuroevolution', color=RED)\n        head2.scale(2)\n        head2.shift(3 * UP)\n        rep = TextMobject('This process is repeated', color=BLUE)\n        rep.scale(2)\n        one = TextMobject('1994', color=RED)\n        one.scale(2)\n        survival = TextMobject('Survival of the fittest')\n        survival.scale(1.5)\n        survival.shift(2 * DOWN)\n        net_group = VGroup()\n        text_group = VGroup()\n        text_group2 = VGroup()\n        circle1 = Circle(color=GREEN)\n        circle1.shift(shift[5])\n        circle2 = Circle(color=GREEN)\n        circle2.shift(shift[1])\n        circle3 = Circle(color=GREEN)\n        circle3.shift(shift[0])\n        circle4 = Circle(color=GREEN)\n        circle4.shift(shift[2])\n        for i in range(6):\n            net = NeuralNetworkMobject([2, 3, 2])\n            net.shift(shift[i])\n            net_group.add(net)\n            text = TextMobject(scores[i])\n            text.shift(shift[i])\n            text.scale(1.5)\n            text_group.add(text)\n            text2 = TextMobject(scores2[i])\n            text2.shift(shift[i])\n            text2.scale(1.5)\n            text_group2.add(text2)\n        self.play(Write(one))\n        self.play(Transform(one, head))\n        self.play(Write(survival))\n        self.wait(0.25)\n        self.play(ApplyMethod(one.shift, 3 * UP), Transform(survival, head2))\n        self.play(Write(net_group))\n        self.wait(0.25)\n        self.play(Write(text_group))\n        self.wait(0.25)\n        self.play(Write(circle1), Write(circle2))\n        self.wait(0.25)\n        self.play(Transform(circle1, net_group), Uncreate(circle2), Uncreate(text_group), Uncreate(net_group))\n        self.wait(0.25)\n        self.play(Write(text_group2))\n        self.play(Write(circle3), Write(circle4))\n        self.wait(0.25)\n        self.play(Uncreate(circle1), Uncreate(text_group2), Uncreate(circle3), Uncreate(circle4), Write(rep))\n        self.wait(0.25)"}]}
{"messages": [{"role": "user", "content": "Visualize the evolution of neural network topologies while displaying evolving text titles and subtitles."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TWEANN(Scene):\n\n    def construct(self):\n        network1 = NeuralNetworkMobject([3, 4, 3])\n        network2 = NeuralNetworkMobject([2, 3, 3])\n        network3 = NeuralNetworkMobject([4, 2, 3])\n        network4 = NeuralNetworkMobject([3, 2, 3])\n        f = 2\n        network1.scale(f)\n        network2.scale(f)\n        network3.scale(f)\n        network4.scale(f)\n        sub = TextMobject('Topology and Weight Evolving Artificial Neural Networks')\n        head = TextMobject('TWEANNs', color=BLUE)\n        head.scale(1.5)\n        head.shift(3.5 * UP)\n        sub.shift(2.5 * UP)\n        sub2 = TextMobject('Neuroevolution of Augmenting Topologies')\n        head2 = TextMobject('NEAT', color=RED)\n        head2.scale(1.5)\n        head2.shift(3.5 * UP)\n        sub2.shift(2.5 * UP)\n        self.play(Write(head), Write(sub))\n        self.play(Write(network1))\n        self.wait()\n        self.play(Transform(network1, network2))\n        self.wait()\n        self.play(Transform(network1, network3))\n        self.wait()\n        self.play(Transform(network1, network4))\n        self.wait()\n        self.play(Transform(sub, sub2), Transform(head, head2))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Create a diagram with a central \"Commentary\" header, two branching nodes below it labeled \"Thanking\" and \"Actual Commentary\", and connecting lines."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Commentary(Scene):\n\n    def construct(self):\n        head = TextMobject('Commentary')\n        head.scale(2)\n        node1 = TextMobject('Thanking')\n        node1.scale(1.5)\n        node1.shift(3 * LEFT + 2 * DOWN)\n        node2 = TextMobject('Actual Commentary')\n        node2.scale(1.5)\n        node2.shift(3 * RIGHT + 2 * DOWN)\n        l1 = Line(1 * UP, ORIGIN, color=GREEN)\n        l2 = Line(3 * RIGHT, 3 * LEFT, color=GREEN)\n        l3 = Line(3 * RIGHT, 3 * RIGHT + 1 * DOWN, color=GREEN)\n        l4 = Line(3 * LEFT, 3 * LEFT + 1 * DOWN, color=GREEN)\n        self.play(Write(head))\n        self.wait(2)\n        self.play(ApplyMethod(head.shift, 2 * UP))\n        self.play(Write(l1), Write(l2))\n        self.play(Write(l3), Write(l4))\n        self.play(Write(node1), Write(node2))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Show the Streamlabs logo and the text \"API\" side-by-side."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass StreamLabs(Scene):\n\n    def construct(self):\n        streamlabs = SVGMobject('files/streamlabs.svg', color=BLUE)\n        api = TextMobject('API', color=BLUE)\n        streamlabs.shift(2 * LEFT)\n        api.shift(2 * RIGHT)\n        api.scale(2)\n        streamlabs.scale(2)\n        self.play(Write(streamlabs), Write(api))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize the expansion of \"API\" to \"Application Programming Interface,\" then display a server and monitor connected by an arrow, followed by the word \"API\" moving back and forth."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass API(Scene):\n\n    def construct(self):\n        api = TextMobject('API', color=RED)\n        full = TextMobject('Application Programming Interface', color=RED)\n        api.scale(2)\n        full.scale(1.5)\n        server = SVGMobject('files/server.svg')\n        monitor = SVGMobject('files/monitor.svg')\n        server.shift(3.5 * RIGHT)\n        monitor.shift(3.5 * LEFT)\n        arrow = Arrow(2.5 * LEFT, 2.5 * RIGHT, color=BLUE)\n        mes = TextMobject('API', color=GREEN)\n        mes.scale(1.25)\n        mes.shift(1.5 * LEFT + 0.5 * UP)\n        self.play(Write(api))\n        self.play(Transform(api, full))\n        self.play(ApplyMethod(api.shift, 3 * UP))\n        self.wait(2)\n        self.play(Write(monitor), Write(server), Write(arrow))\n        self.play(Write(mes))\n        self.play(ApplyMethod(mes.shift, 3 * RIGHT))\n        self.play(ApplyMethod(mes.shift, 3 * LEFT))\n        self.play(ApplyMethod(mes.shift, 3 * RIGHT))\n        self.play(ApplyMethod(mes.shift, 3 * LEFT))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Illustrate a client-server connection with a socket API, showing the creation of a socket and a client pinged on event occurrences."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SocketAPI(Scene):\n\n    def construct(self):\n        head = TextMobject('Socket API', color=ORANGE)\n        head.scale(2)\n        head.shift(1 * UP)\n        foot = TextMobject('Collection of Socket Commands', color=YELLOW)\n        foot.scale(1.25)\n        foot.shift(1 * DOWN)\n        socket = TextMobject('Once a client accepts the connection, a socket is created')\n        socket.shift(3 * DOWN)\n        desc = TextMobject('The client gets pinged every time an event occurs')\n        desc.shift(3 * UP)\n        brace = Brace(foot, UP)\n        client = SVGMobject('files/monitor.svg')\n        server = SVGMobject('files/server.svg')\n        server.shift(3.5 * RIGHT)\n        client.shift(3.5 * LEFT)\n        arrow1 = Arrow(2.5 * LEFT + 0.5 * UP, 2.5 * RIGHT + 0.5 * UP, color=BLUE)\n        arrow2 = Arrow(2.5 * RIGHT + 0.5 * DOWN, 2.5 * LEFT + 0.5 * DOWN, color=BLUE)\n        self.play(Write(head))\n        self.play(Write(foot), Write(brace))\n        self.wait(2)\n        self.play(Uncreate(head), Uncreate(foot), Uncreate(brace))\n        self.play(Write(client), Write(server))\n        self.play(Write(arrow1), Write(arrow2))\n        self.play(Write(socket))\n        self.wait(2)\n        self.play(Write(desc))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Show a Google logo and \"Text to speech\" side-by-side, followed by \"/tmp = RAM\" below."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass GTTS(Scene):\n\n    def construct(self):\n        google = SVGMobject('files/search.svg', color=ORANGE)\n        google.shift(3 * LEFT)\n        gtts = TextMobject('Text to speech')\n        gtts.scale(1.5)\n        gtts.shift(1 * RIGHT)\n        tmp = TextMobject('/tmp = RAM', tex_to_color_map={'/tmp': YELLOW, 'RAM': RED})\n        tmp.scale(1.5)\n        tmp.shift(2 * DOWN)\n        self.play(Write(google), Write(gtts))\n        self.play(Write(tmp))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate a bulleted list of options, sequentially highlighting each item by fading out the others, then reset the list."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass CGame(Scene):\n\n    def construct(self):\n        opt = BulletedList('Markov Chains', 'Recurrent Neural Networks', 'Choosing from list')\n        opt.scale(2)\n        self.play(Write(opt))\n        for i in range(3):\n            self.play(opt.fade_all_but, i)\n            self.wait(2)\n        self.play(opt.reset)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display a title with a specified text and color."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TitleScene(Scene):\n    CONFIG = {'title': 'test', 'color': RED}\n\n    def construct(self):\n        title = TextMobject(self.title, color=self.color)\n        title.scale(2)\n        self.play(Write(title))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display the GitHub logo and a star with an arrow pointing to \"Source Code\"."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass GitHub(Scene):\n\n    def construct(self):\n        logo = SVGMobject('files/github-logo.svg')\n        logo.shift(2 * LEFT)\n        star = SVGMobject('files/star.svg')\n        star.shift(2 * RIGHT)\n        source = TextMobject('Source Code')\n        source.shift(2 * DOWN + 2 * LEFT)\n        source.scale(1.5)\n        arrow = Arrow(1 * DOWN + 2 * RIGHT, 3 * DOWN + 2 * RIGHT, color=RED)\n        self.play(Write(source), Write(arrow))\n        self.play(Write(logo), Write(star))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display a COVID-19 virus SVG image."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        w = SVGMobject('./img/covid20.svg')\n        self.add(w)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Write \"Part 1\" above \"Demand\" in red."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DemandTitle(Scene):\n\n    def construct(self):\n        part = TextMobject('Part 1')\n        part.scale(1.5)\n        part.shift(2 * UP)\n        title = TextMobject('Demand', color=RED)\n        title.scale(1.5)\n        self.play(Write(part))\n        self.play(Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present the word \"Demand:\" in red and then write out a definition of demand."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Demand(Scene):\n\n    def construct(self):\n        l = 5.5\n        pad = 1.5\n        f1 = TextMobject('Demand:', color=RED)\n        f1.shift(l * LEFT + (pad + 0.75) * UP)\n        f1.scale(1.25)\n        f2 = TextMobject('Fact 2:')\n        f2.shift(l * LEFT + (pad - 0.75) * DOWN)\n        f2.scale(1.25)\n        fact1 = TextMobject('The amount of some good or service \\\\\\\\ \\\\\\n                consumers are willing to buy at \\\\\\\\ \\\\\\n                a specific price', alignment='')\n        fact1.shift(pad * UP + 1 * RIGHT)\n        fact1.scale(1.25)\n        self.play(FadeInFromDown(f1))\n        self.play(Write(fact1))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show the definition of \"Supply\" with accompanying text that explains its meaning."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Supply(Scene):\n\n    def construct(self):\n        l = 5.5\n        pad = 1.5\n        f1 = TextMobject('Supply:', color=BLUE)\n        f1.shift(l * LEFT + (pad + 0.75) * UP)\n        f1.scale(1.25)\n        fact1 = TextMobject('The amount of some good or service \\\\\\\\ \\\\\\n                manufacturers are willing to supply at \\\\\\\\ \\\\\\n                a specific price', alignment='')\n        fact1.shift(pad * UP + 1 * RIGHT)\n        fact1.scale(1.25)\n        self.play(FadeInFromDown(f1))\n        self.play(Write(fact1))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate a graph of a linear demand curve with labeled axes."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DemandGraph(Scene):\n\n    def construct(self):\n        axes = Axes(x_min=0, x_max=6, y_min=0, y_max=5, axis_config={'include_tip': False})\n        line = FunctionGraph(self.func, x_min=0, x_max=6, color=RED)\n        grp = VGroup(axes, line)\n        grp.center()\n        xlbl = TextMobject('Quantity')\n        xlbl.shift(3 * DOWN)\n        ylbl = TextMobject('Price (\\\\$)')\n        ylbl.rotate(PI / 2)\n        ylbl.shift(4 * LEFT + 0.5 * UP)\n        self.play(Write(axes))\n        self.play(Write(line))\n        self.play(FadeInFromDown(xlbl), FadeInFromDown(ylbl))\n        self.wait()\n\n    @staticmethod\n    def func(x):\n        return -0.5 * x + 4"}]}
{"messages": [{"role": "user", "content": "Show a graph representing a supply curve with labeled axes."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SupplyGraph(Scene):\n\n    def construct(self):\n        axes = Axes(x_min=0, x_max=6, y_min=0, y_max=5, axis_config={'include_tip': False})\n        line = FunctionGraph(self.func, x_min=0, x_max=6, color=BLUE)\n        grp = VGroup(axes, line)\n        grp.center()\n        xlbl = TextMobject('Quantity')\n        xlbl.shift(3 * DOWN)\n        ylbl = TextMobject('Price (\\\\$)')\n        ylbl.rotate(PI / 2)\n        ylbl.shift(4 * LEFT + 0.5 * UP)\n        self.play(Write(axes))\n        self.play(Write(line))\n        self.play(FadeInFromDown(xlbl), FadeInFromDown(ylbl))\n        self.wait()\n\n    @staticmethod\n    def func(x):\n        return 0.425 * x + 0.785"}]}
{"messages": [{"role": "user", "content": "Visualize the intersection of a supply and demand curve with labeled axes and an equilibrium point."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SupplyAndDemand(Scene):\n\n    def construct(self):\n        axes = Axes(x_min=0, x_max=6, y_min=0, y_max=5, axis_config={'include_tip': False})\n        supply = FunctionGraph(self.supply, x_min=0, x_max=6, color=BLUE)\n        demand = FunctionGraph(self.demand, x_min=0, x_max=6, color=RED)\n        point = Dot(point=[3.475, 2.262, 0], color=YELLOW)\n        grp = VGroup(axes, supply, demand, point)\n        grp.center()\n        xlbl = TextMobject('Quantity')\n        xlbl.shift(3 * DOWN)\n        ylbl = TextMobject('Price (\\\\$)')\n        ylbl.rotate(PI / 2)\n        ylbl.shift(4 * LEFT + 0.5 * UP)\n        self.play(Write(axes))\n        self.play(Write(demand))\n        self.play(Write(supply))\n        self.play(FadeInFromDown(xlbl), FadeInFromDown(ylbl))\n        self.wait()\n        self.play(Write(point))\n        self.wait()\n\n    @staticmethod\n    def demand(x):\n        return -0.5 * x + 4\n\n    @staticmethod\n    def supply(x):\n        return 0.425 * x + 0.785"}]}
{"messages": [{"role": "user", "content": "Display the text \"Minimax\" in green and at a larger scale."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass MinimaxTitle(Scene):\n\n    def construct(self):\n        title = TextMobject('Minimax', color=GREEN)\n        title.scale(2)\n        self.play(Write(title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a minimax decision tree with alternating Maximizer and Minimizer labels."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Minimax(Scene):\n\n    def construct(self):\n        tree = TreeMobject((1, 2, 4))\n        tree.rotate(PI / 2, axis=IN)\n        tree.add_labels(-1, ['9', '2', '5', '3'])\n        tree.scale(2)\n        tree.add_branch_labels(['R', 'L'])\n        max1 = TextMobject('Maximizer')\n        max1.scale(1)\n        max1.shift(2 * LEFT + 1.5 * UP)\n        min1 = TextMobject('Minimizer')\n        min1.scale(1)\n        min1.shift(2 * LEFT + 1.5 * DOWN)\n        self.play(Write(tree))\n        self.wait()\n        self.play(Write(max1), Write(min1))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a LaTeX equation that is scaled up and then written onto the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass EQScene(Scene):\n\n    def construct(self):\n        eq = TexMobject(self.eq)\n        eq.scale(2)\n        self.play(Write(eq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a graph of a function, highlighting stationary points and explaining concepts related to local extrema."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        axes = Axes(x_min=-2, x_max=4, y_min=-2, y_max=4, number_line_config={'include_tip': False})\n        f = FunctionGraph(self.func, x_min=-2, x_max=4)\n        s = [-0.904, 0.904, 3.528]\n        lbl = TexMobject('f(x)', color=YELLOW).move_to(f, RIGHT)\n        xlbl = TexMobject('x').shift(4.5 * RIGHT)\n        ylbl = TexMobject('y').shift(4.5 * UP)\n        lines = VGroup(*[self.get_lines(i) for i in s])\n        graph = VGroup(axes, f, lbl, xlbl, ylbl)\n        grp = VGroup(graph, lines)\n        grp.scale(0.9)\n        grp.move_to(3 * LEFT)\n        self.play(Write(graph))\n        self.wait()\n        head1 = TextMobject('Stationary Points', color=GOLD_B)\n        head1.shift(3.5 * RIGHT + 3 * UP)\n        head1.scale(1.25)\n        self.play(Write(head1))\n        eq1 = TexMobject(\"f'(x) = 0\")\n        eq1.scale(1)\n        eq1.shift(3.5 * RIGHT + 1.5 * UP)\n        self.wait()\n        brect1 = BackgroundRectangle(eq1, buff=0.25, stroke_opacity=1, fill_opacity=0, stroke_width=4, color=BLUE)\n        self.play(Write(eq1))\n        self.play(Write(brect1), Write(lines))\n        self.wait()\n        head2 = TextMobject('Local min/max', color=GREEN)\n        head2.shift(3.5 * RIGHT + 1 * DOWN)\n        head2.scale(1.25)\n        eq2 = TexMobject(\"\\\\text{sign of } f''(x)\")\n        eq2.shift(3.5 * RIGHT + 2.5 * DOWN)\n        brect2 = BackgroundRectangle(eq2, buff=0.25, stroke_opacity=1, fill_opacity=0, stroke_width=4, color=PURPLE)\n        self.play(Write(head2))\n        self.play(Write(brect2), Write(eq2))\n        self.wait()\n\n    def func(self, x):\n        return x * np.sin(np.cos(x)) + 2\n\n    def get_lines(self, point):\n        ret = VGroup()\n        ret.add(DashedLine(ORIGIN, self.func(point) * UP, dash_length=0.1, stroke_opacity=0.7).shift(point * RIGHT))\n        ret.add(Line(0.75 * LEFT, 0.75 * RIGHT, color=BLUE).shift([point, self.func(point), 0]))\n        return ret"}]}
{"messages": [{"role": "user", "content": "Display a transforming mathematical expression, followed by an animated parametric function on axes with labeled points, illustrating the distance calculation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Functional(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('D(f(x))', tex_to_color_map={'f': RED, 'D': BLUE, 'x': GREEN})\n        eq1.scale(3)\n        eq2 = TexMobject('D(f)', tex_to_color_map={'f': RED, 'D': BLUE, 'x': GREEN})\n        eq2.scale(3)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Transform(eq1, eq2))\n        self.play(eq1.scale, 1.5 / 3)\n        self.play(eq1.shift, 3 * UP)\n        axes = Axes(x_min=-3, x_max=3, y_min=-2, y_max=2, number_line_config={'include_tip': False})\n        tracker = ValueTracker(-1)\n        func = ParametricFunction(self.f_r(theta=PI / 4), color=RED, t_min=-2, t_max=2)\n        func.add_updater(lambda x: x.become(ParametricFunction(self.f_r(theta=PI / 4, alpha=np.sin(tracker.get_value())), color=RED, t_min=-2, t_max=2)).shift(0.5 * DOWN))\n        grp = VGroup(axes, func)\n        grp.shift(0.5 * DOWN)\n        p1 = Circle(radius=0.05, fill_opacity=1, color=YELLOW)\n        p1.shift([-np.sqrt(2), -np.sqrt(2) - 0.5, 0])\n        p2 = Circle(radius=0.05, fill_opacity=1, color=YELLOW)\n        p2.shift([np.sqrt(2), np.sqrt(2) - 0.5, 0])\n        lbl1 = TexMobject('A').move_to(p1).shift(0.5 * DOWN)\n        lbl2 = TexMobject('B').move_to(p2).shift(0.5 * UP)\n        points = VGroup(p1, p2, lbl1, lbl2)\n        self.play(Write(points))\n        self.wait()\n        self.bring_to_back(grp)\n        self.play(Write(grp))\n        self.wait()\n        self.play(tracker.increment_value, 8, rate_func=linear, run_time=4 * DEFAULT_ANIMATION_RUN_TIME)\n        self.wait()\n        head1 = TextMobject('Distance from \\\\( A \\\\) to \\\\( B \\\\) along \\\\( f \\\\)', tex_to_color_map={'\\\\( f \\\\)': RED, '\\\\( A \\\\)': GREEN, '\\\\( B \\\\)': GREEN})\n        head1.scale(1.25)\n        head1.shift(3 * UP + 1.75 * RIGHT)\n        self.play(eq1.shift, 5 * LEFT)\n        arrow = Arrow(4 * LEFT, 2.5 * LEFT, color=GOLD).shift(3 * UP)\n        self.play(Write(arrow), FadeInFromDown(head1))\n        self.wait()\n\n    def f(self, x, alpha=0):\n        return alpha * np.cos(PI / 4 * x)\n\n    def f_r(self, theta=PI / 4, alpha=0):\n        return lambda t: [t * np.cos(theta) - self.f(t, alpha=alpha) * np.sin(theta), t * np.sin(theta) + self.f(t, alpha=alpha) * np.cos(theta), 0]\n\n    def func(self, t):\n        return [t - self.f(t), t + self.f(t), 0]"}]}
{"messages": [{"role": "user", "content": "Present \"Traditional Calculus\" and \"Variational Calculus\" side-by-side with introductory diagrams representing their input and output spaces."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Difference(Scene):\n\n    def construct(self):\n        t1 = TextMobject('Traditional Calculus', color=GOLD)\n        t2 = TextMobject('Variational Calculus', color=PURPLE)\n        t1.shift(3.5 * LEFT + 3 * UP)\n        t2.shift(3.5 * RIGHT + 3 * UP)\n        t1.scale(1.25)\n        t2.scale(1.25)\n        l1 = Line(6 * UP, 6 * DOWN)\n        l2 = Line(10 * LEFT, 10 * RIGHT).shift(2 * UP)\n        grp = VGroup(t1, t2, l1, l2)\n        self.play(Write(grp))\n        self.wait()\n        f1 = TexMobject('f', color=RED)\n        i1 = TexMobject('\\\\mathbb{R}', color=YELLOW).shift(1.5 * LEFT)\n        o1 = TexMobject('\\\\mathbb{R}', color=YELLOW).shift(1.5 * RIGHT)\n        a1 = Arrow(1.25 * LEFT, 0.25 * LEFT, color=GREEN)\n        a2 = Arrow(0.25 * RIGHT, 1.25 * RIGHT, color=GREEN)\n        eq1 = VGroup(f1, i1, o1, a1, a2)\n        eq1.shift(3.5 * LEFT)\n        eq1.scale(1.5)\n        f2 = TexMobject('f', color=RED)\n        i2 = TexMobject('f(x)', color=BLUE).shift(1.5 * LEFT)\n        o2 = TexMobject('\\\\mathbb{R}', color=YELLOW).shift(1.5 * RIGHT)\n        a3 = Arrow(1 * LEFT, 0 * LEFT, color=GREEN)\n        a4 = Arrow(0.25 * RIGHT, 1.25 * RIGHT, color=GREEN)\n        eq2 = VGroup(f2, i2, o2, a3, a4)\n        eq2.shift(3.5 * RIGHT)\n        eq2.scale(1.5)\n        self.play(Write(eq1))\n        self.play(Write(eq2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the concept of distance between two points along a curve by displaying related mathematical formulas and animating a parametric function that represents the curve."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DistanceFunc(Scene):\n\n    def construct(self):\n        eq1 = TexMobject('D(f)', tex_to_color_map={'f': RED, 'D': BLUE, 'x': GREEN})\n        eq1.scale(1.5)\n        eq1.shift(3 * UP + 5 * LEFT)\n        head1 = TextMobject('Distance from \\\\( A \\\\) to \\\\( B \\\\) along \\\\( f \\\\)', tex_to_color_map={'\\\\( f \\\\)': RED, '\\\\( A \\\\)': GREEN, '\\\\( B \\\\)': GREEN})\n        head1.scale(1.25)\n        head1.shift(3 * UP + 1.75 * RIGHT)\n        arrow = Arrow(4 * LEFT, 2.5 * LEFT, color=GOLD).shift(3 * UP)\n        self.play(Write(eq1), Write(arrow), FadeInFromDown(head1))\n        self.wait()\n        axes = Axes(x_min=-3, x_max=3, y_min=-2, y_max=2, number_line_config={'include_tip': False})\n        tracker = ValueTracker(-1)\n        func = ParametricFunction(self.f_r(theta=PI / 4), color=RED, t_min=-2, t_max=2)\n        func.add_updater(lambda x: x.become(ParametricFunction(self.f_r(theta=PI / 4, alpha=np.sin(tracker.get_value())), color=RED, t_min=-2, t_max=2)).shift(0.5 * DOWN))\n        grp = VGroup(axes, func)\n        grp.shift(0.5 * DOWN)\n        p1 = Circle(radius=0.05, fill_opacity=1, color=YELLOW)\n        p1.shift([-np.sqrt(2), -np.sqrt(2) - 0.5, 0])\n        p2 = Circle(radius=0.05, fill_opacity=1, color=YELLOW)\n        p2.shift([np.sqrt(2), np.sqrt(2) - 0.5, 0])\n        lbl1 = TexMobject('A').move_to(p1).shift(0.5 * DOWN)\n        lbl2 = TexMobject('B').move_to(p2).shift(0.5 * UP)\n        points = VGroup(p1, p2, lbl1, lbl2)\n        self.play(Write(points))\n        self.wait()\n        self.bring_to_back(grp)\n        self.play(Write(grp))\n        self.wait()\n        self.play(tracker.increment_value, 1 + 3 * PI, rate_func=linear, run_time=4 * DEFAULT_ANIMATION_RUN_TIME)\n        self.wait()\n        f2 = ParametricFunction(self.f_r(theta=PI / 4), color=RED, t_min=-2, t_max=2).shift(0.5 * DOWN)\n        graph = VGroup(axes, f2, points)\n        self.add(f2)\n        self.remove(func)\n        self.play(ApplyMethod(graph.shift, 3.5 * LEFT))\n        eq2 = TexMobject('D(f) ', '= \\\\int_{ x_1 }^{ x_2 } \\\\text{d}s', tex_to_color_map={'f': RED, 'D': BLUE, '\\\\text{d}s': GREEN, '_{ x_1 }': YELLOW, '^{ x_2 }': YELLOW})\n        eq2.scale(1.25)\n        eq2.shift(1.25 * UP + 3 * RIGHT)\n        self.play(TransformFromCopy(eq1, eq2[:4]))\n        self.play(FadeInFromDown(eq2[4:]))\n        self.wait()\n        eq3 = TexMobject('=', \"\\\\int_{ x_1 }^{ x_2 } \\\\sqrt{1 +f'(x)^2 }  \\\\ \\\\text{d}x\", tex_to_color_map={'_{ x_1 }': YELLOW, '^{ x_2 }': YELLOW, '\\\\text{d}x': GREEN})\n        eq3.scale(1)\n        eq3.shift(1 * DOWN + 3 * RIGHT)\n        self.play(FadeInFromDown(eq3))\n        self.wait()\n        rect = BackgroundRectangle(eq3[1:], stroke_width=DEFAULT_STROKE_WIDTH, stroke_opacity=1, color=GOLD, fill_opacity=0, buff=0.1)\n        self.play(Write(rect))\n        txt = TextMobject('Minimize this', color=ORANGE)\n        txt.next_to(rect, DOWN)\n        self.play(Write(txt))\n        self.wait()\n\n    def f(self, x, alpha=0):\n        return alpha * np.cos(PI / 4 * x)\n\n    def f_r(self, theta=PI / 4, alpha=0):\n        return lambda t: [t * np.cos(theta) - self.f(t, alpha=alpha) * np.sin(theta), t * np.sin(theta) + self.f(t, alpha=alpha) * np.cos(theta), 0]\n\n    def func(self, t):\n        return [t - self.f(t), t + self.f(t), 0]"}]}
{"messages": [{"role": "user", "content": "Display the text \"3blue1brown\" and \"VSauce\" on separate sides of the screen, each within a screen rectangle."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Brac(Scene):\n\n    def construct(self):\n        br1 = ScreenRectangle(height=3, width=4).shift(3.5 * LEFT)\n        br2 = ScreenRectangle(height=3, width=4).shift(3.5 * RIGHT)\n        t1 = TextMobject('3blue1brown', color=BLUE).shift(3.5 * LEFT + 2.5 * UP).scale(1.5)\n        t2 = TextMobject('VSauce', color=GREEN).shift(3.5 * RIGHT + 2.5 * UP).scale(1.5)\n        self.play(Write(t1), Write(t2))\n        self.play(Write(br1), Write(br2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present an introductory scene for variational calculus, defining the problem of finding a function that makes an integral stationary."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass IntroToProblem(Scene):\n\n    def construct(self):\n        head = TextMobject('Variational Calculus', color=GOLD).scale(1.5).shift(3 * UP)\n        self.play(Write(head))\n        self.wait()\n        p1 = TextMobject('Find some function \\\\( f \\\\) such that:', tex_to_color_map={'\\\\( f \\\\)': RED})\n        p1.shift(1 * UP)\n        self.play(Write(p1))\n        eq1 = TexMobject(\"I[f] = \\\\int_{ x_1 }^{ x_2 } F({x}, f({x}), f'({x})) \\\\ \\\\text{d}x\", tex_to_color_map={'f': RED, '_{ x_1 }': YELLOW, '^{ x_2 }': YELLOW, '\\\\text{d}x': GREEN, '{x}': BLUE, 'I': BLUE, 'F': PURPLE})\n        eq1.scale(1.25)\n        eq1.shift(0.5 * DOWN)\n        self.play(Write(eq1))\n        p2 = TextMobject('is stationary')\n        p2.shift(2 * DOWN)\n        self.play(Write(p2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate a family of parametric curves with accompanying points, dashed lines, and equations on a Cartesian plane."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Proof(Scene):\n\n    def construct(self):\n        axes = Axes(x_min=-1, x_max=5, y_min=0, y_max=4, number_line_config={'include_tip': False})\n        func1 = ParametricFunction(self.f_r(alpha=1), color=TEAL, t_min=-2, t_max=2)\n        func2 = ParametricFunction(self.f_r(alpha=0.6), color=RED, t_min=-2, t_max=2)\n        func3 = ParametricFunction(self.f_r(alpha=0.2), color=TEAL, t_min=-2, t_max=2)\n        p1 = Circle(radius=0.05, fill_opacity=1, color=YELLOW)\n        p1.shift([-np.sqrt(3), -1, 0])\n        p2 = Circle(radius=0.05, fill_opacity=1, color=YELLOW)\n        p2.shift([np.sqrt(3), 1, 0])\n        points = VGroup(p1, p2)\n        f = VGroup(func1, func2, func3)\n        f.shift(2.5 * RIGHT + 2.5 * UP)\n        points.shift(2.5 * RIGHT + 2.5 * UP)\n        l1 = DashedLine((-np.sqrt(3) + 2.5) * RIGHT, (-np.sqrt(3) + 2.5) * RIGHT + 1.5 * UP, dash_length=0.075, stroke_opacity=0.75)\n        l2 = DashedLine((np.sqrt(3) + 2.5) * RIGHT, (np.sqrt(3) + 2.5) * RIGHT + 3.5 * UP, dash_length=0.075, stroke_opacity=0.75)\n        eq1 = TexMobject('q(x)', color=RED).scale(0.75)\n        eq1.move_to(p2).shift(0.75 * RIGHT)\n        eq2 = TexMobject('q(x) + s \\\\cdot \\\\delta q(x)', color=TEAL).scale(0.75)\n        eq2.move_to(func1).shift(1.5 * UP)\n        everything = VGroup(axes, func1, func2, func3, l1, l2, points, eq1, eq2).center().scale(1.5)\n        self.play(Write(axes))\n        self.play(Write(func2), Write(eq1))\n        self.wait()\n        self.play(Write(func3), Write(func1), Write(eq2))\n        self.play(Write(points), Write(VGroup(l1, l2)))\n        self.wait()\n\n    def f(self, x, alpha=0):\n        return alpha * np.cos(PI / 4 * x)\n\n    def f_r(self, theta=PI / 6, alpha=0):\n        return lambda t: [t * np.cos(theta) - self.f(t, alpha=alpha) * np.sin(theta), t * np.sin(theta) + self.f(t, alpha=alpha) * np.cos(theta), 0]\n\n    def func(self, t):\n        return [t - self.f(t), t + self.f(t), 0]"}]}
{"messages": [{"role": "user", "content": "Present variations of the Euler-Lagrange equation, highlighting specific terms with different colors."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass EulerLagrangeScene(Scene):\n\n    def get_eq(self):\n        eqq = TexMobject('{{\\\\partial F}', ' \\\\over {\\\\partial y}}', \" -\\\\frac{d}{d x} {{\\\\partial F} \\\\over {\\\\partial y'}}=0\", tex_to_color_map={'y': GREEN})\n        eqq.scale(1.25)\n        eqq2 = TexMobject('{{\\\\partial {F}} \\\\over ', '{\\\\partial y}}', \" -\\\\frac{d}{d x} {{\\\\partial F} \\\\over {\\\\partial y'}}=0\", tex_to_color_map={'{F}': YELLOW})\n        eqq2.scale(1.25)\n        eqq3 = TexMobject('{{\\\\partial F} \\\\over ', '{\\\\partial y}}', ' -\\\\frac{d}{d x} ', '{{\\\\partial {F}} ', \"\\\\over {\\\\partial y'}}=0\", tex_to_color_map={'{F}': YELLOW})\n        eqq3.scale(1.25)\n        eqq4 = TexMobject('{{\\\\partial F} \\\\over ', '{\\\\partial y}}', ' -\\\\frac{d}{d x} ', '{{\\\\partial {F}} ', \"\\\\over {\\\\partial y'}}=0\", tex_to_color_map={'x': BLUE})\n        eqq4.scale(1.25)\n        grp = VGroup()\n        grp.add(eqq[1:], eqq2[:3], eqq3[-3:-2], eqq4[3])\n        return grp"}]}
{"messages": [{"role": "user", "content": "Display an image of Wolfram Alpha, followed by a red rectangle with the equation \"= 0\", then the equation \"f''(x) = 0\" with specific colors, and finally an arrow connecting \"f(x) = c_0 + c_1 x\" to the previous equation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Wolfram(Scene):\n\n    def construct(self):\n        img = ImageMobject('./img/wolfram.png')\n        img.scale(2.75)\n        img.shift(1.25 * UP)\n        self.play(ShowCreation(img))\n        self.wait()\n        rect1 = Rectangle(height=1, width=2, color=RED)\n        rect1.shift(2.75 * LEFT + 0.75 * DOWN)\n        eq1 = TexMobject('= 0', color=BLACK).scale(1.5)\n        eq1.shift(0.75 * DOWN + 1 * LEFT)\n        self.play(Write(rect1))\n        self.play(Write(eq1))\n        self.wait()\n        eq2 = TexMobject(\"f''(x) = 0\", tex_to_color_map={'f': RED, 'x': BLUE})\n        eq2.scale(1.5)\n        eq2.shift(2.5 * DOWN + 3.5 * LEFT)\n        self.play(FadeInFromDown(eq2))\n        self.wait()\n        eq3 = TexMobject('f(x) = c_0 + c_1 x', tex_to_color_map={'f': RED, 'x': BLUE})\n        eq3.scale(1.5)\n        eq3.shift(2.5 * DOWN + 4 * RIGHT)\n        arrow = Arrow(LEFT, RIGHT, color=GREEN)\n        arrow.shift(2.5 * DOWN)\n        self.play(Write(arrow))\n        self.play(FadeInFromDown(eq3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display \"Part X\" and a customizable title on screen, then write them out."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass PartScene(Scene):\n    CONFIG = {'n': 1, 'title': 'Placeholder', 'title_color': RED}\n\n    def construct(self):\n        self.part = TexText(f'Part {self.n}')\n        self.part.scale(1.5)\n        self.part.shift(2 * UP)\n        self.title = TexText(self.title, color=self.title_color)\n        self.title.scale(1.5)\n        self.play(Write(self.part))\n        self.play(Write(self.title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a scene with a full-screen colored background, a title at the top, and a screen rectangle below the title."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass TitleScene(Scene):\n    CONFIG = {'color': None, 'text': None}\n\n    def construct(self):\n        if self.text is None:\n            raise NotImplementedError\n        brect = Rectangle(height=FRAME_HEIGHT, width=FRAME_WIDTH, fill_opacity=1, color=self.color)\n        title = TexText(self.text)\n        title.scale(1.5)\n        title.to_edge(UP)\n        rect = ScreenRectangle(height=6)\n        rect.next_to(title, DOWN)\n        self.add(brect)\n        self.play(FadeIn(rect, DOWN), Write(title), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a title about Zagier's One Sentence Proof and then show an image of the proof surrounded by a rectangle."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass OneSentence(Scene):\n\n    def construct(self):\n        title = TexText(\"Zagier's One Sentence Proof\", color=A_LAVENDER)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        img = ImageMobject('img/zagier_proof.png')\n        img.scale(0.85)\n        rect = SurroundingRectangle(img, color=A_LAVENDER, buff=0, stroke_width=8)\n        self.play(Write(title))\n        self.play(FadeIn(img), Write(rect))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Present three screens with accompanying text labels \"Simplicity\", \"Elegance\", and \"Visualization\" using fading animations."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass ZagierIntro(Scene):\n\n    def construct(self):\n        vectors = [FRAME_WIDTH / 4 * LEFT + FRAME_HEIGHT / 4 * UP, FRAME_WIDTH / 4 * RIGHT + FRAME_HEIGHT / 4 * UP, FRAME_HEIGHT / 4 * DOWN]\n        screens = [ScreenRectangle(height=2.75, fill_opacity=1, fill_color=BLACK).move_to(vectors[i]) for i in range(3)]\n        texts = ['Simplicity', 'Elegance', 'Visualization']\n        text_objs = [TexText(texts[i]).next_to(screens[i], UP) for i in range(3)]\n        VGroup(*screens, *text_objs).center()\n        for i in range(3):\n            self.play(FadeIn(screens[i], DOWN))\n            self.play(Write(text_objs[i]))\n            self.wait(0.25)\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Animate three screens, each displaying a word, appearing from bottom to top with text."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass ZagierIntroVertical(Scene):\n\n    def construct(self):\n        b_rect = Rectangle(height=FRAME_HEIGHT, width=9 / 16 * FRAME_HEIGHT, fill_opacity=1, fill_color='#252626', stroke_width=0)\n        self.add(b_rect)\n        vectors = [(FRAME_HEIGHT / 2 - FRAME_HEIGHT / 3.25) * UP, (FRAME_HEIGHT / 2 - 2 * FRAME_HEIGHT / 3.25) * UP, (FRAME_HEIGHT / 2 - 3 * FRAME_HEIGHT / 3.25) * UP]\n        screens = [ScreenRectangle(height=1.75, fill_opacity=1, fill_color=BLACK).move_to(vectors[i]) for i in range(3)]\n        texts = ['Simplicity', 'Elegance', 'Visualization']\n        text_objs = [TexText(texts[i]).move_to(screens[i]).scale(0.75).shift(1.15 * UP) for i in range(3)]\n        VGroup(*screens, *text_objs).center()\n        for i in range(3):\n            self.play(FadeIn(screens[i], DOWN))\n            self.play(Write(text_objs[i]))\n            self.wait(0.25)\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of an involution with visual mappings and explanations of fixed and paired elements."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass Involution(Scene):\n\n    def construct(self):\n\n        def set_bound_curve(t):\n            return [5 * np.cos(t), 3 * np.sin(t) + np.sin(0.5 * t), 0]\n        set_bound = ParametricCurve(set_bound_curve, t_range=(0, 2 * PI), color=A_YELLOW, fill_opacity=0.35)\n        set_bound.center()\n        s_text = Tex('S')\n        s_text.scale(3)\n        s_text.move_to(set_bound, DL)\n        s_text.shift(0.5 * LEFT)\n        self.play(Write(set_bound), Write(s_text))\n        circles = VGroup(Circle(fill_color=RED_E, stroke_color=RED_A, fill_opacity=0.75), Circle(fill_color=GREEN_E, stroke_color=GREEN_A, fill_opacity=0.75), Circle(fill_color=BLUE_E, stroke_color=BLUE_A, fill_opacity=0.75))\n        circles[0].move_to(1.5 * LEFT + UP)\n        circles[1].move_to(RIGHT + 0.75 * UP)\n        circles[2].move_to(0.25 * LEFT + 1.5 * DOWN)\n        self.play(Write(circles))\n        self.wait()\n        circle_move_anims = [ApplyMethod(circles[i].move_to, (3.5 * (i - 1) + 1.75) * RIGHT + 2 * UP) for i in range(3)]\n        self.play(Uncreate(set_bound))\n        self.play(*circle_move_anims, ApplyMethod(s_text.move_to, 5 * LEFT + 2 * UP))\n        self.wait()\n        f_circles = circles.deepcopy()\n        f_circles.shift(4 * DOWN)\n        f_circles[1].set_fill(color=BLUE_E)\n        f_circles[1].set_stroke(color=BLUE_A)\n        f_circles[2].set_fill(color=GREEN_E)\n        f_circles[2].set_stroke(color=GREEN_A)\n        transform_anims = [TransformFromCopy(circles[i], f_circles[(i != 0) * (3 - i)]) for i in range(3)]\n        fs_text = Tex('f(S)', tex_to_color_map={'f': A_YELLOW, ')': A_UNKA, '(': A_UNKA})\n        fs_text.scale(3)\n        fs_text.move_to(5 * LEFT + 2 * DOWN)\n        arrows = VGroup()\n        for i in range(3):\n            start = circles[i].get_center() + 1.25 * DOWN\n            end = f_circles[(i != 0) * (3 - i)].get_center() + 1.25 * UP\n            arrows.add(Arrow(start, end, stroke_width=10, tip_width_ratio=6, stroke_color=A_YELLOW, buff=0))\n        self.play(*transform_anims, run_time=6)\n        self.play(Write(fs_text), Write(arrows))\n        self.bring_to_front(circles, f_circles)\n        self.wait()\n        inv_title = Tex('\\\\text{Involution} \\\\leftrightarrow f(f(x)) = x', tex_to_color_map={'\\\\leftrightarrow': A_RED, 'f': A_YELLOW, '(': A_UNKA, ')': A_UNKA})\n        inv_title[1].set_color(A_RED)\n        inv_title.scale(1.5)\n        inv_title.shift(3.25 * UP)\n        all_curr_obj = VGroup(arrows, s_text, fs_text, circles, f_circles)\n        self.play(all_curr_obj.shift, 0.5 * DOWN)\n        self.play(Write(inv_title))\n        self.wait()\n        inv_transform_anims = [TransformFromCopy(f_circles[i], circles[(i != 0) * (3 - i)]) for i in range(3)]\n        self.play(FadeOut(circles, UP))\n        circles.shift(4 * DOWN)\n        self.play(f_circles.shift, 4 * UP)\n        self.play(*inv_transform_anims, run_time=3)\n        self.wait()\n        self.play(FadeOut(f_circles, UP), FadeOut(arrows, UP), ApplyMethod(circles.shift, 4 * UP))\n        self.wait()\n        arrows2 = VGroup()\n        for i in range(3):\n            start = circles[i].get_center() + 1.25 * DOWN\n            end = circles[(i != 2) * (1 - i) + 2 * (i == 2)].get_center() + 1.25 * UP + 4 * DOWN\n            arrows2.add(Arrow(start, end, stroke_width=10, tip_width_ratio=6, stroke_color=A_YELLOW, buff=0))\n        f_circles2 = circles.deepcopy()\n        f_circles2.shift(4 * DOWN)\n        f_circles2[1].set_fill(color=RED_E)\n        f_circles2[1].set_stroke(color=RED_A)\n        f_circles2[0].set_fill(color=GREEN_E)\n        f_circles2[0].set_stroke(color=GREEN_A)\n        self.play(Write(arrows2[2]), Write(f_circles2[2]))\n        b_rect = SurroundingRectangle(VGroup(f_circles2[2], arrows2[2], f_circles[2]), color=BLUE_E, buff=0.15, stroke_width=8)\n        fixed_text = TexText('Fixed Element', color=BLUE_E)\n        fixed_text.scale(1.5)\n        fixed_text.move_to(b_rect, LEFT)\n        fixed_text.shift(5 * LEFT)\n        self.play(Write(b_rect), Write(fixed_text))\n        self.wait()\n        self.play(Uncreate(b_rect), Uncreate(fixed_text))\n        self.wait()\n        grp = VGroup(f_circles2[2], circles, fs_text, s_text, arrows2[2])\n        self.play(ApplyMethod(grp.scale, 0.5))\n        self.play(ApplyMethod(grp.shift, UP))\n        ff_text = Tex('f(f(S))', tex_to_color_map={'f': A_YELLOW, ')': A_UNKA, '(': A_UNKA})\n        ff_text.scale(1.5)\n        ff_text.move_to(fs_text.get_center() + 2 * DOWN)\n        arr = arrows2[-1].copy()\n        arr.shift(1.75 * LEFT)\n        arr2 = arr.copy()\n        arr2.shift(2 * DOWN)\n        circ = Circle(stroke_color=WHITE)\n        circ.scale(0.5)\n        circ.move_to(f_circles2[2].get_center() + 1.75 * LEFT)\n        q = TexText('?')\n        q.scale(1.5)\n        q.move_to(circ)\n        f_circ = f_circles2[0].copy()\n        f_circ.scale(0.5)\n        f_circ.move_to(circ.get_center() + 2 * DOWN)\n        self.play(Write(ff_text))\n        self.play(Write(arr), Write(VGroup(q, circ)))\n        self.play(Write(arr2), Write(f_circ))\n        self.wait()\n        self.play(Uncreate(VGroup(circ, q, ff_text, arr, arr2, f_circ)))\n        self.play(grp.shift, DOWN)\n        self.play(grp.scale, 2)\n        self.play(Write(f_circles2[:-1]), Write(arrows2[:-1]))\n        self.wait()\n        c = color_gradient([RED_E, GREEN_E, RED_E], 15)\n        p_rect = SurroundingRectangle(VGroup(*f_circles2[:-1], *arrows2[:-1], *f_circles[:-1]), buff=0.15, color=c, stroke_width=8)\n        p_text = Text('Paired Element', gradient=color_gradient([RED_E, GREEN_E], 10))\n        p_text.scale(1.5)\n        p_text.move_to(p_rect)\n        p_text.add_background_rectangle(buff=0.15)\n        self.play(ShowCreation(p_rect), Write(p_text))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Visualize the function f(x) = -x by mapping points from an input number line to an output number line with connecting lines, then transform the visualization to show the mapping in reverse with different colored connecting lines."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass CommonInvolution(Scene):\n\n    def construct(self):\n        input_line = NumberLine()\n        input_line.shift(1 * UP)\n        input_line.add_numbers(font_size=36)\n        x_label = Tex('x', color=A_YELLOW)\n        x_label.move_to([-6.5, 1.5, 0])\n        output_line = NumberLine()\n        output_line.shift(2 * DOWN)\n        output_line.add_numbers(font_size=36)\n        y_label = Tex('f(x)', tex_to_color_map={'x': A_YELLOW, 'f': A_BLUE})\n        y_label.move_to([-6.1902, -1.5, 0])\n        f_label = Tex('f(x) = -x', tex_to_color_map={'x': A_YELLOW, 'f': A_BLUE})\n        f_label.scale(1.5)\n        f_label.shift(3 * UP)\n        self.play(Write(input_line), Write(output_line))\n        self.play(Write(x_label), Write(y_label), Write(f_label))\n        x_vals, y_vals = ([], [])\n        for x in np.linspace(-8, 8, 129):\n            x_vals.append(input_line.n2p(x))\n            y_vals.append(output_line.n2p(-x))\n        grad = color_gradient([A_PINK, A_GREEN], len(x_vals))\n        input_c = DotCloud(x_vals, color=grad)\n        output_c = DotCloud(y_vals, color=grad)\n        lines = VGroup()\n        for i in range(129):\n            lines.add(Line(x_vals[i], y_vals[i], color=grad[i], stroke_opacity=0.3))\n        self.play(ShowCreation(input_c))\n        self.play(TransformFromCopy(input_c, output_c), run_time=5)\n        self.play(ShowCreation(lines))\n        self.wait()\n        lines2 = VGroup()\n        for i in range(129):\n            lines2.add(Line(x_vals[i], y_vals[i], color=grad[len(grad) - i - 1], stroke_opacity=0.3))\n        self.play(FadeOut(input_c, UP), FadeOut(lines))\n        self.play(ApplyMethod(output_c.shift, 3 * UP))\n        input_c.shift(3 * DOWN)\n        self.play(TransformFromCopy(output_c, input_c), run_time=3)\n        self.play(ShowCreation(lines2))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Animate a series of mathematical equations demonstrating the concept of involution, transforming one equation into the next and highlighting the final result."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass MoreInvolution(Scene):\n\n    def construct(self):\n        color_map = {'\\\\text{paired}': A_PINK, '{f}': A_YELLOW, '0': A_UNKA, '2': A_UNKA, 'S': A_GREEN, '\\\\text{fixed}': A_PINK}\n        eq1 = Tex('| \\\\text{paired} \\\\ {f} \\\\ S | \\\\equiv 0 \\\\mod 2', tex_to_color_map=color_map)\n        eq1.scale(2)\n        eq1.shift(1.5 * UP)\n        eq2 = Tex('|S| = | \\\\text{fixed} \\\\ {f} \\\\ S | + | \\\\text{paired} \\\\ {f} \\\\ S |', tex_to_color_map=color_map)\n        eq2.scale(2)\n        eq2.shift(1.5 * DOWN)\n        eq3 = Tex('|S| \\\\equiv | \\\\text{fixed} \\\\ {f} \\\\ S | \\\\mod 2', tex_to_color_map=color_map)\n        eq3.scale(2)\n        eq3.shift(1.5 * DOWN)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(eq2))\n        self.wait()\n        self.play(TransformMatchingTex(eq2, eq3))\n        self.play(Indicate(eq3))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Illustrate the relationship between prime numbers of the form 4k+1 and sums of two squares, visually representing squares and their components."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass WindmillIntro(Scene):\n\n    def construct(self):\n        head_t = Tex('\\\\text{For all } p = 4k + 1', tex_to_color_map={'p': A_GREEN, 'k': A_ORANGE, '4': A_UNKA, '1': A_UNKA})\n        head_t.scale(2)\n        head_t.shift(2.5 * UP)\n        bot_t = Tex('p = a^2 + b^2', tex_to_color_map={'p': A_GREEN, 'a': A_PINK, 'b': A_PINK, '2': A_UNKA})\n        bot_t.scale(2)\n        self.play(Write(head_t))\n        self.play(Write(bot_t))\n        self.wait()\n        self.play(FadeOut(head_t, UP))\n        self.play(bot_t.shift, 3 * UP + FRAME_WIDTH / 4 * LEFT)\n        s1 = Square(side_length=4, fill_opacity=0.5, fill_color=A_GREEN)\n        s1.shift(FRAME_WIDTH / 4 * LEFT + 0.5 * DOWN)\n        s1_lbl = Tex('p').scale(2)\n        s1_lbl.move_to(s1)\n        self.play(Write(s1), Write(s1_lbl))\n        self.wait(1)\n        sr1 = Square(side_length=2, fill_color=A_PINK, fill_opacity=0.5)\n        r1_lbl = Tex('a^2').scale(2)\n        r1_lbl.move_to(sr1)\n        r1 = VGroup(sr1, r1_lbl)\n        r1.shift(2 * LEFT)\n        sr2 = Square(side_length=np.sqrt(12), fill_color=A_PINK, fill_opacity=0.5)\n        r2_lbl = Tex('b^2').scale(2)\n        r2_lbl.move_to(sr2)\n        r2 = VGroup(sr2, r2_lbl)\n        r2.shift(RIGHT)\n        r_left = VGroup(r1, r2)\n        r_left.move_to(s1)\n        s1 = VGroup(s1, s1_lbl)\n        self.play(Transform(s1, r_left))\n        other_t = Tex('p = x^2 + 4yz', tex_to_color_map={'p': A_GREEN, 'x': A_PINK, 'y': A_AQUA, 'z': A_AQUA, '4': A_UNKA, '2': A_UNKA})\n        other_t.scale(2)\n        other_t.shift(FRAME_WIDTH / 4 * RIGHT + 3 * UP)\n        s2 = Square(side_length=4, fill_opacity=0.5, fill_color=A_GREEN)\n        s2.shift(FRAME_WIDTH / 4 * RIGHT + 0.5 * DOWN)\n        s2_lbl = Tex('p').scale(2)\n        s2_lbl.move_to(s2)\n        self.play(Write(other_t))\n        self.play(Write(s2), Write(s2_lbl))\n        self.wait(1)\n        wind_f = Windmill(2, 1, 3, freq=float('inf'))\n        wind_f.square.move_to(FRAME_WIDTH / 4 * RIGHT + 1.125 * UP)\n        for i in range(4):\n            wind_f.rects[i].move_to(ORIGIN + 1.25 * i * RIGHT)\n            if i & 1:\n                wind_f.rects[i].rotate(90 * DEGREES)\n        wind_f.rects.move_to(FRAME_WIDTH / 4 * RIGHT + 1.625 * DOWN)\n        sq_lbl = Tex('x^2')\n        sq_lbl.scale(2)\n        sq_lbl.move_to(wind_f.square)\n        wr_lbls = VGroup()\n        for i in range(4):\n            wr_lbls.add(Tex('yz').move_to(wind_f.rects[i]))\n        s2 = VGroup(s2, s2_lbl)\n        self.play(Transform(s2, wind_f))\n        self.remove(s2)\n        self.add(wind_f)\n        self.play(Write(sq_lbl), Write(wr_lbls))\n        self.wait(1)\n        self.play(FadeOut(VGroup(bot_t, s1), UP))\n        self.play(other_t.scale, 1 / 1.5)\n        self.play(ApplyMethod(other_t.shift, FRAME_WIDTH / 4 * LEFT + 0.25 * UP), FadeOut(VGroup(sq_lbl, wr_lbls)))\n        wind = Windmill(2, 1, 3, freq=float('inf'))\n        wind.scale(0.75)\n        wind.shift(0.5 * DOWN)\n        self.play(Transform(wind_f.square, wind.square))\n        self.play(*[Transform(wind_f.rects[i], wind.rects[i]) for i in range(4)])\n        self.wait()\n        x_label = Tex('x')\n        x_label.scale(1.5)\n        y_label = Tex('y', color=A_AQUA)\n        y_label.scale(1.5)\n        z_label = Tex('z', color=A_AQUA)\n        z_label.scale(1.5)\n        b1 = Brace(wind_f.square, LEFT)\n        b1.rotate(180 * DEGREES)\n        b1.shift(0.5 * RIGHT)\n        b1.put_at_tip(x_label)\n        b2 = Brace(wind_f.rects[1], RIGHT)\n        b2.put_at_tip(y_label)\n        b3 = Brace(wind_f.rects[1], UP)\n        b3.put_at_tip(z_label)\n        self.play(GrowFromCenter(b1), TransformFromCopy(other_t[2], x_label))\n        self.play(GrowFromCenter(b2), TransformFromCopy(other_t[-2], y_label))\n        self.play(GrowFromCenter(b3), TransformFromCopy(other_t[-1], z_label))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Illustrate the definition of a windmill set and its properties with mathematical equations and visual representations."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass WindmillDef(Scene):\n\n    def construct(self):\n        eq1 = Tex('W_{n} = \\\\lbrace (x, y, z) \\\\in \\\\mathbb{{N}}^3 \\\\ | \\\\ x^2 + 4yz = {n} \\\\rbrace', tex_to_color_map={'W': A_YELLOW, '{n}': A_GREEN, 'x': A_PINK, 'y': A_AQUA, 'z': A_AQUA, '2': A_UNKA, '3': A_UNKA, '4': A_UNKA, '{N}': A_LAVENDER})\n        eq1.scale(1.5)\n        eq1.shift(3 * UP)\n        self.play(Write(eq1[:2]))\n        self.wait()\n        self.play(Write(eq1[2:12]))\n        self.wait()\n        self.play(Write(eq1[12:]))\n        self.wait()\n        w_29 = get_windmills(29)\n        windmill_stroke_width = 2\n        windmills = VGroup()\n        positions = [-4.825, -1.25, 2, 4.5, 6.375]\n        for n, i in enumerate(w_29):\n            windmill = Windmill(*i, l_kwargs={'stroke_width': windmill_stroke_width}, i_kwargs={'fill_color': A_PINK, 'fill_opacity': 0.5, 'stroke_width': windmill_stroke_width}, o_kwargs={'fill_color': A_AQUA, 'fill_opacity': 0.5, 'stroke_width': windmill_stroke_width})\n            windmill.scale(0.25)\n            windmill.move_to(positions[n] * RIGHT)\n            windmills.add(windmill)\n        windmills.center()\n        windmills.shift(0.75 * DOWN)\n        labels = VGroup(*[Tex(f'({x}, {y}, {z})').move_to(windmills[i]).shift(2.5 * DOWN) for i, (x, y, z) in enumerate(w_29)])\n        self.play(Write(windmills[2]), Write(labels[2]))\n        for i in range(5):\n            if i != 2:\n                self.play(Write(windmills[i]), Write(labels[i]))\n        b = Brace(windmills, UP)\n        t = Tex('W_{29}', tex_to_color_map={'W': A_YELLOW, '{29}': A_UNKA})\n        b.put_at_tip(t)\n        self.play(Write(b), Write(t))\n        self.wait()\n        self.play(Uncreate(VGroup(b, t, windmills, labels)))\n        head_t = Tex('\\\\text{For all } p = 4k + 1', tex_to_color_map={'p': A_GREEN, 'k': A_ORANGE, '4': A_UNKA, '1': A_UNKA})\n        head_t.scale(1.5)\n        head_t.shift(3 * UP)\n        eq2 = Tex('W_{p} = \\\\lbrace (x, y, z) \\\\in \\\\mathbb{{N}}^3 \\\\ | \\\\ x^2 + 4yz = {p} \\\\rbrace', tex_to_color_map={'W': A_YELLOW, '{p}': A_GREEN, 'x': A_PINK, 'y': A_AQUA, 'z': A_AQUA, '2': A_UNKA, '3': A_UNKA, '4': A_UNKA, '{N}': A_LAVENDER})\n        eq2.scale(1.5)\n        eq2.shift(1.5 * UP)\n        eq3 = Tex('{p} = x^2 + 4yz', tex_to_color_map={'{p}': A_GREEN, 'x': A_PINK, 'y': A_AQUA, 'z': A_AQUA, '2': A_UNKA, '4': A_UNKA})\n        eq3.scale(1.5)\n        self.play(Transform(eq1, eq2))\n        self.play(Write(head_t))\n        self.wait()\n        self.play(TransformMatchingTex(eq2[12:-1], eq3))\n        self.wait()\n        eq4 = Tex('{p} = x^2 + 4y^2', tex_to_color_map={'{p}': A_GREEN, 'x': A_PINK, 'y': A_AQUA, 'z': A_AQUA, '2': A_UNKA, '4': A_UNKA})\n        eq4.scale(1.5)\n        eq4.shift(3 * DOWN)\n        arrow = Arrow(eq3, eq4, stroke_color=A_YELLOW, buff=0.35, stroke_width=16)\n        arrow_tex = Tex('y=z', tex_to_color_map={'y': A_AQUA, 'z': A_AQUA})\n        arrow_tex.scale(1.5)\n        arrow_tex.move_to(arrow)\n        arrow_tex.shift(1.5 * RIGHT)\n        cp = eq3.copy()\n        self.play(Write(arrow), Write(arrow_tex))\n        self.wait()\n        self.play(Transform(cp, eq4))\n        self.wait()\n        eq5 = Tex('{p} = x^2 + (2y)^2', tex_to_color_map={'{p}': A_GREEN, 'x': A_PINK, 'y': A_AQUA, 'z': A_AQUA, '2': A_UNKA, '4': A_UNKA})\n        eq5.scale(1.5)\n        eq5.shift(3 * DOWN)\n        self.play(TransformMatchingTex(cp, eq5))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display a collection of windmills with corresponding coordinate labels, a title, and a brace, then highlight specific windmills and a related equation."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass WindmillOne(Scene):\n\n    def construct(self):\n        w_13 = get_windmills(13)\n        windmill_stroke_width = 2\n        windmills = VGroup()\n        positions = [-4.825, -1.25, 2]\n        for n, i in enumerate(w_13):\n            windmill = Windmill(*i, l_kwargs={'stroke_width': windmill_stroke_width}, i_kwargs={'fill_color': A_PINK, 'fill_opacity': 0.5, 'stroke_width': windmill_stroke_width}, o_kwargs={'fill_color': A_AQUA, 'fill_opacity': 0.5, 'stroke_width': windmill_stroke_width})\n            windmill.scale(0.5)\n            windmill.move_to(positions[n] * RIGHT)\n            windmills.add(windmill)\n        windmills.center()\n        labels = VGroup(*[Tex(f'({x}, {y}, {z})').move_to(windmills[i]).shift(2.5 * DOWN) for i, (x, y, z) in enumerate(w_13)])\n        title = Tex('W_{13}', tex_to_color_map={'W': A_YELLOW, '{13}': A_GREEN})\n        title.scale(1.5)\n        b = Brace(windmills, UP)\n        b.put_at_tip(title)\n        grp = VGroup(windmills, b, labels, title)\n        grp.center()\n        self.play(Write(title), Write(b))\n        for i in range(3):\n            self.play(Write(windmills[i]), Write(labels[i]))\n        self.wait()\n        self.play(Indicate(VGroup(windmills[-1], labels[-1])))\n        self.wait()\n        eq = Tex('(1, 1, k)', '\\\\in W_{4k+1}', tex_to_color_map={'W': A_YELLOW, '4': A_UNKA, '1': A_UNKA, 'k': A_ORANGE})\n        eq.scale(1.5)\n        eq.shift(3.25 * DOWN)\n        self.play(ApplyMethod(VGroup(windmills, labels, b, title).shift, 0.5 * UP), Write(eq))\n        self.play(Indicate(eq[:7]), Indicate(VGroup(windmills[0], labels[0])))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Illustrate a windmill animation with accompanying mathematical expressions explaining its area and prime decomposition properties."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass WindmillProof(Scene):\n\n    def construct(self):\n        head_t = Tex('\\\\text{In }', '{W_{p = 4k}}', '{}_{+}', '{}_{1}', '\\\\text{, (1, 1, k) is the ONLY windmill with } {x} = {y}', tex_to_color_map={'p': A_GREEN, 'k': A_ORANGE, '4': A_UNKA, '1': A_UNKA, '{x}': A_PINK, '{y}': A_AQUA, '{z}': A_AQUA, 'W': A_YELLOW, '{p}': A_GREEN})\n        head_t.shift(3.25 * UP)\n        self.play(Write(head_t))\n        w = Windmill(1, 1, 3)\n        w.scale(0.75)\n        w.shift(0.8 * DOWN)\n        self.play(Write(w))\n        self.play(w.rects[0].rotate, 90 * DEGREES)\n        self.play(w.rects[0].shift, 2 * LEFT + 0.2 * DOWN)\n        b1 = Brace(w.rects[0], RIGHT)\n        b2 = Brace(w.square, UP)\n        x_label = Tex('x', color=A_PINK)\n        x_label.scale(1.5)\n        x_label.shift(0.5 * UP)\n        self.play(Write(b1), Write(b2), Write(x_label))\n        self.wait()\n        self.play(Uncreate(VGroup(b1, b2, x_label)), ApplyMethod(w.rects[0].rotate, -90 * DEGREES))\n        self.play(w.rects[0].shift, 2 * RIGHT + 0.2 * UP)\n        self.wait()\n        w2 = Windmill(1, 1, 3, freq=float('inf'))\n        w2.scale(0.75)\n        w2.shift(0.8 * DOWN)\n        self.play(Transform(w, w2))\n        self.wait()\n        x, z = (ValueTracker(1), ValueTracker(3))\n        w.add_updater(lambda w: w.become(Windmill(x.get_value(), x.get_value(), z.get_value(), freq=float('inf'))).scale(0.75).shift(0.8 * DOWN))\n        self.play(x.increment_value, 2, rate_func=there_and_back)\n        self.play(x.increment_value, -0.75, rate_func=there_and_back)\n        self.play(z.increment_value, 0.75, rate_func=there_and_back)\n        self.play(z.increment_value, -2, rate_func=there_and_back)\n        self.wait()\n        w.clear_updaters()\n        w3 = Windmill(1, 1, 3)\n        w3.scale(0.75)\n        w3.shift(0.8 * DOWN + 3.5 * LEFT)\n        self.play(Transform(w, w3))\n        eq1 = Tex('\\\\text{Area} = \\\\text{prime } 4{k}+1', tex_to_color_map={'\\\\text{Area}': A_LAVENDER, '\\\\text{prime }': A_GREEN, '{p}': A_GREEN, '{k}': A_ORANGE, '4': A_UNKA, '1': A_UNKA})\n        eq1.move_to(2.5 * RIGHT + 2 * UP)\n        eq2 = Tex('= {x}^2 + 4{x}z', tex_to_color_map={'{x}': A_PINK, 'y': A_AQUA, 'z': A_AQUA, '2': A_UNKA, '4': A_UNKA})\n        eq2.move_to(eq1[1], LEFT)\n        eq2.shift(DOWN)\n        eq3 = Tex('x(x+4z)', tex_to_color_map={'x': A_PINK, '4': A_UNKA, 'z': A_AQUA})\n        eq3.scale(1.25)\n        eq3.move_to(eq2)\n        eq3.shift(1.5 * DOWN)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(eq2))\n        self.wait()\n        self.play(TransformMatchingTex(eq2[1:].copy(), eq3))\n        self.wait()\n        eq4 = Tex('\\\\text{If } {x} \\\\neq 1, \\\\text{ then this provides a}\\\\\\\\ \\\\text{ decomposition of a prime}', tex_to_color_map={'{x}': A_PINK, '1': A_UNKA})\n        eq4.move_to(eq3)\n        eq4.shift(1.5 * DOWN)\n        self.play(Write(eq4))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Visualize the effect of a \"Flip Map\" by transforming a windmill and its coordinate representation."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass FlipMap(Scene):\n\n    def construct(self):\n        left_w = Windmill(3, 1, 5)\n        left_w.scale(0.4)\n        left_w.shift(FRAME_WIDTH / 4 * LEFT + 0.5 * UP)\n        right_w = Windmill(3, 5, 1)\n        right_w.scale(0.4)\n        right_w.shift(FRAME_WIDTH / 4 * RIGHT + 0.5 * UP)\n        left_t = Tex('(x, y, z)', tex_to_color_map={'x': A_PINK, 'y': A_UNKA, 'z': A_UNKA})\n        left_t.scale(1.5)\n        left_t.move_to(FRAME_WIDTH / 4 * LEFT + 3 * DOWN)\n        right_t = Tex('(x, z, y)', tex_to_color_map={'x': A_PINK, 'y': A_UNKA, 'z': A_UNKA})\n        right_t.scale(1.5)\n        right_t.move_to(FRAME_WIDTH / 4 * RIGHT + 3 * DOWN)\n        red_arrow = Arrow(LEFT, RIGHT, stroke_color=A_RED, stroke_width=50, max_width_to_length_ratio=10)\n        self.play(Write(left_w), Write(left_t))\n        self.play(Write(red_arrow))\n        self.play(get_flip_transform(left_w, right_w), TransformMatchingTex(left_t.copy(), right_t), run_time=4)\n        self.remove(self.mobjects[-2])\n        self.add(right_w)\n        self.wait()\n        left_t_new = Tex('(3, 1, 5)', tex_to_color_map={'3': A_UNKA, '1': A_UNKA, '5': A_UNKA})\n        left_t_new.scale(1.5)\n        left_t_new.move_to(FRAME_WIDTH / 4 * LEFT + 3 * DOWN)\n        right_t_new = Tex('(3, 5, 1)', tex_to_color_map={'3': A_UNKA, '1': A_UNKA, '5': A_UNKA})\n        right_t_new.scale(1.5)\n        right_t_new.move_to(FRAME_WIDTH / 4 * RIGHT + 3 * DOWN)\n        self.play(TransformMatchingTex(left_t, left_t_new))\n        self.play(TransformMatchingTex(right_t, right_t_new))\n        self.wait()\n        title = TexText('The Flip Map', color=A_BLUE)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        self.play(Write(title))\n        self.wait()\n        left_w_yz = Windmill(3, 2, 2)\n        left_w_yz.scale(0.4)\n        left_w_yz.shift(FRAME_WIDTH / 4 * LEFT + 0.5 * UP)\n        right_w_yz = Windmill(3, 2, 2)\n        right_w_yz.scale(0.4)\n        right_w_yz.shift(FRAME_WIDTH / 4 * RIGHT + 0.5 * UP)\n        left_t_yz = Tex('(3, 2, 2)', tex_to_color_map={'3': A_UNKA, '2': A_UNKA})\n        left_t_yz.scale(1.5)\n        left_t_yz.move_to(FRAME_WIDTH / 4 * LEFT + 3 * DOWN)\n        right_t_yz = Tex('(3, 2, 2)', tex_to_color_map={'3': A_UNKA, '2': A_UNKA})\n        right_t_yz.scale(1.5)\n        right_t_yz.move_to(FRAME_WIDTH / 4 * RIGHT + 3 * DOWN)\n        self.play(Transform(left_w, left_w_yz), TransformMatchingTex(left_t_new, left_t_yz))\n        self.play(Transform(right_w, right_w_yz), TransformMatchingTex(right_t_new, right_t_yz))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Visualize the Zagier map by animating a sequence of windmills and their corresponding text labels, transforming and moving them across the screen."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass ZagierMap(Scene):\n\n    def construct(self):\n        title = TexText('The Zagier Map', color=A_LAVENDER)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        w_1 = Windmill(3, 5, 1)\n        w_1.scale(0.5)\n        t_1 = Tex('(3, 5, 1)', tex_to_color_map={'3': A_UNKA, '5': A_UNKA, '1': A_UNKA})\n        t_1.scale(1.5)\n        t_1.shift(3 * DOWN)\n        s = Square(2.5, stroke_width=10, color=A_YELLOW)\n        red_arrow = Arrow(LEFT, RIGHT, stroke_color=A_RED, stroke_width=50, max_width_to_length_ratio=10)\n        self.play(Write(title))\n        self.wait()\n        self.play(Write(w_1), Write(t_1))\n        self.wait()\n        self.play(Write(s))\n        self.play(Indicate(s))\n        self.wait()\n        self.play(ApplyMethod(w_1.shift, FRAME_WIDTH / 4 * LEFT), ApplyMethod(t_1.shift, FRAME_WIDTH / 4 * LEFT))\n        w_1_cp = w_1.deepcopy()\n        self.add(w_1_cp)\n        self.bring_to_front(s)\n        self.play(Write(red_arrow), ApplyMethod(s.shift, FRAME_WIDTH / 4 * RIGHT), ApplyMethod(w_1_cp.shift, FRAME_WIDTH / 2 * RIGHT))\n        self.wait()\n        w_2 = Windmill(5, 1, 1)\n        w_2.scale(0.5)\n        w_2.shift(FRAME_WIDTH / 4 * RIGHT)\n        t_2 = Tex('(5, 1, 1)', tex_to_color_map={'5': A_UNKA, '1': A_UNKA})\n        t_2.scale(1.5)\n        t_2.shift(FRAME_WIDTH / 4 * RIGHT + 3 * DOWN)\n        self.play(Indicate(s))\n        self.play(Transform(w_1_cp.square, w_2.square), Uncreate(s), TransformMatchingTex(t_1.copy(), t_2))\n        self.remove(w_1_cp)\n        self.add(w_2)\n        self.wait()\n        self.play(FadeOut(w_2, UP), FadeOut(t_1, UP), FadeOut(t_2, UP), FadeOut(w_1, UP), FadeOut(red_arrow, UP))\n        w_3 = Windmill(3, 1, 2)\n        w_3.scale(0.5)\n        w_3.shift(FRAME_WIDTH / 4 * LEFT)\n        t_3 = Tex('(3, 1, 2)', tex_to_color_map={'3': A_UNKA, '2': A_UNKA, '1': A_UNKA})\n        t_3.scale(1.5)\n        t_3.shift(FRAME_WIDTH / 4 * LEFT + 3 * DOWN)\n        red_arrow = Arrow(LEFT, RIGHT, stroke_color=A_RED, stroke_width=50, max_width_to_length_ratio=10)\n        s = Square(1.5, stroke_width=10, color=A_YELLOW)\n        s.shift(FRAME_WIDTH / 4 * LEFT)\n        self.play(Write(w_3), Write(t_3))\n        self.play(Write(red_arrow))\n        self.wait()\n        self.play(Write(s))\n        self.play(Indicate(s))\n        w_4 = Windmill(1, 4, 1)\n        w_4.scale(0.5)\n        w_4.shift(FRAME_WIDTH / 4 * RIGHT)\n        w_3_cp = w_3.deepcopy()\n        w_3_cp.move_to(w_4)\n        t_4 = Tex('(1, 4, 1)', tex_to_color_map={'4': A_UNKA, '1': A_UNKA})\n        t_4.scale(1.5)\n        t_4.shift(FRAME_WIDTH / 4 * RIGHT + 3 * DOWN)\n        self.play(TransformFromCopy(w_3, w_3_cp))\n        self.play(Write(w_4), Uncreate(s), TransformMatchingTex(t_3.copy(), t_4))\n        self.wait()\n        self.remove(w_3_cp)\n        self.add(w_4)\n        self.play(ApplyMethod(VGroup(w_3, t_3).shift, FRAME_WIDTH / 2 * RIGHT), ApplyMethod(VGroup(w_4, t_4).shift, FRAME_WIDTH / 2 * LEFT))\n        self.wait()\n        self.play(ApplyMethod(VGroup(w_3, t_3).shift, FRAME_WIDTH / 2 * LEFT), ApplyMethod(VGroup(w_4, t_4).shift, FRAME_WIDTH / 2 * RIGHT))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display five cases of Zagier's theorem, each with a condition, a windmill diagram, and a corresponding mapping, organized with horizontal and vertical lines, and highlight each case with a temporary yellow rectangle."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass ZagierCases(Scene):\n\n    def construct(self):\n        cases = ['2y < x', 'y < x \\\\land x < 2y', 'y = x', 'y-z < x \\\\land x < y', 'x < y-z']\n        windmills = [[[3, 1, 1], [1, 3, 1]], [[3, 2, 1], [1, 2, 2]], [[3, 3, 1], [3, 3, 1]], [[1, 2, 2], [3, 2, 1]], [[1, 3, 1], [3, 1, 1]]]\n        mapping = ['(x, y, z) \\\\mapsto (x-2y, x+z-y, y)', '(x, y, z) \\\\mapsto (2y-x, y, x+z-y)', '(x, y, z) \\\\mapsto (x, y, z)', '(x, y, z) \\\\mapsto (2y-x, y, x+z-y)', '(x, y, z) \\\\mapsto (x+2z, z, y-x-z)']\n        c_grp, w_grp, m_grp, lines = (VGroup(), VGroup(), VGroup(), VGroup())\n        for i in range(5):\n            wl = Windmill(*windmills[i][0], stroke_width=1).scale(0.25)\n            wl.shift((i - 2) * FRAME_WIDTH / 9 * UP + 2.75 * LEFT)\n            w_grp.add(wl)\n            red_arrow = Arrow(1.75 * LEFT + (i - 2) * FRAME_WIDTH / 9 * UP, 0.75 * LEFT + (i - 2) * FRAME_WIDTH / 9 * UP, stroke_color=A_RED, stroke_width=7.5, max_width_to_length_ratio=50)\n            w_grp.add(red_arrow)\n            wr = Windmill(*windmills[i][1], stroke_width=1).scale(0.25)\n            wr.shift((i - 2) * FRAME_WIDTH / 9 * UP + 0.25 * RIGHT)\n            w_grp.add(wr)\n            c = Tex(cases[i], tex_to_color_map={'x': A_PINK, 'y': A_AQUA, 'z': A_AQUA, '2': A_UNKA})\n            c.scale(0.75)\n            c.shift((i - 2) * FRAME_WIDTH / 9 * UP + 5.375 * LEFT)\n            c_grp.add(c)\n            m = Tex(mapping[i], tex_to_color_map={'x': A_PINK, 'y': A_AQUA, 'z': A_AQUA, '2': A_UNKA})\n            m.scale(0.75)\n            m.shift((i - 2) * FRAME_WIDTH / 9 * UP + 4 * RIGHT)\n            m_grp.add(m)\n        for i in range(4):\n            line = Line(10 * LEFT, 10 * RIGHT, stroke_width=0.75)\n            line.move_to(((i - 2) * FRAME_WIDTH / 9 + FRAME_WIDTH / 18) * UP)\n            lines.add(line)\n        left_line = Line(10 * UP, 10 * DOWN, stroke_width=0.75)\n        left_line.move_to(3.75 * LEFT)\n        right_line = Line(10 * UP, 10 * DOWN, stroke_width=0.75)\n        right_line.move_to(1.25 * RIGHT)\n        self.play(Write(c_grp), Write(w_grp), Write(m_grp), Write(lines))\n        self.wait()\n        b_rect = Rectangle(width=FRAME_WIDTH, height=FRAME_WIDTH / 9, stroke_color=A_YELLOW)\n        b_rect.shift(FRAME_WIDTH / 9 * DOWN)\n        self.play(Write(b_rect))\n        self.wait()\n        self.play(Uncreate(b_rect))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Create a scene titled \"Fixed Point of Zagier Map\" and animate a windmill with its associated coordinates, a square, and an arrow, demonstrating a transformation and repositioning."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass ZagierFixed(Scene):\n\n    def construct(self):\n        title = Tex('\\\\text{Fixed Point of Zagier Map }({x}={y})', tex_to_color_map={'{x}': A_PINK, '{y}': A_AQUA, '(': WHITE, ')': WHITE, '=': WHITE, '\\\\text{Fixed Point of Zagier Map }': A_GREY})\n        title.scale(1.25)\n        title.shift(3 * UP)\n        w_1 = Windmill(3, 3, 2)\n        w_1.scale(0.5)\n        t_1 = Tex('(3, 3, 2)', tex_to_color_map={'3': A_UNKA, '2': A_UNKA})\n        t_1.scale(1.5)\n        t_1.shift(3 * DOWN)\n        s = Square(1.5, stroke_width=10, color=A_YELLOW)\n        red_arrow = Arrow(LEFT, RIGHT, stroke_color=A_RED, stroke_width=50, max_width_to_length_ratio=10)\n        self.play(Write(title))\n        self.wait()\n        self.play(Write(w_1), Write(t_1))\n        self.wait()\n        self.play(Write(s))\n        self.play(Indicate(s))\n        self.wait()\n        self.play(ApplyMethod(w_1.shift, FRAME_WIDTH / 4 * LEFT), ApplyMethod(t_1.shift, FRAME_WIDTH / 4 * LEFT))\n        w_1_cp = w_1.deepcopy()\n        self.play(Write(red_arrow), ApplyMethod(w_1_cp.shift, FRAME_WIDTH / 2 * RIGHT), ApplyMethod(s.shift, FRAME_WIDTH / 4 * RIGHT))\n        self.bring_to_front(s)\n        self.wait()\n        w_2 = Windmill(3, 3, 2)\n        w_2.scale(0.5)\n        w_2.shift(FRAME_WIDTH / 4 * RIGHT)\n        t_2 = Tex('(3, 3, 2)', tex_to_color_map={'3': A_UNKA, '2': A_UNKA})\n        t_2.scale(1.5)\n        t_2.shift(FRAME_WIDTH / 4 * RIGHT + 3 * DOWN)\n        self.play(Write(t_2))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Illustrate the Zagier map's fixed point on the W_{4k+1} manifold by displaying a title, a windmill object with coordinates, a colored square, and an arrow indicating transformation."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass ZagierPrime(Scene):\n\n    def construct(self):\n        title = Tex('\\\\text{Zagier Map has one fixed point on }W_{4k+1}', tex_to_color_map={'W': A_YELLOW, '4': A_UNKA, '1': A_UNKA, 'k': A_ORANGE})\n        title.scale(1.25)\n        title.shift(3 * UP)\n        w_1 = Windmill(1, 1, 3)\n        w_1.scale(0.5)\n        t_1 = Tex('(1, 1, k)', tex_to_color_map={'1': A_UNKA, 'k': A_ORANGE})\n        t_1.scale(1.5)\n        t_1.shift(3 * DOWN)\n        s = Square(0.5, stroke_width=10, color=A_YELLOW)\n        red_arrow = Arrow(LEFT, RIGHT, stroke_color=A_RED, stroke_width=50, max_width_to_length_ratio=10)\n        self.play(Write(title))\n        self.wait()\n        self.play(Write(w_1), Write(t_1))\n        self.wait()\n        self.play(Write(s))\n        self.play(Indicate(s))\n        self.wait()\n        self.play(ApplyMethod(w_1.shift, FRAME_WIDTH / 4 * LEFT), ApplyMethod(t_1.shift, FRAME_WIDTH / 4 * LEFT))\n        w_1_cp = w_1.deepcopy()\n        self.play(Write(red_arrow), ApplyMethod(w_1_cp.shift, FRAME_WIDTH / 2 * RIGHT), ApplyMethod(s.shift, FRAME_WIDTH / 4 * RIGHT))\n        self.bring_to_front(s)\n        self.wait()\n        w_2 = Windmill(1, 1, 3)\n        w_2.scale(0.5)\n        w_2.shift(FRAME_WIDTH / 4 * RIGHT)\n        t_2 = Tex('(1, 1, k)', tex_to_color_map={'1': A_UNKA, 'k': A_ORANGE})\n        t_2.scale(1.5)\n        t_2.shift(FRAME_WIDTH / 4 * RIGHT + 3 * DOWN)\n        self.play(Write(t_2))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Present a mathematical proof step-by-step using text and transformations."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass FinalProof(Scene):\n\n    def construct(self):\n        text1 = Tex('\\\\text{For prime } {p} = 4k + 1', tex_to_color_map={'{p}': A_GREEN, 'k': A_ORANGE, '4': A_UNKA, '1': A_UNKA})\n        text1.move_to((FRAME_HEIGHT / 2 - FRAME_HEIGHT / 5) * UP, LEFT)\n        text2 = Tex('\\\\text{Zagier Map has one fixed point} \\\\Longrightarrow |W_{p}| \\\\text{ is odd}', tex_to_color_map={'W': A_YELLOW, '{p}': A_GREEN, 'fixed point': A_LAVENDER, 'Zagier Map': A_GREY, 'odd': A_UNKA})\n        text2.move_to((FRAME_HEIGHT / 2 - 2 * FRAME_HEIGHT / 5) * UP, LEFT)\n        text3 = Tex('|W_{p}| \\\\text{ is }\\\\text{odd} \\\\Longrightarrow \\\\text{Flip Map}', '\\\\text{ has}', '\\\\text{ odd number of}', '\\\\text{ fixed point}', '\\\\text{s}', tex_to_color_map={'W': A_YELLOW, '{p}': A_GREEN, '\\\\text{Flip Map}': A_BLUE, '\\\\text{odd}': A_UNKA})\n        text3.move_to((FRAME_HEIGHT / 2 - 3 * FRAME_HEIGHT / 5) * UP, LEFT)\n        text4 = Tex('|W_{p}| \\\\text{ is }\\\\text{odd} \\\\Longrightarrow \\\\text{Flip Map}', '\\\\text{ has}', '\\\\text{ at least one}', '\\\\text{ fixed point}', tex_to_color_map={'W': A_YELLOW, '{p}': A_GREEN, '\\\\text{Flip Map}': A_BLUE, '\\\\text{odd}': A_UNKA})\n        text4.move_to((FRAME_HEIGHT / 2 - 3 * FRAME_HEIGHT / 5) * UP, LEFT)\n        text5 = Tex('|\\\\text{fixed} \\\\ \\\\text{Flip Map} \\\\ W_{p}| \\\\geq 1 \\\\Longrightarrow {p} \\\\text{ is a sum of two squares}', tex_to_color_map={'\\\\text{Flip Map}': A_BLUE, '\\\\text{fixed}': A_LAVENDER, '{p}': A_GREEN, 'W': A_YELLOW, '1': A_UNKA})\n        text5.move_to((FRAME_HEIGHT / 2 - 4 * FRAME_HEIGHT / 5) * UP, LEFT)\n        VGroup(text1, text2, text3, text4, text5).shift(6 * LEFT)\n        self.play(Write(text1))\n        self.wait()\n        self.play(Write(text2))\n        self.wait()\n        self.play(Write(text3))\n        self.wait()\n        self.play(TransformMatchingTex(text3, text4))\n        self.wait()\n        self.play(Write(text5))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display an image of Paul Erd\u0151s with his name, connected by lines to a rectangle."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass ErdosBook(Scene):\n\n    def construct(self):\n        back = ImageMobject('img/erdos_back.jpg', height=FRAME_HEIGHT)\n        rect = Rectangle(height=0.75, width=2.5, stroke_width=8)\n        rect.shift(1.4 * LEFT + 0.625 * UP)\n        self.play(Write(rect))\n        erdos = ImageMobject('img/paul_erdos.jpeg')\n        erdos.shift(4 * RIGHT + 1 * UP)\n        erdos_rect = BackgroundRectangle(erdos, fill_opacity=0, stroke_width=8, stroke_color=WHITE, stroke_opacity=1)\n        lines = VGroup(Line(rect.get_vertices()[0], erdos_rect.get_vertices()[1], stroke_width=8), Line(rect.get_vertices()[3], erdos_rect.get_vertices()[2], stroke_width=8))\n        text = TexText('Paul Erd\u0151s')\n        text.scale(1.5)\n        text.move_to(erdos_rect, DOWN)\n        text.shift(0.75 * DOWN)\n        self.play(Write(erdos_rect), Write(lines), Write(text))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display an image of Paul Erd\u0151s with his name, framed by a rectangle and connected by lines to a title box above."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass ErdosBookVertical(Scene):\n\n    def construct(self):\n        b_rect = Rectangle(height=FRAME_HEIGHT, width=9 / 16 * FRAME_HEIGHT, fill_opacity=1, fill_color='#252626', stroke_width=0)\n        rect = Rectangle(height=0.75, width=2.5, stroke_width=8)\n        rect.shift(3 * UP)\n        self.play(Write(rect))\n        erdos = ImageMobject('img/paul_erdos.jpeg')\n        erdos.move_to(rect)\n        erdos.shift(4 * DOWN)\n        erdos_rect = BackgroundRectangle(erdos, fill_opacity=0, stroke_width=8, stroke_color=WHITE, stroke_opacity=1)\n        lines = VGroup(Line(rect.get_vertices()[2], erdos_rect.get_vertices()[1], stroke_width=8), Line(rect.get_vertices()[3], erdos_rect.get_vertices()[0], stroke_width=8))\n        text = TexText('Paul Erd\u0151s')\n        text.scale(1.5)\n        text.move_to(erdos_rect, DOWN)\n        text.shift(0.75 * DOWN)\n        self.play(Write(erdos_rect), Write(lines), Write(text))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display Fermat's Two Squares Theorem with a title and example equations, visually connecting the theorem statement to specific mathematical expressions."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass BookFermat(Scene):\n\n    def construct(self):\n        back = ImageMobject('img/fermat_back', height=FRAME_HEIGHT)\n        title = TexText(\"Fermat's Two Squares Theorem\", color=A_LAVENDER)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        rect = BackgroundRectangle(title, buff=SMALL_BUFF)\n        title = VGroup(rect, title)\n        rect = Rectangle(width=3.5, height=0.5, stroke_width=8)\n        rect.shift(1.5 * RIGHT + 1.625 * UP)\n        rect_2 = Rectangle(width=13.5, height=3, stroke_width=8, fill_color=GREY_D, fill_opacity=1)\n        rect_2.shift(1.5 * DOWN)\n        lines = VGroup(Line(rect.get_vertices()[2], rect_2.get_vertices()[1], stroke_width=8), Line(rect.get_vertices()[3], rect_2.get_vertices()[0], stroke_width=8))\n        eq1 = Tex('\\\\text{Every prime of the form } {p}=4{k}+1 \\\\text{ can be expressed as a sum of two squares.', tex_to_color_map={'{p}': A_GREEN, '{k}': A_ORANGE, '4': A_UNKA, '1': A_UNKA})\n        eq1.scale(0.8)\n        eq2 = Tex('{13} = 4 \\\\cdot{ {3} }+ 1 ={3}^2 + {2}^2', tex_to_color_map={'{3}': A_UNKA, '{ {3} }': A_ORANGE, '^2': GREY_A, '{2}': A_UNKA, '4': A_UNKA, '1': A_UNKA, '{13}': A_GREEN})\n        eq2.scale(0.8)\n        eq2.shift(0.75 * DOWN)\n        eq3 = Tex('29 = 4 \\\\cdot 7 + 1 = 5^2 + {2}^2', tex_to_color_map={'29': A_GREEN, '5': A_UNKA, '^2': GREY_A, '{2}': A_UNKA, '4': A_UNKA, '1': A_UNKA, '7': A_ORANGE})\n        eq3.scale(0.8)\n        eq3.shift(1.5 * DOWN)\n        VGroup(eq1, eq2, eq3).move_to(rect_2)\n        self.play(Write(rect), Write(title))\n        self.play(Write(rect_2), Write(lines))\n        self.play(Write(eq1))\n        self.play(Write(eq2))\n        self.play(Write(eq3))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Display Fermat's Two Squares Theorem title, a graphic representing the theorem's statement, and examples of primes expressed as sums of two squares."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass BookFermatVertical(Scene):\n\n    def construct(self):\n        title = TexText(\"Fermat's Two \\\\\\\\ Squares Theorem\", color=A_LAVENDER)\n        title.scale(1.25)\n        title.shift(2.5 * UP)\n        rect = BackgroundRectangle(title, buff=SMALL_BUFF)\n        title = VGroup(rect, title)\n        rect = Rectangle(width=9 / 16 * FRAME_HEIGHT, height=0.5, stroke_width=8)\n        rect.shift(1.25 * UP)\n        rect_2 = Rectangle(width=4.5, height=3, stroke_width=8, fill_color=GREY_D, fill_opacity=1)\n        rect_2.shift(1.75 * DOWN)\n        lines = VGroup(Line(rect.get_vertices()[2], rect_2.get_vertices()[1], stroke_width=8), Line(rect.get_vertices()[3], rect_2.get_vertices()[0], stroke_width=8))\n        eq1 = TexText('Every prime of the form \\\\\\\\', '${p}$ $=$ $4$${k}$ $+$ $1$ can be expressed \\\\\\\\', 'as a sum of two squares. \\\\\\\\ \\\\leavevmode \\\\\\\\', '$13$ $=$ $4$ $\\\\cdot$ ${3}$ $+$ $1$ $=$ $3$$^2$ $+$ $2$$^2$ \\\\\\\\', '$29$ $=$ $4$ $\\\\cdot$ $7$ $+$ $1$ $=$ $5$$^2$ $+$ $2$$^2$ \\\\\\\\', tex_to_color_map={'${p}$': A_GREEN, '${k}$': A_ORANGE, '$4$': A_UNKA, '$1$': A_UNKA, '$13$': A_GREEN, '${3}$': A_ORANGE, '$^2$': GREY_A, '$3$': A_UNKA, '$2$': A_UNKA, '$4$': A_UNKA, '$1$': A_UNKA, '$29$': A_GREEN, '$5$': A_UNKA, '$^2$': GREY_A, '$2$': A_UNKA, '$4$': A_UNKA, '$1$': A_UNKA, '$7$': A_ORANGE})\n        eq1.scale(0.7)\n        eq1.move_to(rect_2)\n        self.play(Write(rect), Write(title))\n        self.play(Write(rect_2), Write(lines))\n        self.play(Write(eq1))\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Create a scene with two windmills facing each other with a large red arrow between them."}, {"role": "assistant", "content": "from manimlib import *\nfrom itertools import product\n\nclass Thumbnail(Scene):\n\n    def construct(self):\n        w1 = Windmill(3, 1, 2)\n        w1.scale(0.75)\n        w1.shift((FRAME_WIDTH / 4 + 0.5) * LEFT)\n        w2 = Windmill(1, 4, 1)\n        w2.scale(0.75)\n        w2.shift((FRAME_WIDTH / 4 + 0.5) * RIGHT)\n        red_arrow = Arrow(LEFT, RIGHT, stroke_color=A_RED, stroke_width=100, max_width_to_length_ratio=35, tip_width_ratio=2)\n        self.add(w1, w2, red_arrow)\n        self.wait()\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Animate a function graph whose shape changes over time."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Graph(Scene):\n\n    def construct(self):\n        t = ValueTracker(0.1)\n        f = FunctionGraph(func, color=GOLD).scale(5)\n        axes = Axes(x_min=-15, x_max=15, y_min=-15, y_max=15, number_line_config={'color': LIGHT_GREY, 'include_tip': True, 'exclude_zero_from_default_numbers': True})\n        f.add_updater(lambda x: x.become(FunctionGraph(lambda x: func(x, t.get_value()), color=GOLD).scale(5)))\n        self.play(Write(f))\n        self.play(t.increment_value, 4.9, run_time=3, rate_func=linear)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the drawing of a function graph, then a secant line connecting two points on the graph, with one point moving along the graph, and zoom in on the moving point."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Secant(MovingCameraScene):\n    CONFIG = {'x1': -0.4, 'x2': -2.0, 'down': 13.5}\n\n    def construct(self):\n        f = FunctionGraph(lambda x: self.f_s(x, scale=17) - self.down, color=GOLD, stroke_opacity=0.5)\n        self.play(Write(f))\n        self.wait()\n        p1 = Dot(fill_opacity=1, color=YELLOW)\n        p1.shift([self.x1, self.f_s(self.x1) - self.down, 0])\n        t = ValueTracker(-2)\n        p2 = Dot(fill_opacity=1, color=YELLOW)\n        p2.shift([t.get_value(), self.f_s(t.get_value()) - self.down, 0])\n        p2.add_updater(lambda x: x.become(Dot(fill_opacity=1, color=YELLOW).shift([t.get_value(), self.f_s(t.get_value()) - self.down, 0])))\n        line = Line([self.x1, self.f_s(self.x1) - self.down, 0], [t.get_value(), self.f_s(t.get_value()) - self.down, 0])\n        line.scale(100)\n\n        def line_update(l):\n            line = Line([self.x1, self.f_s(self.x1) - self.down, 0], [t.get_value(), self.f_s(t.get_value()) - self.down, 0])\n            line.scale(100)\n            l.become(line)\n        line.add_updater(line_update)\n        self.play(Write(line), Write(p1), Write(p2))\n        self.wait()\n        self.play(t.increment_value, 1.5, run_time=3, rate_func=linear)\n        self.wait()\n        grp = VGroup(f, line, p1, p2)\n        self.remove(p1, p2)\n        width = p1.get_width() * 5\n        self.play(self.camera_frame.set_width, width, self.camera_frame.move_to, p1)\n        p1.scale(0.05)\n        d = Dot(radius=0.05 * DEFAULT_DOT_RADIUS, color=YELLOW, point=p2.get_center())\n        d.add_updater(lambda x: x.become(Dot(fill_opacity=1, radius=0.05 * DEFAULT_DOT_RADIUS, color=YELLOW).shift([t.get_value(), self.f_s(t.get_value()) - self.down, 0])))\n        self.add(p1, d)\n        self.wait()\n        self.play(t.increment_value, 0.09, run_time=3, rate_func=linear)\n        self.wait()\n\n    def f_s_point(self, x, scale, point):\n\n        def f(x):\n            return self.f_s(x) - self.down\n\n        def g(x):\n            return f(x - point) - f(point)\n\n        def z(x):\n            return scale * g(1 / scale * x)\n\n        def ans(x):\n            return z(x + point) + f(point)\n        return ans(x)\n\n    @staticmethod\n    def func(x, b=3):\n        x *= 1 / 10\n        y = 0\n        for i in range(1, maxn):\n            y += np.cos(b ** i * PI * x) / 2 ** i\n        return y\n\n    def f_s(self, x, scale=17):\n        x *= 1 / scale\n        return scale * self.func(x)"}]}
{"messages": [{"role": "user", "content": "Animate the calculation of an anti-derivative by visualizing the integral of a parametric function and its corresponding graph."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass AntiDerivative(Scene):\n\n    def construct(self):\n        r_axes = axes = Axes(x_min=0, x_max=6, y_min=-1, y_max=1, axis_config={'include_tip': False})\n        r_axes.shift(3 * LEFT)\n        c2 = ParametricFunction(self.w_func, t_min=0, t_max=6, color=RED).shift(3 * LEFT)\n        fgrp = VGroup(r_axes, c2)\n        fgrp.shift(1.5 * DOWN)\n        t = ValueTracker(0)\n        grp = VGroup()\n\n        def updater(x):\n            rect = self.get_rect(t.get_value())\n            x.add_to_back(rect)\n            self.bring_to_back(x)\n        grp.add_updater(updater)\n        axes = Axes(x_min=0, x_max=6, y_min=-1, y_max=1, axis_config={'include_tip': False})\n\n        def updater2(x):\n            f = FunctionGraph(self.anti, x_min=-0.01, x_max=t.get_value())\n            f.shift(3 * LEFT + 1.5 * UP)\n            x.become(f)\n        f2 = FunctionGraph(self.anti, x_min=0, x_max=6)\n        f2.add_updater(updater2)\n        grp2 = VGroup(axes, f2)\n        grp2.shift(3 * LEFT + 1.5 * UP)\n        self.play(Write(fgrp), Write(grp))\n        self.play(Write(axes), Write(f2))\n        self.bring_to_back(grp)\n        self.wait()\n        self.play(t.increment_value, 6, run_time=6, rate_func=linear)\n        self.wait()\n\n    def anti(self, x, dx=0.1):\n        return 20 * anti_func(x / 5)\n\n    @staticmethod\n    def w_func(t):\n        return [t, 2.5 * func(t / 5), 0]\n\n    def get_rect(self, t, dx=0.025):\n        y = self.w_func(t)[1]\n        pairity = -1 if y < 0 else 0 if y == 0 else 1\n        return Line(ORIGIN, pairity * (abs(y) - dx) * UP, stroke_width=8, stroke_opacity=0.75, color=BLUE_E).set_opacity(0.75).shift(3 * LEFT + 1.5 * DOWN + t * RIGHT)"}]}
{"messages": [{"role": "user", "content": "Create a horizontal line."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TestScene(Scene):\n\n    def construct(self):\n        l = Line(ORIGIN, 2 * RIGHT)"}]}
{"messages": [{"role": "user", "content": "Present an introduction title and screen rectangle, then remove them before displaying a graph of two linear functions on axes."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        title = TextMobject('Introduction to Linear Equations')\n        title.scale(1.5)\n        title.to_edge(UP)\n        rect = ScreenRectangle(height=6)\n        rect.next_to(title, DOWN)\n        self.play(Write(title), Write(rect))\n        self.wait()\n        self.play(Uncreate(title), Uncreate(rect))\n        self.wait()\n        axes = Axes(x_min=-5, x_max=5, y_min=-3, y_max=3, number_line_config={'include_tip': False})\n        f1 = FunctionGraph(lambda x: x)\n        f2 = FunctionGraph(lambda x: 3 * x, color=RED)\n        self.play(Write(axes), Write(f1), Write(f2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a linear equation and its corresponding graph, then illustrate the calculation of its slope by marking points and showing the rise over run."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SlopeCalc(Scene):\n\n    def construct(self):\n        eqt = TexMobject('y=0.5x+1').scale(1.5)\n        eqt.shift(3 * UP)\n        axes = Axes(x_min=-3, x_max=3, y_min=-2, y_max=2, number_line_config={'include_tip': False})\n        f = ParametricFunction(lambda t: np.array([t, 0.5 * t + 1, 0]), t_min=-3, t_max=3, color=BLUE)\n        eq = VGroup(axes, f).shift(1 * DOWN)\n        self.play(Write(eqt))\n        self.wait()\n        self.play(Write(eq))\n        self.wait()\n        self.play(eq.shift, 2 * RIGHT)\n        self.plot(2)\n        self.plot(1)\n        eq1 = TexMobject('\\\\Delta x = 2 - 1 = 1')\n        eq1.scale(1.25)\n        eq1.shift(3 * LEFT + 2 * UP)\n        eq2 = TexMobject('\\\\Delta y = 2 - 1.5 = 0.5')\n        eq2.scale(1.25)\n        eq2.shift(3 * LEFT + 1 * UP)\n        eq3 = TexMobject('\\\\frac{\\\\Delta y}{\\\\Delta x} = 0.5')\n        eq3.scale(1.25)\n        eq3.shift(4 * LEFT - 2 * UP)\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(eq2))\n        self.wait()\n        self.play(Write(eq3))\n        self.wait()\n        r = Rectangle(height=2, width=3, color=YELLOW).shift(4 * LEFT - 2 * UP)\n        t = TextMobject('Slope', color=GREEN).scale(1.5)\n        t.shift(1 * LEFT + 2 * DOWN)\n        self.play(Write(r), Write(t))\n        self.wait()\n\n    def plot(self, x):\n        y = x * 0.5 + 1\n        p = Circle(radius=0.1, color=YELLOW, fill_opacity=1).shift(x * RIGHT + y * UP)\n        p.shift(2 * RIGHT + 1 * DOWN)\n        t = TexMobject('({},{})'.format(str(x), str(y)))\n        t.shift((x + 2) * RIGHT + (y - 0.25) * UP)\n        self.play(Write(t))\n        self.play(Write(p))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Plot a line with a negative slope on axes."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass NegativeSlope(Scene):\n\n    def construct(self):\n        axes = Axes(x_min=-5, x_max=5, y_min=-5, y_max=5, number_line_config={'include_tip': False})\n        f1 = FunctionGraph(lambda x: -0.5 * x + 1, color=PURPLE)\n        self.play(Write(axes), Write(f1))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Introduce the concept of the equation of a line with its formula and definition of slope."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LinearEq(Scene):\n\n    def construct(self):\n        title = TextMobject('Equation of a Line', color=PINK).scale(1.5)\n        title.shift(2.5 * UP)\n        eq = TexMobject('y = mx + b', tex_to_color_map={'m': BLUE, 'b': GREEN})\n        eq.scale(3)\n        exp = TexMobject('m = \\\\text{Slope}', tex_to_color_map={'m': BLUE}).scale(1.5)\n        exp.shift(2 * DOWN)\n        self.play(Write(title), Write(eq), Write(exp))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate solving for the y-intercept of a linear equation given a point and the slope, then plot the resulting function."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Example(Scene):\n\n    def construct(self):\n        t = TexMobject('y = mx+b')\n        t.scale(1.5)\n        t.shift(3 * UP)\n        given = TexMobject('m = 2 \\\\\\\\ (1,1)', tex_to_color_map={'m': BLUE})\n        given.shift(4 * RIGHT + 3 * UP)\n        eq1 = TexMobject('y = 2x+b')\n        eq1.scale(1.5)\n        eq1.shift(1.5 * UP)\n        eq2 = TexMobject('1 = 2 \\\\cdot 1+b')\n        eq2.scale(1.5)\n        eq2.shift(0 * UP)\n        eq3 = TexMobject('b = -1')\n        eq3.scale(1.5)\n        eq3.shift(-1.5 * UP)\n        eq4 = TexMobject('y=2x-1')\n        eq4.scale(1.5)\n        eq4.shift(-3 * UP)\n        a = Arrow(2 * UP, -0.5 * UP, color=GREEN).shift(3 * RIGHT)\n        l = TexMobject('(1,1)').scale(1.5).shift(4.5 * RIGHT + 0.75 * UP)\n        fb = Rectangle(width=4, height=1, color=YELLOW).shift(3 * DOWN)\n        self.play(Write(t))\n        self.wait()\n        self.play(Write(given))\n        self.wait()\n        self.play(Write(eq1))\n        self.wait()\n        self.play(Write(eq2), Write(a), Write(l))\n        self.wait()\n        self.play(Write(eq3))\n        self.wait()\n        self.play(Write(eq4))\n        self.play(Write(fb))\n        self.wait()\n        v = VGroup()\n        for i in self.mobjects:\n            if i != eq4:\n                v.add(i)\n        self.play(Uncreate(VGroup(v)))\n        self.play(eq4.shift, 6 * UP)\n        self.wait()\n        axes = Axes(x_min=-3, x_max=3, y_min=-3, y_max=3, number_line_config={'include_tip': False})\n        f1 = FunctionGraph(lambda x: 2 * x - 1, color=PINK)\n        func = VGroup(axes, f1)\n        func.shift(0.5 * DOWN)\n        self.play(Write(func))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the title \"Linear Equations\" above three sample linear equations and their graphical representation on a coordinate plane."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        title = TextMobject('Linear Equations', color=RED)\n        title.scale(2)\n        eq1 = TexMobject('2y = 3x + 2').scale(1.5).shift(2 * LEFT + 1 * UP)\n        eq2 = TexMobject('y = x + 3').scale(1.5).shift(3 * LEFT + 1 * DOWN)\n        eq3 = TexMobject('3y + 2x = 1').scale(1.5).shift(2 * LEFT + 3 * DOWN)\n        axes = Axes(x_min=-3, x_max=3, y_min=-3, y_max=3, number_line_config={'include_tip': False})\n        f = FunctionGraph(lambda x: 0.5 * x + 1, x_min=-3, x_max=3)\n        func = VGroup(axes, f)\n        func.shift(2 * RIGHT + 1 * DOWN)\n        self.play(Write(title))\n        self.wait()\n        self.play(title.shift, 3 * UP)\n        self.wait()\n        self.play(Write(func), Write(eq1), Write(eq2), Write(eq3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a Cartesian coordinate system with a point labeled P and a title."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Cartesian(Scene):\n\n    def construct(self):\n        axes = Axes(x_min=-5, x_max=5, y_min=-3, y_max=3, number_line_config={'include_tip': False, 'include_numbers': True}, y_axis_config={'include_numbers': False})\n        p = Circle(radius=0.1, color=YELLOW, fill_opacity=1).shift(3 * RIGHT + 2 * UP)\n        label = TextMobject('P')\n        label.shift(3.5 * RIGHT + 2 * UP)\n        title = TextMobject('Cartesian System', color=ORANGE)\n        title.scale(1.5)\n        title.shift(3 * UP)\n        rect = BackgroundRectangle(title, fill_opacity=1)\n        self.play(Write(axes), Write(rect), Write(title))\n        self.wait()\n        self.play(Write(label), ShowCreation(p))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate how ordered pairs are substituted into and evaluated against the linear equation 2y = 3x + 1."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Satisfy(Scene):\n\n    def construct(self):\n        self.eq = TexMobject('2y = 3x + 1')\n        self.eq.scale(1.5)\n        self.eq.shift(3 * UP)\n        self.play(Write(self.eq))\n        self.wait()\n        m = self.replace(1, 1)\n        self.play(Uncreate(m))\n        self.wait()\n        m = self.replace(1, 2)\n\n    def replace(self, x, y):\n        rect = Rectangle(height=2, width=2, color=YELLOW)\n        val1 = TexMobject('x = {}'.format(x)).shift(0.5 * UP)\n        val2 = TexMobject('y = {}'.format(y)).shift(0.5 * DOWN)\n        r = VGroup(val1, rect, val2)\n        r.shift(4 * RIGHT + 2.5 * UP)\n        t1 = TexMobject('\\\\times')\n        t1.shift(2.5 * LEFT)\n        t2 = TexMobject('\\\\times')\n        t2.shift(-0.5 * LEFT)\n        e1 = TexMobject('2')\n        e1.shift(3 * LEFT)\n        e2 = TexMobject('y')\n        e2.shift(2 * LEFT)\n        e3 = TexMobject('=')\n        e3.shift(1 * LEFT)\n        e4 = TexMobject('3')\n        e4.shift(0 * LEFT)\n        e5 = TexMobject('x')\n        e5.shift(-1 * LEFT)\n        e6 = TexMobject('+')\n        e6.shift(-2 * LEFT)\n        e7 = TexMobject('1')\n        e7.shift(-3 * LEFT)\n        group = VGroup(e1, e2, e3, e4, e5, e6, e7, t1, t2)\n        rep1 = TexMobject(str(x), color=YELLOW)\n        rep1.shift(-1 * LEFT)\n        rep2 = TexMobject(str(y), color=YELLOW)\n        rep2.shift(2 * LEFT)\n        ev1 = TexMobject(str(y * 2))\n        ev2 = TexMobject(str(3 * x + 1))\n        ev1.shift(1.5 * DOWN + 2 * LEFT)\n        ev2.shift(1.5 * DOWN + 0 * RIGHT)\n        eve = TexMobject('\\\\neq') if y * 2 != 3 * x + 1 else TexMobject('=')\n        eve.shift(1.5 * DOWN + 1 * LEFT)\n        ev = VGroup(ev1, ev2, eve)\n        g2 = VGroup(rep1, group, rep2, ev)\n        g2.scale(1.5)\n        b1 = Brace(VGroup(e4, e5, e6, e7))\n        a1 = Arrow(b1.get_tip(), 1.5 * DOWN, color=GREEN)\n        b2 = Brace(VGroup(e1, e2))\n        a2 = Arrow(b2.get_tip(), 1.5 * DOWN + 3 * LEFT, color=GREEN)\n        a = VGroup(a1, b1, a2, b2)\n        state = TexMobject('\\\\text{(' + str(x) + ',' + str(y) + ') does not satisfy the equation }2y = 3x + 11', tex_to_color_map={'2y = 3x + 1': YELLOW, '(' + str(x) + ',' + str(y) + ')': GREEN}) if y * 2 != 3 * x + 1 else TexMobject('\\\\text{(' + str(x) + ',' + str(y) + ') satisfies the equation }2y = 3x + 11', tex_to_color_map={'2y = 3x + 1': YELLOW, '(' + str(x) + ',' + str(y) + ')': GREEN})\n        state.shift(3.25 * DOWN)\n        self.play(Write(r))\n        self.wait()\n        self.play(Write(group))\n        self.wait()\n        self.play(Transform(e5, rep1), Transform(e2, rep2))\n        self.wait()\n        self.play(Write(a))\n        self.wait()\n        self.play(Write(ev))\n        self.wait()\n        self.play(Write(state))\n        self.wait()\n        return VGroup(r, group, a, ev, state)"}]}
{"messages": [{"role": "user", "content": "Visualize the linear equation 2y = x + 1 by plotting it on axes and marking several points with their corresponding y-values."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LinearEq(Scene):\n\n    def construct(self):\n        eqq = TexMobject('2y = x + 1').scale(1.5)\n        eqq.shift(2 * RIGHT + 3 * UP)\n        rr = BackgroundRectangle(eqq, fill_opacity=1)\n        equation = VGroup(rr, eqq)\n        axes = Axes(x_min=-3, x_max=3, y_min=-3, y_max=3, number_line_config={'include_tip': False})\n        f = FunctionGraph(lambda x: 0.5 * x + 0.5, x_min=-3, x_max=3, color=BLUE)\n        func = VGroup(axes, f)\n        func.shift(2 * RIGHT)\n        l1 = Line(3 * DOWN, 4 * UP)\n        l1.shift(5 * LEFT)\n        l2 = Line(7 * LEFT, 3 * LEFT)\n        l2.shift(3 * UP)\n        l3 = Line(3 * DOWN, 4 * UP)\n        l3.shift(3 * LEFT)\n        l4 = Line(3 * DOWN, 4 * UP)\n        l4.shift(7 * LEFT)\n        l5 = Line(7 * LEFT, 3 * LEFT)\n        l5.shift(4 * UP)\n        t1 = TexMobject('x')\n        t1.shift(6 * LEFT + (3 + 0.5) * UP)\n        t2 = TexMobject('y')\n        t2.shift(4 * LEFT + (3 + 0.5) * UP)\n        table = VGroup(l1, l2, t1, t2, l3, l4, l5)\n        for i in range(-3, 3):\n            l = Line(7 * LEFT, 3 * LEFT)\n            l.shift(i * UP)\n            t = TexMobject(str(i))\n            t.shift(6 * LEFT + (i + 0.5) * UP)\n            table.add(l)\n            table.add(t)\n        table.shift(0.5 * DOWN + 1 * RIGHT)\n        self.play(Write(axes), Write(equation))\n        self.wait()\n        self.play(Write(table))\n        self.wait()\n        self.plot(0)\n        self.plot(1)\n        self.plot(-1)\n        self.plot(2)\n        self.plot(-2)\n        self.plot(-3)\n        self.play(Write(f))\n        self.wait()\n\n    def plot(self, x):\n        y = x * 0.5 + 0.5\n        p = Circle(radius=0.1, color=YELLOW, fill_opacity=1).shift(x * RIGHT + y * UP)\n        p.shift(2 * RIGHT)\n        t = TexMobject(str(y))\n        t.shift(3 * LEFT + x * UP)\n        self.play(Write(t))\n        self.play(Write(p))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a red circle above a blue square, then move the circle up."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SquareToCircle(Scene):\n\n    def construct(self):\n        circle = Circle(plot_depth=0).set_fill(RED, opacity=1)\n        square = Square(plot_depth=-1, side_length=1.7).set_fill(BLUE, opacity=1)\n        self.play(FadeIn(VGroup(circle, square)))\n        self.play(ApplyMethod(circle.shift, UP))\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Demonstrate various Manim rate functions by transforming a column of dots into a mirrored column with each dot using a different rate function."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass RateFunctions(Scene):\n\n    def construct(self):\n        title = VGroup(Text('linear', font='Monaco for Powerline').scale(0.5), Text('smooth', font='Monaco for Powerline').scale(0.5), Text('rush_into', font='Monaco for Powerline').scale(0.5), Text('rush_from', font='Monaco for Powerline').scale(0.5), Text('slow_into', font='Monaco for Powerline').scale(0.5), Text('double_smooth', font='Monaco for Powerline').scale(0.5), Text('there_and_back', font='Monaco for Powerline').scale(0.5)).arrange_submobjects(DOWN, aligned_edge=RIGHT, buff=0.55).move_to(LEFT * 7, aligned_edge=LEFT)\n        dots = VGroup(*[Dot(color=BLUE).move_to([-2.5, i, 0]) for i in range(3, -4, -1)])\n        transform_dots = VGroup(*[Dot(color=BLUE).move_to([6, i, 0], aligned_edge=DOWN) for i in range(3, -4, -1)])\n        self.add(title, dots)\n        self.wait(2)\n        self.play(TransformFromCopy(dots[0], transform_dots[0], rate_func=linear))\n        self.play(TransformFromCopy(dots[1], transform_dots[1], rate_func=smooth))\n        self.play(TransformFromCopy(dots[2], transform_dots[2], rate_func=rush_into))\n        self.play(TransformFromCopy(dots[3], transform_dots[3], rate_func=rush_from))\n        self.play(TransformFromCopy(dots[4], transform_dots[4], rate_func=slow_into))\n        self.play(TransformFromCopy(dots[5], transform_dots[5], rate_func=double_smooth))\n        self.play(TransformFromCopy(dots[6], transform_dots[6], rate_func=there_and_back))\n        self.wait(2)\n        self.play(ReplacementTransform(dots[0], transform_dots[0], rate_func=linear), ReplacementTransform(dots[1], transform_dots[1], rate_func=smooth), ReplacementTransform(dots[2], transform_dots[2], rate_func=rush_into), ReplacementTransform(dots[3], transform_dots[3], rate_func=rush_from), ReplacementTransform(dots[4], transform_dots[4], rate_func=slow_into), ReplacementTransform(dots[5], transform_dots[5], rate_func=double_smooth), ReplacementTransform(dots[6], transform_dots[6], rate_func=there_and_back), run_time=3)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate five dots transforming into new positions using distinct rate functions, labeled with corresponding text."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass RateFunctions2(Scene):\n\n    def construct(self):\n        title = VGroup(Text('there_and_back_with_pause', font='Monaco for Powerline').scale(0.3), Text('running_start', font='Monaco for Powerline').scale(0.3), Text('wiggle', font='Monaco for Powerline').scale(0.3), Text('lingering', font='Monaco for Powerline').scale(0.3), Text('exponential_decay', font='Monaco for Powerline').scale(0.3)).arrange_submobjects(DOWN, aligned_edge=RIGHT, buff=0.65).move_to(LEFT * 7, aligned_edge=LEFT)\n        dots = VGroup(*[Dot(color=BLUE).move_to([-2, i, 0]) for i in range(2, -3, -1)])\n        transform_dots = VGroup(*[Dot(color=BLUE).move_to([6, i, 0], aligned_edge=DOWN) for i in range(2, -3, -1)])\n        self.add(title, dots)\n        self.wait(2)\n        self.play(Transform(dots[0], transform_dots[0], rate_func=there_and_back_with_pause), Transform(dots[1], transform_dots[1], rate_func=running_start), Transform(dots[2], transform_dots[2], rate_func=wiggle), Transform(dots[3], transform_dots[3], rate_func=lingering), Transform(dots[4], transform_dots[4], rate_func=exponential_decay), run_time=3)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate a blue dot moving sequentially to three different target locations at a constant rate."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass RateFunctions3(Scene):\n\n    def construct(self):\n        mover = Dot(color=BLUE).move_to(UR)\n        targets = [Dot(color=BLUE).move_to(DR), Dot(color=BLUE).move_to(DL), Dot(color=BLUE).move_to(UL)]\n        self.wait()\n        self.add(mover)\n        self.wait(2)\n        self.play(Succession(*[Transform(mover, target, rate_func=linear) for target in targets], run_time=5))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate a blue dot rotating around the origin, first with a standard rotation and then with a linear rate function, while changing a title from \"Rotate\" to \"Rotating\" and finally to \"Rotate (rate_func=linear)\"."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass RotateAndRotating(Scene):\n\n    def construct(self):\n        title = TextMobject('Rotate').scale(2).to_corner(UL)\n        dot = Dot(color=BLUE).scale(2).move_to(RIGHT * 2.5)\n        self.wait()\n        self.play(Write(title), ShowCreation(dot))\n        self.wait(2)\n        self.play(Rotate(dot, 2 * PI, about_point=ORIGIN), run_time=2)\n        self.wait(2)\n        title2 = TextMobject('Rotating').scale(2).to_corner(UL)\n        self.play(Transform(title, title2))\n        self.wait(2)\n        self.play(Rotating(dot, about_point=ORIGIN), run_time=2)\n        self.wait(2)\n        title3 = TextMobject('Rotate', '(rate\\\\_func=linear)').scale(2).to_corner(UL)\n        title3[1].scale(0.4).next_to(title3[0], RIGHT, aligned_edge=DOWN)\n        self.play(Transform(title, title3))\n        self.wait(2)\n        self.play(Rotate(dot, 2 * PI, about_point=ORIGIN, rate_func=linear), run_time=2)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Show a square with an animated boundary, then replace it with a rotating point tracing a path while displaying its angle and distance from the origin."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass Changing(Scene):\n\n    def construct(self):\n        sq = Square()\n        test = AnimatedBoundary(sq)\n        self.add(sq, test)\n        self.wait(10)\n        self.remove(sq, test)\n        self.wait(2)\n        point = Dot(color=BLUE)\n        point.move_to(RIGHT * 3)\n        point.add_updater(lambda m, dt: m.rotate(dt * 20 * DEGREES, about_point=ORIGIN))\n        test2 = TracedPath(point.get_center, stroke_width=4, stroke_color=RED)\n        angle = Angle(RIGHT * 3, ORIGIN, point.get_center())\n        angle.add_updater(lambda m: m.become(Angle(RIGHT * 3, ORIGIN, point.get_center())))\n        line1 = Line(ORIGIN, RIGHT * 3)\n        line2 = Line(ORIGIN, point.get_center())\n        line2.add_updater(lambda m: m.put_start_and_end_on(ORIGIN, point.get_center()))\n        degree = DecimalNumber(0, edge_to_fix=RIGHT).scale(2).to_corner(UR)\n        degree.add_updater(lambda m: m.set_value(line2.get_angle() * 180 / PI))\n        self.add(test2, angle, degree, line1, line2)\n        self.add(point)\n        self.wait(9.19)"}]}
{"messages": [{"role": "user", "content": "Render a 2D number plane with a red line and an orange ellipse, and mark points on the ellipse that are closest to the line."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass ParaFunction(Scene):\n\n    def construct(self):\n        grid = NumberPlane()\n        grid.add_coordinates()\n        func1 = ParametricFunction(lambda t: [t - 1, t, 0], t_min=-7, t_max=7, color=RED)\n        func2 = ParametricFunction(lambda t: [4 * np.cos(t), 2 * np.sin(t), 0], t_min=0, t_max=2 * PI, color=ORANGE)\n        points2 = func2.points\n        points3 = []\n        for point in points2:\n            d = abs(point[0] - point[1] + 1) / np.sqrt(2)\n            if d < 0.005:\n                points3.append(point)\n        for point in points3:\n            self.add(Dot(point))\n        self.add(grid, func1, func2)"}]}
{"messages": [{"role": "user", "content": "Animate a group of Chinese and English text elements to continuously shift upwards."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass AlwaysMove(Scene):\n\n    def construct(self):\n        text = VGroup(Text('cigar666', font='Source Han Sans CN').scale(0.5), Text('pdcxs', font='Source Han Sans CN').scale(0.5), Text('\u9e64\u7fd4\u4e07\u91cc', font='Source Han Sans CN').scale(0.5), Text('\u6709\u4e00\u79cd\u60b2\u4f24\u53eb\u9893\u5e9f', font='Source Han Sans CN').scale(0.5)).arrange(DOWN, aligned_edge=LEFT)\n        self.add(text)\n        always_shift(text, UP, 0.5)\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Render a 3D cube from a specific camera angle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TryThreeD(ThreeDScene):\n\n    def construct(self):\n        self.set_camera_orientation(phi=30 * DEGREES, theta=PI / 3)\n        cube = Cube()\n        self.add(cube)"}]}
{"messages": [{"role": "user", "content": "Animate a sequence of 3D geometric surfaces, starting with a sphere transforming into an ellipsoid, then a cone, a hyperbolic paraboloid, a paraboloid, and finally a cylinder, before fading out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass SurfacesAnimation(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes()\n        cylinder = ParametricSurface(lambda u, v: np.array([np.cos(TAU * v), np.sin(TAU * v), 2 * (1 - u)]), resolution=(6, 32)).fade(0.5)\n        paraboloid = ParametricSurface(lambda u, v: np.array([np.cos(v) * u, np.sin(v) * u, u ** 2]), v_max=TAU, checkerboard_colors=[PURPLE_D, PURPLE_E], resolution=(10, 32)).scale(2)\n        para_hyp = ParametricSurface(lambda u, v: np.array([u, v, u ** 2 - v ** 2]), v_min=-2, v_max=2, u_min=-2, u_max=2, checkerboard_colors=[BLUE_D, BLUE_E], resolution=(15, 32)).scale(1)\n        cone = ParametricSurface(lambda u, v: np.array([u * np.cos(v), u * np.sin(v), u]), v_min=0, v_max=TAU, u_min=-2, u_max=2, checkerboard_colors=[GREEN_D, GREEN_E], resolution=(15, 32)).scale(1)\n        hip_one_side = ParametricSurface(lambda u, v: np.array([np.cosh(u) * np.cos(v), np.cosh(u) * np.sin(v), np.sinh(u)]), v_min=0, v_max=TAU, u_min=-2, u_max=2, checkerboard_colors=[YELLOW_D, YELLOW_E], resolution=(15, 32))\n        ellipsoid = ParametricSurface(lambda u, v: np.array([1 * np.cos(u) * np.cos(v), 2 * np.cos(u) * np.sin(v), 0.5 * np.sin(u)]), v_min=0, v_max=TAU, u_min=-PI / 2, u_max=PI / 2, checkerboard_colors=[TEAL_D, TEAL_E], resolution=(15, 32)).scale(2)\n        sphere = ParametricSurface(lambda u, v: np.array([1.5 * np.cos(u) * np.cos(v), 1.5 * np.cos(u) * np.sin(v), 1.5 * np.sin(u)]), v_min=0, v_max=TAU, u_min=-PI / 2, u_max=PI / 2, checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)).scale(2)\n        self.set_camera_orientation(phi=75 * DEGREES)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.add(axes)\n        self.play(Write(sphere))\n        self.wait()\n        self.play(ReplacementTransform(sphere, ellipsoid))\n        self.wait()\n        self.play(ReplacementTransform(ellipsoid, cone))\n        self.wait()\n        self.play(ReplacementTransform(cone, hip_one_side))\n        self.wait()\n        self.play(ReplacementTransform(hip_one_side, para_hyp))\n        self.wait()\n        self.play(ReplacementTransform(para_hyp, paraboloid))\n        self.wait()\n        self.play(ReplacementTransform(paraboloid, cylinder))\n        self.wait()\n        self.play(FadeOut(cylinder))"}]}
{"messages": [{"role": "user", "content": "Animate a 3D scene with axes and a circle, rotating the camera around the scene."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass MoveCamera(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes()\n        circle = Circle()\n        self.set_camera_orientation(phi=80 * DEGREES)\n        self.play(ShowCreation(circle), ShowCreation(axes))\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait(5)\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=80 * DEGREES, theta=-PI / 2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a Manim scene with a white background."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Scene_(Scene):\n    CONFIG = {'camera_config': {'background_color': WHITE}}"}]}
{"messages": [{"role": "user", "content": "Transform a circle into a square and then fade out the square."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass Polygon(Scene):\n\n    def construct(self):\n        circle = Circle(radius=2.0)\n        square = Square()\n        self.play(ShowCreation(circle))\n        self.play(Transform(circle, square))\n        self.play(FadeOut(square))"}]}
{"messages": [{"role": "user", "content": "Transform text from one string to another with different colors."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TextTransform(Scene):\n\n    def construct(self):\n        text = TextMobject('this is a text', tex_to_color_map={'text': YELLOW})\n        trans_text = TextMobject('this is another text', tex_to_color_map={'text': RED})\n        self.play(Write(text))\n        self.play(Transform(text, trans_text))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a TexMobject of a summation formula transforming into another summation formula."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TexTransform(Scene):\n\n    def construct(self):\n        tex = TexMobject('\\\\sum_{n=1010a}^\\\\infty \\\\frac{1}{n^2} = \\\\frac{\\\\tau^2}{6}')\n        trans_tex = TexMobject('\\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^2} = \\\\frac{\\\\pi^2}{6}')\n        self.play(Write(tex))\n        self.play(Transform(tex, trans_tex))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Transform a text object three times, changing its content and color with each transformation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass MoveText(Scene):\n\n    def construct(self):\n        title = TextMobject('Tony is trying manim', tex_to_color_map={'manim': RED})\n        trans_title = TextMobject('Tony is learning manim', tex_to_color_map={'manim': YELLOW})\n        trans_title.to_corner(UP)\n        transform_title = TextMobject('Tony is learning manim', tex_to_color_map={'manim': ORANGE})\n        transform_title.to_corner(UP + LEFT)\n        self.play(Write(title))\n        self.play(Transform(title, trans_title))\n        self.wait()\n        self.play(Transform(title, transform_title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Write the text \"Gauss's Law\" in English and Chinese, followed by the mathematical formula for Gauss's Law."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass GaussLaw(Scene):\n\n    def construct(self):\n        example_text = TextMobject(\"Gauss's Law \u9ad8\u65af\u5b9a\u7406\", tex_to_color_map={'Law': RED})\n        example_tex = TexMobject('\\\\def\\\\ooint{{\\\\bigcirc}\\\\kern-12.5pt{\\\\int}\\\\kern-6.5pt{\\\\int}}\\\\ooint_S{E\\\\cdot dS} = {1\\\\over{\\\\epsilon_0}}\\\\times{{\\\\int}\\\\kern-6.5pt{\\\\int}\\\\kern-6.5pt{\\\\int}_V{\\\\rho \\\\cdot dV}}')\n        group = VGroup(example_text, example_tex)\n        group.arrange_submobjects(DOWN)\n        group.set_width(FRAME_WIDTH - 2 * LARGE_BUFF)\n        self.play(Write(example_text))\n        self.play(Write(example_tex))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the text \"@Tony\u9e64\u7fd4\u4e07\u91cc\" in a gradient of colors at the bottom left corner of the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass PrintAuthor(Scene):\n\n    def construct(self):\n        author = TextMobject('@Tony\u9e64\u7fd4\u4e07\u91cc', tex_to_color_map={'@Tony\u9e64\u7fd4\u4e07\u91cc': [BLUE, YELLOW, ORANGE, RED]})\n        author.scale(1.5)\n        author.to_corner(LEFT + DOWN)\n        self.add(author)"}]}
{"messages": [{"role": "user", "content": "Show a number plane with sequential transformations: scaling, translation, linear, and non-linear."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass NumberPlaneTest(Scene):\n\n    def construct(self):\n        grid = NumberPlane()\n        grid_title = TextMobject('\u7a7a\u95f4\u5750\u6807\u7cfb')\n        grid_title.scale(1.5)\n        grid_title.to_corner(UP)\n        self.play(Write(grid), FadeInFromDown(grid_title))\n        self.wait()\n        grid_transform_title = TextMobject('\u653e\u5927')\n        grid_transform_title.to_corner(UP)\n        grid_transform_title.scale(1.5)\n        grid.prepare_for_nonlinear_transform()\n        self.play(Transform(grid_title, grid_transform_title), grid.apply_function, lambda p: p * np.array([2, 2, 0]), run_time=3)\n        self.wait()\n        grid.prepare_for_nonlinear_transform()\n        grid_transform_title = TextMobject('\u5e73\u79fb')\n        grid_transform_title.to_corner(UP)\n        grid_transform_title.scale(1.5)\n        self.play(Transform(grid_title, grid_transform_title), grid.apply_function, lambda p: p + np.array([2, 1, 0]), run_time=3)\n        self.wait()\n        grid.prepare_for_nonlinear_transform()\n        grid_transform_title = TextMobject('\u7ebf\u6027\u53d8\u6362')\n        grid_transform_title.to_corner(UP)\n        grid_transform_title.scale(1.5)\n        self.play(Transform(grid_title, grid_transform_title), grid.apply_function, lambda p: p + np.array([p[1], 0, 0]), run_time=3)\n        self.wait()\n        grid.prepare_for_nonlinear_transform()\n        grid_transform_title = TextMobject('\u975e\u7ebf\u6027\u53d8\u6362')\n        grid_transform_title.to_corner(UP)\n        grid_transform_title.scale(1.5)\n        self.play(Transform(grid_title, grid_transform_title), grid.apply_function, lambda p: p + np.array([np.sin(p[1]), np.sin(p[0]), 0]), run_time=3)"}]}
{"messages": [{"role": "user", "content": "Animate an SVG file appearing with text, followed by a title appearing, and then fading out the author text and title."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass VideoStart(Scene):\n    CONFIG = {'Author': '@\u9e64\u7fd4\u4e07\u91cc', 'title_name': '\u6d4b\u8bd5', 'svg_filename': 'TonySVG', 'author_colors': [BLUE, YELLOW, ORANGE, RED]}\n\n    def construct(self):\n        author = TextMobject(self.Author, tex_to_color_map={self.Author: self.author_colors})\n        svg_file = SVGMobject(file_name=self.svg_filename)\n        svg_file.to_corner(UP)\n        title = TextMobject(self.title_name)\n        title.to_corner(BOTTOM + ORIGIN)\n        self.play(FadeInFromDown(svg_file), Write(author))\n        self.play(Write(title))\n        self.wait()\n        self.play(LaggedStart(FadeOutAndShiftDown, author), FadeOut(title), run_time=0.5)"}]}
{"messages": [{"role": "user", "content": "Show two text snippets, highlight the word \"text\" in each with a rectangle, draw an arrow between them, and then transform the highlighted words into a blue \"TEXT\"."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TrySurroundingRectangle(Scene):\n\n    def construct(self):\n        text = TextMobject('Here is a ', 'text')\n        text.to_edge(TOP)\n        text_rect = SurroundingRectangle(text[1])\n        another_text = TextMobject('That ', 'text', ' is created by Tony')\n        another_text_rect = SurroundingRectangle(another_text[1])\n        text_arrow = Arrow(another_text[1].get_top(), text[1].get_bottom(), tip_length=0.1)\n        trans_text_1 = TextMobject('TEXT', tex_to_color_map={'TEXT': BLUE})\n        trans_text_2 = TextMobject('TEXT', tex_to_color_map={'TEXT': BLUE})\n        trans_text_1.move_to(text[1])\n        trans_text_2.move_to(another_text[1])\n        self.play(Write(text))\n        self.play(ShowCreation(text_rect))\n        self.wait()\n        self.play(Write(another_text), run_time=1)\n        self.play(ShowCreation(another_text_rect))\n        self.play(ShowCreation(text_arrow), run_time=1.5)\n        self.wait()\n        self.play(Transform(text[1], trans_text_1), Transform(another_text[1], trans_text_2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a matrix and then highlight one of its elements with a transformed '1'."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TryMatrix(Scene):\n\n    def construct(self):\n        matrix = Matrix([['0', 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 0, 1, 0]])\n        self.play(Write(matrix), run_time=3)\n        trans = TextMobject('1').move_to(matrix[0][9])\n        self.play(Transform(matrix[0][9], trans))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate Gauss's Law by writing the equation, transforming the 'Sh' integral region to 'V', and then highlighting the 'V' with a blue rectangle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TransformPartOfTex(Scene):\n\n    def construct(self):\n        gauss = TexMobject('\\\\def\\\\ooint{{\\\\bigcirc}\\\\kern-12.5pt{\\\\int}\\\\kern-6.5pt{\\\\int}}\\\\ooint_S{E\\\\cdot dS} = {1\\\\over{\\\\epsilon_0}}\\\\times{{\\\\int}\\\\kern-6.5pt{\\\\int}\\\\kern-6.5pt{\\\\int}', '_{Sh}', '{\\\\rho \\\\cdot dV}}')\n        self.play(Write(gauss))\n        trans_tex = TexMobject('_{V}')\n        trans_tex.move_to(gauss[1])\n        self.play(Transform(gauss[1], trans_tex))\n        self.wait()\n        text = TextMobject('V', tex_to_color_map={'V': BLUE})\n        text.next_to(gauss[1], direction=UP, buff=2)\n        self.play(Transform(trans_tex, text))\n        text_rect = SurroundingRectangle(text)\n        self.play(ShowCreation(text_rect))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a series of video thumbnails that fade in and then highlight the first thumbnail with a yellow glow."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TryVideoSeries(Scene):\n\n    def construct(self):\n        series = VideoSeries(num_videos=6)\n        series.scale(0.8)\n        series.arrange_submobjects(RIGHT, aligned_edge=LEFT, buff=1.6)\n        series.to_edge(UP, buff=1)\n        this_video = series[0]\n        this_video.set_color(YELLOW)\n        this_video.save_state()\n        this_video.set_fill(opacity=0)\n        this_video.center()\n        this_video.set_height(FRAME_HEIGHT)\n        self.play(FadeIn(series, lag_ratio=0.5, run_time=2))\n        self.wait()\n        self.play(this_video.restore, run_time=3)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display a blue SVG image of the Omega Creatures logo with a width of 3 units."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TryOmega(Scene):\n\n    def construct(self):\n        omega = SVGMobject('OmegaCreatures_plain')\n        omega.set_width(3).set_color(BLUE)\n        self.add(omega)"}]}
{"messages": [{"role": "user", "content": "Display the text \"line1\\nline3\" using the Consolas font."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TryFont(Scene):\n\n    def construct(self):\n        text = Text('line1\\nline3', font='Consolas')\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Display a simple C++ code snippet with syntax highlighting."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TryCode(Scene):\n\n    def construct(self):\n        code = Code('#include <bits/stdc++.h>', 'using namespace std; ')\n        self.play(Write(code))"}]}
{"messages": [{"role": "user", "content": "Display a complex plane with coordinate labels."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TryNumberPlane(Scene):\n\n    def construct(self):\n        grid = ComplexPlane().add_coordinates()\n        self.add(grid)"}]}
{"messages": [{"role": "user", "content": "Display binary text and highlight it with a debug box."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\n\nclass TryText(Scene):\n\n    def construct(self):\n        text = Text('0100101101', font='Consolas').scale(0.8)\n        self.add(text)\n        debugTeX(self, text)"}]}
{"messages": [{"role": "user", "content": "Animate a circle being drawn, followed by a sequence of polygons transforming into each other, starting with a triangle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test0(Scene):\n\n    def construct(self):\n        circle = Circle(radius=3)\n        poly = []\n        for i in range(3, 11):\n            po = Polygon(*[UP * np.sin(j * 2 * PI / i) + RIGHT * np.cos(j * 2 * PI / i) for j in range(i)])\n            poly.append(po.scale(3, about_point=ORIGIN))\n        self.play(ShowCreation(circle))\n        self.play(ShowCreation(poly[0]))\n        self.wait()\n        for i in range(1, 8):\n            self.play(Transform(poly[0], poly[i]))\n            self.wait()\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display a 3x3 matrix and highlight its first row."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test1(Scene):\n    \"\"\"Matrix\u7c7b\u4e2d\u95f4\u5143\u7d20\u7684\u4e0b\u6807\u5e03\u5c40\"\"\"\n\n    def construct(self):\n        mat = Matrix([['0', '-1', '2'], ['1', '0', '12'], ['3', '2', 'x']])\n        self.add(mat)\n        debugTeX(self, mat[0])"}]}
{"messages": [{"role": "user", "content": "Display four lines of code, each defining a numpy array with a typewriter font and specific color highlighting for the equals sign and the word \"array\"."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test2(Scene):\n    \"\"\"\u4f7f\u7528\tt\u8c03TextMobject\u6253\u5b57\u673a\u5b57\u4f53\"\"\"\n\n    def construct(self):\n        text = VGroup(TextMobject('\\\\tt UR=np.array([ 1, 1, 0])', tex_to_color_map={'=': RED, 'array': BLUE}), TextMobject('\\\\tt UL=np.array([-1, 1, 0])', tex_to_color_map={'=': RED, 'array': BLUE}), TextMobject('\\\\tt DR=np.array([ 1,-1, 0])', tex_to_color_map={'=': RED, 'array': BLUE}), TextMobject('\\\\tt DL=np.array([-1,-1, 0])', tex_to_color_map={'=': RED, 'array': BLUE})).arrange_submobjects(DOWN)\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Draw a diagonal line from the origin to the point (3,3,0)."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test3(Scene):\n    \"\"\"\u5750\u6807\u53ef\u4ee5\u7528ndarray\uff0c\u4e5f\u53ef\u4ee5\u7528\u5217\u8868\"\"\"\n\n    def construct(self):\n        l = Line([0, 0, 0], [3, 3, 0])\n        self.add(l)"}]}
{"messages": [{"role": "user", "content": "Show four squares positioned in two columns, with the bottom right square of the second column aligned to the left edge of the bottom left square of the same column."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test4(Scene):\n    \"\"\"aligned_edge\u7684\u7528\u6cd5\"\"\"\n\n    def construct(self):\n        sq1 = Square().shift(LEFT * 2)\n        sq2 = Square().next_to(sq1.get_corner(DR), DOWN)\n        sq3 = Square().shift(RIGHT * 2)\n        sq4 = Square().next_to(sq3.get_corner(DR), DOWN, aligned_edge=LEFT)\n        self.add(sq1, sq2, sq3, sq4)"}]}
{"messages": [{"role": "user", "content": "Create text displaying \"LOVE + ROBOTS\" with the \"+\" symbol in red and properly aligned."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test5(Scene):\n    \"\"\"\u52a0\u53f7\u5f3a\u5236next_to\u5bf9\u9f50\"\"\"\n\n    def construct(self):\n        text = TextMobject('LOVE\\\\ DEATH\\\\ ', '$+$', '\\\\ ROBOTS', color=RED)\n        text[1].next_to(text[0], RIGHT)\n        text[2].next_to(text[1], RIGHT)\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Animate a dot with a FocusOn effect followed by a Flash effect, with accompanying titles for each effect."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test6(Scene):\n    \"\"\"FocusOn\u548cFlash\u7684\u52a8\u753b\u6548\u679c\"\"\"\n\n    def construct(self):\n        title1 = TextMobject('FocusOn').scale(2).to_corner(UL)\n        self.add(title1)\n        dot = Dot(radius=0.5, color=BLUE)\n        self.play(ShowCreation(dot))\n        self.wait()\n        self.play(FocusOn(dot))\n        self.wait(2)\n        title2 = TextMobject('Flash').scale(2).to_corner(UL)\n        self.play(Transform(title1, title2))\n        self.wait()\n        self.play(Flash(dot, flash_radius=0.55))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Create a large black zero on a white background."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test7(Scene):\n    \"\"\"\u767d\u5e95\u9ed1\u5b57\"\"\"\n\n    def construct(self):\n        txt = TexMobject('0', fill_color=BLACK, fill_opacity=1.0, stroke_color=BLACK, stroke_opacity=1.0).scale(3)\n        self.add(txt)"}]}
{"messages": [{"role": "user", "content": "Show a brace under a rectangle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test8(Scene):\n    \"\"\"\u4f7f\u7528Rectangle\u6216\u8005Line\u6765\u5f3a\u5236Brace\u5bbd\u5ea6\"\"\"\n\n    def construct(self):\n        rec = Rectangle(width=4)\n        brac = Brace(rec, DOWN)\n        self.add(brac)"}]}
{"messages": [{"role": "user", "content": "Animate a cube rotating in 3D space."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test9(ThreeDScene):\n    \"\"\"\u7acb\u65b9\u4f53\u4e09\u7ef4\u65cb\u8f6c\"\"\"\n\n    def construct(self):\n        self.set_to_default_angled_camera_orientation()\n        cube = Cube()\n        self.add(cube)\n        self.wait()\n        self.play(Rotating(cube, axis=UP, radians=PI / 6))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Create a text object with a gradient color from blue to red."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test10(Scene):\n    \"\"\"\u6587\u5b57\u6e10\u53d8\u8272\"\"\"\n\n    def construct(self):\n        text = TextMobject('test').scale(2).set_color_by_gradient(BLUE, RED)\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Display a LaTeX equation with three cases."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test11(Scene):\n    \"\"\"LaTeX\u7684cases\u53ef\u884c\"\"\"\n\n    def construct(self):\n        text = TexMobject('\\n            \\\\begin{cases}\\n            u^3+v^3=-q\\\\\\\\\\n            uv=-\\\\frac{p}{3}\\\\\\\\\\n            \\\\end{cases}\\n            ')\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Animate a rotating vector and a text-containing circle following the vector's rotation, while a larger stationary circle and title remain visible."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test12(Scene):\n\n    def construct(self):\n        circle0 = Circle(color=WHITE, radius=2)\n        text0 = TextMobject('Gaussian \\\\\\\\ Elimination')\n        vec1 = Vector(1.4 * LEFT).move_to(circle0.get_center() + 2.8 * LEFT)\n        circle1 = Circle(color=RED, radius=1.6).next_to(vec1, LEFT)\n        text1 = TextMobject('System of \\\\\\\\   linear equation').move_to(circle1.get_center() + ORIGIN).scale(0.8)\n        vgr1 = VGroup(text1, circle1)\n        self.add(circle0, text0)\n        self.add(vec1)\n        self.add(vgr1)\n        self.wait(2)\n        pos = Dot(fill_opacity=0).move_to(circle1.get_center())\n\n        def update_text(obj):\n            obj.move_to(pos)\n        vgr1.add_updater(update_text)\n        self.add(vgr1)\n        self.play(Rotating(vec1, radians=6 * PI, about_point=ORIGIN, axis=IN), Rotating(pos, radians=6 * PI, about_point=ORIGIN, axis=IN), run_time=20)"}]}
{"messages": [{"role": "user", "content": "Show a square uncreating itself."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test13(Scene):\n    \"\"\"Uncreate\u6548\u679c\uff0c\u6ce8\u610f\u4e0d\u662fUnCreate\"\"\"\n\n    def construct(self):\n        sq = Square()\n        self.add(sq)\n        self.wait()\n        self.play(Uncreate(sq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a scene with four rectangles, shift them upwards, and transform one of them into a circle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test14(Scene):\n\n    def construct(self):\n        rec1 = Rectangle(height=2, width=6)\n        rec2 = Rectangle(height=1, width=1).shift(LEFT * 2)\n        rec3 = Rectangle(height=1, width=1).shift(RIGHT * 2)\n        rec4 = Rectangle(height=1, width=1)\n        recs = VGroup(rec1, rec2, rec3, rec4)\n        self.add(recs)\n        self.wait()\n        self.play(recs.shift, UP * 2.5)\n        self.wait()\n        circle = Circle(radius=0.5).move_to(rec3)\n        self.play(Transform(rec3, circle))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate three squares arranged horizontally to simultaneously shift upwards."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test16(Scene):\n\n    def construct(self):\n        objs = [Square().shift(LEFT * 3), Square(), Square().shift(RIGHT * 3)]\n        self.add(*objs)\n        self.wait()\n        self.play(*[ApplyMethod(obj.shift, UP) for obj in objs])\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Arrange two groups of shapes, circles and squares, in specific positions relative to each other."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test17(Scene):\n    \"\"\"\u4f7f\u7528index_of_submobject_to_align\u6765\u5bf9\u9f50\uff0c\u6ce8\u610f\u8981get_center()\"\"\"\n\n    def construct(self):\n        vg1 = VGroup(Circle(radius=0.5).shift(LEFT * 2), Circle(radius=0.5).shift(LEFT * 1), Circle(radius=0.5), Circle(radius=0.5).shift(RIGHT * 1), Circle(radius=0.5).shift(RIGHT * 2))\n        vg2 = VGroup(Square(side_length=1).shift(LEFT * 1), Square(side_length=1), Square(side_length=1).shift(RIGHT * 1))\n        vg2.next_to(vg1[3].get_center(), DOWN, index_of_submobject_to_align=1)\n        self.add(vg1, vg2)"}]}
{"messages": [{"role": "user", "content": "Decompose the first character of a LaTeX string into individual components."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test18(Scene):\n    \"\"\"\u4f7f\u7528tex[0]\u6765\u5bf9TexMobject\u7684\u6bcf\u4e2a\u5b57\u7b26\u8fdb\u884c\u5206\u89e3\"\"\"\n\n    def construct(self):\n        tex = TexMobject('a^2+b^2=c^2')\n        self.add(tex)\n        debugTeX(self, tex[0])"}]}
{"messages": [{"role": "user", "content": "Animate a line with a blue animated boundary."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test19(Scene):\n    \"\"\"\u7528AnimatedBoundary\u5b9e\u73b0Line\u7684\u989c\u8272\u53d8\u5316\"\"\"\n\n    def construct(self):\n        l = Line(LEFT * 3, RIGHT * 3)\n        self.add(l)\n        self.wait()\n        l2 = AnimatedBoundary(l, colors=[BLUE])\n        self.add(l2)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Animate text to flicker by repeatedly setting its opacity to zero and then back to one."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test20(Scene):\n    \"\"\"\u4f7f\u7528set_opacity\u5b9e\u73b0\u95ea\u70c1\u6548\u679c\"\"\"\n\n    def construct(self):\n        text = TextMobject('\u9893\u5e9f\u6700\u4e0d\u8981\u8138')\n        self.add(text)\n        for i in range(20):\n            self.play(text.set_opacity, 0, run_time=0.2)\n            self.play(text.set_opacity, 1, run_time=0.2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a blue quarter-circle and its flipped yellow counterpart on a number plane."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test21(Scene):\n    \"\"\"\u5706\u5f27flip\u7684\u9ed8\u8ba4\u8f74\"\"\"\n\n    def construct(self):\n        grid = NumberPlane()\n        arc = Arc(0, PI / 2, color=BLUE)\n        arc2 = arc.copy().flip().set_color(YELLOW)\n        self.add(grid, arc, arc2)"}]}
{"messages": [{"role": "user", "content": "Display the text \"abcd\" on the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test22(Scene):\n\n    def construct(self):\n        text = TextMobject('abcd')\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Animate the creation of a square and an arc simultaneously with different run times."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test23(Scene):\n    \"\"\"move_arc_center_to\u548c\u4e0d\u540crun_time\u7684\u52a8\u753b\u540c\u65f6\u64ad\u653e\"\"\"\n\n    def construct(self):\n        sq = Square(side_length=4)\n        ci = Arc(0, PI / 2, color=BLUE, radius=4).move_arc_center_to(sq.get_corner(DL))\n        self.wait()\n        self.play(ShowCreation(sq, run_time=2), ShowCreation(ci, run_time=4))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display \"abcdefgh\" and surround each character with a rectangle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test24(Scene):\n    \"\"\"\u73af\u7ed5\u6bcf\u4e2a\u5b57\u7b26\"\"\"\n\n    def construct(self):\n        text = TextMobject('abcdefgh')\n        rec = VGroup()\n        for i in text[0]:\n            rec.add(SurroundingRectangle(i, buff=0))\n        self.add(text, rec)"}]}
{"messages": [{"role": "user", "content": "Render a LaTeX table with specified headers and then highlight the entire table structure."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test25(Scene):\n    \"\"\"\u4f7f\u7528LaTeX\u7684\u8868\u683c\"\"\"\n\n    def construct(self):\n        tab = TextMobject('\\n            \\\\begin{table}[]\\n            \\\\begin{tabular}{|l|l|l|l|l|l|}\\n            \\\\hline\\n            a & b & c & d & e & f \\\\\\\\ \\\\hline\\n            \\\\end{tabular}\\n            \\\\end{table}\\n            ')\n        self.add(tab)\n        debugTeX(self, tab[0])"}]}
{"messages": [{"role": "user", "content": "Animate a group of five circles appearing sequentially by fading them in."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test26(Scene):\n    \"\"\"Succession\uff0c\u5176\u5b9e\u548c\u591a\u4e2aplay\u6ca1\u4ec0\u4e48\u533a\u522b\"\"\"\n\n    def construct(self):\n        group = VGroup(Circle(radius=0.5).shift(LEFT * 2), Circle(radius=0.5).shift(LEFT * 1), Circle(radius=0.5), Circle(radius=0.5).shift(RIGHT * 1), Circle(radius=0.5).shift(RIGHT * 2)).set_opacity(0)\n        self.wait()\n        self.play(Succession(*[ApplyMethod(obj.set_opacity, 1) for obj in group]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate the difference between `to_corner(UP)` and `to_corner(TOP)` using text labels."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test27(Scene):\n    \"\"\"UP\u548cTOP\u5728to_corner\u65f6\u7684\u533a\u522b\"\"\"\n\n    def construct(self):\n        text = TextMobject('to\\\\_corner UP').to_corner(UP)\n        text2 = TextMobject('to\\\\_corner TOP').to_corner(TOP)\n        text3 = TextMobject('move\\\\_to TOP').move_to(TOP).set_color(YELLOW)\n        self.add(text, text2, text3)"}]}
{"messages": [{"role": "user", "content": "Fade out all existing Mobjects from the scene after displaying a square."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test28(Scene):\n    \"\"\"\u5c06\u6240\u6709\u7269\u4f53\u90fdFadeOut\uff0c\u6ca1\u6709add\u7684\u7269\u4f53\u4e5f\u4e0d\u4f1a\u5f3a\u5236add\u518dFadeOut\"\"\"\n\n    def construct(self):\n        sq = Square()\n        ci = Circle()\n        self.add(sq)\n        self.wait()\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a long string of text that will not automatically wrap."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test29(Scene):\n    \"\"\"Text\u4e0d\u4f1a\u81ea\u52a8\u6362\u884c\"\"\"\n\n    def construct(self):\n        text = Text('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', font='Consolas')\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Display the text 'AB' with an arc above it."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test30(Scene):\n    \"\"\"\u5b57\u7b26\u4e0a\u5f27\"\"\"\n\n    def construct(self):\n        text = TextMobject('\\\\overarc{AB}')\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Create a gradient of squares moving from left to right with smooth transformations."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test31(Scene):\n\n    def construct(self):\n        Gc = VGroup()\n        colors = color_gradient([BLACK, WHITE], 9)\n        Gc.add(Square(side_length=1).shift(LEFT * 6).set_fill(colors[0], 1).set_color(colors[0]))\n        for i in range(1, 9):\n            Gc.add(Gc[-1].copy().set_fill(colors[i], 1).set_color(colors[i]).shift(RIGHT * 1.2))\n            self.play(Transform(Gc[-2], Gc[-1], rate_func=linear))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a square transitioning through a color gradient from dark yellow to bright yellow by moving it across the screen and changing its color and fill."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test33(Scene):\n    \"\"\"\u7528\u989c\u8272\u7070\u5ea6\u6765\u5b9e\u73b0\u900f\u660e\u5ea6\u7684\u6548\u679c\uff0c\u9632\u6b62\u4e24\u900f\u660e\u5ea6\u989c\u8272\u76f8\u53e0\u52a0\uff0c\u5bfc\u81f4\u4eae\u5ea6\u7a81\u53d8\"\"\"\n\n    def construct(self):\n        colors = color_gradient(['#6C6C00', YELLOW], 9)\n        sq = Square(side_length=1).shift(LEFT * 6).set_fill(colors[0], 1).set_color(colors[0])\n        for i in range(1, 9):\n            self.play(ApplyMethod(sq.shift, RIGHT * 1.2, rate_func=linear), ApplyMethod(sq.set_color, colors[i]), ApplyMethod(sq.set_fill, colors[i], 1))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a white cube with its top face colored blue in a 3D scene."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test34(ThreeDScene):\n    \"\"\"cube\u7684\u9762\"\"\"\n\n    def construct(self):\n        self.set_to_default_angled_camera_orientation()\n        cube = Cube(fill_opacity=0, stroke_width=3).set_fill(opacity=0).set_color(WHITE)\n        cube[5].set_color(BLUE)\n        self.add(cube)\n        debugTeX(self, cube)"}]}
{"messages": [{"role": "user", "content": "Display a 3D paraboloid surface."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test36(ThreeDScene):\n    \"\"\"\u629b\u7269\u9762\"\"\"\n\n    def construct(self):\n        self.set_to_default_angled_camera_orientation()\n        \u9893\u5e9f\u66f2\u9762 = ParametricSurface(lambda u, v: [u, v, u ** 2 + v ** 2], u_min=-1, u_max=1, v_min=-1, v_max=1)\n        self.add(\u9893\u5e9f\u66f2\u9762)"}]}
{"messages": [{"role": "user", "content": "Animate a circle transforming into a flipped square."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test37(Scene):\n    \"\"\"Transfrom\u524d\u7edf\u4e00\u65b9\u5411\uff0c\u4f7f\u52a8\u753b\u66f4\u987a\u6ed1\"\"\"\n\n    def construct(self):\n        ci = Circle()\n        sq = Square().flip()\n        self.play(ShowCreation(ci))\n        self.play(Transform(ci, sq))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Color the \"x^2\" part of a square root expression red."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test38(Scene):\n    \"\"\"\u6839\u5f0f\u4e0a\u8272\"\"\"\n\n    def construct(self):\n        text = TexMobject('\\\\sqrt{x^2+y^2+z^2}')\n        text[0][2:4].set_color(RED)\n        self.add(text)\n        debugTeX(self, text[0])"}]}
{"messages": [{"role": "user", "content": "Color specific parts of a LaTeX expression representing the arc length element."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test39(Scene):\n    \"\"\"\u4e0a\u8272\"\"\"\n\n    def construct(self):\n        text4 = TexMobject('ds=\\\\vert d\\\\vec r \\\\vert=', '\\\\sqrt{x^2+y^2+z^2}')\n        VGroup(text4).set_color(YELLOW)\n        VGroup(text4[1][2:4]).set_color(RED)\n        self.add(text4)\n        debugTeX(self, text4[1])"}]}
{"messages": [{"role": "user", "content": "Move a blue dot towards a yellow dot positioned above it, scaling the blue dot up as it approaches."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test40(Scene):\n    \"\"\"\u4e00\u4e2aself.play\u4e2d\u65e0\u6cd5\u5904\u7406\u4e24\u4e2a\u9488\u5bf9\u540c\u4e00\u7269\u4f53\u7684ApplyMethod\uff0c\u4f46\u4e0d\u52a0ApplyMethod\u53ef\u4ee5\"\"\"\n\n    def construct(self):\n        dot = Dot(color=BLUE)\n        up = Dot(color=YELLOW).to_edge(UP)\n        self.add(dot)\n        self.wait()\n        self.play(dot.next_to, up, DOWN, dot.scale, 3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a square being replaced by a circle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test41(Scene):\n    \"\"\"replace\u7684\u4f5c\u7528\"\"\"\n\n    def construct(self):\n        sq = Square().scale(2)\n        ci = Circle().shift(RIGHT * 3)\n        self.add(sq, ci)\n        self.play(sq.replace, ci)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create two rows of dots, connect them with lines, then shift the top row left and the bottom row right while updating the lines."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test42(Scene):\n    \"\"\"\u4f7f\u7528updater\u65f6\u4e0d\u80fd\u4f7f\u7528\u5faa\u73af\u53d8\u91cfi\"\"\"\n\n    def construct(self):\n        ups = VGroup(*[Dot(color=BLUE).move_to([i, 1, 0]) for i in range(-3, 4)])\n        downs = VGroup(*[Dot(color=YELLOW).move_to([i, -1, 0]) for i in range(-3, 4)])\n        lines = VGroup(*[Line(ups[i], downs[i]) for i in range(0, 7)])\n        lines.add_updater(lambda m: m.become(VGroup(*[Line(ups[i], downs[i]) for i in range(0, 7)])))\n        self.add(ups, downs, lines)\n        self.wait()\n        self.play(ups.shift, LEFT * 2)\n        self.play(downs.shift, RIGHT * 2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Enlarge and recolor a blue dot to yellow."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test43(Scene):\n    \"\"\"\u548cTest40\u540c\u7406\"\"\"\n\n    def construct(self):\n        dot = Dot(color=BLUE)\n        self.add(dot)\n        self.wait()\n        self.play(ApplyMethod(dot.scale, 3), ApplyMethod(dot.set_color, YELLOW))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize an animation of multiple randomly colored spheres with varying radii transforming into concentric spheres of increasing size."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test44(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes()\n        spheres = VGroup(*[Sphere(radius=i, opacity=0.5, resolution=(20, 40)) for i in np.arange(1, 3.1, 0.4)])\n        self.set_to_default_angled_camera_orientation()\n        self.add(axes)\n        old = VGroup()\n        new = VGroup()\n        for i in range(len(spheres[0])):\n            old.add(spheres[randint(1, 5)][i].set_opacity(randint(1, 6) / 10))\n            new.add(spheres[0][i])\n        self.wait()\n        self.wait()\n        self.play(FadeIn(old), *[Transform(i, j) for i, j in zip(old, new)], run_time=6)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render a 3D surface described by a complex parametric equation on a set of 3D axes."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test45(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes()\n        self.set_to_default_angled_camera_orientation()\n        self.add(axes)\n        surface = ParametricSurface(lambda y, z: [-np.sqrt(1 - 9 * y ** 2 / 4 + 320 * 2 ** (1 / 3) * z ** 3 / (99532800 * y ** 2 * z ** 2 + 884736000 * z ** 3 - 1990656000 * y ** 2 * z ** 3 - 884736000 * z ** 5 + np.sqrt((-115964116992000000 * z ** 9 + (99532800 * y ** 2 * z ** 2 + 884736000 * z ** 3 - 1990656000 * y ** 2 * z ** 3 - 884736000 * z ** 5) ** 2) ** 2)) ** (1 / 3) + 1 / 960 * 2 ** (1 / 3) * (99532800 * y ** 2 * z ** 2 + 884736000 * z ** 3 - 1990656000 * y ** 2 * z ** 3 - 884736000 * z ** 5 + np.sqrt(-115964116992000000 * z ** 9 + (99532800 * y ** 2 * z ** 2 + 884736000 * z ** 3 - 1990656000 * y ** 2 * z ** 3 - 884736000 * z ** 5) ** 2)) ** (1 / 3)), y, z])\n        self.add(surface)"}]}
{"messages": [{"role": "user", "content": "Animate text with a brace below it and then write the text."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test46(Scene):\n    \"\"\"Brace\"\"\"\n\n    def construct(self):\n        text = TextMobject('test')\n        brace = Brace(text, DOWN)\n        self.play(Write(brace))\n        self.play(Write(text))"}]}
{"messages": [{"role": "user", "content": "Animate a sequence of dancing stick figures, transforming one into the next."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test47(Scene):\n    \"\"\"LaTeX\u7684dancers\u5c0f\u4eba\uff0c\u9700\u8981\u4e0b\u8f7d\u5b57\u4f53\u5305\u5e76\u4e14\u66f4\u6539ctex_template\"\"\"\n\n    def construct(self):\n        Test = VGroup()\n        for i in range(51):\n            test = TextMobject('\\\\Pisymbol{dancers}{%d}' % i, stroke_width=1, fill_opacity=1, stroke_opacity=1).scale(200)\n            Test.add(test)\n        self.wait()\n        self.play(Write(Test[0]))\n        for i in range(1, 51):\n            self.wait(0.8)\n            self.play(Transform(Test[0], Test[i]))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Show two squares with different plot depths and animate the plot depth of one."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test48(Scene):\n    \"\"\"plot_depth\"\"\"\n    CONFIG = {'camera_config': {'use_plot_depth': True}}\n\n    def construct(self):\n        sq = Square(stroke_width=5).set_plot_depth(1)\n        sq2 = Square(side_length=1, stroke_width=5).shift(RIGHT).set_color(BLUE).set_plot_depth(0)\n        self.add(sq, sq2)\n        self.wait()\n        self.play(sq2.set_plot_depth, 2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display code written in LaTeX's lstlisting environment within a Manim scene."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test49(Scene):\n    \"\"\"\u4f7f\u7528LaTeX\u7684lstlisting\u5199\u4ee3\u7801\uff0c\u9700\u8981\u6539ctex_template\"\"\"\n\n    def construct(self):\n        text = TextMobject('\\n            \\\\begin{lstlisting}\\n            int main() {\\n\\n            }\\n            \\\\end{lstlisting}\\n        ')\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Render a 3D animation of a cone being constructed from stacked triangular slices, with alternating slices briefly flashing yellow."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test50(ThreeDScene):\n    \"\"\"\u6b63\u5288\u9525\u4f53\uff0c\u6e32\u67d3\u8d3c\u6162\"\"\"\n\n    def construct(self):\n        axes = ThreeDAxes()\n        self.set_camera_orientation(phi=70 * DEGREES, theta=45 * DEGREES)\n        self.add(axes)\n        a = VGroup()\n        b = VGroup()\n        c = VGroup()\n        for i in np.arange(-1, 1.00001, 0.0005):\n            tri = Polygon([i, np.sqrt(1 - i ** 2), 0], [i, -np.sqrt(1 - i ** 2), 0], [i, 0, 2], stroke_width=0, fill_color=BLUE, fill_opacity=0.75)\n            a.add(tri)\n        cnt = 1\n        self.begin_ambient_camera_rotation(rate=0.5)\n        for tri in a:\n            if cnt % 2 == 0:\n                self.add(tri.set_fill(color=YELLOW, opacity=0.5))\n                self.wait(0.01)\n                tri.set_fill(color=BLUE, opacity=0.75)\n            else:\n                self.add(tri)\n            cnt += 1\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Animate a series of polygons transforming into a circle by changing the number of sides in a 3D space."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test51(ThreeDScene):\n    \"\"\"\u68f1\u9525\u5230\u8fd1\u4f3c\u5706\u9525\"\"\"\n\n    def construct(self):\n        axes = ThreeDAxes()\n        self.set_camera_orientation(phi=70 * DEGREES, theta=45 * DEGREES)\n        self.add(axes)\n        circle = Circle(radius=2)\n        polys = []\n        faces = []\n        for i in range(3, 16):\n            po = Polygon(*[UP * np.sin(j * 2 * PI / i) + RIGHT * np.cos(j * 2 * PI / i) for j in range(i)], stroke_width=1, stroke_color=BLUE, fill_color=BLUE, fill_opacity=0.75).scale(2, about_point=ORIGIN)\n            polys.append(po)\n            verts = po.get_vertices()\n            faces_ = VGroup()\n            for j in range(i):\n                if j == i - 1:\n                    face = Polygon(verts[j], verts[0], [0, 0, 3])\n                else:\n                    face = Polygon(verts[j], verts[j + 1], [0, 0, 3])\n                face.set_stroke(width=1, color=BLUE)\n                face.set_fill(color=BLUE, opacity=0.75)\n                faces_.add(face)\n            faces.append(faces_)\n        self.play(ShowCreation(circle))\n        self.play(ShowCreation(polys[0]), ShowCreation(faces[0]))\n        self.wait()\n        self.begin_ambient_camera_rotation(rate=0.5)\n        self.wait()\n        for i in range(1, 13):\n            self.play(Transform(polys[0], polys[i]), Transform(faces[0], faces[i]))\n            self.wait()\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Create a 3D animation of a grid of boxes with specified dimensions and spacing."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test53(ThreeDScene):\n    \"\"\"MyBoxes\u7684\u5e8f\u53f7\u5206\u5e03\"\"\"\n\n    def construct(self):\n        axes = ThreeDAxes()\n        self.add(axes)\n        boxes = MyBoxes(fill_color=GRAY, resolution=(9, 18), bottom_size=(0.5, 0.7), gap=0.2, box_height=0.5)\n        self.add(boxes)\n        debugTeX(self, boxes)"}]}
{"messages": [{"role": "user", "content": "Animate a 3D periodic table of elements with rotating camera."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test54(ThreeDScene):\n    \"\"\"\u6d4b\u8bd5\u5143\u7d20\u5468\u671f\u8868\"\"\"\n    CONFIG = {'camera_config': {'background_color': WHITE, 'should_apply_shading': False}}\n\n    def construct(self):\n        self.set_camera_orientation(phi=50 * DEGREES, theta=240 * DEGREES, distance=50)\n        boxes = ChemicalBoxes(fill_color=BLUE_E).add_label().set_block_color()\n        self.add(boxes)\n        self.begin_ambient_camera_rotation(rate=1)"}]}
{"messages": [{"role": "user", "content": "Show a circle with a dot positioned at a specific point on its boundary."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test55(Scene):\n    \"\"\"\u65e0\u6cd5\u50cf\u8fd9\u6837\u83b7\u53d6\u5706\u4e0a\u67d0\u4e00\u65b9\u5411\u7684\u70b9\"\"\"\n\n    def construct(self):\n        ci = Circle()\n        self.add(ci)\n        dot = Dot().move_to(ci.get_boundary_point(UP * 2 * np.sqrt(5) / 5 + RIGHT * np.sqrt(5) / 5))\n        self.add(dot)"}]}
{"messages": [{"role": "user", "content": "Animate a dot moving downwards with a continuous update."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test56(Scene):\n    \"\"\"\u5e26dt\u7684updater\"\"\"\n\n    def construct(self):\n        dot = Dot().to_edge(UP)\n        dot.add_updater(lambda m, dt: m.shift(0.1 * DOWN))\n        self.add(dot)\n        self.wait(6)"}]}
{"messages": [{"role": "user", "content": "Display Chinese text with subscripts and superscripts."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test57(Scene):\n    \"\"\"\u6587\u5b57\u4e0a\u4e0b\u6807\"\"\"\n\n    def construct(self):\n        text = TextMobject('\u6b63\u6587A$_{\\\\text{\u4e0b\u6807B}}^{\\\\text{\u4e0a\u6807C}}$').scale(3)\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Render a smooth parametric function scaled by three."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test58(Scene):\n    \"\"\"rate_func\"\"\"\n\n    def construct(self):\n        func = ParametricFunction(lambda x: [x, smooth(x), 0], t_min=0, t_max=1).scale(3, about_point=ORIGIN)\n        self.add(func)"}]}
{"messages": [{"role": "user", "content": "Create a square and save it as an image."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test59(Scene):\n    \"\"\"save_image\"\"\"\n\n    def construct(self):\n        sq = Square()\n        sq.save_image()\n        self.add(sq)"}]}
{"messages": [{"role": "user", "content": "Align two equations using the equals sign as the reference point."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test60(Scene):\n    \"\"\"\u6839\u636e\u7b49\u53f7\u5bf9\u9f50\"\"\"\n\n    def construct(self):\n        tex1 = TexMobject('A=\\\\frac{\\\\displaystyle\\\\sum^n_{i=0}}{x}')\n        tex2 = TexMobject('=', '\\\\frac{x}{\\\\displaystyle\\\\sum^n_{i=0}}')\n        tex2.next_to(tex1, RIGHT)\n        tex2.next_to(tex1[0][1].get_center(), RIGHT, index_of_submobject_to_align=0, coor_mask=np.array([0, 1, 1]))\n        self.add(tex1, tex2)\n        texs = ['A=\\\\frac{\\\\displaystyle\\\\sum^n_{i=0}}{x}', '=\\\\frac{x}{\\\\displaystyle\\\\sum^n_{i=0}}']\n        tex = TexMobject(*texs)\n        self.add(tex)"}]}
{"messages": [{"role": "user", "content": "Display a series expansion of a function and its simplified form as an infinite series."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test61(Scene):\n\n    def construct(self):\n        for1 = TexMobject('G(x)=\\\\displaystyle\\\\sum_{p=0}^{\\\\infty}{\\\\left( \\\\frac{S^{p}(n)}{p!}x^p\\\\right)}').scale(0.7).to_edge(UP + LEFT)\n        for1_bg = SurroundingRectangle(for1, fill_opacity=0.2)\n        for2 = TexMobject('G(x) = \\\\left( \\\\frac{e^{(n+1)x}-1}{x} \\\\right) \\\\left( \\\\frac{x}{e^x-1} \\\\right)')\n        forrs = ['\\\\frac{e^{(n+1)x}-1}{x}', '= \\\\frac{ \\\\left( \\\\displaystyle\\\\sum_{p=0}^{\\\\infty}{\\\\frac{{((n+1)x)}^p}{p!}} \\\\right) -1}{x}}', '=\\\\frac{1+\\\\left( \\\\displaystyle\\\\sum_{p=1}^{\\\\infty}{\\\\frac{{((n+1)x)}^p}{p!}} \\\\right) -1}{x}}', '=\\\\displaystyle\\\\sum_{p=1}^{\\\\infty}{\\\\frac{(n+1)^p}{p!}x^{p-1}}', '=\\\\displaystyle\\\\sum_{p=0}^{\\\\infty}{\\\\frac{(n+1)^{p+1}}{(p+1)!}x^{p}}']\n        forr = TexMobject(*forrs).scale(0.9)\n        self.add(forr)"}]}
{"messages": [{"role": "user", "content": "Animate a triangle flipping over one of its edges."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test62(Scene):\n    \"\"\"\u4e09\u89d2\u5f62\u7ed5\u8fb9\u7ffb\u8f6c\"\"\"\n\n    def construct(self):\n        tri = Triangle()\n        vert = tri.get_vertices()\n        tri.generate_target()\n        tri.target.flip(axis=vert[0] - vert[1], about_point=(vert[0] + vert[1]) / 2)\n        self.add(tri)\n        self.wait()\n        self.play(MoveToTarget(tri))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the word \"abcde\" with three different gradient colorizations."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test63(Scene):\n    \"\"\"\u6587\u5b57\u6e10\u53d8\u8272\u7684\u533a\u522b\"\"\"\n\n    def construct(self):\n        vg = VGroup(TextMobject('abcde').set_color([RED, BLUE, WHITE]), TextMobject('abcde').set_color_by_gradient(RED, BLUE, WHITE), TextMobject('abcde')).arrange(DOWN)\n        vg[2].shuffle(True)\n        vg[2].set_color_by_gradient(RED, BLUE, WHITE)\n        self.add(vg)"}]}
{"messages": [{"role": "user", "content": "Visualize a cubic Bezier curve defined by four control points and display its interpolated points."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test64(Scene):\n    \"\"\"CubicBezier\u7684points\u53ea\u6709\u56db\u4e2a\u70b9\uff0c\u5373\u951a\u70b9\u548c\u63a7\u5236\u70b9\uff0c\u4f46ParametricFunction\u662f\u597d\u591a\u8d1d\u585e\u5c14\u66f2\u7ebf\uff0c\u597d\u591a\u70b9\"\"\"\n\n    def construct(self):\n        line = ParametricFunction(bezier([np.array([-3, -1.5, 0]), np.array([-3.6, 1.5, 0]), np.array([0, 1.5, 0]), np.array([3, -1.5, 0])]), t_min=0, t_max=1)\n        self.add(line)\n        points = line.get_points()\n        debugTeX(self, points)"}]}
{"messages": [{"role": "user", "content": "Display a square with a vertical gradient from red to blue."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test65(Scene):\n    \"\"\"\u6e10\u53d8\u8272\u7684\u65b9\u5411\uff0c\u7528sheen_direction\u6765\u8bbe\u5b9a\"\"\"\n\n    def construct(self):\n        sq = Square()\n        sq.set_color([RED, BLUE])\n        sq.set_sheen_direction(UP)\n        self.add(sq)"}]}
{"messages": [{"role": "user", "content": "Display a thick line."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test66(Scene):\n    \"\"\"digest_config\u7684\u5f88\u611a\u8822\u7684\u7528\u6cd5\"\"\"\n    CONFIG = {'stroke_width': 15}\n\n    def construct(self):\n        line = Line()\n        digest_config(line, self.CONFIG)\n        self.add(line)"}]}
{"messages": [{"role": "user", "content": "Visualize the underlying points of a scaled arc using debugTeX."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test67(Scene):\n    \"\"\"arc\u7684points\uff0c\u7528\u597d\u591a\u8d1d\u585e\u5c14\u66f2\u7ebf\u6765\u62df\u5408\u7684\"\"\"\n\n    def construct(self):\n        arc = Arc().scale(3)\n        self.add(arc)\n        points = arc.get_points()\n        debugTeX(self, points, 0.3)"}]}
{"messages": [{"role": "user", "content": "Display the Law of Sines formula and highlight it for debugging."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test68(Scene):\n\n    def construct(self):\n        tex = TexMobject('{\\\\sin\\\\alpha\\\\over\\\\sin\\\\gamma}={n_1\\\\over n_2}')\n        self.add(tex)\n        debugTeX(self, tex[0])"}]}
{"messages": [{"role": "user", "content": "Transform a cube into a 2D 'a' by applying a matrix derived from a vector and rotating it."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test69(ThreeDScene):\n    \"\"\"\u65e0\u6cd5\u5c06\u4e09\u7ef4\u7269\u4f53Transform\u5230fixed_in_frame_mobjects\u7684\u4e8c\u7ef4\u7269\u4f53\uff0c\u4f46\u53ef\u4ee5\u901a\u8fc7z_to_vector\u7b49\u53d8\u6362\u5f97\u5230\u7c7b\u4f3c\u7684\u6548\u679c\"\"\"\n\n    def construct(self):\n        self.set_camera_orientation(phi=60 * DEGREES, theta=45 * DEGREES)\n        vec = [np.cos(45 * DEGREES) * np.sin(60 * DEGREES), np.sin(45 * DEGREES) * np.sin(60 * DEGREES), np.cos(60 * DEGREES)]\n        n = z_to_vector(vec)\n        tex = TexMobject('a').apply_matrix(n).rotate(PI / 2, vec)\n        surface = Cube()\n        self.add(surface)\n        self.play(Transform(surface, tex), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the letter 'S' and print its geometric points."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test70(Scene):\n    \"\"\"\u65e0\u6cd5\u901a\u8fc7get_points\u83b7\u53d6TexMobject\u7684\u70b9\"\"\"\n\n    def construct(self):\n        tex = TexMobject('S').scale(2)\n        self.add(tex)\n        p = tex.get_points()\n        print(p)"}]}
{"messages": [{"role": "user", "content": "Animate a number plane transforming under a matrix multiplication, highlighting a specific point."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test71(Scene):\n\n    def construct(self):\n        grid = NumberPlane()\n        vector = np.array([1, 2, 0])\n        matrix = np.identity(3) - np.outer(vector, vector)\n        self.add(grid, Dot([1, 2, 0], color=RED))\n        self.wait()\n        self.play(grid.apply_matrix, matrix, run_time=3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create an ambient light source in the scene."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test72(Scene):\n    \"\"\"\u5149\u6e90\"\"\"\n\n    def construct(self):\n        light = AmbientLight()\n        self.add(light)"}]}
{"messages": [{"role": "user", "content": "Visualize a grid with two scaled parametric functions, one following a running_start equation and the other a six-point Bezier curve."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test73(Scene):\n    \"\"\"running_start\u7684\u5199\u6cd5\u662f\u516d\u6b21\u8d1d\u585e\u5c14\u66f2\u7ebf\"\"\"\n\n    def construct(self):\n        grid = NumberPlane().scale(3)\n        func = ParametricFunction(lambda x: [x, running_start(x), 0], t_min=0, t_max=1).scale(3, about_point=ORIGIN)\n        func2 = ParametricFunction(bezier([np.array([0 / 6, 0, 0]), np.array([1 / 6, 0, 0]), np.array([2 / 6, -0.5, 0]), np.array([3 / 6, -0.5, 0]), np.array([4 / 6, 1, 0]), np.array([5 / 6, 1, 0]), np.array([6 / 6, 1, 0])]), t_min=0, t_max=1, color=RED).scale(3, about_point=ORIGIN)\n        self.add(grid, func, func2)"}]}
{"messages": [{"role": "user", "content": "Display a triangle, label its sides, create squares on each side, and then transform those squares into smaller triangles that correspond to an equation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test74(Scene):\n    \"\"\"\u5e7c\u513f\u56ed\u5c0f\u7ec3\u4e601\"\"\"\n    CONFIG = {'camera_config': {'use_plot_depth': True}}\n\n    def setup(self):\n        self.A = np.array([1, 0, 0])\n        self.B = np.array([-1, 0, 0])\n        self.C = np.array([-0.3, 1.3, 0])\n        self.main_tri = Polygon(self.A, self.B, self.C, color=BLUE, fill_color=BLUE, fill_opacity=0.8)\n        label_a = TexMobject('a').scale(0.7).next_to((self.B + self.C) / 2, UL, buff=0.08)\n        label_b = TexMobject('b').scale(0.7).next_to((self.A + self.C) / 2, UR, buff=0.08)\n        label_c = TexMobject('c').scale(0.7).next_to((self.B + self.A) / 2, DOWN, buff=0.08)\n        self.labels = VGroup(label_a, label_b, label_c).set_plot_depth(5)\n        sq_a = Polygon(self.B, self.C, np.array([-1.6, 2, 0]), np.array([-2.3, 0.7, 0]), color=WHITE)\n        sq_b = Polygon(self.C, self.A, np.array([2.3, 1.3, 0]), np.array([1, 2.6, 0]), color=WHITE)\n        sq_c = Polygon(self.A, self.B, np.array([-1, -2, 0]), np.array([1, -2, 0]), color=WHITE)\n        self.sq = VGroup(sq_a, sq_b, sq_c).set_plot_depth(-1)\n        tri_a = Polygon(self.A, np.array([1, -2, 0]), np.array([2.3, 1.3, 0]), color=RED, fill_color=RED, fill_opacity=0.8)\n        tri_b = Polygon(self.B, np.array([-2.3, 0.7, 0]), np.array([-1, -2, 0]), color=YELLOW, fill_color=YELLOW, fill_opacity=0.8)\n        tri_c = Polygon(self.C, np.array([1, 2.6, 0]), np.array([-1.6, 2, 0]), color=GREEN, fill_color=GREEN, fill_opacity=0.8)\n        self.tri = VGroup(tri_a, tri_b, tri_c)\n        equation = TexMobject('S_{\\\\ } = S_{\\\\ } = S_{\\\\ } = S_{\\\\ }').scale(1.5).to_corner(UR, buff=1.1)\n        tri_1 = self.main_tri.copy().set_stroke(width=0).set_fill(opacity=1).scale(0.2).next_to(equation[0][0], RIGHT + DOWN * 3, buff=-0.08)\n        tri_2 = tri_a.copy().rotate(PI / 2).set_stroke(width=0).set_fill(opacity=1).scale(0.2).next_to(equation[0][2], RIGHT + DOWN * 3, buff=-0.08)\n        tri_3 = tri_b.copy().rotate(PI / 2, axis=IN).set_stroke(width=0).set_fill(opacity=1).scale(0.2).next_to(equation[0][4], RIGHT + DOWN * 3, buff=-0.08)\n        tri_4 = tri_c.copy().rotate(PI / 4, axis=IN).set_stroke(width=0).set_fill(opacity=1).scale(0.2).next_to(equation[0][6], RIGHT + DOWN * 3, buff=-0.08)\n        self.equation = VGroup(equation, tri_1, tri_2, tri_3, tri_4)\n\n    def construct(self):\n        self.wait()\n        self.play(ShowCreation(self.main_tri))\n        self.wait()\n        self.play(FadeIn(self.labels))\n        self.wait(2)\n        self.play(*[ShowCreation(i.set_plot_depth(-5)) for i in self.sq], run_time=2)\n        self.wait()\n        self.play(*[ShowCreation(i) for i in self.tri], run_time=2)\n        self.wait()\n        self.play(*[WiggleOutThenIn(i) for i in self.tri], run_time=2)\n        self.wait(2)\n        self.play(FadeOut(self.sq), Rotating(self.tri[0], radians=PI / 2, about_point=self.A), Rotating(self.tri[1], radians=PI / 2, about_point=self.B), Rotating(self.tri[2], radians=PI / 2, about_point=self.C), run_time=3)\n        self.wait()\n        self.play(self.main_tri.shift, LEFT * 2.5 + DOWN, self.tri.shift, LEFT * 2.5 + DOWN, self.labels.shift, LEFT * 2.5 + DOWN)\n        self.labels.set_plot_depth(6)\n        self.wait(2)\n        self.play(WiggleOutThenIn(self.tri[0]), WiggleOutThenIn(self.main_tri))\n        self.play(FadeIn(self.equation[0][0][:3]), TransformFromCopy(self.main_tri, self.equation[1]), TransformFromCopy(self.tri[0], self.equation[2]), run_time=2)\n        self.wait(2)\n        self.play(WiggleOutThenIn(self.tri[1]), WiggleOutThenIn(self.main_tri))\n        equation_copy_1 = self.equation[1].copy()\n        equation_copy_2 = self.equation[1].copy()\n        self.play(FadeIn(self.equation[0][0][3:5]), TransformFromCopy(self.main_tri, equation_copy_1), TransformFromCopy(self.tri[1], self.equation[3]), run_time=2)\n        self.wait(2)\n        self.play(WiggleOutThenIn(self.tri[2]), WiggleOutThenIn(self.main_tri))\n        self.play(FadeIn(self.equation[0][0][5:]), TransformFromCopy(self.main_tri, equation_copy_2), TransformFromCopy(self.tri[2], self.equation[4]), run_time=2)\n        self.wait(3)\n        self.play(FadeOut(VGroup(self.equation[0][0][:2], self.equation[1], equation_copy_1, equation_copy_2)))\n        self.equation[0][0][:2].set_opacity(0)\n        self.equation[1].set_fill(opacity=0)\n        self.equation.generate_target()\n        self.equation.target.scale(1.3).shift(DOWN + LEFT)\n        self.play(MoveToTarget(self.equation))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Animate a complex plane undergoing a nonlinear transformation to show the squaring of each point."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test75(Scene):\n    \"\"\"\u5bf9\u5750\u6807\u8f74\u7684\u975e\u7ebf\u6027\u53d8\u6362\"\"\"\n\n    def construct(self):\n        grid = ComplexPlane().prepare_for_nonlinear_transform(50)\n        self.add(grid)\n        self.wait()\n        self.play(grid.apply_function, lambda point: complex_to_R3(R3_to_complex(point) ** 2), run_time=5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a regular pentagon and then draw a star inside it by rearranging its vertices."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test76(Scene):\n    \"\"\"\u4ea4\u6362\u70b9\u7684\u987a\u5e8f\u5b9e\u73b0\u4e94\u89d2\u661f\"\"\"\n\n    def construct(self):\n        poly = RegularPolygon(5)\n        verts = poly.get_vertices()\n        poly2 = Polygon(verts[0], verts[2], verts[4], verts[1], verts[3]).set_fill(BLUE, opacity=0.5)\n        self.add(poly2)\n        debugTeX(self, verts)"}]}
{"messages": [{"role": "user", "content": "Display an image object with the filename 'GZTime.png' and color it red."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test77(Scene):\n    \"\"\"\u5bf9Imageset_color\uff0c\u6240\u6709rgb\u5747\u66ff\u6362\u4e3a\u6307\u5b9a\u989c\u8272\uff0c\u4f46\u4fdd\u7559alpha\"\"\"\n\n    def construct(self):\n        image = ImageMobject('GZTime.png').set_color(RED)\n        self.add(image)"}]}
{"messages": [{"role": "user", "content": "Animate a colorful logo rotating and transforming through four stages, accompanied by text that appears and then returns to its original position."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test78(Scene):\n    \"\"\"logo\u7684\u4e00\u79cd\u52a8\u753b\u65b9\u6848\"\"\"\n\n    def construct(self):\n        logo1 = VGroup(Polygon(np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([0, 2, 0])), Polygon(np.array([1.5, 0, 0]), np.array([3, 3, 0]), np.array([0, 3, 0])), Polygon(np.array([2, 0, 0]), np.array([3, 0, 0]), np.array([3, 2, 0]))).set_stroke(width=0).center()\n        logo1[0].set_fill(WHITE, 1)\n        logo1[1].set_fill(BLUE_B, 1)\n        logo1[2].set_fill(BLUE_C, 1)\n        logo1.move_to(np.array([2.5, 1, 0]))\n        logo2 = logo1.copy().rotate(PI / 2, about_point=ORIGIN)\n        logo3 = logo2.copy().rotate(PI / 2, about_point=ORIGIN)\n        logo4 = logo3.copy().rotate(PI / 2, about_point=ORIGIN)\n        logo = VGroup(logo1, logo2, logo3, logo4).scale(1 / 3)\n        logo[0][1].set_fill('#C59978', 1)\n        logo[0][2].set_fill('#8D5630', 1)\n        text = VGroup(Text('Manim', font='Nexa Bold'), Text('Kindergarten', font='Nexa Bold')).arrange(DOWN, aligned_edge=LEFT, buff=0.3).set_height(2).next_to(logo, buff=0.8).shift(DOWN * 0.2)\n        all_logo = VGroup(logo, text).center()\n        bg = Rectangle(height=10, width=10, fill_color=BLACK, fill_opacity=1, stroke_width=0)\n        bg.add_updater(lambda m: m.move_to(logo, aligned_edge=RIGHT))\n        text.save_state()\n        text.shift((text.get_right()[0] - bg.get_right()[0] + 0.2) * LEFT)\n        logo.save_state()\n        logo.center().scale(1.5)\n        self.add(text, bg)\n        self.play(FadeIn(logo[0]))\n        self.wait()\n        for i in range(3):\n            self.play(MyTransform(logo[i], logo[i + 1], about_point=logo.get_center()), run_time=0.25, rate_func=smooth)\n        self.wait(2)\n        self.play(text.restore, logo.restore, rate_func=smooth, run_time=1)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate text by coloring each letter yellow sequentially."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test79(Scene):\n    \"\"\"\u9010\u5b57\u4e0a\u989c\u8272\"\"\"\n\n    def construct(self):\n        tex = TextMobject('text or object')\n        self.add(tex)\n        self.wait(0.5)\n        for letter in tex:\n            self.play(LaggedStart(*[ApplyMethod(i.set_color, YELLOW) for i in letter], run_time=2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a dot moving to the right with a custom rate function."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test80(Scene):\n    \"\"\"rate_func\u7684\u7ec6\u8282\u6548\u679c\"\"\"\n\n    def construct(self):\n        dot = Dot()\n        self.add(dot)\n        self.wait()\n        self.play(dot.shift, RIGHT * 3, rate_func=func, run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a four-part logo animation with a white background, using a color palette of grey, dark blue, light blue, tan, and brown."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test81(Scene):\n    \"\"\"\u767d\u5e95logo\u7684\u914d\u8272\u65b9\u6848\"\"\"\n    CONFIG = {'camera_config': {'background_color': WHITE}}\n\n    def construct(self):\n        logo1 = VGroup(Polygon(np.array([0, 0, 0]), np.array([1, 0, 0]), np.array([0, 2, 0])), Polygon(np.array([1.5, 0, 0]), np.array([3, 3, 0]), np.array([0, 3, 0])), Polygon(np.array([2, 0, 0]), np.array([3, 0, 0]), np.array([3, 2, 0]))).set_stroke(width=0).center()\n        logo1[0].set_fill('#cccccc', 1)\n        logo1[1].set_fill(BLUE_D, 1)\n        logo1[2].set_fill(BLUE_E, 1)\n        logo1.move_to(np.array([2.5, 1, 0]))\n        logo2 = logo1.copy().rotate(PI / 2, about_point=ORIGIN)\n        logo3 = logo2.copy().rotate(PI / 2, about_point=ORIGIN)\n        logo4 = logo3.copy().rotate(PI / 2, about_point=ORIGIN)\n        logo = VGroup(logo1, logo2, logo3, logo4).scale(0.7).center()\n        logo[0][1].set_fill('#C59978', 1)\n        logo[0][2].set_fill('#8D5630', 1)\n        self.add(logo)"}]}
{"messages": [{"role": "user", "content": "Display the text \"ab\"."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test82(Scene):\n\n    def construct(self):\n        tex = TextMobject('ab')\n        self.add(tex)"}]}
{"messages": [{"role": "user", "content": "Animate a complex plane undergoing a nonlinear transformation using the exponential function."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test84(Scene):\n    \"\"\"\u5750\u6807\u7cfb\u975e\u7ebf\u6027\u590d\u53d8\u6362\"\"\"\n\n    def construct(self):\n        grid = ComplexPlane().prepare_for_nonlinear_transform(50)\n        self.add(grid)\n        self.wait()\n        self.play(grid.apply_complex_function, np.exp, run_time=3, rate_func=linear)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a blue-filled triangle composed of three connected lines."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test85(Scene):\n    \"\"\"\u7531Line+VGroup\u62fc\u6210\u7684\u591a\u8fb9\u5f62\u65e0\u6cd5\u4e0a\u8272\"\"\"\n\n    def construct(self):\n        vg = VGroup(Line(ORIGIN, RIGHT), Line(RIGHT, UP), Line(UP, ORIGIN)).set_fill(BLUE, 1)\n        self.add(vg)"}]}
{"messages": [{"role": "user", "content": "Display a large, scaled-up representation of a PointCloudDot composed of individual pixels."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test86(Scene):\n    \"\"\"PointCouldDot\u7684\u7ec6\u8282\uff0c\u6709\u4e00\u4e2a\u4e2a\u50cf\u7d20\u70b9\u6784\u6210\u7684\u70b9\"\"\"\n\n    def construct(self):\n        test = PointCloudDot().scale(30)\n        self.add(test)"}]}
{"messages": [{"role": "user", "content": "Create a simple zig-zagging line by connecting three points in sequence."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test87(Scene):\n    \"\"\"\u65e0\u6cd5\u7528Polygon\u8868\u793a\u6298\u7ebf\uff0c\u56e0\u4e3aPolygon\u5f3a\u5236\u9996\u5c3e\u76f8\u63a5\"\"\"\n\n    def construct(self):\n        lines = Polygon(ORIGIN, UP, RIGHT)\n        self.add(lines)"}]}
{"messages": [{"role": "user", "content": "Create a scene showing two connected lines forming a corner with a creation animation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test88(Scene):\n    \"\"\"\u4e0a\u9762\u7684\u6298\u7ebf\u7c7b\u548cVGroup+Line\u6784\u9020\u7684\u6298\u7ebf\u7684ShowCreation\u6548\u679c\u76f8\u540c\"\"\"\n\n    def construct(self):\n        lines = VGroup(Line(ORIGIN, UP), Line(UP, RIGHT))\n        self.play(ShowCreation(lines))"}]}
{"messages": [{"role": "user", "content": "Create a scene displaying a single large blue point."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test89(Scene):\n    \"\"\"\u6d4b\u8bd5PMobject\uff0c\u7528\u4e8e\u753b\u70b9\uff0cstroke_width\u8868\u793a\u70b9\u5927\u5c0f\"\"\"\n\n    def construct(self):\n        points = PMobject(stroke_width=1080)\n        points.add_points([ORIGIN], color=BLUE)\n        self.add(points)"}]}
{"messages": [{"role": "user", "content": "Demonstrate a point moving along a circle, drawing a dashed line from a fixed point to the moving point, and tracing the path with a second line that forms a right angle with the first."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test90(Scene):\n    \"\"\"mk\u7684\u4e00\u6b21\u4f5c\u4e1a\uff0c\u6d4b\u8bd5\u5305\u7edc\u7ebf\"\"\"\n    CONFIG = {'camera_config': {'background_color': WHITE, 'use_plot_depth': True}}\n\n    def construct(self):\n        circle = Circle(radius=3, color=DARK_BLUE, plot_depth=3).flip()\n        center = Dot(color=GREEN)\n        A = Dot(np.array([-2, 0, 0]), color=RED)\n        alpha = ValueTracker(0.0001)\n        B = Dot(color=BLUE, radius=0.07, plot_depth=4)\n        B.add_updater(lambda m: m.move_to(circle.point_from_proportion(alpha.get_value())))\n        line1 = DashedLine(A.get_center(), B.get_center(), color=DARK_BROWN)\n        line1.add_updater(lambda m: m.put_start_and_end_on(A.get_center(), B.get_center()))\n        C = Dot(color=BLUE, radius=0.07, plot_depth=4)\n        C.add_updater(lambda m: m.move_to(circle.point_from_proportion(alpha.get_value())).flip(axis=B.get_center() - A.get_center(), about_point=ORIGIN))\n        line2 = Line(B.get_center(), C.get_center(), color=ORANGE, stroke_width=3)\n        line2.add_updater(lambda m: m.put_start_and_end_on(B.get_center(), C.get_center()))\n        trace = VGroup()\n        self.i = 0\n\n        def update_trace(m):\n            self.i += 1\n            if self.i % 4 == 0:\n                m.add(line2.copy().clear_updaters())\n        self.wait(3)\n        self.play(ShowCreation(circle), ShowCreation(center))\n        self.wait()\n        self.play(ShowCreation(A))\n        alpha.set_value(0.2)\n        self.play(ShowCreation(B))\n        self.play(alpha.increment_value, 0.6, run_time=1.5)\n        self.play(alpha.increment_value, -0.6, run_time=1.6)\n        self.play(ShowCreation(line1))\n        self.wait()\n        ra = Right_angle(corner=B.get_center(), on_the_right=False, stroke_color=BLUE)\n        ra.move_corner_to(B.get_center())\n        ra.change_angle_to(line1.get_angle() + PI / 2)\n        self.play(ShowCreation(C), ShowCreation(line2), ShowCreation(ra))\n        self.wait(2)\n        self.play(FadeOut(ra))\n        self.play(alpha.increment_value, 0.6, run_time=1.5)\n        self.play(alpha.increment_value, -0.7999, run_time=2, rate_func=linear)\n        self.wait()\n        self.add(trace)\n        line2.set_stroke(width=2)\n        self.wait(2)\n        trace.add_updater(update_trace)\n        alpha.set_value(0)\n        anim = ApplyMethod(alpha.increment_value, 1, run_time=8, rate_func=linear)\n        self.play(anim)\n        self.wait(2)\n        ellipse = Ellipse(width=6, height=2 * np.sqrt(5), color=GREEN, plot_depth=10, run_time=2.5)\n        self.play(ShowCreationThenDestruction(ellipse))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Color specific characters in a TexMobject red and blue, then remove them."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test91(Scene):\n    \"\"\"tex\u4e0a\u8272\u540e\u4f1a\u62c6\u5f00\"\"\"\n\n    def construct(self):\n        tex = TexMobject('abcdefghijk')\n        VGroup(tex[0][:2], tex[0][3:5]).set_color(RED)\n        self.add(tex)\n        self.wait()\n        tex2 = VGroup(tex[0][2], tex[0][5])\n        self.play(tex2.set_color, BLUE)\n        self.wait(2)\n        self.remove(*tex[0])\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Create a NumberPlane and a dot shifted in multiple directions."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test92(Scene):\n    \"\"\"\u6d4b\u8bd5shift\u591a\u53c2\u6570\"\"\"\n\n    def construct(self):\n        plane = NumberPlane()\n        dot = Dot().shift(RIGHT, UP, LEFT)\n        self.add(plane, dot)"}]}
{"messages": [{"role": "user", "content": "Animate a tangent line to the letter 'j' that follows its path as the tangent angle changes."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test93(Scene):\n    \"\"\"\u6d4b\u8bd5\u5207\u7ebf\uff0c\u9002\u7528\u4e8e\u6240\u6709\u5e26\u8def\u5f84\u7684\uff0c\u5305\u62ec\u6587\u5b57\"\"\"\n\n    def construct(self):\n        circle = Circle()\n        text = SingleStringTexMobject('j').scale(8)\n        tl = TangentLine(text[0], 0, length=5, stroke_width=1, color=BLUE)\n        value = ValueTracker(0)\n        tl.add_updater(lambda m: m.become(TangentLine(text[0], value.get_value(), length=5, stroke_wodth=1, color=BLUE)))\n        self.add(text, tl)\n        self.wait()\n        self.play(value.increment_value, 1, run_time=10, rate_func=linear)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a camera moving to the left while showing a cube and 3D axes."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test94(ThreeDScene):\n    \"\"\"3D\u79fb\u52a8\u76f8\u673a\u4e2d\u5fc3\uff0c\u4f46\u662f\u597d\u50cf\u6ca1\u6709\u52a8\u753b\u6548\u679c\"\"\"\n\n    def construct(self):\n        self.set_to_default_angled_camera_orientation()\n        cube = Cube()\n        axes = ThreeDAxes()\n        self.add(axes, cube)\n        self.wait()\n        self.play(self.camera.frame_center.move_to, LEFT * 2, run_time=3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the text \"abcdefghijklmnopqrstuvwkyz\" using a specific font with a thick outline and then display the same font name twice, arranged vertically, also with a thick outline."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test95(Scene):\n    \"\"\"\u4feeText\u7684bug\u65f6\u7528\u7684\uff0c\u73b0\u5728\u5e94\u8be5\u4e0d\u597d\u4f7f\u4e86\"\"\"\n\n    def construct(self):\n        text = Text('abcdefghijklmnopqrstuvwkyz', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', fill_opacity=0, debug=True).scale(1).set_stroke(width=5, opacity=1)\n        diff = VGroup(Text('\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', fill_opacity=0).scale(1).set_stroke(width=5, opacity=1), Text('\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', fill_opacity=0, debug=True).scale(1).set_stroke(width=5, opacity=1)).arrange(DOWN)\n        self.add(diff)"}]}
{"messages": [{"role": "user", "content": "Show three text elements appearing sequentially, with the first two transforming into the subsequent ones."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test96(Scene):\n    \"\"\"\u4feeText\u7684bug\u65f6\u7528\u7684\uff0c\u73b0\u5728\u5e94\u8be5\u4e0d\u597d\u4f7f\u4e86\"\"\"\n\n    def construct(self):\n        text = Text('a  b', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', debug=True).scale(3).shift(UP * 2)\n        text3 = Text('abcd', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', debug=True).scale(3).shift(DOWN * 2)\n        text4 = Text('\u5566 \u5566 \u5566', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', debug=True).scale(3).shift(UP * 2)\n        dot = Dot(ORIGIN, color=BLUE)\n        self.add(dot)\n        self.wait()\n        self.play(Write(text))\n        self.wait(2)\n        self.play(Transform(text, text3))\n        self.wait(2)\n        self.play(Transform(text, text4))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Visualize a large, stroked and outlined \"manim\" text, highlighting individual characters with debug outlines."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test97(Scene):\n    \"\"\"\u4feeText\u7684bug\u65f6\u7528\u7684\uff0c\u73b0\u5728\u5e94\u8be5\u4e0d\u597d\u4f7f\u4e86\"\"\"\n\n    def construct(self):\n        text = VGroup(Text('manim', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', debug=True).set_stroke(width=15, opacity=0.5), Text('manim', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', debug=True, fill_opacity=0).set_stroke(width=5)).scale(8).arrange(DOWN)\n        self.add(text)\n        for i in range(5):\n            points = text[1][i].get_points()\n            debugTeX(self, points)"}]}
{"messages": [{"role": "user", "content": "Animate two lines of text with a \"before\" and \"after\" label, visually debugging each line."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test98(Scene):\n    \"\"\"\u4feeText\u7684bug\u65f6\u7528\u7684\uff0c\u73b0\u5728\u5e94\u8be5\u4e0d\u597d\u4f7f\u4e86\"\"\"\n\n    def construct(self):\n        text = VGroup(Text('a  b', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', debug=False).scale(3).shift(UP * 1.5), Text('a  b', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53').scale(3).shift(DOWN * 1.5))\n        comment = VGroup(Text('before:', font='Consolas').scale(2).next_to(text[0], LEFT, buff=1), Text('after:', font='Consolas').scale(2).next_to(text[1], LEFT, buff=1))\n        self.add(text, comment)\n        for i in text:\n            debugTeX(self, i, 0.8)"}]}
{"messages": [{"role": "user", "content": "Display a comparison of text rendering sizes with a title."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test99(Scene):\n    \"\"\"\u4feeText\u7684bug\u65f6\u7528\u7684\uff0c\u73b0\u5728\u5e94\u8be5\u4e0d\u597d\u4f7f\u4e86\"\"\"\n\n    def construct(self):\n        title = Text('default size compare', font='Consolas', color=BLUE).scale(1.5).shift(UP * 2)\n        text = VGroup(VGroup(Text('before', font='Consolas').scale(2), TextMobject('before')).arrange(RIGHT), VGroup(Text('after', font='Consolas'), TextMobject('after')).arrange(RIGHT)).arrange(DOWN, buff=1)\n        self.add(text, title)"}]}
{"messages": [{"role": "user", "content": "Display the first frame of a GIF image."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test100(Scene):\n    \"\"\"\u6d4b\u8bd5ImageMobject\u5bfc\u5165gif\uff0c\u53ea\u4fdd\u7559\u7b2c\u4e00\u5e27\uff0c\u65e0\u52a8\u56fe\"\"\"\n\n    def construct(self):\n        img = ImageMobject('Test96.gif')\n        self.add(img)\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Create a black background mask that appears, transforms, and then fades out over an image."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test101(Scene):\n    \"\"\"\u8bd5\u9a8c\u9ed1\u80cc\u666f\u906e\u7f69\"\"\"\n    CONFIG = {'reverse_order': False}\n\n    def construct(self):\n        img = ImageMobject('latexlive.png', height=8)\n        self.add(img)\n        rects = VGroup(*[Rectangle() for x in range(2)])\n        rects.set_stroke(width=0)\n        rects.set_fill(GREY, 0.5)\n        rects.set_height(2.2, stretch=True)\n        rects.set_width(7.4, stretch=True)\n        rects[0].move_to(DOWN * 0.1)\n        rects[1].set_height(1.5, stretch=True)\n        rects[1].set_width(3, stretch=True)\n        rects[1].move_to(DOWN * 2.75)\n        inv_rects = VGroup()\n        for rect in rects:\n            fsr = FullScreenFadeRectangle()\n            fsr.append_points(rect.points[::-1])\n            inv_rects.add(fsr)\n        inv_rects.set_fill(BLACK, 0.7)\n        self.wait(2)\n        self.play(VFadeIn(inv_rects[0]))\n        self.wait(2)\n        self.play(Transform(inv_rects[0], inv_rects[1]))\n        self.wait(2)\n        self.play(VFadeOut(inv_rects[0]))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Transform one image into another of the same size."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test102(Scene):\n    \"\"\"\u540c\u5927\u5c0fImage\u7684Transform\"\"\"\n\n    def construct(self):\n        img1 = ImageMobject('latexlive.png', height=8)\n        img2 = ImageMobject('latexhelp.png', height=8)\n        self.add(img1)\n        self.wait(2)\n        self.play(Transform(img1, img2), run_time=2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display the \"helloworldcpp.cpp\" file as a code block with syntax highlighting."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test103(Scene):\n    \"\"\"\u6d4b\u8bd5Code\"\"\"\n\n    def construct(self):\n        helloworldcpp = Code('helloworldcpp.cpp', tab_width=4, insert_line_no=True, style='autumn', background_stroke_color=BLACK, background='window', language='cpp')\n        self.add(helloworldcpp)"}]}
{"messages": [{"role": "user", "content": "Transform text with specific formatting and line breaks into different text with similar formatting."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test104(Scene):\n    \"\"\"\u4feeText\u7684bug\u65f6\u7528\u7684\"\"\"\n\n    def construct(self):\n        text1 = Text('  ab\\ncd', font='Consolas', size=2)\n        text2 = Text('ef\\ngh', font='Consolas', size=2)\n        self.add(text1)\n        self.wait()\n        self.play(Transform(text1, text2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a text string with inconsistent spacing transform to a different string with corrected spacing, highlighting a specific character."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test105(Scene):\n    \"\"\"\u4feeText\u7684bug\u65f6\u7528\u7684\"\"\"\n\n    def construct(self):\n        text = Text('  ab\\ncd\\nef', font='Consolas', size=2)\n        text2 = Text('ab\\n  cd\\nef', font='Consolas', size=2)\n        text[2].set_color(YELLOW)\n        self.add(text)\n        self.wait()\n        self.play(Transform(text, text2))\n        self.wait()\n        debugTeX(self, text)"}]}
{"messages": [{"role": "user", "content": "Create a black-and-white number plane with coordinates."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test106(Scene):\n    \"\"\"https://github.com/3b1b/manim/pull/1072\"\"\"\n    CONFIG = {'camera_config': {'background_color': WHITE}}\n\n    def construct(self):\n        plane = NumberPlane(axis_config={'stroke_color': BLACK})\n        plane.add_coordinates(number_config={'color': BLACK})\n        self.add(plane)"}]}
{"messages": [{"role": "user", "content": "Display \"\u7c89\u4e1d\u95ee\u7b54\" and \"(\u51d1\u591f9\u5f20\u56fe)\" with specified fonts and colors."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test107(Scene):\n    \"\"\"\u4e34\u65f6\u505a\u7684\u4e00\u5f20\u56fe\"\"\"\n    CONFIG = {'camera_config': {'background_color': WHITE}}\n\n    def construct(self):\n        main = Text('\u7c89\u4e1d\u95ee\u7b54', font='\u601d\u6e90\u9ed1\u4f53 CN Heavy', color=BLACK).set_width(6)\n        comment = Text('(\u51d1\u591f9\u5f20\u56fe)', font='\u601d\u6e90\u9ed1\u4f53 CN Light', color=BLUE_D)\n        comment.next_to(main, DOWN)\n        self.add(main, comment)"}]}
{"messages": [{"role": "user", "content": "Display the linear transformation equation with specified vector coordinates."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test108(Scene):\n    \"\"\"https://github.com/3b1b/manim/issues/1095\"\"\"\n    CONFIG = {'v_coord_strings': ['-1', '2']}\n\n    def construct(self):\n        rule = TexMobject('\\\\text{Transformed}\\\\vec{\\\\textbf{v}}', ' = %s' % self.v_coord_strings[0], '(\\\\text{Transformed}\\\\hat{\\\\imath})', '+%s' % self.v_coord_strings[1], '(\\\\text{Transformed}\\\\hat{\\\\jmath})')\n        self.add(rule)"}]}
{"messages": [{"role": "user", "content": "Display a Manim logo and a company logo side-by-side, separated by a thick black line, with accompanying text below the company logo."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test109(Scene):\n    \"\"\"\u751f\u6210README\u4e2d\u7684\u5934\u56fe\"\"\"\n    CONFIG = {'camera_config': {'background_color': WHITE}}\n\n    def construct(self):\n        logo = Logo(black_bg=False).set_height(2)\n        img = ImageMobject('Tony.png').set_height(2)\n        Group(logo, img).arrange(RIGHT, buff=1.5).center()\n        line = Line(UP, DOWN, stroke_width=8, color=BLACK).move_to(mid(logo.get_right(), img.get_left()))\n        line.set_length(1.4)\n        text = VGroup(Text('Manim-Kindergarten', font='Orbitron', color=DARK_GRAY), Text('\u9e64\u7fd4\u4e07\u91cc', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', color=BLACK, size=2.3)).arrange(DOWN, aligned_edge=LEFT, buff=0.1).next_to(img, buff=0.5)\n        text[0][0].set_color(logo.color_2[2])\n        text[0][6].set_color(logo.color_1[2])\n        self.add(logo, img, line, text)\n        Group(*self.mobjects).center()"}]}
{"messages": [{"role": "user", "content": "Display a logo and an image side-by-side, separated by a black line, with accompanying text."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test110(Scene):\n    \"\"\"\u7ed9cigar\u7684\u5934\u56fe\uff0c\u6548\u679c\u4e0d\u592a\u597d\"\"\"\n    CONFIG = {'camera_config': {'background_color': WHITE}}\n\n    def construct(self):\n        logo = Logo(black_bg=False).set_height(2)\n        img = ImageMobject('cigar.png').set_height(2)\n        Group(logo, img).arrange(RIGHT, buff=1.5).center()\n        line = Line(UP, DOWN, stroke_width=8, color=BLACK).move_to(mid(logo.get_right(), img.get_left()))\n        line.set_length(1.4)\n        text = VGroup(Text('Manim-Kindergarten', font='Orbitron', color=DARK_GRAY), Text('cigar666', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', color=BLACK, size=2.1)).arrange(DOWN, aligned_edge=LEFT, buff=0.1).next_to(img, buff=0.5)\n        text[0][0].set_color(logo.color_2[2])\n        text[0][6].set_color(logo.color_1[2])\n        self.add(logo, img, line, text)\n        Group(*self.mobjects).center()"}]}
{"messages": [{"role": "user", "content": "Demonstrate the difference between FadeIn/FadeOut and VFadeIn/VFadeOut using two squares."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test111(Scene):\n    \"\"\"Fade\u548cVFade\u7684\u533a\u522b\"\"\"\n\n    def construct(self):\n        sq = VGroup(Square(stroke_width=15, color=RED, opacity=0.5, fill_opacity=0.8), Square(stroke_width=15, color=RED, opacity=0.5, fill_opacity=0.8)).arrange(RIGHT, buff=1)\n        texts = VGroup(Text('FadeIn', font='Consolas', size=1.3).next_to(sq[0], DOWN), Text('VFadeIn', font='Consolas', size=1.3).next_to(sq[1], DOWN))\n        text = VGroup(Text('FadeOut', font='Consolas', size=1.3).next_to(sq[0], DOWN), Text('VFadeOut', font='Consolas', size=1.3).next_to(sq[1], DOWN))\n        self.add(texts)\n        self.wait()\n        self.play(FadeIn(sq[0]), VFadeIn(sq[1]), run_time=3)\n        self.wait()\n        self.play(Transform(texts[0], text[0]), Transform(texts[1], text[1]))\n        self.wait()\n        self.play(FadeOut(sq[0]), VFadeOut(sq[1]), run_time=3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create two rows of dots connected by lines, then animate the top row shifting left and the bottom row shifting right."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test112(Scene):\n    \"\"\"\u7ed9VGroup\u7528for\u5faa\u73af\u65bd\u52a0updater\uff0c\u9700\u8981\u8f6c\u6362\u5168\u5c40\u53d8\u91cfi\u4e3a\u5c40\u90e8\u53d8\u91cfn\"\"\"\n\n    def construct(self):\n        ups = VGroup(*[Dot(color=BLUE).move_to([i, 1, 0]) for i in range(-3, 4)])\n        downs = VGroup(*[Dot(color=YELLOW).move_to([i, -1, 0]) for i in range(-3, 4)])\n        lines = VGroup(*[Line(ups[i], downs[i]) for i in range(0, 7)])\n        for i in range(7):\n            lines[i].add_updater(lambda m, n=i: m.put_start_and_end_on(ups[n].get_bottom(), downs[n].get_top()))\n        self.add(ups, downs, lines)\n        self.wait()\n        self.play(ups.shift, LEFT * 2)\n        self.play(downs.shift, RIGHT * 2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display an SVG image."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test113(Scene):\n\n    def construct(self):\n        svg = SVGMobject('afed61182cb6d368.svg')\n        self.add(svg)"}]}
{"messages": [{"role": "user", "content": "Show a letter 'S' and animate a dot moving along its path."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test114(Scene):\n    \"\"\"\u5b57\u6bcd\u4e5f\u80fd\u505a\u5207\u7ebf\"\"\"\n\n    def construct(self):\n        ratio = ValueTracker(0)\n        text = TexMobject('S', fill_opacity=0, stroke_width=2).set_height(7)\n        point = Dot().add_updater(lambda m: m.move_to(text[0][0].point_from_proportion(ratio.get_value())))\n        self.add(text, point)\n        self.wait()\n        self.play(ratio.set_value, 1, run_time=3, rate_func=linear)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a large plus sign appearing on screen while a number line and a triangle indicator progress from zero to one."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test115(Scene):\n    \"\"\"Write\u7684\u5177\u4f53\u7ec6\u8282\"\"\"\n\n    def construct(self):\n        text = TextMobject('+').set_height(5)\n        self.wait()\n        progress = NumberLine(x_min=0, x_max=1, unit_size=10, tick_frequency=0.5).center().to_edge(DOWN)\n        alpha = ValueTracker(0)\n        tick = Triangle(fill_opacity=1).scale(0.2).rotate(PI)\n        tick.add_updater(lambda m: m.move_to(progress.n2p(alpha.get_value()), aligned_edge=DOWN))\n        self.add(progress, tick)\n        self.play(Write(text, stroke_width=30), alpha.set_value, 1, run_time=5, rate_func=linear)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a parametric curve defined by a specific equation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test116(Scene):\n\n    def construct(self):\n        test = ParametricFunction(lambda t: np.array([2 * np.sin(3 * t) * np.cos(t), 2 * np.sin(3 * t) * np.sin(t), 0]), t_min=0, t_max=2 * PI)\n        debugTeX(self, test.points)\n        self.add(test)"}]}
{"messages": [{"role": "user", "content": "Display a number plane shifted to the left."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test117(Scene):\n\n    def construct(self):\n        grid = NumberPlane(center_point=LEFT * 3, x_max=15)\n        self.add(grid)"}]}
{"messages": [{"role": "user", "content": "Display a continued fraction equation using LaTeX."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test118(Scene):\n    \"\"\"\u597d\u50cf\u662f\u6d4b\u8bd5\u5988\u54aa\u53d4\u7684latexlive\u5199\u7684\"\"\"\n\n    def construct(self):\n        text = TextMobject('\\\\begin{equation}  x = a_0 \\\\+ \\\\cfrac{1}{a_1           \\\\+ \\\\cfrac{1}{a_2           \\\\+ \\\\cfrac{1}{a_3 \\\\+ \\\\cfrac{1}{a_4} } } }\\\\end{equation}')\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Display the \"mk\" logo scaled to a height of 8 units."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test119(Scene):\n    \"\"\"mk\u7684logo\"\"\"\n\n    def construct(self):\n        logo = Logo().set_height(8)\n        self.add(logo)"}]}
{"messages": [{"role": "user", "content": "Animate a circle, dot, and triangle appearing, then move the dot upwards while maintaining its relative position to the triangle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test120(Scene):\n    \"\"\"MaintainPositionRelativeTo\"\"\"\n\n    def construct(self):\n        dot = Dot()\n        circle = Circle()\n        triangle = Triangle()\n        self.play(Write(circle), Write(dot), Write(triangle), run_time=3)\n        self.play(dot.shift, UP, MaintainPositionRelativeTo(triangle, dot))"}]}
{"messages": [{"role": "user", "content": "Display a non-rendering yellow point at coordinates [1, 1, 0]."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test121(Scene):\n    \"\"\"VectorizedPoint\u4e0d\u4f1a\u88ab\u663e\u793a\"\"\"\n\n    def construct(self):\n        v = VectorizedPoint([1, 1, 0], stroke_width=10, stroke_opacity=1, fill_opacity=0, color=YELLOW, artificial_width=10, artificial_height=10)\n        self.add(v)"}]}
{"messages": [{"role": "user", "content": "Animate a stream field with a gradient color based on vector direction and highlight it with a fading flash."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test122(Scene):\n    \"\"\"StreamLines\"\"\"\n\n    def construct(self):\n        sl = StreamLines(lambda p: rotate_vector(p / 3, 90 * DEGREES), color_by_magnitude=True, color_by_arc_length=False)\n        self.add(sl)\n        self.wait()\n        self.play(ShowPassingFlashWithThinningStrokeWidth(sl))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a series of numbers, each representing a height, with animated decimal number representations."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test123(Scene):\n    \"\"\"\u548cTest112\u7c7b\u4f3c\"\"\"\n\n    def construct(self):\n        heights = [2, 3, 5, 7, 9]\n        trackers = [ValueTracker(h) for h in heights]\n        num_tex = [DecimalNumber(t.get_value()).add_updater(lambda v, x=t: v.set_value(x.get_value())) for t in trackers]\n        for i in range(len(num_tex)):\n            tex = num_tex[i]\n            tex.shift(i * RIGHT)\n            self.play(Write(tex))"}]}
{"messages": [{"role": "user", "content": "Animate the mathematical expression \"f(n)+f(n)=2f(n)\" by writing it out and then transforming parts of it to illustrate the concept."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test124(Scene):\n    \"\"\"discord\u4e0a\u6709\u4e2a\u4eba\u95ee\u7684\u52a8\u753b\"\"\"\n\n    def construct(self):\n        tex = TexMobject('f(n)+f(n)=2f(n)')\n        self.wait()\n        self.play(Write(tex[0][:9]))\n        self.play(Write(tex[0][9]))\n        self.wait()\n        self.play(TransformFromCopy(tex[0][:4], tex[0][-4:]), TransformFromCopy(tex[0][5:9], tex[0][-4:].copy()), FadeInFrom(tex[0][-5], RIGHT))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Transform \"f(n)+f(n)\" to \"2f(n)\" by showing the multiplication."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test125(Scene):\n    \"\"\"\u540c\u4e0a\"\"\"\n\n    def construct(self):\n        tex = TexMobject('f(n)+f(n)')\n        two = TexMobject('2').next_to(tex, LEFT, buff=0.02)\n        self.wait()\n        self.play(Write(tex))\n        self.wait()\n        self.play(Transform(tex[0][5:], tex[0][:4].copy()), FadeOut(tex[0][4]), Write(two))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the Chinese text \"\u6d4b\u8bd5\u5b57\u4f53test\" using the default font."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test126(Scene):\n    \"\"\"\u7ed9LaTeX\u6539\u5b57\u4f53\uff0c\u5931\u8d25\u4e86qwq\"\"\"\n\n    def construct(self):\n        text = TextMobject('\u6d4b\u8bd5\u5b57\u4f53test')\n        self.add(text)"}]}
{"messages": [{"role": "user", "content": "Create and display a Manim scene featuring axes with two plotted graphs and specific coordinate labels."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test127(Scene):\n    \"\"\"\u548cAxes\u6709\u5173\u7684\u6d4b\u8bd5\"\"\"\n\n    def construct(self):\n        axes = Axes(x_min=-14, x_max=14, y_min=-8, y_max=8, number_line_config={'unit_size': 0.5, 'tick_frequency': 2})\n        axes.add_coordinates([-6, -4, -2, 2, 4, 6], [-4, -2, 2, 4])\n        graph = VGroup()\n        graph.add(axes.get_graph(lambda x: -(np.exp(-x) - 3), color=RED, x_min=-2.9))\n        graph.add(axes.get_graph(lambda x: x, color=PURPLE))\n        graph.add(axes.get_graph(lambda x: -np.log(3 - x), color=BLUE, step_size=0.001))\n        self.add(axes, graph)"}]}
{"messages": [{"role": "user", "content": "Create a scene showing the \"Action Renderer\" logo alongside a screenshot, separated by a black line, with accompanying text below the screenshot."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test128(Scene):\n    \"\"\"\u7ed9action_renderer\u9879\u76ee\u505a\u7684\u5934\u56fe\"\"\"\n    CONFIG = {'camera_config': {'background_color': WHITE}}\n\n    def construct(self):\n        logo = Logo(black_bg=False).set_height(2)\n        img = ImageMobject('action.png').set_height(2)\n        Group(logo, img).arrange(RIGHT, buff=1.3).center()\n        line = Line(UP, DOWN, stroke_width=8, color=BLACK).move_to(mid(logo.get_right(), img.get_left()))\n        line.set_length(1.4)\n        text = VGroup(Text('Manim-Kindergarten', font='Orbitron', color=DARK_GRAY), Text('manim_action_renderer', font='\u5e9e\u95e8\u6b63\u9053\u6807\u9898\u4f53', color=BLACK, size=1.4)).arrange(DOWN, aligned_edge=LEFT, buff=0.25).next_to(img, buff=0.5)\n        text[0][0].set_color(logo.color_2[2])\n        text[0][6].set_color(logo.color_1[2])\n        self.add(logo, img, line, text)\n        Group(*self.mobjects).center()"}]}
{"messages": [{"role": "user", "content": "Animate two points, A and B, and a line segment between point A and a moving point C, with a label C that updates its position relative to C, and a special case where the line does not update if A and C coincide."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom manim_projects.tony_useful.imports import *\nfrom random import randint\n\nclass Test129(Scene):\n    \"\"\"updater\u4e2d\u7279\u5224\u70b9\u91cd\u5408\"\"\"\n\n    def construct(self):\n        A = Dot(3 * RIGHT)\n        B = Dot(2 * RIGHT)\n        label_A = TexMobject('A').next_to(A, DOWN, buff=SMALL_BUFF)\n        label_B = TexMobject('B').next_to(B, DOWN, buff=SMALL_BUFF)\n        m = -5 * RIGHT\n        C = A.copy()\n        l = Line(A.get_center(), C.get_center())\n        label_C = TexMobject('C').next_to(C, UP, buff=SMALL_BUFF)\n        label_C.add_updater(lambda m: m.next_to(C, UP, buff=SMALL_BUFF))\n\n        def up_loca(mbj):\n            if all(A.get_center() == C.get_center()):\n                pass\n            else:\n                mbj.put_start_and_end_on(A.get_center(), C.get_center())\n        l.add_updater(up_loca)\n        self.add(A, B, label_A, label_B, label_C, l)\n        self.play(C.move_to, m, run_time=5)"}]}
{"messages": [{"role": "user", "content": "Animate the word \"Intro\" appearing and then fading out."}, {"role": "assistant", "content": "from manim import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        text = Tex('\\\\Huge Intro')\n        self.play(Write(text))\n        self.play(FadeOut(text))"}]}
{"messages": [{"role": "user", "content": "Create a scene that displays the word \"Intro\" and then fades it out against a dark gray background."}, {"role": "assistant", "content": "from manim import *\n\nclass Intro(MovingCameraScene):\n\n    def construct(self):\n        self.camera.background_color = DARKER_GRAY\n        text = Tex('\\\\Huge Intro')\n        self.play(Write(text))\n        self.play(FadeOut(text))"}]}
{"messages": [{"role": "user", "content": "Explain the chromatic number, visualize its application with a colored graph, and then animate the display of code and its output, highlighting code lines sequentially."}, {"role": "assistant", "content": "from utilities import *\n\nclass ChromaticNumber(Scene):\n\n    def construct(self):\n        title = Tex('\\\\Large Chromatic Number ($\\\\chi$)')\n        self.play(Write(title), run_time=1)\n        text = Tex('\\\\parbox{23em}{is the ', 'smallest', ' number of colors needed to color the vertices of a graph $G$, such that ', 'no two', ' neighbouring vertices have the ', 'same color', '.}')\n        for i in range(1, len(text), 2):\n            text[i].set_color(YELLOW)\n        self.play(ApplyMethod(title.shift, UP))\n        text.next_to(title, 1.3 * DOWN)\n        self.play(Write(text), run_time=4)\n        self.play(FadeOut(text), FadeOut(title))\n        vertices = [1, 2, 3, 4, 5, 6]\n        edges = [(1, 2), (3, 2), (2, 4), (1, 4), (2, 5), (6, 5), (3, 6), (1, 5)]\n        g = Graph(vertices, edges, layout='circular', layout_scale=3, labels=True)\n        self.play(Write(g))\n        h = Graph(vertices, edges, layout='circular', layout_scale=3, labels=True, vertex_config={1: {'fill_color': RED}, 2: {'fill_color': GREEN}, 3: {'fill_color': RED}, 4: {'fill_color': BLUE}, 5: {'fill_color': BLUE}, 6: {'fill_color': GREEN}})\n        self.play(Transform(g, h))\n        self.play(ApplyMethod(g.shift, RIGHT * 1.3))\n        text = Tex('$\\\\chi(G) = 3$')\n        text.next_to(g, LEFT).shift(LEFT * 1.3)\n        self.play(Write(text))\n        self.play(FadeOut(text), FadeOut(g))\n        code = open('chromaticNumber.py').read()\n        rendered_code = myCode(code=code, language='Python', scale_factor=0.25)\n        self.play(*create_code(self, rendered_code), run_time=1)\n        line_count = len(code.splitlines())\n        previous_lines = [i for i in range(1, line_count + 1)]\n        for lines in [[3, 4], [6], [8], [9, 10], [12, 13], [14, 15, 16], [17, 18, 19], [21], [23], [25, 26, 27]] + [previous_lines]:\n            self.play(*[(FadeIn if i in lines and i not in previous_lines else FadeOut)(rendered_code.line_numbers[i - 1]) for i in range(1, line_count + 1) if (i in lines) != (i in previous_lines)], run_time=0.5)\n            previous_lines = lines\n        output = open('chromaticNumber.out').read()\n        rendered_output = myOutput(code=output, language='text', scale_factor=0.25)\n        self.play(ApplyMethod(rendered_code.shift, UP))\n        rendered_output.next_to(rendered_code, DOWN)\n        self.play(*create_output(self, rendered_output), run_time=1)"}]}
{"messages": [{"role": "user", "content": "Present the definition of linear programming and then animate an example problem involving maximizing an expression subject to constraints."}, {"role": "assistant", "content": "from utilities import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        title = Tex('\\\\Large Linear Programming')\n        self.play(Write(title), run_time=1)\n        text = Tex('\\\\parbox{23em}{is a method of finding a ', 'minimum/maximum', ' of a linear expression of variables, given linear inequalities as ', 'constraints', '.}')\n        for i in range(1, len(text), 2):\n            text[i].set_color(YELLOW)\n        self.play(ApplyMethod(title.shift, UP))\n        text.next_to(title, DOWN)\n        self.play(Write(text), run_time=4)\n        self.play(FadeOut(text), FadeOut(title))\n        text = Tex('\\\\centering \\\\parbox{23em}{Find $(x, y)$ that ', 'maximizes', ' the expression $$x + 3y$$given the ', 'constraints', ' $$\\\\begin{aligned} y &\\\\ge 5x - 10 \\\\\\\\ y &\\\\le \\\\frac{1}{2}x + 3\\\\end{aligned}$$}')\n        for i in range(1, len(text), 2):\n            text[i].set_color(YELLOW)\n        self.play(Write(text), run_time=4)"}]}
{"messages": [{"role": "user", "content": "Visualize a Python script and its output, highlighting specific lines of code as they are executed."}, {"role": "assistant", "content": "from utilities import *\n\nclass Visualizepy(Scene):\n\n    def construct(self):\n        code = open('visualize.py').read()\n        rendered_code = myCode(code=code, language='Python', scale_factor=0.3)\n        self.play(*create_code(self, rendered_code), run_time=1)\n        line_count = len(code.splitlines())\n        previous_lines = [i for i in range(1, line_count + 1)]\n        for lines in [[1], [3], [5], [7, 8], [10], [12], [14, 15]] + [previous_lines]:\n            self.play(*[(FadeIn if i in lines and i not in previous_lines else FadeOut)(rendered_code.line_numbers[i - 1]) for i in range(1, line_count + 1) if (i in lines) != (i in previous_lines)], run_time=0.5)\n            previous_lines = lines\n        output = open('visualize.out').read()\n        rendered_output = myOutput(code=output, language='text', scale_factor=0.3)\n        self.play(ApplyMethod(rendered_code.shift, UP))\n        rendered_output.next_to(rendered_code, DOWN)\n        self.play(*create_output(self, rendered_output), run_time=1)"}]}
{"messages": [{"role": "user", "content": "Explain the knapsack problem, display its solution code line by line, and then show the output."}, {"role": "assistant", "content": "from utilities import *\n\nclass Knapsack(Scene):\n\n    def construct(self):\n        title = Tex('\\\\Large The Knapsack Problem')\n        self.play(Write(title), run_time=1)\n        text = Tex('\\\\parbox{23em}{We are given a knapsack of fixed ', 'load capacity', ' and a list of $n$ objects, each with a ', 'weight', ' $w_i$ and a ', 'price', ' $p_i$. Determine the maximum price of objects to put in the knapsack while not exceeding its capacity.}')\n        for i in range(1, len(text), 2):\n            text[i].set_color(YELLOW)\n        self.play(ApplyMethod(title.shift, 2 * UP))\n        text.next_to(title, DOWN)\n        self.play(Write(text), run_time=4)\n        self.play(FadeOut(text), FadeOut(title))\n        code = open('knapsack.py').read()\n        rendered_code = myCode(code=code, language='Python', scale_factor=0.3)\n        self.play(*create_code(self, rendered_code), run_time=1)\n        line_count = len(code.splitlines())\n        previous_lines = [i for i in range(1, line_count + 1)]\n        for lines in [[3, 4, 5, 6], [8], [10], [12, 13], [15]] + [previous_lines]:\n            self.play(*[(FadeIn if i in lines and i not in previous_lines else FadeOut)(rendered_code.line_numbers[i - 1]) for i in range(1, line_count + 1) if (i in lines) != (i in previous_lines)], run_time=0.5)\n            previous_lines = lines\n        output = open('knapsack.out').read()\n        rendered_output = myOutput(code=output, language='text', scale_factor=0.3)\n        self.play(ApplyMethod(rendered_code.shift, UP))\n        rendered_output.next_to(rendered_code, DOWN)\n        self.play(*create_output(self, rendered_output), run_time=1)"}]}
{"messages": [{"role": "user", "content": "Create a basic Manim scene using the MovingCameraScene template."}, {"role": "assistant", "content": "from manim import *\n\nclass Scene(MovingCameraScene):\n\n    def construct(self):\n        pass"}]}
{"messages": [{"role": "user", "content": "Display three different graphs with various edge colors animated, then remove them and display a new graph with specific edges colored."}, {"role": "assistant", "content": "from utilities import *\n\nclass BeforeIntro(Scene):\n\n    def construct(self):\n        petersen = nx.petersen_graph()\n        tutte = nx.tutte_graph()\n        complete = nx.complete_graph(8)\n        A = Graph.from_networkx(petersen, layout='planar', layout_scale=2).shift(UP * 1.5 + LEFT * 3)\n        B = Graph.from_networkx(tutte, layout='spring', layout_scale=2.5).rotate(PI / 4).shift(DOWN * 2)\n        C = Graph.from_networkx(complete, layout='circular', layout_scale=1.5).shift(UP * 1.5 + RIGHT * 3)\n        self.play(Write(A), Write(B), Write(C))\n        self.play(A.edges[0, 1].animate.set_color(RED), A.edges[0, 4].animate.set_color(BLUE), A.edges[0, 5].animate.set_color(GREEN), A.edges[1, 2].animate.set_color(PINK), A.edges[1, 6].animate.set_color(BLUE), A.edges[2, 3].animate.set_color(BLUE), A.edges[2, 7].animate.set_color(GREEN), A.edges[3, 4].animate.set_color(GREEN), A.edges[3, 8].animate.set_color(RED), A.edges[4, 9].animate.set_color(PINK), A.edges[5, 7].animate.set_color(PINK), A.edges[5, 8].animate.set_color(BLUE), A.edges[6, 8].animate.set_color(GREEN), A.edges[6, 9].animate.set_color(RED), A.edges[7, 9].animate.set_color(BLUE), B.edges[0, 1].animate.set_color(RED), B.edges[0, 2].animate.set_color(GREEN), B.edges[0, 3].animate.set_color(BLUE), B.edges[1, 4].animate.set_color(GREEN), B.edges[1, 26].animate.set_color(BLUE), B.edges[2, 10].animate.set_color(BLUE), B.edges[2, 11].animate.set_color(RED), B.edges[3, 18].animate.set_color(RED), B.edges[3, 19].animate.set_color(GREEN), B.edges[4, 5].animate.set_color(BLUE), B.edges[4, 33].animate.set_color(RED), B.edges[5, 6].animate.set_color(RED), B.edges[5, 29].animate.set_color(GREEN), B.edges[6, 7].animate.set_color(BLUE), B.edges[6, 27].animate.set_color(GREEN), B.edges[7, 8].animate.set_color(GREEN), B.edges[7, 14].animate.set_color(RED), B.edges[8, 9].animate.set_color(RED), B.edges[8, 38].animate.set_color(BLUE), B.edges[9, 10].animate.set_color(GREEN), B.edges[9, 37].animate.set_color(BLUE), B.edges[10, 39].animate.set_color(RED), B.edges[11, 12].animate.set_color(BLUE), B.edges[11, 39].animate.set_color(GREEN), B.edges[12, 13].animate.set_color(GREEN), B.edges[12, 35].animate.set_color(RED), B.edges[13, 14].animate.set_color(BLUE), B.edges[13, 15].animate.set_color(RED), B.edges[14, 34].animate.set_color(GREEN), B.edges[15, 16].animate.set_color(BLUE), B.edges[15, 22].animate.set_color(GREEN), B.edges[16, 17].animate.set_color(GREEN), B.edges[16, 44].animate.set_color(RED), B.edges[17, 18].animate.set_color(BLUE), B.edges[17, 43].animate.set_color(RED), B.edges[18, 45].animate.set_color(GREEN), B.edges[19, 20].animate.set_color(BLUE), B.edges[19, 45].animate.set_color(RED), B.edges[20, 21].animate.set_color(RED), B.edges[20, 41].animate.set_color(GREEN), B.edges[21, 22].animate.set_color(BLUE), B.edges[21, 23].animate.set_color(GREEN), B.edges[22, 40].animate.set_color(RED), B.edges[23, 24].animate.set_color(RED), B.edges[23, 27].animate.set_color(BLUE), B.edges[24, 25].animate.set_color(GREEN), B.edges[24, 32].animate.set_color(BLUE), B.edges[25, 26].animate.set_color(RED), B.edges[25, 31].animate.set_color(BLUE), B.edges[26, 33].animate.set_color(GREEN), B.edges[27, 28].animate.set_color(RED), B.edges[28, 29].animate.set_color(BLUE), B.edges[28, 32].animate.set_color(GREEN), B.edges[29, 30].animate.set_color(RED), B.edges[30, 31].animate.set_color(GREEN), B.edges[30, 33].animate.set_color(BLUE), B.edges[31, 32].animate.set_color(RED), B.edges[34, 35].animate.set_color(BLUE), B.edges[34, 38].animate.set_color(RED), B.edges[35, 36].animate.set_color(GREEN), B.edges[36, 37].animate.set_color(RED), B.edges[36, 39].animate.set_color(BLUE), B.edges[37, 38].animate.set_color(GREEN), B.edges[40, 41].animate.set_color(BLUE), B.edges[40, 44].animate.set_color(GREEN), B.edges[41, 42].animate.set_color(RED), B.edges[42, 43].animate.set_color(GREEN), B.edges[42, 45].animate.set_color(BLUE), B.edges[43, 44].animate.set_color(BLUE), C.edges[0, 1].animate.set_color(RED), C.edges[0, 2].animate.set_color(GREEN), C.edges[0, 3].animate.set_color(BLUE), C.edges[0, 4].animate.set_color(ORANGE), C.edges[0, 5].animate.set_color(PINK), C.edges[0, 6].animate.set_color(WHITE), C.edges[0, 7].animate.set_color(GRAY), C.edges[1, 2].animate.set_color(WHITE), C.edges[1, 3].animate.set_color(GREEN), C.edges[1, 4].animate.set_color(GRAY), C.edges[1, 5].animate.set_color(ORANGE), C.edges[1, 6].animate.set_color(BLUE), C.edges[1, 7].animate.set_color(PINK), C.edges[2, 3].animate.set_color(ORANGE), C.edges[2, 4].animate.set_color(PINK), C.edges[2, 5].animate.set_color(BLUE), C.edges[2, 6].animate.set_color(GRAY), C.edges[2, 7].animate.set_color(RED), C.edges[3, 4].animate.set_color(RED), C.edges[3, 5].animate.set_color(GRAY), C.edges[3, 6].animate.set_color(PINK), C.edges[3, 7].animate.set_color(WHITE), C.edges[4, 5].animate.set_color(WHITE), C.edges[4, 6].animate.set_color(GREEN), C.edges[4, 7].animate.set_color(BLUE), C.edges[5, 6].animate.set_color(RED), C.edges[5, 7].animate.set_color(GREEN), C.edges[6, 7].animate.set_color(ORANGE))\n        self.play(Write(A), Write(B), Write(C), rate_func=lambda t: smooth(1 - t))\n        self.remove(A)\n        self.remove(B)\n        self.remove(C)\n        vertices = [1, 2, 3, 4]\n        edges = [(2, 3), (2, 4), (1, 4), (3, 4)]\n        g = Graph(vertices, edges, layout='circular', layout_scale=3, labels=True).rotate(-PI / 4)\n        for i in g._labels:\n            g._labels[i].scale(0)\n        self.play(Write(g))\n        self.play(g.edges[2, 4].animate.set_color(RED), g.edges[3, 4].animate.set_color(GREEN), g.edges[1, 4].animate.set_color(BLUE), g.edges[2, 3].animate.set_color(BLUE))\n        visuallyChangeColor(self, [(g.edges[2, 3], RED)])"}]}
{"messages": [{"role": "user", "content": "Present Vizing's Theorem with a title and a highlighted explanation."}, {"role": "assistant", "content": "from utilities import *\n\nclass Intro(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex(\"\\\\Huge Vizing's Theorem\")\n        self.play(Write(title))\n        self.play(ApplyMethod(title.shift, UP * 2))\n        text = Tex('\\\\parbox{23em}{Let $\\\\Delta(G)$ be the maximum degree of a graph $G$. Then the ', \"number of colors $\\\\chi'$\", ' needed to ', 'edge color', ' $G$ is ', \"$$\\\\Delta(G) \\\\le \\\\chi' \\\\le \\\\Delta(G) + 1$$}\")\n        highlightText(text)\n        text.next_to(title, 1.3 * DOWN)\n        self.play(Write(text), run_time=4)"}]}
{"messages": [{"role": "user", "content": "Animate a graph with labeled vertices and edges, highlighting specific edges in different colors while displaying and updating related mathematical text."}, {"role": "assistant", "content": "from utilities import *\n\nclass Example(Scene):\n\n    @fade\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5]\n        edges = [(2, 3), (2, 4), (1, 4), (1, 5), (3, 4)]\n        g = Graph(vertices, edges, layout='circular', layout_scale=3, labels=True)\n        for i in g._labels:\n            g._labels[i].scale(0)\n        self.play(Write(g), run_time=3)\n        text = Tex('$\\\\Delta(G) = 3$')\n        text.next_to(g.vertices[2], 6 * RIGHT)\n        text2 = Tex(\"$\\\\chi'(G) = \\\\Delta(G)$\")\n        text2.next_to(text, DOWN)\n        self.play(Write(text))\n        self.play(g.edges[2, 4].animate.set_color(RED), g.edges[3, 4].animate.set_color(GREEN), g.edges[1, 4].animate.set_color(BLUE), g.edges[1, 5].animate.set_color(RED), g.edges[2, 3].animate.set_color(BLUE))\n        self.play(Write(text2))\n        h = Graph(vertices, edges + [(3, 5), (2, 5)], layout='circular', layout_scale=3, labels=True)\n        self.play(Write(h.edges[3, 5]), Write(h.edges[2, 5]))\n        text3 = Tex('$+\\\\ 1$')\n        text3.next_to(text2, RIGHT)\n        self.play(h.edges[3, 5].animate.set_color(YELLOW), h.edges[2, 5].animate.set_color(GREEN))\n        self.play(Write(text3))"}]}
{"messages": [{"role": "user", "content": "Create a circular graph, display vertex labels with zero scale, then replace them with larger numerical labels and indicate the vertex with the highest degree."}, {"role": "assistant", "content": "from utilities import *\n\nclass Degree(Scene):\n\n    @fade\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5, 6]\n        edges = [(2, 3), (2, 4), (1, 6), (3, 4), (4, 1), (4, 5)]\n        g = Graph(vertices, edges, layout='circular', layout_scale=3, labels=True)\n        for i in g._labels:\n            g._labels[i].scale(0)\n        self.play(Write(g))\n        replaces = [Tex('$2$').move_to(g._labels[1]).set_color(BLACK), Tex('$2$').move_to(g._labels[2]).set_color(BLACK), Tex('$2$').move_to(g._labels[3]).set_color(BLACK), Tex('$4$').move_to(g._labels[4]).set_color(BLACK), Tex('$1$').move_to(g._labels[5]).set_color(BLACK), Tex('$1$').move_to(g._labels[6]).set_color(BLACK)]\n        self.play(*map(FadeIn, replaces))\n        self.play(*[ApplyMethod(replace.shift, 2 * RIGHT) for replace in replaces], ApplyMethod(g.shift, 2 * RIGHT))\n        deg2 = Tex('$\\\\Delta(G) = 4$').next_to(g._labels[4], LEFT * 9)\n        self.play(Write(deg2))\n        self.play(Indicate(g.vertices[4]))"}]}
{"messages": [{"role": "user", "content": "Draw a circular graph with colored edges and highlight specific nodes with colored circles, then sequentially change colors of edges and nodes."}, {"role": "assistant", "content": "from utilities import *\n\nclass FreeColor(Scene):\n\n    @fade\n    def construct(self):\n        vertices = [1, 2, 3, 4, 5]\n        edges = [(2, 3), (2, 4), (1, 4), (1, 5), (3, 4), (3, 5), (2, 5)]\n        g = Graph(vertices, edges, layout='circular', layout_scale=3, labels=True)\n        for i in g._labels:\n            g._labels[i].scale(0)\n        g.edges[2, 4].set_color(RED)\n        g.edges[3, 4].set_color(GREEN)\n        g.edges[1, 4].set_color(BLUE)\n        g.edges[1, 5].set_color(RED)\n        g.edges[2, 3].set_color(BLUE)\n        g.edges[3, 5].set_color(YELLOW)\n        g.edges[2, 5].set_color(GREEN)\n        self.play(Write(g), run_time=4)\n        a = Circle(radius=0.07, fill_opacity=1, color=GREEN).next_to(g.vertices[1], UP * 0.7).shift(LEFT * 0.15)\n        aa = Circle(radius=0.07, fill_opacity=1, color=YELLOW).next_to(g.vertices[1], UP * 0.7).shift(RIGHT * 0.15)\n        b = Circle(radius=0.07, fill_opacity=1, color=YELLOW).next_to(g.vertices[2], UP * 0.7)\n        c = Circle(radius=0.07, fill_opacity=1, color=RED).next_to(g.vertices[3], UP * 0.7)\n        d = Circle(radius=0.07, fill_opacity=1, color=YELLOW).next_to(g.vertices[4], DOWN * 0.7)\n        e = Circle(radius=0.07, fill_opacity=1, color=BLUE).next_to(g.vertices[5], DOWN * 0.7)\n        self.play(FadeIn(a), FadeIn(aa), FadeIn(b), FadeIn(c), FadeIn(d), FadeIn(e))\n        visuallyChangeColor(self, [(g.edges[2, 4], YELLOW), (b, RED), (d, RED)])\n        visuallyChangeColor(self, [(g.edges[3, 4], RED), (c, GREEN), (d, GREEN)])"}]}
{"messages": [{"role": "user", "content": "Display the title \"Lower bound\", then a circular graph with specific edges colored, followed by the inequality $\\Delta(G) \\le \\chi'(G)$."}, {"role": "assistant", "content": "from utilities import *\n\nclass LowerBound(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Lower bound')\n        self.play(Write(title))\n        self.play(ApplyMethod(title.shift, 2 * UP))\n        N = 7\n        vertices = [i + 1 for i in range(N)]\n        edges = [(1, i + 1) for i in range(1, N)]\n        g = Graph(vertices, edges, layout='circular', layout_scale=1.5)\n        g.next_to(title, 3 * DOWN)\n        self.play(Write(g))\n        self.play(g.edges[1, 2].animate.set_color(RED), g.edges[1, 3].animate.set_color(GREEN), g.edges[1, 4].animate.set_color(BLUE), g.edges[1, 5].animate.set_color(YELLOW), g.edges[1, 6].animate.set_color(PINK), g.edges[1, 7].animate.set_color(GRAY))\n        self.play(ApplyMethod(g.shift, 2 * LEFT))\n        text = Tex(\"$\\\\Delta(G)\\\\le \\\\chi'(G)$\")\n        text.next_to(g, 3 * RIGHT)\n        self.play(Write(text))"}]}
{"messages": [{"role": "user", "content": "Animate a graph demonstrating upper bound concepts with colored nodes and edges representing different cases and transformations."}, {"role": "assistant", "content": "from utilities import *\n\nclass UpperBound(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Upper bound')\n        self.play(Write(title))\n        self.play(FadeOut(title))\n        seed(1)\n        e = Ellipse(width=8, height=5, color=WHITE)\n        text = Tex('$G$')\n        text.shift(UP * 2 + RIGHT * 3.2)\n        self.play(Write(e), Write(text))\n        vertices = [i for i in range(10)] + ['9']\n        edges = [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (8, 4), (8, 7), (9, 7), (0, 9), (8, '9'), (3, '9'), (4, 8)]\n        s = 0.3\n        lt = {1: [(32.7448099360117 - 37.5) * s, (24.434327797192754 - 20.85) * s, 0], 2: [(30.06934351228568 - 37.5) * s, (18.314489982954107 - 20.85) * s, 0], 3: [(34.424961294659475 - 37.5) * s, (18.154452377859204 - 20.85) * s, 0], 4: [(38.167198471557086 - 37.5) * s, (19.72097026586286 - 20.85) * s, 0], 5: [(40.08183144578378 - 37.5) * s, (23.144101947056036 - 20.85) * s, 0], 6: [(40.25588898889529 - 37.5) * s, (26.799310352397896 - 20.85) * s, 0], 7: [(43.201193299423025 - 37.5) * s, (16.591257981420444 - 20.85) * s, 0], 8: [(40.16886021733954 - 37.5) * s, (15.630618002742203 - 20.85) * s, 0], 9: [(45.201193299423025 - 37.5) * s, (19.2 - 20.85) * s, 0], 0: [(46.201193299423025 - 37.5) * s, (22.591257981420444 - 20.85) * s, 0], '9': [(37.16886021733954 - 37.5) * s, (14.630618002742203 - 20.85) * s, 0]}\n        g = Graph(vertices, edges, layout=lt, labels=True, layout_scale=0.2)\n        for i in g._labels:\n            g._labels[i].scale(0)\n        replace = Tex('$x$').move_to(g._labels[1]).set_color(BLACK)\n        replace2 = Tex('$y$').move_to(g._labels[2]).set_color(BLACK)\n        self.play(Write(g.vertices[1]), Write(g.vertices[2]), Write(g.edges[1, 2]), FadeIn(replace), FadeIn(replace2))\n        a = Circle(radius=0.07, fill_opacity=1, color=RED)\n        a.next_to(g.vertices[1], UP * 0.7)\n        b = Circle(radius=0.07, fill_opacity=1, color=RED)\n        b.next_to(g.vertices[2], UP * 0.7)\n        self.play(FadeIn(a))\n        self.play(FadeIn(b))\n        visuallyChangeColor(self, [(g.edges[1, 2], RED)])\n        self.play(g.edges[1, 2].animate.set_color(WHITE), b.animate.set_color(PINK))\n        (g.edges[1, 3].set_color(PINK),)\n        self.play(Write(g.vertices[3]), Write(g.edges[1, 3]))\n        c = Circle(radius=0.07, fill_opacity=1, color=BLUE)\n        c.next_to(g.vertices[3], UP * 0.7)\n        self.play(FadeIn(c))\n        (g.edges[1, 4].set_color(BLUE),)\n        (g.edges[1, 5].set_color(GREEN),)\n        d = Circle(radius=0.07, fill_opacity=1, color=GREEN)\n        d.next_to(g.vertices[4], UP * 0.7)\n        e = Tex('?').scale(0.5)\n        e.next_to(g.vertices[5], UP * 0.7)\n        self.play(Write(g.vertices[4]), Write(g.edges[1, 4]), FadeIn(d))\n        self.play(Write(g.vertices[5]), Write(g.edges[1, 5]), FadeIn(e))\n        ee = Circle(radius=0.07, fill_opacity=1, color=RED)\n        ee.next_to(g.vertices[5], UP * 0.7)\n        case1 = Tex('\\\\Large Case I')\n        case1.shift(UP * 2.7 + LEFT * 4.8)\n        self.play(Write(case1))\n        self.play(Transform(e, ee))\n        visuallyChangeColor(self, [(a, GREEN), (e, GREEN), (g.edges[1, 5], RED)])\n        visuallyChangeColor(self, [(a, BLUE), (d, BLUE), (g.edges[1, 4], GREEN)])\n        visuallyChangeColor(self, [(a, PINK), (c, PINK), (g.edges[1, 3], BLUE)])\n        visuallyChangeColor(self, [(a, GRAY), (b, GRAY), (g.edges[1, 2], PINK)])\n        eee = Tex('?').scale(0.5)\n        eee.next_to(g.vertices[5], UP * 0.7)\n        self.play(a.animate.set_color(RED), b.animate.set_color(PINK), c.animate.set_color(BLUE), d.animate.set_color(GREEN), Transform(e, eee), g.edges[1, 2].animate.set_color(WHITE), g.edges[1, 3].animate.set_color(PINK), g.edges[1, 4].animate.set_color(BLUE), g.edges[1, 5].animate.set_color(GREEN))\n        case2 = Tex('\\\\Large I')\n        case2.next_to(case1, RIGHT * 0.2)\n        self.play(Write(case2))\n        ee.set_color(BLUE)\n        self.play(Transform(e, ee))\n        self.play(Indicate(e), Indicate(g.edges[1, 4]))\n        replace3 = Tex('$u$').move_to(g._labels[5]).set_color(BLACK)\n        replace4 = Tex('$v$').move_to(g._labels[4]).set_color(BLACK)\n        g.edges[8, 4].set_color(RED)\n        g.edges[8, 7].set_color(BLUE)\n        g.edges[9, 7].set_color(RED)\n        g.edges[0, 9].set_color(BLUE)\n        self.play(FadeIn(replace3), FadeIn(replace4))\n        f = Circle(radius=0.07, fill_opacity=1, color=RED)\n        f.next_to(g.vertices[0], UP * 0.7)\n        replace5 = Tex('$w$').move_to(g._labels[3]).set_color(BLACK)\n        g.edges[3, '9'].set_color(RED)\n        g.edges[8, '9'].set_color(BLUE)\n        g.edges[4, 8].set_color(RED)\n        self.play(FadeIn(replace5), FadeIn(g.edges[3, '9']), FadeIn(g.edges[4, 8]), FadeIn(g.edges[8, '9']), FadeIn(g.vertices[8]), FadeIn(g.vertices['9']))\n        visuallyChangeColor(self, [(g.edges[1, 4], RED), (g.edges[3, '9'], BLUE), (g.edges[8, '9'], RED), (g.edges[4, 8], BLUE), (c, RED), (a, BLUE)])\n        visuallyChangeColor(self, [(g.edges[1, 5], BLUE), (a, GREEN), (e, GREEN)])\n        visuallyChangeColor(self, [(g.edges[1, 4], GREEN), (a, RED), (d, RED)])\n        visuallyChangeColor(self, [(g.edges[1, 3], RED), (a, PINK), (c, PINK)])\n        visuallyChangeColor(self, [(g.edges[1, 2], PINK), (a, GRAY), (b, GRAY)])\n        self.play(a.animate.set_color(RED), b.animate.set_color(PINK), c.animate.set_color(BLUE), d.animate.set_color(GREEN), e.animate.set_color(BLUE), g.edges[1, 2].animate.set_color(WHITE), g.edges[1, 3].animate.set_color(PINK), g.edges[1, 4].animate.set_color(BLUE), g.edges[1, 5].animate.set_color(GREEN), FadeOut(g.edges[3, '9']), FadeOut(g.edges[8, '9']), FadeOut(g.edges[4, 8]), FadeOut(g.vertices[8]), FadeOut(g.vertices['9']))\n        g.edges[4, 8].set_color(RED)\n        self.play(FadeIn(g.vertices[8]), FadeIn(g.vertices[7]), FadeIn(g.edges[8, 7]), FadeIn(g.edges[9, 7]), FadeIn(g.edges[0, 9]), FadeIn(g.edges[4, 8]), FadeIn(g.vertices[9]), FadeIn(g.vertices[0]), FadeIn(f))\n        visuallyChangeColor(self, [(g.edges[1, 4], RED), (g.edges[8, 4], BLUE), (g.edges[8, 7], RED), (g.edges[9, 7], BLUE), (g.edges[0, 9], RED), (g.edges[0, 9], RED), (a, BLUE), (f, BLUE)])\n        visuallyChangeColor(self, [(g.edges[1, 3], BLUE), (a, PINK), (c, PINK)])\n        visuallyChangeColor(self, [(g.edges[1, 2], PINK), (a, GRAY), (b, GRAY)])\n        self.play(Indicate(g.vertices[4]), Indicate(g.vertices[7]), Indicate(g.vertices[8]), Indicate(g.vertices[9]))\n        self.play(Indicate(g.vertices[1]))\n        self.play(Indicate(g.vertices[0]))"}]}
{"messages": [{"role": "user", "content": "Animate a circular graph, color its edges, then fade it out and repeat the process with a larger circular graph."}, {"role": "assistant", "content": "from utilities import *\n\nclass Outro(Scene):\n\n    def construct(self):\n        g = Graph([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [(0, 11), (0, 10), (0, 16), (0, 6), (1, 18), (1, 5), (1, 11), (1, 8), (1, 10), (2, 9), (2, 15), (3, 13), (3, 19), (3, 12), (3, 18), (3, 8), (4, 17), (4, 13), (4, 19), (5, 7), (5, 10), (5, 15), (5, 8), (6, 11), (6, 10), (6, 16), (7, 9), (7, 15), (8, 18), (8, 11), (8, 10), (9, 15), (10, 11), (10, 16), (11, 16), (13, 17), (13, 19), (17, 19)], layout='circular', layout_scale=3)\n        self.play(Write(g))\n        self.play(g.edges[0, 11].animate.set_color(YELLOW), g.edges[0, 10].animate.set_color(GREEN), g.edges[0, 16].animate.set_color(RED), g.edges[0, 6].animate.set_color(PINK), g.edges[1, 18].animate.set_color(PINK), g.edges[1, 5].animate.set_color(GRAY), g.edges[1, 11].animate.set_color(GREEN), g.edges[1, 8].animate.set_color(ORANGE), g.edges[1, 10].animate.set_color(RED), g.edges[2, 9].animate.set_color(PINK), g.edges[2, 15].animate.set_color(BLUE), g.edges[3, 13].animate.set_color(PINK), g.edges[3, 19].animate.set_color(RED), g.edges[3, 12].animate.set_color(BLUE), g.edges[3, 18].animate.set_color(ORANGE), g.edges[3, 8].animate.set_color(GRAY), g.edges[4, 17].animate.set_color(PINK), g.edges[4, 13].animate.set_color(BLUE), g.edges[4, 19].animate.set_color(RED), g.edges[5, 7].animate.set_color(BLUE), g.edges[5, 10].animate.set_color(ORANGE), g.edges[5, 15].animate.set_color(RED), g.edges[5, 8].animate.set_color(YELLOW), g.edges[6, 11].animate.set_color(RED), g.edges[6, 10].animate.set_color(YELLOW), g.edges[6, 16].animate.set_color(GRAY), g.edges[7, 9].animate.set_color(RED), g.edges[7, 15].animate.set_color(YELLOW), g.edges[8, 18].animate.set_color(GREEN), g.edges[8, 11].animate.set_color(BLUE), g.edges[8, 10].animate.set_color(PINK), g.edges[9, 15].animate.set_color(GRAY), g.edges[10, 11].animate.set_color(GRAY), g.edges[10, 16].animate.set_color(BLUE), g.edges[11, 16].animate.set_color(PINK), g.edges[13, 17].animate.set_color(GRAY), g.edges[13, 19].animate.set_color(RED), g.edges[17, 19].animate.set_color(RED))\n        self.play(Write(g), rate_func=lambda t: smooth(1 - t))\n        self.remove(g)\n        g = Graph([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29], [(0, 2), (0, 24), (0, 11), (1, 17), (2, 27), (2, 15), (2, 24), (3, 13), (3, 24), (3, 11), (3, 26), (4, 9), (4, 12), (4, 29), (4, 16), (5, 10), (5, 19), (5, 18), (5, 15), (5, 27), (6, 8), (6, 23), (6, 7), (6, 25), (7, 19), (8, 23), (8, 25), (9, 25), (9, 12), (10, 18), (10, 15), (10, 27), (10, 17), (10, 19), (11, 26), (11, 13), (11, 24), (13, 26), (13, 24), (14, 28), (14, 21), (14, 20), (15, 27), (15, 18), (16, 29), (17, 18), (18, 19), (18, 27), (19, 27), (20, 29), (20, 28), (20, 21), (21, 28), (21, 26), (23, 25), (24, 26), (28, 29)], layout='circular', layout_scale=3)\n        self.play(Write(g))\n        self.play(g.edges[0, 2].animate.set_color(YELLOW), g.edges[0, 24].animate.set_color(PINK), g.edges[0, 11].animate.set_color(GREEN), g.edges[1, 17].animate.set_color(GRAY), g.edges[2, 27].animate.set_color(GREEN), g.edges[2, 15].animate.set_color(GRAY), g.edges[2, 24].animate.set_color(BLUE), g.edges[3, 13].animate.set_color(PINK), g.edges[3, 24].animate.set_color(GREEN), g.edges[3, 11].animate.set_color(GRAY), g.edges[3, 26].animate.set_color(RED), g.edges[4, 9].animate.set_color(BLUE), g.edges[4, 12].animate.set_color(GREEN), g.edges[4, 29].animate.set_color(RED), g.edges[4, 16].animate.set_color(YELLOW), g.edges[5, 10].animate.set_color(PINK), g.edges[5, 19].animate.set_color(RED), g.edges[5, 18].animate.set_color(YELLOW), g.edges[5, 15].animate.set_color(GREEN), g.edges[5, 27].animate.set_color(GRAY), g.edges[6, 8].animate.set_color(YELLOW), g.edges[6, 23].animate.set_color(RED), g.edges[6, 7].animate.set_color(GRAY), g.edges[6, 25].animate.set_color(PINK), g.edges[7, 19].animate.set_color(BLUE), g.edges[8, 23].animate.set_color(BLUE), g.edges[8, 25].animate.set_color(GREEN), g.edges[9, 25].animate.set_color(YELLOW), g.edges[9, 12].animate.set_color(GRAY), g.edges[10, 18].animate.set_color(GRAY), g.edges[10, 15].animate.set_color(RED), g.edges[10, 27].animate.set_color(BLUE), g.edges[10, 17].animate.set_color(YELLOW), g.edges[10, 19].animate.set_color(GREEN), g.edges[11, 26].animate.set_color(PINK), g.edges[11, 13].animate.set_color(BLUE), g.edges[11, 24].animate.set_color(YELLOW), g.edges[13, 26].animate.set_color(GREEN), g.edges[13, 24].animate.set_color(RED), g.edges[14, 28].animate.set_color(BLUE), g.edges[14, 21].animate.set_color(GRAY), g.edges[14, 20].animate.set_color(YELLOW), g.edges[15, 27].animate.set_color(PINK), g.edges[15, 18].animate.set_color(BLUE), g.edges[16, 29].animate.set_color(RED), g.edges[17, 18].animate.set_color(GREEN), g.edges[18, 19].animate.set_color(PINK), g.edges[18, 27].animate.set_color(RED), g.edges[19, 27].animate.set_color(YELLOW), g.edges[20, 29].animate.set_color(RED), g.edges[20, 28].animate.set_color(PINK), g.edges[20, 21].animate.set_color(RED), g.edges[21, 28].animate.set_color(GREEN), g.edges[21, 26].animate.set_color(YELLOW), g.edges[23, 25].animate.set_color(GRAY), g.edges[24, 26].animate.set_color(GRAY), g.edges[28, 29].animate.set_color(RED))\n        self.play(Write(g), rate_func=lambda t: smooth(1 - t))\n        self.remove(g)\n        g = Graph([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49], [(0, 23), (0, 9), (0, 36), (0, 47), (0, 22), (0, 6), (1, 29), (2, 27), (2, 24), (2, 8), (2, 26), (2, 3), (2, 18), (3, 24), (3, 8), (3, 44), (3, 5), (3, 18), (4, 48), (4, 33), (4, 14), (5, 44), (6, 47), (6, 22), (6, 23), (7, 17), (7, 35), (7, 21), (7, 41), (7, 25), (7, 36), (7, 22), (8, 27), (8, 38), (8, 24), (8, 42), (8, 26), (9, 35), (9, 10), (9, 30), (9, 23), (9, 41), (9, 20), (9, 22), (10, 20), (10, 30), (10, 18), (10, 41), (11, 37), (12, 13), (12, 31), (12, 15), (12, 39), (12, 32), (13, 15), (13, 39), (13, 32), (13, 31), (14, 33), (14, 48), (14, 45), (15, 39), (15, 32), (15, 16), (15, 31), (15, 28), (16, 31), (16, 28), (16, 39), (17, 21), (17, 41), (17, 43), (17, 36), (17, 35), (18, 30), (18, 41), (18, 20), (19, 32), (19, 44), (19, 30), (20, 40), (20, 30), (20, 41), (21, 34), (21, 43), (21, 27), (21, 26), (22, 35), (22, 23), (22, 36), (22, 47), (23, 47), (24, 42), (24, 26), (24, 27), (25, 36), (25, 33), (25, 35), (25, 48), (26, 43), (26, 27), (26, 38), (27, 43), (27, 38), (28, 39), (28, 31), (28, 49), (30, 41), (31, 39), (31, 32), (33, 36), (33, 48), (34, 43), (35, 41), (35, 36), (36, 48), (37, 49)], layout='circular', layout_scale=3)\n        self.play(Write(g))\n        self.play(g.edges[0, 23].animate.set_color(ORANGE), g.edges[0, 9].animate.set_color(RED), g.edges[0, 36].animate.set_color(GRAY), g.edges[0, 47].animate.set_color(WHITE), g.edges[0, 22].animate.set_color(GREEN), g.edges[0, 6].animate.set_color(YELLOW), g.edges[1, 29].animate.set_color(RED), g.edges[2, 27].animate.set_color(YELLOW), g.edges[2, 24].animate.set_color(BLUE), g.edges[2, 8].animate.set_color(WHITE), g.edges[2, 26].animate.set_color(ORANGE), g.edges[2, 3].animate.set_color(GREEN), g.edges[2, 18].animate.set_color(PINK), g.edges[3, 24].animate.set_color(PINK), g.edges[3, 8].animate.set_color(ORANGE), g.edges[3, 44].animate.set_color(GRAY), g.edges[3, 5].animate.set_color(RED), g.edges[3, 18].animate.set_color(BLUE), g.edges[4, 48].animate.set_color(WHITE), g.edges[4, 33].animate.set_color(BLUE), g.edges[4, 14].animate.set_color(ORANGE), g.edges[5, 44].animate.set_color(BLUE), g.edges[6, 47].animate.set_color(ORANGE), g.edges[6, 22].animate.set_color(GRAY), g.edges[6, 23].animate.set_color(GREEN), g.edges[7, 17].animate.set_color(ORANGE), g.edges[7, 35].animate.set_color(GREEN), g.edges[7, 21].animate.set_color(RED), g.edges[7, 41].animate.set_color(BLUE), g.edges[7, 25].animate.set_color(GRAY), g.edges[7, 36].animate.set_color(PINK), g.edges[7, 22].animate.set_color(YELLOW), g.edges[8, 27].animate.set_color(GRAY), g.edges[8, 38].animate.set_color(PINK), g.edges[8, 24].animate.set_color(GREEN), g.edges[8, 42].animate.set_color(BLUE), g.edges[8, 26].animate.set_color(RED), g.edges[9, 35].animate.set_color(BLUE), g.edges[9, 10].animate.set_color(YELLOW), g.edges[9, 30].animate.set_color(WHITE), g.edges[9, 23].animate.set_color(PINK), g.edges[9, 41].animate.set_color(GRAY), g.edges[9, 20].animate.set_color(GREEN), g.edges[9, 22].animate.set_color(ORANGE), g.edges[10, 20].animate.set_color(GRAY), g.edges[10, 30].animate.set_color(PINK), g.edges[10, 18].animate.set_color(GREEN), g.edges[10, 41].animate.set_color(ORANGE), g.edges[11, 37].animate.set_color(RED), g.edges[12, 13].animate.set_color(GREEN), g.edges[12, 31].animate.set_color(BLUE), g.edges[12, 15].animate.set_color(PINK), g.edges[12, 39].animate.set_color(RED), g.edges[12, 32].animate.set_color(ORANGE), g.edges[13, 15].animate.set_color(BLUE), g.edges[13, 39].animate.set_color(PINK), g.edges[13, 32].animate.set_color(WHITE), g.edges[13, 31].animate.set_color(RED), g.edges[14, 33].animate.set_color(YELLOW), g.edges[14, 48].animate.set_color(PINK), g.edges[14, 45].animate.set_color(RED), g.edges[15, 39].animate.set_color(GRAY), g.edges[15, 32].animate.set_color(RED), g.edges[15, 16].animate.set_color(ORANGE), g.edges[15, 31].animate.set_color(YELLOW), g.edges[15, 28].animate.set_color(WHITE), g.edges[16, 31].animate.set_color(WHITE), g.edges[16, 28].animate.set_color(GREEN), g.edges[16, 39].animate.set_color(BLUE), g.edges[17, 21].animate.set_color(YELLOW), g.edges[17, 41].animate.set_color(WHITE), g.edges[17, 43].animate.set_color(RED), g.edges[17, 36].animate.set_color(BLUE), g.edges[17, 35].animate.set_color(GRAY), g.edges[18, 30].animate.set_color(GRAY), g.edges[18, 41].animate.set_color(YELLOW), g.edges[18, 20].animate.set_color(ORANGE), g.edges[19, 32].animate.set_color(YELLOW), g.edges[19, 44].animate.set_color(PINK), g.edges[19, 30].animate.set_color(BLUE), g.edges[20, 40].animate.set_color(WHITE), g.edges[20, 30].animate.set_color(YELLOW), g.edges[20, 41].animate.set_color(PINK), g.edges[21, 34].animate.set_color(PINK), g.edges[21, 43].animate.set_color(ORANGE), g.edges[21, 27].animate.set_color(BLUE), g.edges[21, 26].animate.set_color(WHITE), g.edges[22, 35].animate.set_color(PINK), g.edges[22, 23].animate.set_color(RED), g.edges[22, 36].animate.set_color(WHITE), g.edges[22, 47].animate.set_color(BLUE), g.edges[23, 47].animate.set_color(GRAY), g.edges[24, 42].animate.set_color(YELLOW), g.edges[24, 26].animate.set_color(GRAY), g.edges[24, 27].animate.set_color(RED), g.edges[25, 36].animate.set_color(ORANGE), g.edges[25, 33].animate.set_color(GREEN), g.edges[25, 35].animate.set_color(WHITE), g.edges[25, 48].animate.set_color(RED), g.edges[26, 43].animate.set_color(YELLOW), g.edges[26, 27].animate.set_color(PINK), g.edges[26, 38].animate.set_color(BLUE), g.edges[27, 43].animate.set_color(WHITE), g.edges[27, 38].animate.set_color(GREEN), g.edges[28, 39].animate.set_color(YELLOW), g.edges[28, 31].animate.set_color(PINK), g.edges[28, 49].animate.set_color(RED), g.edges[30, 41].animate.set_color(GREEN), g.edges[31, 39].animate.set_color(ORANGE), g.edges[31, 32].animate.set_color(GRAY), g.edges[33, 36].animate.set_color(RED), g.edges[33, 48].animate.set_color(ORANGE), g.edges[34, 43].animate.set_color(BLUE), g.edges[35, 41].animate.set_color(RED), g.edges[35, 36].animate.set_color(YELLOW), g.edges[36, 48].animate.set_color(GREEN), g.edges[37, 49].animate.set_color(RED))\n        self.play(Write(g), rate_func=lambda t: smooth(1 - t))\n        self.remove(g)"}]}
{"messages": [{"role": "user", "content": "Display two graphs with specific node layouts and color all edges based on a predefined scheme, then present them with accompanying text and zoom the camera to fit the entire composition."}, {"role": "assistant", "content": "from utilities import *\n\nclass Thumbnail(MovingCameraScene):\n\n    def construct(self):\n        self.next_section(skip_animations=True)\n        petersen = nx.petersen_graph()\n        complete = nx.complete_graph(8)\n        C = Graph.from_networkx(complete, layout='circular', layout_scale=1.5).shift(UP * 1.5 + RIGHT * 3)\n        vertices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        edges = [(1, 2), (1, 6), (1, 5), (2, 3), (2, 7), (3, 8), (3, 4), (4, 5), (4, 9), (5, 10), (6, 8), (6, 9), (7, 9), (7, 10), (8, 10)]\n        lt = {1: Dot().shift(UP).get_center(), 2: Dot().shift(UP).rotate_about_origin(2 * PI / 5).get_center(), 3: Dot().shift(UP).rotate_about_origin(2 * PI / 5 * 2).get_center(), 4: Dot().shift(UP).rotate_about_origin(2 * PI / 5 * 3).get_center(), 5: Dot().shift(UP).rotate_about_origin(2 * PI / 5 * 4).get_center(), 6: Dot().shift(UP * 0.5).get_center(), 7: Dot().shift(UP * 0.5).rotate_about_origin(2 * PI / 5).get_center(), 8: Dot().shift(UP * 0.5).rotate_about_origin(2 * PI / 5 * 2).get_center(), 9: Dot().shift(UP * 0.5).rotate_about_origin(2 * PI / 5 * 3).get_center(), 10: Dot().shift(UP * 0.5).rotate_about_origin(2 * PI / 5 * 4).get_center()}\n        A = Graph(vertices, edges, layout=lt, layout_scale=3).scale(1.5)\n        self.play(Write(A), Write(C))\n        self.play(A.edges[1, 2].animate.set_color(YELLOW), A.edges[1, 6].animate.set_color(BLUE), A.edges[1, 5].animate.set_color(ORANGE), A.edges[2, 3].animate.set_color(GREEN), A.edges[2, 7].animate.set_color(RED), A.edges[3, 8].animate.set_color(ORANGE), A.edges[3, 4].animate.set_color(BLUE), A.edges[4, 5].animate.set_color(RED), A.edges[4, 9].animate.set_color(YELLOW), A.edges[5, 10].animate.set_color(GREEN), A.edges[6, 8].animate.set_color(RED), A.edges[6, 9].animate.set_color(GREEN), A.edges[7, 9].animate.set_color(ORANGE), A.edges[7, 10].animate.set_color(BLUE), A.edges[8, 10].animate.set_color(YELLOW), C.edges[0, 1].animate.set_color(RED), C.edges[0, 2].animate.set_color(GREEN), C.edges[0, 3].animate.set_color(BLUE), C.edges[0, 4].animate.set_color(ORANGE), C.edges[0, 5].animate.set_color(PINK), C.edges[0, 6].animate.set_color(WHITE), C.edges[0, 7].animate.set_color(GRAY), C.edges[1, 2].animate.set_color(WHITE), C.edges[1, 3].animate.set_color(GREEN), C.edges[1, 4].animate.set_color(GRAY), C.edges[1, 5].animate.set_color(ORANGE), C.edges[1, 6].animate.set_color(BLUE), C.edges[1, 7].animate.set_color(PINK), C.edges[2, 3].animate.set_color(ORANGE), C.edges[2, 4].animate.set_color(PINK), C.edges[2, 5].animate.set_color(BLUE), C.edges[2, 6].animate.set_color(GRAY), C.edges[2, 7].animate.set_color(RED), C.edges[3, 4].animate.set_color(RED), C.edges[3, 5].animate.set_color(GRAY), C.edges[3, 6].animate.set_color(PINK), C.edges[3, 7].animate.set_color(WHITE), C.edges[4, 5].animate.set_color(WHITE), C.edges[4, 6].animate.set_color(GREEN), C.edges[4, 7].animate.set_color(BLUE), C.edges[5, 6].animate.set_color(RED), C.edges[5, 7].animate.set_color(GREEN), C.edges[6, 7].animate.set_color(ORANGE))\n        self.next_section()\n        g = Group(A, C).arrange(buff=1.2).move_to(ORIGIN)\n        a = Tex(\"Vizing's Theorem\").scale(2).next_to(g, UP, buff=0.8)\n        self.add(a)\n        fg = Group(a, g)\n        self.camera.frame.move_to(fg).set_height(fg.get_height() * 1.4)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate an animation of an optimal sorting network, demonstrating its initial state, highlighting its components, simulating its sorting process, and then showing its optimized version with colored layers."}, {"role": "assistant", "content": "from utilities import *\n\nclass Introduction(Scene):\n\n    @fade\n    def construct(self):\n        sn = SortingNetwork.OptimalSorter(7, width=9, height=4.5, depth_labels=False, optimized=False)\n        sn_optimized = SortingNetwork.OptimalSorter(7, width=9, height=4.5, depth_labels=False, optimized=True)\n        sn_optimized_layers = SortingNetwork.OptimalSorter(7, width=9, height=4.5, depth_labels=True, optimized=True)\n        self.play(Write(sn))\n        lines = sn.get_lines()\n        self.play(AnimationGroup(*[Indicate(line) for line in lines], lag_ratio=0.07))\n        comparators = sn.get_comparators()\n        self.play(AnimationGroup(*[Indicate(comparator) for comparator in comparators], lag_ratio=0.07))\n        sn.animate_sort(self)\n        sn.animate_optimization(sn_optimized, self)\n        numbers = sn_optimized_layers.get_layer_numbers()\n        self.play(*[FadeIn(number) for number in numbers])\n        layers = sn_optimized.get_layers()\n        self.play(*[layer.animate.set_color(rainbow_to_rgb(i / len(layers))) for i, layer in enumerate(layers)], *[layer.animate.set_color(rainbow_to_rgb(i / len(layers))) for i, layer in enumerate(numbers)])"}]}
{"messages": [{"role": "user", "content": "Generate a sorting network animation for seven inputs."}, {"role": "assistant", "content": "from utilities import *\n\nclass Introduction(Scene):\n\n    @fade\n    def construct(self):\n        sn = SortingNetwork.OptimalSorter(7, width=9, height=4.5, depth_labels=False, optimized=False)"}]}
{"messages": [{"role": "user", "content": "Visualize the bubble sort algorithm and demonstrate its optimized version."}, {"role": "assistant", "content": "from utilities import *\n\nclass BubbleSort(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Bubble sort')\n        self.play(Write(title))\n        self.play(FadeOut(title))\n        sn = SortingNetwork.BubbleSorter(5, width=7, height=3.5, optimized=False, oriented=True)\n        sn_optimized = SortingNetwork.BubbleSorter(5, width=7, height=3.5, optimized=True)\n        self.play(Write(sn))\n        sn.animate_sort(self, rate_func=smooth, duration=4)\n        sn.animate_optimization(sn_optimized, self)"}]}
{"messages": [{"role": "user", "content": "Display and animate a strictly bitonic function transforming into two non-strictly bitonic functions."}, {"role": "assistant", "content": "from utilities import *\n\nclass Bitonic(Scene):\n\n    def construct(self):\n        title = Tex('\\\\Large Bitonic sort')\n        self.play(Write(title))\n        self.play(FadeOut(title))\n\n    def construct(self):\n        f = lambda x: -abs(x - 2) - abs(-2 * (x - 2) - 5) + 5\n        r = (-2, 1.999)\n        seq_left = FunctionGraph(f, x_range=r, fill_opacity=0, color=WHITE)\n        self.play(Write(seq_left))\n        text = Tex('strictly bitonic')\n        text.next_to(seq_left, DOWN).shift(DOWN * 0.2)\n        self.play(Write(text), run_time=1)\n        text2 = Tex('bitonic')\n        text2.next_to(seq_left, DOWN).shift(DOWN * 0.2)\n        seq_right = FunctionGraph(f, x_range=r, fill_opacity=0, color=WHITE)\n        seq_right.shift(RIGHT * 2)\n        seq_right.set_color(DARK_GRAY)\n        self.play(seq_left.animate.shift(LEFT * 2))\n        self.play(Write(seq_right), FadeOut(text), FadeIn(text2))\n        seq_left_changing = FunctionGraph(f, x_range=r, fill_opacity=0, color=WHITE)\n        seq_left_changing.shift(LEFT * 2)\n        self.add(seq_left_changing)\n        seq_right_changing = FunctionGraph(f, x_range=r, fill_opacity=0, color=WHITE)\n        seq_right_changing.shift(RIGHT * 2)\n        self.add(seq_right_changing)\n        seq_left.set_color(DARK_GRAY)\n\n        def tmp(x, y):\n            if x > y:\n                return (0, 0)\n            else:\n                return (x, y)\n\n        def fc(obj, t):\n            ff = FunctionGraph(f, x_range=tmp(-2 + t * 4, 1.999), fill_opacity=0, color=WHITE)\n            ff.shift(LEFT * 2)\n            obj.become(ff)\n\n        def gc(obj, t):\n            ff = FunctionGraph(f, x_range=tmp(-2, 1.999 - (1 - t) * 4), fill_opacity=0, color=WHITE)\n            ff.shift(RIGHT * 2)\n            obj.become(ff)\n        self.play(UpdateFromAlphaFunc(seq_left_changing, fc), UpdateFromAlphaFunc(seq_right_changing, gc), run_time=2)"}]}
{"messages": [{"role": "user", "content": "Write the words \"Voronoi Diagrams\" and then fade them out."}, {"role": "assistant", "content": "from utilities import *\n\nclass Intro(Scene):\n\n    def construct(self):\n        text = Tex('\\\\Huge Voronoi Diagrams')\n        self.play(Write(text))\n        self.play(FadeOut(text))"}]}
{"messages": [{"role": "user", "content": "Create a Manim scene that writes text, fades it out, generates Voronoi dots based on a file, and then animates their colors."}, {"role": "assistant", "content": "from utilities import *\n\nclass Simple(Scene):\n\n    def construct(self):\n        text = Tex('\\\\Large Creating a Voronoi diagram')\n        self.play(Write(text))\n        self.play(FadeOut(text))\n        min_x, min_y, max_x, max_y, w, h = get_corner_points(self)\n        dots, colors = get_voronoi_dots('ignored/intro-1.out')\n        dots = [Dot([(x - 0.5) * w, (y - 0.5) * h, 0]) for x, y in dots]\n        self.play(LaggedStart(*map(FadeIn, dots)))\n        visuallyChangeColor(self, [(dot, color) for dot, color in zip(dots, colors)])"}]}
{"messages": [{"role": "user", "content": "Visually distribute points evenly across the screen with a demonstration of the selection process and then color-code the points."}, {"role": "assistant", "content": "from utilities import *\n\nclass Points(Scene):\n\n    def construct(self):\n        text = Tex('\\\\Large Distributing points evenly')\n        self.play(Write(text))\n        self.play(FadeOut(text))\n        min_x, min_y, max_x, max_y, w, h = get_corner_points(self)\n        seed(2)\n        n = 20\n\n        def my_uniform(min_x, min_y, max_x, max_y, regions: int):\n            k = 10\n            points = []\n            dot_points = []\n            while len(points) != regions:\n                best_p = None\n                d_max = 0\n                sample_points = []\n                for _ in range(k * len(points) + 1):\n                    p = (uniform(min_x, max_x), uniform(min_y, max_y))\n                    if len(points) == 0:\n                        best_p = p\n                        break\n                    sample_points.append(Dot([*p, 0], color='#373737'))\n                    d_min = float('inf')\n                    for x, y in points:\n                        d = hypot(p[0] - x, p[1] - y)\n                        if d < d_min:\n                            d_min = d\n                    if d_min > d_max:\n                        d_max = d_min\n                        best_p = p\n                if best_p is None:\n                    continue\n                self.play(LaggedStart(*map(FadeIn, sample_points)), run_time=1)\n                best_p_dot = Dot([*best_p, 0], color=WHITE)\n                self.play(*map(FadeOut, sample_points), FadeIn(best_p_dot), Flash(best_p_dot))\n                points.append(best_p)\n                dot_points.append(best_p_dot)\n                if len(points) == 1:\n\n                    def tmp(mob, dt):\n                        self.add(*dot_points)\n                    dot_points[0].add_updater(tmp)\n            dot_points[0].remove_updater(tmp)\n            return dot_points\n        margin = 0.95\n        dots = my_uniform(min_x * margin, min_y * margin, max_x * margin, max_y * margin, n)\n        print([dot.get_center() for dot in dots])\n        colors = [(145, 219, 87), (87, 211, 219), (87, 211, 219), (87, 211, 219), (161, 87, 219), (161, 87, 219), (87, 112, 219), (87, 112, 219), (87, 211, 219), (145, 219, 87)]\n        colors = [(color[0] / 256, color[1] / 256, color[2] / 256) for color in colors]\n        self.play(*[dot.animate.set_fill(rgb_to_hex(color)) for dot, color in zip(dots, colors)])"}]}
{"messages": [{"role": "user", "content": "Demonstrate the Euclidean and Manhattan distance metrics by animating two points and updating distance calculations in real-time."}, {"role": "assistant", "content": "from utilities import *\n\nclass Metric(Scene):\n\n    def construct(self):\n        text = Tex('\\\\Large Chosing a different metric')\n        self.play(Write(text))\n        self.play(FadeOut(text))\n        dot1start = Dot()\n        dot1end = Dot()\n\n        def euclid(text):\n            text.next_to(dot1start.get_center(), UP * 8)\n        formula = Tex('$\\\\sqrt{x^2 + y^2}$')\n        formulaname = Tex('Euclidean')\n        formulaname.next_to(dot1start.get_center(), UP * 8)\n        self.play(Write(formula), Write(formulaname))\n        formulaname.add_updater(euclid)\n        line = Line(ORIGIN, ORIGIN)\n        formula_value = Tex('$0.00$')\n        formula_value.next_to(ORIGIN, UP)\n        self.play(Create(dot1end), Transform(formula, formula_value))\n        self.add(line)\n        self.add(dot1start)\n        self.add(dot1end)\n\n        def tmp(mob):\n            line.become(Line(dot1start.get_center(), dot1end.get_center()))\n\n        def text_update(text):\n            x, y, _ = dot1end.get_center() - dot1start.get_center()\n            xr, yr = (round(x, 2), round(y, 2))\n            txt = f'${round(sqrt(x * x + y * y), 2):.2f}$'\n            text.become(Tex(txt))\n            text.next_to(dot1end.get_center(), UP)\n        line.add_updater(tmp)\n        formula.add_updater(text_update)\n        self.play(ApplyMethod(dot1end.shift, RIGHT * 2), run_time=1, rate_func=smooth)\n        self.play(ApplyMethod(dot1end.shift, LEFT + UP), run_time=1, rate_func=smooth)\n        self.play(ApplyMethod(dot1end.shift, DOWN + LEFT * 4), run_time=1, rate_func=smooth)\n        self.play(Rotating(dot1end, about_point=dot1start.get_center()), run_time=2, rate_func=smooth)\n        self.play(ApplyMethod(dot1end.shift, RIGHT * 3), run_time=1, rate_func=smooth)\n        l1 = Line(ORIGIN, ORIGIN)\n        l2 = Line(ORIGIN, ORIGIN)\n        dot2start = Dot()\n        dot2end = Dot()\n\n        def tmp1(mob):\n            l1.become(Line(dot2start.get_center(), [dot2end.get_center()[0], 0, 0]))\n\n        def tmp2(mob):\n            l2.become(Line([dot2end.get_center()[0], 0, 0], [dot2end.get_center()[0], dot2end.get_center()[1], 0]))\n\n        def text_update2(text):\n            x, y, _ = dot2end.get_center() - dot2start.get_center()\n            txt = f'${round(abs(x) + abs(y), 2):.2f}$'\n            text.become(Tex(txt))\n            text.next_to(dot2end.get_center(), UP)\n        self.play(ApplyMethod(dot1start.shift, LEFT * 3), ApplyMethod(dot1end.shift, LEFT * 3), run_time=1, rate_func=smooth)\n        dot2start.shift(RIGHT * 3)\n        dot2end.shift(RIGHT * 3)\n        formula2 = Tex('$|x| + |y|$')\n        formula2.move_to(dot2start.get_center())\n        formula2_value = Tex('$0.00$')\n        formula2_value.next_to(dot2start.get_center(), UP)\n        l1.add_updater(tmp1)\n        l2.add_updater(tmp2)\n        self.add(l1)\n        self.add(l2)\n\n        def manhattan(text):\n            text.next_to(dot2start.get_center(), UP * 8)\n        formula2name = Tex('Manhattan')\n        formula2name.next_to(dot2start.get_center(), UP * 8)\n        self.play(Write(formula2), Write(formula2name))\n        formula2name.add_updater(manhattan)\n        self.play(Create(dot2end), Transform(formula2, formula2_value))\n        formula2.add_updater(text_update2)\n        self.add(dot2start)\n        self.add(dot2end)\n        self.play(ApplyMethod(dot1end.shift, RIGHT * 2), ApplyMethod(dot2end.shift, RIGHT * 2), run_time=1, rate_func=smooth)\n        self.play(ApplyMethod(dot1end.shift, LEFT + UP), ApplyMethod(dot2end.shift, LEFT + UP), run_time=1, rate_func=smooth)\n        self.play(ApplyMethod(dot1end.shift, DOWN + LEFT * 2), ApplyMethod(dot2end.shift, DOWN + LEFT * 2), run_time=1, rate_func=smooth)\n        self.play(Rotating(dot1end, about_point=dot1start.get_center()), Rotating(dot2end, about_point=dot2start.get_center()), run_time=2, rate_func=smooth)\n        self.play(ApplyMethod(dot1end.shift, RIGHT * 1), ApplyMethod(dot2end.shift, RIGHT * 1), run_time=1, rate_func=smooth)"}]}
{"messages": [{"role": "user", "content": "Display a graph with colored vertices, transitioning from a plain graph to one where vertices are colored according to a specified list, and then fade in an image."}, {"role": "assistant", "content": "from utilities import *\n\nclass Color(Scene):\n\n    def construct(self):\n        text = Tex('\\\\Large Assigning colors')\n        self.play(Write(text))\n        self.play(FadeOut(text))\n        dots = list(map(Dot, [[-0.22223248, -2.2748981, 0.0], [5.02542935, 3.19432106, 0.0], [-5.59603133, 3.22596847, 0.0], [5.55709686, -2.98486069, 0.0], [-0.3587377, 3.3184144, 0.0], [-5.92227625, -3.12034469, 0.0], [2.31565885, 0.53980622, 0.0], [-2.78178311, -0.0077623, 0.0], [2.69523115, -3.54040193, 0.0], [-6.17100105, 0.11923881, 0.0]]))\n        colors = [(145, 219, 87), (87, 211, 219), (87, 211, 219), (161, 87, 219), (161, 87, 219), (87, 211, 219), (87, 112, 219), (87, 112, 219), (87, 211, 219), (145, 219, 87)]\n        colors = [(color[0] / 256, color[1] / 256, color[2] / 256) for color in colors]\n        for dot, color in zip(dots, colors):\n            dot.set_fill(rgb_to_hex(color))\n        imgblank = ImageMobject('2blank.png')\n        img = ImageMobject('2.png')\n        self.play(FadeIn(imgblank))\n        v = [i + 1 for i, dot in enumerate(dots)]\n        lt = {i + 1: dots[i].get_center() for i, dot in enumerate(dots)}\n        edges = [(v[0], v[6]), (v[0], v[7]), (v[0], v[8]), (v[1], v[4]), (v[1], v[6]), (v[1], v[3]), (v[2], v[4]), (v[2], v[9]), (v[2], v[7]), (v[3], v[8]), (v[3], v[6]), (v[4], v[7]), (v[4], v[6]), (v[5], v[7]), (v[5], v[9]), (v[6], v[8]), (v[7], v[9])]\n        g = Graph(v, edges, labels=True, layout=lt)\n        h = Graph(v, edges, labels=True, layout=lt, vertex_config={i + 1: {'fill_color': rgb_to_hex(color)} for i, color in enumerate(colors)})\n        self.play(Write(g))\n        self.play(Transform(g, h))\n        self.add(img)\n        self.bring_to_back(img)\n        self.remove(img)\n        self.play(FadeIn(img))"}]}
{"messages": [{"role": "user", "content": "Display four images in a grid formation and then fade them all out."}, {"role": "assistant", "content": "from utilities import *\n\nclass Applications(Scene):\n\n    def construct(self):\n        min_x, min_y, max_x, max_y, w, h = get_corner_points(self)\n        images = [ImageMobject('ignored/images/dragonfly-resized.png'), ImageMobject('ignored/images/giraffe-resized.png'), ImageMobject('ignored/images/mud-resized.png'), ImageMobject('ignored/images/soap-resized.png')]\n        for image in images:\n            image.width = w / 3\n            image.height = h / 3\n        self.play(FadeIn(images[0].shift(LEFT * 3 + UP * 2)))\n        self.play(FadeIn(images[1].shift(RIGHT * 3 + UP * 2)))\n        self.play(FadeIn(images[2].shift(LEFT * 3 + DOWN * 2)))\n        self.play(FadeIn(images[3].shift(RIGHT * 3 + DOWN * 2)))\n        fade_all(self)"}]}
{"messages": [{"role": "user", "content": "Animate three circular graphs of decreasing size, highlighting different spanning trees within each graph sequentially."}, {"role": "assistant", "content": "from utilities import *\n\nclass Motivation(Scene):\n\n    @fade\n    def construct(self):\n        n_max = 8\n        g = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.7).scale(GRAPH_SCALE)\n        g_background = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.7).scale(GRAPH_SCALE)\n        n_max = 7\n        g2 = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.5).scale(GRAPH_SCALE)\n        g2_background = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.5).scale(GRAPH_SCALE)\n        n_max = 5\n        g3 = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.3).scale(GRAPH_SCALE)\n        g3_background = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.3).scale(GRAPH_SCALE)\n        for e in g_background.edges:\n            g_background.edges[e].set_color(HIDDEN_COLOR)\n        for v in g_background.vertices:\n            g_background.vertices[v].set_color(HIDDEN_COLOR)\n        for e in g2_background.edges:\n            g2_background.edges[e].set_color(HIDDEN_COLOR)\n        for v in g2_background.vertices:\n            g2_background.vertices[v].set_color(HIDDEN_COLOR)\n        for e in g3_background.edges:\n            g3_background.edges[e].set_color(HIDDEN_COLOR)\n        for v in g3_background.vertices:\n            g3_background.vertices[v].set_color(HIDDEN_COLOR)\n        g.shift(LEFT * 2.5)\n        g_background.shift(LEFT * 2.5)\n        g2.shift(RIGHT * 2.7 + UP * 1.5)\n        g2_background.shift(RIGHT * 2.7 + UP * 1.5)\n        g3.shift(RIGHT * 2.7 + DOWN * 2)\n        g3_background.shift(RIGHT * 2.7 + DOWN * 2)\n        self.play(Write(g), Write(g2), Write(g3))\n        self.add(g_background)\n        self.add(g)\n        self.add(g2_background)\n        self.add(g2)\n        self.add(g3_background)\n        self.add(g3)\n        seed(2)\n        st1 = list(yield_spanning_trees(g.vertices, g.edges))\n        st2 = list(yield_spanning_trees(g2.vertices, g.edges))\n        st3 = list(yield_spanning_trees(g3.vertices, g.edges))\n        shuffle(st1)\n        shuffle(st2)\n        shuffle(st3)\n        for s1, s2, s3 in list(zip(st1, st2, st3))[:10]:\n            self.play(*[g.edges[e].animate.set_opacity(0) for e in g.edges if e not in s1], *[g.edges[e].animate.set_opacity(1) for e in s1], *[g2.edges[e].animate.set_opacity(0) for e in g2.edges if e not in s2], *[g2.edges[e].animate.set_opacity(1) for e in s2], *[g3.edges[e].animate.set_opacity(0) for e in g3.edges if e not in s3], *[g3.edges[e].animate.set_opacity(1) for e in s3])"}]}
{"messages": [{"role": "user", "content": "Display a sequence of expanding graphs while animating their vertex positions and finally highlight three random spanning trees of the largest graph."}, {"role": "assistant", "content": "from utilities import *\n\nclass Definitions(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Definitions')\n        self.play(Write(title))\n        self.play(FadeOut(title))\n        n_min = 4\n        n_max = 7 + 1\n        layout_graphs = [Graph([i for i in range(n)], [(i, j) for i in range(n) for j in range(n) if i < j], layout='circular', layout_scale=0.7).scale(GRAPH_SCALE) for n in range(n_min, n_max)]\n        layout_graph_texts = [Tex(f'$K_{n}$').next_to(layout_graphs[n - n_min].vertices[1], RIGHT).shift(RIGHT * (3 / n)).scale(1.3) for n in range(n_min, n_max)]\n        g = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j]).scale(GRAPH_SCALE)\n        layout_graph = layout_graphs[0]\n        for i, v in enumerate(g.vertices):\n            rand = random() / 10000 + 1\n            new_pos = layout_graph.vertices[min(i, len(layout_graph.vertices) - 1)].get_center() * rand\n            g.vertices[i].move_to(new_pos)\n        self.play(Write(g), Write(layout_graph_texts[0]))\n        for i in range(len(layout_graphs) - 1):\n            i += 1\n            layout_graph = layout_graphs[i]\n            new_positions = []\n            for j, v in enumerate(g.vertices):\n                rand = random() / 10000 + 1\n                new_pos = layout_graph.vertices[min(j, len(layout_graph.vertices) - 1)].get_center() * rand\n                new_positions.append(new_pos)\n            self.play(*[g.vertices[v].animate.move_to(new_positions[v]) for v in g.vertices], Transform(layout_graph_texts[0], layout_graph_texts[i]))\n        for e in layout_graphs[-1].edges:\n            layout_graphs[-1].edges[e].set_color(HIDDEN_COLOR)\n        for v in layout_graphs[-1].vertices:\n            layout_graphs[-1].vertices[v].set_color(HIDDEN_COLOR)\n        self.add(layout_graphs[-1])\n        self.add(g)\n        seed(0)\n        st = list(yield_spanning_trees(g.vertices, g.edges))\n        shuffle(st)\n        i = 0\n        for spanning_tree in st:\n            if i == 3:\n                break\n            self.play(*[g.edges[e].animate.set_opacity(0) for e in g.edges if e not in spanning_tree], *[g.edges[e].animate.set_opacity(1) for e in spanning_tree])\n            i += 1"}]}
{"messages": [{"role": "user", "content": "Show Cayley's Formula with a title, explanatory text, and three disconnected graphs illustrating the formula for a complete graph with 3 vertices."}, {"role": "assistant", "content": "from utilities import *\n\nclass Formula(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex(\"\\\\Large Cayley's Formula\")\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 1.2))\n        text = Tex('\\\\parbox{23em}{The number of ', 'spanning trees', ' of a ', 'complete graph', ' on ', '$n$', ' vertices is ', '$\\\\kappa(n) = n^{n-2}$', '.}')\n        highlightText(text)\n        text.next_to(title, DOWN * 2)\n        self.play(Write(text))\n        self.play(title.animate.shift(UP * 1.3), text.animate.shift(UP * 1.3))\n        a = Graph([0, 1, 2], [(0, 1), (1, 2)], layout='circular', layout_scale=0.35).scale(GRAPH_SCALE).shift(DOWN * 1.6).shift(LEFT * 4)\n        b = Graph([0, 1, 2], [(1, 2), (2, 0)], layout='circular', layout_scale=0.35).scale(GRAPH_SCALE).shift(DOWN * 1.6)\n        c = Graph([0, 1, 2], [(2, 0), (0, 1)], layout='circular', layout_scale=0.35).scale(GRAPH_SCALE).shift(DOWN * 1.6).shift(RIGHT * 4)\n        ne1 = Tex('\\\\large$\\\\ne$').move_to((a.get_center() + b.get_center()) / 2)\n        ne2 = Tex('\\\\large$\\\\ne$').move_to((b.get_center() + c.get_center()) / 2)\n        self.play(Write(a), Write(b), Write(c))\n        self.play(Write(ne1), Write(ne2))"}]}
{"messages": [{"role": "user", "content": "Animate a proof of a combinatorial identity involving labeled trees, starting with a title, explaining the concept of double counting with text and graphs, and then deriving the formula using transformations and various mathematical expressions."}, {"role": "assistant", "content": "from utilities import *\n\nclass Proof(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Double counting')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 1.2))\n        text = Tex('\\\\parbox{23em}{The number of ', 'oriented trees', ' on ', '$n$', ' vertices that have a ', 'root', ' and some ', 'numbering of edges', ' (denoted ', '$\\\\tau(n)$', ').}')\n        highlightText(text)\n        text.next_to(title, DOWN * 2)\n        self.play(Write(text), run_time=4)\n        self.play(FadeOut(title))\n        self.play(text.animate.align_on_border(UP))\n        l = Line(LEFT * 8, RIGHT * 8).next_to(text, DOWN).shift(DOWN * 0.15)\n        self.play(Write(l))\n        DOWN_C = 1.03\n        n = 6\n        g1 = Graph([i for i in range(n)], [(i, j) for i in range(n) for j in range(n) if i < j], layout='circular', layout_scale=0.6).scale(GRAPH_SCALE).shift(DOWN * DOWN_C + RIGHT * 2.9)\n        n = 7\n        g2 = Graph([i for i in range(n)], [(i, j) for i in range(n) for j in range(n) if i < j], layout='circular', layout_scale=0.6).scale(GRAPH_SCALE).shift(DOWN * DOWN_C + LEFT * 2.9)\n        seed(5)\n        strip_graph(g1, get_random_spanning_tree(g1.vertices, g1.edges))\n        orient_from_root(g1, 2)\n        add_edge_numbering(g1)\n        seed(13)\n        strip_graph(g2, get_random_spanning_tree(g2.vertices, g2.edges))\n        orient_from_root(g2, 5)\n        add_edge_numbering(g2)\n        self.play(Write(g1), Write(g2))\n        self.play(FadeOut(g1), FadeOut(g2))\n        OFFSET = LEFT * 2.9\n        OFFSET2 = RIGHT\n        text_1 = Tex('$\\\\tau(n)$').shift(DOWN * DOWN_C + OFFSET2)\n        text_2 = Tex('$= \\\\kappa(n)$').next_to(text_1, RIGHT)\n        text_3d = Tex('$\\\\cdot$').next_to(text_2, RIGHT)\n        text_3 = Tex('$n$').next_to(text_3d, RIGHT)\n        text_4d = Tex('$\\\\cdot$').next_to(text_3, RIGHT)\n        text_4 = Tex('$(n-1)!$').next_to(text_4d, RIGHT)\n        n = 6\n        g3 = Graph([i for i in range(n)], [(i, j) for i in range(n) for j in range(n) if i < j], layout='circular', layout_scale=0.6).scale(GRAPH_SCALE).shift(DOWN * DOWN_C + OFFSET)\n        g_under = Graph([i for i in range(n)], [(i, j) for i in range(n) for j in range(n) if i < j], layout='circular', layout_scale=0.6).scale(GRAPH_SCALE).shift(DOWN * DOWN_C + OFFSET)\n        for e in g_under.edges:\n            g_under.edges[e].set_color(HIDDEN_COLOR)\n        for v in g_under.vertices:\n            g_under.vertices[v].set_color(HIDDEN_COLOR)\n        seed(31)\n        previous_edges = g3.edges\n        edges = get_random_spanning_tree(g3.vertices, g3.edges)\n        prev_edges = g3.edges\n        self.play(Write(g3), Write(text_1))\n        self.add(g_under)\n        self.add(g3)\n        seed(43)\n        m = 3\n        for i in range(m):\n            if i == m - 1:\n                edges = [(0, 1), (0, 5), (1, 4), (3, 4), (2, 3)]\n                edges = [(a, b) if (a, b) in g3.edges else (b, a) for a, b in edges]\n            else:\n                edges = get_random_spanning_tree(g3.vertices, g3.edges)\n            self.play(*[g3.edges[e].animate.set_opacity(1) for e in edges if e not in prev_edges], *[g3.edges[e].animate.set_opacity(0) for e in prev_edges if e not in edges])\n            prev_edges = edges\n        strip_graph(g3, edges)\n        self.play(Write(text_2))\n        self.play(FadeOut(g_under))\n        g_prev = None\n        prev_edges = []\n        for root in range(n):\n            g_curr = Graph([i for i in range(n)], [(i, j) for i in range(n) for j in range(n) if i < j], layout='circular', layout_scale=0.6).scale(GRAPH_SCALE).shift(DOWN * DOWN_C + OFFSET)\n            strip_graph(g_curr, edges)\n            eee = orient_from_root(g_curr, root, no_set_color=True)\n\n            def unfuk(v, w, g):\n                return g.edges[(v, w) if (v, w) in g.edges else (w, v)]\n            self.remove(g_prev)\n            self.add(g_curr)\n            self.play(*[FadeIn(unfuk(*e, g_curr)) for e in eee if e not in prev_edges], *[FadeOut(unfuk(*e, g_prev)) for e in prev_edges if e not in eee], *([] if g_prev is None else [g_prev.vertices[root - 1].animate.set_color(WHITE)]), g_curr.vertices[root].animate.set_color(HIGHLIGHT_COLOR), run_time=0.7)\n            if g_prev is not None:\n                self.remove(g_prev.vertices[root - 1])\n            prev_edges = eee\n            g_prev = g_curr\n        prev_numbers = add_edge_numbering(g_curr, return_only=True)\n        self.play(Write(text_3), Write(text_3d))\n        self.play(*[Write(n) for n in prev_numbers])\n        count = len(list(permutations([i for i in range(len(g_curr.edges))])))\n        for i, p in enumerate(permutations([i for i in range(len(g_curr.edges))])):\n            start = [0.5, 0.5, 0.4, 0.3, 0.15, 0.08]\n            waits = start + [0.008] * count * 2\n            numbers = add_edge_numbering(g_curr, numbers=p, return_only=True)\n            self.play(*[Transform(a, b) for a, b in zip(prev_numbers, numbers)], run_time=waits[i])\n        self.play(Write(text_4), Write(text_4d))\n        delta = UP * 2.4 + LEFT * 0.9\n        self.play(*[FadeOut(n) for n in prev_numbers], FadeOut(g_curr), FadeOut(g3), FadeOut(text_1), FadeOut(text_2), FadeOut(text_3), FadeOut(text_3d), FadeOut(text_4), FadeOut(text_4d))\n        n = 6\n        g4 = Graph([i for i in range(n)], [], layout='circular', layout_scale=0.6).scale(GRAPH_SCALE).shift(DOWN * DOWN_C)\n        for v in g4.vertices:\n            g4.vertices[v].set_color(HIGHLIGHT_COLOR)\n        self.play(Write(g4))\n        edges = []\n        numbers = []\n        operation_list = [(0, 1, True), (4, 3, False), (3, 5, False)]\n\n        def _add_edge(v, w, s, i=[0]):\n            edges.append(create_oriented_edge(g4, v, w))\n            numbers.append(create_edge_number(g4, v, w, i[-1], side=s))\n            i[-1] += 1\n            self.play(Write(edges[-1]), Write(numbers[-1]), g4.vertices[v].animate.set_color(WHITE))\n        _add_edge(*operation_list[0])\n        _add_edge(*operation_list[1])\n        _add_edge(*operation_list[2])\n        OFFSET += LEFT * 0.7\n        self.play(g4.animate.shift(OFFSET), *[n.animate.shift(OFFSET) for n in numbers], *[e.animate.shift(OFFSET) for e in edges])\n        parts = ['\\\\small $1.\\\\ $must start in a root\\\\\\\\ ' + '\\n', \"\\\\small $2.\\\\ $can't be in a single component\\\\\\\\ \"]\n        l = Tex(*parts)\n        l.arrange(DOWN, aligned_edge=LEFT).shift(RIGHT * 3.0 + DOWN * 1)\n        self.play(Write(l[0]))\n        edge = create_oriented_edge(g4, 3, 1)\n        edge.set_color(RED)\n        self.bring_to_back(edge)\n        self.play(Write(edge))\n        self.play(FadeOut(edge))\n        self.play(Write(l[1]))\n        edge = create_oriented_edge(g4, 5, 4)\n        edge.set_color(RED)\n        self.bring_to_back(edge)\n        self.play(Write(edge), g4.vertices[5].animate.set_color(WHITE))\n        self.play(FadeOut(edge), g4.vertices[5].animate.set_color(HIGHLIGHT_COLOR))\n        kth = Tex('$k = 3$').next_to(g4, UP).shift(DOWN * 0.2)\n        D = 0.4\n        self.play(g4.animate.shift(DOWN * D), *[e.animate.shift(DOWN * D) for e in edges], *[e.animate.shift(DOWN * D) for e in numbers])\n        self.play(Write(kth))\n        self.play(l[0].animate.shift(UP * 1.6), l[1].animate.shift(UP * 1.6))\n        parts2 = ['\\\\small end:\\\\\\\\ ' + '\\n', '\\\\small start:\\\\\\\\ ']\n        parts3 = ['\\\\small $n$\\\\\\\\ ' + '\\n', '\\\\small $n - k - 1$\\\\\\\\ ']\n        l2 = Tex(*parts2)\n        l2.arrange(DOWN, aligned_edge=RIGHT).shift(RIGHT * 1.8 + DOWN * 1.7)\n        l3 = Tex(*parts3)\n        l3.arrange(DOWN, aligned_edge=LEFT).shift(RIGHT * 3.5 + DOWN * 1.7)\n        l3[0].set_color(YELLOW)\n        l3[1].set_color(YELLOW)\n        l3[0].shift(DOWN * 0.07)\n        l3[1].shift(DOWN * 0.07)\n        self.play(Write(l2[0]))\n        self.play(Write(l3[0]))\n        for v in g4.vertices:\n            g4.vertices[v].save_state()\n        self.play(l3[0].animate.set_color(BLUE), *[g4.vertices[v].animate.set_color(BLUE) for v in g4.vertices])\n        sel = 2\n        self.play(*[g4.vertices[v].animate.restore() for v in g4.vertices if v != sel])\n        self.play(Circumscribe(l[0], color=WHITE, run_time=1, stroke_width=3))\n        self.play(Circumscribe(l[1], color=WHITE, run_time=1, stroke_width=3))\n        self.play(Write(l2[1]))\n        self.play(Write(l3[1]))\n        a = create_oriented_edge(g4, 1, sel).set_color(GREEN)\n        an = create_edge_number(g4, 1, sel, 3)\n        b = create_oriented_edge(g4, 5, sel).set_color(GREEN)\n        bn = create_edge_number(g4, 5, sel, 3, side=True)\n        self.play(l3[1].animate.set_color(GREEN), g4.vertices[1].animate.set_color(GREEN), g4.vertices[5].animate.set_color(GREEN))\n        self.play(Write(a), Write(an), run_time=1)\n        self.play(FadeOut(a), FadeOut(an), run_time=1)\n        self.play(Write(b), Write(bn), run_time=1)\n        self.play(FadeOut(b), FadeOut(bn), run_time=1)\n        self.play(FadeOut(l2))\n        lp = Tex('\\\\small$($')\n        rp = Tex('\\\\small$)$')\n        cd = Tex('\\\\small$\\\\cdot$')\n        l3[0].shift(LEFT * 0.75 + DOWN * 0.3)\n        delta = (l3[0].get_center() - l3[1][0].get_center())[1] * UP\n        l3[1].shift(delta)\n        lp.next_to(l3[1], LEFT).shift(RIGHT * 0.2)\n        rp.next_to(l3[1], RIGHT).shift(LEFT * 0.2)\n        cd.next_to(l3[0], RIGHT).shift(LEFT * 0.1)\n        l3[1].shift(-delta)\n        l3[0].shift(RIGHT * 0.75 + UP * 0.3)\n\n        def shiftchangecolor(mob, color, delta):\n            mob.set_color(WHITE)\n            mob.shift(delta)\n            return mob\n        self.play(LaggedStart(AnimationGroup(ApplyFunction(lambda x: shiftchangecolor(x, WHITE, LEFT * 0.75 + DOWN * 0.3), l3[0]), ApplyFunction(lambda x: shiftchangecolor(x, WHITE, delta), l3[1])), AnimationGroup(Write(lp), Write(rp), Write(cd)), lag_ratio=0.7))\n        p = Tex('$$\\\\prod_{k=0}^{n-2}$$')\n        p.next_to(l3[0], LEFT).shift(UP * 0.08 + RIGHT * 0.13)\n        self.play(Write(p))\n        nto = Tex('\\\\small $n^{n - 1}$')\n        nto.move_to(-nto[0].get_center() + l3[0][0].get_center()).shift(LEFT * 0.9).shift(UP * 0.12)\n        self.play(LaggedStart(AnimationGroup(p.animate.shift(RIGHT * 0.65), FadeOut(cd), Transform(l3[0], nto))))\n        fac = Tex('\\\\small $(n - 1)!$')\n        fac.move_to(p).shift(RIGHT * 0.5 + DOWN * 0.072)\n        medfac = Tex('\\\\small $(n - 1) \\\\cdot \\\\ldots \\\\cdot 1$')\n        medfac.move_to(fac).align_to(fac, LEFT)\n        combine = VMobject()\n        combine.add(p)\n        combine.add(l3[1])\n        combine.add(lp)\n        combine.add(rp)\n        self.play(Transform(combine, medfac))\n        self.play(Transform(combine, fac))\n        combine2 = VMobject()\n        combine2.add(combine)\n        combine2.add(nto)\n        eq = Tex('\\\\small $=$').shift(DOWN * 0.8)\n        self.remove(nto)\n        self.remove(l3[0])\n        text_2 = Tex('$\\\\kappa(n)$')\n        text_3d = Tex('$\\\\cdot$').next_to(text_2, RIGHT)\n        text_3 = Tex('$n$').next_to(text_3d, RIGHT)\n        text_4d = Tex('$\\\\cdot$').next_to(text_3, RIGHT)\n        text_4 = Tex('$(n-1)!$').next_to(text_4d, RIGHT)\n        left = VMobject()\n        left.add(text_2)\n        left.add(text_3d)\n        left.add(text_3)\n        left.add(text_4d)\n        left.add(text_4)\n        left.next_to(eq, LEFT)\n        self.play(LaggedStart(AnimationGroup(FadeOut(l), FadeOut(kth), *[FadeOut(e) for e in edges], *[FadeOut(e) for e in numbers], FadeOut(g4)), AnimationGroup(combine2.animate.next_to(eq, RIGHT)), AnimationGroup(Write(left)), AnimationGroup(Write(eq)), lag_ratio=0.4))\n        self.play(LaggedStart(AnimationGroup(FadeOut(combine), FadeOut(text_4d), FadeOut(text_4)), AnimationGroup(text_2.animate.shift(RIGHT * 2.13), text_3d.animate.shift(RIGHT * 2.13), text_3.animate.shift(RIGHT * 2.13)), lag_ratio=0.3))\n        two = Tex('\\\\small $^2$')\n        two.move_to(nto[0][3])\n        self.play(LaggedStart(AnimationGroup(Transform(nto[0][3], two), FadeOut(text_3d), FadeOut(text_3)), AnimationGroup(text_2.animate.shift(RIGHT * 0.83)), lag_ratio=0.3))\n        o = Mobject()\n        o.add(text_2)\n        o.add(nto)\n        self.play(Circumscribe(o, color=WHITE, run_time=1, stroke_width=3))"}]}
{"messages": [{"role": "user", "content": "Visualize a circular graph and then animate the selection of a sequence of spanning trees by highlighting and fading edges."}, {"role": "assistant", "content": "from utilities import *\n\nclass Outro(Scene):\n\n    @fade\n    def construct(self):\n        n_max = 9\n        g = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.7).scale(GRAPH_SCALE)\n        g_background = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.7).scale(GRAPH_SCALE)\n        for e in g_background.edges:\n            g_background.edges[e].set_color(HIDDEN_COLOR)\n        for v in g_background.vertices:\n            g_background.vertices[v].set_color(HIDDEN_COLOR)\n        self.play(Write(g))\n        self.add(g_background)\n        self.add(g)\n        seed(2)\n        st1 = list(yield_spanning_trees(g.vertices, g.edges))\n        shuffle(st1)\n        for s1 in st1[:12]:\n            self.play(*[g.edges[e].animate.set_opacity(0) for e in g.edges if e not in s1], *[g.edges[e].animate.set_opacity(1) for e in s1])"}]}
{"messages": [{"role": "user", "content": "Display three circular graphs of different sizes, then animate their edges to highlight spanning trees, and finally display Cayley's formula above the graphs."}, {"role": "assistant", "content": "from utilities import *\n\nclass Thumbnail(MovingCameraScene):\n\n    def construct(self):\n        self.next_section(skip_animations=True)\n        n_max = 8\n        eeee = 1.2\n        g = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.7 * eeee).scale(GRAPH_SCALE / eeee)\n        g_background = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.7 * eeee).scale(GRAPH_SCALE / eeee)\n        n_max = 7\n        eeee = 2\n        g2 = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.4 * eeee).scale(GRAPH_SCALE / eeee)\n        g2_background = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.4 * eeee).scale(GRAPH_SCALE / eeee)\n        n_max = 5\n        g3 = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.25 * eeee).scale(GRAPH_SCALE / eeee).rotate(PI / 4)\n        g3_background = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.25 * eeee).scale(GRAPH_SCALE / eeee).rotate(PI / 4)\n        for e in g_background.edges:\n            g_background.edges[e].set_color(HIDDEN_COLOR_2)\n        for v in g_background.vertices:\n            g_background.vertices[v].set_color(HIDDEN_COLOR_2)\n        for e in g2_background.edges:\n            g2_background.edges[e].set_color(HIDDEN_COLOR_2)\n        for v in g2_background.vertices:\n            g2_background.vertices[v].set_color(HIDDEN_COLOR_2)\n        for e in g3_background.edges:\n            g3_background.edges[e].set_color(HIDDEN_COLOR_2)\n        for v in g3_background.vertices:\n            g3_background.vertices[v].set_color(HIDDEN_COLOR_2)\n        g.shift(LEFT * 2.5)\n        g_background.shift(LEFT * 2.5)\n        g2.shift(RIGHT * 2.7 + UP * 1.5)\n        g2_background.shift(RIGHT * 2.7 + UP * 1.5)\n        g3.shift(RIGHT * 2.7 + DOWN * 2)\n        g3_background.shift(RIGHT * 2.7 + DOWN * 2)\n        g2.align_to(g, UP)\n        g2_background.align_to(g, UP)\n        g3.align_to(g, DOWN)\n        g3_background.align_to(g, DOWN)\n        self.play(Write(g), Write(g2), Write(g3))\n        self.add(g_background)\n        self.add(g)\n        self.add(g2_background)\n        self.add(g2)\n        self.add(g3_background)\n        self.add(g3)\n        seed(2)\n        st1 = list(yield_spanning_trees(g.vertices, g.edges))\n        st2 = list(yield_spanning_trees(g2.vertices, g.edges))\n        st3 = list(yield_spanning_trees(g3.vertices, g.edges))\n        shuffle(st1)\n        shuffle(st2)\n        shuffle(st3)\n        for s1, s2, s3 in list(zip(st1, st2, st3))[:10]:\n            self.play(*[g.edges[e].animate.set_opacity(0) for e in g.edges if e not in s1], *[g.edges[e].animate.set_opacity(1) for e in s1], *[g2.edges[e].animate.set_opacity(0) for e in g2.edges if e not in s2], *[g2.edges[e].animate.set_opacity(1) for e in s2], *[g3.edges[e].animate.set_opacity(0) for e in g3.edges if e not in s3], *[g3.edges[e].animate.set_opacity(1) for e in s3])\n        self.next_section()\n        gr = Group(g_background, g, g2_background, g2, g3_background, g3).scale(0.7)\n        a = Tex(\"Cayley's Formula\").scale(2).next_to(gr, UP, buff=0.8)\n        self.add(a)\n        fg = Group(a, gr)\n        self.camera.frame.move_to(fg).set_height(fg.get_height() * 1.4)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate an animation that visually demonstrates Cayley's formula by animating spanning trees on three distinct circular graphs."}, {"role": "assistant", "content": "from utilities import *\n\nclass TransparentThumbnail(MovingCameraScene):\n\n    def construct(self):\n        self.next_section(skip_animations=True)\n        n_max = 8\n        eeee = 1.2\n        g = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.7 * eeee).scale(GRAPH_SCALE / eeee)\n        g_background = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.7 * eeee).scale(GRAPH_SCALE / eeee)\n        n_max = 7\n        eeee = 2\n        g2 = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.4 * eeee).scale(GRAPH_SCALE / eeee)\n        g2_background = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.4 * eeee).scale(GRAPH_SCALE / eeee)\n        n_max = 5\n        g3 = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.25 * eeee).scale(GRAPH_SCALE / eeee).rotate(PI / 4)\n        g3_background = Graph([i for i in range(n_max - 1)], [(i, j) for i in range(n_max - 1) for j in range(n_max - 1) if i < j], layout='circular', layout_scale=0.25 * eeee).scale(GRAPH_SCALE / eeee).rotate(PI / 4)\n        for e in g_background.edges:\n            g_background.edges[e].set_color(HIDDEN_COLOR_2)\n        for v in g_background.vertices:\n            g_background.vertices[v].set_color(HIDDEN_COLOR_2)\n        for e in g2_background.edges:\n            g2_background.edges[e].set_color(HIDDEN_COLOR_2)\n        for v in g2_background.vertices:\n            g2_background.vertices[v].set_color(HIDDEN_COLOR_2)\n        for e in g3_background.edges:\n            g3_background.edges[e].set_color(HIDDEN_COLOR_2)\n        for v in g3_background.vertices:\n            g3_background.vertices[v].set_color(HIDDEN_COLOR_2)\n        g.shift(LEFT * 2.5)\n        g_background.shift(LEFT * 2.5)\n        g2.shift(RIGHT * 2.7 + UP * 1.5)\n        g2_background.shift(RIGHT * 2.7 + UP * 1.5)\n        g3.shift(RIGHT * 2.7 + DOWN * 2)\n        g3_background.shift(RIGHT * 2.7 + DOWN * 2)\n        g2.align_to(g, UP)\n        g2_background.align_to(g, UP)\n        g3.align_to(g, DOWN)\n        g3_background.align_to(g, DOWN)\n        self.play(Write(g), Write(g2), Write(g3))\n        self.add(g_background)\n        self.add(g)\n        self.add(g2_background)\n        self.add(g2)\n        self.add(g3_background)\n        self.add(g3)\n        seed(2)\n        st1 = list(yield_spanning_trees(g.vertices, g.edges))\n        st2 = list(yield_spanning_trees(g2.vertices, g.edges))\n        st3 = list(yield_spanning_trees(g3.vertices, g.edges))\n        shuffle(st1)\n        shuffle(st2)\n        shuffle(st3)\n        for s1, s2, s3 in list(zip(st1, st2, st3))[:10]:\n            self.play(*[g.edges[e].animate.set_opacity(0) for e in g.edges if e not in s1], *[g.edges[e].animate.set_opacity(1) for e in s1], *[g2.edges[e].animate.set_opacity(0) for e in g2.edges if e not in s2], *[g2.edges[e].animate.set_opacity(1) for e in s2], *[g3.edges[e].animate.set_opacity(0) for e in g3.edges if e not in s3], *[g3.edges[e].animate.set_opacity(1) for e in s3])\n        self.next_section()\n        gr = Group(g_background, g, g2_background, g2, g3_background, g3).scale(0.7)\n        a = Tex(\"Cayley's Formula\").scale(2).next_to(gr, UP, buff=0.8)\n        self.add(a)\n        fg = Group(a, gr)\n        self.camera.frame.move_to(fg).set_height(fg.get_height() * 1.4)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display children's images and names arranged in a circle, then visualize a graph connecting them, highlighting maximum matchings in the graph."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Kids(Scene):\n\n    @fade\n    def construct(self):\n        n = ['Alice', 'Bob', 'Carl', 'Dan', 'Ema', 'Febe']\n        kids = [SVGMobject(f'kids/{i + 1}.svg').scale(0.58) for i in range(6)]\n        names = [Tex(n[i]).scale(0.8) for i in range(6)]\n        seed(4)\n        g = nx.generators.gnm_random_graph(6, 6)\n        g = Graph(list(g.nodes), list(g.edges))\n        C = 2.3\n        D = 3\n        for i in range(6):\n            kids[i].shift(D * RIGHT * abs(sin(PI * 2 / 6 * i - PI / 6)) ** 1.3 * sgn(sin(PI * 2 / 6 * i - PI / 6)) + C * UP * cos(PI * 2 / 6 * i - PI / 6)).shift(DOWN * 0.3)\n            g.vertices[i].move_to(kids[i].get_center())\n            g.vertices[i].scale(3)\n            g.vertices[i].set_opacity(0)\n            names[i].next_to(kids[i], UP, 0.2)\n        self.play(LaggedStart(*[] + [a for b in zip([Write(img) for img in kids], [Write(name) for name in names]) for a in b], lag_ratio=0.2), run_time=1.5)\n        self.bring_to_back(g)\n        self.play(Write(g), run_time=2)\n        from itertools import chain, combinations\n\n        def powerset(iterable):\n            \"\"\"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\"\"\n            s = list(iterable)\n            return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))\n        good_subsets = []\n        for subset in powerset(g.edges):\n            bad = False\n            for a, b in subset:\n                for c, d in subset:\n                    if (a, b) == (c, d):\n                        continue\n                    if a == c or a == d or b == c or (b == d):\n                        bad = True\n            if bad:\n                continue\n            good_subsets.append(list(subset))\n        for subset in good_subsets:\n            self.play(*[ApplyFunction(lambda x: match_edge(x), g.edges[e]) for e in subset], *[ApplyFunction(lambda x: unmatch_edge(x), g.edges[e]) for e in g.edges if e not in subset], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for v in edgesToVertices(subset)], *[g.vertices[v].animate.set_color(EXPOSED_COLOR) for v in g.vertices if v not in edgesToVertices(subset)], run_time=0.3)"}]}
{"messages": [{"role": "user", "content": "Present text about Jack Edmonds alongside his SVG image and a bulleted list of his contributions."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Edmonds(Scene):\n\n    @fade\n    def construct(self):\n        text = Tex('\\\\huge Jack Edmonds').shift(LEFT * 2.7 + UP * 1)\n        image = SVGMobject('edmonds.svg').scale(4).shift(1.4 * DOWN + RIGHT * 4.25)\n        self.play(Write(text), Write(image))\n        l = MyBulletedList('\\\\footnotesize the blossom algorithm', 'P vs. NP (tractable problems)', 'linear programming, matroids')\n        l.next_to(text, DOWN, 0.6)\n        self.play(Write(l))"}]}
{"messages": [{"role": "user", "content": "Visualize a graph with nodes and edges, highlighting matched edges and then circumscribing unmatched nodes with a distinct color."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Intro(Scene):\n\n    @fade\n    def construct(self):\n        g = parse_graph('\\n1 2 <6.603275758877981, 0.22200042158063704> <10.542340602049554, 5.0486231945767255>\\n1 3 <6.603275758877981, 0.22200042158063704> <0.8751494485961517, 2.8894436903527834>\\n2 4 <10.542340602049554, 5.0486231945767255> <8.316429210045438, 9.49508367004807>\\n1 5 <6.603275758877981, 0.22200042158063704> <5.320620964273308, -6.074692063436867>\\n3 6 <0.8751494485961517, 2.8894436903527834> <-4.8178524679438075, 0.2426494079303798>\\n6 7 <-4.8178524679438075, 0.2426494079303798> <-10.765611934215096, -1.6359342354516002>\\n7 8 <-10.765611934215096, -1.6359342354516002> <-14.201191317109153, 3.5640128560657254>\\n3 9 <0.8751494485961517, 2.8894436903527834> <-0.22868399658749183, 8.989711296016043>\\n6 10 <-4.8178524679438075, 0.2426494079303798> <-6.36641219483813, -5.744685968682711>\\n1 12 <6.603275758877981, 0.22200042158063704> <11.495122080884329, -4.388454491563957>\\n8 13 <-14.201191317109153, 3.5640128560657254> <-8.237759615621837, 6.486457369598593>\\n7 10 <-10.765611934215096, -1.6359342354516002> <-6.36641219483813, -5.744685968682711>\\n5 12 <5.320620964273308, -6.074692063436867> <11.495122080884329, -4.388454491563957>\\n3 11 <0.8751494485961517, 2.8894436903527834> <0.4357598447196547, -3.4516057795938906>\\n2 14 <10.542340602049554, 5.0486231945767255> <16.235759844719652, 1.2483942204061114>\\n                ', s=0.12 / NODE_SCALE, t=-0.1 / NODE_SCALE).scale(GRAPH_SCALE * NODE_SCALE).shift(DOWN * 0.5)\n        text = Tex('\\\\large definitions').next_to(g, UP * 3)\n        self.play(Write(text), Write(g))\n        self.play(*[Indicate(g.vertices[v], color=WHITE) for v in g.vertices])\n        self.play(*[ApplyFunction(partial(match_edge, change_color=False, width=10), g.edges[e]) for e in g.edges], run_time=0.5)\n        self.play(*[ApplyFunction(unmatch_edge, g.edges[e], change_color=False) for e in g.edges], run_time=0.5)\n        M = [(1, 2), (8, 13), (5, 12)]\n        MV = edgesToVertices(M)\n        self.play(*[ApplyFunction(match_edge, g.edges[e]) for e in M], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for v, _ in M], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for _, v in M])\n        MP = mm.mm.get_maximum_matching(list(g.edges))\n        MPV = edgesToVertices(MP)\n        self.play(*[ApplyFunction(match_edge, g.edges[e]) for e in MP if e not in M], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for v, _ in MP if v not in MV], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for _, v in MP if v not in MV], *[ApplyFunction(unmatch_edge, g.edges[e]) for e in M if e not in MP], *[g.vertices[v].animate.set_color(WHITE) for v, _ in M if v not in MPV], *[g.vertices[v].animate.set_color(WHITE) for _, v in M if v not in MPV])\n        self.play(*[Circumscribe(g.vertices[v], Circle, color=EXPOSED_COLOR) for v in g.vertices if v not in MPV], *[g.vertices[v].animate.set_color(EXPOSED_COLOR) for v in g.vertices if v not in MPV])"}]}
{"messages": [{"role": "user", "content": "Visualize a graph and highlight augmenting paths within it to demonstrate the relationship between augmenting paths and maximum matchings."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Core(Scene):\n\n    @fade\n    def construct(self):\n        g = parse_graph('\\n1 2 <10.402934501867037, 17.34415069651897> <16.203839106744862, 19.547491168818176>\\n2 3 <16.203839106744862, 19.547491168818176> <22.178420402084758, 17.787256748775246> \\n3 4 <22.178420402084758, 17.787256748775246> <20.774348346247653, 23.755044257314765>\\n2 4 <16.203839106744862, 19.547491168818176> <20.774348346247653, 23.755044257314765>\\n4 5 <20.774348346247653, 23.755044257314765> <27.05817492976113, 23.859707295924565>\\n6 5 <28.449708119653423, 17.768804208250373> <27.05817492976113, 23.859707295924565>\\n4 7 <20.774348346247653, 23.755044257314765> <17.47242508549339, 29.021438342487553>\\n5 8 <27.05817492976113, 23.859707295924565> <31.15502907598739, 28.586235859209886>\\n8 9 <31.15502907598739, 28.586235859209886> <37.31660856822276, 28.245054265211092> \\n6 10 <28.449708119653423, 17.768804208250373> <34.660938508332286, 16.631467003826533>\\n10 11 <34.660938508332286, 16.631467003826533> <40.60957109101587, 18.40703837992414>\\n3 6 <22.178420402084758, 17.787256748775246> <28.449708119653423, 17.768804208250373>\\n5 12 <27.05817492976113, 23.859707295924565> <33.0788344527837, 22.821541250821294>\\n2 13 <16.203839106744862, 19.547491168818176> <12.52911329849324, 24.494238155627645>\\n                ', s=0.12 / NODE_SCALE, t=-0.12 / NODE_SCALE).scale(GRAPH_SCALE * NODE_SCALE).shift(DOWN * 0.65)\n        text = Tex('\\\\large augmenting paths').next_to(g, UP * 3)\n        self.play(Write(text), Write(g))\n        M = [(5, 8), (6, 10), (2, 4)]\n        MV = edgesToVertices(M)\n        self.play(*[ApplyFunction(match_edge, g.edges[e]) for e in M], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for v, _ in M], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for _, v in M], *[g.vertices[v].animate.set_color(EXPOSED_COLOR) for v in g.vertices if v not in MV])\n        animate_augment_path(self, g, [(8, 9), (5, 8), (4, 5), (2, 4), (1, 2)], add_animations_between=[Circumscribe(g.vertices[9], Circle, color=AUGMENTING_COLOR), Circumscribe(g.vertices[1], Circle, color=AUGMENTING_COLOR)])\n        self.play(text.animate.shift(UP * 0.2), g.animate.shift(DOWN * 0.2))\n        text2 = Tex('\\\\scriptsize \\\\em contains an augmenting path $\\\\Leftrightarrow$ matching is not maximum$^{\\\\ast}$').next_to(text, DOWN)\n        box = Tex('$\\\\ast$ proof in description \u2013 theorem 2.4').scale(0.5).align_on_border(UP + RIGHT)\n        frame = SurroundingRectangle(box, color=WHITE, stroke_width=2)\n        self.play(Write(text2))\n        self.play(Write(box, run_time=0.7), Write(frame))\n        animate_augment_path(self, g, [(10, 11), (6, 10), (3, 6)])\n        animate_augment_path(self, g, [(5, 12), (4, 5), (4, 7)])"}]}
{"messages": [{"role": "user", "content": "Visualize the process of finding augmenting paths in a graph to improve a matching, highlighting relevant code lines as the algorithm progresses."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Tree(Scene):\n\n    @fade\n    def construct(self):\n        g_new_positions = parse_graph('\\n1 2 <22.112572766007876, -2.5264304107833246> <25.67796210932871, 2.697892851581728>\\n3 1 <28.55611115849213, -3.7428115450105133> <22.112572766007876, -2.5264304107833246>\\n4 1 <15.428111442950147, -2.829960372608953> <22.112572766007876, -2.5264304107833246>\\n4 5 <15.428111442950147, -2.829960372608953> <8.976964571929539, -3.0504356092202367>\\n3 6 <28.55611115849213, -3.7428115450105133> <34.04768084651785, -0.5973824149390512>\\n3 7 <28.55611115849213, -3.7428115450105133> <32.64776811333644, -8.460442932301625>\\n5 8 <8.976964571929539, -3.0504356092202367> <3.834695753774831, -6.50435350211315>\\n4 9 <15.428111442950147, -2.829960372608953> <14.226722555124457, -8.942190801950318>\\n2 10 <25.67796210932871, 2.697892851581728> <28.496351384614382, 8.224513316804416>\\n1 11 <22.112572766007876, -2.5264304107833246> <22.95614485199056, -8.724125830834108>\\n1 12 <22.112572766007876, -2.5264304107833246> <19.316663589836477, 3.048818090535028>\\n13 4 <11.896071360485621, 2.430059482684668> <15.428111442950147, -2.829960372608953>\\n14 6 <38.90070190924257, 3.2512436388123502> <34.04768084651785, -0.5973824149390512>\\n13 15 <11.896071360485621, 2.430059482684668> <8.433034228381587, 7.599704780509387>\\n5 16 <8.976964571929539, -3.0504356092202367> <3.6702917967931405, 0.23588429272754086>\\n17 12 <17.000076691912383, 8.77194474648056> <19.316663589836477, 3.048818090535028>\\n                ', s=0.05, t=0.06).scale(GRAPH_SCALE * NODE_SCALE).shift(3.7 * RIGHT)\n        g_new_positions.rotate_in_place(-PI / 2)\n        g = parse_graph('\\n1 2 <22.112572766007876, -2.5264304107833246> <25.67796210932871, 2.697892851581728>\\n3 1 <28.55611115849213, -3.7428115450105133> <22.112572766007876, -2.5264304107833246>\\n4 1 <15.428111442950147, -2.829960372608953> <22.112572766007876, -2.5264304107833246>\\n4 5 <15.428111442950147, -2.829960372608953> <8.976964571929539, -3.0504356092202367>\\n3 6 <28.55611115849213, -3.7428115450105133> <34.04768084651785, -0.5973824149390512>\\n3 7 <28.55611115849213, -3.7428115450105133> <32.64776811333644, -8.460442932301625>\\n5 8 <8.976964571929539, -3.0504356092202367> <3.834695753774831, -6.50435350211315>\\n4 9 <15.428111442950147, -2.829960372608953> <14.226722555124457, -8.942190801950318>\\n2 10 <25.67796210932871, 2.697892851581728> <28.496351384614382, 8.224513316804416>\\n1 11 <22.112572766007876, -2.5264304107833246> <22.95614485199056, -8.724125830834108>\\n1 12 <22.112572766007876, -2.5264304107833246> <19.316663589836477, 3.048818090535028>\\n13 4 <11.896071360485621, 2.430059482684668> <15.428111442950147, -2.829960372608953>\\n14 6 <38.90070190924257, 3.2512436388123502> <34.04768084651785, -0.5973824149390512>\\n13 15 <11.896071360485621, 2.430059482684668> <8.433034228381587, 7.599704780509387>\\n5 16 <8.976964571929539, -3.0504356092202367> <3.6702917967931405, 0.23588429272754086>\\n17 12 <17.000076691912383, 8.77194474648056> <19.316663589836477, 3.048818090535028>\\n                ', s=0.09, t=0.09).scale(GRAPH_SCALE * NODE_SCALE)\n        code_str = 'def find_augmenting_path(v):\\n    bfs.start_from_vertex(v)\\n    while bfs.has_unexplored_vertices():\\n        bfs.add_vertices_not_in_matching()\\n\\n        if bfs.found_augmenting_path():\\n            return bfs.augmenting_path\\n\\n        bfs.add_vertices_in_matching()\\n\\n    return []\\n\\ndef improve_matching(G):\\n    for v in exposed_vertices(G):\\n        path = find_augmenting_path(v)\\n\\n        if path != []:\\n            switch_augmenting_path(path)\\n            return True\\n\\n    return False\\n\\nwhile True:\\n    if not improve_matching(G):\\n        break'\n        code = Code(code=code_str, font='Fira Mono', line_spacing=0, style='Monokai', language='python')\n        code.background_mobject[0].set_opacity(0)\n        code.scale(0.65).shift(2.6 * LEFT)\n        c = 0.075\n        for i in range(1, len(code.code)):\n            code.code[i].shift(i * DOWN * c)\n            code.line_numbers[i].shift(i * DOWN * c)\n        code.shift(UP * len(code.code) * c / 2)\n        frame = SurroundingRectangle(code, color=WHITE, stroke_width=2)\n        frame.round_corners(0.2).shift(DOWN * 0.1)\n        self.play(Write(g))\n        self.play(*[g.vertices[v].animate.move_to(g_new_positions.vertices[v].get_center()) for v in g.vertices], run_time=1.5)\n        self.play(Write(code), Write(frame))\n        M = []\n\n        def set_lines(self, code, lines, previous_lines=[]):\n            if previous_lines == []:\n                for i in range(len(code.code_string.splitlines())):\n                    previous_lines.append(i + 1)\n                    code.code.chars[i - 1].save_state()\n            new_lines = [l for l in lines if l not in previous_lines]\n            dis_lines = [l for l in previous_lines if l not in lines]\n            for l in dis_lines:\n                code.code.chars[l - 1].save_state()\n            new_lines_animation = [code.line_numbers[i - 1].animate.set_color(WHITE) for i in new_lines] + [code.code.chars[i - 1].animate.restore() for i in new_lines]\n            dis_lines_animation = [code.line_numbers[i - 1].animate.set_color(HIDDEN_COLOR) for i in dis_lines] + [code.code.chars[i - 1].animate.set_color(HIDDEN_COLOR) for i in dis_lines]\n            while len(previous_lines) != 0:\n                previous_lines.pop()\n            for e in lines:\n                previous_lines.append(e)\n            return new_lines_animation + dis_lines_animation\n        seed(3)\n        self.play(*set_lines(self, code, [i + 1 for i in range(11)]))\n        self.play(*set_lines(self, code, [i + 1 for i in range(12, 25)]))\n        self.play(*set_lines(self, code, [i + 1 for i in range(25)]))\n        while True:\n            animate_correct_graph_color(self, g, M, set_lines, code)\n            result = animate_tree_algorithm_iteration(self, g, M, set_lines, code)\n            if not result:\n                break\n        animate_correct_graph_color(self, g, M, lambda x, y, z: [], None, add_animations=lambda: set_lines(self, code, [i + 1 for i in range(len(code.code))]))"}]}
{"messages": [{"role": "user", "content": "Visualize the steps of the blossom algorithm for maximum matching in a graph, highlighting matching edges, augmenting paths, and blossom contractions."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Problem(Scene):\n\n    @fade\n    def construct(self):\n        g = parse_graph('\\n1 2 <45.9217542503518, 30.268039362382353> <40.418193960422386, 27.255790801835087>\\n2 3 <40.418193960422386, 27.255790801835087> <40.275304608904456, 21.00876563036128>\\n3 4 <40.275304608904456, 21.00876563036128> <34.290257207802384, 19.319999132635935>\\n4 5 <34.290257207802384, 19.319999132635935> <30.320308258664582, 24.016251087986912>\\n5 6 <30.320308258664582, 24.016251087986912> <34.411741345002966, 28.722301776246766>\\n2 6 <40.418193960422386, 27.255790801835087> <34.411741345002966, 28.722301776246766>\\n1 7 <45.9217542503518, 30.268039362382353> <52.08682172920419, 30.518073800366004>\\n3 8 <40.275304608904456, 21.00876563036128> <45.88376295063149, 23.472558301422573>\\n3 9 <40.275304608904456, 21.00876563036128> <44.74231894798374, 16.725946411138796>\\n                ', s=0.1, t=-0.1).scale(GRAPH_SCALE * NODE_SCALE)\n        self.play(Write(g))\n        M = [(1, 2), (3, 4), (5, 6)]\n        MV = edgesToVertices(M)\n        exposed = [v for v in g.vertices if v not in MV]\n        self.play(*[ApplyFunction(match_edge, g.edges[e]) for e in M], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for v in edgesToVertices(M)], *[g.vertices[v].animate.set_color(EXPOSED_COLOR) for v in exposed])\n        self.play(g.vertices[7].animate.set_color(BFS_COLOR), Circumscribe(g.vertices[7], Circle, color=BFS_COLOR))\n        layers = [[(1, 7)], [(1, 2)], [(2, 3), (2, 6)], [(3, 4), (5, 6)], [(4, 5)]]\n        for current_layer in layers:\n            self.play(*[g.vertices[v].animate.set_color(BFS_COLOR) for v in edgesToVertices(current_layer)], *[g.edges[e].animate.set_color(BFS_COLOR) for e in current_layer])\n        animate_correct_graph_color(self, g, M)\n        self.play(*[g.vertices[v].animate.set_color(AUGMENTING_COLOR) for v in edgesToVertices([(1, 7), (1, 2), (2, 6), (5, 6), (4, 5), (3, 4), (3, 9)])], *[g.edges[v].animate.set_color(AUGMENTING_COLOR) for v in [(1, 7), (1, 2), (2, 6), (5, 6), (4, 5), (3, 4), (3, 9)]])\n        animate_correct_graph_color(self, g, M)\n        self.play(g.vertices[8].animate.set_color(HIDDEN_COLOR), g.vertices[9].animate.set_color(HIDDEN_COLOR), g.edges[3, 9].animate.set_color(HIDDEN_COLOR), g.edges[3, 8].animate.set_color(HIDDEN_COLOR))\n        average = (g.vertices[2].get_center() + g.vertices[3].get_center() + g.vertices[4].get_center() + g.vertices[5].get_center() + g.vertices[6].get_center()) / 5\n        blossom_text = Tex('blossom').move_to(average)\n        stem_text = Tex('stem').next_to(g.vertices[1], UP).shift(RIGHT * 0.3 + UP * 0.3)\n        self.play(g.vertices[7].animate.set_color(HIDDEN_COLOR), g.vertices[1].animate.set_color(HIDDEN_COLOR), g.edges[1, 7].animate.set_color(HIDDEN_COLOR), g.edges[1, 2].animate.set_color(HIDDEN_COLOR))\n        self.play(Write(blossom_text))\n        self.play(g.vertices[3].animate.set_color(HIDDEN_COLOR), g.vertices[4].animate.set_color(HIDDEN_COLOR), g.vertices[5].animate.set_color(HIDDEN_COLOR), g.vertices[6].animate.set_color(HIDDEN_COLOR), g.edges[2, 3].animate.set_color(HIDDEN_COLOR), g.edges[2, 6].animate.set_color(HIDDEN_COLOR), g.edges[3, 4].animate.set_color(HIDDEN_COLOR), g.edges[4, 5].animate.set_color(HIDDEN_COLOR), g.edges[5, 6].animate.set_color(HIDDEN_COLOR), blossom_text.animate.set_color(HIDDEN_COLOR), g.vertices[7].animate.set_color(EXPOSED_COLOR), g.vertices[1].animate.set_color(MATCHING_COLOR), g.edges[1, 7].animate.set_color(WHITE), g.edges[1, 2].animate.set_color(MATCHING_COLOR))\n        self.play(Write(stem_text))\n        animate_correct_graph_color(self, g, M, add_animations=[blossom_text.animate.set_color(WHITE)])\n        self.play(FadeOut(blossom_text), FadeOut(stem_text))\n        layers = [[(1, 7)], [(1, 2)], [(2, 3), (2, 6)], [(3, 4), (5, 6)], [(4, 5)]]\n        for current_layer in layers:\n            self.play(*[g.vertices[v].animate.set_color(BFS_COLOR) for v in edgesToVertices(current_layer)], *[g.edges[e].animate.set_color(BFS_COLOR) for e in current_layer], run_time=0.3)\n        self.play(g.animate.shift(LEFT * 2))\n        parts = ['\\\\small $1.\\\\ $contract the blossomg\\\\\\\\ ' + '\\n', '\\\\small $2.\\\\ $find augmenting path\\\\\\\\ ' + '\\n', '\\\\small $3.\\\\ $improve the matching\\\\\\\\ ' + '\\n', '\\\\small $4.\\\\ $lift the path\\\\\\\\ ']\n        l = Tex(*parts)\n        l.arrange(DOWN, aligned_edge=LEFT).shift(RIGHT * 3.5 + UP * 0.4)\n        l[0][20].set_color(BLACK)\n        small_random = [1 + i / 10000 for i in range(5)]\n        average = (g.vertices[2].get_center() + g.vertices[3].get_center() + g.vertices[4].get_center() + g.vertices[5].get_center() + g.vertices[6].get_center()) / 5\n        original_positions = [g.vertices[2].get_center(), g.vertices[3].get_center(), g.vertices[4].get_center(), g.vertices[5].get_center(), g.vertices[6].get_center()]\n        self.play(ApplyFunction(lambda x: match_vertex(x, where=average * small_random[0]), g.vertices[2]), ApplyFunction(lambda x: match_vertex(x, where=average * small_random[1]), g.vertices[3]), ApplyFunction(lambda x: match_vertex(x, where=average * small_random[2]), g.vertices[4]), ApplyFunction(lambda x: match_vertex(x, where=average * small_random[3]), g.vertices[5]), ApplyFunction(lambda x: match_vertex(x, where=average * small_random[4]), g.vertices[6]), Write(l[0]))\n        animate_correct_graph_color(self, g, M)\n        animate_augment_path(self, g, [(1, 7), (1, 2), (2, 6), (5, 6), (4, 5), (3, 4), (3, 9)], add_animations_first=[Write(l[1])], add_animations_second=[Write(l[2])])\n        self.play(ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[0]), g.vertices[2]), ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[1]), g.vertices[3]), ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[2]), g.vertices[4]), ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[3]), g.vertices[5]), ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[4]), g.vertices[6]), Write(l[3]))\n        self.play(g.animate.shift(DOWN * 0.75), l.animate.shift(DOWN * 0.75))\n        text2 = Tex('\\\\scriptsize \\\\em has augmenting path $\\\\Leftrightarrow$ contracted graph has augmenting path$^{\\\\ast}$').shift(UP * 2.6)\n        box = Tex('$\\\\ast$ proof in description \u2013 theorem 2.9').scale(0.5).align_on_border(UP + RIGHT)\n        frame = SurroundingRectangle(box, color=WHITE, stroke_width=2)\n        self.play(Write(text2))\n        self.play(Write(box, run_time=0.7), Write(frame), run_time=1)"}]}
{"messages": [{"role": "user", "content": "Visualize the Edmonds Blossom algorithm for finding maximum matchings in graphs by animating the construction of augmenting paths and demonstrating matching operations."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Blossom(Scene):\n\n    @fade\n    def construct(self):\n\n        @dataclass\n        class Context:\n            graph: MyGraph\n            self: Blossom\n            code: 'typing.Any'\n            set_lines: 'typing.Any'\n        g = parse_graph('\\n5 0 <-16.05615947107685, -12.504911246689693> <-14.446419714646854, -6.866013725874188>\\n0 8 <-14.446419714646854, -6.866013725874188> <-16.42527207725241, -1.8140283988138854>\\n12 0 <-19.64155534824222, -7.330631498406216> <-14.446419714646854, -6.866013725874188>\\n1 3 <-4.698194206378598, 0.11011604485983129> <-10.209550409185647, -2.9552644219000106>\\n1 10 <-4.698194206378598, 0.11011604485983129> <0.9003340177597777, -2.5845025309871477>\\n3 2 <-10.209550409185647, -2.9552644219000106> <-10.670793355913192, -9.290296998392101>\\n5 2 <-16.05615947107685, -12.504911246689693> <-10.670793355913192, -9.290296998392101>\\n3 8 <-10.209550409185647, -2.9552644219000106> <-16.42527207725241, -1.8140283988138854>\\n4 6 <-1.0383909201343497, -12.64149137008625> <-7.062170194186263, -14.061899786709596>\\n4 7 <-1.0383909201343497, -12.64149137008625> <3.324971894939845, -8.293802236457113>\\n4 11 <-1.0383909201343497, -12.64149137008625> <-3.3577054035744847, -6.997621303069259>\\n12 5 <-19.64155534824222, -7.330631498406216> <-16.05615947107685, -12.504911246689693>\\n7 9 <3.324971894939845, -8.293802236457113> <7.465014371318295, -3.8180621675279958>\\n10 7 <0.9003340177597777, -2.5845025309871477> <3.324971894939845, -8.293802236457113>\\n12 8 <-19.64155534824222, -7.330631498406216> <-16.42527207725241, -1.8140283988138854>\\n8 13 <-16.42527207725241, -1.8140283988138854> <-12.470684295924984, 2.950307523065462>\\n10 11 <0.9003340177597777, -2.5845025309871477> <-3.3577054035744847, -6.997621303069259>\\n10 14 <0.9003340177597777, -2.5845025309871477> <5.227801852655065, 1.8530677198156864>\\n                ', s=0.065, t=-0.07).scale(GRAPH_SCALE * NODE_SCALE).rotate_in_place(-PI / 2).shift(3.3 * RIGHT)\n        code_str = 'def find_augmenting_path(v):\\n    bfs.start_from_vertex(v)\\n    while bfs.has_unexplored_vertices():\\n        bfs.add_vertices_not_in_matching()\\n\\n        if bfs.found_blossom():\\n            bfs.contract_blossom()\\n            find_augmenting_path(v)\\n            bfs.lift_blossom()\\n\\n        if bfs.found_augmenting_path():\\n            return bfs.augmenting_path\\n\\n        bfs.add_vertices_in_matching()\\n\\n\\n    return []\\n\\ndef improve_matching(G):\\n    for v in exposed_vertices(G):\\n        path = find_augmenting_path(v)\\n\\n        if path != []:\\n            switch_augmenting_path(path)\\n            return True\\n\\n    return False\\n\\nwhile True:\\n    if not improve_matching(G):\\n        break'\n        code = Code(code=code_str, font='Fira Mono', line_spacing=0, style='Monokai', language='python')\n        code.background_mobject[0].set_opacity(0)\n        code.scale(0.55).shift(2.8 * LEFT)\n        c = 0.075\n        for i in range(1, len(code.code)):\n            code.code[i].shift(i * DOWN * c)\n            code.line_numbers[i].shift(i * DOWN * c)\n        code.shift(UP * len(code.code) * c / 2)\n        frame = SurroundingRectangle(code, color=WHITE, stroke_width=2)\n        frame.round_corners(0.2).shift(DOWN * 0.1)\n        self.play(Write(code), Write(g), Write(frame))\n        M = []\n\n        def set_lines(self, code, lines, previous_lines=[]):\n            if previous_lines == []:\n                for i in range(len(code.code_string.splitlines())):\n                    previous_lines.append(i + 1)\n                    code.code.chars[i - 1].save_state()\n            new_lines = [l for l in lines if l not in previous_lines]\n            dis_lines = [l for l in previous_lines if l not in lines]\n            for l in dis_lines:\n                code.code.chars[l - 1].save_state()\n            new_lines_animation = [code.line_numbers[i - 1].animate.set_color(WHITE) for i in new_lines] + [code.code.chars[i - 1].animate.restore() for i in new_lines]\n            dis_lines_animation = [code.line_numbers[i - 1].animate.set_color(HIDDEN_COLOR) for i in dis_lines] + [code.code.chars[i - 1].animate.set_color(HIDDEN_COLOR) for i in dis_lines]\n            while len(previous_lines) != 0:\n                previous_lines.pop()\n            for e in lines:\n                previous_lines.append(e)\n            return new_lines_animation + dis_lines_animation\n        self.play(*set_lines(self, code, [6, 7, 8, 9]))\n        self.play(*set_lines(self, code, [i + 1 for i in range(len(code.code))]))\n        operations = [('R', None), ('I', 8), ('B', [(8, 0), (8, 12), (8, 3), (8, 13)]), ('A', [(8, 12)]), ('I', 1), ('B', [(1, 3), (1, 10)]), ('A', [(1, 10)]), ('I', 3), ('B', [(3, 8), (3, 2), (3, 1)]), ('A', [(3, 2)]), ('I', 4), ('B', [(4, 11), (4, 6), (4, 7)]), ('A', [(4, 11)]), ('I', 5), ('B', [(5, 0), (5, 12), (5, 2)]), ('A', [(5, 0)]), ('I', 9), ('B', [(9, 7)]), ('A', [(9, 7)]), ('I', 14), ('B', [(14, 10)]), ('BO', [(1, 10)]), ('B', [(1, 3)]), ('BO', [(3, 2)]), ('B', [(2, 5)]), ('BO', [(5, 0)]), ('B', [(0, 8), (0, 12)]), ('BO', [(8, 12)]), ('C', [0, 8, 12]), ('R', None), ('I', 14), ('B', [(14, 10)]), ('BO', [(1, 10)]), ('B', [(1, 3)]), ('BO', [(3, 2)]), ('B', [(2, 5)]), ('BO', [(5, 0), (0, 8), (0, 12), (8, 12)]), ('B', [(8, 13)]), ('A', [(14, 10), (10, 1), (1, 3), (3, 2), (2, 5), (5, 0), (0, 12), (12, 8), (8, 13)]), ('U', [0, 8, 12]), ('I', 6), ('B', [(6, 4)]), ('BO', [(4, 11)]), ('B', [(11, 10)]), ('BO', [(14, 10)]), ('Q', None), ('RR', None)]\n        fk = (12, 5)\n        g.add_to_back(g.edges[fk if fk in g.edges else (fk[1], fk[0])])\n        for operation, argument in operations:\n            if operation == 'R':\n                animate_correct_graph_color(self, g, M)\n            if operation == 'RR':\n                animate_correct_graph_color(self, g, M, lambda x, y, z: [], None, add_animations=lambda: set_lines(self, code, [i + 1 for i in range(len(code.code))]))\n            if operation == 'I':\n                self.play(Circumscribe(g.vertices[argument], Circle, color=BFS_COLOR), g.vertices[argument].animate.set_color(BFS_COLOR), *set_lines(self, code, [20]))\n                self.play(*set_lines(self, code, [21]))\n                self.play(*set_lines(self, code, [2]))\n                self.play(*set_lines(self, code, [3]))\n            if operation[0] == 'B':\n                self.play(*[g.vertices[v].animate.set_color(BFS_COLOR) for v in edgesToVertices(argument)], *[g.edges[e if e in g.edges else (e[1], e[0])].animate.set_color(BFS_COLOR) for e in argument], *set_lines(self, code, [4 if operation == 'B' else 14]))\n            if operation == 'A':\n                augmenting_path = [e if e in g.edges else (e[1], e[0]) for e in argument]\n                animate_augment_path(self, g, augmenting_path, add_animations_first=lambda: set_lines(self, code, [11, 12]), add_animations_second=lambda: set_lines(self, code, [23, 24, 25]))\n                for i in range(0, len(augmenting_path), 2):\n                    M.append(augmenting_path[i])\n                for i in range(1, len(augmenting_path), 2):\n                    M.remove(augmenting_path[i])\n                set_lines(self, code, [23, 24, 25])\n                animate_correct_graph_color(self, g, M)\n            if operation == 'C':\n                small_random = [1 + i / 10000 for i in range(len(argument))]\n                average = sum((g.vertices[v].get_center() for v in argument)) / len(argument)\n                original_vertices = argument\n                original_positions = [g.vertices[v].get_center() for v in argument]\n                self.play(ApplyFunction(lambda x: match_vertex(x, where=average * small_random[0]), g.vertices[0]), ApplyFunction(lambda x: match_vertex(x, where=average * small_random[1]), g.vertices[8]), ApplyFunction(lambda x: match_vertex(x, where=average * small_random[2]), g.vertices[12]), *set_lines(self, code, [6, 7]))\n                self.play(*set_lines(self, code, [8]))\n            if operation == 'U':\n                self.play(ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[0]), g.vertices[0]), ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[1]), g.vertices[8]), ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[2]), g.vertices[12]), *set_lines(self, code, [9]))\n            if operation == 'Q':\n                self.play(*set_lines(self, code, [17]), run_time=SHORT_CODE_PAUSE)\n                self.play(*set_lines(self, code, [27]), run_time=SHORT_CODE_PAUSE)\n                self.play(*set_lines(self, code, [31]), run_time=SHORT_CODE_PAUSE)"}]}
{"messages": [{"role": "user", "content": "Display and compare two graphs, visualizing the process of finding a maximum matching in the second graph."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Overview(Scene):\n\n    @fade\n    def construct(self):\n        naive = Tex('Na\u00efve').shift(UP * 1.7 + RIGHT * 3.35)\n        naive_o = Tex('\u2013 $\\\\mathcal{O}(2^{e})$')\n        naive_o_combined = Tex('Na\u00efve \u2013 $\\\\mathcal{O}(2^{e})$').move_to(naive.get_center())\n        blossom = Tex('Blossom').shift(UP * 1.7 + LEFT * 3.35)\n        blossom_o = Tex('\u2013 $\\\\mathcal{O}(e \\\\cdot v^2)$')\n        blossom_o_combined = Tex('Blossom \u2013 $\\\\mathcal{O}(e \\\\cdot v^2)$').move_to(blossom.get_center())\n        g_naive = parse_graph('\\n1 2 <5.305295407371162, -9.00109716204681> <-0.6729840226655002, -10.4461242684385>\\n3 2 <-0.8425669826207631, -16.51162542950073> <-0.6729840226655002, -10.4461242684385>\\n3 4 <-0.8425669826207631, -16.51162542950073> <-6.220565179720084, -13.23694362201735>\\n2 4 <-0.6729840226655002, -10.4461242684385> <-6.220565179720084, -13.23694362201735>\\n4 5 <-6.220565179720084, -13.23694362201735> <-11.791437508380174, -10.273211500280336>\\n4 6 <-6.220565179720084, -13.23694362201735> <-11.558874566262684, -16.33719898830283>\\n5 6 <-11.791437508380174, -10.273211500280336> <-11.558874566262684, -16.33719898830283>\\n4 7 <-6.220565179720084, -13.23694362201735> <-6.896308576133831, -7.119926197187177>\\n3 8 <-0.8425669826207631, -16.51162542950073> <5.2015048653161315, -15.125611531890883>\\n1 8 <5.305295407371162, -9.00109716204681> <5.2015048653161315, -15.125611531890883>\\n5 9 <-11.791437508380174, -10.273211500280336> <-17.56869374575382, -12.311184072704405>\\n5 10 <-11.791437508380174, -10.273211500280336> <-16.13459349493921, -5.841431825927536>\\n2 11 <-0.6729840226655002, -10.4461242684385> <-1.826409248537547, -4.402336655405>\\n                ', s=0.08 / NODE_SCALE, t=-0.08 / NODE_SCALE).scale(GRAPH_SCALE * NODE_SCALE).shift(DOWN)\n        g_blossom = parse_graph('\\n1 2 <5.305295407371162, -9.00109716204681> <-0.6729840226655002, -10.4461242684385>\\n3 2 <-0.8425669826207631, -16.51162542950073> <-0.6729840226655002, -10.4461242684385>\\n3 4 <-0.8425669826207631, -16.51162542950073> <-6.220565179720084, -13.23694362201735>\\n2 4 <-0.6729840226655002, -10.4461242684385> <-6.220565179720084, -13.23694362201735>\\n4 5 <-6.220565179720084, -13.23694362201735> <-11.791437508380174, -10.273211500280336>\\n4 6 <-6.220565179720084, -13.23694362201735> <-11.558874566262684, -16.33719898830283>\\n5 6 <-11.791437508380174, -10.273211500280336> <-11.558874566262684, -16.33719898830283>\\n4 7 <-6.220565179720084, -13.23694362201735> <-6.896308576133831, -7.119926197187177>\\n3 8 <-0.8425669826207631, -16.51162542950073> <5.2015048653161315, -15.125611531890883>\\n1 8 <5.305295407371162, -9.00109716204681> <5.2015048653161315, -15.125611531890883>\\n5 9 <-11.791437508380174, -10.273211500280336> <-17.56869374575382, -12.311184072704405>\\n5 10 <-11.791437508380174, -10.273211500280336> <-16.13459349493921, -5.841431825927536>\\n2 11 <-0.6729840226655002, -10.4461242684385> <-1.826409248537547, -4.402336655405>\\n                ', s=0.08 / NODE_SCALE, t=-0.08 / NODE_SCALE).scale(GRAPH_SCALE * NODE_SCALE).shift(DOWN)\n        from itertools import chain, combinations\n\n        def powerset(iterable):\n            \"\"\"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\"\"\n            s = list(iterable)\n            return chain.from_iterable((combinations(s, r) for r in range(len(s) + 1)))\n        good_subsets = []\n        for subset in powerset(g_naive.edges):\n            bad = False\n            for a, b in subset:\n                for c, d in subset:\n                    if (a, b) == (c, d):\n                        continue\n                    if a == c or a == d or b == c or (b == d):\n                        bad = True\n            if bad:\n                continue\n            good_subsets.append(list(subset))\n        g_blossom.next_to(blossom, DOWN, 0.8)\n        self.play(Write(blossom), Write(g_blossom))\n        g_naive.next_to(naive, DOWN, 0.8)\n        self.play(Write(naive), Write(g_naive))\n        animation_runtime = 0.06\n        for subset in good_subsets:\n            g = g_naive\n            self.play(*[ApplyFunction(lambda x: match_edge(x), g.edges[e]) for e in subset], *[ApplyFunction(lambda x: unmatch_edge(x), g.edges[e]) for e in g.edges if e not in subset], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for v in edgesToVertices(subset)], *[g.vertices[v].animate.set_color(EXPOSED_COLOR) for v in g.vertices if v not in edgesToVertices(subset)], run_time=animation_runtime)\n        animation_runtime *= 3\n        diff = -naive[0][0].get_center() + naive_o_combined[0][0].get_center()\n        self.play(naive.animate.shift(diff))\n        naive_o.next_to(naive, RIGHT)\n        self.play(Write(naive_o))\n        diff = -blossom[0][0].get_center() + blossom_o_combined[0][0].get_center()\n        g = g_blossom\n        M = []\n        i = 0\n        while True:\n            if i == 0:\n                animate_correct_graph_color(self, g, M, lambda x, y, z: [], None)\n                i += 1\n            else:\n                animate_correct_graph_color(self, g, M, lambda x, y, z: [], None, run_time=animation_runtime)\n            result = animate_tree_algorithm_iteration(self, g, M, lambda x, y, z: [], None, run_time=animation_runtime, no_code=True)\n            if not result:\n                break\n        animate_correct_graph_color(self, g, M, lambda x, y, z: [], None, run_time=animation_runtime)\n        self.play(blossom.animate.shift(diff))\n        blossom_o.next_to(blossom, RIGHT)\n        self.play(Write(blossom_o))"}]}
{"messages": [{"role": "user", "content": "Animate the title \"The Blossom algorithm\" with a flower icon appearing over the letter 'o'."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Title(Scene):\n\n    @fade\n    def construct(self):\n        text = Tex('\\\\Large The Blossom algorithm').scale(1.3)\n        i = 5\n        text[0][i].set_color(BLACK)\n        S = 1.2\n        self.play(LaggedStart(Write(text.scale(S)), Write(SVGMobject('flower.svg').scale(0.225).move_to(text[0][i]).shift(LEFT * 0.02).scale(S), run_time=0.3), lag_ratio=0.2))"}]}
{"messages": [{"role": "user", "content": "Animate a graph traversal and matching process, highlighting nodes and edges as they are visited, augmented, and manipulated."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Outro(Scene):\n\n    @fade\n    def construct(self):\n        g = parse_graph('\\n0 1 <16.41082561017643, 4.667526176613917> <10.84069307855083, 7.503968161787933>\\n1 15 <10.84069307855083, 7.503968161787933> <4.541887477921455, 8.254448675626461>\\n2 5 <-1.196230366996346, 5.4090795936312865> <-6.619254653629823, 1.7609337636785525>\\n2 10 <-1.196230366996346, 5.4090795936312865> <3.816531484644093, 1.7352935181536813>\\n15 2 <4.541887477921455, 8.254448675626461> <-1.196230366996346, 5.4090795936312865>\\n3 14 <15.86879364092038, -9.39849234273218> <9.939049668936683, -11.536515478495724>\\n4 6 <-0.6313440444305729, -6.6657958940717155> <5.039718780660546, -4.2902764515477605>\\n4 7 <-0.6313440444305729, -6.6657958940717155> <-6.4928860212702615, -4.787834235204335>\\n4 9 <-0.6313440444305729, -6.6657958940717155> <-1.7957609981445226, -0.806513806341758>\\n5 7 <-6.619254653629823, 1.7609337636785525> <-6.4928860212702615, -4.787834235204335>\\n5 8 <-6.619254653629823, 1.7609337636785525> <-10.651125829909375, 6.550841780969295>\\n5 16 <-6.619254653629823, 1.7609337636785525> <-11.785738650858029, -1.5835479095931102>\\n10 6 <3.816531484644093, 1.7352935181536813> <5.039718780660546, -4.2902764515477605>\\n6 12 <5.039718780660546, -4.2902764515477605> <11.059397566311196, -5.512977312597954>\\n7 9 <-6.4928860212702615, -4.787834235204335> <-1.7957609981445226, -0.806513806341758>\\n7 11 <-6.4928860212702615, -4.787834235204335> <-12.098487635168565, -7.615515657229979>\\n7 16 <-6.4928860212702615, -4.787834235204335> <-11.785738650858029, -1.5835479095931102>\\n7 19 <-6.4928860212702615, -4.787834235204335> <-2.8286604281628853, -10.234945141734263>\\n10 9 <3.816531484644093, 1.7352935181536813> <-1.7957609981445226, -0.806513806341758>\\n10 18 <3.816531484644093, 1.7352935181536813> <10.072341264393968, 1.4997616137359333>\\n16 11 <-11.785738650858029, -1.5835479095931102> <-12.098487635168565, -7.615515657229979>\\n12 17 <11.059397566311196, -5.512977312597954> <15.546018749458295, -1.4101212844618582>\\n14 13 <9.939049668936683, -11.536515478495724> <3.5146419854002207, -11.66621030177497>\\n19 13 <-2.8286604281628853, -10.234945141734263> <3.5146419854002207, -11.66621030177497>\\n18 17 <10.072341264393968, 1.4997616137359333> <15.546018749458295, -1.4101212844618582>\\n                ', s=0.09, t=-0.08).scale(GRAPH_SCALE * NODE_SCALE)\n\n        @dataclass\n        class Context:\n            graph: MyGraph\n            self: Outro\n        self.play(Write(g))\n        g_structure = ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [(0, 1), (1, 15), (2, 5), (2, 10), (2, 15), (3, 14), (4, 6), (4, 7), (4, 9), (5, 7), (5, 8), (5, 16), (6, 10), (6, 12), (7, 9), (7, 11), (7, 16), (7, 19), (9, 10), (10, 18), (11, 16), (12, 17), (13, 14), (13, 19), (17, 18)])\n        operations = [('R', None), ('I', 0), ('B', [(0, 1)]), ('A', [(0, 1)]), ('I', 2), ('B', [(2, 10), (2, 15), (2, 5)]), ('A', [(2, 10)]), ('I', 14), ('B', [(14, 3), (14, 13)]), ('A', [(14, 3)]), ('I', 9), ('B', [(9, 10), (9, 7), (9, 4)]), ('A', [(9, 4)]), ('I', 5), ('B', [(5, 8), (5, 16), (5, 2), (5, 7)]), ('A', [(5, 8)]), ('I', 12), ('B', [(12, 6), (12, 17)]), ('A', [(6, 12)]), ('I', 7), ('B', [(7, 4), (7, 9), (7, 11), (7, 5), (7, 16), (7, 19)]), ('A', [(16, 7)]), ('I', 11), ('B', [(11, 7), (11, 16), (7, 16)]), ('C', [11, 7, 16]), ('R', None), ('I', 11), ('B', [(16, 5), (7, 9), (7, 4), (7, 19)]), ('A', [(11, 16), (16, 7), (7, 19)]), ('U', [11, 7, 16]), ('I', 17), ('B', [(17, 18), (17, 12)]), ('A', [(17, 18)]), ('I', 13), ('B', [(13, 14), (13, 19)]), ('BO', [(19, 7)]), ('B', [(7, 4), (7, 9), (7, 5), (7, 16), (7, 11)]), ('BO', [(5, 8), (4, 9), (11, 16)]), ('CC', [7, 4, 9]), ('R', None), ('I', 15), ('B', [(15, 2), (15, 1)]), ('BO', [(2, 10), (1, 0)]), ('B', [(10, 9), (10, 18), (10, 6), (9, 4), (4, 7)]), ('BO', [(6, 12), (18, 17), (7, 19)]), ('B', [(12, 17), (19, 13)]), ('A', [(15, 2), (2, 10), (10, 9), (9, 4), (4, 7), (7, 19), (19, 13)]), ('UU', [7, 4, 9]), ('R', None)]\n        g.add_to_back(g.vertices[7])\n        g.add_to_back(g.vertices[16])\n        M = []\n        for operation, argument in operations:\n            if operation == 'R':\n                animate_correct_graph_color(self, g, M)\n            if operation == 'I':\n                self.play(Circumscribe(g.vertices[argument], Circle, color=BFS_COLOR), g.vertices[argument].animate.set_color(BFS_COLOR))\n            if operation[0] == 'B':\n                self.play(*[g.vertices[v].animate.set_color(BFS_COLOR) for v in edgesToVertices(argument)], *[g.edges[e if e in g.edges else (e[1], e[0])].animate.set_color(BFS_COLOR) for e in argument])\n            if operation == 'A':\n                augmenting_path = [e if e in g.edges else (e[1], e[0]) for e in argument]\n                animate_augment_path(self, g, augmenting_path)\n                for i in range(0, len(augmenting_path), 2):\n                    M.append(augmenting_path[i])\n                for i in range(1, len(augmenting_path), 2):\n                    M.remove(augmenting_path[i])\n                animate_correct_graph_color(self, g, M)\n            if operation == 'C':\n                small_random = [1 + i / 10000 for i in range(len(argument))]\n                average = sum((g.vertices[v].get_center() for v in argument)) / len(argument)\n                original_vertices = argument\n                original_positions = [g.vertices[v].get_center() for v in argument]\n                self.play(ApplyFunction(lambda x: match_vertex(x, where=average * small_random[0]), g.vertices[11]), ApplyFunction(lambda x: match_vertex(x, where=average * small_random[1]), g.vertices[7]), ApplyFunction(lambda x: match_vertex(x, where=average * small_random[2]), g.vertices[16]))\n            if operation == 'CC':\n                small_random = [1 + i / 10000 for i in range(len(argument))]\n                average = sum((g.vertices[v].get_center() for v in argument)) / len(argument)\n                original_vertices = argument\n                original_positions = [g.vertices[v].get_center() for v in argument]\n                self.play(ApplyFunction(lambda x: match_vertex(x, where=average * small_random[0]), g.vertices[7]), ApplyFunction(lambda x: match_vertex(x, where=average * small_random[1]), g.vertices[4]), ApplyFunction(lambda x: match_vertex(x, where=average * small_random[2]), g.vertices[9]))\n            if operation == 'U':\n                self.play(ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[0]), g.vertices[11]), ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[1]), g.vertices[7]), ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[2]), g.vertices[16]))\n            if operation == 'UU':\n                self.play(ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[0]), g.vertices[7]), ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[1]), g.vertices[4]), ApplyFunction(lambda x: unmatch_vertex(x, where=original_positions[2]), g.vertices[9]))"}]}
{"messages": [{"role": "user", "content": "Visualize a graph and highlight an augmenting path, then introduce the Blossom Algorithm with a flower icon."}, {"role": "assistant", "content": "from utilities import *\nimport mm.mm\nfrom typing import Tuple, List\nfrom dataclasses import dataclass\n\nclass Thumbnail(MovingCameraScene):\n\n    def construct(self):\n        self.next_section(skip_animations=True)\n        g = parse_graph('\\n1 2 <10.402934501867037, 17.34415069651897> <16.203839106744862, 19.547491168818176>\\n2 3 <16.203839106744862, 19.547491168818176> <22.178420402084758, 17.787256748775246> \\n3 4 <22.178420402084758, 17.787256748775246> <20.774348346247653, 23.755044257314765>\\n2 4 <16.203839106744862, 19.547491168818176> <20.774348346247653, 23.755044257314765>\\n4 5 <20.774348346247653, 23.755044257314765> <27.05817492976113, 23.859707295924565>\\n6 5 <28.449708119653423, 17.768804208250373> <27.05817492976113, 23.859707295924565>\\n4 7 <20.774348346247653, 23.755044257314765> <17.47242508549339, 29.021438342487553>\\n5 8 <27.05817492976113, 23.859707295924565> <31.15502907598739, 28.586235859209886>\\n8 9 <31.15502907598739, 28.586235859209886> <37.31660856822276, 28.245054265211092> \\n6 10 <28.449708119653423, 17.768804208250373> <34.660938508332286, 16.631467003826533>\\n10 11 <34.660938508332286, 16.631467003826533> <40.60957109101587, 18.40703837992414>\\n3 6 <22.178420402084758, 17.787256748775246> <28.449708119653423, 17.768804208250373>\\n5 12 <27.05817492976113, 23.859707295924565> <33.0788344527837, 22.821541250821294>\\n2 13 <16.203839106744862, 19.547491168818176> <12.52911329849324, 24.494238155627645>\\n                ', s=0.12 / NODE_SCALE, t=-0.12 / NODE_SCALE).scale(GRAPH_SCALE * NODE_SCALE).shift(DOWN * 0.65)\n        text = Tex('\\\\large augmenting paths').next_to(g, UP * 3)\n        self.play(Write(text), Write(g))\n        M = [(5, 8), (6, 10), (2, 4)]\n        MV = edgesToVertices(M)\n        self.play(*[ApplyFunction(match_edge, g.edges[e]) for e in M], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for v, _ in M], *[g.vertices[v].animate.set_color(MATCHING_COLOR) for _, v in M], *[g.vertices[v].animate.set_color(EXPOSED_COLOR) for v in g.vertices if v not in MV])\n        animate_augment_path_partial(self, g, [(8, 9), (5, 8), (4, 5), (2, 4), (1, 2)], add_animations_between=[Circumscribe(g.vertices[9], Circle, color=AUGMENTING_COLOR), Circumscribe(g.vertices[1], Circle, color=AUGMENTING_COLOR)])\n        self.play(text.animate.shift(UP * 0.2), g.animate.shift(DOWN * 0.2))\n        text2 = Tex('\\\\scriptsize \\\\em contains an augmenting path $\\\\Leftrightarrow$ matching is not maximum$^{\\\\ast}$').next_to(text, DOWN)\n        box = Tex('$\\\\ast$ proof in description \u2013 theorem 2.4').scale(0.5).align_on_border(UP + RIGHT)\n        frame = SurroundingRectangle(box, color=WHITE, stroke_width=2)\n        self.next_section()\n        text_other = Tex('\\\\Large The Blossom Algorithm').scale(1.3)\n        i = 5\n        text_other[0][i].set_color(BLACK)\n        S = 1.3\n        text_other.scale(S)\n        img = SVGMobject('flower.svg').scale(0.225).move_to(text_other[0][i]).shift(LEFT * 0.02).scale(S)\n        GR = Group(text_other, img).move_to(text).shift(UP * 0.2)\n        self.add(GR)\n        self.remove(text)\n        FG = Group(GR, g)\n        self.camera.frame.move_to(FG).set_height(FG.get_height() * 1.4)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display three different types of graphs, color their vertices, then highlight the maximum clique of a series of induced subgraphs, followed by a tribute to L\u00e1szl\u00f3 Lov\u00e1sz and a list of graph theory definitions."}, {"role": "assistant", "content": "from utilities import *\n\nclass Introduction(Scene):\n\n    @fade\n    def construct(self):\n        a = nx.complete_graph(5)\n        A = Graph.from_networkx(a, layout='circular', layout_scale=0.8).scale(2)\n        A.shift(LEFT * 2.5 + UP * 1.2)\n        b = nx.windmill_graph(3, 4)\n        B = Graph.from_networkx(b, layout='spring', layout_scale=0.8).scale(2)\n        B.shift(RIGHT * 2.5 + UP * 1.2)\n        c = nx.algorithms.bipartite.generators.random_graph(7, 5, 0.5)\n        lt = {i: [(i * 0.5 if i < 7 else (i - 6.5) * 6 / 5 * 0.5) - 3.5 / 2, -2 if i < 7 else -2.6, 0] for i in range(12)}\n        C = Graph.from_networkx(c, layout=lt, layout_scale=0.8).scale(2)\n        self.play(Write(A), Write(B), Write(C))\n        a_coloring = get_coloring(A.vertices, A.edges)\n        b_coloring = get_coloring(B.vertices, B.edges)\n        c_coloring = get_coloring(C.vertices, C.edges)\n        self.play(*[A.vertices[v].animate.set_color(a_coloring[v]) for v in a_coloring], *[B.vertices[v].animate.set_color(b_coloring[v]) for v in b_coloring], *[C.vertices[v].animate.set_color(c_coloring[v]) for v in c_coloring])\n        fade_all(self)\n        g = parse_graph('\\n                1 2 <26.662885174713242, -0.7880518956362271> <20.299615079452142, -2.2027292248396355>\\n                2 3 <20.299615079452142, -2.2027292248396355> <24.56830953315177, -6.584729247606959>\\n                1 3 <26.662885174713242, -0.7880518956362271> <24.56830953315177, -6.584729247606959>\\n                2 4 <20.299615079452142, -2.2027292248396355> <22.271553727598977, 3.6316758770792>\\n                4 5 <22.271553727598977, 3.6316758770792> <17.343615139918665, 7.446951416786913>\\n                2 6 <20.299615079452142, -2.2027292248396355> <13.85481794189012, -3.659900839715152>\\n                6 7 <13.85481794189012, -3.659900839715152> <8.262548996537001, -0.18671408544088353>\\n                7 8 <8.262548996537001, -0.18671408544088353> <11.607524150202432, 5.1194551775136174>\\n                5 8 <17.343615139918665, 7.446951416786913> <11.607524150202432, 5.1194551775136174>\\n                4 9 <22.271553727598977, 3.6316758770792> <28.162799439120477, 5.191593717507401>\\n                1 4 <26.662885174713242, -0.7880518956362271> <22.271553727598977, 3.6316758770792>\\n                9 10 <28.162799439120477, 5.191593717507401> <32.80591827783357, 1.273524410044267>\\n                1 10 <26.662885174713242, -0.7880518956362271> <32.80591827783357, 1.273524410044267>\\n                10 11 <32.80591827783357, 1.273524410044267> <37.171572621859234, 5.723006910222321>\\n                1 12 <26.662885174713242, -0.7880518956362271> <30.779947977758507, -5.495824590447945>\\n                10 13 <32.80591827783357, 1.273524410044267> <38.66223902123862, -0.8626255741213468>\\n                7 17 <8.262548996537001, -0.18671408544088353> <4.952940120341388, 5.132420983952579>\\n                1 9 <26.662885174713242, -0.7880518956362271> <28.162799439120477, 5.191593717507401>\\n                7 19 <8.262548996537001, -0.18671408544088353> <3.791160976605441, -4.557989994527501>\\n                7 20 <8.262548996537001, -0.18671408544088353> <2.027663453810312, 0.5658076528131637>\\n                22 6 <15.494879193803206, -9.683178155518133> <13.85481794189012, -3.659900839715152>\\n                6 21 <13.85481794189012, -3.659900839715152> <10.104081393525236, -8.653103182332902>\\n                ', s=0.11, t=0.11).scale(1.4)\n        self.play(Write(g))\n        isub = list(induced_subgraphs(g.vertices, g.edges))\n        shuffle(isub)\n        isub = [(v, e) for v, e in isub if len(e) > 5]\n        for v, e in isub[:10]:\n            self.play(*[g.vertices[u].animate.set_color(WHITE) for u in v], *[g.edges[f].animate.set_color(WHITE) for f in e], *[g.vertices[u].animate.set_color(dark_color) for u in g.vertices if u not in v], *[g.edges[f].animate.set_color(dark_color) for f in g.edges if f not in e])\n            coloring = get_coloring(v, e)\n            self.play(*[g.vertices[v].animate.set_color(coloring[v]) for v in coloring])\n            maximum_clique = get_maximum_clique(v, e)\n            self.play(*[g.vertices[u].animate.set_color(WHITE) for u in v], *[g.edges[f].animate.set_color(WHITE) for f in e], *[g.vertices[u].animate.set_color(dark_color) for u in g.vertices if u not in v], *[g.edges[f].animate.set_color(dark_color) for f in g.edges if f not in e], *[g.vertices[u].animate.set_color(YELLOW) for u in maximum_clique], *[g.edges[u, v].animate.set_color(YELLOW) for u, v in e if u in maximum_clique and v in maximum_clique], *[Circumscribe(g.vertices[u], Circle) for u in maximum_clique])\n        fade_all(self)\n        text = Tex('\\\\Large L\u00e1szl\u00f3 Lov\u00e1sz (1972)').shift(UP * 2.3)\n        image = SVGMobject('laszlo.svg').scale(2.7).shift(1.4 * DOWN + RIGHT * 0.7)\n        self.play(Write(text), Write(image, run_time=3.5))\n        self.play(FadeOut(text), FadeOut(image))\n        title = Tex('\\\\Large Definitions')\n        title.shift(UP * 2.3)\n        self.play(Write(title))\n        text = [[Tex('Complement graph'), Tex('$\\\\overline{G}$')], [Tex('Clique, independent set'), Tex('$\\\\omega(G), \\\\alpha(G)$')], [Tex('(Proper) induced subgraph'), Tex('$H \\\\leqslant G$, $H < G$')], [Tex('Chromatic number'), Tex('$\\\\chi(G)$')], [Tex('Perfect graph'), Tex('$G_{\\\\star}$')]]\n        text[0][0].align_to(ORIGIN, RIGHT).shift(LEFT * 0.3 + UP * 0.7 + RIGHT * 1.1)\n        text[0][1].align_to(ORIGIN, LEFT).shift(RIGHT * 0.3 + UP * 0.7 + RIGHT * 1.1)\n        for i in range(1, len(text)):\n            text[i][0].next_to(text[i - 1][0], DOWN).align_to(ORIGIN, RIGHT).shift(LEFT * 0.3 + RIGHT * 1.1)\n            text[i][1].next_to(text[i - 1][1], DOWN).align_to(ORIGIN, LEFT).shift(RIGHT * 0.3 + RIGHT * 1.1)\n        self.play(*[Write(i[0], run_time=1) for i in text])\n        self.play(Write(Line(UP * 1.3, DOWN * 2.1).shift(RIGHT * 1.1 + DOWN * 0.3)))\n        self.play(*[Write(i[1].set_color(YELLOW), run_time=1.0) for i in text])"}]}
{"messages": [{"role": "user", "content": "Demonstrate the definition of a graph complement by showing a graph G and its complement $\\overline{G}$, highlighting the relationship between their edges."}, {"role": "assistant", "content": "from utilities import *\n\nclass Complement(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Graph complement')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 2.5))\n        duration, text = createHighlightedParagraph('A ', 'complement', ' of a graph', ' $G$ ', 'is a graph ', '$\\\\overline{G}$', ', such that ', 'each two vertices', ' are adjacent in ', '$\\\\overline{G}$', ', if and only if they are ', 'not adjacent', ' in ', '$G$', '.', size='\\\\footnotesize')\n        text.next_to(title, 2 * DOWN)\n        self.play(Write(text), run_time=duration)\n        vertices = [1, 2, 3, 4, 5]\n        edges = [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n        gg = Graph(vertices, edges, layout='circular', layout_scale=0.6).scale(2)\n        gg.shift(DOWN * 1.75 + LEFT * 2.5)\n        hh = Graph(vertices, edges, layout='circular', layout_scale=0.6).scale(2)\n        hh.shift(DOWN * 1.75 + RIGHT * 2.5)\n        g_edges = [(1, 2), (1, 5), (2, 4), (2, 5), (3, 4)]\n        g = Graph(vertices, g_edges, layout='circular', layout_scale=0.6).scale(2)\n        g.shift(DOWN * 1.75 + LEFT * 2.5)\n        g_text = Tex('G')\n        g_text.next_to(g, RIGHT + UP).shift(DOWN * 0.8 + LEFT * 0.6)\n        h_edges = [(1, 3), (1, 4), (2, 3), (3, 5), (4, 5)]\n        h = Graph(vertices, h_edges, layout='circular', layout_scale=0.6).scale(2)\n        h.shift(DOWN * 1.75 + RIGHT * 2.5)\n        h_text = Tex('$\\\\overline{G}$')\n        h_text.next_to(h, RIGHT + UP).shift(DOWN * 0.8 + LEFT * 0.6)\n        self.play(Write(g), Write(g_text), Write(h), Write(h_text))\n        self.play(FadeOut(g.edges[1, 2]), FadeIn(hh.edges[1, 2]))\n        self.play(FadeOut(g.edges[2, 5]), FadeIn(hh.edges[2, 5]))\n        self.play(FadeOut(h.edges[1, 4]), FadeIn(gg.edges[1, 4]))\n        self.play(FadeOut(h.edges[3, 5]), FadeIn(gg.edges[3, 5]))"}]}
{"messages": [{"role": "user", "content": "Explain and visualize graph theory concepts of cliques and independent sets with color-coded vertex highlighting."}, {"role": "assistant", "content": "from utilities import *\n\nclass CliqueAndIndependentSet(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Clique and independent set')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 2.5))\n        duration, text = createHighlightedParagraph('A ', 'clique', ' is a ', 'subgraph', ' of a graph, such that ', 'each two vertices are adjacent.', ' Analogically, an ', 'independent set', ' of a graph is a ', 'set of vertices', ' such that ', 'no two are adjacent.', size='\\\\footnotesize')\n        text.next_to(title, 2 * DOWN)\n        self.play(Write(text[:6]), run_time=duration / 2)\n        s = 0.13\n        lt = {1: [47.38483438230261, 14.060368360180616, 0], 2: [47.04426001805368, 21.347487665146264, 0], 3: [50.9944860441275, 17.87959586965124, 0], 4: [43.473770252465194, 17.531227666811304, 0], 5: [55.79878824615697, 21.754965041566994, 0], 6: [56.88020523754154, 15.782897747658021, 0], 7: [62.40430614599554, 13.054510220630755, 0], 8: [37.189798625724194, 17.32866367272487, 0], 9: [31.926414399437974, 14.144547277873158, 0], 10: [31.749162068885, 20.199682815964888, 0]}\n        lt_avg_x = 0\n        lt_avg_y = 0\n        for i in lt:\n            lt_avg_x += lt[i][0]\n            lt_avg_y += lt[i][1]\n        lt_avg_x /= len(lt)\n        lt_avg_y /= len(lt)\n        for i in lt:\n            lt[i] = ((lt[i][0] - lt_avg_x) * s, (lt[i][1] - lt_avg_y) * s, 0)\n        vertices = [i + 1 for i in range(10)]\n        edges = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4), (3, 5), (3, 6), (5, 6), (6, 7), (4, 8), (8, 9), (9, 10), (8, 10)]\n        g = Graph(vertices, edges, layout=lt).scale(2)\n        g.shift(DOWN * 1.65)\n        self.play(Write(g))\n\n        def to_color(color):\n            return [g.vertices[i].animate.set_color(color) for i in vertices] + [g.edges[e].animate.set_color(color) for e in edges]\n\n        def to_color_animate(g, color, no_vertices=False):\n            return ([g.vertices[i].animate.set_color(color) for i in g.vertices] if not no_vertices else []) + [g.edges[e].animate.set_color(color) for e in g.edges]\n\n        def to_color_no_animate(g, color):\n            [g.vertices[i].set_color(color) for i in g.vertices]\n            [g.edges[e].set_color(color) for e in g.edges]\n        self.play(*to_color(dark_color), g.vertices[8].animate.set_color(WHITE), g.vertices[9].animate.set_color(WHITE), g.vertices[10].animate.set_color(WHITE), g.edges[8, 9].animate.set_color(WHITE), g.edges[8, 10].animate.set_color(WHITE), g.edges[9, 10].animate.set_color(WHITE))\n        self.play(*to_color(dark_color), g.vertices[5].animate.set_color(WHITE), g.vertices[6].animate.set_color(WHITE), g.edges[5, 6].animate.set_color(WHITE))\n        self.play(*to_color(dark_color), g.vertices[1].animate.set_color(WHITE), g.vertices[2].animate.set_color(WHITE), g.vertices[3].animate.set_color(WHITE), g.vertices[4].animate.set_color(WHITE), g.edges[1, 2].animate.set_color(WHITE), g.edges[1, 3].animate.set_color(WHITE), g.edges[1, 4].animate.set_color(WHITE), g.edges[2, 3].animate.set_color(WHITE), g.edges[2, 4].animate.set_color(WHITE), g.edges[3, 4].animate.set_color(WHITE))\n        self.play(*to_color(WHITE))\n        self.play(Write(text[6:]), run_time=duration / 2)\n        self.play(*to_color(dark_color), g.vertices[8].animate.set_color(WHITE), g.vertices[2].animate.set_color(WHITE), g.vertices[6].animate.set_color(WHITE))\n        self.play(*to_color(dark_color), g.vertices[10].animate.set_color(WHITE), g.vertices[7].animate.set_color(WHITE))\n        self.play(*to_color(dark_color), g.vertices[9].animate.set_color(WHITE), g.vertices[4].animate.set_color(WHITE), g.vertices[5].animate.set_color(WHITE), g.vertices[7].animate.set_color(WHITE))\n        self.play(*to_color(WHITE))\n        omega = Tex('$\\\\omega$(G) = 4')\n        omega.next_to(g).shift(UP + LEFT * 1.7)\n        alpha = Tex('$\\\\alpha$(G) = 4')\n        alpha.next_to(omega, DOWN)\n        self.play(g.animate.shift(LEFT))\n        self.play(Write(omega))\n        self.play(*to_color(dark_color), g.vertices[1].animate.set_color(WHITE), g.vertices[2].animate.set_color(WHITE), g.vertices[3].animate.set_color(WHITE), g.vertices[4].animate.set_color(WHITE), g.edges[1, 2].animate.set_color(WHITE), g.edges[1, 3].animate.set_color(WHITE), g.edges[1, 4].animate.set_color(WHITE), g.edges[2, 3].animate.set_color(WHITE), g.edges[2, 4].animate.set_color(WHITE), g.edges[3, 4].animate.set_color(WHITE))\n        self.play(*to_color(WHITE))\n        self.play(Write(alpha))\n        self.play(*to_color(dark_color), g.vertices[9].animate.set_color(WHITE), g.vertices[4].animate.set_color(WHITE), g.vertices[5].animate.set_color(WHITE), g.vertices[7].animate.set_color(WHITE))\n        fade_all(self)\n        seed(2)\n        a = nx.gnm_random_graph(7, 11)\n        A = Graph.from_networkx(a, layout='circular', layout_scale=1.3).scale(2)\n        b = nx.algorithms.operators.unary.complement(a)\n        B = Graph.from_networkx(b, layout='circular', layout_scale=1.3).scale(2)\n        C = Graph.from_networkx(b, layout='circular', layout_scale=1.3).scale(2)\n        (C.vertices[3].set_color(YELLOW),)\n        (C.vertices[4].set_color(YELLOW),)\n        (C.vertices[5].set_color(YELLOW),)\n        to_color_no_animate(B, dark_color)\n        self.play(Write(B), Write(A))\n        self.play(A.vertices[3].animate.set_color(YELLOW), A.vertices[4].animate.set_color(YELLOW), A.vertices[5].animate.set_color(YELLOW), A.edges[3, 4].animate.set_color(YELLOW), A.edges[3, 5].animate.set_color(YELLOW), A.edges[4, 5].animate.set_color(YELLOW))\n        self.play(*to_color_animate(A, dark_color, True), *to_color_animate(B, WHITE), A.edges[3, 4].animate.set_color('#3a4504'), A.edges[3, 5].animate.set_color('#3a4504'), A.edges[4, 5].animate.set_color('#3a4504'), FadeIn(C))"}]}
{"messages": [{"role": "user", "content": "Display the definition of an induced subgraph and a graph, then highlight vertices and edges to illustrate proper induced subgraphs."}, {"role": "assistant", "content": "from utilities import *\n\nclass InducedSubgraph(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Induced subgraph')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 2.5))\n        duration, text = createHighlightedParagraph('A graph ', '$H$', ' is an ', 'induced subgraph', ' of ', '$G$', ' (denoted ', '$H \\\\leqslant G$', '), if and only if we can get ', '$H$', ' by ', 'removing ', 'zero', ' or more vertices', ' from ', '$G$', '.', size='\\\\footnotesize')\n        text.next_to(title, 2 * DOWN)\n        text[12].set_color(YELLOW)\n        self.play(Write(text), run_time=duration)\n        g = parse_graph('\\n                1 2 <38.80574387665646, 19.075436670793508> <44.36083840295738, 21.761815830298648>\\n                3 2 <39.179534414192304, 25.113064293143765> <44.36083840295738, 21.761815830298648>\\n                1 3 <38.80574387665646, 19.075436670793508> <39.179534414192304, 25.113064293143765>\\n                2 4 <44.36083840295738, 21.761815830298648> <47.96770691008718, 16.796776284879865>\\n                5 4 <50.597978972573785, 22.308728990261567> <47.96770691008718, 16.796776284879865>\\n                2 5 <44.36083840295738, 21.761815830298648> <50.597978972573785, 22.308728990261567>\\n                5 6 <50.597978972573785, 22.308728990261567> <56.88123963001803, 22.427996649354146>\\n                7 6 <60.146402953578516, 27.05692805463163> <56.88123963001803, 22.427996649354146>\\n                8 6 <60.7674389075905, 17.639989234646468> <56.88123963001803, 22.427996649354146>\\n                4 9 <47.96770691008718, 16.796776284879865> <54.11963143013985, 16.08659783621831>\\n                10 5 <46.18150790504464, 26.93894486536683> <50.597978972573785, 22.308728990261567>\\n                5 11 <50.597978972573785, 22.308728990261567> <53.97483357793314, 27.358585478522365>\\n                3 12 <39.179534414192304, 25.113064293143765> <33.482340851356376, 21.51217934696702>\\n                3 13 <39.179534414192304, 25.113064293143765> <33.81193012353412, 26.76776402287787>\\n                7 11 <60.146402953578516, 27.05692805463163> <53.97483357793314, 27.358585478522365>\\n                6 14 <56.88123963001803, 22.427996649354146> <63.959335631709266, 22.318577453431747>\\n                6 11 <56.88123963001803, 22.427996649354146> <53.97483357793314, 27.358585478522365>\\n                1 15 <38.80574387665646, 19.075436670793508> <33.877160014577754, 15.820817608659894>\\n                ', s=0.13, t=0.11)\n        g.shift(DOWN * 1.65)\n        self.play(Write(g))\n\n        def to_color(color):\n            return [g.vertices[i].animate.set_color(color) for i in vertices] + [g.edges[e].animate.set_color(color) for e in edges]\n        take = (2, 5, 6, 11, 10, 7)\n        self.play(*[g.vertices[v].animate.set_color(dark_color) for v in g.vertices if v not in take], *[g.edges[u, v].animate.set_color(dark_color) for u, v in g.edges if u not in take or v not in take])\n        take = (1, 2, 3, 15, 4, 6, 7, 8, 14)\n        self.play(*[g.vertices[v].animate.set_color(WHITE) for v in g.vertices], *[g.edges[u, v].animate.set_color(WHITE) for u, v in g.edges], *[g.vertices[v].animate.set_color(dark_color) for v in g.vertices if v not in take], *[g.edges[u, v].animate.set_color(dark_color) for u, v in g.edges if u not in take or v not in take])\n        take = (2, 3, 13, 12, 5, 6, 8, 14)\n        self.play(*[g.vertices[v].animate.set_color(WHITE) for v in g.vertices], *[g.edges[u, v].animate.set_color(WHITE) for u, v in g.edges], *[g.vertices[v].animate.set_color(dark_color) for v in g.vertices if v not in take], *[g.edges[u, v].animate.set_color(dark_color) for u, v in g.edges if u not in take or v not in take])\n        sis = Tex('\\\\footnotesize proper ind. subg.').set_color(YELLOW)\n        sis.move_to(text[3])\n        subset = Tex('\\\\footnotesize $H < G$').set_color(YELLOW)\n        subset.move_to(text[7]).shift(UP * 0.024)\n        one = Tex('\\\\footnotesize one').set_color(YELLOW)\n        one.move_to(text[12])\n        title2 = Tex('\\\\Large Proper induced subgraph')\n        title2.move_to(title)\n        self.play(Unwrite(title), Write(title2), run_time=1.0)\n        self.play(Unwrite(text[3]), Write(sis), run_time=1.0)\n        self.play(Unwrite(text[7]), Write(subset), run_time=1.0)\n        self.play(Unwrite(text[12]), Write(one), run_time=1.0)"}]}
{"messages": [{"role": "user", "content": "Define the chromatic number of a graph and then visualize it by coloring the vertices of a sample graph."}, {"role": "assistant", "content": "from utilities import *\n\nclass ChromaticNumber(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Chromatic number')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 2.5))\n        duration, text = createHighlightedParagraph('The ', 'chromatic number $\\\\chi(G)$', ' of a graph ', '$G$', ' is the ', 'minimum number of colors', \" we can use to color the graph's \", 'vertices', ', such that ', 'no two adjacent vertices', ' have the ', 'same color.', '', size='\\\\footnotesize')\n        text.next_to(title, 2 * DOWN)\n        self.play(Write(text), run_time=duration)\n        g = parse_graph('\\n                1 2 <28.673998493774764, 16.11549026915917> <23.425160412282423, 19.234907822119965>\\n                3 2 <28.802200340160894, 22.148748965846544> <23.425160412282423, 19.234907822119965>\\n                4 3 <34.11064204718341, 19.008283942135677> <28.802200340160894, 22.148748965846544>\\n                4 1 <34.11064204718341, 19.008283942135677> <28.673998493774764, 16.11549026915917>\\n                1 3 <28.673998493774764, 16.11549026915917> <28.802200340160894, 22.148748965846544>\\n                4 5 <34.11064204718341, 19.008283942135677> <40.414236285526336, 19.051169376775814>\\n                6 5 <36.96163252070064, 24.339334636825303> <40.414236285526336, 19.051169376775814>\\n                5 7 <40.414236285526336, 19.051169376775814> <45.48388231995395, 15.29263869607948>\\n                7 8 <45.48388231995395, 15.29263869607948> <39.14682477691944, 13.282261820358185>\\n                5 9 <40.414236285526336, 19.051169376775814> <45.87721692607333, 21.935623154984626>\\n                9 10 <45.87721692607333, 21.935623154984626> <49.89797067751592, 18.570427080407676>\\n                10 11 <49.89797067751592, 18.570427080407676> <54.13724365458039, 15.423750231452608>\\n                11 12 <54.13724365458039, 15.423750231452608> <54.18094749970476, 21.935623154984626>\\n                9 12 <45.87721692607333, 21.935623154984626> <54.18094749970476, 21.935623154984626>\\n                1 13 <28.673998493774764, 16.11549026915917> <23.457144377268467, 13.325965665482563>\\n                2 14 <23.425160412282423, 19.234907822119965> <22.583067474780947, 24.557853862447182>\\n                ', s=0.1, t=0.1)\n        g.shift(DOWN * 1.7)\n        self.play(Write(g))\n        coloring = get_coloring(g.vertices, g.edges)\n        self.play(*[g.vertices[v].animate.set_color(coloring[v]) for v in coloring])\n        self.play(g.animate.shift(LEFT * 1.3))\n        chi = Tex('$\\\\chi$(G) = 3')\n        chi.next_to(g, RIGHT).shift(RIGHT * 0.5)\n        self.play(Write(chi))"}]}
{"messages": [{"role": "user", "content": "Display the definition of a perfect graph, then animate a graph transformation demonstrating the lemma with vertex coloring and highlighting."}, {"role": "assistant", "content": "from utilities import *\n\nclass Lemma1(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Lemma 1')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 1))\n        duration, text = createHighlightedParagraph('A graph |$G$| is |perfect|, if and only if |$\\\\forall H \\\\leqslant G$| contains an |independent set|, such that |each maximum clique in $H$| contains a v|ertex f|rom this set (called a v|ast independent set)|..', size='\\\\footnotesize', splitBy='|')\n        text.next_to(title, 2 * DOWN)\n        self.play(Write(text), run_time=duration)\n        self.play(FadeOut(title))\n        self.play(text.animate.shift(UP * 3.3))\n        l1 = Line(LEFT * 10, RIGHT * 10).next_to(text, DOWN).shift(DOWN * 0.12)\n        self.play(Write(l1))\n        s = 0.13\n        t = 0.13\n        lt = {1: [37.07173774694345, 24.513069552487252, 0], 2: [42.21727425459074, 27.84392529421318, 0], 3: [36.61427318962413, 30.571308404791655, 0], 4: [48.00554555844992, 30.421376085990417, 0], 5: [53.19846946334912, 27.223933155066213, 0], 6: [47.5677835794533, 24.649184796285315, 0], 7: [52.438226317756744, 21.183244775108147, 0], 8: [59.343089264946734, 28.60991123463918, 0], 9: [65.13351173235914, 26.519184930589873, 0], 10: [64.1236082388095, 32.48951997100356, 0], 11: [55.00129702910227, 33.20668506985356, 0], 12: [59.047410413208894, 23.030623084674833, 0], 13: [42.182298604016225, 20.996876352207323, 0], 14: [42.84315130315794, 34.07480345101175, 0]}\n        lt_avg_x = 0\n        lt_avg_y = 0\n        for i in lt:\n            lt_avg_x += lt[i][0]\n            lt_avg_y += lt[i][1]\n        lt_avg_x /= len(lt)\n        lt_avg_y /= len(lt)\n        for i in lt:\n            lt[i] = ((lt[i][0] - lt_avg_x) * s, (lt[i][1] - lt_avg_y) * t, 0)\n        vertices = [i + 1 for i in range(14)]\n        edges = [(1, 2), (2, 3), (1, 3), (2, 4), (4, 5), (6, 5), (2, 6), (5, 7), (6, 7), (5, 8), (9, 8), (10, 9), (10, 8), (11, 4), (9, 12), (1, 13), (3, 14)]\n        g = Graph(vertices, edges, layout=lt).scale(2)\n        g.shift(DOWN * 1.1)\n        ri = Tex('$\\\\Huge\\\\Rightarrow$').shift(UP * 1.2)\n        li = Tex('$\\\\Huge\\\\Leftarrow$').shift(UP * 1.2)\n        self.play(Write(ri))\n        self.play(Write(g))\n        coloring = get_coloring(g.vertices, g.edges)\n        self.play(*[g.vertices[v].animate.set_color(coloring[v]) for v in coloring])\n        take = (1, 2, 3, 8, 9, 10, 5, 6, 7)\n        self.play(*[g.vertices[v].animate.set_color(dark_color) for v in vertices if v not in take], *[g.edges[a, b].animate.set_color(dark_color) for a, b in edges if a not in take or b not in take], g.edges[5, 8].animate.set_color(dark_color), g.edges[2, 6].animate.set_color(dark_color))\n        take2 = (9, 6, 3)\n        self.play(*[g.vertices[v].animate.set_color(WHITE) for v in vertices if v not in take2 and v in take], *[g.vertices[v].animate.set_color(YELLOW) for v in vertices if v in take2], *[Circumscribe(g.vertices[v], Circle, fade_out=True) for v in vertices if v in take2])\n        self.play(FadeOut(g))\n        self.play(Transform(ri, li))\n        wow = Graph([0], []).scale(2).shift(DOWN * 0.3)\n        self.play(Write(wow))\n        s = 0.13\n        t = 0.13\n        lt = {1: [15.309880071637778, 13.88267275823302, 0], 2: [11.152629866734753, 18.473208465522124, 0], 3: [21.533770509017973, 14.062269409469383, 0], 4: [27.653696990616425, 14.33728783167967, 0], 5: [24.379606335811236, 19.510373877028115, 0], 6: [20.128537819154758, 24.02595082531033, 0], 7: [13.899970073784655, 24.08450707296808, 0], 8: [9.21073459378905, 28.051299475263892, 0], 9: [17.983654838438074, 18.871973067254114, 0], 10: [26.376723806437678, 27.54463130743147, 0], 11: [30.093540665815272, 21.669662723253982, 0], 12: [5.894245809297855, 20.83448131841834, 0], 13: [6.894245809297855, 13.784481318418347, 0]}\n        lt_avg_x = 0\n        lt_avg_y = 0\n        for i in lt:\n            lt_avg_x += lt[i][0]\n            lt_avg_y += lt[i][1]\n        lt_avg_x /= len(lt)\n        lt_avg_y /= len(lt)\n        for i in lt:\n            lt[i] = ((lt[i][0] - lt_avg_x) * s, (lt[i][1] - lt_avg_y) * t, 0)\n        vertices = [i + 1 for i in range(13)]\n        edges = [(1, 2), (1, 3), (4, 3), (4, 5), (3, 5), (6, 5), (6, 7), (2, 7), (8, 7), (6, 9), (10, 6), (11, 5), (2, 9), (1, 9), (2, 12), (2, 13)]\n        h = Graph(vertices, edges, layout=lt).scale(2)\n        h.shift(DOWN * 1.1)\n        h2 = Graph(vertices, edges, layout=lt).scale(2)\n        h2.shift(DOWN * 1.1)\n        take = (9, 4)\n        gt = Tex('$G$').shift(RIGHT * 3.5 + UP * 0.2)\n        ht = Tex('$H$').shift(RIGHT * 3.5 + UP * 0.2)\n        gt_p = Tex('$G_\\\\star$').shift(RIGHT * 3.5 + UP * 0.2)\n        ht_p = Tex('$H_\\\\star$').shift(RIGHT * 3.5 + UP * 0.2)\n        self.play(Transform(wow, h))\n        self.play(Write(gt))\n        self.play(*[h.vertices[i].animate.set_color(YELLOW) for i in take], *[Circumscribe(h.vertices[i], Circle) for i in take])\n        self.play(FadeOut(h.vertices[take[0]]), FadeOut(h.vertices[take[1]]))\n        self.add(h2)\n        self.remove(wow)\n        self.play(*[FadeOut(h2.vertices[v]) for v in take], *[FadeOut(h2.edges[u, v]) for u, v in h2.edges if u in take or v in take], Transform(gt, ht))\n        coloring = [BLUE, RED, RED, GREEN, BLUE, RED, BLUE, RED, GREEN, BLUE, RED, BLUE, BLUE]\n        self.play(*[h2.vertices[v].animate.set_color(coloring[v - 1]) for v in h2.vertices if v not in take], Transform(gt, ht_p))\n        self.play(*[FadeIn(h2.vertices[v].set_color(GREEN)) for v in take], *[FadeIn(h2.edges[u, v]) for u, v in h2.edges if u in take or v in take], Transform(gt, gt_p))"}]}
{"messages": [{"role": "user", "content": "Animate the transformation of a graph to demonstrate vertex expansion and coloring."}, {"role": "assistant", "content": "from utilities import *\n\nclass Lemma2(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Lemma 2')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 1))\n        duration, text = createHighlightedParagraph('A graph |$G$| is |perfect|, then any graph constructed from |$G$| by |expanding| a vertex is also |perfect|.', size='\\\\footnotesize', splitBy='|')\n        text.next_to(title, 2 * DOWN)\n        self.play(Write(text), run_time=duration)\n        self.play(FadeOut(title))\n        self.play(text.animate.shift(UP * 3.3))\n        kp = Tex('$K_3$')\n        l1 = Line(LEFT * 10, RIGHT * 10).next_to(text, DOWN).shift(DOWN * 0.12)\n        self.play(Write(l1))\n        s = 0.16\n        t = 0.16\n        lt = {1: [-12.029991806683347, 4.322127883398239, 0], 2: [-12.076574068953635, -1.7412590025323897, 0], 3: [-6.720733101887893, 1.2500538046558693, 0], 4: [-0.49692711688713764, 1.1491474582769117, 0], 5: [4.580001507046976, 5.772457897171072, 0], 6: [2.8472799643190907, -5.4330886795147935, 0], 7: [10.056125142803856, 5.6897045204928, 0], 8: [6.62012252897766, -0.5945984711319062, 0], 9: [10.98788525283437, -4.414560016084881, 0], 10: [-4.057687247555594, -5.415416431868287, 0], 11: [-6.465793761818169, 6.59644290985542, 0]}\n        lt2 = {1: [-12.029991806683347, 4.322127883398239, 0], 2: [-12.076574068953635, -1.7412590025323897, 0], 3: [-6.720733101887893, 1.2500538046558693, 0], 4: [-0.8722482728059152, 2.341019980268004, 0], 5: [4.580001507046976, 5.772457897171072, 0], 6: [2.8472799643190907, -5.4330886795147935, 0], 7: [10.056125142803856, 5.6897045204928, 0], 8: [6.62012252897766, -0.5945984711319062, 0], 9: [10.98788525283437, -4.414560016084881, 0], 10: [-4.057687247555594, -5.415416431868287, 0], 11: [-6.465793761818169, 6.59644290985542, 0], 12: [-1.5366450936795812, -1.6601239954250642, 0], 13: [2.318809025203322, 0.06587271750884371, 0]}\n        lt_avg_x = 0\n        lt_avg_y = 0\n        for i in lt:\n            lt_avg_x += lt[i][0]\n            lt_avg_y += lt[i][1]\n        lt_avg_x /= len(lt)\n        lt_avg_y /= len(lt)\n        for i in lt:\n            lt[i] = ((lt[i][0] - lt_avg_x) * s, (lt[i][1] - lt_avg_y) * t, 0)\n        for i in lt2:\n            lt2[i] = ((lt2[i][0] - lt_avg_x) * s, (lt2[i][1] - lt_avg_y) * t, 0)\n        vertices = [i + 1 for i in range(11)]\n        vertices2 = [3, 4, 5, 6, 12, 13]\n        edges = [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5), (4, 6), (5, 7), (6, 8), (9, 8), (6, 10), (1, 11)]\n        edges2 = [(u, v) for u, v in [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5), (4, 6), (5, 7), (6, 8), (9, 8), (6, 10), (1, 11), (4, 12), (13, 12), (4, 13), (3, 12), (3, 13), (13, 6), (6, 12), (13, 5), (5, 12)] if u in vertices2 and v in vertices2]\n        g = Graph(vertices, edges, layout=lt).scale(2)\n        g2 = Graph(vertices2, edges2, layout=lt2).scale(2)\n        g.shift(DOWN * 0.8)\n        g2.shift(g.vertices[3].get_center() - g2.vertices[3].get_center())\n        g.vertices[4].set_color(YELLOW)\n        g2.vertices[4].set_color(YELLOW)\n        g2.vertices[12].set_color(YELLOW)\n        g2.vertices[13].set_color(YELLOW)\n        self.play(Write(g))\n        self.play(Circumscribe(g.vertices[4], Circle))\n        group = VGroup(g2.vertices[4], g2.vertices[12], g2.vertices[13])\n        self.play(FadeTransform(g.vertices[4], group), *[FadeOut(g.edges[u, v]) for u, v in edges if u == 4 or v == 4], *[FadeIn(g2.edges[u, v]) for u, v in g2.edges], *[FadeIn(g2.vertices[v]) for v in g2.vertices if v not in (4, 12, 13)], Write(kp.next_to(g2.vertices[4], UP).set_color(YELLOW)))\n        self.remove(group)\n        self.play(FadeOut(g2), *[FadeOut(g.edges[u, v]) for u, v in edges if u != 4 and v != 4], *[FadeOut(g.vertices[v]) for v in vertices if v != 4], FadeOut(kp))\n        graphs = [Graph.from_networkx(nx.complete_graph(1), layout='circular', layout_scale=0.4).scale(2).shift(DOWN * 0.6), Graph.from_networkx(nx.complete_graph(2), layout='circular', layout_scale=0.4).scale(2).shift(DOWN * 0.6), Graph.from_networkx(nx.complete_graph(3), layout='circular', layout_scale=0.4).scale(2).shift(DOWN * 0.6)]\n        self.play(Write(graphs[0]))\n        for g in graphs[1:]:\n            self.play(Transform(graphs[0], g))\n        self.play(FadeOut(graphs[0]))\n        g = Graph.from_networkx(nx.complete_graph(1), layout='circular', layout_scale=0.4).scale(2).shift(DOWN * 0.6)\n        h = Graph.from_networkx(nx.complete_graph(2), layout='circular', layout_scale=0.4).scale(2).shift(DOWN * 0.6)\n        self.play(Write(g))\n        self.play(FadeTransform(g, h))\n        coloring = get_coloring(h.vertices, h.edges)\n        self.play(*[h.vertices[v].animate.set_color(coloring[v]) for v in coloring])\n        self.play(FadeOut(h))\n        s = 0.16\n        t = 0.16\n        lt = {1: [31.8034087985056, 21.180454392536536, 0], 2: [34.609439649137066, 15.785461954390827, 0], 3: [38.18419657345534, 20.835063248552107, 0], 4: [35.213109065971565, 26.23652372171837, 0], 5: [44.76233477480106, 20.86973516627854, 0], 6: [48.690086325063504, 16.052131276509638, 0], 7: [51.07614064122136, 21.579182218042003, 0], 8: [47.708359547565784, 26.402544082922805, 0], 9: [41.97052991769025, 15.384911836633577, 0], 10: [41.26645957589335, 26.325346343930015, 0], 11: [57.17698377454542, 22.616073172202213, 0], 12: [26.569111783890147, 24.5420949338908, 0], 13: [26.563703898682927, 17.828541284261505, 0]}\n        lt2 = {1: [31.8034087985056, 21.180454392536536, 0], 2: [34.609439649137066, 15.785461954390827, 0], 3: [38.18419657345534, 20.835063248552107, 0], 4: [35.213109065971565, 26.23652372171837, 0], 5: [44.76233477480106, 20.86973516627854, 0], 6: [48.690086325063504, 16.052131276509638, 0], 7: [51.07614064122136, 21.579182218042003, 0], 8: [47.708359547565784, 26.402544082922805, 0], 9: [41.97052991769025, 15.384911836633577, 0], 10: [41.26645957589335, 26.325346343930015, 0], 11: [57.17698377454542, 22.616073172202213, 0], 12: [26.569111783890147, 24.5420949338908, 0], 13: [26.563703898682927, 17.828541284261505, 0], 14: [53.55910399699539, 26.968055538883853, 0]}\n        lt3 = {1: [31.8034087985056, 21.180454392536536, 0], 2: [31.16604926939867, 15.750680233383367, 0], 3: [38.18419657345534, 20.835063248552107, 0], 4: [35.213109065971565, 26.23652372171837, 0], 5: [44.76233477480106, 20.86973516627854, 0], 6: [48.690086325063504, 16.052131276509638, 0], 7: [51.07614064122136, 21.579182218042003, 0], 8: [47.708359547565784, 26.402544082922805, 0], 9: [41.97052991769025, 15.384911836633577, 0], 10: [41.26645957589335, 26.325346343930015, 0], 11: [57.17698377454542, 22.616073172202213, 0], 12: [26.569111783890147, 24.5420949338908, 0], 13: [26.563703898682927, 17.828541284261505, 0], 14: [36.96822307643766, 15.350960722392697, 0]}\n        lt_avg_x = 0\n        lt_avg_y = 0\n        for i in lt:\n            lt_avg_x += lt[i][0]\n            lt_avg_y += lt[i][1]\n        lt_avg_x /= len(lt)\n        lt_avg_y /= len(lt)\n        for i in lt:\n            lt[i] = ((lt[i][0] - lt_avg_x) * s, (lt[i][1] - lt_avg_y) * t, 0)\n        for i in lt2:\n            lt2[i] = ((lt2[i][0] - lt_avg_x) * s, (lt2[i][1] - lt_avg_y) * t, 0)\n        for i in lt3:\n            lt3[i] = ((lt3[i][0] - lt_avg_x) * s, (lt3[i][1] - lt_avg_y) * t, 0)\n        vertices = [i + 1 for i in range(13)]\n        vertices2 = [7, 11, 14]\n        vertices3 = [1, 2, 3, 14]\n        edges = [(1, 2), (3, 4), (1, 4), (3, 2), (3, 1), (3, 5), (5, 6), (5, 7), (6, 7), (5, 8), (5, 9), (10, 4), (7, 11), (1, 12), (1, 13)]\n        edges2 = [(u, v) for u, v in [(1, 2), (3, 4), (1, 4), (3, 2), (3, 1), (3, 5), (5, 6), (5, 7), (6, 7), (5, 8), (5, 9), (10, 4), (7, 11), (1, 12), (1, 13), (11, 14), (7, 14)] if u in vertices2 and v in vertices2]\n        edges3 = [(u, v) for u, v in [(1, 2), (3, 4), (1, 4), (3, 2), (3, 1), (3, 5), (5, 6), (5, 7), (6, 7), (5, 8), (5, 9), (10, 4), (7, 11), (1, 12), (1, 13), (11, 14), (1, 14), (2, 14), (3, 14)] if u in vertices3 and v in vertices3]\n        g = Graph(vertices, edges, layout=lt).scale(2)\n        g.shift(DOWN * 0.8)\n        g2 = Graph(vertices2, edges2, layout=lt2).scale(2)\n        g2.shift(-g2.vertices[7].get_center() + g.vertices[7].get_center())\n        g2.vertices[11].set_color(BLUE)\n        g3 = Graph(vertices3, edges3, layout=lt3).scale(2)\n        g3.shift(-g3.vertices[1].get_center() + g.vertices[1].get_center())\n        g3.vertices[2].set_color(GREEN)\n        coloring = get_coloring(g.vertices, g.edges)\n        v_label = Tex('$v$').next_to(g.vertices[2], LEFT)\n        v_label_prime = Tex(\"$v'$\").next_to(g3.vertices[14], RIGHT)\n        g_orig = Tex('$G$').shift(RIGHT * 4.6 + DOWN * 1.9)\n        g_label = Tex('$G$').shift(RIGHT * 4.6 + DOWN * 1.9)\n        g_prime_label = Tex(\"$G'$\").shift(RIGHT * 4.6 + DOWN * 1.9)\n        for v in coloring:\n            g.vertices[v].set_color(coloring[v])\n        self.play(Write(g), Write(g_label))\n        self.play(Write(v_label))\n        group = VGroup(g3.vertices[2], g3.vertices[14])\n        self.play(FadeTransform(g.vertices[2], group), *[FadeOut(g.edges[u, v]) for u, v in edges if u == 2 or v == 2], v_label.animate.next_to(g3.vertices[2], LEFT), Transform(g_label, g_prime_label), *[FadeIn(g3.edges[u, v]) for u, v in g3.edges])\n        self.play(Write(v_label_prime))\n        self.play(Circumscribe(g3.vertices[14], Circle), g3.vertices[14].animate.set_color(YELLOW))\n        self.play(FadeOut(group), *[FadeIn(g.edges[u, v]) for u, v in edges if u == 2 or v == 2], *[FadeOut(g3.edges[u, v]) for u, v in g3.edges], FadeIn(g.vertices[2]), FadeOut(v_label), FadeOut(v_label_prime), Transform(g_label, g_orig))\n        v_label.next_to(g2.vertices[11], RIGHT)\n        v_label_prime.next_to(g2.vertices[14], RIGHT)\n        self.play(Write(v_label))\n        group = VGroup(g2.vertices[11], g2.vertices[14])\n        self.play(FadeTransform(g.vertices[11], group), *[FadeOut(g.edges[u, v]) for u, v in edges if u == 11 or v == 11], Transform(g_label, g_prime_label), *[FadeIn(g2.edges[u, v]) for u, v in g2.edges])\n        self.play(Write(v_label_prime))\n        take = (1, 9, 6, 11, 8, 10)\n        take2 = (1, 9, 6, 8, 10)\n        self.play(*[Circumscribe(g.vertices[v], Circle, fade_out=True) for v in vertices if v in take])\n        self.play(*[g.edges[u, v].animate.set_color(dark_color) for u, v in g.edges if u in take2 or v in take2], *[g.vertices[v].animate.set_color(dark_color) for v in take2], g2.vertices[14].animate.set_color(dark_color), *[g2.edges[u, v].animate.set_color(dark_color) for u, v in g2.edges if u == 14 or v == 14], v_label_prime.animate.set_color(dark_color))\n        self.play(*[Circumscribe(g.vertices[v], Circle, color=g.vertices[v].color) for v in g.vertices if v not in take2], g2.vertices[11].animate.set_color(GREEN), Circumscribe(g2.vertices[11], Circle, color=GREEN))\n        self.play(*[g.edges[u, v].animate.set_color(WHITE) for u, v in g.edges if u in take2 or v in take2], *[g.vertices[v].animate.set_color(BLUE) for v in take2], g2.vertices[14].animate.set_color(BLUE), *[g2.edges[u, v].animate.set_color(WHITE) for u, v in g2.edges if u == 14 or v == 14], v_label_prime.animate.set_color(WHITE))"}]}
{"messages": [{"role": "user", "content": "Display the definition of a perfect graph, followed by the construction and coloring of a specific graph example to illustrate its chromatic and clique numbers."}, {"role": "assistant", "content": "from utilities import *\n\nclass PerfectGraph(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Perfect graph')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 2.8))\n        duration, text = createHighlightedParagraph('A graph |$G$| is |perfect| (informally denoted |$G_{\\\\star}$|), if and only if |$$\\\\forall H \\\\leqslant G: \\\\chi(H) = \\\\omega(H)$$|', size='\\\\footnotesize', splitBy='|')\n        text.next_to(title, 2 * DOWN)\n        self.play(Write(text), run_time=duration)\n        s = 0.13\n        t = 0.1\n        lt = {1: [-23.077176841641393, -3.6014238478640053, 0], 2: [-17.53400032559717, -0.7232673082021435, 0], 3: [-17.585547717712963, -6.611537570521636, 0], 4: [-11.87839351679463, -3.7000433413833758, 0], 5: [-7.810612906695855, -0.14713004947159197, 0], 6: [-13.139976458938843, 2.483979391581951, 0], 7: [-7.873814738368363, -7.324043997994387, 0], 8: [-4.128425988901852, -3.7682916367758734, 0], 9: [0.9505618235022141, -7.371686271022552, 0], 10: [1.0132341302781502, -0.2549027730859073, 0], 11: [-28.505591928163522, -6.575932020162197, 0], 12: [-28.452365469134666, -0.5317762398287528, 0], 13: [-13.2486886857803, -9.86088904888131, 0]}\n        lt_avg_x = 0\n        lt_avg_y = 0\n        for i in lt:\n            lt_avg_x += lt[i][0]\n            lt_avg_y += lt[i][1]\n        lt_avg_x /= len(lt)\n        lt_avg_y /= len(lt)\n        for i in lt:\n            lt[i] = ((lt[i][0] - lt_avg_x) * s, (lt[i][1] - lt_avg_y) * t, 0)\n        vertices = [i + 1 for i in range(13)]\n        edges = [(1, 2), (3, 2), (2, 4), (4, 5), (6, 4), (4, 7), (5, 7), (1, 3), (3, 4), (6, 5), (8, 4), (8, 7), (8, 5), (8, 9), (10, 8), (11, 1), (12, 11), (12, 1), (13, 7), (13, 4)]\n        g = Graph(vertices, edges, layout=lt).scale(2)\n        g.shift(DOWN * 1.3)\n        self.play(Write(g))\n        self.play(g.animate.shift(LEFT * 1.2))\n        coloring = get_coloring(g.vertices, g.edges)\n        chi = Tex('$\\\\chi(G) = 4$')\n        omega = Tex('$\\\\omega(G) = 4$')\n        chii = Tex('$\\\\chi(H) = 3$')\n        omegaa = Tex('$\\\\omega(H) = 3$')\n\n        def to_color(color):\n            return [g.vertices[i].animate.set_color(color) for i in g.vertices] + [g.edges[e].animate.set_color(color) for e in g.edges]\n        chi.next_to(g, RIGHT).shift(RIGHT * 0.3 + UP * 0.4)\n        omega.next_to(chi, DOWN)\n        chii.next_to(g, RIGHT).shift(RIGHT * 0.3 + UP * 0.4)\n        omegaa.next_to(chi, DOWN)\n        self.play(*[g.vertices[v].animate.set_color(coloring[v]) for v in coloring], Write(chi))\n        take = (4, 5, 7, 8)\n        self.play(*to_color(YELLOW), *[g.vertices[v].animate.set_color(WHITE) for v in vertices if v not in take], *[g.edges[a, b].animate.set_color(WHITE) for a, b in edges if a not in take or b not in take], Write(omega))\n        take = (11, 12, 1, 3, 2, 4)\n        self.play(*to_color(WHITE), *[g.vertices[v].animate.set_color(dark_color) for v in vertices if v not in take], *[g.edges[a, b].animate.set_color(dark_color) for a, b in edges if a not in take or b not in take])\n        less_edges = [(a, b) for a, b in edges if a in take and b in take]\n        less_coloring = get_coloring(take, less_edges)\n        self.play(*[g.vertices[v].animate.set_color(less_coloring[v]) for v in take], TransformMatchingShapes(chi, chii))\n        takeee = (1, 3, 2)\n        self.play(*[g.vertices[v].animate.set_color(WHITE) for i, v in enumerate(take)], *[g.edges[a, b].animate.set_color(YELLOW) for a, b in edges if a in takeee and b in takeee], *[g.vertices[v].animate.set_color(YELLOW) for i, v in enumerate(takeee)], TransformMatchingShapes(omega, omegaa))"}]}
{"messages": [{"role": "user", "content": "Display graph coloring examples for complete, bipartite, odd cycle, and wheel graphs."}, {"role": "assistant", "content": "from utilities import *\n\nclass Observations(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Observations')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 2.5))\n        one = Tex('\\\\small$\\\\forall H \\\\leqslant G: \\\\omega(H) \\\\le \\\\chi(H)$').shift(LEFT * 3 + UP)\n        two = Tex('\\\\small$G_\\\\star \\\\Rightarrow \\\\forall H \\\\leqslant G: H_\\\\star$').shift(RIGHT * 3 + UP)\n        self.play(Write(one))\n        g = Graph.from_networkx(nx.complete_graph(5), layout='circular', layout_scale=0.6).scale(2)\n        g.shift(LEFT * 3 + DOWN * 1.5)\n        self.play(Write(g))\n        coloring = get_coloring(g.vertices, g.edges)\n        self.play(*[g.vertices[v].animate.set_color(coloring[v]) for v in coloring])\n        self.play(Write(two))\n        g = parse_graph('\\n                1 2 <28.321813901107728, 28.675721154416973> <32.87561944049231, 24.45977927204777>\\n                3 2 <26.915895781980787, 22.79756134095007> <32.87561944049231, 24.45977927204777>\\n                3 1 <26.915895781980787, 22.79756134095007> <28.321813901107728, 28.675721154416973>\\n                4 2 <33.24770177727062, 18.11545137329273> <32.87561944049231, 24.45977927204777>\\n                4 5 <33.24770177727062, 18.11545137329273> <31.34755829803025, 12.22668404420929>\\n                6 5 <27.2553244314561, 16.697459676808915> <31.34755829803025, 12.22668404420929>\\n                4 6 <33.24770177727062, 18.11545137329273> <27.2553244314561, 16.697459676808915>\\n                3 6 <26.915895781980787, 22.79756134095007> <27.2553244314561, 16.697459676808915>\\n                4 7 <33.24770177727062, 18.11545137329273> <38.19963686006849, 13.825620464525823>\\n                2 8 <32.87561944049231, 24.45977927204777> <34.81712389270086, 30.371822569173045>\\n                2 9 <32.87561944049231, 24.45977927204777> <39.02180120198095, 25.325061233401833>\\n                9 10 <39.02180120198095, 25.325061233401833> <39.36160664403505, 19.76151037083551>\\n                ', s=0.09, t=0.09).rotate(PI / 3)\n        g.shift(RIGHT * 3 + DOWN * 1.5)\n        self.play(Write(g))\n        isub = list(induced_subgraphs(g.vertices, g.edges))\n        shuffle(isub)\n        isub = [(v, e) for v, e in isub if len(e) >= 4]\n        for v, e in isub[:10]:\n            self.play(*[g.vertices[u].animate.set_color(WHITE) for u in v], *[g.edges[f].animate.set_color(WHITE) for f in e], *[g.vertices[u].animate.set_color(dark_color) for u in g.vertices if u not in v], *[g.edges[f].animate.set_color(dark_color) for f in g.edges if f not in e])\n            coloring = get_coloring(v, e)\n            self.play(*[g.vertices[v].animate.set_color(coloring[v]) for v in coloring])\n        fade_all(self)\n        title = Tex('\\\\Large Examples')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 2.5))\n        g1 = Tex('$\\\\text{complete}^{\\\\star}$').shift(LEFT * 4.7 + UP * 0.7)\n        g2 = Tex('$\\\\text{bipartite}^{\\\\star}$').shift(LEFT * 1.7 + UP * 0.7)\n        g3 = Tex('$\\\\text{odd cycles}_{\\\\scriptsize\\\\ge 5}$').shift(RIGHT * 1.7 + UP * 0.7)\n        g4 = Tex('$\\\\text{wheel}_{\\\\scriptsize\\\\ge 6}$').shift(RIGHT * 4.7 + UP * 0.7)\n        self.play(Write(g1))\n        g = Graph.from_networkx(nx.complete_graph(4), layout='circular', layout_scale=0.5).scale(2).rotate(PI / 4)\n        g.shift(LEFT * 4.7 + DOWN * 1.3)\n        self.play(Write(g))\n        coloring = get_coloring(g.vertices, g.edges)\n        self.play(*[g.vertices[v].animate.set_color(coloring[v]) for v in coloring])\n        self.play(Write(g2))\n        g = parse_graph('\\n            1 2 <37.34537111614888, 25.18886807744483> <44.004899931339125, 22.297273897437805>\\n            3 2 <37.32817381688349, 19.139829354958998> <44.004899931339125, 22.297273897437805>\\n            3 4 <37.32817381688349, 19.139829354958998> <43.940539956858906, 16.21648972542787>\\n            5 2 <37.293336692987694, 12.987483033125892> <44.004899931339125, 22.297273897437805>\\n            1 4 <37.34537111614888, 25.18886807744483> <43.940539956858906, 16.21648972542787>\\n                ', s=0.09, t=0.09)\n        g.shift(LEFT * 1.7 + DOWN * 1.3)\n        self.play(Write(g))\n        coloring = get_coloring(g.vertices, g.edges)\n        self.play(*[g.vertices[v].animate.set_color(coloring[v]) for v in coloring])\n        self.play(Write(g3))\n        g = Graph.from_networkx(nx.cycle_graph(5), layout='circular', layout_scale=0.5).scale(2).rotate(2 * PI / 20)\n        g.shift(RIGHT * 1.7 + DOWN * 1.3)\n        self.play(Write(g))\n        coloring = get_coloring(g.vertices, g.edges)\n        self.play(*[g.vertices[v].animate.set_color(coloring[v]) for v in coloring])\n        self.play(Write(g4))\n        g = parse_graph('\\n                1 2 <17.337719904381842, 13.098659761454995> <22.63234538756785, 16.96391344782175>\\n                3 2 <20.592399935170032, 23.193830591605924> <22.63234538756785, 16.96391344782175>\\n                3 4 <20.592399935170032, 23.193830591605924> <14.03701882720638, 23.17887744719346>\\n                4 5 <14.03701882720638, 23.17887744719346> <12.025515945673726, 16.939718751923685>\\n                1 5 <17.337719904381842, 13.098659761454995> <12.025515945673726, 16.939718751923685>\\n                1 6 <17.337719904381842, 13.098659761454995> <17.32499999999996, 18.67499999999997>\\n                2 6 <22.63234538756785, 16.96391344782175> <17.32499999999996, 18.67499999999997>\\n                3 6 <20.592399935170032, 23.193830591605924> <17.32499999999996, 18.67499999999997>\\n                4 6 <14.03701882720638, 23.17887744719346> <17.32499999999996, 18.67499999999997>\\n                6 5 <17.32499999999996, 18.67499999999997> <12.025515945673726, 16.939718751923685>\\n                ', s=0.09, t=0.09)\n        g.shift(RIGHT * 4.7 + DOWN * 1.15).rotate(PI)\n        self.play(Write(g))\n        coloring = get_coloring(g.vertices, g.edges)\n        self.play(*[g.vertices[v].animate.set_color(coloring[v]) for v in coloring])"}]}
{"messages": [{"role": "user", "content": "Illustrate the weak perfect graph theorem by displaying its statement and then visually representing its implications through graph transformations and color-coding."}, {"role": "assistant", "content": "from utilities import *\n\nclass Theorem(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Weak perfect graph theorem')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 0.7))\n        duration, text = createHighlightedParagraph('Graph |$G$ is perfect|, |if and only if| graph |$\\\\bar{G}$ is perfect.', size='\\\\footnotesize', splitBy='|')\n        text[3].set_color(WHITE)\n        text.next_to(title, 2 * DOWN)\n        impl = Tex('\\\\footnotesize$\\\\Rightarrow$')\n        self.play(Write(text), run_time=duration)\n        self.play(FadeOut(title))\n        self.play(text.animate.shift(UP * 3.6))\n        impl.move_to(text[3].get_center())\n        l1 = Line(LEFT * 10, RIGHT * 10).shift(UP * 2.6)\n        self.play(Write(l1))\n        self.play(text[0].animate.shift(RIGHT * 0.9), text[1].animate.shift(RIGHT * 0.9), text[2].animate.shift(RIGHT * 0.9), Transform(text[3], impl), text[4].animate.shift(LEFT * 0.9), text[5].animate.shift(LEFT * 0.9))\n        a = Ellipse(width=5, height=3, color=WHITE).shift(LEFT * 3.4 + DOWN)\n        b = Ellipse(width=5, height=3, color=WHITE).shift(RIGHT * 3.4 + DOWN)\n        a_text = Tex('$G_{\\\\star}$').move_to(a).shift(UP * 2)\n        b_text = Tex('$\\\\bar{G}$').move_to(b).shift(UP * 2)\n        aa = Ellipse(width=2.5, height=1.6, color=WHITE).shift(LEFT * 3.4 + DOWN * 1.2 + LEFT * 0.6)\n        bb = Ellipse(width=2.5, height=1.6, color=WHITE).shift(RIGHT * 3.4 + DOWN * 1.2 + LEFT * 0.6)\n        aa_text = Tex('$\\\\bar{H}_{\\\\star}$').move_to(a).shift(UP * 0.3 + RIGHT * 1.3)\n        bb_text = Tex('$H$').move_to(b).shift(UP * 0.3 + RIGHT * 1.3)\n        self.play(Write(a), Write(a_text))\n        self.play(Write(b), Write(b_text))\n        self.play(Write(bb), Write(bb_text))\n        self.play(Write(aa), Write(aa_text))\n        aaa_text = Tex('=').next_to(a_text, RIGHT)\n        bbb_text = Tex('=').next_to(b_text, RIGHT)\n        self.play(Transform(aa, a), Transform(bb, b), FadeIn(aaa_text), FadeIn(bbb_text), aa_text.animate.next_to(aaa_text, RIGHT), bb_text.animate.next_to(bbb_text, RIGHT))\n        ra = Rectangle(width=8, height=3.9 * 2).shift(LEFT * 4 + DOWN * 1.3)\n        rb = Rectangle(width=8, height=3.9 * 2).shift(RIGHT * 4 + DOWN * 1.3)\n        l2 = Line(UP * 2.6, DOWN * 10)\n        self.play(Transform(a, ra), Transform(b, rb), FadeOut(aa), FadeOut(bb), FadeOut(aaa_text), FadeOut(bbb_text), FadeOut(aa_text), FadeOut(bb_text), a_text.animate.shift(UP * 0.9), b_text.animate.shift(UP * 0.9))\n        self.remove(a)\n        self.remove(b)\n        self.add(l2)\n        v = [Graph([0], []).scale(2).shift(RIGHT * 2 + DOWN * 0.2), Graph([0], []).scale(2).shift(RIGHT * 4 + DOWN * -1), Graph([0], []).scale(2).shift(RIGHT * 5 + DOWN * 1.1)]\n        a = nx.complete_graph(5)\n        A = Graph.from_networkx(a, layout='circular', layout_scale=0.4).scale(2)\n        A.shift(RIGHT * 2.5 + DOWN * 2.4)\n        A.set_color(dark_color)\n        self.play(Write(v[0]), Write(v[1]), Write(v[2]), Write(A))\n        b = nx.complete_graph(3)\n        lt = {0: v[0].vertices[0].get_center() / 2, 1: v[1].vertices[0].get_center() / 2, 2: v[2].vertices[0].get_center() / 2}\n        B = Graph.from_networkx(b, layout=lt).scale(2).shift(LEFT * 5.5 + DOWN * 0.1)\n        c = nx.complete_graph(5)\n        C = Graph.from_networkx(a, layout='circular', layout_scale=0.4).scale(2)\n        C.move_to(A).shift(LEFT * 7.3 + DOWN * 0.1)\n        C.set_color(dark_color)\n        v2 = [Graph([0], []).scale(2).move_to(C.vertices[0]).set_color(dark_color), Graph([0], []).scale(2).move_to(C.vertices[1]).set_color(dark_color), Graph([0], []).scale(2).move_to(C.vertices[2]).set_color(dark_color), Graph([0], []).scale(2).move_to(C.vertices[3]).set_color(dark_color), Graph([0], []).scale(2).move_to(C.vertices[4]).set_color(dark_color)]\n        self.play(Write(B), Write(v2[0]), Write(v2[1]), Write(v2[2]), Write(v2[3]), Write(v2[4]))\n        self.play(a_text.animate.shift(LEFT * a_text.get_x()), l2.animate.shift(RIGHT * 8), A.animate.shift(RIGHT * 8), b_text.animate.shift(RIGHT * 8), v[0].animate.shift(RIGHT * 8), v[1].animate.shift(RIGHT * 8), v[2].animate.shift(RIGHT * 8), B.animate.shift(RIGHT * 6 + DOWN * 0.8), v2[0].animate.shift(RIGHT * 1.5 + UP * 1.6), v2[1].animate.shift(RIGHT * 1.5 + UP * 1.6), v2[2].animate.shift(RIGHT * 1.5 + UP * 1.6), v2[3].animate.shift(RIGHT * 1.5 + UP * 1.6), v2[4].animate.shift(RIGHT * 1.5 + UP * 1.6), run_time=1.5)\n        q_text = Tex('$Q_1$').move_to(B).shift(RIGHT * 0.3)\n        i_text = Tex('$I_1$').move_to(v2[1]).shift(DOWN * 0.8 + LEFT * 0.2)\n        self.play(Write(q_text))\n        self.play(Write(i_text))\n        qs = [Graph.from_networkx(nx.complete_graph(3), layout='circular', layout_scale=0.6).scale(2).rotate(uniform(0, 2 * PI)).shift(LEFT * 1.7 + UP * 0.2), Graph.from_networkx(nx.complete_graph(3), layout='circular', layout_scale=0.6).scale(2).rotate(uniform(0, 2 * PI)).shift(RIGHT * 2 + DOWN * 1.5), Graph.from_networkx(nx.complete_graph(3), layout='circular', layout_scale=0.6).scale(2).rotate(uniform(0, 2 * PI)).shift(DOWN * 0.7 + LEFT * 1.6), Graph.from_networkx(nx.complete_graph(3), layout='circular', layout_scale=0.6).scale(2).shift(RIGHT * 3 + DOWN * 1)]\n        iss = [Graph([0, 1, 2, 3, 4], [], layout='circular', layout_scale=0.6).scale(2).rotate(uniform(0, 2 * PI)).shift(RIGHT * 2.7 + DOWN * 1.2).set_color(dark_color), Graph([0, 1, 2, 3, 4], [], layout='circular', layout_scale=0.6).scale(2).rotate(uniform(0, 2 * PI)).shift(LEFT * 3).set_color(dark_color), Graph([0, 1, 2, 3, 4], [], layout='circular', layout_scale=0.6).scale(2).rotate(uniform(0, 2 * PI)).shift(RIGHT * 3).set_color(dark_color), Graph([0, 1, 2, 3, 4], [], layout='circular', layout_scale=0.6).scale(2).shift(LEFT * 3 + DOWN * 1).set_color(dark_color)]\n        iss_text = [Tex(f\"$I_{(str(i + 2) if i != len(iss) - 1 else 't')}$\").move_to(iss[i].get_center_of_mass()) for i in range(len(iss))]\n        qs_text = [Tex(f\"$Q_{(str(i + 2) if i != len(iss) - 1 else 't')}$\").move_to(qs[i].get_center_of_mass()) for i in range(len(qs))]\n        self.play(FadeOut(v2[0]), FadeOut(v2[1]), FadeOut(v2[2]), FadeOut(v2[3]), FadeOut(v2[4]), FadeOut(B), FadeOut(q_text), FadeOut(i_text), Write(qs[0]), Write(qs_text[0]), Write(iss[0]), Write(iss_text[0]))\n        for i in range(len(iss) - 1):\n            self.play(FadeOut(qs[i]), FadeOut(qs_text[i]), FadeOut(iss[i]), FadeOut(iss_text[i]), FadeIn(qs[i + 1]), FadeIn(qs_text[i + 1]), FadeIn(iss[i + 1]), FadeIn(iss_text[i + 1]))\n        self.play(FadeOut(qs[len(qs) - 1]), FadeOut(qs_text[len(qs) - 1]), FadeOut(iss[len(qs) - 1]), FadeOut(iss_text[len(qs) - 1]))\n        v_label = Tex('$v$')\n        v_function = Tex('$f($', '$v$', '$) = 3$')\n        v = Graph([0], []).scale(2).move_to(ORIGIN + UP * 0.6)\n        self.play(Write(v), Write(v_label))\n        issss = [Graph([0, 1, 2, 3], [], layout='spring', layout_scale=0.5).scale(2).rotate(uniform(0, 2 * PI)).shift(LEFT * 4 + DOWN * 0.5).set_color(RED), Graph([0, 1, 2, 3], [], layout='spring', layout_scale=0.5).scale(2).rotate(uniform(0, 2 * PI)).shift(RIGHT * 4 + DOWN * 0.5).set_color(GREEN), Graph([0, 1, 2, 3], [], layout='spring', layout_scale=0.5).scale(2).rotate(uniform(0, 2 * PI)).shift(DOWN * 2.2).set_color(BLUE)]\n        issss_text = [Tex(f'$I_i$').move_to(issss[0].get_center_of_mass()), Tex(f'$I_j$').move_to(issss[1].get_center_of_mass()), Tex(f'$I_k$').move_to(issss[2].get_center_of_mass())]\n        self.play(v.animate.set_color_by_gradient((GREEN, GREEN, GREEN, RED, BLUE, BLUE, BLUE)), Write(issss[0]), Write(issss[1]), Write(issss[2]), Write(issss_text[0]), Write(issss_text[1]), Write(issss_text[2]))\n        v_function.shift(LEFT * v_function[1].get_center() - v_label.get_center())\n        self.play(Write(v_function[0]), Write(v_function[2]))\n        self.play(FadeOut(v_function[0]), FadeOut(v_function[2]), FadeOut(v_label), FadeOut(issss_text[0]), FadeOut(issss_text[1]), FadeOut(issss_text[2]))\n        L = Graph.from_networkx(nx.complete_graph(3), layout='circular', layout_scale=0.3).scale(2).rotate(PI / 6)\n        L.move_to(v)\n        L.vertices[0].set_color(RED)\n        L.vertices[1].set_color(GREEN)\n        L.vertices[2].set_color(BLUE)\n        a_prime_text = Tex(\"$G'_{\\\\star}$\").move_to(a_text)\n        isssst = [[Graph.from_networkx(nx.complete_graph(randint(2, 5)), layout='circular', layout_scale=0.2, vertex_config={0: {'fill_color': RED}}).scale(1.5).rotate(uniform(0, PI * 2)).move_to(issss[0].vertices[a]) for a in issss[0].vertices], [Graph.from_networkx(nx.complete_graph(randint(2, 5)), layout='circular', layout_scale=0.2, vertex_config={0: {'fill_color': GREEN}}).scale(1.5).rotate(uniform(0, PI * 2)).move_to(issss[1].vertices[a]) for a in issss[1].vertices], [Graph.from_networkx(nx.complete_graph(randint(2, 5)), layout='circular', layout_scale=0.2, vertex_config={0: {'fill_color': BLUE}}).scale(1.5).rotate(uniform(0, PI * 2)).move_to(issss[2].vertices[a]) for a in issss[2].vertices]]\n        self.play(FadeTransform(v, L), Transform(a_text, a_prime_text), *[FadeTransform(issss[0].vertices[a], b) for a, b in zip(issss[0].vertices, isssst[0])], *[FadeTransform(issss[1].vertices[a], b) for a, b in zip(issss[1].vertices, isssst[1])], *[FadeTransform(issss[2].vertices[a], b) for a, b in zip(issss[2].vertices, isssst[2])])\n        self.play(FadeOut(L), *[FadeOut(i) for i in isssst[0]], *[FadeOut(i) for i in isssst[1]], *[FadeOut(i) for i in isssst[2]], FadeOut(a_prime_text), FadeOut(a_text))\n        up_coeff = UP * 0.9\n        vertices_1 = Tex(\"$|V(G'_{\\\\star})|$\").shift(up_coeff)\n        vertices_2 = Tex('$=$').shift(up_coeff)\n        vertices_3 = Tex('$t \\\\cdot \\\\alpha(G_{\\\\star})$').shift(up_coeff)\n        self.play(Write(vertices_1))\n        v = Graph([0], []).scale(2).move_to(ORIGIN + DOWN * 1.2)\n        (v.set_color_by_gradient((GREEN, GREEN, GREEN, RED, BLUE, BLUE, BLUE)),)\n        g = Graph.from_networkx(nx.complete_graph(3), layout='circular', layout_scale=0.3).scale(2).rotate(PI / 6)\n        g.move_to(ORIGIN + DOWN * 1.4)\n        g.vertices[0].set_color(RED)\n        g.vertices[1].set_color(GREEN)\n        g.vertices[2].set_color(BLUE)\n        self.play(Write(v))\n        self.play(FadeTransform(v, g))\n        self.play(vertices_1.animate.next_to(vertices_2, LEFT))\n        vertices_3.next_to(vertices_2, RIGHT)\n        self.play(Write(vertices_2), Write(vertices_3))\n        self.play(vertices_1.animate.shift(LEFT * 4.5 + UP), vertices_2.animate.shift(LEFT * 4.5 + UP), vertices_3.animate.shift(LEFT * 4.5 + UP), FadeOut(g))\n        chi_1 = Tex(\"$\\\\chi(G'_{\\\\star})$\").shift(up_coeff)\n        chi_1_copy = Tex(\"$\\\\chi(G'_{\\\\star})$\").shift(up_coeff)\n        chi_2 = Tex('$\\\\ge$').shift(up_coeff)\n        chi_2_copy = Tex('$\\\\ge$').shift(up_coeff)\n        chi_3 = Tex(\"$|V(G'_{\\\\star})|$\").shift(up_coeff)\n        chi_4 = Tex(\"$\\\\alpha(G'_{\\\\star})$\").shift(up_coeff)\n        chi_5 = Tex('$\\\\alpha(G_{\\\\star})$').shift(up_coeff)\n        chi_6 = Tex('$t$').shift(up_coeff)\n        chi_7 = Tex('$t \\\\cdot \\\\alpha(G_{\\\\star})$')\n        chi_line = Line(LEFT * (chi_3.width / 2), chi_3.width / 2 * RIGHT).next_to(chi_2, RIGHT)\n        chi_3.next_to(chi_line, UP * 0.5)\n        chi_4.next_to(chi_line, DOWN * 0.5)\n        chi_5.next_to(chi_line, DOWN * 0.5)\n        chi_6.next_to(chi_2, RIGHT)\n        chi_7.move_to(chi_3)\n        vertices_3_copy = Tex('$t \\\\cdot \\\\alpha(G_{\\\\star})$').move_to(vertices_3)\n        self.play(Write(chi_1))\n        s = 0.11\n        t = 0.11\n        lt = {1: [19.548217614388534, 21.340577554023504, 0], 2: [20.662008110549685, 15.382615667209869, 0], 3: [25.300617985296988, 19.402275147120974, 0], 4: [30.94295584178832, 16.726260097368442, 0], 5: [29.650114385797423, 23.773084129741097, 0], 6: [35.16952313921368, 21.143570822050012, 0], 7: [26.157058197320413, 13.318633839769966, 0], 8: [36.37430103474421, 15.313893361048475, 0], 9: [41.333240274979886, 22.35772831721661, 0], 10: [13.362661329279078, 22.761201537059815, 0], 11: [14.572572144179105, 17.06814491517606, 0], 12: [23.748642306908586, 23.920326298309895, 0], 13: [41.71468063949628, 16.2784339371247, 0]}\n        lt_avg_x = 0\n        lt_avg_y = 0\n        for i in lt:\n            lt_avg_x += lt[i][0]\n            lt_avg_y += lt[i][1]\n        lt_avg_x /= len(lt)\n        lt_avg_y /= len(lt)\n        for i in lt:\n            lt[i] = ((lt[i][0] - lt_avg_x) * s, (lt[i][1] - lt_avg_y) * t, 0)\n        vertices = [i + 1 for i in range(13)]\n        edges = [(1, 2), (3, 2), (3, 1), (3, 4), (3, 5), (4, 6), (5, 6), (4, 7), (4, 8), (9, 6), (1, 10), (1, 11), (1, 12), (13, 8)]\n        h = Graph(vertices, edges, layout=lt).scale(2)\n        h.shift(DOWN * 1.5)\n        self.play(Write(h))\n        self.play(chi_1.animate.next_to(chi_2, LEFT))\n        self.play(Write(chi_2), Write(chi_3), Write(chi_line), Write(chi_4))\n        ins = get_independent_set(edges)\n        self.play(*[Circumscribe(h.vertices[v], Circle, color=RED) for v in ins], *[h.vertices[v].animate.set_color(RED) for v in ins])\n        self.play(h.vertices[1].animate.set_color(GREEN), h.vertices[3].animate.set_color(BLUE), h.vertices[4].animate.set_color(GREEN), h.vertices[6].animate.set_color(BLUE), h.vertices[8].animate.set_color(BLUE))\n        self.play(TransformMatchingShapes(chi_4, chi_5))\n        self.add(vertices_3_copy)\n        self.play(FadeOut(chi_3), TransformMatchingShapes(vertices_3, chi_7))\n        self.remove(chi_7)\n        self.remove(vertices_3)\n        group = VGroup(chi_5, chi_7, chi_line)\n        self.play(Transform(group, chi_6))\n        self.remove(group)\n        chi_2_copy.next_to(vertices_2, DOWN * 2.5)\n        self.play(chi_2.animate.next_to(vertices_2, DOWN * 2.5), chi_6.animate.next_to(chi_2_copy, RIGHT), chi_1.animate.next_to(chi_2_copy, LEFT), FadeOut(h))\n        omega_1 = Tex(\"$\\\\omega(G'_{\\\\star})$\").shift(up_coeff)\n        omega_2 = Tex('$\\\\le$').shift(up_coeff)\n        omega_22 = Tex('$<$').shift(up_coeff)\n        omega_3 = Tex('$t - 1$').shift(up_coeff)\n        s = 0.1\n        t = -0.1\n        lt = {1: [135.16695278754875, 21.799871409019467, 0], 2: [135.23974320121462, 26.995869054443364, 0], 3: [129.97095514212484, 21.872661822685316, 0], 4: [130.0437455557907, 27.068659468109214, 0], 5: [141.89096109447206, 35.392026752382, 0], 6: [135.63477405240312, 34.066543991842444, 0], 7: [129.5059688153642, 34.08623598267496, 0], 8: [123.54386010179873, 35.40080564245303, 0], 9: [122.63066582824992, 29.03885300896691, 0], 10: [121.54368309842575, 24.067955925975035, 0], 11: [115.63153661766992, 24.123476883046557, 0], 12: [112.83175634818338, 28.626425603912605, 0], 13: [141.47586853932546, 28.873495345254142, 0], 14: [142.5705309790387, 25.095144343663446, 0], 15: [146.7726222798732, 23.965170212346607, 0], 16: [146.96559967175557, 28.624210346460647, 0], 17: [151.1865837303296, 25.307014493285358, 0]}\n        lt_avg_x = 0\n        lt_avg_y = 0\n        for i in lt:\n            lt_avg_x += lt[i][0]\n            lt_avg_y += lt[i][1]\n        lt_avg_x /= len(lt)\n        lt_avg_y /= len(lt)\n        for i in lt:\n            lt[i] = ((lt[i][0] - lt_avg_x) * s, (lt[i][1] - lt_avg_y) * t, 0)\n        A = Graph.from_networkx(nx.complete_graph(5), layout='circular', layout_scale=0.8).scale(2)\n        A.shift(DOWN * 0.9)\n        qp_label = Tex(\"$Q'$\").shift(UP * 0.2 + RIGHT * 1.3)\n        self.play(Write(A), Write(qp_label))\n        self.play(FadeOut(A), FadeOut(qp_label))\n        vertices = [i + 1 for i in range(17)]\n        edges = [(1, 2), (3, 4), (4, 2), (3, 1), (1, 4), (3, 2)]\n        h = Graph(vertices, edges, layout=lt).scale(2)\n        h.shift(DOWN * 1.4)\n        q_label = Tex('$Q$').shift(UP * 0.2 + RIGHT * 1.1)\n        self.play(Write(h), Write(q_label))\n        self.play(h.vertices[1].animate.set_color(BLUE), h.vertices[2].animate.set_color(RED), h.vertices[3].animate.set_color(LIGHT_BROWN), h.vertices[4].animate.set_color_by_gradient((PINK, PINK, GREEN, GREEN)), h.vertices[5].animate.set_color(YELLOW), h.vertices[6].animate.set_color(YELLOW), h.vertices[7].animate.set_color(YELLOW), h.vertices[8].animate.set_color(YELLOW), h.vertices[13].animate.set_color(PINK), h.vertices[14].animate.set_color_by_gradient((PINK, PINK, PINK, RED, BLUE, BLUE, BLUE)), h.vertices[15].animate.set_color_by_gradient((RED, RED, BLUE, BLUE)), h.vertices[16].animate.set_color_by_gradient((PINK, PINK, BLUE, BLUE)), h.vertices[17].animate.set_color(RED), h.vertices[9].animate.set_color_by_gradient((LIGHT_BROWN, LIGHT_BROWN, GREEN, GREEN)), h.vertices[10].animate.set_color_by_gradient((LIGHT_BROWN, LIGHT_BROWN, GREEN, GREEN)), h.vertices[11].animate.set_color(LIGHT_BROWN), h.vertices[12].animate.set_color(GREEN))\n        self.play(Circumscribe(h.vertices[5], Circle), Circumscribe(h.vertices[6], Circle), Circumscribe(h.vertices[7], Circle), Circumscribe(h.vertices[8], Circle))\n        self.play(FadeOut(q_label))\n        self.play(Write(omega_1))\n        self.play(omega_1.animate.next_to(omega_2, LEFT))\n        omega_3.next_to(omega_2, RIGHT)\n        self.play(Write(omega_2), Write(omega_3))\n        chi_1_copy.move_to(chi_1)\n        self.add(chi_1_copy)\n        self.play(chi_1.animate.next_to(omega_2, RIGHT), FadeOut(omega_3), Transform(omega_2, omega_22))\n        self.play(Circumscribe(VGroup(chi_1, omega_2, omega_1)))"}]}
{"messages": [{"role": "user", "content": "Present the Strong Perfect Graph Theorem, illustrate a \"hole\" and an \"antihole\" graph, highlight the odd cycles within them, and then show two proof images."}, {"role": "assistant", "content": "from utilities import *\n\nclass Theorem2(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large Strong perfect graph theorem')\n        self.play(Write(title))\n        self.play(title.animate.shift(UP * 1.3))\n        duration, text = createHighlightedParagraph(\"Graph |$G$ is perfect|, |if and only if| it |doesn't contain| an |odd hole| or an |odd antihole greater than 3| (is a |Berge graph|).\", size='\\\\footnotesize', splitBy='|')\n        text[3].set_color(WHITE)\n        text.next_to(title, 2 * DOWN)\n        self.play(Write(text), run_time=duration)\n        self.play(FadeOut(title))\n        self.play(text.animate.shift(UP * 3.1))\n        l1 = Line(LEFT * 10, RIGHT * 10).next_to(text, DOWN).shift(DOWN * 0.12)\n        self.play(Write(l1))\n        s = 0.09\n        t = 0.09\n        lt = {1: [-0.13468417754907686, -11.382616759291821, 0], 2: [-6.34849625738931, -11.40647453424448, 0], 3: [-3.2526218113979337, -6.242787222493782, 0], 4: [2.9143602874895524, -5.9709400410760605, 0], 5: [-9.769595162673074, -6.223457085564913, 0], 6: [-0.5868623771064418, -0.8392016711467933, 0], 7: [-6.797128201812322, -0.7758522039253336, 0]}\n        lt_avg_x = 0\n        lt_avg_y = 0\n        for i in lt:\n            lt_avg_x += lt[i][0]\n            lt_avg_y += lt[i][1]\n        lt_avg_x /= len(lt)\n        lt_avg_y /= len(lt)\n        for i in lt:\n            lt[i] = ((lt[i][0] - lt_avg_x) * s, (lt[i][1] - lt_avg_y) * t, 0)\n        vertices = [i + 1 for i in range(7)]\n        edges = [(1, 2), (3, 1), (4, 1), (3, 2), (5, 2), (3, 6), (6, 7), (4, 6), (5, 7)]\n        g = Graph(vertices, edges, layout=lt).scale(2)\n        g.shift(DOWN * 1.2 + LEFT * 3)\n        s = 0.13\n        t = 0.13\n        lt = {1: [11.017918974171332, -6.591774340119114, 0], 2: [16.962897427793656, -4.746124663681754, 0], 3: [13.13398895475949, -9.70491764147956, 0], 4: [13.21453712023058, -3.5349324907386763, 0], 5: [16.912690271108087, -8.591990051119353, 0], 6: [22.979777239232465, -9.802147496310052, 0], 7: [23.059508184569292, -3.6947624028155706, 0]}\n        lt_avg_x = 0\n        lt_avg_y = 0\n        for i in lt:\n            lt_avg_x += lt[i][0]\n            lt_avg_y += lt[i][1]\n        lt_avg_x /= len(lt)\n        lt_avg_y /= len(lt)\n        for i in lt:\n            lt[i] = ((lt[i][0] - lt_avg_x) * s, (lt[i][1] - lt_avg_y) * t, 0)\n        vertices = [i + 1 for i in range(7)]\n        edges = [(1, 2), (2, 3), (4, 5), (1, 5), (3, 4), (5, 6), (2, 7), (6, 7)]\n        h = Graph(vertices, edges, layout=lt).scale(2)\n        h.shift(DOWN * 1.2 + RIGHT * 3)\n        take_g = (2, 3, 5, 6, 7)\n        take_h = (1, 2, 3, 4, 5)\n        hole = Tex('hole').next_to(g, UP).shift(UP * 0.2)\n        antihole = Tex('antihole').next_to(h, UP).shift(UP * 0.2)\n        self.play(Write(hole), Write(antihole), Write(g), Write(h))\n        self.play(*[g.vertices[v].animate.set_color(dark_color) for v in g.vertices if v not in take_g], *[g.edges[u, v].animate.set_color(dark_color) for u, v in g.edges if u not in take_g or v not in take_g], *[h.vertices[v].animate.set_color(dark_color) for v in h.vertices if v not in take_h], *[h.edges[u, v].animate.set_color(dark_color) for u, v in h.edges if u not in take_h or v not in take_h])\n        self.play(FadeOut(g), FadeOut(h), FadeOut(hole), FadeOut(antihole))\n        image1 = ImageMobject('proof1.png')\n        image1.set_height(5).shift(LEFT * 2.1 + DOWN)\n        image2 = ImageMobject('proof2.png')\n        image2.set_height(5).shift(RIGHT * 2.1 + DOWN)\n        self.play(FadeIn(image1), FadeIn(image2))"}]}
{"messages": [{"role": "user", "content": "Display three distinct graph structures with their vertices colored according to their connectivity and present the text \"Weak Perfect Graph Theorem\"."}, {"role": "assistant", "content": "from utilities import *\n\nclass Thumbnail(MovingCameraScene):\n\n    def construct(self):\n        seed(3735928559)\n        self.next_section(skip_animations=True)\n        a = nx.complete_graph(5)\n        A = Graph.from_networkx(a, layout='circular', layout_scale=0.8).scale(2)\n        A.shift(LEFT * 2.5 + UP * 1.2)\n        b = nx.windmill_graph(3, 4)\n        B = Graph.from_networkx(b, layout='spring', layout_scale=0.8).scale(2)\n        B.shift(RIGHT * 2.5 + UP * 1.2)\n        seven = 6\n        five = 4\n        c = nx.algorithms.bipartite.generators.random_graph(seven, five, 0.5)\n        lt = nx.bipartite_layout(c, [n for i, n in enumerate(c.nodes) if i < seven], align='horizontal', aspect_ratio=0.35)\n        for k in lt:\n            lt[k] = np.array([lt[k][0], lt[k][1], 0])\n        C = Graph.from_networkx(c, layout=lt, layout_scale=0.8).scale(2)\n        C.vertices[6].shift(LEFT * 0.25)\n        C.vertices[7].shift(LEFT * 0.5)\n        C.vertices[8].shift(RIGHT * 0.5)\n        C.vertices[9].shift(RIGHT * 0.25)\n        Group(A, C, B).arrange(buff=0.8)\n        A.scale(0.8)\n        B.scale(0.8)\n        self.play(Write(A), Write(B), Write(C))\n        a_coloring = get_coloring(A.vertices, A.edges)\n        b_coloring = get_coloring(B.vertices, B.edges)\n        c_coloring = get_coloring(C.vertices, C.edges)\n        self.play(*[A.vertices[v].animate.set_color(a_coloring[v]) for v in a_coloring], *[B.vertices[v].animate.set_color(b_coloring[v]) for v in b_coloring], *[C.vertices[v].animate.set_color(c_coloring[v]) for v in c_coloring])\n        a = Tex('Weak Perfect')\n        b = Tex('Graph Theorem').next_to(a, DOWN)\n        g = Group(a, b).scale(2.5).next_to(Group(A, B, C), UP, buff=1.2)\n        self.add(g)\n        self.next_section()\n        fg = Group(g, A, B, C)\n        self.camera.frame.move_to(fg).set_height(fg.get_height() * 1.4)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the execution of a C code snippet, highlighting line-by-line operations and illustrating a binary addition process with intermediate steps and results."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\n\nclass Intro(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        with open('funf.c') as f:\n            contents = f.read()\n        q = Tex('\\\\underline{How does it work?}').scale(1.15)\n        code = MyCode(contents)\n        q.next_to(code, UP, buff=1)\n        g = VGroup(q, code)\n        self.camera.frame.set_width(g.width * 1.4).move_to(g)\n        self.play(Write(q, run_time=1), FadeIn(code))\n        sr = CreateHighlightCodeLines(code, [12, 13, 14, 15, 16, 17, 18], offset=0)\n        sr_orig = sr.copy()\n        sr.save_state()\n        sr.become(CreateHighlightCodeLine(code, 15, start=10))\n        with open('funf.out') as f:\n            contents = f.read()\n        brace = BraceBetweenPoints(Dot().next_to(sr, LEFT, buff=-0.1).get_center(), Dot().next_to(sr, RIGHT, buff=-0.1).get_center(), direction=UP).next_to(sr, UP, buff=0)\n        output = MyCode(contents).code.next_to(brace, UP).scale(1.5)\n        sr = CreateHighlightObject(VGroup(brace, output, sr_orig))\n        self.play(AnimationGroup(FadeIn(sr), FadeIn(output, shift=UP * 0.1), FadeIn(brace, shift=UP * 0.1)))\n        self.play(Transform(sr, CreateHighlightCodeLines(code, [2, 3, 4, 5, 6, 7, 8, 9, 10], offset=0)))\n        self.play(Transform(sr, CreateHighlightCodeLine(code, 4, start=2)))\n        self.play(Transform(sr, CreateHighlightCodeLines(code, [5, 6, 7, 8], offset=4)))\n        self.play(Transform(sr, CreateHighlightCodeLine(code, 9, start=2)))\n        x, y = (MyCodeKindaTho('111101'), MyCodeKindaTho('11001'))\n        orig_color = x.code[0][0].color\n        numbers = [(MyCodeKindaTho('100100'), MyCodeKindaTho('110010')), (MyCodeKindaTho('10110'), MyCodeKindaTho('1000000')), (MyCodeKindaTho('1010110'), MyCodeKindaTho('0000000'))]\n        sum = MyCodeKindaTho('x = sum').scale(0.75)\n        carry = MyCodeKindaTho('y = carry').scale(0.75)\n        table = Table([[x], [y], [numbers[0][0]], [numbers[0][1]]], arrange_in_grid_config={'col_alignments': 'rr'}, v_buff=0.4, h_buff=0.65, element_to_mobject=lambda x: x, row_labels=[code.code[2][10].copy(), code.code[2][17].copy(), code.code[6][7:-1].copy(), code.code[7][6:].copy()]).move_to(self.camera.frame)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(sr), FadeOut(code), FadeOut(code.code[-1]), FadeOut(code.code[-2]), FadeOut(code.code[15][18:]), FadeOut(code.code[15][14]), FadeOut(code.code[15][15]), FadeOut(brace), FadeOut(output), FadeOut(q)), AnimationGroup(ReplacementTransform(code.code[2][10], table.get_row_labels()[0]), ReplacementTransform(code.code[2][17], table.get_row_labels()[1]), ReplacementTransform(code.code[6][7:-1], table.get_row_labels()[2]), ReplacementTransform(code.code[7][6:], table.get_row_labels()[3]), ReplacementTransform(code.code[15][12:14], x), ReplacementTransform(code.code[15][16:18], y)), lag_ratio=0.75))\n        xor = table.get_entries((-1, 2))\n        indexes = [0, 3]\n        color_anim = []\n        x.save_state()\n        y.save_state()\n        xor.save_state()\n        for i in range(len(x.code[0])):\n            color = RED if i not in indexes else GREEN\n            color_anim.append(x.code[0][i].animate.set_color(color))\n            xor.code[0][i].set_color(color)\n            if i != 0:\n                color_anim.append(y.code[0][i - 1].animate.set_color(color))\n        h = CreateHighlightObject(table.get_row_labels()[2])\n        self.play(FadeIn(h))\n        self.play(*color_anim, FadeIn(xor), Circumscribe(xor, color=WHITE))\n        self.play(x.animate.restore(), y.animate.restore(), xor.animate.restore(), Transform(h, CreateHighlightObject(table.get_row_labels()[3][1:6])))\n        indexes = [1, 2, 5]\n        color_anim = []\n        x.save_state()\n        y.save_state()\n        andd = table.get_entries((0, 2))\n        andd.save_state()\n        andd.code[0][-1].set_opacity(0)\n        pos = andd.code[0][:-1].get_center()\n        andd.code[0][:-1].align_to(andd.code[0][-1], RIGHT)\n        andd.code[0][-1].save_state()\n        for i in range(len(x.code[0])):\n            color = RED if i not in indexes else GREEN\n            color_anim.append(x.code[0][i].animate.set_color(color))\n            andd.code[0][i - 1].set_color(color)\n            if i != 0:\n                color_anim.append(y.code[0][i - 1].animate.set_color(color))\n        self.play(*color_anim, FadeIn(andd), Circumscribe(andd, color=WHITE))\n        andd.code[0][-1].restore()\n        self.play(AnimationGroup(Transform(h, CreateHighlightObject(table.get_row_labels()[3][8:])), AnimationGroup(andd.code[0][:-1].animate.move_to(pos), andd.code[0][-1].animate.set_opacity(1)), lag_ratio=0.75))\n        self.play(x.animate.restore(), y.animate.restore(), andd.animate.restore())\n        table.get_row_labels().save_state()\n        sum.move_to(table.get_row_labels()[2]).align_to(table.get_row_labels()[2], RIGHT)\n        carry.move_to(table.get_row_labels()[3]).align_to(table.get_row_labels()[3], RIGHT)\n        g = VGroup(table.get_entries((0, 2)), table.get_entries((-1, 2)), table.get_entries((-2, 2)), table.get_entries((-3, 2)))\n        plus = MyCodeKindaTho('+').move_to(table.get_entries((-2, 2))).next_to(table.get_entries((-2, 2)).code[0][1:], LEFT, buff=0.3).set_color(WHITE)\n        self.play(FadeOut(h), FadeOut(table.get_row_labels()), self.camera.frame.animate.set_width(g.width * 2).move_to(g))\n        c = (table.get_entries((-1, 2)).get_center() + table.get_entries((-2, 2)).get_center()) / 2\n        line = Line(Dot().move_to(c).align_to(table.get_entries((-3, 2)), LEFT).get_center(), Dot().move_to(c).align_to(table.get_entries((-3, 2)), RIGHT).get_center(), stroke_width=2).scale(1.25)\n        self.play(AnimationGroup(Create(line), FadeIn(plus), lag_ratio=0.25))\n        sum.next_to(table.get_entries((-1, 2)), DOWN, buff=0.1).align_to(table.get_entries((-2, 2)), RIGHT)\n        sum.code[0][:3].set_color(WHITE)\n        sum.code[0][3:].set_color(GREEN)\n        sum.code[0][2].scale(0.7).next_to(sum.code[0][4], LEFT, buff=0.08)\n        sum.code[0][0].scale(0.7).next_to(sum.code[0][2], LEFT, buff=0.08)\n        carry.next_to(table.get_entries((0, 2)), DOWN, buff=0.1).align_to(table.get_entries((-2, 2)), RIGHT)\n        carry.code[0][:3].set_color(WHITE)\n        carry.code[0][3:].set_color(ORANGE)\n        carry.code[0][2].scale(0.7).next_to(carry.code[0][4], LEFT, buff=0.08)\n        carry.code[0][0].scale(0.7).next_to(carry.code[0][2], LEFT, buff=0.08).shift(DOWN * 0.03)\n        self.play(AnimationGroup(AnimationGroup(xor.animate.set_color(GREEN), x.code[0][0].animate.set_color(GREEN), x.code[0][3].animate.set_color(GREEN), y.code[0][2].animate.set_color(GREEN)), FadeIn(sum, shift=DOWN * 0.1), lag_ratio=0.5))\n        self.play(AnimationGroup(AnimationGroup(andd.code[0][:-1].animate.set_color(ORANGE), x.code[0][1].animate.set_color(ORANGE), x.code[0][2].animate.set_color(ORANGE), y.code[0][0].animate.set_color(ORANGE), y.code[0][1].animate.set_color(ORANGE), y.code[0][-1].animate.set_color(ORANGE), x.code[0][-1].animate.set_color(ORANGE)), FadeIn(carry, shift=DOWN * 0.1), lag_ratio=0.5))\n        a, b = numbers[1]\n        a.set_z_index(1)\n        b.set_z_index(1)\n        a.move_to(numbers[0][0]).align_to(numbers[0][0], RIGHT)\n        b.move_to(numbers[0][1]).align_to(numbers[0][1], RIGHT)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(x), FadeOut(y), sum.animate.set_opacity(0.25), carry.animate.set_opacity(0.25)), AnimationGroup(numbers[0][0].animate.move_to(x).align_to(x, RIGHT).set_color(orig_color), numbers[0][1].animate.move_to(y).align_to(y, RIGHT).set_color(orig_color), plus.animate.shift(0.2 * LEFT), self.camera.frame.animate.move_to(VGroup(plus.copy().shift(0.2 * LEFT), x, y, numbers[0][0], numbers[0][1])).scale(1.1)), lag_ratio=0.5))\n        a.set_color(GREEN)\n        b.code[0][:-1].set_color(ORANGE)\n        self.play(FadeIn(a, shift=DOWN * 0.15), FadeIn(b, shift=DOWN * 0.15), sum.animate.set_opacity(1), carry.animate.set_opacity(1), numbers[0][0].code[0][1].animate.set_color(GREEN), numbers[0][0].code[0][3].animate.set_color(GREEN), numbers[0][0].code[0][4].animate.set_color(GREEN), numbers[0][1].code[0][1].animate.set_color(GREEN), numbers[0][1].code[0][3].animate.set_color(GREEN), numbers[0][1].code[0][4].animate.set_color(GREEN), numbers[0][0].code[0][0].animate.set_color(ORANGE), numbers[0][1].code[0][0].animate.set_color(ORANGE))\n        c, d = numbers[2]\n        c.set_z_index(1)\n        d.set_z_index(1)\n        a.move_to(numbers[1][0]).align_to(numbers[1][0], RIGHT)\n        b.move_to(numbers[1][1]).align_to(numbers[1][1], RIGHT)\n        c.move_to(a).align_to(a, RIGHT)\n        d.move_to(b).align_to(b, RIGHT)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(numbers[0][0]), FadeOut(numbers[0][1]), sum.animate.set_opacity(0.25), carry.animate.set_opacity(0.25)), AnimationGroup(a.animate.move_to(numbers[0][0]).align_to(numbers[0][0], RIGHT).set_color(orig_color), b.animate.move_to(numbers[0][1]).align_to(numbers[0][1], RIGHT).set_color(orig_color), plus.animate.shift(0.2 * LEFT), self.camera.frame.animate.move_to(VGroup(plus.copy().shift(0.2 * LEFT), a, b, numbers[0][0], numbers[0][1])).scale(1.1)), lag_ratio=0.5))\n        c.set_color(GREEN)\n        d.code[0][:-1].set_color(ORANGE)\n        self.play(FadeIn(c, shift=DOWN * 0.15), FadeIn(d, shift=DOWN * 0.15), sum.animate.set_opacity(1), carry.animate.set_opacity(1), a.code[0][0].animate.set_color(GREEN), a.code[0][2].animate.set_color(GREEN), a.code[0][3].animate.set_color(GREEN), b.code[0][0].animate.set_color(GREEN), b.code[0][2].animate.set_color(GREEN), b.code[0][4].animate.set_color(GREEN), b.code[0][5].animate.set_color(GREEN))\n        self.play(Circumscribe(VGroup(d, carry), color=ORANGE))\n        eq = MyCodeKindaTho('=').set_color(WHITE).rotate(PI / 2).scale(1.25).next_to(c, DOWN)\n        esix = MyCodeKindaTho('86').next_to(eq, DOWN).set_color(WHITE)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(plus), FadeOut(a), FadeOut(b), FadeOut(d), FadeOut(line), FadeOut(sum), FadeOut(carry)), AnimationGroup(FadeIn(eq, shift=DOWN * 0.15), FadeIn(esix, shift=DOWN * 0.15), c.animate.set_color(WHITE), self.camera.frame.animate.move_to(VGroup(c, eq, esix))), lag_ratio=0.5))"}]}
{"messages": [{"role": "user", "content": "Animate a grid of factories producing different items, demonstrating the grouping and transformation of product names into a logical formula and highlighting the logical relationships."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass Factories(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        seed(3735928559)\n        h = 13\n        w = 31\n        offset = w * h // 2 - 1\n        not_wanted = range(offset, offset + 3)\n        choices = sorted(['Kofola', 'Cola', 'Fanta', 'Pepsi', 'Sprite', 'Apple Juice', 'Lemon Juice', 'Oreos', 'Snickers', 'Mars', 'Kit-Kat', 'Chairs', 'Tables', 'Spoons', 'Forks', 'Knifes', 'Mayonnaise', 'Mustard', 'Ketchup', 'Ranch'])\n        products = [sample(choices, choice([1, 2, 2])) for _ in range(offset)] + [['Mars', 'Oreos'], ['Sprite'], ['Pepsi', 'Sprite']] + [sample(choices, choice([1, 2, 2])) for _ in range(offset)]\n        factories = VGroup(*[SVGMobject('assets/factory.svg').set_width(2) for _ in products]).arrange_in_grid(buff=(1, 2), cols=w)\n        self.camera.frame.move_to(VGroup(*factories[offset:offset + 3]))\n        texts = VGroup(*[VGroup(*[Tex(p) for p in pgroup]).arrange(DOWN, buff=0.25).next_to(factories[i], DOWN, buff=0.45) if len(pgroup) == 2 else VGroup(*[Tex(p) for p in pgroup]).arrange(DOWN, buff=0.25).next_to(factories[i], DOWN, buff=0.45).shift(DOWN * 0.3) for i, pgroup in enumerate(products)])\n        groups = sorted([(i, distance(f, Dot())) for i, f in enumerate(factories)], key=lambda x: x[1])\n        v = VGroup(texts, factories)\n        for i, factory in enumerate(factories):\n            if i in not_wanted:\n                continue\n            p = 0.075\n            factory.scale(uniform(1 - p, 1 + p))\n        self.play(AnimationGroup(*[FadeIn(f, shift=UP * 0.25) for f in factories[offset:offset + 3]], lag_ratio=0.1))\n        self.play(AnimationGroup(*[FadeIn(t, shift=UP * 0.25, lag_ratio=0.02) for t in texts[offset:offset + 3]], lag_ratio=0.2), self.camera.frame.animate.move_to(VGroup(*factories[offset:offset + 3], *texts[offset:offset + 3])))\n        self.camera.frame.save_state()\n        l = Line(Dot().next_to(texts[offset + 2][1], LEFT, buff=0.05).get_center(), Dot().next_to(texts[offset + 2][1], RIGHT, buff=0.05).get_center(), color=DARK_GRAY, stroke_width=2)\n        unique = Tex('$$\\\\{\\\\text{Mars}, \\\\text{Oreos}, \\\\text{Sprite}, \\\\text{Pepsi}\\\\}$$').next_to(VGroup(*texts[offset:offset + 3]), DOWN, buff=1).scale(0.8)\n        copies = VGroup(*[texts[offset][0].copy(), texts[offset][1].copy(), texts[offset + 1][0].copy(), texts[offset + 2][0].copy(), texts[offset + 2][1].copy()])\n        unique[0][0].scale(1.1).shift(LEFT * 0.05)\n        unique[0][-1].scale(1.1).shift(RIGHT * 0.05)\n        self.play(AnimationGroup(AnimationGroup(Write(unique[0][0]), Write(unique[0][-1]), FadeTransform(copies[0], unique[0][1:1 + 4].copy()), FadeTransform(copies[1], unique[0][6:6 + 5].copy()), FadeTransform(copies[2], unique[0][12:12 + 6].copy()), FadeTransform(copies[2], unique[0][19:19 + 5].copy()), FadeTransform(copies[3], unique[0][12:12 + 6].copy())), AnimationGroup(*[FadeIn(unique[0][c]) for c in [5, 11, 18]], lag_ratio=0.05), lag_ratio=0.5), self.camera.frame.animate.move_to(VGroup(*factories[offset:offset + 3], *texts[offset:offset + 3], unique)))\n        self.play(*[Succession(Wait(d / 40), FadeIn(factories[i], shift=UP * 0.1)) for i, d in groups if i not in not_wanted], *[Succession(Wait(d / 40), FadeIn(texts[i], shift=UP * 0.1)) for i, d in groups if i not in not_wanted], *[FadeOut(o) for o in self.mobjects if o not in factories[offset:offset + 3] and o not in texts[offset:offset + 3]], self.camera.frame.animate(run_time=2).set_height(v.get_height() * 1.25))\n        text = Tex('How can you do this efficiently?').scale(10).move_to(self.camera.frame)\n        self.play(factories.animate.set_opacity(0.3), texts.animate.set_opacity(0.3), FadeIn(text))\n        self.wait()\n        self.remove(text)\n        factories.set_opacity(1)\n        texts.set_opacity(1)\n        self.play(self.camera.frame.animate.restore(), *[FadeOut(f) for i, f in enumerate(factories) if i not in not_wanted], *[FadeOut(t) for i, t in enumerate(texts) if i not in not_wanted])\n        formula = Tex('$$(a) \\\\land (\\\\lnot a) \\\\land (b \\\\lor \\\\lnot c) \\\\land (c)$$').next_to(factories[offset + 1], DOWN).shift(DOWN * 3.5).scale(1.75)\n        abc = VGroup(Tex('$$a$$'), Tex('$$b$$'), Tex('$$c$$')).set_height(factories[0].height * 0.5)\n        for i in range(3):\n            abc[i].move_to(factories[offset + i])\n        abc[0].align_to(abc[1], DOWN)\n        abc[2].align_to(abc[1], DOWN)\n        parens = [0, 2, 4, 7, 9, 14, 16, 18]\n        symbols = [3, 8, 11, 15]\n        for i in symbols:\n            if i == 11:\n                continue\n            formula[0][i].scale(0.75)\n        braces = [BraceBetweenPoints(formula[0][parens[i * 2]].get_center(), formula[0][parens[i * 2 + 1]].get_center(), UP).shift(UP * 0.5) for i in range(len(parens) // 2)]\n        texts_copies = VGroup(*[texts[offset][0].copy().set_color(DARK_GRAY), texts[offset][1].copy().set_color(DARK_GRAY), texts[offset + 1][0].copy().set_color(DARK_GRAY), texts[offset + 2][0].copy().set_color(DARK_GRAY), texts[offset + 2][1].copy().set_color(DARK_GRAY)])\n        self.bring_to_back(texts_copies)\n        self.play(texts[offset][0].animate.scale(0.75).next_to(braces[0], UP), texts[offset][1].animate.scale(0.75).next_to(braces[1], UP), texts[offset + 1][0].animate.scale(0.75).next_to(braces[2], UP), texts[offset + 2][0].animate.scale(0.75).next_to(braces[3], UP), texts[offset + 2][1].animate.scale(0.75).next_to(braces[2], UP), self.camera.frame.animate.move_to(VGroup(*factories[offset:offset + 3], *texts[offset:offset + 3], formula)).set_height(VGroup(*factories[offset:offset + 3], *texts[offset:offset + 3], formula).get_height() * 1.5), AnimationGroup(*[FadeIn(formula[0][t]) for t in parens], lag_ratio=0.05), *[FadeIn(b) for b in braces])\n        self.play(AnimationGroup(*[Write(a) for a in abc]), AnimationGroup(*[f.animate.set_opacity(0.3) for f in factories[offset:offset + 3]]))\n        self.play(Transform(abc[1].copy().fade(0.8), formula[0][10].set_color(GREEN)))\n        self.play(AnimationGroup(AnimationGroup(Transform(abc[0].copy().fade(0.8), formula[0][1].set_color(GREEN)), Transform(abc[0].copy().fade(0.8), formula[0][6].set_color(RED)), FadeIn(formula[0][5].set_color(RED)), lag_ratio=0.2), AnimationGroup(Transform(abc[2].copy().fade(0.8), formula[0][17].set_color(GREEN)), Transform(abc[2].copy().fade(0.8), formula[0][13].set_color(RED)), FadeIn(formula[0][12].set_color(RED)), lag_ratio=0.2), lag_ratio=0.75))\n        self.play(AnimationGroup(*[FadeIn(formula[0][i], shift=UP * 0.2) for i in symbols], lag_ratio=0.05))\n        self.play(texts[offset][0].animate.set_color(YELLOW), texts[offset][1].animate.set_color(YELLOW), texts_copies[0].animate.set_color(YELLOW), texts_copies[1].animate.set_color(YELLOW), braces[0].animate.set_color(YELLOW), braces[1].animate.set_color(YELLOW), formula[0][parens[0]].animate.set_color(YELLOW), formula[0][parens[1]].animate.set_color(YELLOW), formula[0][parens[2]].animate.set_color(YELLOW), formula[0][parens[3]].animate.set_color(YELLOW))"}]}
{"messages": [{"role": "user", "content": "Visualize the exponential growth of a function and compare it to polynomial growth with a table, then introduce different SAT problem types."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass SATSad(MovingCameraScene):\n\n    @fade\n    def construct(self):\n\n        def f1(x):\n            return 2 ** x\n        n = 6\n        axes = Axes(x_range=[-0.05 * n, n], y_range=[-0.05 * 2 ** n, 2 ** n], x_length=6.5, y_length=4, axis_config={'include_ticks': False})\n        labels = axes.get_axis_labels(x_label='\\\\text{input}', y_label='\\\\text{time}')\n        labels[0].scale(0.8)\n        labels[1].scale(0.8)\n        g1 = axes.plot(f1, x_range=[0, n], color=BLUE)\n        l1 = axes.get_graph_label(g1, '\\\\mathcal{O}(\\\\mathrm{exp})', x_val=n * (5 / 6), direction=UP + LEFT, buff=0.1).scale(0.7)\n        tip = Triangle().set_color(BLUE).set_opacity(1.0).scale(0.15).rotate(-PI / 10).move_to(axes.coords_to_point(n, f1(n))).shift(UP * 0.07 + LEFT * 0.01)\n        thing = VGroup(axes, labels, g1, tip, l1).move_to(ORIGIN)\n        self.play(AnimationGroup(FadeIn(VGroup(axes, labels)), AnimationGroup(Write(g1), AnimationGroup(Write(tip, run_time=0.5), Write(l1)), lag_ratio=0.5), lag_ratio=0.3))\n        nof = n * (11 / 12)\n        point = Dot(axes.coords_to_point(nof, f1(nof)), color=BLUE)\n        line = axes.get_lines_to_point(axes.c2p(nof, f1(nof)))[1].set_color(BLUE)\n        text = Tex('few millennia').scale(0.65).next_to(point, RIGHT, buff=0.25).set_color(BLUE)\n        self.play(AnimationGroup(AnimationGroup(Write(point), Write(line, run_time=0.75)), FadeIn(text, shift=RIGHT * 0.2), lag_ratio=0.3))\n        self.play(FadeOut(text), FadeOut(point), FadeOut(line))\n        myTemplate = TexTemplate()\n        myTemplate.add_to_preamble('\\\\usepackage{booktabs}')\n        myTemplate.add_to_preamble('\\\\usepackage{xcolor}')\n        table = Table([[Tex('$\\\\mathcal{O}(\\\\mathrm{exp})$', color=BLUE), Tex('optimal', color=BLUE)], [Tex('$\\\\mathcal{O}(\\\\mathrm{poly})$', color=RED), Tex('almost optimal', color=RED)]], element_to_mobject=lambda x: x, row_labels=[Tex('\\\\textbf{exact}', color=BLUE), Tex('\\\\textbf{approximation}', color=RED)], col_labels=[Tex('\\\\textbf{running time}'), Tex('\\\\textbf{solution}')], v_buff=0.4, h_buff=0.65, include_outer_lines=True).scale(0.85).next_to(thing, UP, buff=1.5)\n        table.remove(*table.get_vertical_lines())\n        hlines = list(table.get_horizontal_lines())\n        table.remove(table.get_horizontal_lines()[3])\n        hlines.remove(table.get_horizontal_lines()[3])\n        hlines[2].set_stroke_width(1.5)\n        self.camera.frame.save_state()\n        self.play(self.camera.frame.animate.move_to(VGroup(table, thing)).set_height(VGroup(table, thing).get_height() * 1.45), FadeIn(table, shift=UP * 0.3))\n\n        def f2(x):\n            return x ** (3 / 2) + 1\n        g2 = axes.plot(f2, x_range=[0, n], color=RED)\n        l2 = axes.get_graph_label(g2, '\\\\mathcal{O}(\\\\mathrm{poly})', x_val=n * (6 / 6), direction=UP, buff=0.35).scale(0.7)\n        tip2 = Triangle().set_color(RED).set_opacity(1.0).scale(0.15).rotate(-PI / 2.4).move_to(axes.coords_to_point(n, f2(n))).shift(RIGHT * 0.07)\n        self.play(AnimationGroup(Write(g2), AnimationGroup(Write(tip2, run_time=0.5), Write(l2)), lag_ratio=0.5))\n        self.play(*[FadeOut(o) for o in self.mobjects])\n        best_sat = Tex('\\\\Huge BEST-SAT').shift(UP)\n        best_sat[0][0:5].set_color(GREEN)\n        lp = Tex('\\\\Large LP-SAT \\\\\\\\ \\\\vspace{0.3em} \\\\normalsize \\\\textit{also random, based on \\\\\\\\ linear programming}').move_to(best_sat).shift((RIGHT + DOWN) * 3)\n        lp[0][0:3].set_color(RED)\n        rand = Tex('\\\\Large RAND-SAT \\\\\\\\ \\\\vspace{0.3em} \\\\normalsize \\\\textit{assignment is \\\\\\\\ entirely random}').move_to(best_sat).shift((LEFT + DOWN) * 3)\n        rand[0][0:5].set_color(RED)\n        self.camera.frame.restore()\n        self.camera.frame.move_to(best_sat)\n        self.play(FadeIn(best_sat))\n        self.play(FadeIn(lp), FadeIn(rand), self.camera.frame.animate.set_y(VGroup(lp, rand, best_sat).get_y()))"}]}
{"messages": [{"role": "user", "content": "Animate the definition of RAND-SAT, zoom into its title, then scale and move the title to the top right corner of the screen."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass TransparentRANDSAT(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        sat = Tex('RAND-SAT \\\\\\\\ \\\\vspace{0.3em} \\\\textit{assignment is entirely random ($p=1/2$)}').scale(3)\n        sat[0][8:].scale(0.35).next_to(sat[0][:8], DOWN, buff=0.35)\n        self.camera.frame.save_state()\n        self.camera.frame.move_to(sat[0][0:8])\n        self.play(Write(sat[0][0:8]))\n        self.play(self.camera.frame.animate.move_to(sat), FadeIn(sat[0][8:], shift=DOWN * 0.15))\n        self.play(AnimationGroup(FadeOut(sat[0][8:]), sat[0][:8].animate.scale(1 / 2.5).move_to(config.top).align_to(config.right_side, RIGHT).shift(LEFT), lag_ratio=0.5))"}]}
{"messages": [{"role": "user", "content": "Show a large red multiplication symbol that transforms into a smaller red multiplication symbol above text stating \"Integer Linear Programming is exponential\"."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass TransparentCrossText(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        cross = Tex('\\\\Huge $$\\\\times$$').set_color(RED).scale(6)\n        self.play(FadeIn(cross))\n        text = Tex('Integer Linear Programming is \\\\textbf{exponential}.')\n        text[0][26:26 + 11].set_color(RED)\n        new_cross = cross.copy().scale(0.5)\n        VGroup(new_cross, text).arrange(DOWN, buff=1)\n        self.play(AnimationGroup(Transform(cross, new_cross), FadeIn(text), lag_ratio=0.3))"}]}
{"messages": [{"role": "user", "content": "Explain the Boolean Satisfiability Problem by transforming \"Boolean Satisfiability Problem\" into \"SAT\", displaying an example formula, highlighting clauses, and then representing each variable assignment as a 1 or 0."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass SAT(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        bsat = Tex('\\\\Huge Boolean Satisfiability Problem').scale(0.7)\n        sat = Tex('SAT').scale(4)\n        sat_cp = sat.copy()\n        self.play(Write(bsat), run_time=1.5)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(bsat[0][0:7], shift=LEFT * 0.15), FadeOut(bsat[0][10:], shift=RIGHT * 0.15)), AnimationGroup(FadeTransform(bsat[0][7], sat[0][0]), ReplacementTransform(bsat[0][8], sat[0][1]), ReplacementTransform(bsat[0][9], sat[0][2])), lag_ratio=0.5))\n        self.remove(bsat)\n        self.add(sat)\n        sat.save_state()\n        example = Tex('$$(a \\\\lor \\\\lnot b \\\\lor \\\\lnot c) \\\\land (\\\\lnot a \\\\lor d \\\\lor \\\\lnot e) \\\\land (e \\\\lor f)$$').shift(DOWN * 0.5).scale(1.25)\n        example[0][9].scale(0.75)\n        example[0][19].scale(0.75)\n        self.play(sat.animate.shift(UP * 1.2).scale(0.65), FadeIn(example, shift=UP * 0.5))\n\n        def straight_brace_points(p1, p2):\n            p2[1] = p1[1]\n            return (p1, p2)\n        braces = VGroup(BraceBetweenPoints(*straight_brace_points(example[0][0].get_center(), example[0][8].get_center())), BraceBetweenPoints(*straight_brace_points(example[0][10].get_center(), example[0][18].get_center())), BraceBetweenPoints(*straight_brace_points(example[0][20].get_center(), example[0][24].get_center()))).shift(DOWN * 0.3)\n        for brace in braces:\n            brace.add(Tex('clause').next_to(brace, DOWN))\n        self.play(AnimationGroup(*[FadeIn(brace, shift=UP * 0.1) for brace in braces], lag_ratio=0.1))\n        groups = Tex('$$[a, \\\\lnot b, \\\\lnot c] \\\\quad [\\\\lnot a, d, \\\\lnot e] \\\\quad [e, f]$$').move_to(example).scale(1.6)\n        variable_pos_example = [[1], [3, 4], [6, 7], [11, 12], [14], [16, 17], [21], [23]]\n        variable_pos_groups = [[1], [3, 4], [6, 7], [10, 11], [13], [15, 16], [19], [21]]\n        all_variable_pos_example = sum(variable_pos_example, [])\n        all_variable_pos_groups = sum(variable_pos_groups, [])\n        for q in [1, 2]:\n            self.play(AnimationGroup(*[VGroup(*[example[0][ii] for ii in i]).animate.set_color(RED if len(i) == 2 else GREEN) for i in variable_pos_example if len(i) == q], lag_ratio=0.1), AnimationGroup(*[Circumscribe(VGroup(*[example[0][ii] for ii in i]), color=RED if len(i) == 2 else GREEN, shape=Circle, buff=0.05, stroke_width=2) for i in variable_pos_example if len(i) == q], lag_ratio=0.1))\n        for i in variable_pos_groups:\n            VGroup(*[groups[0][ii] for ii in i]).set_color(RED if len(i) == 2 else GREEN)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(braces), *[FadeOut(s) for i, s in enumerate(example[0]) if i not in all_variable_pos_example]), AnimationGroup(*[ReplacementTransform(VGroup(*[example[0][ii] for ii in i]), VGroup(*[groups[0][jj] for jj in j])) for i, j in zip(variable_pos_example, variable_pos_groups)]), AnimationGroup(*[FadeIn(s) for i, s in enumerate(groups[0]) if i not in all_variable_pos_groups]), lag_ratio=0.5), run_time=2)\n        ade = [variable_pos_groups[0], variable_pos_groups[4], variable_pos_groups[6]]\n        not_ae = [variable_pos_groups[3], variable_pos_groups[5]]\n        otherslmao = [variable_pos_groups[1], variable_pos_groups[2], variable_pos_groups[7]]\n        equals = Tex('$=$').rotate(PI / 2).scale(0)\n        one = Tex('$1$').scale(0.85).next_to(equals, DOWN, buff=0.15)\n        zero = Tex('$0$').scale(0.85).next_to(equals, DOWN, buff=0.15)\n        q = Tex('$*$').scale(0.85).next_to(equals, DOWN, buff=0.2)\n        combined = VGroup(equals, one)\n        combined_zero = VGroup(equals, zero)\n        combined_q = VGroup(equals, q)\n        lmao = [combined.copy().next_to(VGroup(*[groups[0][j] for j in i]), DOWN, buff=0.2) for i in ade]\n        lmao2 = [combined_zero.copy().next_to(VGroup(*[groups[0][j] for j in i]), DOWN, buff=0.2) for i in not_ae]\n        lmao3 = [combined_q.copy().next_to(VGroup(*[groups[0][j] for j in i]), DOWN, buff=0.2) for i in otherslmao]\n        for o in lmao3:\n            o.align_to(lmao2[0], UP)\n        combined_copies = VGroup(lmao[0], lmao3[0], lmao3[1], lmao2[0], lmao[1], lmao2[1], lmao[2], lmao3[2])\n        self.play(FadeIn(lmao[0], shift=DOWN * 0.2), run_time=0.5)\n        self.play(FadeIn(lmao[1], shift=DOWN * 0.2), run_time=0.5)\n        self.play(FadeIn(lmao[2], shift=DOWN * 0.2), run_time=0.5)\n        self.play(AnimationGroup(*[FadeIn(combined_copy, shift=DOWN * 0.2) for combined_copy in lmao2], lag_ratio=0.1))\n        self.play(AnimationGroup(*[FadeIn(combined_copy, shift=DOWN * 0.2) for combined_copy in lmao3], lag_ratio=0.1))"}]}
{"messages": [{"role": "user", "content": "Demonstrate the SAT problem by showing logical clauses, assigning values to variables, and explaining the goal of maximizing satisfied clauses."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass SATAgain(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        sat = Tex('SAT').scale(4)\n        self.play(FadeIn(sat))\n        sat.save_state()\n        example = Tex('$$(a \\\\lor \\\\lnot b \\\\lor \\\\lnot c) \\\\land (\\\\lnot a \\\\lor d \\\\lor \\\\lnot e) \\\\land (e \\\\lor f)$$').shift(DOWN * 0.5).scale(1.25)\n        example[0][9].scale(0.75)\n        example[0][19].scale(0.75)\n        variable_pos_example = [[1], [3, 4], [6, 7], [11, 12], [14], [16, 17], [21], [23]]\n        for i in variable_pos_example:\n            VGroup(*[example[0][ii] for ii in i]).set_color(RED if len(i) == 2 else GREEN)\n        self.play(sat.animate.shift(UP * 1.2).scale(0.65), FadeIn(example, shift=UP * 0.5))\n        ade = [variable_pos_example[0], variable_pos_example[4], variable_pos_example[6]]\n        not_ae = [variable_pos_example[3], variable_pos_example[5]]\n        otherslmao = [variable_pos_example[1], variable_pos_example[2], variable_pos_example[7]]\n        equals = Tex('$=$').rotate(PI / 2).scale(0)\n        one = Tex('$1$').scale(0.85).next_to(equals, DOWN, buff=0.15)\n        zero = Tex('$0$').scale(0.85).next_to(equals, DOWN, buff=0.15)\n        q = Tex('$*$').scale(0.85).next_to(equals, DOWN, buff=0.2)\n        combined = VGroup(equals, one)\n        combined_zero = VGroup(equals, zero)\n        combined_q = VGroup(equals, q)\n        lmao = [combined.copy().next_to(VGroup(*[example[0][j] for j in i]), DOWN, buff=0.2) for i in ade]\n        lmao2 = [combined_zero.copy().next_to(VGroup(*[example[0][j] for j in i]), DOWN, buff=0.2) for i in not_ae]\n        lmao3 = [combined_q.copy().next_to(VGroup(*[example[0][j] for j in i]), DOWN, buff=0.2) for i in otherslmao]\n        for o in lmao3:\n            o.align_to(lmao2[0], UP)\n        self.play(AnimationGroup(*[FadeIn(combined_copy, shift=DOWN * 0.2) for combined_copy in lmao]), AnimationGroup(*[FadeIn(combined_copy, shift=DOWN * 0.2) for combined_copy in lmao2]), AnimationGroup(*[FadeIn(combined_copy, shift=DOWN * 0.2) for combined_copy in lmao3]))\n        example.add(*[o for o in lmao + lmao2 + lmao3])\n        example2 = Tex('$$(a) \\\\land (\\\\lnot a) \\\\land (b \\\\lor \\\\lnot c) \\\\land (c)$$').shift(DOWN * 0.5).align_to(example, UP)\n        example2[0][1].set_color(GREEN)\n        example2[0][5:5 + 2].set_color(RED)\n        example2[0][10].set_color(GREEN)\n        example2[0][12:12 + 2].set_color(RED)\n        example2[0][17].set_color(GREEN)\n        self.play(FadeOut(example, shift=UP * 1.5), FadeIn(example2, shift=UP * 1.5))\n        self.remove(*[o for o in lmao + lmao2 + lmao3])\n        self.play(example2[0][0].animate.set_color(YELLOW), example2[0][2].animate.set_color(YELLOW), example2[0][4].animate.set_color(YELLOW), example2[0][7].animate.set_color(YELLOW), Circumscribe(example2[0][0:7 + 1]))\n        max_sat = Tex('\\\\Huge MAX', color=BLUE)\n        dash = Tex('\\\\Huge -', color=BLUE)\n        new_sat = sat.copy()\n        ms = VGroup(max_sat, dash, new_sat).arrange(buff=0.3).move_to(sat)\n        dash.shift(LEFT * 0.08)\n        sat.set_z_index(1)\n        self.play(sat.animate.move_to(new_sat), FadeIn(max_sat, shift=LEFT * 0.5), FadeIn(dash, shift=LEFT * 0.5), example2[0][0].animate.set_color(WHITE), example2[0][2].animate.set_color(WHITE), example2[0][4].animate.set_color(WHITE), example2[0][7].animate.set_color(WHITE))\n        goal = Tex('\\\\textbf{Maximize} the number of satisfied clauses.').next_to(ms, DOWN, buff=0.45)\n        goal[0][0:8].set_color(BLUE)\n        example2_new = example2.copy().shift(DOWN)\n        self.play(self.camera.frame.animate.move_to(VGroup(ms, goal, example2_new)), FadeIn(goal, shift=DOWN * 0.8), Transform(example2, example2_new))\n        one = Tex('$1$').scale(0.65)\n        not_one = Tex('$0$').scale(0.65)\n        combined_copies = VGroup(one.copy().next_to(VGroup(*[example2[0][i] for i in [1]]), DOWN, buff=0.2), not_one.copy().next_to(VGroup(*[example2[0][i] for i in [5, 6]]), DOWN, buff=0.2), one.copy().next_to(VGroup(*[example2[0][i] for i in [10]]), DOWN, buff=0.2), not_one.copy().next_to(VGroup(*[example2[0][i] for i in [12, 13]]), DOWN, buff=0.2), one.copy().next_to(VGroup(*[example2[0][i] for i in [17]]), DOWN, buff=0.2))\n        self.play(AnimationGroup(*[FadeIn(c, shift=DOWN * 0.25) for c in combined_copies], lag_ratio=0.05))\n        self.play(AnimationGroup(*[Circumscribe(c, color=WHITE, shape=Circle, stroke_width=2.5) for i, c in enumerate(combined_copies) if i in [0, 2, 4]], lag_ratio=0.1), *[c.animate.set_opacity(0.2) for i, c in enumerate(combined_copies) if i not in [0, 2, 4]], example2.animate.set_opacity(0.2))"}]}
{"messages": [{"role": "user", "content": "Visualize the probabilistic method for the randomized satisfiability problem by highlighting clauses, showing assignment probabilities, and demonstrating expected clause satisfaction."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass RANDSATFormal(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        example = Tex('$$(a \\\\lor \\\\lnot b \\\\lor \\\\lnot c) \\\\land (\\\\lnot a \\\\lor d \\\\lor \\\\lnot e) \\\\land (e \\\\lor f)$$').scale(1.25)\n        variable_pos_example = [[1], [3, 4], [6, 7], [11, 12], [14], [16, 17], [21], [23]]\n        for i in variable_pos_example:\n            VGroup(*[example[0][ii] for ii in i]).set_color(RED if len(i) == 2 else GREEN)\n        self.play(FadeIn(example))\n        brace = BraceBetweenPoints(example[0][0].get_center(), example[0][8].get_center()).shift(DOWN * 0.3)\n        k = Tex('$$k = 3$$').next_to(brace, DOWN)\n        self.camera.frame.save_state()\n        self.play(FadeOut(example[0][9:]), FadeIn(VGroup(brace, k), shift=DOWN * 0.2), self.camera.frame.animate.move_to(VGroup(example[0][:9], brace, k)).scale(1 / 2))\n        equals = Tex('--').rotate(PI / 2).scale(0.7)\n        one = Tex('$\\\\lnot 1$').scale(0.85).next_to(equals, UP, buff=0.2)\n        zero = Tex('$0$').scale(0.85).next_to(equals, UP, buff=0.2)\n        combined_one = VGroup(equals, one)\n        combined_zero = VGroup(equals, zero)\n        combined_copies = VGroup(combined_zero.copy().next_to(VGroup(*[example[0][i] for i in variable_pos_example[0]]), UP), combined_one.copy().next_to(VGroup(*[example[0][i] for i in variable_pos_example[1]]), UP), combined_one.copy().next_to(VGroup(*[example[0][i] for i in variable_pos_example[2]]), UP))\n        for i, c in enumerate(combined_copies[1:]):\n            c.align_to(combined_copies[i], DOWN)\n        combined_copies.shift(UP * 0.1)\n        self.play(AnimationGroup(*[FadeIn(combined_copy, shift=UP * 0.2) for combined_copy in combined_copies], lag_ratio=0.05), self.camera.frame.animate.move_to(VGroup(example[0][:9], brace, k, combined_copies)))\n        psat = Tex('$$\\\\mathrm{Pr}\\\\left[\\\\text{not satisfied}\\\\right] = \\\\left(\\\\frac{1}{2}\\\\right)^k$$').move_to(k).scale(0.55)\n        self.play(AnimationGroup(FadeOut(k[0][1:]), ReplacementTransform(k[0][0], psat[0][21]), FadeIn(psat[0][:21]), lag_ratio=0.4))\n        sat = Tex('$$\\\\mathrm{Pr}\\\\left[\\\\text{satisfied}\\\\right] = 1 - \\\\left(\\\\frac{1}{2}\\\\right)^k$$').move_to(psat).scale(0.55)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(psat[0][3:3 + 3])), AnimationGroup(AnimationGroup(ReplacementTransform(psat[0][:3], sat[0][:3]), ReplacementTransform(psat[0][6:6 + 10], sat[0][3:3 + 10]), ReplacementTransform(psat[0][16:], sat[0][15:])), AnimationGroup(FadeIn(sat[0][13:13 + 2])), lag_ratio=0.3), lag_ratio=0.75))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(combined_copies), FadeOut(sat), FadeOut(brace), self.camera.frame.animate.restore()), FadeIn(example[0][9:]), lag_ratio=0.3))\n        prob = Tex('$$\\\\mathbb{E}\\\\left[\\\\text{\\\\# of sat. clauses}\\\\right] \\\\ge 1/2 \\\\cdot \\\\text{total}$$').next_to(example, DOWN, buff=1.0).scale(1.25)\n        braces = VGroup(BraceBetweenPoints(example[0][0].get_center(), example[0][8].get_center(), UP), BraceBetweenPoints(example[0][10].get_center(), example[0][18].get_center(), UP), BraceBetweenPoints(example[0][20].get_center(), example[0][24].get_center(), UP)).shift(UP * 0.3)\n        for i, brace in enumerate(braces):\n            brace.add(Tex('$$\\\\ge 1/2$$').scale(0.75).next_to(brace, UP))\n        self.play(AnimationGroup(*[FadeIn(brace, shift=UP * 0.1) for brace in braces], lag_ratio=0.1))\n        self.play(FadeIn(prob, shift=DOWN * 0.3), self.camera.frame.animate.move_to(VGroup(prob, example, braces)))"}]}
{"messages": [{"role": "user", "content": "Show the transformation from Linear Programming to LP-SAT and then to MAX-SAT with corresponding mathematical expressions and visualizations."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass TransparentLPSAT(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        lpsat = Tex('LP-SAT').scale(3)\n        lp = Tex('Linear Programming').scale(2)\n        self.play(Write(lpsat))\n        self.play(AnimationGroup(FadeOut(lpsat[0][2:]), TransformMatchingShapes(lpsat[0][0:2], lp), lag_ratio=0.5))\n        myTemplate = TexTemplate()\n        myTemplate.add_to_preamble('\\\\usepackage{amsmath}')\n        lp_table = VGroup(Tex('{\\\\bf Variables:}'), Tex('$$a, b, c, d \\\\in \\\\mathbb{R}$$'), Tex('{\\\\bf Inequalities:}'), Tex('\\\\begin{flalign*}\\n& \\\\mathbin{\\\\hphantom{-}}500a+10b+230c+10d \\\\le \\\\hphantom{5}50 \\\\\\\\\\n& \\\\mathbin{\\\\hphantom{-}}\\\\hphantom{5}10a+\\\\hphantom{1}2b-\\\\hphantom{10}7c+\\\\hphantom{10}d \\\\le 125 \\\\\\\\\\n& \\\\hphantom{5}-50a\\\\mathbin{\\\\hphantom{+}}\\\\hphantom{12b}-\\\\hphantom{1}15c\\\\mathbin{\\\\hphantom{+}}\\\\hphantom{10d} \\\\le 500 &\\n\\\\end{flalign*}', tex_template=myTemplate), Tex('{\\\\bf Maximize:}'), Tex('18a + 2b + 10c + 7d'))\n        lp_table.arrange_in_grid(cols=2, col_alignments='rl', row_alignments='uuu', buff=(0.5, 0.65))\n        new_lp = lp.copy().scale(0.75)\n        VGroup(new_lp, lp_table).arrange(DOWN, buff=1)\n        self.play(Transform(lp, new_lp))\n        self.play(Write(lp_table[0:2], run_time=1.5))\n        self.play(Write(lp_table[2:4], run_time=3))\n        self.play(Write(lp_table[4:6], run_time=1.5))\n        img = SVGMobject('assets/lp-sat.svg').stretch_to_fit_width(self.camera.frame.get_width()).stretch_to_fit_height(self.camera.frame.get_height()).move_to(self.camera.frame)\n        transforms = [*[(1, i, i) for i in range(7)], *[(3, i, i + 7) for i in range(47)], *[(5, i, i + 7 + 47) for i in range(13)]]\n        new_lp.scale(1 / 1.75).align_to(self.camera.frame, UP).align_to(self.camera.frame, RIGHT).shift((DOWN + LEFT) * 0.5)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(lp_table[0]), FadeOut(lp_table[2]), FadeOut(lp_table[4]), FadeOut(lp_table[1][0][7:]), FadeOut(lp)), AnimationGroup(Transform(lp, new_lp), AnimationGroup(*[FadeTransform(lp_table[a][0][b], img[c]) for a, b, c in transforms], lag_ratio=0.0005)), lag_ratio=0.7, run_time=2))\n        self.remove(lp)\n        self.remove(new_lp)\n        self.add(new_lp)\n        objects = []\n        for a, b, c in transforms:\n            objects.append(img[c])\n        self.play(*[FadeOut(o) for o in objects])\n        max_sat = Tex('MAX-SAT using').set_height(new_lp.get_height())\n        new_lp_2 = VGroup(max_sat, new_lp.copy()).arrange(DOWN).align_to(self.camera.frame, UP).align_to(self.camera.frame, RIGHT).shift((DOWN + LEFT) * 0.5)\n        example2 = Tex('$$(a) \\\\land (\\\\lnot a) \\\\land (b \\\\lor \\\\lnot c) \\\\land (c)$$')\n        example2[0][1].set_color(GREEN)\n        example2[0][5:5 + 2].set_color(RED)\n        example2[0][10].set_color(GREEN)\n        example2[0][12:12 + 2].set_color(RED)\n        example2[0][17].set_color(GREEN)\n        self.play(Write(example2, run_time=1), FadeIn(new_lp_2[0], shift=DOWN * 0.25), Transform(new_lp, new_lp_2[1]))\n        img = SVGMobject('assets/lp-max-sat.svg').stretch_to_fit_width(self.camera.frame.get_width()).stretch_to_fit_height(self.camera.frame.get_height()).move_to(self.camera.frame)\n        transforms = [1, 5, 6, 10, 12, 13, 17]\n        self.play(AnimationGroup(AnimationGroup(*[FadeOut(example2[0][i]) for i in range(len(example2[0])) if i not in transforms]), AnimationGroup(*[FadeTransform(example2[0][b], img[i]) for i, b in enumerate(transforms)], lag_ratio=0.0005), lag_ratio=0.7, run_time=2))\n        self.remove(img)\n        self.remove(example2)\n        objects = []\n        for i, b in enumerate(transforms):\n            objects.append(img[i])\n        self.play(*[FadeOut(o) for o in objects])"}]}
{"messages": [{"role": "user", "content": "Demonstrate the proof of the approximation ratio for LP-SAT by transforming mathematical expressions and highlighting key steps with color and bounding boxes."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass Proof(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        tex = Tex('How good is LP-SAT?').scale(1.8)\n        self.play(Write(tex))\n        self.play(FadeOut(tex))\n        tex_ag = Tex('$$\\\\prod_{i = 1}^{n} \\\\sqrt[n]{a_i} \\\\le \\\\frac{1}{n} \\\\sum_{i = 1}^{n} a_i$$')\n        sr_ag = SurroundingRectangle(tex_ag, buff=0.25, color=WHITE)\n        text_ag = Tex('A')\n        tex_jen = Tex('$f$ concave on $[0, 1]$, $f(0) = a$, $f(1) = a + b$', '$$\\\\implies$$', '$$\\\\forall x \\\\in \\\\left[0, 1\\\\right]: f(x) \\\\le a + bx$$')\n        tex_jen[1].rotate(-PI / 2).scale(0.85)\n        sr_jen = SurroundingRectangle(tex_jen, buff=0.35, color=WHITE)\n        text_jen = Tex('B')\n        ag = VGroup(tex_ag, sr_ag)\n        jen = VGroup(tex_jen, sr_jen)\n        self.play(Write(ag[0], run_time=2))\n        self.play(Write(ag[1]))\n        self.play(Circumscribe(ag[0][0][0:10], color=RED), ag[0][0][0:10].animate.set_color(RED))\n        self.play(Circumscribe(ag[0][0][11:], color=BLUE), ag[0][0][11:].animate.set_color(BLUE))\n        copies = VGroup(ag.copy().set_height(1.25), jen.copy().set_height(1.25)).arrange().align_to(config.top, UP).shift(DOWN * 0.4)\n        text_ag.move_to(copies[0])\n        copies[0][0].set_opacity(0.2).set_color(WHITE)\n        self.play(Succession(Transform(ag, copies[0]), Write(text_ag)))\n        ag.add(text_ag)\n        self.play(Write(tex_jen[0][:15]), run_time=1.4)\n        self.play(Write(tex_jen[0][15:22]), run_time=1)\n        self.play(Write(tex_jen[0][22:]), run_time=1)\n        self.play(FadeIn(tex_jen[1], shift=DOWN * 0.25))\n        self.play(Write(tex_jen[2], run_time=1.5))\n        self.play(Write(sr_jen))\n        text_jen.move_to(copies[1])\n        self.play(Transform(jen, copies[1]))\n\n        def f1(x):\n            return (1 - x) ** 4 + 2 * (1 - x) ** 2 - 4 * (1 - x) + 2\n\n        def f2(x):\n            return x + 1\n        axes = Axes(x_range=[-0.25, 1.15], y_range=[0, 3], x_axis_config={'numbers_to_include': [0, 1], 'numbers_to_exclude': None}, x_length=5, y_length=3)\n        labels = axes.get_axis_labels(x_label='x', y_label='y')\n        labels[0].scale(0.8)\n        labels[1].scale(0.8)\n        d1 = Dot().move_to(axes.coords_to_point(*(0, 1))).set_z_index(1)\n        d2 = Dot().move_to(axes.coords_to_point(*(1, 2))).set_z_index(1)\n        d3 = Dot().move_to(axes.coords_to_point(*(0, 2))).set_z_index(1)\n        g1 = axes.plot(f1, color=RED)\n        g2 = axes.plot(f2, color=BLUE, x_range=[0, 1])\n        a = Tex('$a$').scale(0.4).next_to(d1, LEFT, buff=0.1)\n        apb = Tex('$a+b$').scale(0.4).next_to(d3, RIGHT, buff=0.1)\n        l1 = axes.get_graph_label(g1, 'f(x)', x_val=0.85, direction=DOWN + RIGHT, buff=0.1).scale(0.7)\n        l2 = axes.get_graph_label(g2, 'a + bx', x_val=0.7, direction=UP, buff=0.2).scale(0.7)\n        g = VGroup(axes, labels, g1, g2, d1, d2, l1, l2, a, apb).shift(DOWN * 0.65)\n        self.play(AnimationGroup(AnimationGroup(FadeIn(axes), FadeIn(labels)), AnimationGroup(Write(d1), Write(d2), Write(a), Write(apb), AnimationGroup(AnimationGroup(Write(g1), Write(l1)), AnimationGroup(Write(g2), Write(l2)), lag_ratio=0.5)), lag_ratio=0.5))\n        self.play(AnimationGroup(AnimationGroup(jen[0].animate.set_opacity(0.2), FadeOut(g)), Write(text_jen), lag_ratio=0.5))\n        jen.add(text_jen)\n        lp_table = VGroup(Tex('{\\\\bf Variables:}'), Tex('$$y_i\\\\ \\\\text{(literals) and}\\\\ z_j\\\\ \\\\text{(clauses)} \\\\in \\\\left[0, 1\\\\right] $$'), Tex('{\\\\bf Inequalities:}'), Tex('$$z_j \\\\le \\\\sum_{\\\\text{positive}} y_i + \\\\sum_{\\\\text{negative}} \\\\left(1-y_i\\\\right)$$'), Tex('{\\\\bf Maximize:}'), Tex('$$\\\\sum z_j\\\\ \\\\text{(satisfied clauses)}$$ '))\n        lp_table.arrange_in_grid(cols=2, col_alignments='rl', row_alignments='uuu', buff=(0.5, 0.8)).scale(0.75).shift(DOWN * 0.75)\n        lp_table[2].shift(DOWN * 0.11)\n        lp_table[4].shift(DOWN * 0.1)\n        self.play(FadeIn(lp_table, run_time=1.5))\n        consider = Tex('$$y_i^*, z_j^* \\\\qquad C_j\\\\ \\\\text{with}\\\\ k_j\\\\ \\\\text{literals}$$').shift(DOWN * 0.5)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(lp_table[0]), FadeOut(lp_table[1]), FadeOut(lp_table[2]), FadeOut(lp_table[3]), FadeOut(lp_table[4]), FadeOut(lp_table[5])), AnimationGroup(AnimationGroup(ReplacementTransform(lp_table[1][0][0], VGroup(consider[0][0])), ReplacementTransform(lp_table[1][0][1], VGroup(consider[0][2])), ReplacementTransform(lp_table[1][0][15], VGroup(consider[0][4])), ReplacementTransform(lp_table[1][0][16], VGroup(consider[0][6]))), Write(VGroup(consider[0][1], consider[0][3], consider[0][5]), run_time=1.5), lag_ratio=1), lag_ratio=0.5))\n        self.play(Write(consider[0][7:]))\n        proof_not_satisfied = Tex('$$\\n\\\\begin{aligned}\\n    \\\\mathrm{Pr}\\\\left[C_j\\\\ \\\\text{is not satisfied}\\\\right] &= \\\\prod_{\\\\text{positive}} (1 - y^*_i)\\\\prod_{\\\\text{negative}} y^*_i & \\\\\\\\\\n    &\\\\overset{A}{\\\\le} \\\\left[\\\\frac{1}{k_j} \\\\left(\\\\sum_{\\\\text{positive}} (1 - y^*_i) + \\\\sum_{\\\\text{negative}} y^*_i\\\\right)\\\\right]^{k_j} & \\\\\\\\\\n    &= \\\\left[1 - \\\\frac{1}{k_j} \\\\left(\\\\sum_{\\\\text{positive}} y^*_i + \\\\sum_{\\\\text{negative}} (1 - y^*_i)\\\\right)\\\\right]^{k_j} & \\\\\\\\\\n    &\\\\le \\\\left[1 - \\\\frac{z_j^*}{k_j}\\\\right]^{k_j}\\n\\\\end{aligned}$$').scale(0.65)\n        o1 = 27\n        o2 = 1\n        p1 = VGroup(proof_not_satisfied[0][:75 - o1]).move_to(ORIGIN).shift(DOWN * 0.2)\n        p2 = VGroup(proof_not_satisfied[0][75 - o1:119 - o1 + o2]).next_to(p1, DOWN).align_to(p1[0][19], LEFT)\n        self.play(AnimationGroup(consider.animate.next_to(VGroup(ag, jen), DOWN, buff=0.5), Write(p1[0][:19], run_time=1.25), lag_ratio=0.75))\n        self.play(Write(p1[0][19:], run_time=1.25))\n        combined = VGroup(p1.copy(), p2.copy()).move_to(ORIGIN).align_to(p1, UP)\n        self.play(Transform(p1, combined[0]), FadeIn(p2.become(combined[1].set_color(BLUE)), shift=LEFT), ag.animate.set_color(BLUE), ag[0].animate.set_opacity(1).set_color(BLUE), ag[2].animate.set_opacity(0))\n        p1_firstpart = p1[0][19:]\n        p2_copy = p2.copy()\n        align_object_by_coords(p2_copy, p2_copy[0][1].get_center(), p1[0][19].get_center())\n        p3 = VGroup(proof_not_satisfied[0][119 - o1 + o2:164 - o1 + o2 * 2]).next_to(p2_copy, DOWN).align_to(p2[0][1], LEFT)\n        self.play(FadeOut(p1_firstpart, shift=UP * 1.45), align_object_by_coords(p2, p2[0][1].get_center(), p1[0][19].get_center(), animation=True), FadeIn(p3, shift=UP * 1.45))\n        self.play(Circumscribe(p3[0][9:42], run_time=1.5), p3[0][9:42].animate(run_time=1.5).set_color(YELLOW))\n        p3_copy = p3.copy()\n        align_object_by_coords(p3_copy, p3_copy[0][0].get_center(), p2[0][1].get_center())\n        p4 = VGroup(proof_not_satisfied[0][164 - o1 + o2 * 2:]).next_to(p3_copy, DOWN).align_to(p3[0][0], LEFT)\n        p4[0][4:4 + 3].set_color(YELLOW)\n        self.play(FadeOut(p2, shift=UP * 1.45), align_object_by_coords(p3, p3[0][0].get_center(), p2[0][1].get_center(), animation=True), FadeIn(p4, shift=UP * 1.45))\n        self.play(FadeOut(p3, shift=UP * 1.3), align_object_by_coords(p4, p4[0][0].get_center(), p3[0][0].get_center(), animation=True).set_color(WHITE))\n        p5 = Tex('$$\\\\ge 1 - \\\\left[1 - \\\\frac{z_j^*}{k_j}\\\\right]^{k_j}$$').scale(0.65)\n        p5_with_overset = Tex('$$\\\\ge \\\\overbrace{1 - \\\\left[1 - \\\\frac{z_j^*}{k_j}\\\\right]^{k_j}}^{f(z_j^*)}$$').scale(0.65)\n        align_object_by_coords(p5, p5[0][0].get_center(), p4[0][0].get_center())\n        align_object_by_coords(p5_with_overset, p5_with_overset[0][0].get_center(), p4[0][0].get_center())\n        self.play(AnimationGroup(AnimationGroup(FadeOut(p1[0][7:7 + 3]), p4[0][0].animate.flip(), ReplacementTransform(p4[0][1:], p5[0][3:])), AnimationGroup(FadeIn(p5[0][1:3]), p1[0][:7].animate.shift(RIGHT * 0.55)), lag_ratio=0.35))\n        self.remove(p4)\n        self.remove(p4[0][0])\n        self.add(p5)\n        self.play(FadeIn(p5_with_overset[0][1:13], shift=UP * 0.1))\n        self.remove(p5)\n        self.add(p5_with_overset)\n        p6 = Tex('$$\\\\overset{B}{\\\\ge} \\\\left[1 - \\\\left(1 - \\\\frac{1}{k_j}\\\\right)^{k_j}\\\\right] z^*_j$$').scale(0.65).set_color(RED)\n        p6.next_to(p5, DOWN).align_to(p5, LEFT)\n        self.play(FadeIn(p6, shift=UP * 0.25), jen.animate.set_color(RED), jen[0].animate.set_opacity(1).set_color(RED), jen[2].animate.set_opacity(0))\n        self.remove(p5)\n        p7 = Tex('$$\\\\ge \\\\left(1 - \\\\frac{1}{e}\\\\right) z^*_j$$').scale(0.65)\n        p8 = Tex('$$\\\\approx 0.63z^*_j$$').scale(0.65)\n        p6_copy = p6.copy()\n        align_object_by_coords(p6_copy, p6_copy[0][1].get_center(), p5_with_overset[0][0].get_center())\n        p7.next_to(p6_copy, DOWN).align_to(p6_copy[0][1], LEFT)\n        self.play(p6[0][5:15].animate.set_color(YELLOW), Circumscribe(p6[0][5:15]))\n        p7[0][4:4 + 3].set_color(YELLOW)\n        self.play(FadeOut(p5_with_overset, shift=UP * 1.15), align_object_by_coords(p6, p6[0][1].get_center(), p5_with_overset[0][0].get_center(), animation=True), FadeIn(p7, shift=UP * 1.15))\n        p8.next_to(p7, RIGHT, buff=0.15).align_to(p7[0][-1], DOWN)\n        self.play(Write(p8))\n        p7.add(p8)\n        p7_copy = p7.copy().set_color(WHITE)\n        align_object_by_coords(p7_copy, p7_copy[0][0].get_center(), p6[0][1].get_center())\n        p1_copy = p1[0][:19].copy()\n        a = VGroup(p1_copy, p7_copy).scale(1.5).move_to(ORIGIN).shift(UP * 0.2)\n        p1_copy[7:7 + 3].set_opacity(0)\n        p1[0][7:7 + 3].set_opacity(0)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(p6), FadeOut(ag), FadeOut(jen), FadeOut(consider)), AnimationGroup(Transform(p1[0][:19], p1_copy), Transform(p7, p7_copy)), lag_ratio=0.5))\n        p9 = Tex('$$\\\\mathbb{E}\\\\left[\\\\text{\\\\# of sat. clauses}\\\\right] = \\\\sum_j \\\\mathrm{Pr}\\\\left[C_j\\\\ \\\\text{is satisfied}\\\\right]$$').scale(0.65).scale(1.5)\n        p9.next_to(a, DOWN, buff=1)\n        self.play(Write(p9), self.camera.frame.animate.move_to(VGroup(a, p9)))\n        cplmao = p7[0][1:1 + 10].copy().next_to(p9[0][18], RIGHT, buff=0.13)\n        self.play(p7[0][0].animate.move_to(p9[0][17]), FadeOut(p9[0][17]), p7[0][1:1 + 10].animate.next_to(p9[0][18], RIGHT, buff=0.13), Transform(p7[0][1:1 + 10], cplmao), FadeOut(p9[0][20:]), FadeOut(p1[0][:19]), FadeOut(p8), self.camera.frame.animate.move_to(VGroup(p9[0][:20], cplmao)))\n        self.play(p7[0][1:1 + 7].animate.align_to(p9[0][18], LEFT), p9[0][18:18 + 2].animate.align_to(p7[0][1:1 + 7], RIGHT))\n        vg = VGroup(p9[0][18:18 + 2], p7[0][1 + 7:1 + 7 + 3])\n        opt = Tex('OPT').align_to(vg, LEFT).align_to(p9[0][6], DOWN).shift(DOWN * 0.06)\n        self.play(FadeTransform(vg, opt))"}]}
{"messages": [{"role": "user", "content": "Display and animate tables comparing RAND-SAT and LP-SAT probabilities for clause satisfaction, with explanations of variables and highlighting of specific values."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass BestSAT(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        table = Table([[Tex('$$\\\\left[1 - \\\\left(\\\\frac{1}{2}\\\\right)^{k_j}\\\\right] z^*_j$$')], [Tex('$$\\\\left[1 - \\\\left(1 - \\\\frac{1}{k_j}\\\\right)^{k_j}\\\\right] z^*_j$$')]], element_to_mobject=lambda x: x, row_labels=[Tex('RAND-SAT'), Tex('LP-SAT')], col_labels=[Tex('$$\\\\mathrm{Pr}\\\\left[C_j\\\\ \\\\text{is satisfied}\\\\right] \\\\ge$$')], v_buff=0.4, h_buff=0.65, include_outer_lines=True)\n        table.remove(*table.get_vertical_lines())\n        hlines = list(table.get_horizontal_lines())\n        table.remove(table.get_horizontal_lines()[3])\n        hlines.remove(table.get_horizontal_lines()[3])\n        hlines[2].set_stroke_width(1.5)\n        self.play(AnimationGroup(FadeIn(table.get_entries((0, 0)), shift=RIGHT * 0.5), FadeIn(table.get_entries((1, 0)), shift=RIGHT * 0.5), lag_ratio=0.75))\n        self.play(Write(VGroup(*sorted(hlines, key=lambda x: -x.get_y()))), FadeIn(table.get_labels()[0]))\n        self.play(AnimationGroup(FadeIn(table.get_entries((0, 1))[0][1:10], shift=RIGHT * 0.5), FadeIn(table.get_entries((1, 1)), shift=RIGHT * 0.5), lag_ratio=0.25))\n        z_j = Tex('$z^*_j \\\\in \\\\left[0, 1\\\\right] \\\\ldots$ how can the clause be satisfied \\\\textbf{in the optimal case}').scale(0.75)\n        z_j.next_to(table, DOWN, buff=0.75)\n        z_j_opt = Tex('$\\\\ldots$ $\\\\sum z_j^* = \\\\text{OPT}$ (sum of clause variables)').scale(0.75).next_to(z_j, DOWN).align_to(z_j[0][9], LEFT)\n        self.play(FadeIn(z_j, shift=DOWN * 0.5), self.camera.frame.animate.move_to(VGroup(z_j, table)).set_width(VGroup(table, z_j).get_width() * 1.5))\n        self.play(FadeIn(z_j_opt, shift=DOWN * 0.25), self.camera.frame.animate.move_to(VGroup(z_j, table, z_j_opt)).set_width(VGroup(table, z_j).get_width() * 1.6))\n        self.play(FadeIn(table.get_entries((0, 1))[0][0], shift=RIGHT * 0.25), FadeIn(table.get_entries((0, 1))[0][10:], shift=LEFT * 0.25))\n        table2 = Table([[Tex('$$\\\\frac{1}{2} z_j^*$$'), Tex('$$\\\\frac{3}{4} z_j^*$$'), Tex('$$\\\\frac{7}{8} z_j^*$$'), Tex('$$\\\\frac{15}{16} z_j^*$$')], [Tex('$$1 z_j^*$$'), Tex('$$\\\\frac{3}{4} z_j^*$$'), Tex('$$\\\\approx 0.703 z_j^*$$'), Tex('$$\\\\approx 0.683 z_j^*$$')]], element_to_mobject=lambda x: x, row_labels=[Tex('RAND-SAT'), Tex('LP-SAT')], col_labels=[Tex('1'), Tex('2'), Tex('3'), Tex('4')], top_left_entry=Tex('$k$ (clause size)').scale(0.7), v_buff=0.4, h_buff=0.65, include_outer_lines=True)\n        table3 = Table([[Tex('$$\\\\frac{1}{2} z_j^*$$'), Tex('$$\\\\frac{3}{4} z_j^*$$'), Tex('$$\\\\frac{7}{8} z_j^*$$'), Tex('$$\\\\frac{15}{16} z_j^*$$')], [Tex('$$1 z_j^*$$'), Tex('$$\\\\frac{3}{4} z_j^*$$'), Tex('$$\\\\approx 0.703 z_j^*$$'), Tex('$$\\\\approx 0.683 z_j^*$$')], [Tex('$$\\\\frac{3}{4} z_j^*$$'), Tex('$$\\\\frac{3}{4} z_j^*$$'), Tex('$$\\\\frac{3}{4} z_j^*$$'), Tex('$$\\\\frac{3}{4} z_j^*$$')]], element_to_mobject=lambda x: x, row_labels=[Tex('RAND-SAT'), Tex('LP-SAT'), Tex('BEST-SAT')], col_labels=[Tex('1'), Tex('2'), Tex('3'), Tex('4')], top_left_entry=Tex('$k$ (clause size)').scale(0.7), v_buff=0.4, h_buff=0.65, include_outer_lines=True)\n        table2.remove(*table2.get_vertical_lines())\n        hlines2 = list(table2.get_horizontal_lines())\n        table2.remove(table2.get_horizontal_lines()[3])\n        hlines2.remove(table2.get_horizontal_lines()[3])\n        hlines2[2].set_stroke_width(1.5)\n        table3.remove(*table3.get_vertical_lines())\n        hlines3 = list(table3.get_horizontal_lines())\n        table3.remove(table3.get_horizontal_lines()[3])\n        hlines3.remove(table3.get_horizontal_lines()[3])\n        hlines3[2].set_stroke_width(1.5)\n        self.play(AnimationGroup(FadeOut(table), AnimationGroup(self.camera.frame.animate.move_to(VGroup(z_j, table2)).set_width(VGroup(table2, z_j).get_width() * 1.5), Transform(table.get_row_labels()[0], table2.get_row_labels()[0]), Transform(table.get_row_labels()[1], table2.get_row_labels()[1]), run_time=0.75), AnimationGroup(FadeIn(VGroup(*table2.get_col_labels())), FadeIn(VGroup(*table2.get_entries_without_labels())), FadeIn(table2.top_left_entry), Write(VGroup(*sorted(hlines2, key=lambda x: -x.get_y())))), lag_ratio=0.5))\n        for o in self.mobjects:\n            self.remove(o)\n        self.add(table2)\n        self.add(z_j)\n        self.add(z_j_opt)\n        res = 1000\n        cols = color_gradient([RED, RED, GREEN], res + 1)\n        self.play(Circumscribe(VGroup(table2.get_entries((2, 2)), table2.get_entries((2, 3)), table2.get_entries((2, 4)), table2.get_entries((2, 5))), color=WHITE), table2.get_entries((2, 2)).animate.set_color(cols[int(1 / 2 * res)]), table2.get_entries((2, 3)).animate.set_color(cols[int(3 / 4 * res)]), table2.get_entries((2, 4)).animate.set_color(cols[int(7 / 8 * res)]), table2.get_entries((2, 5)).animate.set_color(cols[int(15 / 16 * res)]))\n        self.play(Circumscribe(VGroup(table2.get_entries((3, 2)), table2.get_entries((3, 3)), table2.get_entries((3, 4)), table2.get_entries((3, 5))), color=WHITE), table2.get_entries((3, 2)).animate.set_color(cols[int(1 * res)]), table2.get_entries((3, 3)).animate.set_color(cols[int(3 / 4 * res)]), table2.get_entries((3, 4)).animate.set_color(cols[int(0.703 * res)]), table2.get_entries((3, 5)).animate.set_color(cols[int(0.683 * res)]))\n        table3.get_entries((4, 2)).set_color(cols[int(3 / 4 * res)])\n        table3.get_entries((4, 3)).set_color(cols[int(3 / 4 * res)])\n        table3.get_entries((4, 4)).set_color(cols[int(3 / 4 * res)])\n        table3.get_entries((4, 5)).set_color(cols[int(3 / 4 * res)])\n        calc = Tex('$$\\\\approx 0.632 z_j^*$$').set_color(cols[int(0.632 * res)]).move_to(table2.get_entries((3, 4)))\n        calc2 = calc.copy().move_to(table2.get_entries((3, 5)))\n        sorted_lines2 = list(sorted(hlines2, key=lambda x: -x.get_y()))\n        sorted_lines3 = list(sorted(hlines3, key=lambda x: -x.get_y()))\n        align_object_by_coords(table3, sorted_lines3[0], sorted_lines2[0])\n        c = DOWN * 1\n        cp = z_j_opt.copy().shift(c)\n        self.play(sorted_lines2[-1].animate.move_to(sorted_lines3[-1]), FadeIn(table3.get_row_labels()[2], shift=DOWN * 0.4), z_j.animate.shift(c), z_j_opt.animate.shift(c), self.camera.frame.animate.move_to(VGroup(z_j, z_j_opt, cp, table2)).set_width(VGroup(table2, z_j, z_j_opt, cp).get_width() * 1.6))\n        a1 = ArcBetweenPoints(Dot().next_to(table2.get_row_labels()[0], LEFT).get_center(), Dot().next_to(table3.get_row_labels()[2], LEFT).get_center())\n        a2 = ArcBetweenPoints(Dot().next_to(table2.get_row_labels()[1], LEFT).get_center(), Dot().next_to(table3.get_row_labels()[2], LEFT).get_center())\n        self.play(AnimationGroup(Create(a1, run_time=0.75), Create(a2, run_time=0.75), lag_ratio=0.5))\n        self.play(FadeOut(table2.get_entries((3, 4))[0][1:-3], shift=DOWN * 0.5), FadeOut(table2.get_entries((3, 5))[0][1:-3], shift=DOWN * 0.5), FadeIn(calc[0][1:-3], shift=DOWN * 0.5), FadeIn(calc2[0][1:-3], shift=DOWN * 0.5))\n        self.next_section()\n        for i in range(4):\n            self.play(Transform(table2.get_entries((2, 2 + i)).copy(), table3.get_entries((4, 2 + i)).copy()), Transform(table2.get_entries((3, 2 + i)).copy(), table3.get_entries((4, 2 + i)).copy()), run_time=1 - 0.1 * i)\n        self.play()"}]}
{"messages": [{"role": "user", "content": "Display the relaxed MAX-SAT problem formulation and then illustrate the MAX-SAT and Relaxed MAX-SAT concepts on a number line."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass TransparentRelaxedMAXSAT(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        table = VGroup(Tex('{\\\\bf Variables:}'), Tex('$$y_i\\\\ \\\\text{(literals) and}\\\\ z_j\\\\ \\\\text{(clauses)} \\\\in \\\\left\\\\{0, 1\\\\right\\\\}$$'), Tex('{\\\\bf Inequalities:}'), Tex('$$z_j \\\\le \\\\sum_{\\\\text{positive}} y_i + \\\\sum_{\\\\text{negative}} \\\\left(1-y_i\\\\right)$$'), Tex('{\\\\bf Maximize:}'), Tex('$$\\\\sum z_j\\\\ \\\\text{(satisfied clauses)}$$ '))\n        table.arrange_in_grid(cols=2, col_alignments='rl', row_alignments='uuu', buff=(0.5, 0.8))\n        table[2].shift(DOWN * 0.1)\n        table[4].shift(DOWN * 0.095)\n        self.play(FadeIn(table))\n        for i in [1, 3, 5]:\n            sr = SurroundingRectangle(table[i], color=WHITE, buff=0.25)\n            self.play(Create(sr), run_time=0.75)\n            self.play(FadeOut(sr), run_time=0.75)\n        table2 = VGroup(Tex('{\\\\bf Variables:}'), Tex('$$y_i\\\\ \\\\text{(literals) and}\\\\ z_j\\\\ \\\\text{(clauses)} \\\\in \\\\left[0, 1\\\\right]$$'), Tex('{\\\\bf Inequalities:}'), Tex('$$z_j \\\\le \\\\sum_{\\\\text{positive}} y_i + \\\\sum_{\\\\text{negative}} \\\\left(1-y_i\\\\right)$$'), Tex('{\\\\bf Maximize:}'), Tex('$$\\\\sum z_j\\\\ \\\\text{(satisfied clauses)}$$ '))\n        table2.arrange_in_grid(cols=2, col_alignments='rl', row_alignments='uuu', buff=(0.5, 0.8))\n        table2[2].shift(DOWN * 0.1)\n        table2[4].shift(DOWN * 0.095)\n        table2[1][0][27].move_to(table[1][0][27]).scale(-1).flip()\n        table2[1][0][27 + 4].move_to(table[1][0][27 + 4]).scale(-1).flip()\n        self.play(Flash(table[1][0][27:27 + 5], color=WHITE, flash_radius=0.7), ReplacementTransform(table[1][0][27], table2[1][0][27]), ReplacementTransform(table[1][0][27 + 4], table2[1][0][27 + 4]))\n        example2 = Tex('$$(a) \\\\land (\\\\lnot a \\\\lor b) \\\\land (\\\\lnot a \\\\lor \\\\lnot b)$$').next_to(table2, DOWN, buff=1.5)\n        example2[0][1].set_color(GREEN)\n        example2[0][5:5 + 2].set_color(RED)\n        example2[0][8].set_color(GREEN)\n        example2[0][12:12 + 2].set_color(RED)\n        example2[0][15:15 + 2].set_color(RED)\n        self.play(FadeIn(example2, shift=DOWN * 0.25), self.camera.frame.animate.move_to(VGroup(table2, example2)).set_height(VGroup(table2, example2).get_height() * 1.5))\n        img = SVGMobject('assets/lp-max-sat-relax.svg').stretch_to_fit_width(self.camera.frame.get_width()).stretch_to_fit_height(self.camera.frame.get_height()).move_to(self.camera.frame)\n        tfs1 = [28, 30]\n        tfs2 = [1, 5, 6, 8, 12, 13, 15, 16]\n        text = VGroup(Tex('Relaxed MAX-SAT using'), Tex('Linear Programming')).scale(0.9).arrange(DOWN).align_to(self.camera.frame, UP).align_to(self.camera.frame, RIGHT).shift((DOWN + LEFT) * 0.5)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(table[0]), FadeOut(table[2]), FadeOut(table[4]), FadeOut(table[5]), FadeOut(table[3]), *[FadeOut(c) for i, c in enumerate(table2[1][0]) if i in [27, 31]], *[FadeOut(c) for i, c in enumerate(table[1][0]) if i not in tfs1], *[FadeOut(c) for i, c in enumerate(example2[0]) if i not in tfs1]), AnimationGroup(FadeIn(text), AnimationGroup(FadeTransform(table[1][0][28].copy(), img[0]), FadeTransform(table[1][0][28], img[2]), FadeTransform(table[1][0][30].copy(), img[1]), FadeTransform(table[1][0][30], img[3]), FadeTransform(example2[0][1], img[4]), FadeTransform(example2[0][5], img[5]), FadeTransform(example2[0][6], img[6]), FadeTransform(example2[0][8], img[7]), FadeTransform(example2[0][12], img[8]), FadeTransform(example2[0][13], img[9]), FadeTransform(example2[0][15], img[10]), FadeTransform(example2[0][16], img[11]), lag_ratio=0.0005)), lag_ratio=0.7, run_time=2))\n        self.play(*[FadeOut(o) for o in self.mobjects if o != text and o is not text])\n        return\n        nl = NumberLine(x_range=[0, 11, 1], length=10, include_tip=True, include_numbers=False).next_to(table, DOWN, buff=2)\n        nl.add_numbers(x_values=[0])\n        tm = nl.get_tick_marks()\n        nl.remove(tm)\n        nl.add(tm[0])\n        tm[0].set_z_index(1).set_stroke_width(4)\n        tm[9].set_z_index(1).set_stroke_width(4)\n        tm[10].set_z_index(1).set_stroke_width(4)\n        l1 = Line(tm[0].get_center(), tm[9].get_center(), stroke_width=6, color=GREEN).set_z_index(0.8)\n        ms = Tex('MAX-SAT', color=BLUE).next_to(tm[9], DOWN, buff=0.4)\n        tm[9].set_color(BLUE).set_stroke_width(5).scale(1.2)\n        rms = Tex('Relaxed MAX-SAT', color=ORANGE).next_to(tm[10], UP, buff=0.4)\n        tm[10].set_color(ORANGE).set_stroke_width(5).scale(1.2)\n        self.play(FadeIn(nl, shift=DOWN * 0.5), self.camera.frame.animate.move_to(VGroup(table, nl, ms)).set_width(VGroup(table, nl, ms).get_width() * 1.6))\n        self.play(FadeIn(tm[10]), FadeIn(rms, shift=DOWN * 0.25))\n        self.play(FadeIn(tm[9]), FadeIn(ms, shift=UP * 0.25))\n        omsa = Tex('Approximation', color=GREEN).next_to(l1, UP, buff=0.4).align_to(rms, UP).shift(LEFT)\n        self.play(Create(l1), FadeIn(omsa, shift=RIGHT * 0.25))"}]}
{"messages": [{"role": "user", "content": "Write the text \"assign true to a literal with the probability of its corresponding variable\" on the screen."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass TransparentMoreExplainPls(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        tex = Tex('assign true to a \\\\textbf{literal} with the', 'probability of its corresponding \\\\textbf{variable}').arrange(DOWN).next_to(config.bottom, UP, buff=1)\n        self.play(Write(tex))"}]}
{"messages": [{"role": "user", "content": "Display the text \"LP-SAT\" in large font near the top right of the screen."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass TransparentLPSAT2(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        tex = Tex('LP-SAT').scale(1.3).align_to(self.camera.frame, UP).align_to(self.camera.frame, RIGHT).shift((DOWN + LEFT) * 0.8)\n        self.play(Write(tex))"}]}
{"messages": [{"role": "user", "content": "Display the text \"The Remarkable\", a complex logical formula, and \"Algorithm\" with additional text and arrows overlaid, creating a thumbnail for the \"LP-SAT\" and \"RAND-SAT\" algorithms."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass Thumbnail(MovingCameraScene):\n\n    def construct(self):\n        a = Tex('The Remarkable').scale(1.55)\n        formula = Tex('$$(\\\\mathrm{B} \\\\kern-0.25em\\\\lor\\\\kern-0.25em \\\\mathrm{E} \\\\kern-0.25em\\\\lor\\\\kern-0.25em \\\\mathrm{S} \\\\kern-0.25em\\\\lor\\\\kern-0.25em \\\\mathrm{T}) \\\\land (\\\\mathrm{S} \\\\kern-0.25em\\\\lor\\\\kern-0.4em \\\\mathrm{A} \\\\kern-0.4em\\\\lor\\\\kern-0.25em \\\\mathrm{T})$$').scale(2.2)\n        c = Tex('Algorithm').scale(1.75)\n        for i in [2, 4, 6, 9, 12, 14]:\n            formula[0][i].scale(0.75)\n        for i in [1, 3, 5, 7, 11, 13, 15]:\n            formula[0][i].set_color(GREEN)\n        opacity = 0.5\n        self.add(formula, a, c)\n        a.next_to(formula, UP, buff=0.7).align_to(formula, LEFT)\n        c.next_to(formula, DOWN, buff=0.5).align_to(formula, RIGHT)\n        lp = Tex('\\\\Large LP-SAT').scale(1.5).set_opacity(opacity).move_to(formula).align_to(formula, RIGHT).shift(UP * 2.5)\n        lp[0][0:3].set_color(RED)\n        rand = Tex('\\\\Large RAND-SAT').scale(1.5).set_opacity(opacity).move_to(formula).align_to(formula, LEFT).shift(DOWN * 2.5)\n        rand[0][0:5].set_color(RED)\n        a1 = Arrow(ORIGIN, UP * 1.5).scale(0.8).next_to(rand, UP, buff=0.4).set_opacity(opacity)\n        a2 = Arrow(ORIGIN, DOWN * 1.5).scale(0.8).next_to(lp, DOWN, buff=0.4).set_opacity(opacity)\n        self.add(lp, rand, a1, a2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the \"The Remarkable\", a logical formula, and \"Algorithm\" titles, with semi-transparent \"LP-SAT\" and \"RAND-SAT\" labels positioned above and below the formula respectively, connected by arrows."}, {"role": "assistant", "content": "from utilities import *\nfrom random import choice, sample, seed, uniform\nfrom math import *\n\nclass TransparentThumbnail(MovingCameraScene):\n\n    def construct(self):\n        a = Tex('The Remarkable').scale(1.55)\n        formula = Tex('$$(\\\\mathrm{B} \\\\kern-0.25em\\\\lor\\\\kern-0.25em \\\\mathrm{E} \\\\kern-0.25em\\\\lor\\\\kern-0.25em \\\\mathrm{S} \\\\kern-0.25em\\\\lor\\\\kern-0.25em \\\\mathrm{T}) \\\\land (\\\\mathrm{S} \\\\kern-0.25em\\\\lor\\\\kern-0.4em \\\\mathrm{A} \\\\kern-0.4em\\\\lor\\\\kern-0.25em \\\\mathrm{T})$$').scale(2.2)\n        c = Tex('Algorithm').scale(1.75)\n        for i in [2, 4, 6, 9, 12, 14]:\n            formula[0][i].scale(0.75)\n        for i in [1, 3, 5, 7, 11, 13, 15]:\n            formula[0][i].set_color(GREEN)\n        opacity = 0.5\n        self.add(formula, a, c)\n        a.next_to(formula, UP, buff=0.7).align_to(formula, LEFT)\n        c.next_to(formula, DOWN, buff=0.5).align_to(formula, RIGHT)\n        lp = Tex('\\\\Large LP-SAT').scale(1.5).set_opacity(opacity).move_to(formula).align_to(formula, RIGHT).shift(UP * 2.5)\n        lp[0][0:3].set_color(RED)\n        rand = Tex('\\\\Large RAND-SAT').scale(1.5).set_opacity(opacity).move_to(formula).align_to(formula, LEFT).shift(DOWN * 2.5)\n        rand[0][0:5].set_color(RED)\n        a1 = Arrow(ORIGIN, UP * 1.5).scale(0.8).next_to(rand, UP, buff=0.4).set_opacity(opacity)\n        a2 = Arrow(ORIGIN, DOWN * 1.5).scale(0.8).next_to(lp, DOWN, buff=0.4).set_opacity(opacity)\n        self.add(lp, rand, a1, a2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the tiling of parentheses using braces to label segments of the input and output tiles."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass WebExampleParenthesesLogMinimal(Scene):\n\n    def construct(self):\n        wall, tileset = examples['parentheses_log_compact']\n        result_wall = find_tiling(tileset, wall, max_height=2).next_to(tileset, DOWN)\n        g = VGroup(tileset, result_wall).move_to(ORIGIN).scale(1.3)\n        tileset = tileset.scale(0.6)\n        for i, (text, start, end) in enumerate([('start + increment', tileset[0], tileset[1]), ('carry', tileset[2], tileset[3]), ('end + decrement', tileset[4], tileset[5])]):\n            b = BraceBetweenPoints(Point().next_to(start, UP + LEFT, buff=0).get_center(), Point().next_to(end, UP + RIGHT, buff=0).get_center(), direction=UP, color=NOTES_COLOR).scale([-1, NOTES_SCALE, 1])\n            bl = Tex(text, color=NOTES_COLOR).next_to(b, UP).scale(NOTES_SCALE).shift(DOWN * 0.1)\n            if i == 1:\n                bl.shift(DOWN * 0.05)\n            g.add(b)\n            g.add(bl)\n        g.move_to(ORIGIN)\n        self.add(g)"}]}
{"messages": [{"role": "user", "content": "Visualize a tiling puzzle and its solution, annotating key stages of the tiling process with braces and labels."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass WebExampleParenthesesLog(Scene):\n\n    def construct(self):\n        wall, tileset = examples['parentheses_log']\n        result_wall = find_tiling(tileset, wall, max_height=2).next_to(tileset, DOWN)\n        g = VGroup(tileset, result_wall).move_to(ORIGIN).scale(1.3)\n        tileset = tileset.scale(0.6)\n        for i, (text, start, end) in enumerate([('start', tileset[0], tileset[0]), ('increment', tileset[1], tileset[2]), ('carry over', tileset[3], tileset[4]), ('decrement', tileset[5], tileset[6]), ('end', tileset[7], tileset[8]), ('fill', tileset[9], tileset[9])]):\n            b = BraceBetweenPoints(Point().next_to(start, UP + LEFT, buff=0).get_center(), Point().next_to(end, UP + RIGHT, buff=0).get_center(), direction=UP, color=NOTES_COLOR).scale([-1, NOTES_SCALE, 1])\n            bl = Tex(text, color=NOTES_COLOR).next_to(b, UP).scale(NOTES_SCALE).shift(DOWN * 0.1)\n            if i == 2:\n                bl.shift(DOWN * 0.05)\n            g.add(b)\n            g.add(bl)\n        g.move_to(ORIGIN)\n        self.add(g)"}]}
{"messages": [{"role": "user", "content": "Illustrate the tiling process for a \"power of two\" example with braces and text annotations explaining each step."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass WebExamplePowerOfTwo(Scene):\n\n    def construct(self):\n        wall, tileset = examples['power_of_two']\n        result_wall = find_tiling(tileset, wall, max_height=3).next_to(tileset, DOWN)\n        tileset = tileset.scale(0.9)\n        g = VGroup(tileset, result_wall)\n        for i, (text, start, end) in enumerate([('eat the first one', tileset[0], tileset[1]), ('increment', tileset[2], tileset[3]), ('carry', tileset[4], tileset[5]), (\"accept '1' too\", tileset[6], tileset[6])]):\n            b = BraceBetweenPoints(Point().next_to(start, UP + LEFT, buff=0).get_center(), Point().next_to(end, UP + RIGHT, buff=0).get_center(), direction=UP, color=NOTES_COLOR).scale([-1, NOTES_SCALE, 1])\n            bl = Tex(text, color=NOTES_COLOR).next_to(b, UP).scale(NOTES_SCALE).shift(DOWN * 0.1)\n            if i == 2 or i == 3:\n                bl.shift(DOWN * 0.05)\n            g.add(b)\n            g.add(bl)\n        g.move_to(ORIGIN)\n        self.add(g)"}]}
{"messages": [{"role": "user", "content": "Show a tiling puzzle example with a custom tileset and its solution."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass WebExampleDivisible(Scene):\n\n    def construct(self):\n        wall, tileset = examples['divisibleby']\n        result_wall = find_tiling(tileset, wall, max_height=1).scale(1.4).next_to(tileset, DOWN).shift(DOWN * 0.7)\n        (TileSet(*[Tile([(j * 10 + i) % 13, i, j, '']) for i in range(10) for j in range(13)]),)\n        tileset = TileSet(Tex('all tiles in the form'), Tile(['j', 'i', '$k$', PALETTE[0]]), Tex('$\\\\substack { {\\\\forall i \\\\in \\\\left\\\\{0, \\\\ldots, 9\\\\right\\\\} } \\\\\\\\ {\\\\forall j \\\\in \\\\left\\\\{0, \\\\ldots, 12\\\\right\\\\} } \\\\\\\\ {\\\\forall k = (10j + i)\\\\ \\\\mathrm{mod}\\\\ 13} }$'), exclude_commas=True)\n        g = VGroup(tileset, result_wall).scale(1.2)\n        g.move_to(ORIGIN)\n        self.add(g)"}]}
{"messages": [{"role": "user", "content": "Visualize a tiling example for a palindrome, highlighting specific sections with braces and text labels."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass WebExamplePalindrome(Scene):\n\n    def construct(self):\n        wall, tileset = examples['palindrome']\n        result_wall = find_tiling(tileset, wall, max_height=4).next_to(tileset, DOWN)\n        g = VGroup(tileset, result_wall).move_to(ORIGIN)\n        tileset = tileset.scale(0.6)\n        for i, (text, start, end) in enumerate([('start/end 0', tileset[0], tileset[1]), ('start/end 1', tileset[2], tileset[3]), ('carry sides', tileset[4], tileset[5]), ('carry input to next row', tileset[6], tileset[9]), ('odd size', tileset[10], tileset[11])]):\n            b = BraceBetweenPoints(Point().next_to(start, UP + LEFT, buff=0).get_center(), Point().next_to(end, UP + RIGHT, buff=0).get_center(), direction=UP, color=NOTES_COLOR).scale([-1, NOTES_SCALE, 1])\n            bl = Tex(text, color=NOTES_COLOR).next_to(b, UP).scale(NOTES_SCALE * 0.8).shift(DOWN * 0.1)\n            if i == 0 or i == 1:\n                bl.shift(DOWN * 0.05)\n            if i == 4:\n                bl.shift(UP * 0.07)\n            g.add(b)\n            g.add(bl)\n        g.move_to(ORIGIN)\n        self.add(g)"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of Archimedes' principle using a bathroom tile analogy and visual demonstrations of tile placement and rearrangement."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass Motivation(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        p1 = SVGMobject('assets/pillar.svg').scale(2.8).shift(LEFT * 4.8)\n        p2 = SVGMobject('assets/pillar.svg').scale(2.8).shift(RIGHT * 4.8)\n        ft = Text('\u0395\u03cd\u03c1\u03b7\u03ba\u03b1!').scale(2)\n        archimedes = Text('\u2013 \u1f08\u03c1\u03c7\u03b9\u03bc\u03ae\u03b4\u03b7\u03c2').scale(0.7).next_to(ft, DOWN).align_to(ft, RIGHT)\n        g = VGroup(ft, archimedes).move_to(ORIGIN)\n        text_write_duration = 1\n        self.play(FadeInUp(p1), FadeInUp(p2))\n        self.play(AnimationGroup(Write(ft, run_time=text_write_duration), Write(archimedes, run_time=text_write_duration), lag_ratio=0.8))\n        offset = 1.2\n        ft2 = Text('Bathroom tiles!').scale(1.05).shift(DOWN * offset)\n        tom = Text('\u2013 Tom').scale(0.7).next_to(ft2, DOWN).align_to(ft2, RIGHT)\n        g2 = VGroup(ft2, tom)\n        g2.move_to(ORIGIN).shift(DOWN * offset)\n        laptop = SVGMobject('assets/laptop.svg').shift(DOWN * 1.5)\n        water = SVGMobject('assets/water.svg').scale(0.35).next_to(laptop, UP + LEFT).shift(RIGHT * 0.75 + DOWN * 0.73)\n        bolt = SVGMobject('assets/bolt.svg').scale(0.3).move_to(laptop).shift(UP * 0.37)\n        self.play(g.animate.shift(UP * offset), FadeInUp(laptop))\n        self.play(AnimationGroup(FadeInUp(water), Write(bolt), lag_ratio=0.5))\n        self.play(AnimationGroup(FadeOutUp(VGroup(water, bolt, laptop)), AnimationGroup(Write(ft2, run_time=text_write_duration), Write(tom, run_time=text_write_duration / 3), lag_ratio=0.8), lag_ratio=1))\n        self.add(ft2)\n        self.add(tom)\n        w = 9\n        h = 3\n        wall = Wall(PALETTE, width=w, height=h)\n        bl = BraceBetweenPoints([-w / 2, h / 2, 0], [-w / 2, -h / 2, 0])\n        blt = Tex('\\\\footnotesize h').next_to(bl, LEFT * 0.5)\n        bu = BraceBetweenPoints([-w / 2, h / 2, 0], [w / 2, h / 2, 0], direction=UP).scale([-1, 1, 0])\n        but = Tex('\\\\footnotesize w').next_to(bu, UP * 0.5)\n        self.play(AnimationGroup(AnimationGroup(*map(FadeOutUp, self.mobjects)), Write(wall.border), lag_ratio=0.8))\n        self.play(Write(bu), Write(but))\n        self.play(Write(bl), Write(blt))\n        seed(3)\n        tiles = [[Tile([choice(PALETTE) for _ in range(4)]) for _ in range(w)] for _ in range(h)]\n        for i in range(w):\n            for j in range(h):\n                wall.add_tile(tiles[j][i], i, j)\n        self.play(AnimationGroup(*[FadeIn(t.border) for t in wall.tiles], lag_ratio=0.01))\n        tile = wall.get_tile(w // 2, h // 2)\n        zoom_ratio = 0.2\n        self.play(self.camera.frame.animate.scale(zoom_ratio).move_to(tile), rate_func=smooth, run_time=1.5)\n        self.play(AnimationGroup(Write(tile.cross), lag_ratio=0.3))\n        self.bring_to_front(tile.border)\n        for c in tile.color_objects:\n            self.bring_to_back(c)\n        self.bring_to_front(tile)\n        self.play(*[FadeIn(tile.get_color_object_in_direction(d)) for d in [LEFT, UP, RIGHT, DOWN]], tile.border.animate.set_color(WHITE))\n        for t in wall.tiles:\n            for c in t.color_objects:\n                self.bring_to_back(c)\n            self.bring_to_front(t)\n        self.play(AnimationGroup(self.camera.frame.animate.scale(1 / zoom_ratio).move_to(ORIGIN), rate_func=smooth, run_time=1.5), *[t.border.animate.set_color(WHITE) for t in wall.tiles if t is not tile], *[Write(t.cross) for t in wall.tiles if t is not tile], *[Write(t.color_objects) for t in wall.tiles if t is not tile])\n        changes = {}\n        seed(1)\n        for count, (i1, i2) in enumerate(zip((range(w - 1), range(w)), (range(h), range(h - 1)))):\n            for i in i1:\n                for j in i2:\n                    p1, p2 = ((i, j), (i + 1, j) if not count else (i, j + 1))\n                    d1, d2 = (RIGHT, LEFT) if not count else (DOWN, UP)\n                    c1, c2 = (tiles[p1[1]][p1[0]].get_color_in_direction(d1), tiles[p2[1]][p2[0]].get_color_in_direction(d2))\n                    new_color = choice([c1, c2])\n                    if p1 not in changes:\n                        changes[p1] = tiles[p1[1]][p1[0]].animate\n                    changes[p1].set_color_in_direction(new_color, d1)\n                    if p2 not in changes:\n                        changes[p2] = tiles[p2[1]][p2[0]].animate\n                    changes[p2].set_color_in_direction(new_color, d2)\n        self.play(*changes.values())\n        changes = {}\n        for count, iterable in enumerate([range(w), range(h)]):\n            for x in iterable:\n                for index in range(2):\n                    y = ((0, h - 1) if not count else (0, w - 1))[index]\n                    direction = ((UP, DOWN) if not count else (LEFT, RIGHT))[index]\n                    if count:\n                        i, j = (y, x)\n                    else:\n                        i, j = (x, y)\n                    if tiles[j][i].get_color_in_direction(direction) != wall.get_color_in_direction(direction):\n                        if (i, j) not in changes:\n                            changes[i, j] = tiles[j][i].animate\n                        changes[i, j].set_color_in_direction(wall.get_color_in_direction(direction), direction)\n        self.play(AnimationGroup(FadeOut(VGroup(bl, blt, bu, but)), Write(wall.color_objects), lag_ratio=0.6))\n        self.play(*changes.values())\n        tiles = [Tile([REDUCED_PALETTE[1], REDUCED_PALETTE[1], REDUCED_PALETTE[0], REDUCED_PALETTE[1]]), Tile([REDUCED_PALETTE[1], REDUCED_PALETTE[1], REDUCED_PALETTE[1], REDUCED_PALETTE[1]]), Tile([REDUCED_PALETTE[0], REDUCED_PALETTE[1], REDUCED_PALETTE[1], REDUCED_PALETTE[1]])]\n        tileset = TileSet(*tiles)\n        self.play(AnimationGroup(*[FadeOut(t) for t in wall.tiles], lag_ratio=0.01, run_time=1))\n        for t in wall.tiles:\n            wall.remove_tile(t)\n        wall.generate_target()\n        wall.target.shift(DOWN * 1.1)\n        wall.target.get_color_object_in_direction(LEFT).set_fill(REDUCED_PALETTE[0])\n        wall.target.get_color_object_in_direction(DOWN).set_fill(REDUCED_PALETTE[1])\n        wall.target.get_color_object_in_direction(RIGHT).set_fill(REDUCED_PALETTE[0])\n        tileset.next_to(wall.target, UP).shift(UP * 0.5)\n        self.play(AnimationGroup(MoveToTarget(wall), tileset.animateWrite(), lag_ratio=0.8))\n        question = Tex('?').scale(QUESTION_MARK_SCALE).move_to(wall)\n        self.play(Write(question))\n        self.play(FadeOutUp(question))\n        animations1, tiles1, positions1 = animate_tile_pasting(tiles[-1], wall, [(-1, i) for i in range(h)])\n        animations2, tiles2, positions2 = animate_tile_pasting(tiles[0], wall, [(0, i) for i in range(h)])\n        self.play(*animations1, *animations2)\n        wall.add_tiles(tiles1, positions1)\n        wall.add_tiles(tiles2, positions2)\n        from_tile_wrong = tiles[-1].copy()\n        cross_size = 0.6\n        cross = VGroup()\n        r1 = Line(start=(UP + LEFT) * cross_size, end=(DOWN + RIGHT) * cross_size, stroke_width=6).set_stroke('#8b0000')\n        r2 = Line(start=(RIGHT + UP) * cross_size, end=(DOWN + LEFT) * cross_size, stroke_width=6).set_stroke('#8b0000')\n        cross.add(r1)\n        cross.add(r2)\n        self.play(from_tile_wrong.animate.move_to(wall.get_tile_position(4, 0)).rotate(-PI / 2))\n        cross.move_to(from_tile_wrong)\n        self.play(Write(cross, run_time=0.5))\n        self.play(FadeOutUp(from_tile_wrong), FadeOutUp(cross))\n        animations, tiles, positions = animate_tile_pasting(tiles[1], wall, [(i, j) for i in reversed(range(1, w - 1)) for j in reversed(range(h))], speed=0.03)\n        self.play(*animations)\n        wall.add_tiles(tiles, positions)\n        self.play(wall.get_color_object_in_direction(UP).animate.set_fill(REDUCED_PALETTE[0]))\n        self.play(*[FadeOut(wall.get_tile(i, 0)) for i in range(wall.w)])\n        for i in range(wall.w):\n            wall.remove_tile(wall.get_tile(i, 0))"}]}
{"messages": [{"role": "user", "content": "Demonstrate two examples of computational tasks: one involving tiling a wall with specific color constraints and another involving checking if the number of ones in an input string is divisible by three."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass ProgrammingModel(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large \\\\textsc{Programming model}')\n        self.play(FadeInUp(title))\n        self.play(title.animate.shift(UP * 2.5))\n        text = [(Tex('Input:'), HighlightedTex('|colors| on the |top side| of the wall')), (Tex('Program:'), HighlightedTex('finite set of |tile types| and the |remaining wall colors|')), (Tex('Output:'), HighlightedTex('|accept| if there exists valid tiling, else |reject| it', color=[GREEN, RED]))]\n        text_scale = 0.85\n        for i in range(len(text)):\n            text[i][0].scale(text_scale).next_to(text[i - 1][0], DOWN).align_to(text[i - 1][0], RIGHT)\n            text[i][1].scale(text_scale).next_to(text[i][0], RIGHT)\n        g = VGroup()\n        for i in range(len(text)):\n            g.add(text[i][0])\n            g.add(text[i][1])\n        g.move_to(ORIGIN).shift(UP * 0.7)\n        wall, tileset = examples['even_size']\n        wall = wall.shift(DOWN * 2)\n        self.play(FadeInUp(text[0][0]))\n        self.play(Write(text[0][1]), wall.animateWrite(), run_time=2.1)\n        self.play(AnimationGroup(*[Wiggle(wall.get_color_object_characters_in_direction(UP)[i]) for i in range(len(wall.input))], lag_ratio=0.08))\n        tileset.next_to(wall, RIGHT, buff=1)\n        g = VGroup(tileset, wall)\n        self.play(wall.animate.set_x(wall.get_x() - g.get_x()), FadeInUp(text[1][0]))\n        tileset.next_to(wall, RIGHT, buff=1)\n        self.play(Write(text[1][1], run_time=2.8), AnimationGroup(tileset.animateWrite(), AnimationGroup(wall.get_color_object_in_direction(LEFT).animate.set_fill(PALETTE[1]), wall.get_color_object_in_direction(DOWN).animate.set_fill(PALETTE[0]), wall.get_color_object_in_direction(RIGHT).animate.set_fill(PALETTE[1])), lag_ratio=1))\n        self.play(FadeInUp(text[2][0]))\n        n = 24\n        self.play(Write(VGroup(text[2][1][0], text[2][1][1][:n]), run_time=1.8))\n        self.play(Write(VGroup(text[2][1][1][n:], text[2][1][2], text[2][1][3]), run_time=1))\n        self.play(AnimationGroup(AnimationGroup(FadeOutUp(title), *[FadeOutUp(text[i][j]) for i in range(len(text)) for j in range(len(text[0]))]), AnimationGroup(tileset.animate.move_to(ORIGIN).shift(TILESET_OFFSET), wall.animate.move_to(ORIGIN).shift(WALL_OFFSET)), lag_ratio=0.0), run_time=1.5)\n        task = HighlightedTex('{\\\\bf Task:} |accept| input \\\\(\\\\Leftrightarrow\\\\) it has even length', color=GREEN).next_to(tileset, UP).shift(TASK_OFFSET)\n        self.play(FadeInUp(task))\n        for i in range(wall.w // 2):\n            animations, tiles, positions = animate_tile_pasting(tileset[i % 2], wall, [(i, 0)])\n            animations2, tiles2, positions2 = animate_tile_pasting(tileset[(i + 1) % 2], wall, [(wall.w - i - 1, 0)])\n            self.play(*animations, *animations2)\n            if i != wall.w // 2 - 1:\n                self.play(Swap(tileset[0], tileset[1], path_arc=160 * DEGREES, run_time=1.25))\n            wall.add_tiles(tiles, positions)\n            wall.add_tiles(tiles2, positions2)\n        self.play(*wall.animateFillFlash())\n        wall_old = wall\n        tileset_old = tileset\n        task_old = task\n        wall, tileset = examples['divby3']\n        tileset.move_to(ORIGIN).shift(TILESET_OFFSET)\n        wall.move_to(ORIGIN).shift(WALL_OFFSET)\n        task = HighlightedTex('{\\\\bf Task:} |accept| input \\\\(\\\\Leftrightarrow\\\\) \\\\# of ones is divisible by 3', color=GREEN).next_to(tileset, UP).shift(TASK_OFFSET)\n        self.play(AnimationGroup(AnimationGroup(FadeOutUp(wall_old), FadeOutUp(tileset_old), FadeOutUp(task_old)), AnimationGroup(FadeInUp(wall), FadeInUp(tileset), FadeInUp(task)), lag_ratio=0.6))\n        nums = [Tex(str(wall.input[:i + 1].count('1')), color=NOTES_COLOR).scale(NOTES_SCALE).next_to(wall.get_color_object_characters_in_direction(UP)[i], UP) for i in range(len(wall.input))]\n        self.play(AnimationGroup(*[Wiggle(wall.get_color_object_characters_in_direction(UP)[i]) for i in range(len(wall.input)) if wall.input[i] == '1'], lag_ratio=0.08))\n        nums = [Tex(str(wall.input[:i + 1].count('1')), color=NOTES_COLOR).scale(NOTES_SCALE).next_to(wall.get_color_object_characters_in_direction(UP)[i], UP) for i in range(len(wall.input))]\n        nums_lag = 0.3\n        nums_run_time = 1.5\n        self.play(AnimationGroup(*[FadeInUp(n) for n in nums], lag_ratio=nums_lag, run_time=nums_run_time))\n        nums_transformed = [Tex(str(wall.input[:i + 1].count('1') % 3), color=NOTES_COLOR).scale(NOTES_SCALE).move_to(nums[i]) for i in range(len(nums))]\n        self.play(AnimationGroup(*[AnimationGroup(FadeOutUp(a, move_factor=0.25), FadeInUp(b, move_factor=0.25)) for a, b in zip(nums[3:], nums_transformed[3:])], lag_ratio=nums_lag, run_time=nums_run_time))\n        self.play(Wiggle(nums_transformed[-1]), Wiggle(wall.get_color_object_characters_in_direction(RIGHT)))\n        bs = []\n        brace_offset = 0.25\n        for i, (text, start, end) in enumerate([('carry', tileset[0], tileset[2]), ('increment', tileset[3], tileset[5])]):\n            b = BraceBetweenPoints(Point().next_to(start, UP + LEFT, buff=0).get_center(), Point().next_to(end, UP + RIGHT, buff=0).get_center(), direction=UP, color=NOTES_COLOR).scale([-1, NOTES_SCALE, 1])\n            bl = Tex(text, color=NOTES_COLOR).next_to(b, UP).scale(NOTES_SCALE).shift(DOWN * 0.1)\n            bs += [b, bl]\n            self.play(FadeInUp(b), FadeInUp(bl) if i == 1 else AnimationGroup(FadeInUp(bl), task.animate.shift(UP * 0.3)))\n            self.play(*[Wiggle(t.get_color_object_in_direction(UP), run_time=2.5, n_wiggles=5) for t in tileset][i * 3:(i + 1) * 3])\n            self.play(AnimationGroup(*[AnimationGroup(Wiggle(t.get_color_object_in_direction(LEFT)), Wiggle(t.get_color_object_in_direction(RIGHT)), lag_ratio=0.1) for t in tileset][i * 3:(i + 1) * 3], lag_ratio=0.35))\n        for i, (tile, positions) in enumerate([(3, [(0, 0)]), (1, [(1, 0)]), (4, [(2, 0)]), (5, [(3, 0)]), (0, [(4, 0)]), (3, [(5, 0)]), (4, [(6, 0)]), (5, [(7, 0)])]):\n            animations, tiles, positions = animate_tile_pasting(tileset[tile], wall, positions)\n            self.play(*animations, run_time=1 - i / wall.w * 0.5)\n            self.play(Wiggle(tiles[0].get_color_object_in_direction(RIGHT)), Wiggle((nums if i < 3 else nums_transformed)[i]), run_time=1.5)\n            wall.add_tiles(tiles, positions)\n        self.play(*wall.animateFillFlash())\n        self.play(AnimationGroup(*[Wiggle(wall.get_color_object_characters_in_direction(UP)[i]) for i in range(len(wall.input)) if wall.input[i] == '1'], lag_ratio=0.08))"}]}
{"messages": [{"role": "user", "content": "Compare and contrast the traditional model and the bathroom model of time complexity, illustrating each with examples and highlighting key terms."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass TimeComplexity(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large \\\\textsc{Time Complexity}')\n        self.play(FadeInUp(title))\n        traditional = Tex('Traditional model')\n        traditional_text = Tex('\\\\parbox{15em}{Minimum number of instructions needed to compute the solution, based on the size of the input.}').scale(0.7).next_to(traditional, DOWN).shift(DOWN * 0.2)\n        for i, j in ((0, 7), (15, 27), (35, 42), (64, 80)):\n            traditional_text[0][i:j].set_color(YELLOW)\n        traditional_group = VGroup(traditional, traditional_text)\n        traditional_group.move_to(ORIGIN).shift(LEFT * 3.2 + UP * 0.5)\n        bathroom = Tex('Bathroom model')\n        bathroom_text = HighlightedTex('\\\\parbox{15em}{Minimum number of rows needed to accept the input, based on the size of the input.}').scale(0.7).next_to(bathroom, DOWN).shift(DOWN * 0.2)\n        for k, (i, j) in enumerate(((0, 7), (15, 19), (27, 33), (52, 73))):\n            if k == 2:\n                color = GREEN\n            else:\n                color = YELLOW\n            bathroom_text[0][i:j].set_color(color)\n        bathroom_text_2 = HighlightedTex('\\\\parbox{15em}{Rejected inputs are ignored.}').scale(0.7).next_to(bathroom_text, DOWN)\n        for k, (i, j) in enumerate(((0, 8), (17, 25))):\n            if k == 0:\n                color = RED\n            else:\n                color = YELLOW\n            bathroom_text_2[0][i:j].set_color(color)\n        bathroom_group = VGroup(bathroom, bathroom_text)\n        bathroom_group.move_to(ORIGIN).shift(RIGHT * 3.2 + UP * 0.5)\n        self.play(AnimationGroup(title.animate.shift(UP * 2.5), AnimationGroup(FadeInUp(traditional), FadeInUp(bathroom), run_time=0.8), lag_ratio=0.2))\n        self.play(Write(traditional_text, run_time=3.5))\n        traditional_examples = Tex('\\n                \\\\begin{itemize}\\n                \\\\itemsep0em\\n                \\\\item {\\\\bf Bubble sort:} \\\\(\\\\mathcal{O}(n^2)\\\\)\\n                \\\\item {\\\\bf Binary search:} \\\\(\\\\mathcal{O}(\\\\log n)\\\\)\\n                \\\\end{itemize}\\n                ').scale(0.7).next_to(traditional_text, DOWN).shift(DOWN * 0.2)\n        bathroom_examples = Tex('\\n                \\\\begin{itemize}\\n                \\\\itemsep0em\\n                \\\\item {\\\\bf Even length:} \\\\(\\\\mathcal{O}(1)\\\\)\\n                \\\\item {\\\\bf 3\\\\(n\\\\) ones in input:} \\\\(\\\\mathcal{O}(1)\\\\)\\n                \\\\end{itemize}\\n                ').scale(0.7).next_to(bathroom_text, DOWN).shift(DOWN * 0.75)\n        n = 17\n        self.play(FadeInUp(traditional_examples[0][0:n]))\n        self.play(FadeInUp(traditional_examples[0][n:]))\n        question = Tex('?').scale(QUESTION_MARK_SCALE).move_to(VGroup(bathroom_text, *bathroom_examples)).shift(UP * 0.7)\n        self.play(Write(question))\n        self.play(AnimationGroup(FadeOutDown(question), Write(bathroom_text, run_time=3.5), lag_ratio=0.3))\n        bathroom_text_2.next_to(bathroom_text, DOWN).align_to(bathroom_text, LEFT)\n        self.play(Write(bathroom_text_2, run_time=1))\n        n = 16\n        self.play(AnimationGroup(FadeInUp(bathroom_examples[0][0:n]), FadeInUp(bathroom_examples[0][n:]), lag_ratio=0.3))"}]}
{"messages": [{"role": "user", "content": "Demonstrate the process of finding a tiling with highlighted parentheses and tiles, explaining the time complexity progression from O(n) to O(log n)."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass ParenthesesExample(Scene):\n\n    @fade\n    def construct(self):\n        task = HighlightedTex('{\\\\bf Task:} |accept| input \\\\(\\\\Leftrightarrow\\\\) parentheses are balanced', color=GREEN)\n        self.play(FadeInUp(task))\n        parentheses = Tex('$(\\\\ (\\\\ )\\\\ (\\\\ )\\\\ )\\\\ (\\\\ )$').next_to(task, DOWN).scale(2)\n        self.play(AnimationGroup(task.animate.shift(UP), FadeInUp(parentheses)))\n\n        def BracketBetweenPoints(p1, p2, direction=UP, color=WHITE, width=0.06, height=0.22, **kwargs):\n            w = width\n            h = height\n            r1 = Rectangle(width=w, height=h).next_to(p1, direction, buff=0)\n            r3 = Rectangle(width=w, height=h).next_to(p2, direction, buff=0)\n            r2 = Rectangle(width=abs(p1[0] - p2[0]) + w, height=w).align_to(r1, direction).set_x((r1.get_x() + r3.get_x()) / 2)\n            return Union(r1, r2, r3, fill_color=color, fill_opacity=1, stroke_width=0)\n        braces = [BracketBetweenPoints(Dot().next_to(parentheses[0][0], DOWN, buff=0.1).get_center(), Dot().next_to(parentheses[0][5], DOWN, buff=0.1).get_center(), direction=DOWN, height=0.43, color=GRAY).scale(0.95), BracketBetweenPoints(Dot().next_to(parentheses[0][1], DOWN, buff=0.1).get_center(), Dot().next_to(parentheses[0][2], DOWN, buff=0.1).get_center(), direction=DOWN, color=GRAY).scale(0.78), BracketBetweenPoints(Dot().next_to(parentheses[0][3], DOWN, buff=0.1).get_center(), Dot().next_to(parentheses[0][4], DOWN, buff=0.1).get_center(), direction=DOWN, color=GRAY).scale(0.78), BracketBetweenPoints(Dot().next_to(parentheses[0][6], DOWN, buff=0.1).get_center(), Dot().next_to(parentheses[0][7], DOWN, buff=0.1).get_center(), direction=DOWN, color=GRAY).scale(0.78)]\n        self.play(FadeInUp(braces[0], move_factor=0.1), FadeInUp(braces[1], move_factor=0.1), FadeInUp(braces[2], move_factor=0.1), FadeInUp(braces[3], move_factor=0.1), run_time=0.65)\n        wall, tileset = examples['parentheses']\n        tileset_scale = 0.7\n        tileset.scale(tileset_scale)\n        tileset.move_to(ORIGIN).shift(TILESET_OFFSET).shift(UP * 0.5)\n        wall.move_to(ORIGIN).shift(WALL_OFFSET * 0.8)\n        for i in range(len(wall.input)):\n            wall.get_color_object_in_direction(UP).remove(wall.get_color_object_characters_in_direction(UP)[i])\n        self.play(AnimationGroup(AnimationGroup(task.animate.next_to(tileset, UP).shift(TASK_OFFSET * 0.8), AnimationGroup(FadeOutUp(braces[0], move_factor=0.1), FadeOutUp(braces[1], move_factor=0.1), FadeOutUp(braces[2], move_factor=0.1), FadeOutUp(braces[3], move_factor=0.1), run_time=0.5), *[Transform(parentheses[0][i], wall.get_color_object_characters_in_direction(UP)[i].copy()) for i in range(len(wall.input))], run_time=1), AnimationGroup(FadeInUp(wall), FadeInUp(tileset), run_time=0.7), lag_ratio=0.3))\n        tileset.scale(1 / tileset_scale)\n        result_wall = find_tiling(tileset, wall, max_height=2)\n        for i in range(wall.w):\n            for j in range(wall.h):\n                wall.add_tile(result_wall.get_tile(i, j), i, j, copy=True)\n        tileset.scale(tileset_scale)\n        self.play(AnimationGroup(*[t.animateWrite() for t in wall.tiles], lag_ratio=0.01))\n        self.play(*wall.animateFillFlash())\n        for i in range(wall.w):\n            for j in range(wall.h):\n                wall.remove_tile(result_wall.get_tile(i, j))\n        parentheses_coefficient = 0.085\n        shift = 0.43\n\n        def highlight_parentheses(indexes, prev_indexes=[[]]):\n            if prev_indexes == [[]]:\n                for i in range(wall.w):\n                    parentheses[0][i].scale(INDICATE_SCALE).shift(UP * parentheses_coefficient + (ORIGIN if i in indexes else DOWN * shift))\n                    parentheses[0][i].save_state()\n                    parentheses[0][i].scale(1 / INDICATE_SCALE).shift(DOWN * parentheses_coefficient + (ORIGIN if i in indexes else UP * shift))\n            for i in range(wall.w):\n                if i in prev_indexes[0]:\n                    parentheses[0][i].save_state()\n            result = AnimationGroup(*[parentheses[0][i].animate.restore() if i in indexes and i not in prev_indexes[0] else parentheses[0][i].animate.scale(1 / INDICATE_SCALE).shift(DOWN * parentheses_coefficient).fade(FADE_COEFFICIENT) if i not in indexes and i in prev_indexes[0] else parentheses[0][i].animate.fade(FADE_COEFFICIENT) if prev_indexes == [[]] else parentheses[0][i].animate.fade(0) for i in range(wall.w)])\n            prev_indexes[0] = indexes\n            return result\n\n        def highlight_tiles(indexes, cache=[[[]]]):\n            first = False\n            if cache == [[[]]]:\n                first = True\n                cache[0] = [(i, j) for i in range(wall.w) for j in range(wall.h)]\n            for i in range(wall.w):\n                for j in range(wall.h):\n                    if (i, j) in cache[0]:\n                        if first:\n                            wall.shift(ORIGIN if (i, j) in indexes else DOWN * shift)\n                        wall.get_tile(i, j).save_state()\n                        if first:\n                            wall.shift(ORIGIN if (i, j) in indexes else UP * shift)\n            result = AnimationGroup(*[wall.get_tile(i, j).animate.fade(FADE_COEFFICIENT) if (i, j) not in indexes and (i, j) in cache[0] else wall.get_tile(i, j).animate.restore() if (i, j) in indexes else wall.get_tile(i, j).animate.fade(0) for i in range(wall.w) for j in range(wall.h)], run_time=0.75)\n            cache[0] = indexes\n            return result\n        p_copy = parentheses.copy().shift(DOWN * shift)\n        self.play(highlight_parentheses([0, 5]))\n        self.play(highlight_tiles([(0, 0), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (5, 0)]))\n        brace_offset = 0.25\n        bs = []\n        for i, (text, start, end) in enumerate([('single', tileset[0], tileset[1]), (['opening', 'closing'], [tileset[2], tileset[8]], [tileset[2], tileset[8]]), ('path creation', tileset[3], tileset[7]), ('fill', tileset[9], tileset[9])]):\n\n            def get_b_local(t, s, e):\n                b = BraceBetweenPoints(Point().next_to(s, UP + LEFT, buff=0).get_center(), Point().next_to(e, UP + RIGHT, buff=0).get_center(), direction=UP, color=NOTES_COLOR).scale([-1, NOTES_SCALE, 1])\n                return [b, Tex(t, color=NOTES_COLOR).next_to(b, UP).scale(NOTES_SCALE).shift(DOWN * 0.1)]\n            b_local = []\n            if type(text) is list:\n                for t, s, e in zip(text, start, end):\n                    b_local += get_b_local(t, s, e)\n            else:\n                b_local = get_b_local(text, start, end)\n            bs += b_local\n            additional = []\n            if i == 3:\n                b_local[-1].shift(UP * 0.08)\n                additional += [highlight_tiles([(6, 1), (7, 1)])]\n                additional += [highlight_parentheses([])]\n            if i == 1:\n                additional += [highlight_tiles([(0, 0), (5, 0)])]\n                additional += [highlight_parentheses((0, 5))]\n            if i == 2:\n                additional += [highlight_tiles([(0, 0), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (5, 0)])]\n            if i == 0:\n                for b in b_local:\n                    b.shift(DOWN * shift)\n                self.play(task.animate.shift(UP * shift / 2), parentheses.animate.shift(DOWN * shift), wall.animate.shift(DOWN * shift), tileset.animate.shift(DOWN * shift))\n                self.play(*[FadeInUp(b, move_factor=0.1) for b in b_local], highlight_parentheses([1, 2, 3, 4, 6, 7]), highlight_tiles([(2, 0), (1, 0), (3, 0), (4, 0), (6, 0), (7, 0)]))\n            else:\n                self.play(*[FadeInUp(b) for b in b_local], *additional)\n        self.play(highlight_tiles([(i, j) for i in range(wall.w) for j in range(wall.h)]), Transform(parentheses, p_copy))\n        wall.save_state()\n        tileset.save_state()\n        self.play(wall.get_tile(5, 0).get_color_object_in_direction(DOWN).animate.set_fill(PALETTE[1]), wall.get_tile(5, 1).get_color_object_in_direction(UP).animate.set_fill(PALETTE[1]), tileset[6].get_color_object_in_direction(UP).animate.set_fill(PALETTE[1]), tileset[7].get_color_object_in_direction(UP).animate.set_fill(PALETTE[1]), tileset[7].get_color_object_in_direction(DOWN).animate.set_fill(PALETTE[1]), tileset[8].get_color_object_in_direction(DOWN).animate.set_fill(PALETTE[1]))\n        self.play(Rotate(parentheses[0][5]), Rotate(parentheses[0][0]), Rotate(wall.get_tile(5, 0).get_color_object_in_direction(UP)), Rotate(wall.get_tile(0, 0).get_color_object_in_direction(UP)))\n        self.play(wall.animate.restore(), tileset.animate.restore(), Rotate(parentheses[0][5], angle=-PI), Rotate(parentheses[0][0], angle=-PI), Rotate(wall.get_tile(5, 0).get_color_object_in_direction(UP), angle=-PI), Rotate(wall.get_tile(0, 0).get_color_object_in_direction(UP), angle=-PI))\n        self.play(*[FadeOutUp(b) for b in bs])\n        no2 = Tex('$\\\\frac{1}{2}n$').next_to(task, DOWN)\n        no2dot = Tex('$1 \\\\cdot \\\\frac{1}{2}n$').next_to(task, DOWN)\n        no2o = Tex('time complexity: $\\\\mathcal{O}(n)$').next_to(task, DOWN).align_to(task[1][0], LEFT)\n        self.play(Write(no2))\n        self.play(TransformMatchingShapes(no2, no2dot))\n        self.play(TransformMatchingShapes(no2dot, no2o))\n        self.play(no2o.animate.shift(DOWN * 2.2), task.animate.shift(DOWN * 2.2), FadeOutDown(wall, move_factor=2.2), FadeOutDown(tileset, move_factor=2.2), FadeOutDown(parentheses, move_factor=2.2), run_time=1.5)\n        opt = HighlightedTex('|optimal| time complexity: $\\\\mathcal{O}(\\\\log n)$').next_to(no2o, DOWN)\n        opt.shift(LEFT * (-no2o[0][0].get_x() + opt[1][0].get_x()))\n        self.play(FadeInDown(opt))\n        arrows = [Arrow(start=UP, end=DOWN, stroke_width=10, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.5).align_on_border(DOWN).shift(LEFT + UP), Arrow(start=UP, end=DOWN, stroke_width=10, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.5).align_on_border(DOWN).shift(RIGHT + UP)]\n        self.play(opt.animate.shift(UP * 1.25), no2o.animate.shift(UP * 1.25), task.animate.shift(UP * 1.25), FadeInUp(arrows[0], move_factor=0.6), FadeInUp(arrows[1], move_factor=0.6))"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of computational power by showing a tile transforming into a question mark, then a Python logo appearing, followed by a progression of equality and inequality symbols, ultimately leading to Haskell and a demonstration of examples like prime numbers and pathfinding."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass ComputationalPower(Scene):\n\n    @fade\n    def construct(self):\n        title = Tex('\\\\Large \\\\textsc{Computational Power}')\n        self.play(FadeInUp(title))\n        cf = 0.8\n        c = 1.3\n        tile = Tile(PALETTE).scale(2).shift(LEFT * cf)\n        question = Tex('?').scale(QUESTION_MARK_SCALE * 1.5).shift(RIGHT * cf)\n        self.play(ReplacementTransform(title, VGroup(tile, question)))\n        lang = SVGMobject('assets/languages/python.svg').next_to(ORIGIN, RIGHT).shift(RIGHT * c)\n        sscale = 2.8\n        l = Tex('$=$').scale(sscale)\n        g = Tex('$>$').scale(sscale)\n        ll = Tex('$\\\\ll$').scale(sscale)\n        self.play(tile.animate.next_to(ORIGIN, LEFT).shift(LEFT * c), FadeInRight(lang), question.animate.move_to(ORIGIN).fade(FADE_COEFFICIENT), FadeInUp(l))\n        self.play(FadeOutUp(l, move_factor=0.85), FadeInUp(g, move_factor=0.85))\n        self.play(FadeOutUp(g, move_factor=0.85), FadeInUp(ll, move_factor=0.85))\n        r = Tex('$\\\\Leftrightarrow$').scale(sscale / 1.5).move_to(tile).rotate(PI / 2).shift(DOWN * 0.5)\n        g = VGroup(tile, lang, ll, question)\n        lbtm = Tex('linear TM').scale(sscale / 1.5).next_to(r, DOWN)\n        self.play(AnimationGroup(g.animate.shift(UP * 1.2), AnimationGroup(FadeInDown(r), FadeInDown(lbtm)), lag_ratio=0.5))\n        lll = Tex('$<$').scale(sscale).move_to(ll)\n        java = SVGMobject('assets/languages/java.svg').move_to(lang).set_height(lang.height)\n        hs = SVGMobject('assets/languages/haskell.svg').move_to(lang)\n        self.play(FadeOutUp(ll, move_factor=0.85), FadeInUp(lll, move_factor=0.85), FadeOut(question))\n        self.play(FadeOutUp(lang, move_factor=1.5), FadeInUp(java, move_factor=1.5))\n        self.play(FadeOutUp(java, move_factor=1.5), FadeInUp(hs, move_factor=1.5))\n        r2 = Tex('$\\\\Leftrightarrow$').scale(sscale / 1.5).set_x(hs.get_x()).set_y(r.get_y()).rotate(PI / 2)\n        g = VGroup(tile, lang, ll, question)\n        tm = Tex('TM').scale(sscale / 1.5).next_to(r2, DOWN)\n        self.play(FadeInDown(r2), FadeInDown(tm))\n        examples = Tex('\\n                \\\\begin{itemize}\\n                \\\\itemsep0em\\n                \\\\item prime numbers\\n                \\\\item path in a maze\\n                \\\\item SAT assignment\\n                \\\\end{itemize}\\n                ').set_x(lang.get_x()).set_y(tile.get_y()).shift(LEFT * 0.5)\n        ns = [13, 25, 1000]\n        self.play(AnimationGroup(AnimationGroup(FadeOutUp(tm), FadeOutUp(r2), FadeOutUp(hs), FadeOutUp(lll)), FadeInUp(examples[0][0:ns[0]]), lag_ratio=0.35))\n        self.play(FadeInUp(examples[0][ns[0]:ns[1]]))\n        self.play(FadeInUp(examples[0][ns[1]:ns[2]]))\n        impl = Tex('$\\\\Rightarrow$').scale(sscale / 1.5).next_to(lbtm, RIGHT).shift(RIGHT * 0.35)\n        algorithm = Tex('\\\\parbox{6.5em}{$\\\\exists$ an algorithm to find tiling}').next_to(impl, RIGHT).shift(RIGHT * 0.25)\n        self.play(FadeInRight(impl), FadeInRight(algorithm))"}]}
{"messages": [{"role": "user", "content": "Animate the growth of a tiled wall and illustrate the relationship between tiling problems and the halting problem."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass ToInfinity(Scene):\n\n    @fade\n    def construct(self):\n        w = 8\n        h = 3\n        dw = 2\n        dh = 3\n        w2 = w * dw\n        h2 = h * dh\n        s = 0.887\n        title = Tex('\\\\Large \\\\textsc{To Infinity!}')\n        self.play(FadeInUp(title))\n        wall = Wall(PALETTE, width=w, height=h, size=s).move_to(ORIGIN)\n        wall2 = Wall(PALETTE, width=w2, height=h2, size=s).move_to(ORIGIN)\n        self.play(AnimationGroup(FadeOut(title), Write(wall.border), lag_ratio=0.5))\n        seed(5)\n        tiles = [[Tile([choice(PALETTE) for _ in range(4)], size=s) for _ in range(w)] for _ in range(h)]\n        tiles2 = [[Tile([choice(PALETTE) for _ in range(4)], size=s) for _ in range(w2)] for _ in range(h2)]\n        for i in range(w):\n            for j in range(h):\n                wall.add_tile(tiles[j][i], i, j)\n        for i in range(w2):\n            for j in range(h2):\n                wall2.add_tile(tiles2[j][i], i, j)\n        self.next_section()\n        self.play(AnimationGroup(*[FadeIn(t.border) for t in wall.tiles], lag_ratio=0.01))\n        remaining_w = w2 - w\n        remaining_h = h2 - h\n        tls = [wall2.get_tile(i, j) for i in range(w2) for j in range(h2) if i in range(int(remaining_w / 2), int(remaining_w / 2 + w)) and j not in range(int(remaining_h / 2), int(remaining_h / 2 + h)) or (i not in range(int(remaining_w / 2), int(remaining_w / 2 + w)) and j in range(int(remaining_h / 2), int(remaining_h / 2 + h))) or (i not in range(int(remaining_w / 2), int(remaining_w / 2 + w)) and j not in range(int(remaining_h / 2), int(remaining_h / 2 + h)))]\n        tls = sorted(tls, key=lambda x: np.linalg.norm(x.get_center()))\n        self.remove(wall.border)\n        self.play(AnimationGroup(*[FadeIn(t.border) for t in tls], lag_ratio=0.005, run_time=2))\n        self.play(*[t.border.animate.fade(0.94) for t in tls + list(wall.tiles)])\n        l1 = Tex('1. If a tileset can fill the plane, can it also fill it periodically?').scale(0.9)\n        l2 = Tex('2. Is there an algorithm to check if a tiling exists?').scale(0.9).next_to(l1, DOWN)\n        questions = VGroup(l1, l2)\n        self.play(Write(l1, run_time=2))\n        self.play(Write(l2, run_time=2))\n        no = Tex('No.', color=RED).scale(4).shift(DOWN)\n        self.play(questions.animate.next_to(no, UP).shift(UP * 0.8))\n        self.play(Write(no))\n        impl = Tex('$\\\\Rightarrow$').rotate(-PI / 2).scale(1.5).next_to(l1, DOWN)\n        self.play(AnimationGroup(FadeOutDown(no), AnimationGroup(l2.animate.shift(DOWN * 0.9), FadeInDown(impl, move_factor=0.5)), lag_ratio=0.5))\n        impl2 = Tex('$\\\\Rightarrow$').rotate(-PI / 2).scale(1.5).next_to(l2, DOWN)\n        hp = Tex('$\\\\lnot$ halting problem', color=RED).next_to(impl2, DOWN)\n        self.play(AnimationGroup(FadeInDown(impl2, move_factor=0.5), FadeInDown(hp, move_factor=0.5)))\n        not1 = Tex('$\\\\lnot$', color=RED).move_to(questions[0][0][:2]).align_to(questions[0][0][:2], DOWN)\n        not2 = Tex('$\\\\lnot$', color=RED).move_to(questions[1][0][:2]).align_to(questions[1][0][:2], DOWN)\n        l1p = questions[0][0][2:]\n        l2p = questions[1][0][2:]\n        self.play(Rotate(impl2, PI, about_point=impl2.get_center()), l2p.animate.set_color(RED), Transform(questions[1][0][:2], not2))\n        self.play(Rotate(impl, PI, about_point=impl.get_center()), l1p.animate.set_color(RED), Transform(questions[0][0][:2], not1))\n\n        def to_colors(c):\n            return [PALETTE[{RED: 0, GREEN: 1, BLUE: 2, WHITE: 3}[a]] for a in c]\n        tileset = TileSet(Tile(to_colors([RED, RED, GREEN, RED])), Tile(to_colors([RED, BLUE, GREEN, BLUE])), Tile(to_colors([GREEN, RED, GREEN, GREEN])), Tile(to_colors([BLUE, WHITE, BLUE, RED])), Tile(to_colors([BLUE, BLUE, BLUE, WHITE])), Tile(to_colors([WHITE, WHITE, WHITE, RED])), Tile(to_colors([GREEN, RED, WHITE, BLUE])), Tile(to_colors([WHITE, BLUE, RED, BLUE])), Tile(to_colors([RED, BLUE, RED, WHITE])), Tile(to_colors([GREEN, GREEN, RED, BLUE])), Tile(to_colors([WHITE, RED, GREEN, RED])), rows=2).scale(1).next_to(l1, DOWN)\n        result = find_tiling(tileset, wall2, w=w2, max_height=h2, min_height=h2, ignore_sides=True).scale(s)\n        self.play(AnimationGroup(AnimationGroup(FadeOutDown(impl), FadeOutDown(impl2), FadeOutDown(l2), FadeOutDown(not2), FadeOutDown(hp), l1.animate.set_color(WHITE).shift(UP * 0.3)), AnimationGroup(Write(tileset)), lag_ratio=0.4))\n        self.play(FadeOutDown(tileset), FadeOutDown(l1))\n        tls = [result.get_tile(i, j) for i in range(w2) for j in range(h2)]\n        tls = sorted(tls, key=lambda x: np.linalg.norm(x.get_center()))\n        self.play(AnimationGroup(*[Write(t) for t in tls], lag_ratio=0.005, run_time=2))"}]}
{"messages": [{"role": "user", "content": "Animate a list of computer science topics followed by the creation and coloring of a tiled wall."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass Outro(Scene):\n\n    @fade\n    def construct(self):\n        holes = Tex('\\n                \\\\begin{itemize}\\n                \\\\itemsep0em\\n                \\\\item reductions to automatons and grammars\\n                \\\\item other convex shapes (triangles, hexagons)\\n                \\\\item Penrose and Truchet tilings\\n                \\\\item non-Euclidianity, higher dimensions\\n                \\\\end{itemize}\\n                ')\n        ns = [34, 72, 97, 10000]\n        self.play(AnimationGroup(*[FadeInUp(holes[0][0 if i == 0 else ns[i - 1]:ns[i]]) for i in range(len(ns))], lag_ratio=0.25))\n        w = 16\n        h = 9\n        s = 0.887\n        wall = Wall(PALETTE, width=w, height=h, size=s)\n        seed(3)\n        tiles = [[Tile([choice(PALETTE) for _ in range(4)], size=s) for _ in range(w)] for _ in range(h)]\n        for i in range(w):\n            for j in range(h):\n                wall.add_tile(tiles[j][i], i, j)\n        self.play(FadeOutUp(holes))\n        seed(5)\n        for count, (i1, i2) in enumerate(zip((range(w - 1), range(w)), (range(h), range(h - 1)))):\n            for i in i1:\n                for j in i2:\n                    p1, p2 = ((i, j), (i + 1, j) if not count else (i, j + 1))\n                    d1, d2 = (RIGHT, LEFT) if not count else (DOWN, UP)\n                    c1, c2 = (tiles[p1[1]][p1[0]].get_color_in_direction(d1), tiles[p2[1]][p2[0]].get_color_in_direction(d2))\n                    new_color = choice([c1, c2])\n                    tiles[p1[1]][p1[0]].set_color_in_direction(new_color, d1)\n                    tiles[p2[1]][p2[0]].set_color_in_direction(new_color, d2)\n        self.play(AnimationGroup(*[Write(t.color_objects) for t in wall.tiles], lag_ratio=0.01), run_time=2)\n        tile = Tile(PALETTE)\n        pp = Tex('{ \\\\bf ++ }').scale(2).next_to(tile, RIGHT)\n        g = VGroup(tile, pp).scale(2).move_to(ORIGIN)\n        self.play(*[t.color_objects.animate.fade(0.85) for t in wall.tiles])\n        self.play(Write(g))"}]}
{"messages": [{"role": "user", "content": "Display a visual explanation of tiling and its connection to the halting problem, starting with a wall animation and transitioning to text-based questions and their negative implications."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass Thumbnail(Scene):\n\n    def construct(self):\n        self.next_section(skip_animations=True)\n        w = 8\n        h = 3\n        dw = 2\n        dh = 3\n        w2 = w * dw\n        h2 = h * dh\n        s = 0.887\n        title = Tex('\\\\Large \\\\textsc{To Infinity!}')\n        self.play(FadeInUp(title))\n        wall = Wall(PALETTE, width=w, height=h, size=s).move_to(ORIGIN)\n        wall2 = Wall(PALETTE, width=w2, height=h2, size=s).move_to(ORIGIN)\n        self.play(AnimationGroup(FadeOut(title), Write(wall.border), lag_ratio=0.5))\n        seed(5)\n        tiles = [[Tile([choice(PALETTE) for _ in range(4)], size=s) for _ in range(w)] for _ in range(h)]\n        tiles2 = [[Tile([choice(PALETTE) for _ in range(4)], size=s) for _ in range(w2)] for _ in range(h2)]\n        for i in range(w):\n            for j in range(h):\n                wall.add_tile(tiles[j][i], i, j)\n        for i in range(w2):\n            for j in range(h2):\n                wall2.add_tile(tiles2[j][i], i, j)\n        self.play(AnimationGroup(*[FadeIn(t.border) for t in wall.tiles], lag_ratio=0.01))\n        remaining_w = w2 - w\n        remaining_h = h2 - h\n        tls = [wall2.get_tile(i, j) for i in range(w2) for j in range(h2) if i in range(int(remaining_w / 2), int(remaining_w / 2 + w)) and j not in range(int(remaining_h / 2), int(remaining_h / 2 + h)) or (i not in range(int(remaining_w / 2), int(remaining_w / 2 + w)) and j in range(int(remaining_h / 2), int(remaining_h / 2 + h))) or (i not in range(int(remaining_w / 2), int(remaining_w / 2 + w)) and j not in range(int(remaining_h / 2), int(remaining_h / 2 + h)))]\n        tls = sorted(tls, key=lambda x: np.linalg.norm(x.get_center()))\n        self.remove(wall.border)\n        self.play(AnimationGroup(*[FadeIn(t.border) for t in tls], lag_ratio=0.005, run_time=2))\n        self.play(*[t.border.animate.fade(0.94) for t in tls + list(wall.tiles)])\n        l1 = Tex('1. If a tileset can fill the plane, can it also fill it periodically?').scale(0.9)\n        l2 = Tex('2. Is there an algorithm to check if a tiling exists?').scale(0.9).next_to(l1, DOWN)\n        questions = VGroup(l1, l2)\n        self.play(Write(l1, run_time=2))\n        self.play(Write(l2, run_time=2))\n        no = Tex('No.', color=RED).scale(4).shift(DOWN)\n        self.play(questions.animate.next_to(no, UP).shift(UP * 0.8))\n        self.play(Write(no))\n        impl = Tex('$\\\\Rightarrow$').rotate(-PI / 2).scale(1.5).next_to(l1, DOWN)\n        self.play(AnimationGroup(FadeOutDown(no), AnimationGroup(l2.animate.shift(DOWN * 0.9), FadeInDown(impl, move_factor=0.5)), lag_ratio=0.5))\n        impl2 = Tex('$\\\\Rightarrow$').rotate(-PI / 2).scale(1.5).next_to(l2, DOWN)\n        hp = Tex('$\\\\lnot$ halting problem', color=RED).next_to(impl2, DOWN)\n        self.play(AnimationGroup(FadeInDown(impl2, move_factor=0.5), FadeInDown(hp, move_factor=0.5)))\n        not1 = Tex('$\\\\lnot$', color=RED).move_to(questions[0][0][:2]).align_to(questions[0][0][:2], DOWN)\n        not2 = Tex('$\\\\lnot$', color=RED).move_to(questions[1][0][:2]).align_to(questions[1][0][:2], DOWN)\n        l1p = questions[0][0][2:]\n        l2p = questions[1][0][2:]\n        self.play(Rotate(impl2, PI, about_point=impl2.get_center()), l2p.animate.set_color(RED), Transform(questions[1][0][:2], not2))\n        self.play(Rotate(impl, PI, about_point=impl.get_center()), l1p.animate.set_color(RED), Transform(questions[0][0][:2], not1))\n\n        def to_colors(c):\n            return [PALETTE[{RED: 0, GREEN: 1, BLUE: 2, WHITE: 3}[a]] for a in c]\n        tileset = TileSet(Tile(to_colors([RED, RED, GREEN, RED])), Tile(to_colors([RED, BLUE, GREEN, BLUE])), Tile(to_colors([GREEN, RED, GREEN, GREEN])), Tile(to_colors([BLUE, WHITE, BLUE, RED])), Tile(to_colors([BLUE, BLUE, BLUE, WHITE])), Tile(to_colors([WHITE, WHITE, WHITE, RED])), Tile(to_colors([GREEN, RED, WHITE, BLUE])), Tile(to_colors([WHITE, BLUE, RED, BLUE])), Tile(to_colors([RED, BLUE, RED, WHITE])), Tile(to_colors([GREEN, GREEN, RED, BLUE])), Tile(to_colors([WHITE, RED, GREEN, RED])), rows=2).scale(1).next_to(l1, DOWN)\n        result = find_tiling(tileset, wall2, w=w2, max_height=h2, min_height=h2, ignore_sides=True).scale(s)\n        self.play(AnimationGroup(AnimationGroup(FadeOutDown(impl), FadeOutDown(impl2), FadeOutDown(l2), FadeOutDown(not2), FadeOutDown(hp), l1.animate.set_color(WHITE).shift(UP * 0.3)), AnimationGroup(Write(tileset)), lag_ratio=0.4))\n        self.play(FadeOutDown(tileset), FadeOutDown(l1))\n        tls = [result.get_tile(i, j) for i in range(w2) for j in range(h2)]\n        tls = sorted(tls, key=lambda x: np.linalg.norm(x.get_center()))\n        self.play(AnimationGroup(*[Write(t) for t in tls], lag_ratio=0.005, run_time=2))\n        self.next_section()\n        a = Tex('Bathroom Tile', stroke_width=40, stroke_color=WHITE, color=BLACK).scale(3)\n        b = Tex('Programming', stroke_width=40, stroke_color=WHITE, color=BLACK).scale(3).next_to(a, DOWN, buff=0.6)\n        Group(a, b).move_to(ORIGIN)\n        self.add(a)\n        self.add(b)\n        a2 = Tex('Bathroom Tile', stroke_width=3, stroke_color=BLACK, color=BLACK).scale(3).set_z_index(1).move_to(a)\n        b2 = Tex('Programming', stroke_width=3, stroke_color=BLACK, color=BLACK).scale(3).next_to(a, DOWN, buff=0.6).set_z_index(1).move_to(b)\n        self.add(a2)\n        self.add(b2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate how a tiling puzzle is solved by transforming parentheses into wall tiles and highlighting the steps."}, {"role": "assistant", "content": "from utilities import *\nfrom string import digits\nfrom random import seed, choice\n\nclass TransparentThumbnail(Scene):\n\n    @fade\n    def construct(self):\n        FADE_COEFFICIENT = 0.75\n        self.next_section(skip_animations=True)\n        task = HighlightedTex('{\\\\bf Task:} |accept| input \\\\(\\\\Leftrightarrow\\\\) parentheses are balanced', color=GREEN)\n        self.play(FadeInUp(task))\n        parentheses = Tex('$(\\\\ (\\\\ )\\\\ (\\\\ )\\\\ )\\\\ (\\\\ )$').next_to(task, DOWN).scale(2)\n        self.play(AnimationGroup(task.animate.shift(UP), FadeInUp(parentheses)))\n\n        def BracketBetweenPoints(p1, p2, direction=UP, color=WHITE, width=0.06, height=0.22, **kwargs):\n            w = width\n            h = height\n            r1 = Rectangle(width=w, height=h).next_to(p1, direction, buff=0)\n            r3 = Rectangle(width=w, height=h).next_to(p2, direction, buff=0)\n            r2 = Rectangle(width=abs(p1[0] - p2[0]) + w, height=w).align_to(r1, direction).set_x((r1.get_x() + r3.get_x()) / 2)\n            return Union(r1, r2, r3, fill_color=color, fill_opacity=1, stroke_width=0)\n        braces = [BracketBetweenPoints(Dot().next_to(parentheses[0][0], DOWN, buff=0.1).get_center(), Dot().next_to(parentheses[0][5], DOWN, buff=0.1).get_center(), direction=DOWN, height=0.43, color=GRAY).scale(0.95), BracketBetweenPoints(Dot().next_to(parentheses[0][1], DOWN, buff=0.1).get_center(), Dot().next_to(parentheses[0][2], DOWN, buff=0.1).get_center(), direction=DOWN, color=GRAY).scale(0.78), BracketBetweenPoints(Dot().next_to(parentheses[0][3], DOWN, buff=0.1).get_center(), Dot().next_to(parentheses[0][4], DOWN, buff=0.1).get_center(), direction=DOWN, color=GRAY).scale(0.78), BracketBetweenPoints(Dot().next_to(parentheses[0][6], DOWN, buff=0.1).get_center(), Dot().next_to(parentheses[0][7], DOWN, buff=0.1).get_center(), direction=DOWN, color=GRAY).scale(0.78)]\n        self.play(FadeInUp(braces[0], move_factor=0.1), FadeInUp(braces[1], move_factor=0.1), FadeInUp(braces[2], move_factor=0.1), FadeInUp(braces[3], move_factor=0.1), run_time=0.65)\n        wall, tileset = examples['parentheses']\n        tileset_scale = 0.7\n        tileset.scale(tileset_scale)\n        tileset.move_to(ORIGIN).shift(TILESET_OFFSET).shift(UP * 0.5)\n        wall.move_to(ORIGIN).shift(WALL_OFFSET * 0.8)\n        for i in range(len(wall.input)):\n            wall.get_color_object_in_direction(UP).remove(wall.get_color_object_characters_in_direction(UP)[i])\n        self.play(AnimationGroup(AnimationGroup(task.animate.next_to(tileset, UP).shift(TASK_OFFSET * 0.8), AnimationGroup(FadeOutUp(braces[0], move_factor=0.1), FadeOutUp(braces[1], move_factor=0.1), FadeOutUp(braces[2], move_factor=0.1), FadeOutUp(braces[3], move_factor=0.1), run_time=0.5), *[Transform(parentheses[0][i], wall.get_color_object_characters_in_direction(UP)[i].copy()) for i in range(len(wall.input))], run_time=1), AnimationGroup(FadeInUp(wall), FadeInUp(tileset), run_time=0.7), lag_ratio=0.3))\n        tileset.scale(1 / tileset_scale)\n        result_wall = find_tiling(tileset, wall, max_height=2)\n        for i in range(wall.w):\n            for j in range(wall.h):\n                wall.add_tile(result_wall.get_tile(i, j), i, j, copy=True)\n        tileset.scale(tileset_scale)\n        self.play(AnimationGroup(*[t.animateWrite() for t in wall.tiles], lag_ratio=0.01))\n        self.play(*wall.animateFillFlash())\n        for i in range(wall.w):\n            for j in range(wall.h):\n                wall.remove_tile(result_wall.get_tile(i, j))\n        parentheses_coefficient = 0.085\n        shift = 0.43\n\n        def highlight_parentheses(indexes, prev_indexes=[[]]):\n            if prev_indexes == [[]]:\n                for i in range(wall.w):\n                    parentheses[0][i].scale(INDICATE_SCALE).shift(UP * parentheses_coefficient + (ORIGIN if i in indexes else DOWN * shift))\n                    parentheses[0][i].save_state()\n                    parentheses[0][i].scale(1 / INDICATE_SCALE).shift(DOWN * parentheses_coefficient + (ORIGIN if i in indexes else UP * shift))\n            for i in range(wall.w):\n                if i in prev_indexes[0]:\n                    parentheses[0][i].save_state()\n            result = AnimationGroup(*[parentheses[0][i].animate.restore() if i in indexes and i not in prev_indexes[0] else parentheses[0][i].animate.scale(1 / INDICATE_SCALE).shift(DOWN * parentheses_coefficient).fade(FADE_COEFFICIENT) if i not in indexes and i in prev_indexes[0] else parentheses[0][i].animate.fade(FADE_COEFFICIENT) if prev_indexes == [[]] else parentheses[0][i].animate.fade(0) for i in range(wall.w)])\n            prev_indexes[0] = indexes\n            return result\n\n        def highlight_tiles(indexes, cache=[[[]]]):\n            first = False\n            if cache == [[[]]]:\n                first = True\n                cache[0] = [(i, j) for i in range(wall.w) for j in range(wall.h)]\n            for i in range(wall.w):\n                for j in range(wall.h):\n                    if (i, j) in cache[0]:\n                        if first:\n                            wall.shift(ORIGIN if (i, j) in indexes else DOWN * shift)\n                        wall.get_tile(i, j).save_state()\n                        if first:\n                            wall.shift(ORIGIN if (i, j) in indexes else UP * shift)\n            result = AnimationGroup(*[wall.get_tile(i, j).animate.fade(FADE_COEFFICIENT) if (i, j) not in indexes and (i, j) in cache[0] else wall.get_tile(i, j).animate.restore() if (i, j) in indexes else wall.get_tile(i, j).animate.fade(0) for i in range(wall.w) for j in range(wall.h)], run_time=0.75)\n            cache[0] = indexes\n            return result\n        p_copy = parentheses.copy().shift(DOWN * shift)\n        self.next_section()\n        self.play(highlight_parentheses([0, 5]))\n        self.play(highlight_tiles([(0, 0), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (5, 0)]))\n        return\n        brace_offset = 0.25\n        bs = []\n        for i, (text, start, end) in enumerate([('single', tileset[0], tileset[1]), (['opening', 'closing'], [tileset[2], tileset[8]], [tileset[2], tileset[8]]), ('path creation', tileset[3], tileset[7]), ('fill', tileset[9], tileset[9])]):\n\n            def get_b_local(t, s, e):\n                b = BraceBetweenPoints(Point().next_to(s, UP + LEFT, buff=0).get_center(), Point().next_to(e, UP + RIGHT, buff=0).get_center(), direction=UP, color=NOTES_COLOR).scale([-1, NOTES_SCALE, 1])\n                return [b, Tex(t, color=NOTES_COLOR).next_to(b, UP).scale(NOTES_SCALE).shift(DOWN * 0.1)]\n            b_local = []\n            if type(text) is list:\n                for t, s, e in zip(text, start, end):\n                    b_local += get_b_local(t, s, e)\n            else:\n                b_local = get_b_local(text, start, end)\n            bs += b_local\n            additional = []\n            if i == 3:\n                b_local[-1].shift(UP * 0.08)\n                additional += [highlight_tiles([(6, 1), (7, 1)])]\n                additional += [highlight_parentheses([])]\n            if i == 1:\n                additional += [highlight_tiles([(0, 0), (5, 0)])]\n                additional += [highlight_parentheses((0, 5))]\n            if i == 2:\n                additional += [highlight_tiles([(0, 0), (0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (5, 0)])]\n            if i == 0:\n                for b in b_local:\n                    b.shift(DOWN * shift)\n                self.play(task.animate.shift(UP * shift / 2), parentheses.animate.shift(DOWN * shift), wall.animate.shift(DOWN * shift), tileset.animate.shift(DOWN * shift))\n                self.play(*[FadeInUp(b, move_factor=0.1) for b in b_local], highlight_parentheses([1, 2, 3, 4, 6, 7]), highlight_tiles([(2, 0), (1, 0), (3, 0), (4, 0), (6, 0), (7, 0)]))\n            else:\n                self.play(*[FadeInUp(b) for b in b_local], *additional)\n        self.play(highlight_tiles([(i, j) for i in range(wall.w) for j in range(wall.h)]), Transform(parentheses, p_copy))\n        wall.save_state()\n        tileset.save_state()\n        self.play(wall.get_tile(5, 0).get_color_object_in_direction(DOWN).animate.set_fill(PALETTE[1]), wall.get_tile(5, 1).get_color_object_in_direction(UP).animate.set_fill(PALETTE[1]), tileset[6].get_color_object_in_direction(UP).animate.set_fill(PALETTE[1]), tileset[7].get_color_object_in_direction(UP).animate.set_fill(PALETTE[1]), tileset[7].get_color_object_in_direction(DOWN).animate.set_fill(PALETTE[1]), tileset[8].get_color_object_in_direction(DOWN).animate.set_fill(PALETTE[1]))\n        self.play(Rotate(parentheses[0][5]), Rotate(parentheses[0][0]), Rotate(wall.get_tile(5, 0).get_color_object_in_direction(UP)), Rotate(wall.get_tile(0, 0).get_color_object_in_direction(UP)))\n        self.play(wall.animate.restore(), tileset.animate.restore(), Rotate(parentheses[0][5], angle=-PI), Rotate(parentheses[0][0], angle=-PI), Rotate(wall.get_tile(5, 0).get_color_object_in_direction(UP), angle=-PI), Rotate(wall.get_tile(0, 0).get_color_object_in_direction(UP), angle=-PI))\n        self.play(*[FadeOutUp(b) for b in bs])\n        no2 = Tex('$\\\\frac{1}{2}n$').next_to(task, DOWN)\n        no2dot = Tex('$1 \\\\cdot \\\\frac{1}{2}n$').next_to(task, DOWN)\n        no2o = Tex('time complexity: $\\\\mathcal{O}(n)$').next_to(task, DOWN).align_to(task[1][0], LEFT)\n        self.play(Write(no2))\n        self.play(TransformMatchingShapes(no2, no2dot))\n        self.play(TransformMatchingShapes(no2dot, no2o))\n        self.play(no2o.animate.shift(DOWN * 2.2), task.animate.shift(DOWN * 2.2), FadeOutDown(wall, move_factor=2.2), FadeOutDown(tileset, move_factor=2.2), FadeOutDown(parentheses, move_factor=2.2), run_time=1.5)\n        opt = HighlightedTex('|optimal| time complexity: $\\\\mathcal{O}(\\\\log n)$').next_to(no2o, DOWN)\n        opt.shift(LEFT * (-no2o[0][0].get_x() + opt[1][0].get_x()))\n        self.play(FadeInDown(opt))\n        arrows = [Arrow(start=UP, end=DOWN, stroke_width=10, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.5).align_on_border(DOWN).shift(LEFT + UP), Arrow(start=UP, end=DOWN, stroke_width=10, max_stroke_width_to_length_ratio=10, max_tip_length_to_length_ratio=0.5).align_on_border(DOWN).shift(RIGHT + UP)]\n        self.play(opt.animate.shift(UP * 1.25), no2o.animate.shift(UP * 1.25), task.animate.shift(UP * 1.25), FadeInUp(arrows[0], move_factor=0.6), FadeInUp(arrows[1], move_factor=0.6))"}]}
{"messages": [{"role": "user", "content": "Animate the prime factorization of numbers from 0 to 12, showing their original form and then their factored form."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\n\nclass Intro(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        lines = open('cisla.txt').read().splitlines()\n        primes = [2, 3, 5, 7, 11, 13]\n        cool = 0.01\n        fade = 0.25\n        nesting_colors = ['#54d4ff', '#fdf39b', '#afffff']\n        nnn = 13\n\n        def factors(n):\n            if n == 0:\n                return ['0']\n            if n == 1:\n                return ['1']\n            f = []\n            for i in range(2, n):\n                count = 0\n                while n % i == 0:\n                    count += 1\n                    n //= i\n                if count == 1:\n                    f.append(i)\n                elif count != 0:\n                    f.append(f'{i}^{count}')\n            if n != 1:\n                f.append(n)\n            return f\n\n        def factors_with_zeroes(n):\n            if n == 0:\n                return ['0']\n            if n == 1:\n                return ['1']\n            f = []\n            for i in range(2, n):\n                count = 0\n                while n % i == 0:\n                    count += 1\n                    n //= i\n                if count != 0 or i in primes:\n                    f.append(f'{i}^{count}')\n            if n != 1:\n                f.append(f'{n}^1')\n            while f[-1].endswith('0'):\n                f.pop()\n            return f\n        numbers_factors = VGroup(*[Tex('$$' + ' \\\\cdot '.join(map(str, factors(i))) + '$$').scale(1.25) for i in range(nnn)]).arrange(DOWN, buff=0.3)\n        numbers_factors_zero = VGroup(*[Tex('$$' + ' \\\\cdot '.join(map(str, factors_with_zeroes(i))) + '$$').scale(1.25) for i in range(nnn)]).arrange(DOWN, buff=0.3)\n        numbers_original = VGroup(*[Tex(i).scale(1.25) for i in range(nnn)]).arrange(DOWN, buff=0.3)\n        numbers = VGroup(*[Tex(f'\\\\textbf{{{l}}}') for l in lines[:nnn]]).arrange(DOWN, buff=0.3)\n        for a, b in zip(numbers_original, numbers):\n            b.move_to(a)\n        for i in range(1, len(numbers_original)):\n            numbers_original[i].align_to(numbers_original[i - 1], RIGHT)\n        numbers_super = numbers_original.copy()\n        for a, b in zip(numbers, numbers_original):\n            a.next_to(b, RIGHT, buff=0.5)\n        for a, b in zip(numbers_original, numbers_factors):\n            b.move_to(a).align_to(a, DOWN).align_to(a, RIGHT)\n        for a, b in zip(numbers_original, numbers_factors_zero):\n            b.move_to(a).align_to(a, DOWN).align_to(a, RIGHT)\n        numbers[0].shift(DOWN * 0.1)\n        for i, n in enumerate(numbers):\n            nesting = 0\n            for j, p in enumerate(lines[i]):\n                if p == '(':\n                    numbers[i][0][j].set_color(nesting_colors[nesting])\n                    nesting += 1\n                elif p == ')':\n                    nesting -= 1\n                    numbers[i][0][j].set_color(nesting_colors[nesting])\n        self.camera.frame.move_to(numbers_original).set_height(numbers_original.get_height() * 1.3)\n        self.play(FadeIn(numbers_original, lag_ratio=cool))\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(VGroup(numbers, numbers_original)), FadeIn(numbers, lag_ratio=cool), lag_ratio=0.25))\n        self.play(*[numbers_original[i].animate.set_opacity(fade) for i in range(len(numbers_original)) if i not in primes], *[numbers[i].animate.set_opacity(fade) for i in range(len(numbers)) if i not in primes])\n        self.play(numbers_original.animate.set_opacity(1), numbers.animate.set_opacity(1))\n        self.play(AnimationGroup(*[Transform(numbers_original[i], numbers_factors[i]) for i in range(len(numbers_factors))], lag_ratio=cool), self.camera.frame.animate.move_to(VGroup(numbers, numbers_original, numbers_factors)))\n        single_factors = primes + [0, 1, 6, 10]\n        self.play(*[numbers_original[i].animate.set_opacity(fade) for i in range(len(numbers_original)) if i not in single_factors], *[numbers[i].animate.set_opacity(fade) for i in range(len(numbers_original)) if i not in single_factors])\n        sr1 = SR(VGroup(numbers_original[0], numbers_original[1], numbers[0], numbers[1]))\n        self.play(Write(sr1))\n        self.play(FadeOut(sr1))\n        self.play(*[numbers_original[i].animate.set_opacity(1) for i in range(len(numbers_original)) if i not in single_factors], *[numbers[i].animate.set_opacity(1) for i in range(len(numbers_original)) if i not in single_factors], *[numbers_original[i].animate.set_opacity(fade) for i in range(len(numbers_original)) if i in single_factors], *[numbers[i].animate.set_opacity(fade) for i in range(len(numbers_original)) if i in single_factors])\n        self.play(numbers_original.animate.set_opacity(1), numbers.animate.set_opacity(1))\n        self.play(AnimationGroup(*[Transform(numbers_original[i], numbers_factors_zero[i]) for i in range(2, len(numbers_factors))], lag_ratio=cool), self.camera.frame.animate.move_to(VGroup(numbers, numbers_original, numbers_factors, numbers_factors_zero)).set_width(VGroup(numbers, numbers_original, numbers_factors, numbers_factors_zero).width * 1.3))\n        anims = []\n        for i in range(len(numbers_original)):\n            num = numbers_original[i][0]\n            for j in range(len(num)):\n                if (i == 11 or i == 13) and j >= 13:\n                    break\n                if (j - 1) % 3 != 0:\n                    anims.append(num[j].animate.set_opacity(fade))\n            if i == 11:\n                anims.append(num[-2].animate.set_opacity(fade))\n            elif i == 11:\n                anims.append(num[-2].animate.set_opacity(fade))\n                anims.append(num[-5].animate.set_opacity(fade))\n        anims2 = []\n        for i in range(len(numbers)):\n            num = numbers[i][0]\n            anims2.append(num[0].animate.set_opacity(fade))\n            anims2.append(num[-1].animate.set_opacity(fade))\n        self.play(*anims, *anims2)\n        n1 = 5\n        sr1 = SR(numbers_original[n1][0][1])\n        sr2 = SR(numbers[n1][0][1])\n        n2 = 9\n        numbers_original[n1].save_state()\n        numbers[n1].save_state()\n        numbers_original[n2].save_state()\n        numbers[n2].save_state()\n        self.play(*[numbers_original[i].animate.set_opacity(fade) for i in range(nnn) if i != n1], *[numbers[i].animate.set_opacity(fade) for i in range(nnn) if i != n1], self.camera.frame.animate.move_to(VGroup(numbers[n1], numbers_original[n1])).set_width(VGroup(numbers[n1], numbers_original[n1]).width * 1.5))\n        self.play(FadeIn(sr1), FadeIn(sr2))\n        self.play(Transform(sr1, SR(numbers_original[n1][0][4])), Transform(sr2, SR(numbers[n1][0][2])))\n        self.play(Transform(sr1, SR(numbers_original[n1][0][7])), Transform(sr2, SR(numbers[n1][0][3:5])))\n        self.play(FadeOut(sr1), FadeOut(sr2), *[numbers_original[i].animate.set_opacity(fade) for i in range(nnn) if i != n2], *[numbers[i].animate.set_opacity(fade) for i in range(nnn) if i != n2], numbers[n2].animate.restore(), numbers_original[n2].animate.restore(), self.camera.frame.animate.move_to(VGroup(numbers[n2], numbers_original[n2])).set_width(VGroup(numbers[n2], numbers_original[n2]).width * 1.5))\n        sr1 = SR(numbers_original[n2][0][1])\n        sr2 = SR(numbers[n2][0][1])\n        self.play(FadeIn(sr1), FadeIn(sr2))\n        self.play(Transform(sr1, SR(numbers_original[n2][0][4])), Transform(sr2, SR(numbers[n2][0][2:6])))\n        self.play(FadeOut(sr1), FadeOut(sr2))\n        self.play(numbers_original.animate.set_opacity(1), numbers.animate.set_opacity(1), self.camera.frame.animate.move_to(VGroup(numbers_super, numbers)).set_height(VGroup(numbers_super, numbers).height * 1.3), AnimationGroup(*[Transform(numbers_original[i], numbers_super[i]) for i in range(len(numbers_factors))], lag_ratio=cool))"}]}
{"messages": [{"role": "user", "content": "Visualize an AB-tree, highlight specific nodes, and then present information about file systems, containers, and databases by zooming into different parts of the tree with associated text."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass Usage(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        ab = ABTree([[[4, 6]], [[1, 2, 3], [5], [7, 8]]], fill_background=False).scale(1.8)\n        self.add(ab)\n        r = Square(fill_opacity=1, color=RED).scale(10)\n        i = r\n        for j in [(0, 0), (1, 0), (1, 1), (1, 2)]:\n            i = Difference(i, ab.node_by_index(*j)[1], fill_opacity=1, color=BLACK).set_z_index(1)\n        ab.node_mobjects.set_z_index(2)\n        ab.edges.set_z_index(1.99)\n        ab.keys.set_z_index(0)\n        self.add(i)\n        self.play(Write(ab))\n        a = Tex('Why')\n        b = Tex('should')\n        c = Tex('I')\n        d = Tex('care?')\n        d_ex = Tex('care!')\n        text = VGroup(a, b, c, d).scale(1.5).set_z_index(0)\n        a.move_to(ab.node_by_index(0, 0)[0]).shift(DOWN * 0.08)\n        b.move_to(ab.node_by_index(1, 0)[0])\n        c.move_to(ab.node_by_index(1, 1)[0])\n        d.move_to(ab.node_by_index(1, 2)[0])\n        d_ex.move_to(d).scale(1.5)\n        self.play(AnimationGroup(AnimationGroup(FadeIn(a, shift=DOWN * 1), FadeOut(ab.node_by_index(0, 0)[0], shift=DOWN * 1)), AnimationGroup(FadeIn(b, shift=DOWN * 1), FadeOut(ab.node_by_index(1, 0)[0], shift=DOWN * 1)), AnimationGroup(FadeIn(c, shift=DOWN * 1), FadeOut(ab.node_by_index(1, 1)[0], shift=DOWN * 1)), AnimationGroup(FadeIn(d, shift=DOWN * 1), FadeOut(ab.node_by_index(1, 2)[0], shift=DOWN * 1)), lag_ratio=0.1))\n        self.camera.frame.save_state()\n\n        def f(index, title, items, scale=1, special=None):\n            self.play(self.camera.frame.animate.move_to(ab.node_by_index(2, index)).scale(scale))\n            fs_title = Tex(title).scale(1.7).set_z_index(10000)\n            fs = VGroup(*[Tex(item) for item in items]).set_z_index(10000)\n            for i in range(1, len(items)):\n                fs[i].align_to(fs[0], LEFT).shift(DOWN * 0.7 * i)\n            fs_group = VGroup(fs_title, fs).arrange(DOWN, buff=0.7).scale(0.08)\n            fs_group.move_to(self.camera.frame)\n            self.play(FadeIn(fs_title))\n            for i in range(len(items)):\n                if special == 1 and i in [1, 2]:\n                    self.play(Write(fs[i][0][:-5], stroke_width=0.2, run_time=0.75))\n                else:\n                    self.play(Write(fs[i], stroke_width=0.2, run_time=0.75))\n            if special == 1:\n                self.play(FadeIn(fs[1][0][-5:], stroke_width=0.2, run_time=1), FadeIn(fs[2][0][-5:], stroke_width=0.2, run_time=1))\n        f(6, '\\\\underline{File systems}', [\"\\\\begin{itemize} \\\\item Apple's \\\\textbf{APFS} \\\\end{itemize}\", \"\\\\begin{itemize} \\\\item Microsoft's \\\\textbf{NTFS} \\\\end{itemize}\", \"\\\\begin{itemize} \\\\item Linux's \\\\textbf{Ext4} \\\\end{itemize}\"], scale=0.08)\n        f(7, '\\\\underline{Containers}', ['\\\\begin{itemize} \\\\item \\\\textbf{Rust} \\\\end{itemize}', '\\\\begin{itemize} \\\\item \\\\textbf{C++} (R\\\\&B) \\\\end{itemize}', '\\\\begin{itemize} \\\\item \\\\textbf{Java} (R\\\\&B) \\\\end{itemize}'], special=1)\n        f(8, '\\\\underline{Databases}', ['\\\\begin{itemize} \\\\item \\\\textbf{Microsoft SQL} \\\\end{itemize}', '\\\\begin{itemize} \\\\item \\\\textbf{Oracle} \\\\end{itemize}', '\\\\begin{itemize} \\\\item \\\\textbf{MySQL} \\\\end{itemize}', '\\\\begin{itemize} \\\\item \\\\textbf{SQLite} \\\\end{itemize}'])\n        self.remove(d)\n        self.add(d_ex)\n        ab.edges_by_node_index(0, 0).set_color(DARK_COLOR)\n        ab.subtree_by_index(1, 1).set_color(DARK_COLOR)\n        c.set_color(DARK_COLOR)\n        self.play(self.camera.frame.animate.move_to(ab.subtree_by_index(1, 2)).scale(5))"}]}
{"messages": [{"role": "user", "content": "Animate a question about a problem with a binary tree restructuring, followed by a solution emphasizing speed, simplicity, and lack of rotations."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass Fever(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        happened = VGroup(Tex('\\\\sc Has This Ever'), Tex('\\\\sc Happened to Y\\\\kern-0.1em ou?')).scale(2.2).arrange(DOWN, buff=0.5)\n        self.play(FadeIn(happened))\n        self.wait()\n        self.camera.frame.save_state()\n        self.remove(happened)\n        binary_tree = ABTree([[[4]], [[2], [6]], [[1], [3], [5], [7]]], fill_background=True).scale(1.5)\n        for edge in binary_tree.edges_individually:\n            edge.scale(1.2)\n        binary_tree.subtree_by_index(1, 0).set_stroke_color(BLACK)\n        binary_tree.node_by_index(1, 0).set_color(BLACK).set_z_index(-1)\n        binary_tree.node_by_index(2, 1).set_color(BLACK).set_z_index(-1)\n        binary_tree.subtree_by_index(2, 0).set_stroke_color(WHITE).move_to(binary_tree.subtree_by_index(1, 0)).align_to(binary_tree.subtree_by_index(1, 0), UP)\n        self.add(binary_tree)\n        self.play(binary_tree.node_by_index(0, 0).animate.move_to(binary_tree.node_by_index(1, 1)), binary_tree.subtree_by_index(2, 0).animate.move_to(binary_tree.node_by_index(0, 0)).align_to(binary_tree.node_by_index(0, 0), UP), binary_tree.subtree_by_index(1, 1).animate.move_to(binary_tree.node_by_index(2, 3)).align_to(binary_tree.node_by_index(2, 3), UP), binary_tree.subtree_by_index(3, 1).animate.move_to(binary_tree.node_by_index(2, 2)).align_to(binary_tree.node_by_index(2, 2), UP), binary_tree.subtree_by_index(3, 0).animate.move_to(binary_tree.node_by_index(2, 0)).align_to(binary_tree.node_by_index(2, 0), UP), Transform(binary_tree.edges_by_node_index(0, 0)[0], binary_tree.edges_by_node_index(0, 0)[1].copy().rotate(PI)), Transform(binary_tree.edges_by_node_index(0, 0)[1], binary_tree.edges_by_node_index(1, 1)[1]), Transform(binary_tree.edges_by_node_index(2, 0)[0], binary_tree.edges_by_node_index(0, 0)[0]), Transform(binary_tree.edges_by_node_index(2, 0)[1], binary_tree.edges_by_node_index(1, 1)[0]), self.camera.frame.animate.scale(1.2).shift(DOWN * 0.75 + LEFT))\n        ono = Tex('\\\\sc Oh no!').scale(3.5).move_to(self.camera.frame).shift(LEFT * 3 + DOWN * 0.75).set_z_index(10).rotate(-PI / 8)\n        self.play(SpinInFromNothing(ono, angle=3 * PI))\n        self.wait()\n        rect = get_fade_rect()\n        bw = VGroup(Tex('\\\\sc Is there a'), Tex('\\\\sc better way?')).scale(3.5).arrange(DOWN, buff=0.5).move_to(self.camera.frame).set_z_index(1000)\n        thereis = Tex('\\\\sc There is!').next_to(bw, DOWN).scale(4.5).set_z_index(1000)\n        g = VGroup(bw.copy(), thereis).arrange(DOWN, buff=1.5).move_to(self.camera.frame)\n        self.play(AnimationGroup(FadeIn(rect), FadeIn(bw), lag_ratio=0.5))\n        self.play(Transform(bw, g[0]), FadeIn(thereis, shift=UP * 0.5))\n        self.wait()\n        for m in self.mobjects:\n            self.remove(m)\n        self.camera.frame.restore()\n        ab_tree = ABTree([[[2, 4]], [[1], [3], [5, 6, 7]]]).scale(1.75)\n        self.add(ab_tree)\n        g = VGroup(Tex('\\\\sc Fast!').scale(1.5).next_to(ab_tree.node_by_index(0, 0), LEFT, buff=1.5), Tex('\\\\sc Simpl!').scale(1.5).next_to(ab_tree.node_by_index(0, 0), RIGHT, buff=1.2), Tex('\\\\sc No rotations!').scale(1.5).rotate(PI).next_to(ab_tree.node_by_index(0, 0), UP, buff=0.75))\n        g[0].align_to(g[1], UP)\n        self.play(FadeIn(g[0], shift=RIGHT * 0.5), run_time=0.33)\n        self.play(FadeIn(g[1], shift=LEFT * 0.5))\n        self.play(FadeIn(g[2], shift=DOWN * 0.5), self.camera.frame.animate.shift(UP * 0.75))"}]}
{"messages": [{"role": "user", "content": "Introduce an (a,b)-tree and a binary search tree, then animate their arrangement side-by-side while zooming out the camera."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass IntroFix(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        ab_tree = ABTree([[[2, 4]], [[1], [3], [5, 6, 7]]], fill_background=False)\n        binary_tree = ABTree([[[4]], [[2], [6]], [[1], [3], [5], [7]]], fill_background=False)\n        ab = VGroup(Tex('\\\\underline{$(a,b)$-tree}').scale(1.25), ab_tree).arrange(DOWN, buff=1)\n        bst = VGroup(Tex('\\\\underline{binary search tree}').scale(1.25), binary_tree).arrange(DOWN, buff=1.2)\n        ab.move_to(self.camera.frame.get_center())\n        bst.move_to(self.camera.frame.get_center())\n        self.camera.frame.scale(0.95)\n        S = 0.8\n        self.camera.frame.scale(S)\n        self.play(Write(ab))\n        group_cp = VGroup(ab.copy(), bst).arrange(buff=1.15)\n        group_cp[0].align_to(group_cp[1], UP)\n        self.play(AnimationGroup(AnimationGroup(ab[0].animate.move_to(group_cp[0][0]), ab[1].animate.move_to(group_cp[0][1]).align_to(bst, DOWN), self.camera.frame.animate.scale(1 / S)), FadeIn(bst), lag_ratio=0.5))\n        self.next_section()\n        ab[0].set_z_index(10000)\n        s = Square(fill_opacity=1, stroke_width=0).set_color(BLACK).set_width(ab[0].get_width()).set_z_index(100).move_to(ab[0]).align_to(ab[0], DOWN)\n        self.add(s)\n        bbp = Tex('B or B\\\\texttt{+}').scale(1.25).next_to(ab[0], DOWN, buff=0.1)\n        self.add(bbp)\n        bbp.shift(UP * 1)\n        self.play(bbp.animate.shift(DOWN * 1))\n        self.play(bbp.animate.shift(UP * 1))"}]}
{"messages": [{"role": "user", "content": "Demonstrate the process of inserting nodes into an AVL tree and an AB tree, highlighting the balancing operations."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass Intro(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        ab_tree = ABTree([[[2, 4]], [[1], [3], [5, 6, 7]]], fill_background=False)\n        binary_tree = ABTree([[[4]], [[2], [6]], [[1], [3], [5], [7]]], fill_background=False)\n        ab = VGroup(Tex('\\\\underline{$(a,b)$-tree}').scale(1.25), ab_tree).arrange(DOWN, buff=1)\n        bst = VGroup(Tex('\\\\underline{binary search tree}').scale(1.25), binary_tree).arrange(DOWN, buff=1.2)\n        ab.move_to(self.camera.frame.get_center())\n        bst.move_to(self.camera.frame.get_center())\n        self.camera.frame.scale(0.95)\n        S = 0.8\n        self.camera.frame.scale(S)\n        self.play(Write(ab))\n        group_cp = VGroup(ab.copy(), bst).arrange(buff=1.15)\n        group_cp[0].align_to(group_cp[1], UP)\n        self.play(AnimationGroup(AnimationGroup(ab[0].animate.move_to(group_cp[0][0]), ab[1].animate.move_to(group_cp[0][1]).align_to(bst, DOWN), self.camera.frame.animate.scale(1 / S)), FadeIn(bst), lag_ratio=0.5))\n        a1 = Arrow(ORIGIN, DOWN * 1.25).next_to(ab_tree.node_by_index(1, 2), UP).set_color(BLUE)\n        a2 = Arrow(ORIGIN, DOWN * 1.25).next_to(ab_tree.node_by_index(0, 0), UP).set_color(BLUE)\n        self.play(AnimationGroup(AnimationGroup(ab_tree.node_by_index(0, 0).animate.set_color(BLUE), ab_tree.node_edges[ab_tree.node_by_index(0, 0)].animate.set_color(BLUE), FadeIn(a2, shift=DOWN * 0.25)), AnimationGroup(ab_tree.node_by_index(1, 2).animate.set_color(BLUE), ab_tree.node_edges[ab_tree.node_by_index(1, 2)].animate.set_color(BLUE), FadeIn(a1, shift=DOWN * 0.25)), lag_ratio=0.1))\n        self.play(FadeOut(a1), FadeOut(a2), ab_tree.node_by_index(0, 0).animate.set_color(WHITE), ab_tree.node_edges[ab_tree.node_by_index(0, 0)].animate.set_color(WHITE), ab_tree.node_by_index(1, 2).animate.set_color(WHITE), ab_tree.node_edges[ab_tree.node_by_index(1, 2)].animate.set_color(WHITE))\n        keys = VGroup(*list(ab_tree.keys) + list(binary_tree.keys))\n        min_x, max_x = (float('inf'), float('-inf'))\n        for k in keys:\n            min_x = min(k.get_x(), min_x)\n            max_x = max(k.get_x(), max_x)\n        wait_scale = 0.5\n        runtime = 1.25\n        self.play(ab_tree.skeleton.animate(rate_func=lambda t: there_and_back_with_pause(t), run_time=wait_scale * 3 + runtime).set_color(DARK_COLOR), binary_tree.skeleton.animate(rate_func=lambda t: there_and_back_with_pause(t), run_time=wait_scale * 3 + runtime).set_color(DARK_COLOR), Succession(Wait(wait_scale), AnimationGroup(*[Succession(Wait((k.get_x() - min_x) / (max_x - min_x) * wait_scale), k.animate(rate_func=there_and_back, run_time=runtime).scale(1.35).set_color(WHITE)) for k in keys])))\n        self.camera.frame.save_state()\n        self.play(ab.animate.set_color(DARK_COLOR).shift(LEFT * 4), self.camera.frame.animate.move_to(bst))\n        bubbles, node_bubbles = get_tree_bubbles(binary_tree)\n        target = Tex('$5$').next_to(binary_tree.node_by_index(0, 0), UP).scale(0.8).set_z_index(10000)\n        self.play(FadeIn(target, shift=UP * 0.1))\n        self.play(FadeIn(bubbles))\n        binary_tree.save_state()\n        bubbles.save_state()\n        bezier = CubicBezier(target.get_center(), Dot().move_to(binary_tree.node_by_index(1, 1)).align_to(target, DOWN).get_center(), Dot().move_to(binary_tree.node_by_index(1, 1)).align_to(target, DOWN).get_center(), target.copy().next_to(binary_tree.node_by_index(1, 1), UP).get_center())\n        self.play(MoveAlongPath(target, bezier), binary_tree.node_subtree_mobjects[binary_tree.node_by_index(1, 0)].animate.set_color(DARK_COLOR), binary_tree.node_edges[binary_tree.node_by_index(0, 0)][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(0, 0)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(1, 0)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 0)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 1)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(1, 0)][1][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 0)][1][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 1)][1][0].animate.set_color(DARK_COLOR))\n        bezier = CubicBezier(target.get_center(), Dot().move_to(binary_tree.node_by_index(2, 2)).align_to(target, DOWN).get_center(), Dot().move_to(binary_tree.node_by_index(2, 2)).align_to(target, DOWN).get_center(), target.copy().next_to(binary_tree.node_by_index(2, 2), UP).get_center())\n        self.play(MoveAlongPath(target, bezier), binary_tree.node_subtree_mobjects[binary_tree.node_by_index(2, 3)].animate.set_color(DARK_COLOR), binary_tree.node_edges[binary_tree.node_by_index(1, 1)][1].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(1, 1)][1][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 3)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 3)][1][0].animate.set_color(DARK_COLOR))\n        target_cp = binary_tree.node_by_index(2, 2)[0].copy().set_opacity(0).set_color(GREEN)\n        self.play(Transform(target, target_cp), binary_tree.node_by_index(2, 2).animate.set_color(GREEN))\n        self.remove(target_cp)\n        self.play(binary_tree.animate.restore(), bubbles.animate.restore())\n        target = Tex('$8$').next_to(binary_tree.node_by_index(0, 0), UP).scale(0.8).set_z_index(10000)\n        self.play(Write(target))\n        binary_tree.save_state()\n        bubbles.save_state()\n        bezier = CubicBezier(target.get_center(), Dot().move_to(binary_tree.node_by_index(1, 1)).align_to(target, DOWN).get_center(), Dot().move_to(binary_tree.node_by_index(1, 1)).align_to(target, DOWN).get_center(), target.copy().next_to(binary_tree.node_by_index(1, 1), UP).get_center())\n        self.play(MoveAlongPath(target, bezier), binary_tree.node_subtree_mobjects[binary_tree.node_by_index(1, 0)].animate.set_color(DARK_COLOR), binary_tree.node_edges[binary_tree.node_by_index(0, 0)][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(0, 0)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(1, 0)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 0)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 1)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(1, 0)][1][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 0)][1][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 1)][1][0].animate.set_color(DARK_COLOR))\n        bezier = CubicBezier(target.get_center(), Dot().move_to(binary_tree.node_by_index(2, 3)).align_to(target, DOWN).get_center(), Dot().move_to(binary_tree.node_by_index(2, 3)).align_to(target, DOWN).get_center(), target.copy().next_to(binary_tree.node_by_index(2, 3), UP).get_center())\n        self.play(MoveAlongPath(target, bezier), binary_tree.node_subtree_mobjects[binary_tree.node_by_index(2, 2)].animate.set_color(DARK_COLOR), binary_tree.node_edges[binary_tree.node_by_index(1, 1)][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(1, 1)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 2)][0][0].animate.set_color(DARK_COLOR), node_bubbles[binary_tree.node_by_index(2, 2)][1][0].animate.set_color(DARK_COLOR))\n        bezier = CubicBezier(target.get_center(), Dot().move_to(binary_tree.node_by_index(3, 7)).align_to(target, DOWN).get_center(), Dot().move_to(binary_tree.node_by_index(3, 7)).align_to(target, DOWN).get_center(), target.copy().move_to(binary_tree.node_by_index(3, 7), UP).get_center())\n        self.play(MoveAndFade(target, bezier), binary_tree.node_subtree_mobjects[binary_tree.node_by_index(3, 7)].animate.set_color(RED), node_bubbles[binary_tree.node_by_index(2, 3)][0][0].animate.set_color(DARK_COLOR), binary_tree.node_edges[binary_tree.node_by_index(2, 3)][0].animate.set_color(DARK_COLOR), binary_tree.node_subtree_mobjects[binary_tree.node_by_index(3, 6)].animate.set_color(DARK_COLOR))\n        self.remove(target_cp)\n        self.play(binary_tree.animate.restore(), bubbles.animate.restore())\n        old_bubbles = bubbles\n        bubbles, node_bubbles = get_tree_bubbles(ab_tree)\n        self.add(bubbles)\n        self.play(ab.animate.set_color(WHITE).shift(RIGHT * 4), bst.animate.set_color(DARK_COLOR).shift(RIGHT * 4), bubbles.animate.shift(RIGHT * 4), old_bubbles.animate.set_color(DARK_COLOR).shift(RIGHT * 4), self.camera.frame.animate.move_to(ab).shift(RIGHT * 4))\n        self.remove(old_bubbles)\n        target = Tex('$5$').next_to(ab_tree.node_by_index(0, 0), UP).scale(0.8).set_z_index(10000)\n        self.play(Write(target))\n        ab_tree.save_state()\n        bubbles.save_state()\n        bezier = CubicBezier(target.get_center(), Dot().move_to(ab_tree.node_by_index(1, 2)).align_to(target, DOWN).get_center(), Dot().move_to(ab_tree.node_by_index(1, 2)).align_to(target, DOWN).get_center(), target.copy().next_to(ab_tree.node_by_index(1, 2), UP).get_center())\n        self.play(MoveAlongPath(target, bezier), ab_tree.node_subtree_mobjects[ab_tree.node_by_index(1, 0)].animate.set_color(DARK_COLOR), ab_tree.node_subtree_mobjects[ab_tree.node_by_index(1, 1)].animate.set_color(DARK_COLOR), ab_tree.node_edges[ab_tree.node_by_index(0, 0)][0].animate.set_color(DARK_COLOR), ab_tree.node_edges[ab_tree.node_by_index(0, 0)][1].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(0, 0)][0][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(0, 0)][1][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(1, 0)][0][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(1, 0)][1][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(1, 1)][0][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(1, 1)][1][0].animate.set_color(DARK_COLOR))\n        target_cp = ab_tree.node_by_index(1, 2)[0][0].copy().set_opacity(0).set_color(GREEN)\n        self.play(Transform(target, target_cp), ab_tree.node_by_index(1, 2).animate.set_color(GREEN), ab_tree.node_by_index(1, 2)[0][1].animate.set_color(WHITE), ab_tree.node_by_index(1, 2)[0][2].animate.set_color(WHITE))\n        ab_tree.node_by_index(1, 2)[0][1].set_color(WHITE)\n        ab_tree.node_by_index(1, 2)[0][2].set_color(WHITE)\n        self.remove(old_bubbles)\n        bst.set_color(WHITE)\n        self.play(ab_tree.animate.restore(), bubbles.animate.restore())\n        target = Tex('$8$').next_to(ab_tree.node_by_index(0, 0), UP).scale(0.8).set_z_index(10000)\n        self.play(Write(target))\n        ab_tree.save_state()\n        bubbles.save_state()\n        bezier = CubicBezier(target.get_center(), Dot().move_to(ab_tree.node_by_index(1, 2)).align_to(target, DOWN).get_center(), Dot().move_to(ab_tree.node_by_index(1, 2)).align_to(target, DOWN).get_center(), target.copy().next_to(ab_tree.node_by_index(1, 2), UP).get_center())\n        self.play(MoveAlongPath(target, bezier), ab_tree.node_subtree_mobjects[ab_tree.node_by_index(1, 0)].animate.set_color(DARK_COLOR), ab_tree.node_subtree_mobjects[ab_tree.node_by_index(1, 1)].animate.set_color(DARK_COLOR), ab_tree.node_edges[ab_tree.node_by_index(0, 0)][0].animate.set_color(DARK_COLOR), ab_tree.node_edges[ab_tree.node_by_index(0, 0)][1].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(0, 0)][0][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(0, 0)][1][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(1, 0)][0][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(1, 0)][1][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(1, 1)][0][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(1, 1)][1][0].animate.set_color(DARK_COLOR))\n        bezier = CubicBezier(target.get_center(), Dot().move_to(ab_tree.node_by_index(2, 7)).align_to(target, DOWN).get_center(), Dot().move_to(ab_tree.node_by_index(2, 7)).align_to(target, DOWN).get_center(), target.copy().move_to(ab_tree.node_by_index(2, 7), UP).get_center())\n        self.play(MoveAndFade(target, bezier), ab_tree.node_subtree_mobjects[ab_tree.node_by_index(2, 7)].animate.set_color(RED), node_bubbles[ab_tree.node_by_index(1, 2)][0][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(1, 2)][1][0].animate.set_color(DARK_COLOR), node_bubbles[ab_tree.node_by_index(1, 2)][2][0].animate.set_color(DARK_COLOR), ab_tree.node_edges[ab_tree.node_by_index(1, 2)][0].animate.set_color(DARK_COLOR), ab_tree.node_edges[ab_tree.node_by_index(1, 2)][1].animate.set_color(DARK_COLOR), ab_tree.node_edges[ab_tree.node_by_index(1, 2)][2].animate.set_color(DARK_COLOR), ab_tree.node_subtree_mobjects[ab_tree.node_by_index(2, 4)].animate.set_color(DARK_COLOR), ab_tree.node_subtree_mobjects[ab_tree.node_by_index(2, 5)].animate.set_color(DARK_COLOR), ab_tree.node_subtree_mobjects[ab_tree.node_by_index(2, 6)].animate.set_color(DARK_COLOR))\n        self.play(ab_tree.animate.restore(), FadeOut(bubbles), bst.animate.shift(LEFT * 4), self.camera.frame.animate.move_to(VGroup(ab_tree, bst.copy().shift(LEFT * 4))))\n        ng = VGroup(binary_tree)\n        self.play(ab.animate.set_color(DARK_COLOR).shift(LEFT * 4), bst[0].animate.set_color(DARK_COLOR).shift(UP * 4), self.camera.frame.animate.move_to(ng).set_height(ng.get_height() * 1.6))\n        ab.shift(LEFT * 10)\n        a = binary_tree.node_by_index(3, 7)\n        b = ABTree([[[8]]], fill_background=False).move_to(a).align_to(a, UP + LEFT)\n        e = binary_tree.node_edges[binary_tree.node_by_index(2, 3)][1]\n        ng = VGroup(binary_tree, b)\n        self.play(self.camera.frame.animate.move_to(ng).set_height(ng.get_height() * 1.4), AnimationGroup(AnimationGroup(ReplacementTransform(a, b.node_by_index(0, 0)), ReplacementTransform(e, Line(e.points[0], Dot().scale(0.001).move_to(b).align_to(b, UP).get_center()))), AnimationGroup(FadeIn(b.node_by_index(1, 0)), FadeIn(b.node_by_index(1, 1)), FadeIn(b.node_edges[b.node_by_index(0, 0)])), lag_ratio=0.5))\n        old_b = b\n        a = old_b.node_by_index(1, 1)\n        b = ABTree([[[9]]], fill_background=False).move_to(a).align_to(a, UP + LEFT)\n        e = old_b.node_edges[old_b.node_by_index(0, 0)][1]\n        ng = VGroup(binary_tree, b)\n        self.play(self.camera.frame.animate.move_to(ng).set_height(ng.get_height() * 1.4), AnimationGroup(AnimationGroup(ReplacementTransform(a, b.node_by_index(0, 0)), ReplacementTransform(e, Line(e.points[0], Dot().scale(0.001).move_to(b).align_to(b, UP).get_center()))), AnimationGroup(FadeIn(b.node_by_index(1, 0)), FadeIn(b.node_by_index(1, 1)), FadeIn(b.node_edges[b.node_by_index(0, 0)])), lag_ratio=0.5))\n        old_b = b\n        a = old_b.node_by_index(1, 1)\n        b = ABTree([[[10]]], fill_background=False).move_to(a).align_to(a, UP + LEFT)\n        e = old_b.node_edges[old_b.node_by_index(0, 0)][1]\n        ng = VGroup(binary_tree, b)\n        self.play(self.camera.frame.animate.move_to(ng).set_height(ng.get_height() * 1.4), AnimationGroup(AnimationGroup(ReplacementTransform(a, b.node_by_index(0, 0)), ReplacementTransform(e, Line(e.points[0], Dot().scale(0.001).move_to(b).align_to(b, UP).get_center()))), AnimationGroup(FadeIn(b.node_by_index(1, 0)), FadeIn(b.node_by_index(1, 1)), FadeIn(b.node_edges[b.node_by_index(0, 0)])), lag_ratio=0.5))\n        avl = Tex('AVL trees')\n        rb = Tex('R\\\\&B trees')\n        g = VGroup(avl, rb).scale(2).arrange(DOWN, buff=0.35).move_to(ng).align_to(ng, DOWN + LEFT).shift(LEFT * 1.4)\n        avl.align_to(rb, RIGHT)\n        self.play(FadeIn(avl, shift=RIGHT))\n        self.play(FadeIn(rb, shift=RIGHT))\n        rect = get_fade_rect(z_index=100)\n        t = Tex('$\\\\times$').move_to(VGroup(g, ng)).shift(DOWN * 0.25).scale(15).set_color(RED).set_z_index(101)\n        self.play(AnimationGroup(FadeIn(rect), FadeIn(t), lag_ratio=0.5))\n        ab_four = ABTree([[[2, 4]], [[1], [3], [5, 6, 7]]], fill_background=False).scale(2).next_to(self.camera.frame, LEFT).set_z_index(1000)\n        self.add(ab_four)\n        self.play(self.camera.frame.animate.move_to(ab_four))\n        self.play(self.camera.frame.animate(rate_func=rush_into).move_to(ab_four.node_by_index(0, 0)).scale(0.005))"}]}
{"messages": [{"role": "user", "content": "Illustrate the properties and operations of an $(a,b)$-tree with animated transitions and highlighting of key elements."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass Basics(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        ab_tree = ABTree([[[1, 3]], [[0], [2], [4, 5, 6]]], fill_background=False)\n        bee = SVGMobject('assets/bee.svg')\n        bees = VGroup()\n        nums = VGroup()\n        ab = VGroup(Tex('\\\\underline{$(a,b)$-tree}').scale(1.25), ab_tree).arrange(DOWN, buff=1.2)\n        two_four = Tex('\\\\underline{$(2,4)$-tree}').scale(1.25).move_to(ab[0]).set_color(BLUE)\n        self.camera.frame.scale(0.8)\n        indexes = [(0, 0, 0), (0, 0, 1), (1, 0, 0), (1, 1, 0), (1, 2, 0), (1, 2, 1), (1, 2, 2)]\n        for x, y, i in indexes:\n            item = ab_tree.node_by_index(x, y)[0][i]\n            bees.add(bee.copy().set_height(item.get_height()).move_to(item))\n            nums.add(item.copy())\n            item.set_opacity(0)\n        self.play(AnimationGroup(AnimationGroup(Write(ab)), FadeIn(bees, lag_ratio=0.1), lag_ratio=0.5))\n        self.play(AnimationGroup(AnimationGroup(*[FadeOut(bee, shift=DOWN * 0.25, run_time=0.75) for bee in bees], lag_ratio=0.1), AnimationGroup(*[FadeIn(num, shift=DOWN * 0.25, run_time=0.75) for num in nums], lag_ratio=0.1), lag_ratio=0.1))\n        for x, y, i in indexes:\n            ab_tree.node_by_index(x, y)[0][i].set_opacity(1)\n        for num in nums:\n            self.remove(num)\n        self.play(ab_tree.edges.animate.set_color(DARK_COLOR))\n        self.play(*[node[1].animate.set_color(DARK_COLOR) for node in ab_tree.nodes])\n        symbols = VGroup(Tex('$<$', stroke_width=1.5).scale(0.4).move_to(ab_tree.node_by_index(0, 0)[0][0:2]).shift(LEFT * 0.035), Tex('$<$', stroke_width=1.5).scale(0.4).move_to(ab_tree.node_by_index(1, 2)[0][0:2]), Tex('$<$', stroke_width=1.5).scale(0.4).move_to(ab_tree.node_by_index(1, 2)[0][1:3]))\n        self.play(Write(symbols))\n        self.play(symbols.animate.set_color(DARK_COLOR), *[node[0].animate.set_color(DARK_COLOR) for node in ab_tree.nodes], ab_tree.leafs.animate.set_color(WHITE))\n        self.play(ab_tree.animate.set_color(WHITE), symbols.animate.set_color(WHITE))\n        self.play(ab_tree.node_by_index(0, 0)[0][1].animate.set_color(DARK_COLOR), symbols.animate.set_color(DARK_COLOR), ab_tree.subtree_by_index(1, 2).animate.set_color(DARK_COLOR), ab_tree.edges_by_node_index(0, 0)[2].animate.set_color(DARK_COLOR))\n        symbol = Tex('$<$').scale(1).move_to(VGroup(Dot().next_to(ab_tree.node_by_index(1, 0), RIGHT), Dot().next_to(ab_tree.node_by_index(1, 1), LEFT)))\n        self.play(ab_tree.subtree_by_index(1, 0).animate.set_color(RED), ab_tree.edges_by_node_index(0, 0)[0].animate.set_color_by_gradient((WHITE, WHITE, RED, RED)), FadeIn(symbol))\n        self.play(ab_tree.subtree_by_index(1, 1).animate.set_color(GREEN), ab_tree.edges_by_node_index(0, 0)[1].animate.set_color_by_gradient((WHITE, WHITE, GREEN, GREEN)))\n        symbol2 = Tex('$<$').scale(1).move_to(VGroup(Dot().next_to(ab_tree.node_by_index(1, 1), RIGHT), Dot().next_to(ab_tree.node_by_index(1, 2), LEFT)))\n        self.play(FadeOut(symbol), FadeIn(symbol2), ab_tree.node_by_index(0, 0)[0][0].animate.set_color(DARK_COLOR), ab_tree.node_by_index(0, 0)[0][1].animate.set_color(WHITE), ab_tree.subtree_by_index(1, 0).animate.set_color(DARK_COLOR), ab_tree.subtree_by_index(1, 1).animate.set_color(RED), ab_tree.subtree_by_index(1, 2).animate.set_color(GREEN), ab_tree.edges_by_node_index(0, 0)[0].animate.set_color(DARK_COLOR), ab_tree.edges_by_node_index(0, 0)[1].animate.set_color_by_gradient((WHITE, WHITE, RED, RED)), ab_tree.edges_by_node_index(0, 0)[2].animate.set_color_by_gradient((GREEN, GREEN, WHITE, WHITE)), symbols[1].animate.set_color(GREEN), symbols[2].animate.set_color(GREEN))\n        self.play(ab_tree.animate.set_color(WHITE), symbols.animate.set_color(WHITE), FadeOut(symbol2))\n        a1 = Arrow(ORIGIN, UP * 1.05).next_to(ab[0][0][1], DOWN, buff=0.35).set_color(GRAY)\n        a2 = Arrow(ORIGIN, UP * 1.05).next_to(ab[0][0][3], DOWN, buff=0.35).set_color(GRAY)\n        t1 = Tex('\\\\underline{\\\\phantom{(}min. children\\\\phantom{)}    }').scale(0.6).next_to(a1, LEFT, buff=-0.075).align_to(a1, DOWN).set_color(GRAY)\n        t2 = Tex('\\\\underline{    \\\\phantom{)}max. children\\\\phantom{)}}').scale(0.6).next_to(a2, RIGHT, buff=-0.075).align_to(a2, DOWN).set_color(GRAY)\n        non_root = Tex('($2$ for root)').scale(0.6).next_to(t1, DOWN, buff=0.12).set_color(GRAY).shift(LEFT * 0.05)\n        ab_tree.save_state()\n        symbols.save_state()\n        counts_scale = 0.5\n        counts = VGroup(Tex('\\\\textbf{3}').move_to(ab_tree.node_by_index(0, 0)).scale(counts_scale).set_z_index(10), Tex('\\\\textbf{2}').move_to(ab_tree.node_by_index(1, 0)).scale(counts_scale).set_z_index(10), Tex('\\\\textbf{2}').move_to(ab_tree.node_by_index(1, 1)).scale(counts_scale).set_z_index(10), Tex('\\\\textbf{4}').move_to(ab_tree.node_by_index(1, 2)).scale(counts_scale).set_z_index(10)).set_color(BLACK)\n        counts_circles = VGroup(Circle(fill_opacity=1).scale(0.25 * counts_scale).set_color(BLUE).set_z_index(9).move_to(counts[0]), Circle(fill_opacity=1).scale(0.25 * counts_scale).set_color(BLUE).set_z_index(9).move_to(counts[1]), Circle(fill_opacity=1).scale(0.25 * counts_scale).set_color(BLUE).set_z_index(9).move_to(counts[2]), Circle(fill_opacity=1).scale(0.25 * counts_scale).set_color(BLUE).set_z_index(9).move_to(counts[3]))\n        counts_combined = VGroup(VGroup(counts[0], counts_circles[0]).next_to(ab_tree.node_by_index(0, 0), DOWN, buff=0).shift(UP * 0.1), VGroup(counts[1], counts_circles[1]).next_to(ab_tree.node_by_index(1, 0), DOWN, buff=0).shift(UP * 0.1), VGroup(counts[2], counts_circles[2]).next_to(ab_tree.node_by_index(1, 1), DOWN, buff=0).shift(UP * 0.1), VGroup(counts[3], counts_circles[3]).next_to(ab_tree.node_by_index(1, 2), DOWN, buff=0).shift(UP * 0.1))\n        self.play(AnimationGroup(AnimationGroup(FadeIn(counts), FadeIn(counts_circles), ab_tree.edges_by_node_index(0, 0).animate.set_color(BLUE), ab_tree.edges_by_node_index(1, 0).animate.set_color(BLUE), ab_tree.edges_by_node_index(1, 1).animate.set_color(BLUE), ab_tree.edges_by_node_index(1, 2).animate.set_color(BLUE)), lag_ratio=0.5))\n        self.play(AnimationGroup(FadeIn(a1, shift=UP * 0.25), FadeIn(a2, shift=UP * 0.25), lag_ratio=0.1))\n        self.play(FadeIn(t1))\n        self.play(FadeIn(t2))\n        at1 = VGroup(a1, t1)\n        at2 = VGroup(a2, t2)\n        rect = get_fade_rect(z_index=10)\n        b_copy = ab[0][0][3].copy().next_to(two_four[0][3], UP, buff=0).scale(0.6)\n        self.play(AnimationGroup(ab[0][0][1].animate.next_to(two_four[0][1], UP, buff=0).scale(0.6).align_to(b_copy, DOWN).set_color(GRAY), FadeIn(two_four[0][1]), lag_ratio=0.5), AnimationGroup(ab[0][0][3].animate.next_to(two_four[0][3], UP, buff=0).scale(0.6).set_color(GRAY), FadeIn(two_four[0][3]), lag_ratio=0.5))\n        ab_tree.save_state()\n        counts.save_state()\n        self.play(counts_circles[0].animate.set_color(DARK_COLOR), counts_circles[1].animate.set_color(DARK_COLOR), counts_circles[2].animate.set_color(DARK_COLOR), counts_circles[3].animate.set_color(DARK_COLOR), ab_tree.node_by_index(0, 0).animate.set_color(DARK_COLOR), ab_tree.node_by_index(1, 0).animate.set_color(DARK_COLOR), ab_tree.node_by_index(1, 1).animate.set_color(DARK_COLOR), ab_tree.node_by_index(1, 2).animate.set_color(DARK_COLOR), ab_tree.edges_by_node_index(0, 0).animate.set_color(DARK_COLOR), ab_tree.edges_by_node_index(1, 0).animate.set_color(DARK_COLOR), ab_tree.edges_by_node_index(1, 1).animate.set_color(DARK_COLOR), ab_tree.edges_by_node_index(1, 2).animate.set_color(DARK_COLOR), symbols.animate.set_color(DARK_COLOR))\n        self.play(ab_tree.animate.restore(), counts_circles[0].animate.set_color(BLUE), ab_tree.node_by_index(1, 0).animate.set_color(DARK_COLOR), ab_tree.node_by_index(1, 1).animate.set_color(DARK_COLOR), ab_tree.node_by_index(1, 2).animate.set_color(DARK_COLOR), ab_tree.edges_by_node_index(1, 0).animate.set_color(DARK_COLOR), ab_tree.edges_by_node_index(1, 1).animate.set_color(DARK_COLOR), ab_tree.edges_by_node_index(1, 2).animate.set_color(DARK_COLOR), ab_tree.node_by_index(2, 0).animate.set_color(DARK_COLOR), ab_tree.node_by_index(2, 1).animate.set_color(DARK_COLOR), ab_tree.node_by_index(2, 2).animate.set_color(DARK_COLOR), ab_tree.node_by_index(2, 3).animate.set_color(DARK_COLOR), ab_tree.node_by_index(2, 4).animate.set_color(DARK_COLOR), ab_tree.node_by_index(2, 5).animate.set_color(DARK_COLOR), ab_tree.node_by_index(2, 6).animate.set_color(DARK_COLOR), ab_tree.node_by_index(2, 7).animate.set_color(DARK_COLOR), symbols[0].animate.set_color(WHITE))\n        self.play(FadeIn(non_root))\n        self.play(ab_tree.animate(lag_ratio=0).set_color(WHITE), FadeOut(counts_combined, lag_ratio=0), FadeOut(symbols))\n        title_scale = 0.85\n        txt_scale = 0.75\n        reqs_title = Tex('\\\\textbf{Invariants}').scale(title_scale)\n        reqs_list = VGroup(Tex('\\\\begin{itemize} \\\\item leaves on the same layer \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $a \\\\ge 2$,\\\\kern0.5em$b \\\\ge 2a - 1$ \\\\end{itemize}')).arrange(DOWN, buff=0.2).scale(txt_scale)\n        reqs = VGroup(reqs_title, reqs_list).arrange(DOWN, buff=0.3)\n        reqs_list[0][0][1:7].set_color(GREEN)\n        reqs_list[1][0][1:4].set_color(BLUE)\n        reqs_list[1][0][5:].set_color(BLUE)\n        ops_title = Tex('\\\\textbf{Operations}').scale(title_scale)\n        ops_list = VGroup(Tex('\\\\begin{itemize} \\\\item \\\\textit{searching} for a key \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item \\\\textit{inserting} a key \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item \\\\textit{deleting} a key \\\\end{itemize}')).arrange(DOWN, buff=0.2).scale(txt_scale)\n        ops = VGroup(ops_title, ops_list).arrange(DOWN, buff=0.3)\n        for l in [ops_list, reqs_list]:\n            for b in l:\n                b.align_to(l[0], LEFT)\n        ops_list.align_to(ops_title, LEFT).shift(RIGHT * 0.1)\n        reqs_list.align_to(reqs_title, LEFT).shift(RIGHT * 0.1)\n        ops.next_to(ab, RIGHT, buff=1.5).align_to(ab, DOWN)\n        reqs.next_to(ab, RIGHT, buff=1.5).align_to(ab[0][0][0], UP)\n        brace = BraceBetweenPoints(Dot().move_to(ab_tree).align_to(ab_tree, UP + LEFT).shift(LEFT * 0.15).get_center(), Dot().move_to(ab_tree).align_to(ab_tree, DOWN + LEFT).shift(LEFT * 0.15 + DOWN * 0.1).get_center())\n        t = Tex('$$\\\\log(n)$$').scale(0.6).rotate(PI / 2).next_to(brace, LEFT)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(VGroup(ab_tree, at1, at2, ops, reqs, t)).scale(1.25), Write(reqs_title), lag_ratio=0.5))\n        self.play(FadeIn(reqs_list[0], shift=RIGHT * 0.25), ab_tree.node_by_index(2, 0).animate.set_color(GREEN), ab_tree.node_by_index(2, 1).animate.set_color(GREEN), ab_tree.node_by_index(2, 2).animate.set_color(GREEN), ab_tree.node_by_index(2, 3).animate.set_color(GREEN), ab_tree.node_by_index(2, 4).animate.set_color(GREEN), ab_tree.node_by_index(2, 5).animate.set_color(GREEN), ab_tree.node_by_index(2, 6).animate.set_color(GREEN), ab_tree.node_by_index(2, 7).animate.set_color(GREEN))\n        self.play(FadeIn(brace, shift=RIGHT * 0.2), FadeIn(t, shift=RIGHT * 0.2))\n        self.play(FadeIn(reqs_list[1][0][:5], shift=RIGHT * 0.25))\n        self.play(FadeIn(reqs_list[1][0][5:], shift=RIGHT * 0.1))\n        a = CreateHighlight(reqs_list[1][0][1:4])\n        b = CreateHighlight(reqs_list[1][0][5:])\n        self.play(FadeIn(a))\n        self.play(Transform(a, b))\n        self.play(FadeOut(a))\n        self.play(Write(ops_title))\n        for row in ops_list:\n            self.play(FadeIn(row, shift=RIGHT * 0.25))"}]}
{"messages": [{"role": "user", "content": "Visualize the insertion of randomly ordered numbers into an AVL tree, with the camera dynamically adjusting to fit the tree after each insertion."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass Outro(MovingCameraScene):\n\n    def construct(self):\n        tree = ABTree([[[]]], fill_background=False).scale(S)\n        self.camera.frame.scale(0.75)\n        n = 50\n        nums = list(range(n))\n        seed(3735928559)\n        shuffle(nums)\n\n        def get_camera_anim():\n            w_ratio = tree.get_width() * 1.2 / self.camera.frame.get_width()\n            h_ratio = tree.get_height() * 1.5 / self.camera.frame.get_height()\n            print(w_ratio, h_ratio)\n            return self.camera.frame.animate.move_to(tree).scale(max(w_ratio, h_ratio, 1))\n        for ii, i in enumerate(nums):\n            anim, tree = tree.insert(i, scale=S)\n            self.play(anim, get_camera_anim(), run_time=1 if ii <= 3 else 0.7 if ii <= 5 else 0.4 if ii <= 7 else 0.25)\n            for mobject in self.mobjects:\n                self.remove(mobject)\n            self.add(tree)\n            result = tree.bubble_insert(3, scale=S, pause_between_shift=False)\n            while result is not None:\n                anim, tree = result\n                self.play(anim, get_camera_anim(), run_time=1 if ii <= 3 else 0.7 if ii <= 5 else 0.4 if ii <= 7 else 0.25)\n                for mobject in self.mobjects:\n                    self.remove(mobject)\n                self.add(tree)\n                result = tree.bubble_insert(3, scale=S, pause_between_shift=False)"}]}
{"messages": [{"role": "user", "content": "Display an AB-tree structure with text elements and accompanying graphics, animating their appearance."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass TransparentInterlude(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        ab = ABTree([[[123]], [[111], [2345]], [['\\\\textit{most}'], ['\\\\textit{elegant}'], ['\\\\textit{search}'], ['\\\\textit{structure}']]], layer_buffer=0.2, node_buffer=0.3, add_leafs=False, is_interlude=True).scale(2.5)\n        the = Tex('\\\\sc The').scale(0.85)\n        a = Tex('\\\\sc (a,b)')\n        trees = Tex('\\\\sc Tree')\n        dash = Tex('-').scale(1.6).stretch_to_fit_height(Tex('-').get_height() * 2)\n        text = VGroup(the, a, dash, trees).scale(2.2)\n        for e in ab.edges_individually:\n            e.scale(1.4).set_stroke_width(6)\n        ab.edges_individually[-1].scale(0.001)\n        ab.edges_individually[-2].scale(0.001)\n        ab.edges_individually[-3].scale(0.001)\n        ab.edges_individually[-4].scale(0.001)\n        ab.node_by_index(2, 1)[0][0].shift(DOWN * 0.035)\n        ab.node_by_index(2, 0)[0].scale(0.9)\n        ab.node_by_index(2, 1)[0].scale(0.9)\n        ab.node_by_index(2, 2)[0].scale(0.9)\n        ab.node_by_index(2, 3)[0].scale(0.9)\n        bee = SVGMobject('assets/bee.svg').scale(0.9).move_to(ab.node_by_index(1, 0)[0]).rotate(PI / 15).shift(UP * 0.7 + LEFT * 0.9)\n        cache = SVGMobject('assets/cache_line.svg').scale(1.05).move_to(ab.node_by_index(1, 1)[0]).rotate(-PI / 20).shift(UP * 0.6 + RIGHT * 1.05)\n        cache[1].set_color(GREEN)\n        cache[2].set_color(GREEN)\n        ab.node_by_index(0, 0)[0].become(the.move_to(ab.node_by_index(0, 0)[0]))\n        ab.node_by_index(1, 0)[0].become(a.move_to(ab.node_by_index(1, 0)[0]))\n        ab.node_by_index(1, 1)[0].become(trees.move_to(ab.node_by_index(1, 1)[0]))\n        dash.scale(1.15)\n        dash.move_to(VGroup(Dot().next_to(ab.node_by_index(1, 0), RIGHT), Dot().next_to(ab.node_by_index(1, 1), LEFT))).shift(LEFT * 0.115)\n        x = VGroup(Tex('\\\\textit{most}'), Tex('\\\\textit{elegant}')).arrange(DOWN).next_to(the, LEFT, buff=1.5).scale(0.8)\n        y = VGroup(Tex('\\\\textit{search}'), Tex('\\\\textit{structure}')).arrange(DOWN).next_to(the, RIGHT, buff=1.5).scale(0.8)\n        self.add(ab.skeleton)\n        self.camera.frame.scale(0.8)\n        text.set_z_index(10000)\n        self.play(AnimationGroup(Write(text, run_time=1.5), AnimationGroup(AnimationGroup(FadeIn(ab.node_by_index(2, 0)[0]), FadeIn(ab.node_by_index(2, 1)[0]), FadeIn(ab.node_by_index(2, 2)[0]), FadeIn(ab.node_by_index(2, 3)[0]), lag_ratio=0.35), AnimationGroup(FadeIn(bee, shift=UP * 0.5 + LEFT * 0.25), FadeIn(cache, shift=UP * 0.3 + RIGHT * 0.25)), lag_ratio=0.5), lag_ratio=0.7))"}]}
{"messages": [{"role": "user", "content": "Display a stylized AB tree with text and images replacing some nodes, representing \"The (a,b) Tree\"."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass Interlude(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        ab = ABTree([[[123]], [[111], [2345]], [['\\\\textit{most}'], ['\\\\textit{elegant}'], ['\\\\textit{search}'], ['\\\\textit{structure}']]], layer_buffer=0.2, node_buffer=0.3, add_leafs=False, is_interlude=True).scale(2.5)\n        the = Tex('\\\\sc The').scale(0.85)\n        a = Tex('\\\\sc (a,b)')\n        trees = Tex('\\\\sc Tree')\n        dash = Tex('-').scale(1.6).stretch_to_fit_height(Tex('-').get_height() * 2)\n        text = VGroup(the, a, dash, trees).scale(2.2)\n        for e in ab.edges_individually:\n            e.scale(1.4).set_stroke_width(6)\n        ab.edges_individually[-1].scale(0.001)\n        ab.edges_individually[-2].scale(0.001)\n        ab.edges_individually[-3].scale(0.001)\n        ab.edges_individually[-4].scale(0.001)\n        ab.node_by_index(2, 1)[0][0].shift(DOWN * 0.035)\n        ab.node_by_index(2, 0)[0].scale(0.9)\n        ab.node_by_index(2, 1)[0].scale(0.9)\n        ab.node_by_index(2, 2)[0].scale(0.9)\n        ab.node_by_index(2, 3)[0].scale(0.9)\n        bee = SVGMobject('assets/bee.svg').scale(0.9).move_to(ab.node_by_index(1, 0)[0]).rotate(PI / 15).shift(UP * 0.7 + LEFT * 0.9)\n        cache = SVGMobject('assets/cache_line.svg').scale(1.05).move_to(ab.node_by_index(1, 1)[0]).rotate(-PI / 20).shift(UP * 0.6 + RIGHT * 1.05)\n        cache[1].set_color(GREEN)\n        cache[2].set_color(GREEN)\n        ab.node_by_index(0, 0)[0].become(the.move_to(ab.node_by_index(0, 0)[0]))\n        ab.node_by_index(1, 0)[0].become(a.move_to(ab.node_by_index(1, 0)[0]))\n        ab.node_by_index(1, 1)[0].become(trees.move_to(ab.node_by_index(1, 1)[0]))\n        dash.scale(1.15)\n        dash.move_to(VGroup(Dot().next_to(ab.node_by_index(1, 0), RIGHT), Dot().next_to(ab.node_by_index(1, 1), LEFT))).shift(LEFT * 0.115)\n        x = VGroup(Tex('\\\\textit{most}'), Tex('\\\\textit{elegant}')).arrange(DOWN).next_to(the, LEFT, buff=1.5).scale(0.8)\n        y = VGroup(Tex('\\\\textit{search}'), Tex('\\\\textit{structure}')).arrange(DOWN).next_to(the, RIGHT, buff=1.5).scale(0.8)\n        self.add(ab.skeleton)\n        self.camera.frame.scale(0.8)\n        text.set_z_index(10000)\n        self.play(AnimationGroup(Write(text, run_time=1.5), AnimationGroup(AnimationGroup(FadeIn(ab.node_by_index(2, 0)[0]), FadeIn(ab.node_by_index(2, 1)[0]), FadeIn(ab.node_by_index(2, 2)[0]), FadeIn(ab.node_by_index(2, 3)[0]), lag_ratio=0.35), AnimationGroup(FadeIn(bee, shift=UP * 0.5 + LEFT * 0.25), FadeIn(cache, shift=UP * 0.3 + RIGHT * 0.25)), lag_ratio=0.5), lag_ratio=0.7))"}]}
{"messages": [{"role": "user", "content": "Animate a search operation within an animated B-tree structure, highlighting the search path."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass Search(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        ab_tree = ABTree([[[1, 3]], [[0], [2], [4, 5, 6]]], fill_background=False)\n        ab = VGroup(Tex('\\\\underline{\\\\textit{Search}}').scale(1.25), ab_tree).arrange(DOWN, buff=1).scale(S)\n        self.play(AnimationGroup(Write(ab[0]), Write(ab_tree), lag_ratio=0.5))\n        bgs = ab_tree.search_but_like_animate(5, self, scale=S)\n        self.play(FadeOut(VGroup(*bgs), run_time=0.1))\n        bgs = ab_tree.search_but_like_animate(7, self, scale=S, speedup=2)\n        self.play(FadeOut(VGroup(*bgs), run_time=0.1))"}]}
{"messages": [{"role": "user", "content": "Animate a pause icon moving across a line from left to right."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass TransparentPause(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        line = Line(3 * LEFT, 3 * RIGHT, stroke_width=8).shift(UP * 0).set_color(WHITE)\n        d1 = Dot().move_to(line.get_left())\n        d2 = Dot().move_to(line.get_right())\n        pause = SVGMobject('assets/pause.svg').move_to(line.get_left()).scale(0.3).set_z_index(1000)\n        self.add(line, pause, d1, d2)\n        self.play(pause.animate(rate_func=linear, run_time=5).move_to(line.get_right()))"}]}
{"messages": [{"role": "user", "content": "Visualize the insertion and balancing process of an Abstract Binary Tree with animated data insertions and node highlighting."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass Insertion(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        ab_tree = ABTree([[[1, 3]], [[0], [2], [4, 5, 6]]], fill_background=False)\n        ab = VGroup(Tex('\\\\underline{\\\\textit{Search}}').scale(1.25), ab_tree).arrange(DOWN, buff=1).scale(S)\n        ins = Tex('\\\\underline{\\\\textit{Insertion}}').scale(1.25).scale(S).move_to(ab[0])\n        self.add(ab)\n        self.play(FadeOut(ab[0], shift=LEFT * 3.7), FadeIn(ins, shift=LEFT * 3.7))\n        target, qs, bgs = ab_tree.search_but_like_animate(7, self, scale=S, speedup=5, no_cleanup=True)\n\n        def darken_our_tree(tree):\n            tree.subtree_by_index(1, 0).set_color(DARK_COLOR)\n            tree.subtree_by_index(1, 1).set_color(DARK_COLOR)\n            tree.node_by_index(0, 0).set_color(DARK_COLOR)\n            tree.edges_by_node_index(0, 0).set_color(DARK_COLOR)\n        anim, tree = ab_tree.insert(7, scale=S, transform_instead=target, tree_transform_function=darken_our_tree)\n        self.play(Succession(AnimationGroup(FadeOut(qs), anim, lag_ratio=0.5), FadeOut(VGroup(*bgs))))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(tree, ins)\n        self.play(tree.animate.set_color(WHITE))\n        self.play(tree.node_by_index(1, 2)[1].animate.set_stroke_color(RED), tree.node_by_index(1, 2)[0].animate.set_color(RED), tree.edges_by_node_index(1, 2).animate.set_color(RED))\n        anim, tree = tree.bubble_insert(4, scale=S, pause_between_shift=True)\n        self.play(anim)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(tree, ins)\n        self.play(tree.node_by_index(0, 0).animate.set_color(BLUE), tree.edges_by_node_index(0, 0).animate.set_color(BLUE))\n        self.play(tree.node_by_index(0, 0).animate.set_color(WHITE), tree.edges_by_node_index(0, 0).animate.set_color(WHITE))\n        for i in [8, 9]:\n            target = Tex(f'${i}$').next_to(tree.node_by_index(0, 0), UP).scale(1.2).set_z_index(10)\n            self.play(FadeIn(target, shift=UP * 0.1))\n            anim, tree = tree.insert(i, scale=S, transform_instead=target)\n            self.play(anim)\n            for mobject in self.mobjects:\n                self.remove(mobject)\n            self.add(tree, ins)\n        self.play(tree.node_by_index(1, 3).animate.set_color(RED), tree.edges_by_node_index(1, 3).animate.set_color(RED))\n        anim, tree = tree.bubble_insert(4, scale=S)\n        self.play(anim)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(tree, ins)\n        self.play(tree.node_by_index(0, 0).animate.set_color(RED), tree.edges_by_node_index(0, 0).animate.set_color(RED))\n        anim, tree = tree.bubble_insert(4, scale=S)\n        new_ins = ins.copy().shift(UP)\n        self.play(anim, self.camera.frame.animate.move_to(VGroup(new_ins, tree)).set_height(VGroup(new_ins, tree).get_height() * 1.4), Transform(ins, new_ins))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(tree, ins)\n        self.camera.frame.save_state()\n        tree.save_state()\n        g = VGroup(tree.subtree_by_index(2, 3), tree.subtree_by_index(2, 4))\n        eq = Tex('$$\\\\lfloor (b+1)/2 \\\\rfloor \\\\ge  \\\\lfloor 2a  / 2 \\\\rfloor = a$$').next_to(g, DOWN, buff=0.75)\n        g.add(eq)\n        self.play(self.camera.frame.animate.move_to(g).scale(0.65), tree.subtree_by_index(1, 0).animate.set_color(DARK_COLOR), tree.node_by_index(0, 0).animate.set_color(DARK_COLOR), tree.edges_by_node_index(0, 0).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 2).animate.set_color(DARK_COLOR), tree.node_by_index(1, 1).animate.set_color(DARK_COLOR), tree.edges_by_node_index(1, 1).animate.set_color(DARK_COLOR), ins.animate.set_color(DARK_COLOR))\n        self.play(Write(eq[0][:9]))\n        ba = Tex('$$\\\\overbrace{b \\\\ge 2a - 1}^{\\\\phantom{.}}$$').next_to(eq[0][9], DOWN, buff=0.05).scale(0.8).set_color(GRAY)\n        self.play(FadeIn(eq[0][9]), FadeIn(ba))\n        self.play(Write(eq[0][10:]))\n        g = VGroup(tree.node_by_index(0, 0), tree.node_by_index(1, 0), tree.node_by_index(1, 1))\n        a1 = Arrow(ORIGIN, RIGHT * 1.25).next_to(tree.node_by_index(0, 0), LEFT, buff=0.65)\n        text = Tex('2 children').next_to(a1, LEFT)\n        self.play(FadeOut(eq), FadeOut(ba), self.camera.frame.animate.move_to(g), tree.subtree_by_index(2, 0).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 1).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 2).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 3).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 4).animate.set_color(DARK_COLOR), tree.edges_by_node_index(1, 0).animate.set_color(DARK_COLOR), tree.edges_by_node_index(1, 1).animate.set_color(DARK_COLOR), tree.edges_by_node_index(0, 0).animate.set_color(WHITE), tree.node_by_index(0, 0).animate.set_color(WHITE), tree.node_by_index(1, 0).animate.set_color(WHITE), tree.node_by_index(1, 1).animate.set_color(WHITE), ins.animate.set_color(DARK_COLOR))\n        self.play(AnimationGroup(Write(text, run_time=1), FadeIn(a1), lag_ratio=0.5))\n        self.play(FadeOut(a1), FadeOut(text), self.camera.frame.animate.restore(), tree.animate.restore(), ins.animate.set_color(WHITE))"}]}
{"messages": [{"role": "user", "content": "Animate the search and insertion operations of an (a,b)-tree, followed by a deletion operation and its associated node merging or key stealing logic."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass Deletion(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        ab_text = Tex('\\\\underline{$(a,b)$-tree}').scale(1.25).scale(S)\n        self.next_section(skip_animations=True)\n        ab_tree = ABTree([[[1, 3]], [[0], [2], [4, 5, 6]]], fill_background=False)\n        ab = VGroup(Tex('\\\\underline{\\\\textit{Search}}').scale(1.25), ab_tree).arrange(DOWN, buff=1).scale(S)\n        ins = Tex('\\\\underline{\\\\textit{Insertion}}').scale(1.25).scale(S).move_to(ab[0])\n        self.add(ab)\n        self.play(FadeOut(ab[0], shift=LEFT * 3.7), FadeIn(ins, shift=LEFT * 3.7))\n        target, qs, bgs = ab_tree.search_but_like_animate(7, self, scale=S, speedup=5, no_cleanup=True)\n\n        def darken_our_tree(tree):\n            tree.subtree_by_index(1, 0).set_color(DARK_COLOR)\n            tree.subtree_by_index(1, 1).set_color(DARK_COLOR)\n            tree.node_by_index(0, 0).set_color(DARK_COLOR)\n            tree.edges_by_node_index(0, 0).set_color(DARK_COLOR)\n        anim, tree = ab_tree.insert(7, scale=S, transform_instead=target, tree_transform_function=darken_our_tree)\n        self.play(FadeOut(VGroup(*bgs)), AnimationGroup(FadeOut(qs), anim, lag_ratio=0.5))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(tree, ins)\n        self.play(tree.animate.set_color(WHITE))\n        self.play(tree.node_by_index(1, 2)[1].animate.set_stroke_color(RED), tree.node_by_index(1, 2)[0].animate.set_color(RED), tree.edges_by_node_index(1, 2).animate.set_color(RED))\n        anim, tree = tree.bubble_insert(4, scale=S, pause_between_shift=True)\n        self.play(anim)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(tree, ins)\n        self.play(tree.node_by_index(0, 0).animate.set_color(BLUE), tree.edges_by_node_index(0, 0).animate.set_color(BLUE))\n        self.play(tree.node_by_index(0, 0).animate.set_color(WHITE), tree.edges_by_node_index(0, 0).animate.set_color(WHITE))\n        for i in [8, 9]:\n            target = Tex(f'${i}$').next_to(tree.node_by_index(0, 0), UP).scale(1.2).set_z_index(10)\n            self.play(FadeIn(target, shift=UP * 0.1))\n            anim, tree = tree.insert(i, scale=S, transform_instead=target)\n            self.play(anim)\n            for mobject in self.mobjects:\n                self.remove(mobject)\n            self.add(tree, ins)\n        self.play(tree.node_by_index(1, 3).animate.set_color(RED), tree.edges_by_node_index(1, 3).animate.set_color(RED))\n        anim, tree = tree.bubble_insert(4, scale=S)\n        self.play(anim)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(tree, ins)\n        self.play(tree.node_by_index(0, 0).animate.set_color(RED), tree.edges_by_node_index(0, 0).animate.set_color(RED))\n        anim, tree = tree.bubble_insert(4, scale=S)\n        new_ins = ins.copy().shift(UP)\n        self.play(anim, self.camera.frame.animate.move_to(VGroup(new_ins, tree)).set_height(VGroup(new_ins, tree).get_height() * 1.4), Transform(ins, new_ins))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(tree, ins)\n        self.camera.frame.save_state()\n        tree.save_state()\n        g = VGroup(tree.subtree_by_index(2, 3), tree.subtree_by_index(2, 4))\n        eq = Tex('$$\\\\lfloor (b+1)/2 \\\\rfloor \\\\ge  \\\\lfloor 2a  / 2 \\\\rfloor = a$$').next_to(g, DOWN, buff=0.75)\n        g.add(eq)\n        self.play(self.camera.frame.animate.move_to(g).scale(0.65), tree.subtree_by_index(1, 0).animate.set_color(DARK_COLOR), tree.node_by_index(0, 0).animate.set_color(DARK_COLOR), tree.edges_by_node_index(0, 0).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 2).animate.set_color(DARK_COLOR), tree.node_by_index(1, 1).animate.set_color(DARK_COLOR), tree.edges_by_node_index(1, 1).animate.set_color(DARK_COLOR), ins.animate.set_color(DARK_COLOR))\n        self.play(Write(eq[0][:9]))\n        ba = Tex('$$\\\\overbrace{b \\\\ge 2a - 1}^{\\\\phantom{.}}$$').next_to(eq[0][9], DOWN, buff=0.05).scale(0.8).set_color(GRAY)\n        self.play(FadeIn(eq[0][9]), FadeIn(ba))\n        self.play(Write(eq[0][10:]))\n        g = VGroup(tree.node_by_index(0, 0), tree.node_by_index(1, 0), tree.node_by_index(1, 1))\n        a1 = Arrow(ORIGIN, RIGHT * 1.25).next_to(tree.node_by_index(0, 0), LEFT, buff=0.65)\n        text = Tex('2 children').next_to(a1, LEFT)\n        self.play(FadeOut(eq), FadeOut(ba), self.camera.frame.animate.move_to(g), tree.subtree_by_index(2, 0).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 1).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 2).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 3).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 4).animate.set_color(DARK_COLOR), tree.edges_by_node_index(1, 0).animate.set_color(DARK_COLOR), tree.edges_by_node_index(1, 1).animate.set_color(DARK_COLOR), tree.edges_by_node_index(0, 0).animate.set_color(WHITE), tree.node_by_index(0, 0).animate.set_color(WHITE), tree.node_by_index(1, 0).animate.set_color(WHITE), tree.node_by_index(1, 1).animate.set_color(WHITE), ins.animate.set_color(DARK_COLOR))\n        self.play(AnimationGroup(Write(text, run_time=1), FadeIn(a1), lag_ratio=0.5))\n        self.play(FadeOut(a1), FadeOut(text), self.camera.frame.animate.restore(), tree.animate.restore(), ins.animate.set_color(WHITE))\n        self.next_section()\n        dl = Tex('\\\\underline{\\\\textit{Deletion}}').scale(1.25).scale(S).move_to(ins)\n        self.play(FadeOut(ins, shift=LEFT * 4.2), FadeIn(dl, shift=LEFT * 4.2))\n        ab_tree = ABTree([[[3]], [[1], [5, 7]], [[0], [2], [4], [6], [8, 9]]], fill_background=False).scale(S).move_to(tree)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(ab_tree, dl)\n        target, qs, bgs = ab_tree.search_but_like_animate(9, self, scale=S, speedup=5, no_cleanup=True)\n\n        def darken_our_tree(tree):\n            tree.subtree_by_index(1, 0).set_color(DARK_COLOR)\n            tree.subtree_by_index(2, 2).set_color(DARK_COLOR)\n            tree.subtree_by_index(2, 3).set_color(DARK_COLOR)\n            tree.node_by_index(0, 0).set_color(DARK_COLOR)\n            tree.node_by_index(1, 1).set_color(DARK_COLOR)\n            tree.edges_by_node_index(0, 0).set_color(DARK_COLOR)\n            tree.edges_by_node_index(1, 1).set_color(DARK_COLOR)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(dl)\n        anim, tree = ab_tree.delete(9, scale=S, tree_transform_function=darken_our_tree)\n        self.play(FadeOut(VGroup(*bgs)), FadeOut(target), FadeOut(qs), anim)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(dl, tree)\n        self.play(tree.animate.set_color(WHITE))\n        target = Tex('$3$').next_to(tree.node_by_index(0, 0), UP).scale(0.8 * S)\n        self.play(FadeIn(target, shift=UP * 0.1), target.animate.set_color(GREEN), tree.node_by_index(0, 0)[0].animate.set_color(GREEN))\n        self.play(FadeOut(target), tree.node_by_index(0, 0)[0].animate.set_opacity(0))\n        self.play(tree.edges_by_node_index(2, 0).animate.set_color(DARK_COLOR), tree.edges_by_node_index(2, 3).animate.set_color(DARK_COLOR), tree.edges_by_node_index(2, 4).animate.set_color(DARK_COLOR), tree.edges_by_node_index(2, 1).animate.set_color(DARK_COLOR), tree.edges_by_node_index(2, 2).animate.set_color(DARK_COLOR), tree.node_by_index(1, 0).animate.set_color(DARK_COLOR), tree.node_by_index(1, 1).animate.set_color(DARK_COLOR), tree.edges_by_node_index(0, 0).animate.set_color(DARK_COLOR), tree.edges_by_node_index(1, 0).animate.set_color(DARK_COLOR), tree.edges_by_node_index(1, 1).animate.set_color(DARK_COLOR), tree.node_by_index(3, 0).animate.set_color(DARK_COLOR), tree.node_by_index(3, 1).animate.set_color(DARK_COLOR), tree.node_by_index(3, 2).animate.set_color(DARK_COLOR), tree.node_by_index(3, 3).animate.set_color(DARK_COLOR), tree.node_by_index(3, 4).animate.set_color(DARK_COLOR), tree.node_by_index(3, 5).animate.set_color(DARK_COLOR), tree.node_by_index(3, 6).animate.set_color(DARK_COLOR), tree.node_by_index(3, 7).animate.set_color(DARK_COLOR), tree.node_by_index(3, 8).animate.set_color(DARK_COLOR), tree.node_by_index(3, 9).animate.set_color(DARK_COLOR))\n        self.play(tree.subtree_by_index(2, 0).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 3).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 4).animate.set_color(DARK_COLOR), tree.node_by_index(2, 1).animate.set_color(ORANGE), tree.node_by_index(2, 2).animate.set_color(ORANGE))\n        self.play(tree.node_by_index(2, 1).animate.set_color(DARK_COLOR))\n        self.play(tree.node_by_index(1, 1).animate.set_color(WHITE), tree.edges_by_node_index(1, 1).animate.set_color(WHITE), tree.edges_by_node_index(0, 0)[1].animate.set_color(WHITE), tree.subtree_by_index(2, 3).animate.set_color(WHITE), tree.subtree_by_index(2, 4).animate.set_color(WHITE), tree.node_by_index(3, 4).animate.set_color(WHITE), tree.node_by_index(3, 5).animate.set_color(WHITE), tree.edges_by_node_index(2, 2).animate.set_color(WHITE))\n        self.play(tree.node_by_index(1, 1)[0].animate.set_color(DARK_COLOR), tree.node_by_index(2, 3)[0].animate.set_color(DARK_COLOR), tree.node_by_index(2, 4)[0].animate.set_color(DARK_COLOR))\n        new_tree = ABTree([[[4]], [[1], [5, 7]], [[0], [2], [3], [6], [8]]], fill_background=False).scale(S).move_to(tree)\n        new_tree.subtree_by_index(1, 0).set_color(DARK_COLOR)\n        new_tree.edges_by_node_index(0, 0)[0].set_color(DARK_COLOR)\n        new_tree.node_by_index(2, 2)[0].set_color(ORANGE)\n        new_tree.node_by_index(2, 2)[1].set_color(ORANGE)\n        new_tree.node_by_index(0, 0)[0].set_color(DARK_GRAY)\n        new_tree.node_by_index(1, 1)[0].set_color(DARK_COLOR)\n        new_tree.node_by_index(2, 3)[0].set_color(DARK_COLOR)\n        new_tree.node_by_index(2, 4)[0].set_color(DARK_COLOR)\n        tree.node_by_index(0, 0)[0].set_color(DARK_GRAY)\n        tree.node_by_index(1, 1)[0].set_color(DARK_COLOR)\n        tree.node_by_index(2, 3)[0].set_color(DARK_COLOR)\n        tree.node_by_index(2, 4)[0].set_color(DARK_COLOR)\n        self.play(Transform(tree, new_tree), tree.node_by_index(2, 2)[0].animate.move_to(tree.node_by_index(0, 0)[0]), tree.node_by_index(0, 0)[0].animate.set_opacity(0))\n        self.play(tree.animate.set_color(WHITE))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        tree = ABTree([[[4]], [[1], [5, 7]], [[0], [2], [3], [6], [8]]], fill_background=False).scale(S).move_to(tree)\n        wow = tree.node_by_index(0, 0)[0].copy().set_opacity(1).move_to(tree.node_by_index(0, 0)[0])\n        tree.node_by_index(2, 2)[0].set_opacity(0)\n\n        def idk(tree):\n            tree.node_by_index(0, 0)[0].become(wow)\n            tree.node_by_index(2, 2)[0].set_opacity(0)\n        self.add(dl)\n        anim, tree = tree.delete(((2, 2), 3), scale=S, tree_transform_function=idk)\n        self.play(anim)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        tree = ABTree([[[4]], [[1], [5, 7]], [[0], [2], [], [6], [8]]], fill_background=False).scale(S).move_to(tree)\n        self.add(tree, dl)\n        self.play(tree.node_by_index(2, 2).animate.set_color(RED), tree.edges_by_node_index(2, 2).animate.set_color(RED))\n        self.camera.frame.save_state()\n        g = VGroup(tree.subtree_by_index(1, 1))\n        a = VGroup(Tex('\\\\textbf{a)} merge nodes'), Tex('\\\\textbf{b)} steal a key')).arrange(DOWN)\n        a[1].align_to(a[0], LEFT)\n        a.next_to(g, RIGHT, buff=0.75)\n        self.play(tree.subtree_by_index(1, 0).animate.set_color(DARK_COLOR), tree.node_by_index(0, 0).animate.set_color(DARK_COLOR), tree.edges_by_node_index(0, 0).animate.set_color(DARK_COLOR), self.camera.frame.animate.move_to(g).scale(0.65))\n        self.play(tree.node_by_index(2, 3).animate.set_color(BLUE))\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(VGroup(g, a)), FadeIn(a[0]), lag_ratio=0.5))\n        self.play(FadeIn(a[1]))\n        self.play(tree.edges_by_node_index(2, 3).animate.set_color(BLUE))\n        self.play(tree.subtree_by_index(1, 1).animate.set_color(WHITE), a[1].animate.set_color(DARK_COLOR))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(dl, a)\n        self.add(tree.node_by_index(0, 0))\n\n        def f(tree):\n            (tree.subtree_by_index(1, 0).set_color(DARK_COLOR),)\n            (tree.node_by_index(0, 0).set_color(DARK_COLOR),)\n            (tree.edges_by_node_index(0, 0).set_color(DARK_COLOR),)\n        anim, new_tree = tree.bubble_delete(2, scale=S, tree_transform_function=f)\n        self.add(dl)\n        self.play(AnimationGroup(anim, run_time=1.5), AnimationGroup(Wait(1.5), AnimationGroup(Transform(tree.subtree_by_index(1, 0), new_tree.subtree_by_index(1, 0), run_time=1), Transform(tree.edges_by_node_index(0, 0), new_tree.edges_by_node_index(0, 0), run_time=1)), lag_ratio=0.4))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        tree = ABTree([[[4]], [[1], [7]], [[0], [2], [5, 6], [8]]], fill_background=False).scale(S)\n        align_object_by_coords(tree, tree.node_by_index(0, 0), new_tree.node_by_index(0, 0))\n        self.add(dl, tree, a)\n        f(tree)\n        self.play(tree.node_by_index(1, 1).animate.set_color(BLUE), tree.edges_by_node_index(1, 1).animate.set_color(BLUE))\n        self.camera.frame.save_state()\n        self.play(tree.node_by_index(1, 1).animate.set_color(WHITE), tree.edges_by_node_index(1, 1).animate.set_color(WHITE))\n        b1 = BraceBetweenPoints(Dot().align_to(tree.node_by_index(3, 4), LEFT + DOWN).shift(LEFT * 0.1).get_center(), Dot().align_to(tree.node_by_index(3, 4), RIGHT + DOWN).shift(RIGHT * 0.1).get_center(), DOWN)\n        b1.stretch_to_fit_height(b1.get_height() / 1.5)\n        b2 = BraceBetweenPoints(Dot().align_to(tree.node_by_index(3, 5), LEFT + DOWN).shift(LEFT * 0.1).get_center(), Dot().align_to(tree.node_by_index(3, 6), RIGHT + DOWN).shift(RIGHT * 0.1).get_center(), DOWN)\n        b2.stretch_to_fit_height(b2.get_height() / 1.5)\n        ap1 = Tex('$$a - 1$$').scale(0.6).next_to(b1, DOWN, buff=0.03)\n        ap2 = Tex('$$a$$').scale(0.6).next_to(b2, DOWN, buff=0.03).align_to(ap1, DOWN)\n        self.play(self.camera.frame.animate.move_to(tree.subtree_by_index(2, 2)).scale(0.65).shift(DOWN * 0.5), tree.edges_by_node_index(1, 1).animate.set_color(DARK_COLOR), tree.subtree_by_index(2, 3).animate.set_color(DARK_COLOR))\n        self.play(AnimationGroup(AnimationGroup(FadeIn(b1, shift=DOWN * 0.25), tree.edges_by_node_index(2, 2)[0].animate.set_color(RED), tree.node_by_index(3, 4).animate.set_color(RED)), FadeIn(ap1), lag_ratio=0.5), run_time=1)\n        self.play(AnimationGroup(AnimationGroup(FadeIn(b2, shift=DOWN * 0.25), tree.edges_by_node_index(2, 2)[1].animate.set_color(BLUE), tree.edges_by_node_index(2, 2)[2].animate.set_color(BLUE), tree.node_by_index(3, 5).animate.set_color(BLUE), tree.node_by_index(3, 6).animate.set_color(BLUE)), FadeIn(ap2), lag_ratio=0.5), run_time=1)\n        eq = Tex('$$a - 1 + a = 2a - 1 \\\\le b$$').move_to(tree.subtree_by_index(2, 2)).align_to(VGroup(ap2, ap1), UP).scale(0.8)\n        self.play(FadeOut(b1), FadeOut(b2), AnimationGroup(AnimationGroup(Transform(ap1[0][0], eq[0][0]), Transform(ap1[0][1], eq[0][1]), Transform(ap1[0][2], eq[0][2]), Transform(ap2, eq[0][4])), FadeIn(eq[0][3]), lag_ratio=0.5))\n        self.play(Write(eq[0][5:10]))\n        self.play(FadeIn(eq[0][10:]))\n        a[0].set_color(DARK_COLOR)\n        a[1].set_color(WHITE)\n        self.play(self.camera.frame.animate.restore(), FadeOut(eq), tree.edges_by_node_index(1, 1).animate.set_color(WHITE), tree.subtree_by_index(2, 2).animate.set_color(WHITE), tree.subtree_by_index(2, 3).animate.set_color(WHITE), FadeOut(ap1[0][0]), FadeOut(ap1[0][1]), FadeOut(ap1[0][2]), FadeOut(ap2))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(dl, a)\n        anim, tree = tree.delete(8, scale=S, tree_transform_function=f)\n        self.play(anim)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        tree = ABTree([[[4]], [[1], [7]], [[0], [2], [5, 6], []]], fill_background=False).scale(S).move_to(tree)\n        tree_to_transform = ABTree([[[4]], [[1], [6]], [[0], [2], [5], [7]]], fill_background=False).scale(S).move_to(tree)\n        self.add(tree, dl, a)\n        f(tree)\n        f(tree_to_transform)\n        self.play(tree.node_by_index(2, 3).animate.set_color(RED), tree.edges_by_node_index(2, 3).animate.set_color(RED))\n        self.play(tree.node_by_index(2, 2).animate.set_color(BLUE), tree.edges_by_node_index(2, 2).animate.set_color(BLUE))\n        self.play(Transform(tree.subtree_by_index(1, 0), tree_to_transform.subtree_by_index(1, 0)), Transform(tree.edges_by_node_index(0, 0), tree_to_transform.edges_by_node_index(0, 0)), Transform(tree.node_by_index(0, 0), tree_to_transform.node_by_index(0, 0)), Transform(tree.node_by_index(1, 1)[1], tree_to_transform.node_by_index(1, 1)[1]), Transform(tree.node_by_index(1, 1)[0][0], tree_to_transform.node_by_index(2, 3)[0][0]), Transform(tree.node_by_index(2, 2)[0][1], tree_to_transform.node_by_index(1, 1)[0][0]), Transform(tree.node_by_index(2, 2)[0][0], tree_to_transform.node_by_index(2, 2)[0][0]), Transform(tree.node_by_index(2, 2)[1], tree_to_transform.node_by_index(2, 2)[1]), Transform(tree.node_by_index(3, 4), tree_to_transform.node_by_index(3, 4)), Transform(tree.node_by_index(3, 5), tree_to_transform.node_by_index(3, 5)), Transform(tree.node_by_index(3, 6), tree_to_transform.node_by_index(3, 6)), Transform(tree.node_by_index(3, 7), tree_to_transform.node_by_index(3, 7)), Transform(tree.edges_by_node_index(1, 1), tree_to_transform.edges_by_node_index(1, 1)), Transform(tree.edges_by_node_index(2, 2)[0], tree_to_transform.edges_by_node_index(2, 2)[0]), Transform(tree.edges_by_node_index(2, 2)[1], tree_to_transform.edges_by_node_index(2, 2)[1]), Transform(tree.edges_by_node_index(2, 2)[2], tree_to_transform.edges_by_node_index(2, 3)[0]), Transform(tree.edges_by_node_index(2, 3)[0], tree_to_transform.edges_by_node_index(2, 3)[1]), Transform(tree.node_by_index(2, 3)[1], tree_to_transform.node_by_index(2, 3)[1]), run_time=1.5)\n        ab_tree_both = ABTree([[[4]], [[1], [6, 8]], [[0], [2], [5], [], [9, 10]]], fill_background=False).scale(S * 0.75).move_to(tree).align_to(tree, RIGHT).align_to(tree, DOWN).shift(DOWN * 7.8)\n        ab_tree_both.subtree_by_index(1, 0).set_color(DARK_COLOR)\n        ab_tree_both.node_by_index(0, 0).set_color(DARK_COLOR)\n        ab_tree_both.edges_by_node_index(0, 0).set_color(DARK_COLOR)\n        ab_tree_both.node_by_index(2, 2).set_color(BLUE)\n        ab_tree_both.edges_by_node_index(2, 2).set_color(BLUE)\n        ab_tree_both.node_by_index(2, 3).set_color(RED)\n        ab_tree_both.edges_by_node_index(2, 3).set_color(RED)\n        ab_tree_both.node_by_index(2, 4).set_color(BLUE)\n        ab_tree_both.edges_by_node_index(2, 4).set_color(BLUE)\n        self.add(ab_tree_both)\n        ab_tree_to_transform = ABTree([[[4]], [[1], [6, 9]], [[0], [2], [5], [8], [10]]], fill_background=False).scale(S * 0.75).move_to(ab_tree_both).align_to(ab_tree_both, RIGHT).align_to(ab_tree_both, DOWN)\n        ab_tree_to_transform.subtree_by_index(1, 0).set_color(DARK_COLOR)\n        ab_tree_to_transform.node_by_index(0, 0).set_color(DARK_COLOR)\n        ab_tree_to_transform.edges_by_node_index(0, 0).set_color(DARK_COLOR)\n        self.play(self.camera.frame.animate.shift(DOWN * 8), a[0].animate.shift(DOWN * 8).set_color(WHITE), a[1].animate.shift(DOWN * 8), run_time=1.5)\n        high = CreateHighlight(a[1])\n        self.play(a[0].animate.set_color(DARK_COLOR), ab_tree_both.subtree_by_index(2, 2).animate.set_color(WHITE), ab_tree_both.node_by_index(2, 4).animate.set_color(GREEN), ab_tree_both.edges_by_node_index(2, 4).animate.set_color(GREEN))\n        self.play(Transform(ab_tree_both.subtree_by_index(1, 0), ab_tree_to_transform.subtree_by_index(1, 0)), Transform(ab_tree_both.node_by_index(0, 0), ab_tree_to_transform.node_by_index(0, 0)), Transform(ab_tree_both.edges_by_node_index(0, 0), ab_tree_to_transform.edges_by_node_index(0, 0)), Transform(ab_tree_both.edges_by_node_index(1, 1), ab_tree_to_transform.edges_by_node_index(1, 1)), Transform(ab_tree_both.node_by_index(1, 1)[1], ab_tree_to_transform.node_by_index(1, 1)[1]), Transform(ab_tree_both.node_by_index(1, 1)[0][0], ab_tree_to_transform.node_by_index(1, 1)[0][0]), Transform(ab_tree_both.node_by_index(1, 1)[0][1], ab_tree_to_transform.node_by_index(2, 3)[0][0]), Transform(ab_tree_both.node_by_index(2, 3)[1], ab_tree_to_transform.node_by_index(2, 3)[1]), Transform(ab_tree_both.node_by_index(2, 4)[1], ab_tree_to_transform.node_by_index(2, 4)[1]), Transform(ab_tree_both.node_by_index(2, 4)[0][0], ab_tree_to_transform.node_by_index(1, 1)[0][1]), Transform(ab_tree_both.node_by_index(2, 4)[0][1], ab_tree_to_transform.node_by_index(2, 4)[0][0]), Transform(ab_tree_both.edges_by_node_index(2, 3)[0], ab_tree_to_transform.edges_by_node_index(2, 3)[0]), Transform(ab_tree_both.edges_by_node_index(2, 4)[0], ab_tree_to_transform.edges_by_node_index(2, 3)[1]), Transform(ab_tree_both.edges_by_node_index(2, 4)[1], ab_tree_to_transform.edges_by_node_index(2, 4)[0]), Transform(ab_tree_both.edges_by_node_index(2, 4)[2], ab_tree_to_transform.edges_by_node_index(2, 4)[1]), Transform(ab_tree_both.node_by_index(3, 7), ab_tree_to_transform.node_by_index(3, 7)), Transform(ab_tree_both.node_by_index(3, 8), ab_tree_to_transform.node_by_index(3, 8)), Transform(ab_tree_both.node_by_index(3, 9), ab_tree_to_transform.node_by_index(3, 9)), Transform(ab_tree_both.subtree_by_index(2, 2), ab_tree_to_transform.subtree_by_index(2, 2)))\n        tree.set_color(WHITE)\n        tc = tree.copy()\n        tree.move_to(self.camera.frame).align_to(tc, DOWN)\n        dl.align_to(dl.copy().move_to(tree), RIGHT)\n        self.remove(dl)\n        self.add(ab_text)\n        ab_text.move_to(dl).align_to(dl, DOWN)\n        self.play(self.camera.frame.animate.move_to(VGroup(tree, ab_text)).scale(1 / 0.65), FadeOut(a))\n        print(tree.get_center() - ab_text.get_center())\n        print(self.camera.frame.get_height())\n        print(tree.get_height())\n        print(ab_text.get_height())"}]}
{"messages": [{"role": "user", "content": "Visualize an (a,b)-tree and then transition to illustrating CPU cache lines and their associated data transfer with accompanying benchmark graphs and problem statements."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import shuffle, seed\nfrom math import sqrt\n\nclass SelectingAB(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        tree = ABTree([[[4]], [[1], [6]], [[0], [2], [5], [7]]], fill_background=False).set_height(4.781904820000001)\n        ab_text = Tex('\\\\underline{$(a,b)$-tree}').scale(1.25).scale(S).set_height(1.0112004875)\n        tree.shift(UP * -3.84538207)\n        self.camera.frame.set_height(9.0639165645).move_to(VGroup(tree, ab_text))\n        self.add(tree, ab_text)\n        self.wait()\n        q1 = Tex('?').move_to(ab_text[0][1]).scale(1.25 * S)\n        q2 = Tex('?').move_to(ab_text[0][3]).scale(1.25 * S).align_to(q1, DOWN)\n        two = Tex('2').move_to(ab_text[0][1]).scale(1.25 * S)\n        four = Tex('4').move_to(ab_text[0][3]).scale(1.25 * S).align_to(q1, DOWN)\n        self.play(self.camera.frame.animate.move_to(ab_text).scale(0.5), ReplacementTransform(ab_text[0][1], q1), ReplacementTransform(ab_text[0][3], q2), tree.animate.set_color(DARK_COLOR).shift(DOWN * 2))\n        q1.set_z_index(10)\n        q2.set_z_index(10)\n        ab_text.set_z_index(10)\n        self.remove(tree)\n        cpu = SVGMobject('assets/cpu.svg').next_to(ab_text, DOWN, buff=1).set_color(WHITE)\n        self.play(self.camera.frame.animate.move_to(VGroup(ab_text, cpu)).scale(1.25), FadeIn(cpu))\n        cache = SVGMobject('assets/cache_line.svg').next_to(ab_text, DOWN, buff=1).scale(1.25)\n        g = VGroup(cpu.copy(), cache).arrange(buff=1.5 / 2).move_to(cpu)\n        tree_to_steal_from = ABTree([[[2, 4]], [[1], [3], [5, 6, 7, 8]]], fill_background=False).scale(0.75)\n        self.play(AnimationGroup(Transform(cpu, g[0]), FadeIn(cache), lag_ratio=0.5))\n        cache.set_z_index(10)\n        self.camera.frame.save_state()\n        a = tree_to_steal_from.node_by_index(0, 0).next_to(cache, RIGHT, buff=0.5)\n        self.play(self.camera.frame.animate.move_to(cache).scale(0.75), cpu.animate.set_color(DARK_COLOR), q1.animate.set_color(DARK_COLOR), q2.animate.set_color(DARK_COLOR), ab_text.animate.set_color(DARK_COLOR), FadeIn(a))\n        self.play(a.animate.align_to(cache, LEFT).set_color(BLACK), cache[1].animate.set_color(GREEN))\n        a = tree_to_steal_from.node_by_index(1, 2).next_to(cache, RIGHT, buff=0.5)\n        self.play(FadeIn(a))\n        self.play(a.animate.align_to(cache, LEFT).set_color(BLACK), cache[2].animate.set_color(GREEN))\n        cls = VGroup(Tex('$64\\\\mathrm{B}$').next_to(cache[1], RIGHT, buff=0.1).scale(0.4), Tex('$64\\\\mathrm{B}$').next_to(cache[2], RIGHT, buff=0.1).scale(0.4), Tex('$64\\\\mathrm{B}$').next_to(cache[3], RIGHT, buff=0.1).scale(0.4), Tex('$64\\\\mathrm{B}$').next_to(cache[4], RIGHT, buff=0.1).scale(0.4), Tex('$64\\\\mathrm{B}$').next_to(cache[5], RIGHT, buff=0.1).scale(0.4), Tex('$64\\\\mathrm{B}$').next_to(cache[6], RIGHT, buff=0.1).scale(0.4))\n        self.play(FadeIn(cls, shift=RIGHT * 0.25, lag_ratio=0.03))\n        cls2 = VGroup(Tex('$8 \\\\cdot 64\\\\mathrm{b}$').scale(0.4).move_to(cls[0]).align_to(cls[0], LEFT), Tex('$8 \\\\cdot 64\\\\mathrm{b}$').scale(0.4).move_to(cls[1]).align_to(cls[1], LEFT), Tex('$8 \\\\cdot 64\\\\mathrm{b}$').scale(0.4).move_to(cls[2]).align_to(cls[2], LEFT), Tex('$8 \\\\cdot 64\\\\mathrm{b}$').scale(0.4).move_to(cls[3]).align_to(cls[3], LEFT), Tex('$8 \\\\cdot 64\\\\mathrm{b}$').scale(0.4).move_to(cls[4]).align_to(cls[4], LEFT), Tex('$8 \\\\cdot 64\\\\mathrm{b}$').scale(0.4).move_to(cls[5]).align_to(cls[5], LEFT))\n        self.play(AnimationGroup(AnimationGroup(*[FadeTransform(cls[i][0][0:], cls2[i][0][2:]) for i in range(len(cls))]), AnimationGroup(*[FadeIn(cls2[i][0][:2]) for i in range(len(cls))]), lag_ratio=0.25))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(ab_text, cache, cpu, cls2)\n        self.play(self.camera.frame.animate.restore(), cpu.animate.set_color(WHITE), q1.animate.set_color(WHITE), q2.animate.set_color(WHITE), ab_text.animate.set_color(WHITE))\n        self.remove(ab_text[0][1])\n        self.remove(ab_text[0][3])\n        self.play(Transform(q2, four))\n        self.play(Transform(q1, two))\n        ax, x_label, y_label, g1, g2, g3, texts, l1, l2, l3, ax_more_nums = get_benchmark_graph()\n        g = VGroup(ax, x_label, y_label, g1, g2, g3, texts, l1, l2, l3, ax_more_nums)\n        g.next_to(self.camera.frame, DOWN).scale(0.8)\n        cache[0].set_z_index(-1)\n        ab_text[0].remove(ab_text[0][1])\n        ab_text[0].remove(ab_text[0][2])\n        self.play(AnimationGroup(AnimationGroup(self.camera.frame.animate.move_to(g), FadeOut(cpu), FadeOut(cache[0]), FadeOut(cls2), FadeOut(ab_text), FadeOut(q1), FadeOut(q2)), AnimationGroup(FadeIn(ax), FadeIn(ax_more_nums[0][1]), FadeIn(x_label), FadeIn(y_label)), lag_ratio=0.25))\n        self.play(AnimationGroup(AnimationGroup(Create(g1), FadeIn(texts[0]), lag_ratio=0.25), AnimationGroup(Create(g2), FadeIn(texts[1]), lag_ratio=0.25), AnimationGroup(Create(g3), FadeIn(texts[2]), lag_ratio=0.25), lag_ratio=0.33))\n        self.camera.frame.save_state()\n        self.play(AnimationGroup(AnimationGroup(self.camera.frame.animate.move_to(VGroup(l1, l2, l3)).scale(0.5).shift(UP * 0.25)), AnimationGroup(FadeIn(l1, run_time=0.75), FadeIn(l2, run_time=0.75), FadeIn(l3, run_time=0.75), lag_ratio=0.1), lag_ratio=0.75))\n        self.play(self.camera.frame.animate.move_to(VGroup(ab_text, cpu)).scale(2), FadeOut(l1), FadeOut(l2), FadeOut(l3), FadeOut(g1), FadeOut(g2), FadeOut(g3), FadeOut(ax), FadeOut(ax_more_nums[0][1]), FadeOut(x_label), FadeOut(y_label), FadeIn(cpu), FadeIn(cache[0]), FadeIn(cls2), FadeIn(ab_text), FadeIn(q1), FadeIn(q2))\n        rect = get_fade_rect()\n        indx = rect.get_z_index() + 1\n        ab_text.set_z_index(rect.get_z_index() + 1)\n        q1.set_z_index(indx)\n        q2.set_z_index(indx)\n        t = Tex('Oversimplification!').move_to(VGroup(cpu, cache)).scale(1.45).set_z_index(indx)\n        problems = VGroup(Tex('\\\\begin{itemize} \\\\item implementation-specific details \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item usage determines runtime \\\\end{itemize}')).arrange(DOWN, buff=0.2).set_z_index(indx).scale(0.8)\n        problems[1].align_to(problems[0], LEFT)\n        self.play(AnimationGroup(FadeIn(rect), FadeIn(t), lag_ratio=0.5))\n        problems.move_to(t)\n        tmp = VGroup(t.copy(), problems).arrange(DOWN, buff=0.3).move_to(t)\n        self.play(AnimationGroup(Transform(t, tmp[0]), FadeIn(problems[0]), lag_ratio=0.5))\n        self.play(FadeIn(problems[1]))\n        paper = ImageMobject('assets/performance.png').set_height(self.camera.frame.get_height() * 0.85).next_to(self.camera.frame, RIGHT).shift(LEFT).set_z_index(indx)\n        self.play(FadeIn(paper), self.camera.frame.animate.move_to(Group(t, paper)).scale(1.3))"}]}
{"messages": [{"role": "user", "content": "Animate Theseus and the Minotaur navigating a maze, with the camera focusing on their movements, eventually leading to a table explaining movement validity."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass MinotaurMovement(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        with open('maze/mask.txt') as f:\n            contents = f.read().splitlines()\n        theseus = ImageMobject('assets/theseus-nobackground.png').set_height(0.8).set_z_index(100)\n        theseus_position = (22, 9)\n        theseus_text = Tex('Theseus').next_to(theseus, DOWN, buff=-0.08).scale(0.25)\n        theseus_miniature = ImageMobject('assets/theseus-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (theseus_position[0] + 0.5) + DOWN * (theseus_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.camera.frame.move_to(Group(theseus, theseus_text)).set_height(theseus.height * 2)\n        self.play(AnimationGroup(FadeIn(theseus), FadeIn(theseus_text, lag_ratio=0.1), lag_ratio=0.5))\n        minotaur = ImageMobject('assets/minotaur-nobackground.png').set_height(0.8).next_to(theseus, RIGHT, buff=0.3).set_z_index(100)\n        minotaur_position = (33, 9)\n        minotaur_text = Tex('Minotaur').next_to(minotaur, DOWN, buff=-0.08).scale(0.25)\n        minotaur_miniature = ImageMobject('assets/minotaur-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (minotaur_position[0] + 0.5) + DOWN * (minotaur_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        minotaur_miniature_fade = ImageMobject('assets/minotaur-nobackground-outline-fade.png').set_height(0.8).move_to(RIGHT * (minotaur_position[0] + 0.5) + DOWN * (minotaur_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(Group(theseus, minotaur)).scale(1.25), AnimationGroup(FadeIn(minotaur), FadeIn(minotaur_text, lag_ratio=0.1), lag_ratio=0.5), lag_ratio=0.25))\n        maze, maze_dict = maze_to_vgroup(contents)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(theseus_text), FadeOut(minotaur_text)), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)).set_height(maze.height * 0.65), FadeTransform(theseus, theseus_miniature), FadeTransform(minotaur, minotaur_miniature)), AnimationGroup(FadeIn(maze)), lag_ratio=0.5, run_time=2))\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2))\n        for i in range(1):\n            self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(LEFT), minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2), theseus_miniature.animate.shift(LEFT))\n        self.next_section()\n        minotaur_miniature.shift(LEFT * 2)\n        theseus_miniature.shift(RIGHT)\n        self.camera.frame.move_to(Group(theseus_miniature, minotaur_miniature))\n        self.camera.frame.scale(0.75)\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(RIGHT), minotaur_miniature)), theseus_miniature.animate.shift(RIGHT))\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy(), minotaur_miniature.copy().shift(LEFT * 2))), minotaur_miniature.animate.shift(LEFT * 2), rate_func=double_smooth, run_time=MINOTAUR_MOVE_SPEED)\n        minotaur_miniature.save_state()\n        theseus_miniature.save_state()\n        self.camera.frame.save_state()\n        rect = get_fade_rect()\n        self.play(AnimationGroup(FadeIn(rect, run_time=2, rate_func=there_and_back), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(LEFT * 6 + UP * 2), minotaur_miniature.copy().shift(LEFT * 4))), theseus_miniature.animate.shift(LEFT * 6 + UP * 2), minotaur_miniature.animate.shift(LEFT * 4), run_time=1), lag_ratio=0.25))\n        for i in range(2):\n            self.play(minotaur_miniature.animate.shift(LEFT * 0.1), rate_func=there_and_back, run_time=0.8)\n            self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy(), minotaur_miniature.copy().shift(UP))), minotaur_miniature.animate.shift(UP), run_time=MINOTAUR_MOVE_SPEED / 2)\n        for i in range(2):\n            self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(DOWN), minotaur_miniature)), theseus_miniature.animate.shift(DOWN))\n            self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy(), minotaur_miniature.copy().shift(LEFT * 2))), minotaur_miniature.animate.shift(LEFT * 2), rate_func=double_smooth, run_time=MINOTAUR_MOVE_SPEED)\n            self.wait(MINOTAUR_MOVE_DELAY)\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(RIGHT), minotaur_miniature)), theseus_miniature.animate.shift(RIGHT))\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy(), minotaur_miniature.copy().shift(RIGHT))), minotaur_miniature.animate.shift(RIGHT))\n        self.wait(MINOTAUR_MOVE_DELAY)\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(LEFT), minotaur_miniature)), theseus_miniature.animate.shift(LEFT), run_time=FAST_RUNTIME)\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy(), minotaur_miniature.copy().shift(LEFT))), minotaur_miniature.animate.shift(LEFT), run_time=FAST_RUNTIME)\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy(), minotaur_miniature.copy().shift(DOWN))), minotaur_miniature.animate.shift(DOWN), run_time=FAST_RUNTIME)\n        self.wait(MINOTAUR_MOVE_DELAY)\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(RIGHT), minotaur_miniature)), theseus_miniature.animate.shift(RIGHT), run_time=FAST_RUNTIME)\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy(), minotaur_miniature.copy().shift(DOWN))), minotaur_miniature.animate.shift(DOWN), run_time=FAST_RUNTIME)\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy(), minotaur_miniature.copy().shift(RIGHT))), minotaur_miniature.animate.shift(RIGHT), FadeOut(theseus_miniature), run_time=FAST_RUNTIME)\n        tm = theseus_miniature.copy().shift(LEFT)\n        theseus_miniature.set_opacity(0)\n        self.play(Transform(theseus_miniature, tm), minotaur_miniature.animate.shift(RIGHT), self.camera.frame.animate.scale(0.5), run_time=1.5)\n        question = Tex('\\\\underline{How to approach this problem?}').set_z_index(1000001).next_to(Group(theseus_miniature, minotaur_miniature), UP).scale(0.65)\n        rect = get_fade_rect()\n        self.play(AnimationGroup(FadeIn(rect), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature, question)), FadeIn(question, shift=UP * 0.25)), lag_ratio=0.5))\n        self.play(FadeOut(maze))\n        self.remove(rect)\n        table = Table([[Tex('$(t_x, t_y)$'), Tex('$((t_x, t_y), (m_x, m_y))$')], [Tex('$t$ is not a wall'), Tex('$t$, $m$ is not a wall, $t \\\\neq m$')]], element_to_mobject=lambda x: x, col_labels=[Tex('Placeholder'), Tex('Placeholder')], row_labels=[Tex('State'), Tex('Validity')])\n        table.next_to(question, DOWN, buff=1.5)\n        a = theseus_miniature.copy().set_height(table.get_col_labels()[0].get_height() * 2.5)\n        b = Group(theseus_miniature.copy().set_height(table.get_col_labels()[0].get_height() * 2.5), Tex('+').set_height(table.get_col_labels()[0].get_height() * 1.2), minotaur_miniature.copy().set_height(table.get_col_labels()[0].get_height() * 2.5)).arrange()\n        a.move_to(table.get_col_labels()[0])\n        b.move_to(table.get_col_labels()[1])\n        new_question = question.copy().scale(2).next_to(table, UP, buff=1)\n        self.play(AnimationGroup(AnimationGroup(ReplacementTransform(theseus_miniature, a), ReplacementTransform(theseus_miniature.copy(), b[0]), ReplacementTransform(minotaur_miniature, b[2]), Transform(question, new_question), self.camera.frame.animate.scale(2.7).move_to(Group(table, new_question))), AnimationGroup(FadeIn(table.get_horizontal_lines()), FadeIn(table.get_vertical_lines()), FadeIn(table.get_row_labels()), FadeIn(b[1])), lag_ratio=0.75))\n        self.play(Write(table.get_entries_without_labels((1, 1))), run_time=1)\n        self.play(Write(table.get_entries_without_labels((1, 2))), run_time=1)\n        self.play(Write(table.get_entries_without_labels((2, 1))), Write(table.get_entries_without_labels((2, 2))[0][:13]), run_time=1)\n        self.play(Write(table.get_entries_without_labels((2, 2))[0][13:]), run_time=0.5)"}]}
{"messages": [{"role": "user", "content": "Animate the introduction of characters Theseus and Minotaur, a maze visualization, a Breadth-First Search (BFS) algorithm demonstration on the maze, and the final pathfinding of Theseus."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass Intro(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        with open('maze/mask.txt') as f:\n            contents = f.read().splitlines()\n        theseus = ImageMobject('assets/theseus-nobackground.png').set_height(0.8).set_z_index(100)\n        theseus_position = (22, 9)\n        theseus_text = Tex('Theseus').next_to(theseus, DOWN, buff=-0.08).scale(0.25)\n        theseus_miniature = ImageMobject('assets/theseus-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (theseus_position[0] + 0.5) + DOWN * (theseus_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.camera.frame.move_to(Group(theseus, theseus_text)).set_height(theseus.height * 2)\n        self.play(AnimationGroup(FadeIn(theseus), FadeIn(theseus_text, lag_ratio=0.1), lag_ratio=0.5))\n        minotaur = ImageMobject('assets/minotaur-nobackground.png').set_height(0.8).next_to(theseus, RIGHT, buff=0.3).set_z_index(100)\n        minotaur_position = (27, 9)\n        minotaur_text = Tex('Minotaur').next_to(minotaur, DOWN, buff=-0.08).scale(0.25)\n        minotaur_miniature = ImageMobject('assets/minotaur-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (minotaur_position[0] + 0.5) + DOWN * (minotaur_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(Group(theseus, minotaur)).scale(1.25), AnimationGroup(FadeIn(minotaur), FadeIn(minotaur_text, lag_ratio=0.1), lag_ratio=0.5), lag_ratio=0.25))\n        maze, maze_dict = maze_to_vgroup(contents)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(theseus_text), FadeOut(minotaur_text)), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)).set_height(maze.height * 0.3), FadeTransform(theseus, theseus_miniature), FadeTransform(minotaur, minotaur_miniature)), AnimationGroup(FadeIn(maze)), lag_ratio=0.5, run_time=2))\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2))\n        for i in range(1):\n            self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(LEFT), minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2), theseus_miniature.animate.shift(LEFT))\n        rect = get_fade_rect()\n        canhe = Tex('\\\\underline{Can he get out?}').scale(1.25).next_to(Group(theseus_miniature, minotaur_miniature), UP, buff=0.25).set_z_index(10000000)\n        self.play(AnimationGroup(FadeIn(rect), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature, canhe)), FadeIn(canhe, shift=UP * 0.25)), lag_ratio=0.5))\n        self.play(FadeOut(rect), FadeOut(canhe), self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)))\n        self.play(Flash(minotaur_miniature, color=WHITE), FadeOut(minotaur_miniature))\n        self.play(self.camera.frame.animate.move_to(maze).set_height(maze.height * 1.25), run_time=1.5)\n        shortest_path = [(21, 9), (22, 9), (23, 9), (24, 9), (25, 9), (26, 9), (27, 9), (27, 10), (27, 11), (27, 12), (27, 13), (27, 14), (27, 15), (28, 15), (29, 15), (30, 15), (31, 15), (32, 15), (33, 15), (34, 15), (35, 15), (36, 15), (37, 15), (37, 16), (37, 17), (38, 17), (39, 17), (39, 16), (39, 15), (40, 15)]\n        theseus_miniature.set_z_index(1)\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE) for p in shortest_path], lag_ratio=0.02))\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(WHITE, 0).set_stroke_color(WHITE) for p in shortest_path]))\n        bfs_text = Tex('BFS').scale(5).next_to(maze, RIGHT, buff=1.5).align_to(maze, UP).shift(DOWN)\n        q = Queue(scale=2).next_to(bfs_text, DOWN, buff=2)\n        self.play(FadeIn(q), FadeIn(bfs_text), self.camera.frame.animate.move_to(Group(maze, theseus_miniature, q, bfs_text)), run_time=1)\n        theseus_position = (theseus_position[0] - 1, theseus_position[1])\n        queue = [theseus_position]\n        discovered = {theseus_position: None}\n\n        def is_valid(position):\n            x, y = position\n            return 0 <= x < len(contents[0]) and 0 <= y < len(contents) and (contents[y][x] != '#')\n\n        def next_states(position):\n            x, y = position\n            states = []\n            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                nx = x + dx\n                ny = y + dy\n                if is_valid((nx, ny)):\n                    states.append((nx, ny))\n            return states\n\n        def animate_discover(states):\n            return AnimationGroup(*[maze_dict[p].animate.set_fill(BLUE, 0.75).set_stroke_color(BLUE) for p in states])\n\n        def animate_leave(state):\n            return maze_dict[state].animate.set_fill(LIGHT_GRAY, 0.75).set_stroke_color(LIGHT_GRAY).set_z_index(3)\n\n        def animate_add_to_queue(states):\n            fade_froms = [maze_dict[s] for s in states]\n            state_texs = [Tex((a - 8, b)) for a, b in states]\n            return q.animate_add_from(state_texs, fade_froms)\n\n        def animate_pop_from_queue(state):\n            copy = maze_dict[state].copy().set_fill(WHITE, 0).set_stroke_color(WHITE).set_z_index(0.05)\n            return (AnimationGroup(q.animate_remove_to(copy), maze_dict[state].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE).set_z_index(2)), copy)\n\n        def stop_condition(state):\n            return state == escape\n        i = 1\n\n        def add_neighbours(position):\n            states = []\n            for next_state in next_states(position):\n                if next_state not in discovered:\n                    discovered[next_state] = position\n                    queue.append(next_state)\n                    states.append(next_state)\n            if len(states) != 0:\n                self.play(animate_leave(current), animate_discover(states), animate_add_to_queue(states))\n            else:\n                self.play(animate_leave(current))\n        self.play(animate_discover([theseus_position]), animate_add_to_queue([theseus_position]))\n        escape = (40, 15)\n        queue2 = [theseus_position]\n        discovered2 = {theseus_position: 0}\n        while len(queue2) != 0:\n            current = queue2.pop(0)\n            for next_state in next_states(current):\n                if next_state not in discovered2:\n                    discovered2[next_state] = discovered2[current] + 1\n                    queue2.append(next_state)\n        maze_dict[theseus_position].set_z_index(1000)\n        theseus_miniature.set_z_index(1001)\n        self.play(AnimationGroup(*[AnimationGroup(*[maze_dict[p].animate(rate_func=there_and_back, run_time=1.5).set_color(BLUE).set_fill(BLUE, 0.75) for p in discovered2.keys() if discovered2[p] == d]) for d in range(1, max(discovered2.values()) + 1)], lag_ratio=0.025))\n        path = list(reversed(shortest_path))\n        while len(queue) != 0:\n            current = queue.pop(0)\n            if config.quality.startswith('medium') and i > 10:\n                break\n            i += 1\n            a, o = animate_pop_from_queue(current)\n            self.play(a)\n            self.remove(o)\n            self.remove(theseus_miniature)\n            theseus_miniature.set_z_index(10000)\n            self.add(theseus_miniature)\n            if stop_condition(current):\n                path = [current]\n                while discovered[current] is not None:\n                    current = discovered[current]\n                    path.append(current)\n                break\n            add_neighbours(current)\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE) for p in reversed(path)], lag_ratio=0.02))"}]}
{"messages": [{"role": "user", "content": "Visualize the Breadth-First Search algorithm, animating its application to the Minotaur and Theseus maze problem by highlighting code and moving figures through the maze."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass BFSMinotaur(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        blocks = code_parts_from_file('programs/bfs.py')\n        bfs = Tex('Breadth-First Search').scale(1.65)\n        code_web = align_code([('-', 'c'), [('|', 'c'), bfs, blocks['start'], blocks['output']], [('|', 'l'), blocks['is_valid'], blocks['next_states'], blocks['bfs_deque']]])\n        start_group = VGroup(bfs, blocks['start'].background_mobject)\n        blocks['output'].align_to(blocks['start'], RIGHT)\n        self.camera.frame.move_to(blocks['bfs_deque']).set_height(blocks['bfs_deque'].height * 1.2)\n        self.add(*code_web)\n        self.remove(blocks['output'])\n        self.play(FadeCode(blocks['start']), FadeCode(blocks['is_valid']), FadeCode(blocks['next_states']))\n        self.next_section()\n        highlight = CreateHighlightCodeLine(blocks['bfs_deque'], 2, start=8, end=38)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks['bfs_deque'], [22, 23, 24, 25], offset=2)))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['bfs_deque'], 22, start=20, end=40)))\n        self.play(AnimationGroup(AnimationGroup(FadeCode(blocks['bfs_deque']), FadeOut(highlight)), self.camera.frame.animate.move_to(start_group), UnfadeCode(blocks['start']), lag_ratio=0.5))\n        blocks_minotaur = code_parts_from_file('programs/minotaur.py')\n        bfs_copy = bfs.copy()\n        code_web_minotaur = align_code([('-', 'c'), [('|', 'c'), bfs_copy, blocks_minotaur['start'], blocks_minotaur['output']], [('|', 'l'), blocks_minotaur['is_valid'], blocks_minotaur['next_theseus_positions'], blocks_minotaur['next_minotaur_position'], blocks_minotaur['next_states'], blocks_minotaur['bfs']]])\n        blocks_minotaur['output'].align_to(blocks_minotaur['start'], RIGHT)\n        align_object_by_coords(code_web_minotaur, blocks_minotaur['start'], blocks_minotaur['start'].copy().move_to(blocks['start']).align_to(blocks['start'], UP).align_to(blocks['start'], RIGHT))\n        blocks_minotaur['start_partial'].move_to(blocks['start'])\n        blocks_minotaur['start_partial_2'].set_z_index(10)\n        self.camera.frame.save_state()\n        self.play(self.camera.frame.animate.move_to(blocks_minotaur['start_partial'].code[0:10]).scale(0.5))\n        self.play(FadeIn(blocks_minotaur['start_partial']), Flash(blocks_minotaur['start_partial'].code[4][8], color=blocks_minotaur['start_partial'].code[4][8].color, flash_radius=0.175))\n        self.play(self.camera.frame.animate.restore())\n        blocks_minotaur['start_partial_2'].move_to(blocks_minotaur['start_partial']).align_to(blocks_minotaur['start_partial'], UP)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(blocks['is_valid'])\n        self.add(blocks['next_states'])\n        self.add(bfs)\n        self.add(blocks['bfs_deque'])\n        self.play(AnimationGroup(AnimationGroup(FadeTransform(blocks_minotaur['start_partial'].background_mobject, blocks_minotaur['start_partial_2'].background_mobject), Transform(blocks_minotaur['start_partial'].code[:14], blocks_minotaur['start_partial_2'].code[:14]), Transform(blocks_minotaur['start_partial'].code[14:21], blocks_minotaur['start_partial_2'].code[15:22]), Transform(blocks_minotaur['start_partial'].code[21:], blocks_minotaur['start_partial_2'].code[24:]), self.camera.frame.animate.move_to(blocks_minotaur['start_partial_2'])), AnimationGroup(Write(blocks_minotaur['start_partial_2'].code[14]), Write(blocks_minotaur['start_partial_2'].code[22:24]), run_time=1), lag_ratio=0.75))\n        blocks_minotaur['start'].set_z_index(20)\n        blocks_minotaur['start_partial_2'].set_z_index(20)\n        blocks_minotaur['start_partial_2'].background_mobject.set_z_index(0)\n        blocks_minotaur['start_this_sucks'].background_mobject.set_z_index(1)\n        blocks_minotaur['start'].align_to(blocks_minotaur['start_partial_2'], LEFT)\n        blocks_minotaur['start_this_sucks'].align_to(blocks_minotaur['start'], LEFT).align_to(blocks_minotaur['start'], UP)\n        highlight = CreateHighlightCodeLine(blocks_minotaur['start'], -3, start=1).set_z_index(1000)\n        self.play(AnimationGroup(AnimationGroup(FadeTransform(blocks_minotaur['start_partial_2'].background_mobject, blocks_minotaur['start_this_sucks'].background_mobject), Transform(blocks_minotaur['start_partial'].code[-1][4:12], blocks_minotaur['start'].code[-3][2:10]), *[Transform(blocks_minotaur['start_partial'].code[-1][12 + i], blocks_minotaur['start'].code[-2][0 + i]) for i in range(20)], Transform(blocks_minotaur['start_partial'].code[-1][33:-1], blocks_minotaur['start'].code[-2][24:]), Transform(blocks_minotaur['start_partial'].code[-1][-1], blocks_minotaur['start'].code[-1][-1]), self.camera.frame.animate.move_to(blocks_minotaur['start_this_sucks'])), AnimationGroup(Write(blocks_minotaur['start'].code[-3][:2]), Write(blocks_minotaur['start'].code[-3][10:]), Write(blocks_minotaur['start'].code[-2][20:23]), run_time=1), lag_ratio=0.75))\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks_minotaur['start'], -2, start=1).set_z_index(1000)))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(blocks['is_valid'])\n        self.add(blocks['next_states'])\n        self.add(bfs)\n        self.add(blocks_minotaur['start'])\n        self.add(blocks['bfs_deque'])\n        blocks_minotaur['start'].background_mobject.become(blocks_minotaur['start_this_sucks'].background_mobject)\n        self.play(AnimationGroup(AnimationGroup(FadeCode(blocks_minotaur['start']), FadeOut(highlight)), self.camera.frame.animate.move_to(blocks['next_states']), UnfadeCode(blocks['next_states']), lag_ratio=0.5))\n        ntp_copy = blocks_minotaur['next_theseus_positions'].copy().move_to(blocks['next_states'])\n        self.play(FadeTransform(blocks['next_states'].code[0][9:9 + 6], ntp_copy.code[0][9:9 + 17]), Transform(blocks['next_states'].code[0][9 + 6:], ntp_copy.code[0][9 + 17:]))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(blocks['is_valid'])\n        self.add(ntp_copy)\n        self.add(bfs)\n        self.add(blocks_minotaur['start'])\n        self.add(blocks['bfs_deque'])\n        blocks_minotaur['is_valid'].set_opacity(BIG_OPACITY)\n        blocks_minotaur['next_theseus_positions'].set_opacity(BIG_OPACITY)\n        blocks_minotaur['bfs'].set_opacity(BIG_OPACITY)\n        self.play(AnimationGroup(AnimationGroup(Transform(blocks['is_valid'], blocks_minotaur['is_valid']), Transform(ntp_copy, blocks_minotaur['next_theseus_positions']), Transform(blocks['bfs_deque'], blocks_minotaur['bfs']), self.camera.frame.animate.move_to(blocks_minotaur['next_minotaur_position'].background_mobject)), AnimationGroup(FadeIn(blocks_minotaur['next_minotaur_position'].background_mobject)), lag_ratio=0.5))\n        self.play(Write(blocks_minotaur['next_minotaur_position'].code[:2]))\n        highlight = CreateHighlightCodeLine(blocks_minotaur['next_minotaur_position'], 1, start=8, end=10)\n        self.play(FadeIn(highlight), run_time=0.5)\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks_minotaur['next_minotaur_position'], 1, start=25, end=26)), run_time=0.5)\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks_minotaur['next_minotaur_position'], 1, start=42, end=44)), run_time=0.5)\n        self.play(FadeOut(highlight), run_time=0.5)\n        blocks_minotaur['next_minotaur_position_move_forward_example'].move_to(blocks_minotaur['next_minotaur_position'])\n        self.camera.frame.save_state()\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(blocks_minotaur['next_minotaur_position_move_forward_example'].code[3:6]).scale(0.5), FadeIn(blocks_minotaur['next_minotaur_position_move_forward_example'].code[3:6]), lag_ratio=0.5))\n        self.play(AnimationGroup(FadeOut(blocks_minotaur['next_minotaur_position_move_forward_example'].code[3:6]), self.camera.frame.animate.restore(), lag_ratio=0.5))\n        self.play(Write(blocks_minotaur['next_minotaur_position'].code[2:]))\n        highlight = CreateHighlightCodeLines(blocks_minotaur['next_minotaur_position'], [8, 9, 10, 11, 12], offset=2)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_minotaur_position'], [14, 15, 16, 17, 18], offset=2)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_minotaur_position'], [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18], offset=1)))\n        self.play(FadeOut(highlight))\n        self.play(AnimationGroup(AnimationGroup(FadeCode(blocks_minotaur['next_minotaur_position']), self.camera.frame.animate.move_to(blocks_minotaur['next_states'].background_mobject)), AnimationGroup(FadeIn(blocks_minotaur['next_states'].background_mobject), Write(blocks_minotaur['next_states'].code)), lag_ratio=0.5))\n        highlight = CreateHighlightCodeLines(blocks_minotaur['next_states'], [1], offset=1)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_states'], [4], offset=1)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_states'], [5], offset=2)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_states'], [7, 8], offset=2)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_states'], [10], offset=2)))\n        self.play(FadeOut(highlight))\n        maze_str = ['##########', '# #     E#', '# # # ####', '# T # M  #', '### # ## #', '#   #    #', '## ## # ##', '#  #  #  #', '##########']\n        solution = [((2, 3), (6, 3)), ((3, 3), (5, 3)), ((3, 4), (5, 4)), ((3, 5), (5, 5)), ((2, 5), (5, 5)), ((2, 6), (5, 6)), ((2, 7), (4, 7)), ((2, 6), (4, 7)), ((2, 5), (4, 7)), ((3, 5), (4, 7)), ((3, 4), (4, 7)), ((3, 3), (4, 7)), ((3, 2), (4, 7)), ((3, 1), (4, 7)), ((4, 1), (4, 7)), ((5, 1), (5, 6)), ((6, 1), (6, 5)), ((7, 1), (7, 5)), ((8, 1), (8, 4))]\n        maze, maze_dict = maze_to_vgroup(maze_str)\n        maze.next_to(blocks_minotaur['output'], LEFT, buff=ALIGN_SPACING)\n        maze.align_to(blocks_minotaur['output'], UP)\n        theseus = ImageMobject('assets/theseus-nobackground-outline.png').set_height(0.8).move_to(maze_dict[solution[0][0]]).set_z_index(10000000)\n        minotaur = ImageMobject('assets/minotaur-nobackground-outline.png').set_height(0.8).move_to(maze_dict[solution[0][1]]).set_z_index(10000000)\n        door = ImageMobject('assets/door-outline.png').set_height(0.8).move_to(maze_dict[solution[-1][0]]).set_z_index(10000000000000000000000000)\n        numbers_x = VGroup(*[Tex(str(i), color=BLACK).scale(0.85).move_to(maze_dict[i, 0]).set_z_index(1000000000) for i in range(1, len(maze_str[0]) - 1)])\n        numbers_y = VGroup(*[Tex(str(i), color=BLACK).scale(0.85).move_to(maze_dict[0, i]).set_z_index(1000000000) for i in range(1, len(maze_str) - 1)])\n        self.play(AnimationGroup(FadeCode(blocks_minotaur['next_states']), AnimationGroup(FadeIn(blocks_minotaur['output'].background_mobject), Write(blocks_minotaur['output'].code), self.camera.frame.animate.move_to(VGroup(maze, blocks_minotaur['output'])).scale(0.9), FadeIn(maze), FadeIn(theseus), FadeIn(minotaur), FadeIn(door)), AnimationGroup(AnimationGroup(*[FadeIn(n) for n in numbers_x], lag_ratio=0.05), AnimationGroup(*[FadeIn(n) for n in numbers_y], lag_ratio=0.05)), lag_ratio=0.5))\n        highlight = CreateHighlightCodeLine(blocks_minotaur['output'], 1)\n        prev_m = None\n        for i, (t, m) in enumerate(solution):\n            anim = None\n            if i == 0:\n                anim = FadeIn(highlight)\n            else:\n                anim = Transform(highlight, CreateHighlightCodeLine(blocks_minotaur['output'], i + 1))\n            anim2 = None\n            if t == solution[-1][0]:\n                anim2 = theseus.animate.set_opacity(0).move_to(maze_dict[t])\n            else:\n                anim2 = theseus.animate.move_to(maze_dict[t])\n            run_time = 1 if i <= 2 else FAST_RUNTIME\n            if prev_m == m:\n                maze_dict[t].set_z_index(0.05)\n                self.play(AnimationGroup(AnimationGroup(anim, anim2), maze_dict[t].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE), lag_ratio=0.33), run_time=run_time)\n            else:\n                maze_dict[t].set_z_index(0.05)\n                maze_dict[m].set_z_index(0.05)\n                self.play(AnimationGroup(AnimationGroup(AnimationGroup(anim, anim2), maze_dict[t].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE), lag_ratio=0.33), AnimationGroup(minotaur.animate.move_to(maze_dict[m]), maze_dict[m].animate.set_fill(BLUE, 0.75).set_stroke_color(BLUE), lag_ratio=0.33), lag_ratio=0.25), run_time=run_time)\n            prev_m = m\n        bfs = Tex('BFS').scale(2.5)\n        bfs_full = Tex('(Breadth-First Search)').scale(1.5).next_to(bfs, DOWN)\n        a = VGroup(bfs, bfs_full)\n        stop = Tex('\\\\parbox{18em}{Solves problems that have \\\\textit{states} where the goal is to get from the \\\\textit{starting} state to an \\\\textit{ending state} in the \\\\textit{least amount of steps possible:}}')\n        l1 = Tex('\\\\begin{itemize} \\\\item shortest path \\\\end{itemize}')\n        l2 = Tex('\\\\begin{itemize} \\\\item Theseus and the Minotaur \\\\end{itemize}')\n        l = VGroup(l1, l2).arrange(DOWN, buff=0.25)\n        l2.align_to(l1, LEFT)\n        b = VGroup(stop, l).arrange(DOWN, buff=0.75)\n        VGroup(a, b).arrange(DOWN, buff=1).next_to(blocks['bfs_deque'], LEFT, buff=1.5)\n        self.play(AnimationGroup(FadeOut(highlight), FadeOut(maze), FadeOut(blocks_minotaur['output'].background_mobject), FadeOut(blocks_minotaur['output'].code), FadeOut(theseus), FadeOut(minotaur), FadeOut(door), FadeOut(numbers_x), FadeOut(numbers_y), FadeOut(blocks_minotaur['next_states']), FadeOut(blocks_minotaur['start']), FadeOut(blocks_minotaur['next_minotaur_position']), FadeOut(blocks_minotaur['next_theseus_positions'])), AnimationGroup(AnimationGroup(UnfadeCode(blocks['bfs_deque']), self.camera.frame.animate.move_to(VGroup(blocks['bfs_deque'], a, b)).scale(1.1)), AnimationGroup(Write(a[0], run_time=0.5), FadeIn(a[1], run_time=1), lag_ratio=0.5), lag_ratio=0.75))\n        l.align_to(stop, LEFT).shift(RIGHT * 0.3)\n        self.play(Write(stop), run_time=2.5)\n        self.play(Write(l1), run_time=0.75)\n        self.play(Write(l2), run_time=1)"}]}
{"messages": [{"role": "user", "content": "Animate the explanation of Breadth-First Search by showing code blocks, highlighting logic, and demonstrating a maze traversal."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass BFS(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        blocks = code_parts_from_file('programs/bfs.py')\n        bfs = Tex('Breadth-First Search').scale(1.65)\n        code_web = align_code([('-', 'c'), [('|', 'c'), bfs, blocks['start'], blocks['output']], [('|', 'l'), blocks['is_valid'], blocks['next_states'], blocks['bfs']]])\n        start_group = VGroup(bfs, blocks['start'].background_mobject)\n        (self.camera.frame.move_to(start_group).set_height(start_group.height * 1.2),)\n        self.play(Write(bfs, run_time=1), Write(blocks['start'].background_mobject))\n        self.play(Write(blocks['start'].code[:11]), run_time=1.5)\n        highlight = CreateHighlightCodeLine(blocks['start'], 4, start=4, end=5)\n        highlight2 = CreateHighlightCodeLine(blocks['start'], 2, start=10, end=11)\n        self.play(FadeIn(highlight), FadeIn(highlight2))\n        self.play(FadeOut(highlight), FadeOut(highlight2))\n        self.play(Write(blocks['start'].code[12:22]), run_time=3)\n        question = Tex('\\\\underline{What now?}').set_z_index(1000001).move_to(self.camera.frame).scale(2)\n        answer = Tex('write small functions!').set_z_index(1000001).move_to(self.camera.frame).scale(1.25)\n        group = VGroup(question.copy(), answer)\n        answer.next_to(question, DOWN, buff=0.25)\n        self.play(AnimationGroup(FadeCode(blocks['start'], skip_lines=[22]), FadeIn(question), lag_ratio=0.5))\n        self.play(AnimationGroup(Transform(question, group[0]), FadeIn(group[1], run_time=1), lag_ratio=0.75))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(question), FadeOut(answer)), self.camera.frame.animate.move_to(blocks['is_valid']), WriteCode(blocks['is_valid']), lag_ratio=0.5))\n        highlight = CreateHighlightCodeLines(blocks['is_valid'], [3, 4], offset=8)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks['is_valid'], [5], offset=6)))\n        self.play(FadeOut(highlight))\n        self.play(AnimationGroup(FadeCode(blocks['is_valid']), self.camera.frame.animate.move_to(blocks['next_states']), WriteCode(blocks['next_states']), lag_ratio=0.5))\n        blocks['next_states'].code.set_z_index(1)\n        highlight = CreateHighlightCodeLines(blocks['next_states'], [4, 5, 6], offset=1)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks['next_states'], [8, 9], offset=2)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks['next_states'], [11], offset=1)))\n        self.play(FadeOut(highlight))\n        self.play(AnimationGroup(FadeCode(blocks['next_states']), self.camera.frame.animate.move_to(blocks['bfs']), Write(blocks['bfs'].background_mobject), lag_ratio=0.5))\n        self.play(Write(blocks['bfs'].code[0]), run_time=1)\n        highlight = CreateHighlightCodeLine(blocks['bfs'], 0, start=8, end=22)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['bfs'], 0, start=24, end=38)))\n        stop = Tex('\\\\parbox{12em}{Allows us to support more complex ways of ending the BFS (multiple escape tiles).}').set_z_index(1000001).scale(0.5).next_to(highlight, DOWN)\n        pointless = Tex('\\\\parbox{12em}{Is this pointless?}').set_z_index(1000001).scale(0.5).next_to(highlight, DOWN)\n        self.camera.frame.save_state()\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(VGroup(highlight, stop)).scale(0.25), FadeIn(pointless), lag_ratio=0.5))\n        self.play(FadeOut(pointless, shift=UP * 0.3), FadeIn(stop, shift=UP * 0.3))\n        self.play(AnimationGroup(FadeOut(stop), FadeOut(highlight), self.camera.frame.animate.restore(), lag_ratio=0.5))\n        self.play(Write(blocks['bfs'].code[1]), run_time=1)\n        self.play(Write(blocks['bfs'].code[2]), run_time=1)\n        self.play(Write(blocks['bfs'].code[4]), run_time=1)\n        self.play(Write(blocks['bfs'].code[5]), run_time=1)\n        self.play(Write(blocks['bfs'].code[7:10]), run_time=1.75)\n        self.play(Write(blocks['bfs'].code[11:14]), run_time=1.75)\n        self.play(Write(blocks['bfs'].code[14]), run_time=1)\n        self.play(Write(blocks['bfs'].code[16]), run_time=1)\n        blocks['bfs_mid'].align_to(blocks['bfs'], UP).align_to(blocks['bfs'], LEFT)\n        blocks['bfs_better'].align_to(blocks['bfs'], UP).align_to(blocks['bfs'], LEFT)\n        highlight = CreateHighlightCodeLine(blocks['bfs'], 2, 1)\n        self.play(FadeIn(highlight))\n        self.play(AnimationGroup(AnimationGroup(Transform(highlight, CreateHighlightCodeLine(blocks['bfs_mid'], 2, 1)), Transform(blocks['bfs'].code[2][-1], blocks['bfs_mid'].code[2][-1])), FadeIn(blocks['bfs_mid'].code[2][-10:-1]), lag_ratio=0.5))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['bfs_mid'], 2, start=15, end=29)))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['bfs_mid'], 2, start=31, end=35)))\n        blocks['bfs_mid'].code[14].move_to(blocks['bfs'].code[14]).align_to(blocks['bfs'].code[14], LEFT)\n        h = highlight\n        highlight = CreateHighlightCodeLine(blocks['bfs'], 14, start=4)\n        self.play(FadeOut(h), FadeIn(highlight))\n        self.play(AnimationGroup(AnimationGroup(Transform(highlight, CreateHighlightCodeLine(blocks['bfs_mid'], 14, start=4)), FadeTransform(blocks['bfs'].code[14][14:19], blocks['bfs_mid'].code[14][14]), FadeTransform(blocks['bfs'].code[14][19:19 + 7], blocks['bfs_mid'].code[14][-7:1000]), FadeTransform(blocks['bfs'].code[14][-1], blocks['bfs_mid'].code[14][25]), FadeTransform(blocks['bfs'].background_mobject, blocks['bfs_mid'].background_mobject)), AnimationGroup(FadeIn(blocks['bfs_mid'].code[14][14:25]), FadeIn(blocks['bfs_mid'].code[14][27])), lag_ratio=0.5))\n        self.play(FadeOut(highlight))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(blocks['start'])\n        self.add(blocks['is_valid'])\n        self.add(blocks['next_states'])\n        self.add(bfs)\n        self.add(blocks['bfs_mid'])\n        self.remove(blocks['start'].code[-1])\n        self.play(AnimationGroup(AnimationGroup(FadeTransform(blocks['bfs_mid'].background_mobject, blocks['bfs_better'].background_mobject), FadeTransform(blocks['bfs_mid'].code[10:], blocks['bfs_better'].code[19:]), FadeTransform(blocks['bfs_mid'].code[9][3:], blocks['bfs_better'].code[18][3:]), self.camera.frame.animate.move_to(blocks['bfs_better']).set_height(blocks['bfs_better'].height * 1.2)), FadeIn(blocks['bfs_better'].code[9:18]), lag_ratio=0.5))\n        highlight = CreateHighlightCodeLine(blocks['bfs_better'], 10, start=3)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['bfs_better'], 11, start=3)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks['bfs_better'], [12], offset=4)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks['bfs_better'], [13], offset=4)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks['bfs_better'], [15, 16], offset=3)))\n        self.play(FadeOut(highlight))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(blocks['start'])\n        self.add(blocks['is_valid'])\n        self.add(blocks['next_states'])\n        self.add(bfs)\n        self.add(blocks['bfs_better'])\n        self.remove(blocks['start'].code[-1])\n        blocks['bfs_deque'].align_to(blocks['bfs_better'], UP).align_to(blocks['bfs_better'], LEFT)\n        self.play(AnimationGroup(AnimationGroup(FadeTransform(blocks['bfs_better'].background_mobject, blocks['bfs_deque'].background_mobject), blocks['bfs_better'].code.animate.align_to(blocks['bfs_deque'].code[2], UP), self.camera.frame.animate.move_to(blocks['bfs_deque']).set_height(blocks['bfs_deque'].height * 1.2)), FadeIn(blocks['bfs_deque'].code[0]), lag_ratio=0.5))\n        highlight = CreateHighlightCodeLine(blocks['bfs_better'], 1, start=1)\n        self.play(FadeIn(highlight))\n        self.play(AnimationGroup(AnimationGroup(Transform(blocks['bfs_better'].code[1][9:], blocks['bfs_deque'].code[3][15:-1]), Transform(highlight, CreateHighlightCodeLine(blocks['bfs_deque'], 3, start=1))), AnimationGroup(FadeIn(blocks['bfs_deque'].code[3][7:7 + 8]), FadeIn(blocks['bfs_deque'].code[3][-1])), lag_ratio=0.5))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['bfs_better'], 5, start=2)))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(blocks['bfs_better'].code[5][-2]), AnimationGroup(Transform(highlight, CreateHighlightCodeLine(blocks['bfs_deque'], 7, start=2)), Transform(blocks['bfs_better'].code[5][-3], blocks['bfs_deque'].code[7][-2]), Transform(blocks['bfs_better'].code[5][-1], blocks['bfs_deque'].code[7][-1])), lag_ratio=0.25), FadeIn(blocks['bfs_deque'].code[7][-6:-2]), lag_ratio=0.5))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(blocks['start'])\n        self.add(blocks['is_valid'])\n        self.add(blocks['next_states'])\n        self.add(bfs)\n        self.add(blocks['bfs_deque'])\n        self.remove(blocks['start'].code[-1])\n        self.play(AnimationGroup(AnimationGroup(FadeCode(blocks['bfs_deque']), FadeOut(highlight)), self.camera.frame.animate.move_to(VGroup(blocks['start'], bfs)), UnfadeCode(blocks['start'], skip_lines=[22]), lag_ratio=0.5))\n        self.add(blocks['start'].code[-1])\n        self.play(Write(blocks['start'].code[22]), run_time=1)\n        highlight = CreateHighlightCodeLine(blocks['start'], 22, 4, 11)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['start'], 22, 13, -1)))\n        self.play(FadeOut(highlight))\n        blocks['output'].align_to(blocks['start'], RIGHT)\n        maze_str = ['##########', '# #     E#', '# # # ####', '# T #    #', '### # ## #', '#   #    #', '## ## # ##', '#  #  #  #', '##########']\n        solution = [(2, 3), (3, 3), (3, 2), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 1)]\n        maze, maze_dict = maze_to_vgroup(maze_str)\n        maze.next_to(blocks['output'], LEFT, buff=ALIGN_SPACING)\n        maze.align_to(blocks['output'], UP)\n        theseus = ImageMobject('assets/theseus-nobackground-outline.png').set_height(0.8).move_to(maze_dict[solution[0]]).set_z_index(100)\n        door = ImageMobject('assets/door-outline.png').set_height(0.8).move_to(maze_dict[solution[-1]]).set_z_index(10000000000000000)\n        numbers_x = VGroup(*[Tex(str(i), color=BLACK).scale(0.85).move_to(maze_dict[i, 0]).set_z_index(1000000000) for i in range(1, len(maze_str[0]) - 1)])\n        numbers_y = VGroup(*[Tex(str(i), color=BLACK).scale(0.85).move_to(maze_dict[0, i]).set_z_index(1000000000) for i in range(1, len(maze_str) - 1)])\n        self.play(AnimationGroup(FadeCode(blocks['start']), AnimationGroup(self.camera.frame.animate.move_to(VGroup(maze, blocks['output'])).scale(0.9), FadeIn(maze), FadeIn(theseus), FadeIn(door), WriteCode(blocks['output'])), AnimationGroup(AnimationGroup(*[FadeIn(n) for n in numbers_x], lag_ratio=0.051), AnimationGroup(*[FadeIn(n) for n in numbers_y], lag_ratio=0.051)), lag_ratio=0.5))\n        highlight = CreateHighlightCodeLine(blocks['output'], 1)\n        for i, step in enumerate(solution):\n            anim = None\n            if i == 0:\n                anim = FadeIn(highlight)\n            else:\n                anim = Transform(highlight, CreateHighlightCodeLine(blocks['output'], i + 1))\n            anim2 = None\n            if step == solution[-1]:\n                anim2 = theseus.animate.set_opacity(0).move_to(maze_dict[step])\n            else:\n                anim2 = theseus.animate.move_to(maze_dict[step])\n            maze_dict[step].set_z_index(0.05)\n            run_time = 1 if i <= 2 else FAST_RUNTIME\n            self.play(AnimationGroup(AnimationGroup(anim, anim2), maze_dict[step].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE), lag_ratio=0.33), run_time=run_time)"}]}
{"messages": [{"role": "user", "content": "Display the AOC logo and SVG, with parts of the SVG animating in a bobbing motion, then zoom into a highlighted section and fade to black."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass AOC(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        text = ImageMobject('assets/aoc/logo.png').set_height(0.75).shift(UP * 2)\n        aoc = SVGMobject('assets/aoc/aoc.svg').set_width(self.camera.frame.get_width() * 0.8).next_to(text, DOWN, buff=1)\n        seed(3735928559)\n        offsets = [uniform(0.05, 0.1) for _ in range(1000)]\n        offsets2 = [uniform(0, 2 * pi) for _ in range(1000)]\n        times = [0 for _ in range(1000)]\n        original_position = []\n\n        def bob(i, obj, dt):\n            times[i] += dt\n            offset = sin(self.renderer.time * pi + offsets2[(i - 1) // 3]) * offsets[(i - 1) // 3]\n            obj.move_to(original_position[i - 1] + UP * offset)\n        original_position.append(aoc[-1].get_center())\n        aoc[-1].add_updater(lambda x, dt: bob(1, x, dt))\n        original_position.append(aoc[-2].get_center())\n        aoc[-2].add_updater(lambda x, dt: bob(2, x, dt))\n        original_position.append(aoc[-3].get_center())\n        aoc[-3].add_updater(lambda x, dt: bob(3, x, dt))\n        original_position.append(aoc[-4].get_center())\n        aoc[-4].add_updater(lambda x, dt: bob(4, x, dt))\n        original_position.append(aoc[-5].get_center())\n        aoc[-5].add_updater(lambda x, dt: bob(5, x, dt))\n        original_position.append(aoc[-6].get_center())\n        aoc[-6].add_updater(lambda x, dt: bob(6, x, dt))\n        original_position.append(aoc[-7].get_center())\n        aoc[-7].add_updater(lambda x, dt: bob(7, x, dt))\n        original_position.append(aoc[-8].get_center())\n        aoc[-8].add_updater(lambda x, dt: bob(8, x, dt))\n        original_position.append(aoc[-9].get_center())\n        aoc[-9].add_updater(lambda x, dt: bob(9, x, dt))\n        original_position.append(aoc[-10].get_center())\n        aoc[-10].add_updater(lambda x, dt: bob(10, x, dt))\n        original_position.append(aoc[-11].get_center())\n        aoc[-11].add_updater(lambda x, dt: bob(11, x, dt))\n        original_position.append(aoc[-12].get_center())\n        aoc[-12].add_updater(lambda x, dt: bob(12, x, dt))\n        original_position.append(aoc[-13].get_center())\n        aoc[-13].add_updater(lambda x, dt: bob(13, x, dt))\n        original_position.append(aoc[-14].get_center())\n        aoc[-14].add_updater(lambda x, dt: bob(14, x, dt))\n        original_position.append(aoc[-15].get_center())\n        aoc[-15].add_updater(lambda x, dt: bob(15, x, dt))\n        original_position.append(aoc[-16].get_center())\n        aoc[-16].add_updater(lambda x, dt: bob(16, x, dt))\n        original_position.append(aoc[-17].get_center())\n        aoc[-17].add_updater(lambda x, dt: bob(17, x, dt))\n        original_position.append(aoc[-18].get_center())\n        aoc[-18].add_updater(lambda x, dt: bob(18, x, dt))\n        original_position.append(aoc[-19].get_center())\n        aoc[-19].add_updater(lambda x, dt: bob(19, x, dt))\n        original_position.append(aoc[-20].get_center())\n        aoc[-20].add_updater(lambda x, dt: bob(20, x, dt))\n        original_position.append(aoc[-21].get_center())\n        aoc[-21].add_updater(lambda x, dt: bob(21, x, dt))\n        original_position.append(aoc[-22].get_center())\n        aoc[-22].add_updater(lambda x, dt: bob(22, x, dt))\n        original_position.append(aoc[-23].get_center())\n        aoc[-23].add_updater(lambda x, dt: bob(23, x, dt))\n        original_position.append(aoc[-24].get_center())\n        aoc[-24].add_updater(lambda x, dt: bob(24, x, dt))\n        original_position.append(aoc[-25].get_center())\n        aoc[-25].add_updater(lambda x, dt: bob(25, x, dt))\n        original_position.append(aoc[-26].get_center())\n        aoc[-26].add_updater(lambda x, dt: bob(26, x, dt))\n        original_position.append(aoc[-27].get_center())\n        aoc[-27].add_updater(lambda x, dt: bob(27, x, dt))\n        original_position.append(aoc[-28].get_center())\n        aoc[-28].add_updater(lambda x, dt: bob(28, x, dt))\n        original_position.append(aoc[-29].get_center())\n        aoc[-29].add_updater(lambda x, dt: bob(29, x, dt))\n        original_position.append(aoc[-30].get_center())\n        aoc[-30].add_updater(lambda x, dt: bob(30, x, dt))\n        original_position.append(aoc[-31].get_center())\n        aoc[-31].add_updater(lambda x, dt: bob(31, x, dt))\n        original_position.append(aoc[-32].get_center())\n        aoc[-32].add_updater(lambda x, dt: bob(32, x, dt))\n        original_position.append(aoc[-33].get_center())\n        aoc[-33].add_updater(lambda x, dt: bob(33, x, dt))\n        original_position.append(aoc[-34].get_center())\n        aoc[-34].add_updater(lambda x, dt: bob(34, x, dt))\n        original_position.append(aoc[-35].get_center())\n        aoc[-35].add_updater(lambda x, dt: bob(35, x, dt))\n        original_position.append(aoc[-36].get_center())\n        aoc[-36].add_updater(lambda x, dt: bob(36, x, dt))\n        original_position.append(aoc[-37].get_center())\n        aoc[-37].add_updater(lambda x, dt: bob(37, x, dt))\n        original_position.append(aoc[-38].get_center())\n        aoc[-38].add_updater(lambda x, dt: bob(38, x, dt))\n        original_position.append(aoc[-39].get_center())\n        aoc[-39].add_updater(lambda x, dt: bob(39, x, dt))\n        original_position.append(aoc[-40].get_center())\n        aoc[-40].add_updater(lambda x, dt: bob(40, x, dt))\n        original_position.append(aoc[-41].get_center())\n        aoc[-41].add_updater(lambda x, dt: bob(41, x, dt))\n        original_position.append(aoc[-42].get_center())\n        aoc[-42].add_updater(lambda x, dt: bob(42, x, dt))\n        self.play(Succession(AnimationGroup(FadeIn(aoc), FadeIn(text)), Wait(1.65)))\n        highlight = CreateHighlight(aoc[0:50])\n        aoc.set_z_index(10000)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(highlight), FadeIn(highlight), lag_ratio=0.25))\n        self.remove(text)\n        rect = get_fade_rect(opacity=1)\n        self.play(AnimationGroup(self.camera.frame.animate(run_time=1, rate_func=rush_into).scale(0.01), AnimationGroup(FadeIn(rect), run_time=0.2), lag_ratio=0.8))"}]}
{"messages": [{"role": "user", "content": "Simulate a robot mining operation, displaying resource acquisition and robot production over time."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass Robots(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.camera.frame.save_state()\n        robots = VGroup(*[SVGMobject('assets/robot-ore.svg'), SVGMobject('assets/robot-clay.svg'), SVGMobject('assets/robot-obsidian.svg'), SVGMobject('assets/robot-geode.svg')]).arrange(buff=0.8)\n        minerals = Group(*[ImageMobject('assets/minerals/ore.png'), ImageMobject('assets/minerals/clay.png'), ImageMobject('assets/minerals/obsidian.png'), ImageMobject('assets/minerals/geode.png')])\n        robot_counts = VGroup(*[Tex(4).next_to(robots[0], DOWN), Tex(0).next_to(robots[1], DOWN), Tex(0).next_to(robots[2], DOWN), Tex(0).next_to(robots[3], DOWN)])\n        for m, r in zip(minerals, robots):\n            m.set_height(1).next_to(r, UP)\n        self.camera.frame.move_to(Group(minerals, robots))\n        mineral_counts = VGroup(*[Tex('\\\\textbf{0}').move_to(minerals[0]).set_z_index(1), Tex('\\\\textbf{0}').move_to(minerals[1]).set_z_index(1), Tex('\\\\textbf{0}').move_to(minerals[2]).set_z_index(1), Tex('\\\\textbf{0}').move_to(minerals[3]).set_z_index(1)])\n        self.play(AnimationGroup(*[FadeIn(r, shift=DOWN * 0.25) for r in robots], lag_ratio=0.1))\n        for i in range(4):\n            self.play(FadeIn(minerals[i], shift=UP * 0.25), FadeIn(mineral_counts[i], shift=UP * 0.25), run_time=0.5)\n        minute_text = Tex('Minute:').scale(1.5)\n        minute_count = Tex('\\\\textbf{0}').scale(1.5).next_to(minute_text, RIGHT).align_to(minute_text, DOWN)\n        VGroup(minute_text, minute_count).next_to(minerals, UP, buff=1)\n        self.play(AnimationGroup(AnimationGroup(self.camera.frame.animate.move_to(VGroup(minute_text, robot_counts)), robots[1].animate.set_opacity(BIG_OPACITY), robots[2].animate.set_opacity(BIG_OPACITY), robots[3].animate.set_opacity(BIG_OPACITY), minerals[1].animate.set_opacity(BIG_OPACITY), minerals[2].animate.set_opacity(BIG_OPACITY), minerals[3].animate.set_opacity(BIG_OPACITY), mineral_counts[1].animate.set_opacity(BIG_OPACITY), mineral_counts[2].animate.set_opacity(BIG_OPACITY), mineral_counts[3].animate.set_opacity(BIG_OPACITY), run_time=1), AnimationGroup(*[FadeIn(c, shift=DOWN * 0.1) for c in robot_counts], Write(minute_text), FadeIn(minute_count)), lag_ratio=0.5))\n        for i in range(1):\n            minute_count_1 = Tex('\\\\textbf{' + str(i + 1) + '}').scale(1.5).move_to(minute_count)\n            self.play(FadeOut(minute_count, shift=UP * 0.65), FadeIn(minute_count_1, shift=UP * 0.65))\n            minute_count = minute_count_1\n            self.play(robots[0].animate(rate_func=ROBOT_RATE_FUNC).next_to(minerals[0], DOWN, buff=0), minerals[0].animate(rate_func=MINERAL_RATE_FUNC).shift(UP * 0.08), Increment(mineral_counts[0], 4 * (i + 1), 0.08), run_time=1)\n        a = Tex(4).scale(0.8)\n        b = minerals[0].copy().set_opacity(1).set_height(a.get_height()).next_to(a, buff=0.05)\n        ore_cost = Group(a, b)\n        a = Tex(2).scale(0.8)\n        b = minerals[0].copy().set_opacity(1).set_height(a.get_height()).next_to(a, buff=0.05)\n        clay_cost = Group(a, b)\n        a = Tex(3).scale(0.8)\n        b = minerals[0].copy().set_opacity(1).set_height(a.get_height()).next_to(a, buff=0.05)\n        p = Tex('+').scale(0.8)\n        c = Tex(14).scale(0.8)\n        d = minerals[1].copy().set_opacity(1).set_height(c.get_height()).next_to(c, buff=0.05)\n        obsidian_cost = Group(Group(a, b), p, Group(c, d)).arrange(buff=0.1)\n        a = Tex(2).scale(0.8)\n        b = minerals[0].copy().set_opacity(1).set_height(a.get_height()).next_to(a, buff=0.05)\n        p = Tex('+').scale(0.8)\n        c = Tex(7).scale(0.8)\n        d = minerals[2].copy().set_opacity(1).set_height(c.get_height()).next_to(c, buff=0.05)\n        geode_cost = Group(Group(a, b), p, Group(c, d)).arrange(buff=0.1)\n        robot_costs = Group(*[ore_cost.next_to(robot_counts[0], DOWN, buff=0.5), clay_cost.next_to(robot_counts[1], DOWN, buff=0.5), obsidian_cost.next_to(robot_counts[2], DOWN, buff=0.5), geode_cost.next_to(robot_counts[3], DOWN, buff=0.5), geode_cost.copy().next_to(robot_counts[0], DOWN, buff=0.5)])\n        self.play(self.camera.frame.animate.move_to(Group(minute_text, robot_costs)).scale(1.15), FadeIn(robot_costs[0], shift=DOWN * 0.25))\n        self.play(FadeIn(robot_costs[1], shift=DOWN * 0.25))\n        self.play(FadeIn(robot_costs[2], shift=DOWN * 0.25))\n        self.play(FadeIn(robot_costs[3], shift=DOWN * 0.25))\n        command = 1\n\n        def rot(obj, dt):\n            obj.rotate(-dt)\n        gear = SVGMobject('assets/gear.svg').set_height(robot_counts[command].get_height()).next_to(robot_counts[command], RIGHT)\n        gear.add_updater(rot)\n        minute_count_1 = Tex('\\\\textbf{2}').scale(1.5).move_to(minute_count)\n        self.play(FadeOut(minute_count, shift=UP * 0.65), FadeIn(minute_count_1, shift=UP * 0.65))\n        minute_count = minute_count_1\n        self.play(Succession(AnimationGroup(FadeIn(gear, shift=RIGHT * 0.25), Transform(mineral_counts[0], Tex('\\\\textbf{2}').move_to(mineral_counts[0])), minerals[0].animate(rate_func=there_and_back).scale(0.75)), Wait(2.58)))\n        self.play(Succession(AnimationGroup(robots[0].animate(rate_func=ROBOT_RATE_FUNC).next_to(minerals[0], DOWN, buff=0), minerals[0].animate(rate_func=MINERAL_RATE_FUNC).shift(UP * 0.08), Increment(mineral_counts[0], 6, 0.08), run_time=1), Wait(1.46)))\n        self.play(robots[command].animate.set_opacity(1), minerals[command].animate.set_opacity(1), mineral_counts[command].animate.set_opacity(1), Transform(robot_counts[command], Tex(1).move_to(robot_counts[command])), FadeOut(gear, shift=RIGHT * 0.25))\n        minute_count_1 = Tex('\\\\textbf{' + str(0) + '}').scale(1.5).move_to(minute_count)\n        self.play(FadeOut(minute_count, shift=DOWN * 0.65), FadeIn(minute_count_1, shift=DOWN * 0.65), robots[0].animate.set_opacity(1), robots[1].animate.set_opacity(BIG_OPACITY), robots[2].animate.set_opacity(BIG_OPACITY), robots[3].animate.set_opacity(BIG_OPACITY), minerals[0].animate.set_opacity(1), minerals[1].animate.set_opacity(BIG_OPACITY), minerals[2].animate.set_opacity(BIG_OPACITY), minerals[3].animate.set_opacity(BIG_OPACITY), mineral_counts[0].animate.set_opacity(1), mineral_counts[1].animate.set_opacity(BIG_OPACITY), mineral_counts[2].animate.set_opacity(BIG_OPACITY), mineral_counts[3].animate.set_opacity(BIG_OPACITY), Transform(robot_counts[0], Tex(1).move_to(robot_counts[0])), Transform(robot_counts[1], Tex(0).move_to(robot_counts[1])), Transform(mineral_counts[0], Tex('\\\\textbf{0}').move_to(mineral_counts[0])), Transform(mineral_counts[1], Tex('\\\\textbf{0}').move_to(mineral_counts[1])))\n        minute_count = minute_count_1\n        g = VGroup(minute_count, minute_text)\n        q = Tex('\\\\textit{Maximize geodes in 24 minutes.}').move_to(g)\n        gc = g.copy()\n        cp = VGroup(gc, q).arrange(buff=2).move_to(g)\n        self.play(AnimationGroup(g.animate.move_to(gc), Write(q, run_time=1.25), lag_ratio=0.75))\n        materials_array = [0, 0, 0, 0]\n        robots_array = [1, 0, 0, 0]\n        commands = [None, None, 1, None, 1, None, 1, None, None, None, 2, 1, None, None, 2, None, None, 3, None, None, 3, None, None, None]\n        for i, command in enumerate(commands):\n            minute_count_1 = Tex('\\\\textbf{' + str(i + 1) + '}').scale(1.5).next_to(minute_text, RIGHT).align_to(minute_text, DOWN)\n            self.play(FadeOut(minute_count, shift=UP * 0.65), FadeIn(minute_count_1, shift=UP * 0.65))\n            minute_count = minute_count_1\n            if command is not None:\n                animations = []\n\n                def rot(obj, dt):\n                    obj.rotate(-dt)\n                gear = SVGMobject('assets/gear.svg').set_height(robot_counts[command].get_height()).next_to(robot_counts[command], RIGHT)\n                gear.add_updater(rot)\n                animations.append(FadeIn(gear, shift=RIGHT * 0.25))\n                prev_materials_array = list(materials_array)\n                if command == 0:\n                    materials_array[0] -= 4\n                if command == 1:\n                    materials_array[0] -= 2\n                if command == 2:\n                    materials_array[0] -= 3\n                    materials_array[1] -= 14\n                if command == 3:\n                    materials_array[0] -= 2\n                    materials_array[2] -= 7\n                for j in range(4):\n                    if prev_materials_array[j] != materials_array[j]:\n                        animations.append(Transform(mineral_counts[j], Tex('\\\\textbf{' + str(materials_array[j]) + '}').move_to(mineral_counts[j])))\n                        animations.append(minerals[j].animate(rate_func=there_and_back).scale(0.75))\n                self.play(*animations, run_time=1)\n            for j in range(4):\n                materials_array[j] += robots_array[j]\n            animations = []\n            for j, robot in enumerate(robots_array):\n                if robot != 0:\n                    animations += [robots[j].animate(rate_func=ROBOT_RATE_FUNC).next_to(minerals[j], DOWN, buff=0), minerals[j].animate(rate_func=MINERAL_RATE_FUNC).shift(UP * 0.08), Increment(mineral_counts[j], materials_array[j], 0.08)]\n            self.play(*animations, run_time=1)\n            animations = []\n            if command is not None:\n                robots_array[command] += 1\n                if robots_array[command] == 1:\n                    animations.append(robots[command].animate.set_opacity(1))\n                    animations.append(minerals[command].animate.set_opacity(1))\n                    animations.append(mineral_counts[command].animate.set_opacity(1))\n                animations.append(Transform(robot_counts[command], Tex(robots_array[command]).move_to(robot_counts[command])))\n                prev_materials_array = list(materials_array)\n                self.play(*animations, FadeOut(gear, shift=RIGHT * 0.25), Transform(robot_counts[j], Tex(robots_array[j]).move_to(robot_counts[j])), run_time=1)\n        rect = get_fade_rect()\n        self.play(Circumscribe(minerals[-1], color=WHITE, buff=-0.08, shape=Circle))\n        canhe = Tex('\\\\underline{What are the states/neighbours?}').scale(1.5).move_to(self.camera.frame).set_z_index(10000000)\n        self.play(AnimationGroup(FadeIn(rect), FadeIn(canhe), lag_ratio=0.5))\n        self.play(FadeOut(rect), FadeOut(canhe))\n\n        def vertex_from_state(state):\n            text = Tex('$$' + str(state) + '$$').set_z_index(10)\n            g = Group(text)\n            start = 1 + len(str(state[0])) + 2\n            for i in range(4):\n                s = start\n                e = start + len(str(state[1][i]))\n                g.add(minerals[i].copy().set_height(text.get_height() * 0.5).next_to(text[0][s:e], UP, buff=0.05).set_z_index(10))\n                start += len(str(state[1][i])) + 1\n            start += 2\n            for i in range(4):\n                s = start\n                e = start + len(str(state[2][i]))\n                g.add(robots[i].copy().set_height(text.get_height() * 0.5).next_to(text[0][s:e], UP, buff=0.05).set_z_index(10))\n                start += len(str(state[2][i])) + 1\n            return g\n        root = (24, (6, 41, 8, 9), (1, 4, 2, 2))\n        g = vertex_from_state(root).scale(1.5)\n        g.move_to(self.camera.frame)\n        self.play(AnimationGroup(AnimationGroup(Transform(robots[0], g[0][0]), Transform(robots[0], g[1 + 4 + 0]), Transform(robots[1], g[1 + 4 + 1]), Transform(robots[2], g[1 + 4 + 2]), Transform(robots[3], g[1 + 4 + 3]), Transform(minerals[0], g[1 + 0]), Transform(minerals[1], g[1 + 1]), Transform(minerals[2], g[1 + 2]), Transform(minerals[3], g[1 + 3]), FadeTransform(mineral_counts[0], g[0][0][5]), FadeTransform(mineral_counts[1], g[0][0][7:9]), FadeTransform(mineral_counts[2], g[0][0][10]), FadeTransform(mineral_counts[3], g[0][0][12]), FadeTransform(robot_counts[0], g[0][0][16]), FadeTransform(robot_counts[1], g[0][0][18]), FadeTransform(robot_counts[2], g[0][0][20]), FadeTransform(robot_counts[3], g[0][0][22])), AnimationGroup(FadeIn(g[0][0][4]), FadeIn(g[0][0][6]), FadeIn(g[0][0][9]), FadeIn(g[0][0][11]), FadeIn(g[0][0][13]), FadeIn(g[0][0][14]), FadeIn(g[0][0][15]), FadeIn(g[0][0][17]), FadeIn(g[0][0][19]), FadeIn(g[0][0][21]), FadeIn(g[0][0][23])), lag_ratio=0.75))\n        self.play(AnimationGroup(FadeOut(minute_text), AnimationGroup(FadeTransform(minute_count[0][0], g[0][0][1]), FadeTransform(minute_count[0][1], g[0][0][2]), q.animate.move_to(Group(q, minute_text))), AnimationGroup(FadeIn(g[0][0][0]), FadeIn(g[0][0][3]), FadeIn(g[0][0][-1])), lag_ratio=0.5))\n        self.play(FadeOut(q), FadeOut(robot_costs[:4]))\n        for o in self.mobjects:\n            self.remove(o)\n        tree, state_objects, state_bgs = actually_get_tree(25, root, 0.159)\n        self.camera.frame.scale(1 / 1.5)\n        self.camera.frame.move_to(state_objects[root])\n        self.add(state_objects[root])\n        ng = Group(*[state_objects[s] for s in state_objects if s != root])\n        for s in state_bgs:\n            self.add(state_bgs[s])\n        states = [root, (25, (4, 31, 10, 11), (1, 4, 3, 2)), (25, (3, 45, 10, 11), (2, 4, 2, 2)), (25, (7, 45, 10, 11), (1, 4, 2, 2)), (25, (5, 45, 3, 11), (1, 4, 2, 3)), (25, (5, 45, 10, 11), (1, 5, 2, 2))]\n\n        def get_edge(a, b):\n            return (a, b) if (a, b) in tree.edges else (b, a)\n        tree.suspend_updating()\n        tree.edges[get_edge(states[0], states[3])].rotate(pi)\n        robot_edges = Group(*[robots[0].copy().set_height(state_objects[root].get_height() * 0.8).move_to(Group(state_objects[states[0]], state_objects[states[2]])), robots[1].copy().set_height(state_objects[root].get_height() * 0.8).move_to(Group(state_objects[states[0]], state_objects[states[5]])), robots[2].copy().set_height(state_objects[root].get_height() * 0.8).move_to(Group(state_objects[states[0]], state_objects[states[1]])), robots[3].copy().set_height(state_objects[root].get_height() * 0.8).move_to(Group(state_objects[states[0]], state_objects[states[4]]))])\n        b = Tex('Branching factor').scale(3)\n        f = Tex('Average number of neighbouring states.').scale(1.5).next_to(b, DOWN, buff=0.5)\n        bf = VGroup(b, f).next_to(ng, LEFT, buff=3)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(ng).set_height(ng.get_height() * 1.3), AnimationGroup(AnimationGroup(*[Create(tree.edges[e]) for e in tree.edges], FadeIn(ng)), FadeIn(robot_edges), lag_ratio=0.25), lag_ratio=0.5))\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(Group(ng, bf)).set_width(Group(ng, bf).get_width() * 1.25), FadeIn(b, run_time=1), lag_ratio=0.5))\n        self.play(Write(f, run_time=1.5))\n        wat = vertex_from_state((0, (0, 0, 0, 0), (1, 0, 0, 0))).move_to(state_objects[root])\n        self.play(AnimationGroup(AnimationGroup(FadeOut(f), FadeOut(b), FadeOut(robot_edges), FadeOut(ng), *[FadeOut(tree.edges[e]) for e in tree.edges], Transform(state_objects[root][1:], wat[1:]), Transform(state_objects[root][0], wat[0])), AnimationGroup(self.camera.frame.animate.restore()), lag_ratio=0.5))"}]}
{"messages": [{"role": "user", "content": "Visualize the growth of a tree-like structure, highlighting path segments and then showing pruning and prioritization concepts with text overlays and graph transformations."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass RobotGraph(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        root = (0, (0, 0, 0, 0), (1, 0, 0, 0))\n        tree, state_objects, state_bgs = actually_get_tree(8, root, -pi / 4, [(8, (3, 0, 0, 0), (3, 0, 0, 0))])\n        self.add(state_bgs[root])\n        self.play(FadeIn(state_objects[root]))\n\n        def neighbours(vertex):\n            n = []\n            for a, b in tree.edges:\n                if vertex == a:\n                    n.append(b)\n                elif vertex == b:\n                    n.append(a)\n            return n\n\n        def get_neighbours(vertices):\n            \"\"\"Return new vertices and corresponding edges.\"\"\"\n            new_vertices = []\n            new_edges = []\n            for v in vertices:\n                for neighbour in neighbours(v):\n                    if v[0] > neighbour[0]:\n                        continue\n                    if neighbour not in new_vertices and neighbour not in vertices:\n                        new_vertices.append(neighbour)\n                        a = neighbour\n                        b = v\n                        new_edges.append((a, b) if (a, b) in tree.edges else (b, a))\n            return (new_edges, new_vertices)\n\n        def reverse_get_neighbours(vertices):\n            \"\"\"Return new vertices and corresponding edges.\"\"\"\n            new_vertices = []\n            new_edges = []\n            for v in vertices:\n                for neighbour in neighbours(v):\n                    if v[0] < neighbour[0]:\n                        continue\n                    if neighbour not in new_vertices and neighbour not in vertices:\n                        new_vertices.append(neighbour)\n                        a = neighbour\n                        b = v\n                        new_edges.append((a, b) if (a, b) in tree.edges else (b, a))\n            return (new_edges, new_vertices)\n        vertices = [root]\n        edges = []\n        initial_thickness = 1\n        last_thickness = None\n        for i in range(7):\n            new_edges, new_vertices = get_neighbours(vertices)\n            animations = []\n            for v in new_vertices:\n                animations.append(FadeIn(state_objects[v]))\n            for e in new_edges:\n                animations.append(Create(tree.edges[e]))\n            vertices += new_vertices\n            edges += new_edges\n            g = Group(*[state_objects[v] for v in vertices])\n            for v in new_vertices:\n                self.add(state_bgs[v])\n            w_size = g.get_width() * 1.5\n            h_size = g.get_height() * 1.2\n            if w_size / self.camera.frame.get_width() > h_size / self.camera.frame.get_height():\n                camera_anim = self.camera.frame.animate(run_time=1.33333).move_to(g).set_width(w_size)\n            else:\n                camera_anim = self.camera.frame.animate(run_time=1.33333).move_to(g).set_height(h_size)\n            last_thickness = initial_thickness * (g.get_width() * 1.8) ** (1 / 2)\n            self.play(AnimationGroup(AnimationGroup(camera_anim, *[tree.edges[e].animate.set_stroke_width(last_thickness) for e in edges]), AnimationGroup(*animations, run_time=0.99), lag_ratio=0.25))\n        graph, numbers, labels, bars = cool_graphy_graphy(15)\n        better_g = VGroup(graph, labels, numbers, bars).set_height(self.camera.frame.get_height() * 0.26)\n        scf = self.camera.frame\n        better_g.move_to(Dot().align_to(g, RIGHT)).align_to(g, UP).shift((DOWN + LEFT) * g.get_height() * 0.05)\n        self.play(AnimationGroup(scf.animate.move_to(Group(better_g, *[state_objects[v] for v in vertices])), AnimationGroup(Write(graph), StretchUp(bars[0])), AnimationGroup(FadeIn(numbers[0]), FadeIn(labels[0])), lag_ratio=0.5))\n        rect = get_fade_rect()\n        myTemplate = TexTemplate()\n        myTemplate.add_to_preamble('\\\\usepackage{soul}')\n        pruning = Tex('\\\\ul{Pruning}', tex_template=myTemplate).move_to(self.camera.frame).set_height(self.camera.frame.get_height() * 0.1).set_z_index(10000000)\n        prioritization = Tex('\\\\ul{Prioritization}', tex_template=myTemplate).move_to(self.camera.frame).set_height(self.camera.frame.get_height() * 0.1).set_z_index(10000000)\n        pp = VGroup(pruning, prioritization).arrange(buff=0.1 * self.camera.frame.get_width()).move_to(self.camera.frame)\n        self.play(AnimationGroup(FadeIn(rect), FadeIn(pp), lag_ratio=0.5))\n        cp = pruning.copy().scale(0.75).move_to(Dot().align_to(g, LEFT)).align_to(g, UP).shift(DOWN * g.get_height() * 0.08)\n        self.play(AnimationGroup(FadeOut(prioritization), AnimationGroup(FadeOut(rect), Transform(pruning, cp), scf.animate.move_to(Group(better_g, *[state_objects[v] for v in vertices], cp))), lag_ratio=0.5))\n        badpath = [(0, (0, 0, 0, 0), (1, 0, 0, 0)), (1, (1, 0, 0, 0), (1, 0, 0, 0)), (2, (2, 0, 0, 0), (1, 0, 0, 0)), (3, (3, 0, 0, 0), (1, 0, 0, 0)), (4, (4, 0, 0, 0), (1, 0, 0, 0)), (5, (1, 0, 0, 0), (2, 0, 0, 0)), (6, (3, 0, 0, 0), (2, 0, 0, 0)), (7, (5, 0, 0, 0), (2, 0, 0, 0)), (8, (3, 0, 0, 0), (3, 0, 0, 0)), (9, (6, 0, 0, 0), (3, 0, 0, 0))]\n\n        def get_edge(a, b):\n            return (a, b) if (a, b) in tree.edges else (b, a)\n        an = []\n        for i in range(len(badpath) - 1):\n            e = tree.edges[get_edge(badpath[i], badpath[i + 1])]\n            e.set_stroke_width(last_thickness)\n            e.save_state()\n            an.append(e.animate.set_color(numbers[1].get_color()).set_stroke_width(last_thickness * 3))\n        vertices = [badpath[7]]\n        animations = []\n        for i in range(5):\n            new_edges, new_vertices = get_neighbours(vertices)\n            for v in new_vertices:\n                self.add(state_bgs[v])\n            for v in new_vertices:\n                animations.append(FadeIn(state_objects[v]))\n                state_objects[v].set_z_index(state_bgs[v].get_z_index())\n            for e in new_edges:\n                tree.edges[e].set_stroke_width(last_thickness)\n                if e not in badpath:\n                    animations.append(FadeIn(tree.edges[e]))\n            vertices = new_vertices\n        self.play(*animations, AnimationGroup(*an))\n        an = []\n        for i in range(len(badpath) - 1):\n            e = tree.edges[get_edge(badpath[i], badpath[i + 1])]\n            an.append(e.animate.restore())\n        vertices = [badpath[7]]\n        animations = []\n        for i in range(5):\n            new_edges, new_vertices = get_neighbours(vertices)\n            for v in new_vertices:\n                animations.append(FadeOut(state_objects[v]))\n            for e in new_edges:\n                animations.append(FadeOut(tree.edges[e]))\n            vertices = new_vertices\n        new_edges, _ = reverse_get_neighbours([badpath[7]])\n        animations.append(FadeOut(state_objects[badpath[7]]))\n        for e in new_edges:\n            animations.append(FadeOut(tree.edges[e]))\n        self.play(AnimationGroup(AnimationGroup(*an, *animations, StretchUp(bars[1])), AnimationGroup(FadeIn(numbers[1]), FadeIn(labels[1])), lag_ratio=0.5))\n        cut = [(7, (1, 3, 0, 0), (2, 1, 0, 0)), (7, (1, 3, 0, 0), (1, 3, 0, 0)), (7, (5, 2, 0, 0), (1, 1, 0, 0)), (7, (5, 1, 0, 0), (1, 1, 0, 0)), (7, (7, 0, 0, 0), (1, 0, 0, 0)), (7, (1, 6, 0, 0), (1, 3, 0, 0)), (7, (1, 5, 0, 0), (1, 3, 0, 0)), (7, (5, 4, 0, 0), (1, 1, 0, 0))]\n        animations = []\n        new_edges, new_vertices = reverse_get_neighbours(cut)\n        for v in cut:\n            animations.append(FadeOut(state_objects[v]))\n        for e in new_edges:\n            animations.append(FadeOut(tree.edges[e]))\n        self.play(AnimationGroup(AnimationGroup(*animations, StretchUp(bars[2])), AnimationGroup(FadeIn(numbers[2]), FadeIn(labels[2])), lag_ratio=0.5))\n        prioritization.move_to(pruning)\n        prcp = prioritization.copy()\n        prioritization.scale(0.75).align_to(prcp, LEFT)\n        pr = pruning.copy().next_to(prioritization, DOWN, buff=0).align_to(prioritization, LEFT)\n        ad = Tex('and').set_height(prioritization.get_height() * 0.35).move_to(pr)\n        self.play(AnimationGroup(AnimationGroup(pruning.animate.next_to(pr, DOWN, buff=0).align_to(prioritization, LEFT), self.camera.frame.animate.move_to(VGroup(prioritization, tree, graph)).scale(1.1)), AnimationGroup(FadeIn(prioritization), FadeIn(ad)), lag_ratio=0.5))\n        self.play(self.camera.frame.animate.move_to(better_g).set_height(better_g.get_height() * 1.25))\n        self.play(AnimationGroup(AnimationGroup(StretchUp(bars[3])), AnimationGroup(FadeIn(numbers[3]), FadeIn(labels[3])), lag_ratio=0.5))"}]}
{"messages": [{"role": "user", "content": "Simulate a maze-solving algorithm with visuals of Theseus and the Minotaur navigating a maze."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass BeegMaze(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        with open('maze/mask.txt') as f:\n            contents = f.read().splitlines()\n        theseus = ImageMobject('assets/theseus-nobackground.png').set_height(0.8).set_z_index(100)\n        theseus_position = (22, 9)\n        theseus_text = Tex('Theseus').next_to(theseus, DOWN, buff=-0.08).scale(0.25)\n        theseus_miniature = ImageMobject('assets/theseus-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (theseus_position[0] + 0.5) + DOWN * (theseus_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.camera.frame.move_to(Group(theseus, theseus_text)).set_height(theseus.height * 2)\n        self.play(AnimationGroup(FadeIn(theseus), FadeIn(theseus_text, lag_ratio=0.1), lag_ratio=0.5))\n        minotaur = ImageMobject('assets/minotaur-nobackground.png').set_height(0.8).next_to(theseus, RIGHT, buff=0.3).set_z_index(100)\n        minotaur_position = (27, 9)\n        minotaur_text = Tex('Minotaur').next_to(minotaur, DOWN, buff=-0.08).scale(0.25)\n        minotaur_miniature = ImageMobject('assets/minotaur-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (minotaur_position[0] + 0.5) + DOWN * (minotaur_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(Group(theseus, minotaur)).scale(1.25), AnimationGroup(FadeIn(minotaur), FadeIn(minotaur_text, lag_ratio=0.1), lag_ratio=0.5), lag_ratio=0.25))\n        maze, maze_dict = maze_to_vgroup(contents)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(theseus_text), FadeOut(minotaur_text)), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)).set_height(maze.height * 0.3), FadeTransform(theseus, theseus_miniature), FadeTransform(minotaur, minotaur_miniature)), AnimationGroup(FadeIn(maze)), lag_ratio=0.5, run_time=2))\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2))\n        for i in range(1):\n            self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(LEFT), minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2), theseus_miniature.animate.shift(LEFT))\n        rect = get_fade_rect()\n        canhe = Tex('\\\\underline{Can he get out?}').scale(1.25).next_to(Group(theseus_miniature, minotaur_miniature), UP, buff=0.25).set_z_index(10000000)\n        self.play(AnimationGroup(FadeIn(rect), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature, canhe)), FadeIn(canhe, shift=UP * 0.25)), lag_ratio=0.5))\n        self.play(FadeOut(rect), FadeOut(canhe), self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)))\n        self.play(Flash(minotaur_miniature, color=WHITE), FadeOut(minotaur_miniature))\n        self.play(self.camera.frame.animate.move_to(maze).set_height(maze.height * 1.25), run_time=1.5)\n        shortest_path = [(21, 9), (22, 9), (23, 9), (24, 9), (25, 9), (26, 9), (27, 9), (27, 10), (27, 11), (27, 12), (27, 13), (27, 14), (27, 15), (28, 15), (29, 15), (30, 15), (31, 15), (32, 15), (33, 15), (34, 15), (35, 15), (36, 15), (37, 15), (37, 16), (37, 17), (38, 17), (39, 17), (39, 16), (39, 15), (40, 15)]\n        theseus_miniature.set_z_index(10000)\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE) for p in shortest_path], lag_ratio=0.02))\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(WHITE, 0).set_stroke_color(WHITE) for p in shortest_path]))\n        bfs_text = Tex('BFS').scale(5).next_to(maze, RIGHT, buff=1.5).align_to(maze, UP).shift(DOWN)\n        astar_text = Tex('A*').scale(5).move_to(bfs_text)\n        q = Queue(scale=2).next_to(bfs_text, DOWN, buff=2)\n        self.play(FadeIn(q), FadeIn(bfs_text), self.camera.frame.animate.move_to(Group(maze, theseus_miniature, q, bfs_text)), run_time=1)\n        theseus_position = (theseus_position[0] - 1, theseus_position[1])\n        escape = (40, 15)\n        queue = [(0, theseus_position)]\n        discovered = {theseus_position: None}\n\n        def is_valid(position):\n            x, y = position\n            return 0 <= x < len(contents[0]) and 0 <= y < len(contents) and (contents[y][x] != '.')\n\n        def next_states(position):\n            x, y = position\n            states = []\n            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                nx = x + dx\n                ny = y + dy\n                if not is_valid((nx, ny)):\n                    continue\n                if contents[ny][nx] == ' ':\n                    states.append((1, (nx, ny)))\n                else:\n                    states.append((10, (nx, ny)))\n            return states\n\n        def animate_discover(states):\n            for p in states:\n                if contents[p[1]][p[0]] != ' ':\n                    maze_dict[p].set_z_index(5000)\n            return AnimationGroup(*[maze_dict[p].animate.set_fill(BLUE if contents[p[1]][p[0]] == ' ' else DARK_BLUE, 0.75).set_stroke_color(BLUE if contents[p[1]][p[0]] == ' ' else DARK_BLUE) for p in states])\n\n        def animate_leave(state):\n            p = state\n            if contents[p[1]][p[0]] != ' ':\n                maze_dict[p].set_z_index(3000)\n            return maze_dict[state].animate.set_fill(LIGHT_GRAY if contents[p[1]][p[0]] == ' ' else GRAY, 0.75).set_stroke_color(LIGHT_GRAY if contents[p[1]][p[0]] == ' ' else GRAY).set_z_index(3 if contents[p[1]][p[0]] == ' ' else 3000)\n\n        def animate_add_to_queue(states):\n            fade_froms = [maze_dict[s] for s in states]\n            state_texs = [Tex(s) for s in states]\n            return q.animate_add_from(state_texs, fade_froms)\n\n        def animate_pop(state):\n            p = state\n            if contents[p[1]][p[0]] != ' ':\n                maze_dict[p].set_z_index(2000)\n            return maze_dict[state].animate.set_fill(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN, 0.75).set_stroke_color(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN).set_z_index(2 if contents[p[1]][p[0]] == ' ' else 2000)\n\n        def stop_condition(state):\n            return state == escape\n        i = 1\n\n        def add_neighbours(distance, position):\n            states = []\n            for next_distance, next_state in next_states(position):\n                if next_state not in discovered:\n                    discovered[next_state] = position\n                    queue.append((distance + next_distance, next_state))\n                    states.append(next_state)\n            if len(states) != 0:\n                self.play(animate_leave(current), animate_discover(states))\n            else:\n                self.play(animate_leave(current))\n        self.play(FadeOut(q), FadeOut(bfs_text), self.camera.frame.animate.move_to(maze), run_time=1)\n        self.next_section()\n        seed(3134975699)\n        for i in range(len(contents)):\n            contents[i] = list(contents[i])\n        blocks = []\n        for _ in range(40):\n            x, y = (0, 0)\n            while contents[y][x] != ' ' or (x, y) == theseus_position or (x, y) == escape:\n                x, y = (randint(0, len(contents[0]) - 1), randint(0, len(contents) - 1))\n            blocks.append((x, y))\n            contents[y][x] = '#'\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(WHITE, 1).set_stroke_color(WHITE).set_z_index(10000) for p in blocks], lag_ratio=0.02))\n        i = 0\n        ten = VGroup(maze_dict[x, y].copy().set_stroke_width(10).set_stroke_width(10).scale(1.75), Tex('10 steps').scale(2)).arrange(DOWN, buff=0.5)\n        one = VGroup(maze_dict[x, y].copy().set_fill(WHITE, 0).set_stroke_width(10).scale(1.75), Tex('1 step').scale(2)).arrange(DOWN, buff=0.5)\n        VGroup(ten, one).arrange(DOWN, buff=3).next_to(maze, RIGHT, buff=3)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(VGroup(maze, one, ten)), AnimationGroup(FadeIn(ten), FadeIn(one)), lag_ratio=0.5))\n        rect = get_fade_rect()\n        problem = Tex('\\\\textbf{Problem}: order in queue $\\\\neq$ distance from start').scale(3.5).set_z_index(10000001)\n        solution = Tex('\\\\textbf{Solution}: use a \\\\textit{priority queue}').scale(3.5).set_z_index(10000001)\n        VGroup(problem, solution).arrange(DOWN, buff=1.5).move_to(self.camera.frame)\n        self.play(AnimationGroup(FadeIn(rect), FadeIn(problem), lag_ratio=0.5))\n        self.play(FadeIn(solution))\n        self.play(FadeOut(rect), FadeOut(problem), FadeOut(solution))\n        self.next_section()\n        while len(queue) != 0:\n            distance, current = queue.pop(0)\n            i += 1\n            a = animate_pop(current)\n            self.play(a)\n            if stop_condition(current):\n                path = [current]\n                while discovered[current] is not None:\n                    current = discovered[current]\n                    path.append(current)\n                break\n            add_neighbours(distance, current)\n            queue = sorted(queue)\n        path = list(reversed(path))\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN, 0.75).set_stroke_color(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN) for p in path], lag_ratio=0.02))"}]}
{"messages": [{"role": "user", "content": "Visualize the process of solving a maze using Dijkstra's algorithm, highlighting the explored paths and the final solution."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass BeegMazeTransition(MovingCameraScene):\n\n    def construct(self):\n        self.next_section(skip_animations=True)\n        with open('maze/mask.txt') as f:\n            contents = f.read().splitlines()\n        theseus = ImageMobject('assets/theseus-nobackground.png').set_height(0.8).set_z_index(100)\n        theseus_position = (22, 9)\n        theseus_text = Tex('Theseus').next_to(theseus, DOWN, buff=-0.08).scale(0.25)\n        theseus_miniature = ImageMobject('assets/theseus-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (theseus_position[0] + 0.5) + DOWN * (theseus_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.camera.frame.move_to(Group(theseus, theseus_text)).set_height(theseus.height * 2)\n        self.play(AnimationGroup(FadeIn(theseus), FadeIn(theseus_text, lag_ratio=0.1), lag_ratio=0.5))\n        minotaur = ImageMobject('assets/minotaur-nobackground.png').set_height(0.8).next_to(theseus, RIGHT, buff=0.3).set_z_index(100)\n        minotaur_position = (27, 9)\n        minotaur_text = Tex('Minotaur').next_to(minotaur, DOWN, buff=-0.08).scale(0.25)\n        minotaur_miniature = ImageMobject('assets/minotaur-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (minotaur_position[0] + 0.5) + DOWN * (minotaur_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(Group(theseus, minotaur)).scale(1.25), AnimationGroup(FadeIn(minotaur), FadeIn(minotaur_text, lag_ratio=0.1), lag_ratio=0.5), lag_ratio=0.25))\n        maze, maze_dict = maze_to_vgroup(contents)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(theseus_text), FadeOut(minotaur_text)), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)).set_height(maze.height * 0.3), FadeTransform(theseus, theseus_miniature), FadeTransform(minotaur, minotaur_miniature)), AnimationGroup(FadeIn(maze)), lag_ratio=0.5, run_time=2))\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2))\n        for i in range(1):\n            self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(LEFT), minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2), theseus_miniature.animate.shift(LEFT))\n        rect = get_fade_rect()\n        canhe = Tex('\\\\underline{Can he get out?}').scale(1.25).next_to(Group(theseus_miniature, minotaur_miniature), UP, buff=0.25).set_z_index(10000000)\n        self.play(AnimationGroup(FadeIn(rect), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature, canhe)), FadeIn(canhe, shift=UP * 0.25)), lag_ratio=0.5))\n        self.play(FadeOut(rect), FadeOut(canhe), self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)))\n        self.play(Flash(minotaur_miniature, color=WHITE), FadeOut(minotaur_miniature))\n        self.play(self.camera.frame.animate.move_to(maze).set_height(maze.height * 1.25), run_time=1.5)\n        shortest_path = [(21, 9), (22, 9), (23, 9), (24, 9), (25, 9), (26, 9), (27, 9), (27, 10), (27, 11), (27, 12), (27, 13), (27, 14), (27, 15), (28, 15), (29, 15), (30, 15), (31, 15), (32, 15), (33, 15), (34, 15), (35, 15), (36, 15), (37, 15), (37, 16), (37, 17), (38, 17), (39, 17), (39, 16), (39, 15), (40, 15)]\n        theseus_miniature.set_z_index(10000)\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE) for p in shortest_path], lag_ratio=0.02))\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(WHITE, 0).set_stroke_color(WHITE) for p in shortest_path]))\n        bfs_text = Tex('BFS').scale(5).next_to(maze, RIGHT, buff=1.5).align_to(maze, UP).shift(DOWN)\n        astar_text = Tex('A*').scale(5).move_to(bfs_text)\n        q = Queue(scale=2).next_to(bfs_text, DOWN, buff=2)\n        self.play(FadeIn(q), FadeIn(bfs_text), self.camera.frame.animate.move_to(Group(maze, theseus_miniature, q, bfs_text)), run_time=1)\n        theseus_position = (theseus_position[0] - 1, theseus_position[1])\n        escape = (40, 15)\n        queue = [(0, theseus_position)]\n        discovered = {theseus_position: None}\n\n        def is_valid(position):\n            x, y = position\n            return 0 <= x < len(contents[0]) and 0 <= y < len(contents) and (contents[y][x] != '.')\n\n        def next_states(position):\n            x, y = position\n            states = []\n            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                nx = x + dx\n                ny = y + dy\n                if not is_valid((nx, ny)):\n                    continue\n                if contents[ny][nx] == ' ':\n                    states.append((1, (nx, ny)))\n                else:\n                    states.append((10, (nx, ny)))\n            return states\n\n        def animate_discover(states):\n            for p in states:\n                if contents[p[1]][p[0]] != ' ':\n                    maze_dict[p].set_z_index(5000)\n            return AnimationGroup(*[maze_dict[p].animate.set_fill(BLUE if contents[p[1]][p[0]] == ' ' else DARK_BLUE, 0.75).set_stroke_color(BLUE if contents[p[1]][p[0]] == ' ' else DARK_BLUE) for p in states])\n\n        def animate_leave(state):\n            p = state\n            if contents[p[1]][p[0]] != ' ':\n                maze_dict[p].set_z_index(3000)\n            return maze_dict[state].animate.set_fill(LIGHT_GRAY if contents[p[1]][p[0]] == ' ' else GRAY, 0.75).set_stroke_color(LIGHT_GRAY if contents[p[1]][p[0]] == ' ' else GRAY).set_z_index(3 if contents[p[1]][p[0]] == ' ' else 3000)\n\n        def animate_add_to_queue(states):\n            fade_froms = [maze_dict[s] for s in states]\n            state_texs = [Tex(s) for s in states]\n            return q.animate_add_from(state_texs, fade_froms)\n\n        def animate_pop(state):\n            p = state\n            if contents[p[1]][p[0]] != ' ':\n                maze_dict[p].set_z_index(2000)\n            return maze_dict[state].animate.set_fill(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN, 0.75).set_stroke_color(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN).set_z_index(2 if contents[p[1]][p[0]] == ' ' else 2000)\n\n        def stop_condition(state):\n            return state == escape\n        i = 1\n\n        def add_neighbours(distance, position):\n            states = []\n            for next_distance, next_state in next_states(position):\n                if next_state not in discovered:\n                    discovered[next_state] = position\n                    queue.append((distance + next_distance, next_state))\n                    states.append(next_state)\n            if len(states) != 0:\n                self.play(animate_leave(current), animate_discover(states))\n            else:\n                self.play(animate_leave(current))\n        self.play(FadeOut(q), FadeOut(bfs_text), self.camera.frame.animate.move_to(maze), run_time=1)\n        seed(3134975699)\n        for i in range(len(contents)):\n            contents[i] = list(contents[i])\n        blocks = []\n        for _ in range(40):\n            x, y = (0, 0)\n            while contents[y][x] != ' ' or (x, y) == theseus_position or (x, y) == escape:\n                x, y = (randint(0, len(contents[0]) - 1), randint(0, len(contents) - 1))\n            blocks.append((x, y))\n            contents[y][x] = '#'\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(WHITE, 1).set_stroke_color(WHITE).set_z_index(10000) for p in blocks], lag_ratio=0.02))\n        for x in range(len(contents[0])):\n            for y in range(len(contents)):\n                if is_valid((x, y)):\n                    maze_dict[x, y].save_state()\n        i = 0\n        ten = VGroup(maze_dict[x, y].copy().set_stroke_width(10).set_stroke_width(10).scale(1.75), Tex('10 steps').scale(2)).arrange(DOWN, buff=0.5)\n        one = VGroup(maze_dict[x, y].copy().set_fill(WHITE, 0).set_stroke_width(10).scale(1.75), Tex('1 step').scale(2)).arrange(DOWN, buff=0.5)\n        VGroup(ten, one).arrange(DOWN, buff=3).next_to(maze, RIGHT, buff=3)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(VGroup(maze, one, ten)), AnimationGroup(FadeIn(ten), FadeIn(one)), lag_ratio=0.5))\n        rect = get_fade_rect()\n        problem = Tex('\\\\textbf{Problem}: order in queue $\\\\neq$ distance from start').scale(3.5).set_z_index(10000001)\n        solution = Tex('\\\\textbf{Solution}: use a \\\\textit{priority queue}').scale(3.5).set_z_index(10000001)\n        VGroup(problem, solution).arrange(DOWN, buff=1.5).move_to(self.camera.frame)\n        self.play(AnimationGroup(FadeIn(rect), FadeIn(problem), lag_ratio=0.5))\n        self.play(FadeIn(solution))\n        self.play(FadeOut(rect), FadeOut(problem), FadeOut(solution))\n        while len(queue) != 0:\n            distance, current = queue.pop(0)\n            i += 1\n            a = animate_pop(current)\n            self.play(a)\n            if stop_condition(current):\n                path = [current]\n                while discovered[current] is not None:\n                    current = discovered[current]\n                    path.append(current)\n                break\n            add_neighbours(distance, current)\n            queue = sorted(queue)\n        path = list(reversed(path))\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN, 0.75).set_stroke_color(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN) for p in path], lag_ratio=0.02))\n        self.next_section()\n        self.play(FadeOut(ten), FadeOut(one), self.camera.frame.animate.move_to(maze), *[maze_dict[x, y].animate.restore() for x in range(len(contents[0])) for y in range(len(contents)) if is_valid((x, y))])"}]}
{"messages": [{"role": "user", "content": "Visualize a maze-solving algorithm with Theseus and the Minotaur, showing the pathfinding process."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass BeegMazeAStarTho(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        with open('maze/mask.txt') as f:\n            contents = f.read().splitlines()\n        theseus = ImageMobject('assets/theseus-nobackground.png').set_height(0.8).set_z_index(100)\n        theseus_position = (22, 9)\n        theseus_text = Tex('Theseus').next_to(theseus, DOWN, buff=-0.08).scale(0.25)\n        theseus_miniature = ImageMobject('assets/theseus-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (theseus_position[0] + 0.5) + DOWN * (theseus_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.camera.frame.move_to(Group(theseus, theseus_text)).set_height(theseus.height * 2)\n        self.play(AnimationGroup(FadeIn(theseus), FadeIn(theseus_text, lag_ratio=0.1), lag_ratio=0.5))\n        minotaur = ImageMobject('assets/minotaur-nobackground.png').set_height(0.8).next_to(theseus, RIGHT, buff=0.3).set_z_index(100)\n        minotaur_position = (27, 9)\n        minotaur_text = Tex('Minotaur').next_to(minotaur, DOWN, buff=-0.08).scale(0.25)\n        minotaur_miniature = ImageMobject('assets/minotaur-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (minotaur_position[0] + 0.5) + DOWN * (minotaur_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(Group(theseus, minotaur)).scale(1.25), AnimationGroup(FadeIn(minotaur), FadeIn(minotaur_text, lag_ratio=0.1), lag_ratio=0.5), lag_ratio=0.25))\n        maze, maze_dict = maze_to_vgroup(contents)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(theseus_text), FadeOut(minotaur_text)), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)).set_height(maze.height * 0.3), FadeTransform(theseus, theseus_miniature), FadeTransform(minotaur, minotaur_miniature)), AnimationGroup(FadeIn(maze)), lag_ratio=0.5, run_time=2))\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2))\n        for i in range(1):\n            self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(LEFT), minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2), theseus_miniature.animate.shift(LEFT))\n        rect = get_fade_rect()\n        canhe = Tex('\\\\underline{Can he get out?}').scale(1.25).next_to(Group(theseus_miniature, minotaur_miniature), UP, buff=0.25).set_z_index(10000000)\n        self.play(AnimationGroup(FadeIn(rect), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature, canhe)), FadeIn(canhe, shift=UP * 0.25)), lag_ratio=0.5))\n        self.play(FadeOut(rect), FadeOut(canhe), self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)))\n        self.play(Flash(minotaur_miniature, color=WHITE), FadeOut(minotaur_miniature))\n        self.play(self.camera.frame.animate.move_to(maze).set_height(maze.height * 1.25), run_time=1.5)\n        shortest_path = [(21, 9), (22, 9), (23, 9), (24, 9), (25, 9), (26, 9), (27, 9), (27, 10), (27, 11), (27, 12), (27, 13), (27, 14), (27, 15), (28, 15), (29, 15), (30, 15), (31, 15), (32, 15), (33, 15), (34, 15), (35, 15), (36, 15), (37, 15), (37, 16), (37, 17), (38, 17), (39, 17), (39, 16), (39, 15), (40, 15)]\n        theseus_miniature.set_z_index(10000)\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE) for p in shortest_path], lag_ratio=0.02))\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(WHITE, 0).set_stroke_color(WHITE) for p in shortest_path]))\n        bfs_text = Tex('BFS').scale(5).next_to(maze, RIGHT, buff=1.5).align_to(maze, UP).shift(DOWN)\n        astar_text = Tex('A*').scale(5).move_to(bfs_text)\n        q = Queue(scale=2).next_to(bfs_text, DOWN, buff=2)\n        self.play(FadeIn(q), FadeIn(bfs_text), self.camera.frame.animate.move_to(Group(maze, theseus_miniature, q, bfs_text)), run_time=1)\n        theseus_position = (theseus_position[0] - 1, theseus_position[1])\n\n        def dist(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        escape = (40, 15)\n\n        def heuristic(state):\n            return dist(state, escape)\n        queue = [(0 + heuristic(theseus_position), theseus_position)]\n        discovered = {theseus_position: None}\n\n        def is_valid(position):\n            x, y = position\n            return 0 <= x < len(contents[0]) and 0 <= y < len(contents) and (contents[y][x] != '.')\n\n        def next_states(position):\n            x, y = position\n            states = []\n            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                nx = x + dx\n                ny = y + dy\n                if not is_valid((nx, ny)):\n                    continue\n                if contents[ny][nx] == ' ':\n                    states.append((1, (nx, ny)))\n                else:\n                    states.append((10, (nx, ny)))\n            return states\n\n        def animate_discover(states):\n            for p in states:\n                if contents[p[1]][p[0]] != ' ':\n                    maze_dict[p].set_z_index(5000)\n            return AnimationGroup(*[maze_dict[p].animate.set_fill(BLUE if contents[p[1]][p[0]] == ' ' else DARK_BLUE, 0.75).set_stroke_color(BLUE if contents[p[1]][p[0]] == ' ' else DARK_BLUE) for p in states])\n\n        def animate_leave(state):\n            p = state\n            if contents[p[1]][p[0]] != ' ':\n                maze_dict[p].set_z_index(3000)\n            return maze_dict[state].animate.set_fill(LIGHT_GRAY if contents[p[1]][p[0]] == ' ' else GRAY, 0.75).set_stroke_color(LIGHT_GRAY if contents[p[1]][p[0]] == ' ' else GRAY).set_z_index(3 if contents[p[1]][p[0]] == ' ' else 3000)\n\n        def animate_add_to_queue(states):\n            fade_froms = [maze_dict[s] for s in states]\n            state_texs = [Tex(s) for s in states]\n            return q.animate_add_from(state_texs, fade_froms)\n\n        def animate_pop(state):\n            p = state\n            if contents[p[1]][p[0]] != ' ':\n                maze_dict[p].set_z_index(2000)\n            return maze_dict[state].animate.set_fill(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN, 0.75).set_stroke_color(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN).set_z_index(2 if contents[p[1]][p[0]] == ' ' else 2000)\n\n        def stop_condition(state):\n            return state == escape\n        i = 1\n\n        def add_neighbours(distance, position):\n            steps_to_position = distance - heuristic(position)\n            states = []\n            for next_distance, next_state in next_states(position):\n                if next_state not in discovered:\n                    discovered[next_state] = position\n                    queue.append((steps_to_position + next_distance + heuristic(next_state), next_state))\n                    states.append(next_state)\n            if len(states) != 0:\n                self.play(animate_leave(current), animate_discover(states))\n            else:\n                self.play(animate_leave(current))\n        self.play(FadeOut(q), FadeOut(bfs_text), self.camera.frame.animate.move_to(maze), run_time=1)\n        self.next_section()\n        seed(3134975699)\n        for i in range(len(contents)):\n            contents[i] = list(contents[i])\n        blocks = []\n        for _ in range(40):\n            x, y = (0, 0)\n            while contents[y][x] != ' ' or (x, y) == theseus_position or (x, y) == escape:\n                x, y = (randint(0, len(contents[0]) - 1), randint(0, len(contents) - 1))\n            blocks.append((x, y))\n            contents[y][x] = '#'\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(WHITE, 1).set_stroke_color(WHITE).set_z_index(10000) for p in blocks], lag_ratio=0.02))\n        queue2 = []\n        discovered2 = {escape: 0}\n        for x in range(100):\n            for y in range(100):\n                if is_valid((x, y)):\n                    discovered2[x, y] = dist((x, y), escape)\n        all_colors = color_gradient([GREEN, RED], max(discovered2.values()) + 1)\n        all_colors_light = color_gradient(['#dbfcde', '#fcdcdb'], max(discovered2.values()) + 1)\n        self.play(*[AnimationGroup(*[maze_dict[p].animate(run_time=1).set_color(all_colors[d] if contents[p[1]][p[0]] != '#' else WHITE).set_fill(all_colors[d] if contents[p[1]][p[0]] != '#' else all_colors_light[d], 0.4 if contents[p[1]][p[0]] != '#' else 1) for p in discovered2.keys() if discovered2[p] == d]) for d in range(0, max(discovered2.values()) + 1)])\n        i = 0\n        while len(queue) != 0:\n            distance, current = queue.pop(0)\n            i += 1\n            a = animate_pop(current)\n            self.play(a)\n            if stop_condition(current):\n                path = [current]\n                while discovered[current] is not None:\n                    current = discovered[current]\n                    path.append(current)\n                break\n            add_neighbours(distance, current)\n            queue = sorted(queue)\n        path = list(reversed(path))\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN, 0.75).set_stroke_color(ORANGE if contents[p[1]][p[0]] == ' ' else DARK_BROWN) for p in path], lag_ratio=0.02))\n        bfs = ImageMobject('assets/compare/2-dijkstra.png').move_to(self.camera.frame).set_height(self.camera.frame.get_height())\n        bfs.next_to(maze, LEFT)\n        astar_text = Tex('A*').scale(7).next_to(maze, UP, buff=3)\n        bfs_text = Tex('Dijkstra').scale(7).move_to(bfs).align_to(astar_text, DOWN)\n        g = Group(bfs, self.camera.frame.copy(), astar_text, bfs_text)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(g).set_width(g.get_width()), AnimationGroup(FadeIn(bfs), FadeIn(bfs_text), FadeIn(astar_text)), lag_ratio=0.5))"}]}
{"messages": [{"role": "user", "content": "Visualize the A* pathfinding algorithm on a maze with a character, showcasing BFS and then A* comparison, and highlighting the shortest path."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass AStar(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        with open('maze/mask.txt') as f:\n            contents = f.read().splitlines()\n        theseus = ImageMobject('assets/theseus-nobackground.png').set_height(0.8).set_z_index(100)\n        theseus_position = (22, 9)\n        theseus_text = Tex('Theseus').next_to(theseus, DOWN, buff=-0.08).scale(0.25)\n        theseus_miniature = ImageMobject('assets/theseus-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (theseus_position[0] + 0.5) + DOWN * (theseus_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.camera.frame.move_to(Group(theseus, theseus_text)).set_height(theseus.height * 2)\n        self.play(AnimationGroup(FadeIn(theseus), FadeIn(theseus_text, lag_ratio=0.1), lag_ratio=0.5))\n        minotaur = ImageMobject('assets/minotaur-nobackground.png').set_height(0.8).next_to(theseus, RIGHT, buff=0.3).set_z_index(100)\n        minotaur_position = (27, 9)\n        minotaur_text = Tex('Minotaur').next_to(minotaur, DOWN, buff=-0.08).scale(0.25)\n        minotaur_miniature = ImageMobject('assets/minotaur-nobackground-outline.png').set_height(0.8).move_to(RIGHT * (minotaur_position[0] + 0.5) + DOWN * (minotaur_position[1] + 0.5) + len(contents) / 2 * UP + len(contents[0]) / 2 * LEFT).set_z_index(1000000 + 1)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(Group(theseus, minotaur)).scale(1.25), AnimationGroup(FadeIn(minotaur), FadeIn(minotaur_text, lag_ratio=0.1), lag_ratio=0.5), lag_ratio=0.25))\n        maze, maze_dict = maze_to_vgroup(contents)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(theseus_text), FadeOut(minotaur_text)), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)).set_height(maze.height * 0.3), FadeTransform(theseus, theseus_miniature), FadeTransform(minotaur, minotaur_miniature)), AnimationGroup(FadeIn(maze)), lag_ratio=0.5, run_time=2))\n        self.play(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2))\n        for i in range(1):\n            self.play(self.camera.frame.animate.move_to(Group(theseus_miniature.copy().shift(LEFT), minotaur_miniature.copy().shift(LEFT * 2))).scale(0.85), minotaur_miniature.animate.shift(LEFT * 2), theseus_miniature.animate.shift(LEFT))\n        rect = get_fade_rect()\n        canhe = Tex('\\\\underline{Can he get out?}').scale(1.25).next_to(Group(theseus_miniature, minotaur_miniature), UP, buff=0.25).set_z_index(10000000)\n        self.play(AnimationGroup(FadeIn(rect), AnimationGroup(self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature, canhe)), FadeIn(canhe, shift=UP * 0.25)), lag_ratio=0.5))\n        self.play(FadeOut(rect), FadeOut(canhe), self.camera.frame.animate.move_to(Group(theseus_miniature, minotaur_miniature)))\n        self.play(Flash(minotaur_miniature, color=WHITE), FadeOut(minotaur_miniature))\n        self.play(self.camera.frame.animate.move_to(maze).set_height(maze.height * 1.25), run_time=1.5)\n        shortest_path = [(21, 9), (22, 9), (23, 9), (24, 9), (25, 9), (26, 9), (27, 9), (27, 10), (27, 11), (27, 12), (27, 13), (27, 14), (27, 15), (28, 15), (29, 15), (30, 15), (31, 15), (32, 15), (33, 15), (34, 15), (35, 15), (36, 15), (37, 15), (37, 16), (37, 17), (38, 17), (39, 17), (39, 16), (39, 15), (40, 15)]\n        theseus_miniature.set_z_index(10000)\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE) for p in shortest_path], lag_ratio=0.02))\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(WHITE, 0).set_stroke_color(WHITE) for p in shortest_path]))\n        bfs_text = Tex('BFS').scale(5).next_to(maze, RIGHT, buff=1.5).align_to(maze, UP).shift(DOWN)\n        astar_text = Tex('A*').scale(5).move_to(bfs_text)\n        q = Queue(scale=2).next_to(bfs_text, DOWN, buff=2)\n        self.next_section()\n        self.play(FadeIn(q), FadeIn(bfs_text), self.camera.frame.animate.move_to(Group(maze, theseus_miniature, q, bfs_text)), run_time=1)\n        theseus_position = (theseus_position[0] - 1, theseus_position[1])\n\n        def dist(a, b):\n            return abs(a[0] - b[0]) + abs(a[1] - b[1])\n        escape = (40, 15)\n\n        def heuristic(state):\n            return dist(state, escape)\n        queue = [(0 + heuristic(theseus_position), theseus_position)]\n        discovered = {theseus_position: None}\n\n        def is_valid(position):\n            x, y = position\n            return 0 <= x < len(contents[0]) and 0 <= y < len(contents) and (contents[y][x] != '#')\n\n        def next_states(position):\n            x, y = position\n            states = []\n            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                nx = x + dx\n                ny = y + dy\n                if is_valid((nx, ny)):\n                    states.append((nx, ny))\n            return states\n\n        def animate_discover(states):\n            return AnimationGroup(*[maze_dict[p].animate.set_fill(BLUE, 0.75).set_stroke_color(BLUE) for p in states])\n\n        def animate_leave(state):\n            return maze_dict[state].animate.set_fill(LIGHT_GRAY, 0.75).set_stroke_color(LIGHT_GRAY).set_z_index(3)\n\n        def animate_add_to_queue(states):\n            fade_froms = [maze_dict[s] for s in states]\n            state_texs = [Tex(s) for s in states]\n            return q.animate_add_from(state_texs, fade_froms)\n\n        def animate_pop(state):\n            return maze_dict[state].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE).set_z_index(2)\n\n        def stop_condition(state):\n            return state == escape\n        i = 1\n\n        def add_neighbours(distance, position):\n            steps_to_position = distance - heuristic(position)\n            states = []\n            for next_state in next_states(position):\n                if next_state not in discovered:\n                    discovered[next_state] = position\n                    queue.append((steps_to_position + 1 + heuristic(next_state), next_state))\n                    states.append(next_state)\n            if len(states) != 0:\n                self.play(animate_leave(current), animate_discover(states))\n            else:\n                self.play(animate_leave(current))\n        queue2 = [escape]\n        discovered2 = {escape: 0}\n        while len(queue2) != 0:\n            current = queue2.pop(0)\n            for next_state in next_states(current):\n                if next_state not in discovered2:\n                    discovered2[next_state] = dist(next_state, escape)\n                    queue2.append(next_state)\n        all_colors = color_gradient([GREEN, RED], max(discovered2.values()) + 1)\n        self.play(AnimationGroup(*[AnimationGroup(*[maze_dict[p].animate(run_time=0.5).set_color(all_colors[d]).set_fill(all_colors[d], 0.75) for p in discovered2.keys() if discovered2[p] == d]) for d in range(0, max(discovered2.values()) + 1)], lag_ratio=0.045))\n        self.play(Transform(bfs_text, astar_text))\n        self.play(AnimationGroup(*[AnimationGroup(*[maze_dict[p].animate(run_time=1, rate_func=there_and_back).set_color(all_colors[d]).set_fill(all_colors[d], 1) for p in discovered2.keys() if discovered2[p] == d]) for d in range(0, max(discovered2.values()) + 1)], lag_ratio=0.025))\n        self.play(*[AnimationGroup(*[maze_dict[p].animate(run_time=1).set_color(all_colors[d]).set_fill(all_colors[d], 0.4) for p in discovered2.keys() if discovered2[p] == d]) for d in range(0, max(discovered2.values()) + 1)])\n        self.play(FadeOut(q), FadeOut(bfs_text), self.camera.frame.animate.move_to(maze), run_time=1)\n        while len(queue) != 0:\n            distance, current = queue.pop(0)\n            i += 1\n            a = animate_pop(current)\n            self.play(a)\n            if stop_condition(current):\n                path = [current]\n                while discovered[current] is not None:\n                    current = discovered[current]\n                    path.append(current)\n                break\n            add_neighbours(distance, current)\n            queue = sorted(queue)\n        self.play(AnimationGroup(*[maze_dict[p].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE) for p in shortest_path], lag_ratio=0.02))\n        bfs = ImageMobject('assets/compare/1-bfs.png').move_to(self.camera.frame).set_height(self.camera.frame.get_height())\n        bfs.next_to(maze, LEFT)\n        astar_text = Tex('A*').scale(7).next_to(maze, UP, buff=3)\n        bfs_text = Tex('BFS').scale(7).move_to(bfs).align_to(astar_text, DOWN)\n        g = Group(bfs, self.camera.frame.copy(), astar_text, bfs_text)\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(g).set_width(g.get_width()), AnimationGroup(FadeIn(bfs), FadeIn(bfs_text), FadeIn(astar_text)), lag_ratio=0.5))"}]}
{"messages": [{"role": "user", "content": "Show Dijkstra's algorithm and Breadth-First Search side-by-side, highlighting lines of code sequentially."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass DijkstraFixed(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        blocks = code_parts_from_file('programs/dijkstra.py')\n        dijkstra = Tex(\"Dijkstra's algorithm\").scale(1.65)\n        bfs = Tex('Breadth-First Search').scale(1.65)\n        code_web = align_code([('|', 'c'), dijkstra, blocks['dijkstra']])\n        code_web_2 = align_code([('|', 'c'), bfs, blocks['bfs']]).next_to(code_web, LEFT, buff=2.5)\n        self.add(code_web)\n        self.add(code_web_2)\n        sg = Group(code_web, code_web_2)\n        self.camera.frame.move_to(sg).set_height(sg.get_height() * 1.28)\n\n        def fadyfady(indexes, previous_indexes=[]):\n            return AnimationGroup(*[blocks['dijkstra'].code[i].animate.set_opacity(BIG_OPACITY) for i in range(len(blocks['dijkstra'].code)) if i not in indexes], *[blocks['dijkstra'].code[i].animate.set_opacity(1) for i in range(len(blocks['dijkstra'].code)) if i in indexes], *[blocks['bfs'].code[i].animate.set_opacity(BIG_OPACITY) for i in range(len(blocks['bfs'].code)) if i not in indexes], *[blocks['bfs'].code[i].animate.set_opacity(1) for i in range(len(blocks['bfs'].code)) if i in indexes])\n        self.play(FadeIn(code_web), FadeIn(code_web_2))\n        self.play(fadyfady([0, 3]))\n        self.play(fadyfady([8]))\n        self.play(fadyfady([23]))\n        self.play(fadyfady([24]))\n        self.play(fadyfady([26, 27, 28]))\n        self.play(fadyfady([5, 26, 27, 28, 31]))"}]}
{"messages": [{"role": "user", "content": "Visualize Dijkstra's algorithm by transforming code lines from a BFS representation to Dijkstra's, highlighting key changes and then showing both algorithms side-by-side with most lines faded."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass Dijkstra(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        blocks = code_parts_from_file('programs/dijkstra.py')\n        bfs = Tex(\"Dijkstra's algorithm\").scale(1.65)\n        code_web = align_code([('|', 'c'), bfs, blocks['bfs']])\n        blocks['dijkstra'].move_to(blocks['bfs']).align_to(blocks['bfs'], LEFT)\n        dijkstra = Tex('Dijkstra').scale(1.65).move_to(bfs)\n        start_group = VGroup(bfs, blocks['bfs'])\n        self.camera.frame.move_to(start_group).set_height(start_group.height * 1.2)\n        self.play(Write(bfs, run_time=1), Write(blocks['bfs'].background_mobject), FadeIn(blocks['bfs'].code))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(blocks['bfs'].code[0][4:4 + 12]), FadeOut(blocks['bfs'].code[0][4 + 12 + 7:])), AnimationGroup(Transform(blocks['bfs'].code[0][4 + 12:4 + 12 + 7], blocks['dijkstra'].code[0][4 + 6:4 + 5 + 8])), AnimationGroup(FadeIn(blocks['dijkstra'].code[0][4:4 + 6]), FadeIn(blocks['dijkstra'].code[0][4 + 5 + 8:])), lag_ratio=0.5))\n        highlight = CreateHighlightCodeLine(blocks['bfs'], 3, start=1)\n        self.play(FadeIn(highlight))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(blocks['bfs'].code[3][-1]), FadeOut(blocks['bfs'].code[3][8:7 + 8])), AnimationGroup(Transform(highlight, CreateHighlightCodeLine(blocks['dijkstra'], 3, start=1)), Transform(blocks['bfs'].code[3][-2], blocks['dijkstra'].code[3][-1]), Transform(blocks['bfs'].code[3][7 + 8], blocks['dijkstra'].code[3][9]), Transform(blocks['bfs'].code[3][7 + 8 + 1:-2], blocks['dijkstra'].code[3][14:-2])), AnimationGroup(FadeIn(blocks['dijkstra'].code[3][-2]), FadeIn(blocks['dijkstra'].code[3][10:10 + 3])), lag_ratio=0.5))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['dijkstra'], 3, start=14, end=-2)))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['dijkstra'], 3, start=11, end=12)))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['bfs'], 7, start=2)))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(blocks['bfs'].code[7][1 + 10 + 6:])), AnimationGroup(Transform(blocks['bfs'].code[7][1:1 + 10], blocks['dijkstra'].code[7][3 + 1:3 + 1 + 10]), Transform(blocks['bfs'].code[7][1 + 10 + 1:1 + 10 + 6], blocks['dijkstra'].code[7][-1 - 5:-1]), Transform(highlight, CreateHighlightCodeLine(blocks['dijkstra'], 7, start=2))), AnimationGroup(FadeIn(blocks['dijkstra'].code[7][:4]), FadeIn(blocks['dijkstra'].code[7][-1]), FadeIn(blocks['dijkstra'].code[7][3 + 1 + 10:-1 - 5])), lag_ratio=0.5))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['bfs'], 22, start=2)))\n        self.play(AnimationGroup(AnimationGroup(Transform(blocks['bfs'].code[22][5:], blocks['dijkstra'].code[22][16:]), FadeTransform(blocks['bfs'].background_mobject, blocks['dijkstra'].background_mobject), self.camera.frame.animate.move_to(VGroup(blocks['dijkstra'], bfs)), bfs.animate.align_to(bfs.copy().next_to(blocks['dijkstra'], UP), LEFT), Transform(highlight, CreateHighlightCodeLine(blocks['dijkstra'], 22, start=2))), FadeIn(blocks['dijkstra'].code[22][5:16]), lag_ratio=0.5))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['bfs'], 24, start=4)))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(blocks['bfs'].code[24][4 + 5:])), AnimationGroup(Transform(blocks['bfs'].code[24][4:4 + 5], blocks['dijkstra'].code[24][4 + 9:4 + 9 + 5]), Transform(highlight, CreateHighlightCodeLine(blocks['dijkstra'], 24, start=4))), AnimationGroup(FadeIn(blocks['dijkstra'].code[24][:4 + 9]), FadeIn(blocks['dijkstra'].code[24][4 + 9 + 5:])), lag_ratio=0.5))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['dijkstra'], 24, start=21, end=34)))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['dijkstra'], 24, start=21, end=22)))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['dijkstra'], 24, start=25, end=34)))\n        for o in self.mobjects:\n            self.remove(o)\n        blocks = code_parts_from_file('programs/dijkstra.py')\n        dijkstra = Tex(\"Dijkstra's algorithm\").scale(1.65)\n        bfs = Tex('Breadth-First Search').scale(1.65)\n        code_web = align_code([('|', 'c'), dijkstra, blocks['dijkstra']])\n        code_web_2 = align_code([('|', 'c'), bfs, blocks['bfs']]).next_to(code_web, LEFT, buff=2.5)\n        self.add(code_web)\n        self.add(code_web_2)\n        start_group = VGroup(dijkstra, blocks['dijkstra'])\n        self.camera.frame.move_to(start_group).set_height(start_group.height * 1.2)\n        highlight.become(CreateHighlightCodeLine(blocks['dijkstra'], 24, start=25, end=34))\n        a = VGroup(code_web, code_web_2)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(highlight), self.camera.frame.animate.move_to(a).set_width(a.width * 1.4)), FadeIn(code_web_2), lag_ratio=0.5))\n        keep = [0, 3, 7, 22, 24]\n        self.play(*[blocks['dijkstra'].code[i].animate.set_opacity(BIG_OPACITY) for i in range(len(blocks['dijkstra'].code)) if i not in keep], *[blocks['bfs'].code[i].animate.set_opacity(BIG_OPACITY) for i in range(len(blocks['bfs'].code)) if i not in keep])"}]}
{"messages": [{"role": "user", "content": "Create a Manim scene with a camera that will eventually be used for an outro, applying a fade transition."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass Outro(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        pass"}]}
{"messages": [{"role": "user", "content": "Animate a simulation of robots gathering and processing minerals to maximize geodes within a time limit."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass LastScreen(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        self.camera.frame.save_state()\n        robots = VGroup(*[SVGMobject('assets/robot-ore.svg'), SVGMobject('assets/robot-clay.svg'), SVGMobject('assets/robot-obsidian.svg'), SVGMobject('assets/robot-geode.svg')]).arrange(buff=0.8)\n        minerals = Group(*[ImageMobject('assets/minerals/ore.png'), ImageMobject('assets/minerals/clay.png'), ImageMobject('assets/minerals/obsidian.png'), ImageMobject('assets/minerals/geode.png')])\n        robot_counts = VGroup(*[Tex(4).next_to(robots[0], DOWN), Tex(0).next_to(robots[1], DOWN), Tex(0).next_to(robots[2], DOWN), Tex(0).next_to(robots[3], DOWN)])\n        for m, r in zip(minerals, robots):\n            m.set_height(1).next_to(r, UP)\n        self.camera.frame.move_to(Group(minerals, robots))\n        mineral_counts = VGroup(*[Tex('\\\\textbf{0}').move_to(minerals[0]).set_z_index(1), Tex('\\\\textbf{0}').move_to(minerals[1]).set_z_index(1), Tex('\\\\textbf{0}').move_to(minerals[2]).set_z_index(1), Tex('\\\\textbf{0}').move_to(minerals[3]).set_z_index(1)])\n        self.play(AnimationGroup(*[FadeIn(r, shift=DOWN * 0.25) for r in robots], lag_ratio=0.1))\n        for i in range(4):\n            self.play(FadeIn(minerals[i], shift=UP * 0.25), FadeIn(mineral_counts[i], shift=UP * 0.25), run_time=0.5)\n        minute_text = Tex('Minute:').scale(1.5)\n        minute_count = Tex('\\\\textbf{0}').scale(1.5).next_to(minute_text, RIGHT).align_to(minute_text, DOWN)\n        VGroup(minute_text, minute_count).next_to(minerals, UP, buff=1)\n        self.play(AnimationGroup(AnimationGroup(self.camera.frame.animate.move_to(VGroup(minute_text, robot_counts)), robots[1].animate.set_opacity(BIG_OPACITY), robots[2].animate.set_opacity(BIG_OPACITY), robots[3].animate.set_opacity(BIG_OPACITY), minerals[1].animate.set_opacity(BIG_OPACITY), minerals[2].animate.set_opacity(BIG_OPACITY), minerals[3].animate.set_opacity(BIG_OPACITY), mineral_counts[1].animate.set_opacity(BIG_OPACITY), mineral_counts[2].animate.set_opacity(BIG_OPACITY), mineral_counts[3].animate.set_opacity(BIG_OPACITY), run_time=1), AnimationGroup(*[FadeIn(c, shift=DOWN * 0.1) for c in robot_counts], Write(minute_text), FadeIn(minute_count)), lag_ratio=0.5))\n        for i in range(1):\n            minute_count_1 = Tex('\\\\textbf{' + str(i + 1) + '}').scale(1.5).move_to(minute_count)\n            self.play(FadeOut(minute_count, shift=UP * 0.65), FadeIn(minute_count_1, shift=UP * 0.65))\n            minute_count = minute_count_1\n            self.play(robots[0].animate(rate_func=ROBOT_RATE_FUNC).next_to(minerals[0], DOWN, buff=0), minerals[0].animate(rate_func=MINERAL_RATE_FUNC).shift(UP * 0.08), Increment(mineral_counts[0], 4 * (i + 1), 0.08), run_time=1)\n        a = Tex(4).scale(0.8)\n        b = minerals[0].copy().set_opacity(1).set_height(a.get_height()).next_to(a, buff=0.05)\n        ore_cost = Group(a, b)\n        a = Tex(2).scale(0.8)\n        b = minerals[0].copy().set_opacity(1).set_height(a.get_height()).next_to(a, buff=0.05)\n        clay_cost = Group(a, b)\n        a = Tex(3).scale(0.8)\n        b = minerals[0].copy().set_opacity(1).set_height(a.get_height()).next_to(a, buff=0.05)\n        p = Tex('+').scale(0.8)\n        c = Tex(14).scale(0.8)\n        d = minerals[1].copy().set_opacity(1).set_height(c.get_height()).next_to(c, buff=0.05)\n        obsidian_cost = Group(Group(a, b), p, Group(c, d)).arrange(buff=0.1)\n        a = Tex(2).scale(0.8)\n        b = minerals[0].copy().set_opacity(1).set_height(a.get_height()).next_to(a, buff=0.05)\n        p = Tex('+').scale(0.8)\n        c = Tex(7).scale(0.8)\n        d = minerals[2].copy().set_opacity(1).set_height(c.get_height()).next_to(c, buff=0.05)\n        geode_cost = Group(Group(a, b), p, Group(c, d)).arrange(buff=0.1)\n        robot_costs = Group(*[ore_cost.next_to(robot_counts[0], DOWN, buff=0.5), clay_cost.next_to(robot_counts[1], DOWN, buff=0.5), obsidian_cost.next_to(robot_counts[2], DOWN, buff=0.5), geode_cost.next_to(robot_counts[3], DOWN, buff=0.5), geode_cost.copy().next_to(robot_counts[0], DOWN, buff=0.5)])\n        self.play(self.camera.frame.animate.move_to(Group(minute_text, robot_costs)).scale(1.15), FadeIn(robot_costs[0], shift=DOWN * 0.25))\n        self.play(FadeIn(robot_costs[1], shift=DOWN * 0.25))\n        self.play(FadeIn(robot_costs[2], shift=DOWN * 0.25))\n        self.play(FadeIn(robot_costs[3], shift=DOWN * 0.25))\n        command = 1\n\n        def rot(obj, dt):\n            obj.rotate(-dt)\n        gear = SVGMobject('assets/gear.svg').set_height(robot_counts[command].get_height()).next_to(robot_counts[command], RIGHT)\n        gear.add_updater(rot)\n        minute_count_1 = Tex('\\\\textbf{2}').scale(1.5).move_to(minute_count)\n        self.play(FadeOut(minute_count, shift=UP * 0.65), FadeIn(minute_count_1, shift=UP * 0.65))\n        minute_count = minute_count_1\n        self.play(FadeIn(gear, shift=RIGHT * 0.25), Transform(mineral_counts[0], Tex('\\\\textbf{2}').move_to(mineral_counts[0])), minerals[0].animate(rate_func=there_and_back).scale(0.75))\n        self.play(robots[0].animate(rate_func=ROBOT_RATE_FUNC).next_to(minerals[0], DOWN, buff=0), minerals[0].animate(rate_func=MINERAL_RATE_FUNC).shift(UP * 0.08), Increment(mineral_counts[0], 6, 0.08), run_time=1)\n        self.play(robots[command].animate.set_opacity(1), minerals[command].animate.set_opacity(1), mineral_counts[command].animate.set_opacity(1), Transform(robot_counts[command], Tex(1).move_to(robot_counts[command])), FadeOut(gear, shift=RIGHT * 0.25))\n        minute_count_1 = Tex('\\\\textbf{' + str(0) + '}').scale(1.5).move_to(minute_count)\n        self.play(FadeOut(minute_count, shift=DOWN * 0.65), FadeIn(minute_count_1, shift=DOWN * 0.65), robots[0].animate.set_opacity(1), robots[1].animate.set_opacity(BIG_OPACITY), robots[2].animate.set_opacity(BIG_OPACITY), robots[3].animate.set_opacity(BIG_OPACITY), minerals[0].animate.set_opacity(1), minerals[1].animate.set_opacity(BIG_OPACITY), minerals[2].animate.set_opacity(BIG_OPACITY), minerals[3].animate.set_opacity(BIG_OPACITY), mineral_counts[0].animate.set_opacity(1), mineral_counts[1].animate.set_opacity(BIG_OPACITY), mineral_counts[2].animate.set_opacity(BIG_OPACITY), mineral_counts[3].animate.set_opacity(BIG_OPACITY), Transform(robot_counts[0], Tex(1).move_to(robot_counts[0])), Transform(robot_counts[1], Tex(0).move_to(robot_counts[1])), Transform(mineral_counts[0], Tex('\\\\textbf{0}').move_to(mineral_counts[0])), Transform(mineral_counts[1], Tex('\\\\textbf{0}').move_to(mineral_counts[1])))\n        minute_count = minute_count_1\n        g = VGroup(minute_count, minute_text)\n        q = Tex('\\\\textit{Maximize geodes in 32 minutes.}').move_to(g)\n        gc = g.copy()\n        cp = VGroup(gc, q).arrange(buff=2).move_to(g)\n        self.play(AnimationGroup(g.animate.move_to(gc), Write(q, run_time=1.25), lag_ratio=0.75))\n        materials_array = [0, 0, 0, 0]\n        robots_array = [1, 0, 0, 0]\n        self.next_section()\n        commands = [None, None, None, None, 0, None, 1, 1, 1, 1, 1, 1, 1, 2, None, 2, 2, None, 2, 3, 2, 3, 3, 3, None, 3, 3, None, 3, 3, 3, None]\n        ggg = Group(g, q, robot_costs)\n        tfw = Tex('Thanks for watching!').scale(3).next_to(ggg, UP, buff=2)\n        self.add(tfw)\n        l = Line(start=LEFT * 1000, end=RIGHT * 1000).next_to(tfw, DOWN, buff=0.5)\n        self.add(l)\n        (self.camera.frame.move_to(Group(tfw, ggg)).scale(1.4),)\n        for i, command in enumerate(commands):\n            minute_count_1 = Tex('\\\\textbf{' + str(i + 1) + '}').scale(1.5).next_to(minute_text, RIGHT).align_to(minute_text, DOWN)\n            self.play(FadeOut(minute_count, shift=UP * 0.65), FadeIn(minute_count_1, shift=UP * 0.65))\n            minute_count = minute_count_1\n            if command is not None:\n                animations = []\n\n                def rot(obj, dt):\n                    obj.rotate(-dt)\n                gear = SVGMobject('assets/gear.svg').set_height(robot_counts[command].get_height()).next_to(robot_counts[command], RIGHT)\n                gear.add_updater(rot)\n                animations.append(FadeIn(gear, shift=RIGHT * 0.25))\n                prev_materials_array = list(materials_array)\n                if command == 0:\n                    materials_array[0] -= 4\n                if command == 1:\n                    materials_array[0] -= 2\n                if command == 2:\n                    materials_array[0] -= 3\n                    materials_array[1] -= 14\n                if command == 3:\n                    materials_array[0] -= 2\n                    materials_array[2] -= 7\n                for j in range(4):\n                    if prev_materials_array[j] != materials_array[j]:\n                        animations.append(Transform(mineral_counts[j], Tex('\\\\textbf{' + str(materials_array[j]) + '}').move_to(mineral_counts[j])))\n                        animations.append(minerals[j].animate(rate_func=there_and_back).scale(0.75))\n                self.play(*animations, run_time=1)\n            for j in range(4):\n                materials_array[j] += robots_array[j]\n            animations = []\n            for j, robot in enumerate(robots_array):\n                if robot != 0:\n                    animations += [robots[j].animate(rate_func=ROBOT_RATE_FUNC).next_to(minerals[j], DOWN, buff=0), minerals[j].animate(rate_func=MINERAL_RATE_FUNC).shift(UP * 0.08), Increment(mineral_counts[j], materials_array[j], 0.08)]\n            self.play(*animations, run_time=1)\n            animations = []\n            if command is not None:\n                robots_array[command] += 1\n                if robots_array[command] == 1:\n                    animations.append(robots[command].animate.set_opacity(1))\n                    animations.append(minerals[command].animate.set_opacity(1))\n                    animations.append(mineral_counts[command].animate.set_opacity(1))\n                animations.append(Transform(robot_counts[command], Tex(robots_array[command]).move_to(robot_counts[command])))\n                prev_materials_array = list(materials_array)\n                self.play(*animations, FadeOut(gear, shift=RIGHT * 0.25), Transform(robot_counts[j], Tex(robots_array[j]).move_to(robot_counts[j])), run_time=1)"}]}
{"messages": [{"role": "user", "content": "Display a grid of algorithm-related images, each with its name and a thick white border, transitioning them into view."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass Outro(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        slides = Group(*[ImageMobject('assets/outro-images/1-bfs.png'), ImageMobject('assets/outro-images/2-pruning.png'), ImageMobject('assets/outro-images/3-astar.png'), ImageMobject('assets/outro-images/4-dijkstra.png')]).arrange_in_grid(rows=2, buff=(8, 8))\n\n        def sr(obj):\n            return SurroundingRectangle(obj, color=WHITE, stroke_width=15, buff=0)\n        for s, t in zip(slides, ['BFS', 'Pruning', 'A*', 'Dijkstra']):\n            s.add(sr(s))\n            s.add(Tex(t).next_to(s, UP, buff=2.5).scale(7))\n        self.camera.frame.move_to(slides).set_height(slides.get_height() * 1.25)\n        for i in slides:\n            self.play(FadeIn(i, shift=UP * 1.5))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show the BFS and Minotaur maze traversal algorithms with code and visualizations, highlighting key steps and transformations."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass Thumbnail(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        blocks = code_parts_from_file('programs/bfs.py')\n        bfs = Tex('Breadth-First Search').scale(1.65)\n        code_web = align_code([('-', 'c'), [('|', 'c'), bfs, blocks['start'], blocks['output']], [('|', 'l'), blocks['is_valid'], blocks['next_states'], blocks['bfs_deque']]])\n        start_group = VGroup(bfs, blocks['start'].background_mobject)\n        blocks['output'].align_to(blocks['start'], RIGHT)\n        self.camera.frame.move_to(blocks['bfs_deque']).set_height(blocks['bfs_deque'].height * 1.2)\n        self.add(*code_web)\n        self.remove(blocks['output'])\n        self.play(FadeCode(blocks['start']), FadeCode(blocks['is_valid']), FadeCode(blocks['next_states']))\n        highlight = CreateHighlightCodeLine(blocks['bfs_deque'], 2, start=8, end=38)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks['bfs_deque'], [22, 23, 24, 25], offset=2)))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks['bfs_deque'], 22, start=20, end=40)))\n        self.play(AnimationGroup(AnimationGroup(FadeCode(blocks['bfs_deque']), FadeOut(highlight)), self.camera.frame.animate.move_to(start_group), UnfadeCode(blocks['start']), lag_ratio=0.5))\n        blocks_minotaur = code_parts_from_file('programs/minotaur.py')\n        bfs_copy = bfs.copy()\n        code_web_minotaur = align_code([('-', 'c'), [('|', 'c'), bfs_copy, blocks_minotaur['start'], blocks_minotaur['output']], [('|', 'l'), blocks_minotaur['is_valid'], blocks_minotaur['next_theseus_positions'], blocks_minotaur['next_minotaur_position'], blocks_minotaur['next_states'], blocks_minotaur['bfs']]])\n        blocks_minotaur['output'].align_to(blocks_minotaur['start'], RIGHT)\n        align_object_by_coords(code_web_minotaur, blocks_minotaur['start'], blocks_minotaur['start'].copy().move_to(blocks['start']).align_to(blocks['start'], UP).align_to(blocks['start'], RIGHT))\n        blocks_minotaur['start_partial'].move_to(blocks['start'])\n        blocks_minotaur['start_partial_2'].set_z_index(10)\n        self.camera.frame.save_state()\n        self.play(self.camera.frame.animate.move_to(blocks_minotaur['start_partial'].code[0:10]).scale(0.5))\n        self.play(FadeIn(blocks_minotaur['start_partial']), Flash(blocks_minotaur['start_partial'].code[4][8], color=blocks_minotaur['start_partial'].code[4][8].color, flash_radius=0.175))\n        self.play(self.camera.frame.animate.restore())\n        blocks_minotaur['start_partial_2'].move_to(blocks_minotaur['start_partial']).align_to(blocks_minotaur['start_partial'], UP)\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(blocks['is_valid'])\n        self.add(blocks['next_states'])\n        self.add(bfs)\n        self.add(blocks['bfs_deque'])\n        self.play(AnimationGroup(AnimationGroup(FadeTransform(blocks_minotaur['start_partial'].background_mobject, blocks_minotaur['start_partial_2'].background_mobject), Transform(blocks_minotaur['start_partial'].code[:14], blocks_minotaur['start_partial_2'].code[:14]), Transform(blocks_minotaur['start_partial'].code[14:21], blocks_minotaur['start_partial_2'].code[15:22]), Transform(blocks_minotaur['start_partial'].code[21:], blocks_minotaur['start_partial_2'].code[24:]), self.camera.frame.animate.move_to(blocks_minotaur['start_partial_2'])), AnimationGroup(Write(blocks_minotaur['start_partial_2'].code[14]), Write(blocks_minotaur['start_partial_2'].code[22:24]), run_time=1), lag_ratio=0.75))\n        blocks_minotaur['start'].set_z_index(20)\n        blocks_minotaur['start_partial_2'].set_z_index(20)\n        blocks_minotaur['start_partial_2'].background_mobject.set_z_index(0)\n        blocks_minotaur['start_this_sucks'].background_mobject.set_z_index(1)\n        blocks_minotaur['start'].align_to(blocks_minotaur['start_partial_2'], LEFT)\n        blocks_minotaur['start_this_sucks'].align_to(blocks_minotaur['start'], LEFT).align_to(blocks_minotaur['start'], UP)\n        highlight = CreateHighlightCodeLine(blocks_minotaur['start'], -3, start=1).set_z_index(1000)\n        self.play(AnimationGroup(AnimationGroup(FadeTransform(blocks_minotaur['start_partial_2'].background_mobject, blocks_minotaur['start_this_sucks'].background_mobject), Transform(blocks_minotaur['start_partial'].code[-1][4:12], blocks_minotaur['start'].code[-3][2:10]), *[Transform(blocks_minotaur['start_partial'].code[-1][12 + i], blocks_minotaur['start'].code[-2][0 + i]) for i in range(20)], Transform(blocks_minotaur['start_partial'].code[-1][33:-1], blocks_minotaur['start'].code[-2][24:]), Transform(blocks_minotaur['start_partial'].code[-1][-1], blocks_minotaur['start'].code[-1][-1]), self.camera.frame.animate.move_to(blocks_minotaur['start_this_sucks'])), AnimationGroup(Write(blocks_minotaur['start'].code[-3][:2]), Write(blocks_minotaur['start'].code[-3][10:]), Write(blocks_minotaur['start'].code[-2][20:23]), run_time=1), lag_ratio=0.75))\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks_minotaur['start'], -2, start=1).set_z_index(1000)))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(blocks['is_valid'])\n        self.add(blocks['next_states'])\n        self.add(bfs)\n        self.add(blocks_minotaur['start'])\n        self.add(blocks['bfs_deque'])\n        blocks_minotaur['start'].background_mobject.become(blocks_minotaur['start_this_sucks'].background_mobject)\n        self.play(AnimationGroup(AnimationGroup(FadeCode(blocks_minotaur['start']), FadeOut(highlight)), self.camera.frame.animate.move_to(blocks['next_states']), UnfadeCode(blocks['next_states']), lag_ratio=0.5))\n        ntp_copy = blocks_minotaur['next_theseus_positions'].copy().move_to(blocks['next_states'])\n        self.play(FadeTransform(blocks['next_states'].code[0][9:9 + 6], ntp_copy.code[0][9:9 + 17]), Transform(blocks['next_states'].code[0][9 + 6:], ntp_copy.code[0][9 + 17:]))\n        for mobject in self.mobjects:\n            self.remove(mobject)\n        self.add(blocks['is_valid'])\n        self.add(ntp_copy)\n        self.add(bfs)\n        self.add(blocks_minotaur['start'])\n        self.add(blocks['bfs_deque'])\n        blocks_minotaur['is_valid'].set_opacity(BIG_OPACITY)\n        blocks_minotaur['next_theseus_positions'].set_opacity(BIG_OPACITY)\n        blocks_minotaur['bfs'].set_opacity(BIG_OPACITY)\n        self.play(AnimationGroup(AnimationGroup(Transform(blocks['is_valid'], blocks_minotaur['is_valid']), Transform(ntp_copy, blocks_minotaur['next_theseus_positions']), Transform(blocks['bfs_deque'], blocks_minotaur['bfs']), self.camera.frame.animate.move_to(blocks_minotaur['next_minotaur_position'].background_mobject)), AnimationGroup(FadeIn(blocks_minotaur['next_minotaur_position'].background_mobject)), lag_ratio=0.5))\n        self.play(Write(blocks_minotaur['next_minotaur_position'].code[:2]))\n        highlight = CreateHighlightCodeLine(blocks_minotaur['next_minotaur_position'], 1, start=8, end=10)\n        self.play(FadeIn(highlight), run_time=0.5)\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks_minotaur['next_minotaur_position'], 1, start=25, end=26)), run_time=0.5)\n        self.play(Transform(highlight, CreateHighlightCodeLine(blocks_minotaur['next_minotaur_position'], 1, start=42, end=44)), run_time=0.5)\n        self.play(FadeOut(highlight), run_time=0.5)\n        blocks_minotaur['next_minotaur_position_move_forward_example'].move_to(blocks_minotaur['next_minotaur_position'])\n        self.camera.frame.save_state()\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(blocks_minotaur['next_minotaur_position_move_forward_example'].code[3:6]).scale(0.5), FadeIn(blocks_minotaur['next_minotaur_position_move_forward_example'].code[3:6]), lag_ratio=0.5))\n        self.play(AnimationGroup(FadeOut(blocks_minotaur['next_minotaur_position_move_forward_example'].code[3:6]), self.camera.frame.animate.restore(), lag_ratio=0.5))\n        self.play(Write(blocks_minotaur['next_minotaur_position'].code[2:]))\n        highlight = CreateHighlightCodeLines(blocks_minotaur['next_minotaur_position'], [8, 9, 10, 11, 12], offset=2)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_minotaur_position'], [14, 15, 16, 17, 18], offset=2)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_minotaur_position'], [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18], offset=1)))\n        self.play(FadeOut(highlight))\n        self.play(AnimationGroup(AnimationGroup(FadeCode(blocks_minotaur['next_minotaur_position']), self.camera.frame.animate.move_to(blocks_minotaur['next_states'].background_mobject)), AnimationGroup(FadeIn(blocks_minotaur['next_states'].background_mobject), Write(blocks_minotaur['next_states'].code)), lag_ratio=0.5))\n        highlight = CreateHighlightCodeLines(blocks_minotaur['next_states'], [1], offset=1)\n        self.play(FadeIn(highlight))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_states'], [4], offset=1)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_states'], [5], offset=2)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_states'], [7, 8], offset=2)))\n        self.play(Transform(highlight, CreateHighlightCodeLines(blocks_minotaur['next_states'], [10], offset=2)))\n        self.play(FadeOut(highlight))\n        maze_str = ['##########', '# #     E#', '# # # ####', '# T # M  #', '### # ## #', '#   #    #', '## ## # ##', '#  #  #  #', '##########']\n        solution = [((2, 3), (6, 3)), ((3, 3), (5, 3)), ((3, 4), (5, 4)), ((3, 5), (5, 5)), ((2, 5), (5, 5)), ((2, 6), (5, 6)), ((2, 7), (4, 7)), ((2, 6), (4, 7)), ((2, 5), (4, 7)), ((3, 5), (4, 7)), ((3, 4), (4, 7)), ((3, 3), (4, 7)), ((3, 2), (4, 7)), ((3, 1), (4, 7)), ((4, 1), (4, 7)), ((5, 1), (5, 6)), ((6, 1), (6, 5)), ((7, 1), (7, 5)), ((8, 1), (8, 4))]\n        maze, maze_dict = maze_to_vgroup(maze_str)\n        maze.next_to(blocks_minotaur['output'], LEFT, buff=ALIGN_SPACING)\n        maze.align_to(blocks_minotaur['output'], UP)\n        theseus = ImageMobject('assets/theseus-nobackground-outline.png').set_height(0.8).move_to(maze_dict[solution[0][0]]).set_z_index(10000000)\n        minotaur = ImageMobject('assets/minotaur-nobackground-outline.png').set_height(0.8).move_to(maze_dict[solution[0][1]]).set_z_index(10000000)\n        door = ImageMobject('assets/door-outline.png').set_height(0.8).move_to(maze_dict[solution[-1][0]]).set_z_index(10000000000000000000000000)\n        numbers_x = VGroup(*[Tex(str(i), color=BLACK).scale(0.85).move_to(maze_dict[i, 0]).set_z_index(1000000000) for i in range(1, len(maze_str[0]) - 1)])\n        numbers_y = VGroup(*[Tex(str(i), color=BLACK).scale(0.85).move_to(maze_dict[0, i]).set_z_index(1000000000) for i in range(1, len(maze_str) - 1)])\n        self.play(AnimationGroup(FadeCode(blocks_minotaur['next_states']), AnimationGroup(FadeIn(blocks_minotaur['output'].background_mobject), Write(blocks_minotaur['output'].code), self.camera.frame.animate.move_to(VGroup(maze, blocks_minotaur['output'])).scale(0.9), FadeIn(maze), FadeIn(theseus), FadeIn(minotaur), FadeIn(door)), AnimationGroup(AnimationGroup(*[FadeIn(n) for n in numbers_x], lag_ratio=0.05), AnimationGroup(*[FadeIn(n) for n in numbers_y], lag_ratio=0.05)), lag_ratio=0.5))\n        highlight = CreateHighlightCodeLine(blocks_minotaur['output'], 1)\n        prev_m = None\n        for i, (t, m) in enumerate(solution):\n            anim = None\n            if i == 0:\n                anim = FadeIn(highlight)\n            else:\n                anim = Transform(highlight, CreateHighlightCodeLine(blocks_minotaur['output'], i + 1))\n            anim2 = None\n            if t == solution[-1][0]:\n                anim2 = theseus.animate.set_opacity(0).move_to(maze_dict[t])\n            else:\n                anim2 = theseus.animate.move_to(maze_dict[t])\n            run_time = 1 if i <= 2 else FAST_RUNTIME\n            if prev_m == m:\n                maze_dict[t].set_z_index(0.05)\n                self.play(AnimationGroup(AnimationGroup(anim, anim2), maze_dict[t].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE), lag_ratio=0.33), run_time=run_time)\n            else:\n                maze_dict[t].set_z_index(0.05)\n                maze_dict[m].set_z_index(0.05)\n                self.play(AnimationGroup(AnimationGroup(AnimationGroup(anim, anim2), maze_dict[t].animate.set_fill(ORANGE, 0.75).set_stroke_color(ORANGE), lag_ratio=0.33), AnimationGroup(minotaur.animate.move_to(maze_dict[m]), maze_dict[m].animate.set_fill(BLUE, 0.75).set_stroke_color(BLUE), lag_ratio=0.33), lag_ratio=0.25), run_time=run_time)\n            prev_m = m\n        self.next_section()\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Render a 3D graph of a function over specified axes with ambient camera rotation and checkerboard coloring."}, {"role": "assistant", "content": "from utilities import *\n\nclass Intro(ThreeDScene):\n\n    def construct(self):\n        n = 4\n        resolution = 32\n        g = parse_graph('\\n1 2 <14.955583178269885, 12.492887677476215> <16.3169159925859, 18.518980248079334>\\n3 2 <10.488387335146333, 16.6269826120094> <16.3169159925859, 18.518980248079334>\\n1 3 <14.955583178269885, 12.492887677476215> <10.488387335146333, 16.6269826120094>\\n1 4 <14.955583178269885, 12.492887677476215> <15.748659587666504, 6.403292853126976>\\n2 5 <16.3169159925859, 18.518980248079334> <15.588570469025248, 24.63764356262158>\\n2 6 <16.3169159925859, 18.518980248079334> <22.433423744442276, 19.229414535025658>\\n                ', s=0.12, t=0.12).scale(GRAPH_SCALE)\n        f = tutte(g.vertices, g.edges)\n        axes = ThreeDAxes(x_length=4.5, y_length=4.5, z_length=4.5)\n        x_start, x_end = (-2.5, 2.5)\n        y_start, y_end = (-2.5, 2.5)\n        surface = Surface(lambda x, y: axes.c2p(x, y, f(x, y)), u_range=[x_start, x_end], v_range=[y_start, y_end], resolution=resolution)\n        surface.set_fill_by_checkerboard(LIGHT_GRAY, DARK_GRAY, opacity=0.5)\n        surface.set_style(fill_opacity=1)\n        self.set_camera_orientation(theta=120 * DEGREES, phi=75 * DEGREES)\n        self.renderer.camera.light_source.move_to(3 * IN)\n        axes.scale(1.5)\n        surface.scale(1.5)\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.play(Write(axes))\n        self.play(Write(surface), run_time=1)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Visualize two graphs, highlight the edges of a random spanning tree in one, then display the graph rank formula as a transformation."}, {"role": "assistant", "content": "from utilities import *\n\nclass Definitions(Scene):\n\n    def construct(self):\n        g = parse_graph('\\n12 14 <6.603275758877981, 0.22200042158063704> <10.542340602049554, 5.0486231945767255>\\n2 12 <6.603275758877981, 0.22200042158063704> <10.542340602049554, 5.0486231945767255>\\n1 2 <6.603275758877981, 0.22200042158063704> <10.542340602049554, 5.0486231945767255>\\n1 3 <6.603275758877981, 0.22200042158063704> <0.8751494485961517, 2.8894436903527834>\\n2 4 <10.542340602049554, 5.0486231945767255> <8.316429210045438, 9.49508367004807>\\n1 5 <6.603275758877981, 0.22200042158063704> <5.320620964273308, -6.074692063436867>\\n3 6 <0.8751494485961517, 2.8894436903527834> <-4.8178524679438075, 0.2426494079303798>\\n6 7 <-4.8178524679438075, 0.2426494079303798> <-10.765611934215096, -1.6359342354516002>\\n7 8 <-10.765611934215096, -1.6359342354516002> <-12.201191317109153, 3.5640128560657254>\\n3 9 <0.8751494485961517, 2.8894436903527834> <-0.22868399658749183, 8.989711296016043>\\n6 10 <-4.8178524679438075, 0.2426494079303798> <-6.36641219483813, -5.744685968682711>\\n1 12 <6.603275758877981, 0.22200042158063704> <11.495122080884329, -4.388454491563957>\\n7 10 <-10.765611934215096, -1.6359342354516002> <-6.36641219483813, -5.744685968682711>\\n5 12 <5.320620964273308, -6.074692063436867> <11.495122080884329, -4.388454491563957>\\n3 11 <0.8751494485961517, 2.8894436903527834> <0.4357598447196547, -3.4516057795938906>\\n2 14 <10.542340602049554, 5.0486231945767255> <16.235759844719652, 1.2483942204061114>\\n                ', s=0.09, t=-0.09, scale=GRAPH_SCALE)\n        g = parse_graph('\\n6 7 <54.25855271252895, 12.605258737045363> <49.97809002456518, 17.223303631173835>\\n1 2 <54.25855271252895, 12.605258737045363> <49.97809002456518, 17.223303631173835>\\n2 3 <49.97809002456518, 17.223303631173835> <48.02294843888141, 11.350789057404267>\\n4 3 <52.149033019191855, 6.802331116231416> <48.02294843888141, 11.350789057404267>\\n1 4 <54.25855271252895, 12.605258737045363> <52.149033019191855, 6.802331116231416>\\n1 3 <54.25855271252895, 12.605258737045363> <48.02294843888141, 11.350789057404267>\\n2 5 <49.97809002456518, 17.223303631173835> <49.74637608557099, 23.451457900736685>\\n6 2 <43.65095804413591, 17.90980753240204> <49.97809002456518, 17.223303631173835>\\n3 7 <48.02294843888141, 11.350789057404267> <41.570463661087516, 11.264455652109186>\\n7 8 <41.570463661087516, 11.264455652109186> <37.54525580765764, 16.20621404223973>\\n6 8 <43.65095804413591, 17.90980753240204> <37.54525580765764, 16.20621404223973>\\n9 8 <35.656960798955396, 22.156374762503873> <37.54525580765764, 16.20621404223973>\\n7 10 <41.570463661087516, 11.264455652109186> <36.787106474033266, 7.267481585540526>\\n11 8 <32.58556368601467, 12.426968450935073> <37.54525580765764, 16.20621404223973>\\n8 12 <37.54525580765764, 16.20621404223973> <31.554060828717343, 18.03169739449139>\\n2 13 <49.97809002456518, 17.223303631173835> <56.10183864395022, 18.439664762058413>\\n1 13 <54.25855271252895, 12.605258737045363> <56.10183864395022, 18.439664762058413>\\n1 14 <54.25855271252895, 12.605258737045363> <60.76717116984745, 12.659450257008507>\\n15 14 <67.01144901151935, 12.83577484836884> <60.76717116984745, 12.659450257008507>\\n14 16 <60.76717116984745, 12.659450257008507> <64.0003798835964, 7.329479394566733>\\n17 14 <62.30058045153706, 18.742885487319455> <60.76717116984745, 12.659450257008507>\\n17 13 <62.30058045153706, 18.742885487319455> <56.10183864395022, 18.439664762058413>\\n17 18 <62.30058045153706, 18.742885487319455> <66.7506950936482, 23.079993839461366>\\n                ', s=0.08, t=-0.07, scale=GRAPH_SCALE)\n        self.play(Write(g))\n        seed(2)\n        st = get_random_spanning_tree(g.vertices, g.edges)\n        self.play(*[g.edges[e].animate.set_color(HIDDEN_COLOR) for e in g.edges if e not in st], *[Flash(g.edges[e], color=WHITE) for e in g.edges if e not in st])\n        self.play(g.animate.shift(DOWN * 0.7))\n        rank = Tex('\\\\small {\\\\bf rank:} r(G)').next_to(g, UP).shift(UP * 0.45)\n        self.play(Write(rank))\n        equal = Tex('\\\\small $=$').move_to(rank).align_to(g)\n        vm = Tex('\\\\small $|V|\\\\ -$').next_to(equal, RIGHT)\n        one = Tex('\\\\small $1$').next_to(vm, RIGHT)\n        self.play(LaggedStart(AnimationGroup(rank.animate.next_to(equal, LEFT)), AnimationGroup(Write(equal), Write(vm), Write(one)), lag_ratio=0.5))\n        cg = Tex('\\\\small $c(G)$').next_to(vm, RIGHT)\n        exclude = [(1, 14), (17, 13), (3, 7), (6, 2)]\n        self.play(*[FadeOut(g.edges[e]) for e in exclude])\n        self.play(Transform(one, cg))"}]}
{"messages": [{"role": "user", "content": "Visualize a grid of houses with varying populations and animate paths connecting them to an optimal meeting location."}, {"role": "assistant", "content": "from manim import *\nfrom random import uniform, seed, choice\n\nclass Intro(MovingCameraScene):\n\n    def construct(self):\n        self.camera.background_color = DARKER_GRAY\n        grid_x = 3\n        grid_y = 6\n        grid = VGroup()\n        self.camera.frame.scale(0.54)\n\n        def distance(p1, p2):\n            return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** (1 / 2)\n\n        def distance_but_kinda_l(p1, p3):\n            p2 = np.asarray([p1[0], p3[1], 0])\n            return distance(p1, p2) + distance(p2, p3)\n\n        def create_double_line_nodash(p_start, p_end, direction: bool):\n            p1 = p_start\n            if direction:\n                p2 = np.asarray([p_start[0], p_end[1], 0])\n            else:\n                p2 = np.asarray([p_end[0], p_start[1], 0])\n            p3 = p_end\n            if len(p1) == 2:\n                p1 = (p1[0], p1[1], 0)\n            if len(p3) == 2:\n                p3 = (p3[0], p3[1], 0)\n            return Path([p1, p2, p3])\n\n        def create_double_line(p_start, p_end, direction: bool):\n            p1 = p_start\n            if direction:\n                p2 = np.asarray([p_start[0], p_end[1], 0])\n            else:\n                p2 = np.asarray([p_end[0], p_start[1], 0])\n            p3 = p_end\n            if len(p1) == 2:\n                p1 = (p1[0], p1[1], 0)\n            if len(p3) == 2:\n                p3 = (p3[0], p3[1], 0)\n            total_distance = distance(p1, p2) + distance(p2, p3)\n            return (total_distance, DashedPath([p1, p2, p3], num_dashes=int(total_distance * 10)).set_color(GRAY))\n        stupid = [(-2, -2), (-1, -4), (-1, 4)]\n\n        def get_id(obj):\n            return True\n\n        def update_number(obj, dt, dot, start, goal, people):\n            d = distance(start, obj.get_center()) * 2\n            opacity = 1 if d > 0.5 else d\n            opacity = min(opacity, distance(obj.get_center(), goal) * 2)\n            d *= people\n            obj.become(Tex(f'{d:.1f}').scale(0.5).set_opacity(opacity))\n\n        def get_steps(places, place):\n            total = 0\n            x1, y1 = place\n            for x2, y2 in places:\n                total += (abs(x1 - x2) + abs(y1 - y2)) * places[x2, y2]\n            return total\n\n        def find_optimal_meeting_place(places):\n            min_steps = float('inf')\n            min_pos = None\n            for p in [(x, y) for x in range(-100, 100) for y in range(-100, 100)]:\n                steps = get_steps(places, p)\n                if steps < min_steps:\n                    min_steps = steps\n                    min_pos = p\n            return min_pos\n        places = {(2, -1): 3, (-2, 2): 6, (1, -5): 8, (2, 5): 9, (-2, -2): 1, (-1, -4): 3, (-1, 4): 5, (-0, -0): 10}\n        meeting_place = find_optimal_meeting_place(places)\n        place_double_lines = {p: create_double_line(p, meeting_place, get_id(p))[1] for p in places}\n        place_double_lines_dots = {p: Dot().move_to((p[0], p[1], 0)) for p in places}\n        place_double_lines_text = {p: Tex() for p in places}\n        place_double_lines_nodash = {p: create_double_line_nodash(p, meeting_place, get_id(p)) for p in places}\n        house_objects = {}\n        for y in reversed(range(-grid_y, grid_y + 1)):\n            for x in range(-grid_x, grid_x + 1):\n                if (x, y) in places:\n                    obj = VGroup(SVGMobject('resources/house.svg').scale(0.35), Tex(places[x, y], color=self.camera.background_color).set_opacity(0).scale(0.85).shift(DOWN * 0.06))\n                    house_objects[x, y] = obj\n                else:\n                    obj = Dot().scale(0.5)\n                obj.shift(RIGHT * x + UP * y)\n                obj.set_z_index(10)\n                grid.add(obj)\n        self.play(FadeIn(grid, lag_ratio=0.01), run_time=1)\n        self.play(AnimationGroup(*[AnimationGroup(house_objects[p][1].animate(run_time=0.5).set_opacity(1), Flash(house_objects[p][1], flash_radius=0.5, line_length=0.1, color=WHITE)) for p in house_objects], lag_ratio=0.05))\n        for p in place_double_lines_dots:\n            place_double_lines_dots[p].set_z_index(1)\n\n        def get_uniform(p):\n            seed(id(p))\n            return uniform(3, 4.5)\n        self.play(*[FadeIn(place_double_lines[p], run_time=get_uniform(p)) for p in place_double_lines], *[MoveAlongPath(place_double_lines_dots[p], place_double_lines_nodash[p], run_time=get_uniform(p)) for p in place_double_lines], lag_ratio=1, rate_func=linear)"}]}
{"messages": [{"role": "user", "content": "Animate a graph coloring visualization with a focus on chromatic polynomials, graph properties, and related mathematical concepts."}, {"role": "assistant", "content": "from manim import *\nfrom random import seed, shuffle, uniform\nfrom math import comb\nfrom itertools import combinations, product\nimport sympy\nfrom sympy.abc import x, y\nimport networkx as nx\nfrom pulp import *\n\nclass Introo(MovingCameraScene):\n\n    def get_graphy_graphy(self, g_nx):\n        ax = Axes(x_range=[-0.25, 3, 1], y_range=[-5, 24, 1], tips=False, y_axis_config={'include_ticks': False}, x_axis_config={'include_ticks': False, 'include_numbers': True})\n        f = lambda i: float(chromatic(g_nx.nodes, g_nx.edges).subs(x, i))\n        graph = ax.plot(f, x_range=[-0.35, 3.1, 0.01])\n        a = Dot(ax.c2p(0, 0)).scale(1.5).set_z_index(1)\n        b = Dot(ax.c2p(1, 0)).scale(1.5).set_z_index(1)\n        c = Dot(ax.c2p(2, 0)).scale(1.5).set_z_index(1)\n        d = Dot(ax.c2p(3, 24)).scale(1.5).set_z_index(1)\n        bn = Tex('0').next_to(b, UP).set_z_index(1)\n        cn = Tex('0').next_to(c, UP).set_z_index(1)\n        dn = Tex('24').next_to(d, LEFT).set_z_index(1)\n        x_label = ax.get_x_axis_label('n')\n        graph = CurvesAsSubmobjects(graph).set_color_by_gradient(DARKER_GRAY, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, WHITE, DARKER_GRAY)\n        return (ax, x_label, graph, a, b, c, d, bn, cn, dn)\n\n    def construct(self):\n        seed(3735928559)\n        g_nx = nx.windmill_graph(3, 3)\n        p = Tex('$$\\n\\\\begin{aligned}\\nT(G) &= x^{6} + 3 x^{5} \\\\\\\\[-0.1cm]\\n    &+ 3 x^{4} y + 3 x^{4} \\\\\\\\[-0.1cm]\\n    &+ 6 x^{3} y + x^{3} \\\\\\\\[-0.1cm]\\n    &+ 3 x^{2} y^{2} + 3 x^{2} y \\\\\\\\[-0.1cm]\\n    &+ 3 x y^{2} + y^{3}\\n\\\\end{aligned}$$').scale(2)\n        good_for = Tex('\\n        \\\\begin{itemize} \\\\item $T_{1,1} = $ \\\\# of spanning trees\\n                        \\\\item $T_{2,0} = $ \\\\# of acyclic orientations\\n                        \\\\item measures network reliability\\n                        \\\\item calculates linear codes\\n                        \\\\item has ties to quantum field theory\\n                       \\\\end{itemize}')\n        colorings = get_all_colorings(g_nx.nodes, g_nx.edges, 3)\n        g = Graph.from_networkx(g_nx, layout='spring', layout_scale=0.8, layout_config={'seed': 1}).scale(5).rotate(1.26).move_to(ORIGIN)\n        coloring = get_coloring(g_nx.nodes, g_nx.edges)\n        random_vertices = list(g.vertices)\n        shuffle(random_vertices)\n        a = Tex('\\\\underline{How many $n$-colorings?}').scale(2.15)\n        b = Tex('(adjacent vertices $=$ different colors)').scale(1.25).next_to(a, DOWN, buff=0.7)\n        texts = VGroup(a, b)\n        spacing = 3\n        g.next_to(b, DOWN, buff=spacing)\n        self.camera.frame.move_to(Group(a, b, g))\n        g.move_to(self.camera.frame)\n        self.play(Write(g))\n        diff = -g.get_center() + g.copy().next_to(b, DOWN, buff=spacing).get_center()\n        self.play(AnimationGroup(AnimationGroup(g.animate.next_to(b, DOWN, buff=spacing), AnimationGroup(*[g.vertices[v].animate.set_color(coloring[v]).shift(diff) for v in random_vertices])), AnimationGroup(FadeIn(a), FadeIn(b)), lag_ratio=0.5))\n        graph_grid = VGroup()\n        for c in colorings:\n            gc = g.copy()\n            graph_grid.add(gc)\n            for i, vertex in enumerate(gc.vertices):\n                gc.vertices[vertex].set_color(c[i]).scale(2)\n        graph_grid.scale(0.125).arrange_in_grid(cols=4, buff=0.2)\n        box = SurroundingRectangle(graph_grid, color=GRAY, buff=0.25, corner_radius=0.2, stroke_width=5)\n        ax, x_label, graph, a, b, c, d, bn, cn, dn = self.get_graphy_graphy(g_nx)\n        d.set_z_index(1)\n        dn.set_z_index(1)\n        beeg_g = VGroup(ax, x_label, graph, a, b, c, d, bn, cn, dn)\n        beeg_g.scale(0.9).align_to(g, DOWN).shift(DOWN * 4)\n        line = Line(start=Dot().scale(1e-05).next_to(box, RIGHT, buff=0).shift(DOWN * 0.5).get_center(), end=d.get_center(), color=GRAY)\n        c = Tex(f'$$\\\\chi(G) = {polynomial_to_tex(chromatic(g_nx.nodes, g_nx.edges))}$$').next_to(beeg_g, DOWN, buff=-0.2)\n        shitty_code_delta = 0.5\n        c.shift(DOWN * shitty_code_delta)\n        c[0][2].set_opacity(0)\n        cin = g.copy().set_color(WHITE).move_to(c[0][2]).set_height(c[0][2].get_height())\n        self.play(self.camera.frame.animate.move_to(VGroup(g, beeg_g, texts, c)), FadeIn(ax), FadeIn(x_label), Succession(Wait(0.25), Write(graph, run_time=1)), Succession(Wait(0.25), FadeIn(c, run_time=1)), Succession(Wait(0.5), FadeIn(cin, run_time=1)), AnimationGroup(*[FadeIn(o) for o in [a, b, c, d]], lag_ratio=0.25), AnimationGroup(*[FadeIn(o) for o in [Dot().shift(LEFT * 1000), bn, cn, dn]], lag_ratio=0.25))\n        t = 8\n        self.play(AnimationGroup(Transform(g, graph_grid[t]), AnimationGroup(FadeIn(graph_grid[:t]), FadeIn(graph_grid[t:]), FadeIn(box), FadeIn(line)), lag_ratio=0.5))\n        p[0][2].set_opacity(0)\n        c.shift(UP * shitty_code_delta)\n        p.next_to(c, DOWN, buff=4)\n        c.shift(DOWN * shitty_code_delta)\n        idkman = g.copy().set_color(WHITE).move_to(p[0][2]).set_height(p[0][2].get_height()).shift(DOWN * 0.04)\n        self.play(AnimationGroup(self.camera.frame.animate.next_to(self.camera.frame, DOWN, buff=-2), AnimationGroup(FadeIn(p), FadeIn(idkman, run_time=1)), lag_ratio=0.5))\n        good_for.scale(1.25).next_to(p, DOWN, buff=2).align_to(p, LEFT)\n        good_for[0][0:22].set_color(RED)\n        good_for[0][22:50].set_color(BLUE)\n        self.play(FadeIn(good_for[0][0:22]))\n        self.play(FadeIn(good_for[0][22:50]))\n        s = 11\n        seed(s)\n        nxgraph = nx.erdos_renyi_graph(12, 0.45, seed=s)\n        G = Graph.from_networkx(nxgraph, layout='spring', layout_scale=3.5, layout_config={'seed': s}).rotate(PI / 7 + PI).scale(1.15)\n        for e in G.edges:\n            G.edges[e].set_stroke_width(uniform(1, 7))\n            G.edges[e].set_opacity(uniform(0, 1))\n        for v in G.vertices:\n            G.vertices[v].scale(uniform(2, 3.5))\n        G.next_to(p, DOWN, buff=7)\n        self.play(FadeIn(good_for[0][50:77]), FadeIn(G))\n        self.play(FadeOut(G))\n        quantum = ImageMobject('assets/index.png').set_width(self.camera.frame.get_width() * 0.5)\n        quantum.next_to(p, DOWN, buff=8.4)\n        lc = Tex('$$\\\\begin{pmatrix}\\n            1 & 1 & 0 & 1 & 0 & 0 & 0 \\\\\\\\\\n            0 & 1 & 1 & 0 & 1 & 0 & 0 \\\\\\\\\\n            0 & 0 & 1 & 1 & 0 & 1 & 0 \\\\\\\\\\n            0 & 0 & 0 & 1 & 1 & 0 & 1\\n        \\\\end{pmatrix}$$').scale(1.5)\n        lc.next_to(p, DOWN, buff=8.4)\n        self.play(FadeIn(good_for[0][77:99]), FadeIn(lc))\n        self.play(FadeOut(lc))\n        self.play(FadeIn(good_for[0][99:]), FadeIn(quantum))\n        title = ImageMobject('assets/handbook.png').set_width(self.camera.frame.get_width() * 0.8)\n        title.next_to(self.camera.frame, RIGHT, buff=1)\n        for m in self.mobjects:\n            self.remove(m)\n        self.add(p)\n        self.add(good_for)\n        self.add(idkman)\n        self.add(quantum)\n        self.play(AnimationGroup(AnimationGroup(self.camera.frame.animate.move_to(title)), FadeIn(title), lag_ratio=0.75))\n        self.play(FadeOut(title))"}]}
{"messages": [{"role": "user", "content": "Render a 3D surface with axes, highlight two specific points on the surface with labels, and animate the camera rotating around the scene."}, {"role": "assistant", "content": "from manim import *\nfrom random import seed, shuffle, uniform\nfrom math import comb\nfrom itertools import combinations, product\nimport sympy\nfrom sympy.abc import x, y\nimport networkx as nx\nfrom pulp import *\n\nclass TP(ThreeDScene):\n\n    def construct(self):\n        resolution_fa = 24\n        phi = 75 * DEGREES\n        theta = 100 * DEGREES\n        self.set_camera_orientation(phi=phi, theta=theta)\n        rate = 0.2\n        self.begin_ambient_camera_rotation(rate=rate)\n        scale = 1 / 750\n        f = lambda x, y: [x, y, (x ** 6 + 3 * x ** 5 + 3 * x ** 4 * y + 3 * x ** 4 + 6 * x ** 3 * y + x ** 3 + 3 * x ** 2 * y ** 2 + 3 * x ** 2 * y + 3 * x * y ** 2 + y ** 3) * scale]\n        surface = Surface(f, resolution=(resolution_fa, resolution_fa), v_range=[-3, +3], u_range=[-3, +3])\n        surface.scale(1.2, about_point=ORIGIN)\n        surface.set_style(fill_opacity=1, stroke_color=WHITE)\n        surface.set_fill_by_checkerboard(GREEN_C, GREEN_E, opacity=1)\n        axes = ThreeDAxes()\n        spanning = f(1, 1)[-1] / scale\n        orient = f(2, 0)[-1] / scale\n        sw = 3\n        a = Dot3D(point=axes.coords_to_point(1, 1, f(1, 1)[-1]), color=RED, stroke_width=sw, stroke_color=BLACK).scale(3)\n        b = Dot3D(point=axes.coords_to_point(2, 0, f(2, 0)[-1]), color=BLUE, stroke_width=sw, stroke_color=BLACK).scale(3)\n        self.add(axes)\n        self.add(surface)\n        st = Tex(f'\\\\textbf{{{int(spanning)}}}', color=RED, stroke_width=sw, stroke_color=BLACK).rotate(phi, axis=RIGHT).rotate(theta + PI / 2, axis=OUT).move_to(a).shift(OUT).scale(1.5)\n        st.add_updater(lambda x, dt: x.rotate(rate * dt, axis=OUT))\n        st.set_opacity(0)\n        ori = Tex(f'\\\\textbf{{{int(orient)}}}', color=BLUE, stroke_width=sw, stroke_color=BLACK).rotate(phi, axis=RIGHT).rotate(theta + PI / 2, axis=OUT).move_to(b).shift(OUT).scale(1.5)\n        ori.add_updater(lambda x, dt: x.rotate(rate * dt, axis=OUT))\n        ori.set_opacity(0)\n        self.add(st)\n        self.add(ori)\n        self.wait(5.083333)\n        self.play(FadeIn(a), st.animate.set_opacity(1))\n        self.wait(1.7)\n        self.play(FadeIn(b), ori.animate.set_opacity(1))\n        self.wait(3.33333)"}]}
{"messages": [{"role": "user", "content": "Visualize the generation and transformation of binary trees with star labels, illustrating a mathematical formula."}, {"role": "assistant", "content": "from utilities import *\n\nclass ConstructStarsExample(MovingCameraScene):\n\n    def construct(self):\n        height_scale = 1.6\n        star_offset = 0.25\n        n = 4\n        tree = BinaryTree.generate_binary_trees(n)[6]\n        tree_nolabels = tree.copy()\n        StarUtilities.add_stars_to_graph(tree, star_offset=star_offset)\n        StarUtilities.add_stars_to_graph(tree_nolabels, star_offset=star_offset, no_labels=True)\n        self.camera.frame.move_to(tree).set_height(tree.height * height_scale)\n        self.play(FadeIn(tree_nolabels, shift=DOWN * 0.1))\n        self.play(AnimationGroup(*[Wiggle(tree_nolabels.vertices[s], scale_value=1.5) for s in StarUtilities.get_all_stars(tree_nolabels)], lag_ratio=0.03))\n        self.play(AnimationGroup(*[FadeIn(tree.vertices[s][1], run_time=0.6) for s in StarUtilities.get_all_stars(tree)], lag_ratio=0.07), AnimationGroup(*[Circumscribe(tree.vertices[s][1], color=BLACK, run_time=0.6, shape=Circle, stroke_width=1.2, buff=0.01) for s in StarUtilities.get_all_stars(tree)], lag_ratio=0.07))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(tree)\n        from math import factorial\n        for i in range(30):\n            self.play(ChangeStars(tree, i, i + 1), run_time=0.5 if i < 3 else (1 / (i - 1)) ** (3 / 2))\n        self.play(ChangeStars(tree, i, factorial(n + 1) - 1), run_time=0.1)\n        self.wait(0.5)\n        TEXT_SCALE = 0.4\n        llb = Tex('$$\\\\mathrm{LLB}_{2n + 1} = C_n (n + 1)!$$').scale(TEXT_SCALE).next_to(tree, LEFT, buff=1)\n        llb_compute = Tex('$$= \\\\left(2 \\\\cdot 1\\\\right) \\\\left(2 \\\\cdot 3\\\\right) \\\\ldots \\\\left(2 \\\\cdot (2n + 1)\\\\right)$$').scale(TEXT_SCALE)\n        self.play(FadeIn(llb, shift=LEFT * 0.1), self.camera.frame.animate.move_to(VGroup(llb, tree)))\n        self.play(AnimationGroup(*[Circumscribe(tree.vertices[s], shape=Circle, color=WHITE if not StarUtilities.is_star_name(s) else GREEN, stroke_width=1, buff=0.03) for s in tree.vertices], lag_ratio=0.05))\n        tree.suspend_updating()\n        subtree = VGroup(tree.vertices['r'], tree.vertices['rl'], tree.vertices['star_1'], tree.vertices['star_2'], tree.vertices['star_3'], tree.edges['r', 'rl'], tree.edges['r', 'star_1'], tree.edges['rl', 'star_2'], tree.edges['rl', 'star_3'])\n        ldot = Dot().move_to(StarUtilities.get_star_position(tree, 'r', LEFT, star_offset=star_offset)).scale(0.5).set_color(DARK_GRAY)\n        rdot = Dot().move_to(StarUtilities.get_star_position(tree, 'r', RIGHT, star_offset=star_offset)).scale(0.5).set_color(DARK_GRAY)\n        vpos = tree.vertices['r'].get_center()\n        ldot_line = Line(vpos, ldot.get_center(), stroke_width=tree.edges['', 'r'].stroke_width * 0.75).set_color(DARK_GRAY)\n        rdot_line = Line(vpos, rdot.get_center(), stroke_width=tree.edges['', 'r'].stroke_width * 0.75).set_color(DARK_GRAY)\n        subtree.shift(DOWN)\n        scale = self.camera.frame.height / (VGroup(tree, llb).height * height_scale)\n        animation = self.camera.frame.animate.move_to(VGroup(tree, llb)).set_height(VGroup(tree, llb).height * height_scale)\n        subtree.shift(UP)\n        v = BinaryTree.generate_binary_trees(1)[0].move_to(vpos)\n        v.set_z_index(1)\n        self.play(AnimationGroup(AnimationGroup(subtree.animate.shift(DOWN), animation), AnimationGroup(FadeIn(v), AnimationGroup(FadeIn(ldot), Flash(ldot, color=DARK_GRAY, line_stroke_width=1, flash_radius=0.1, line_length=0.05), Write(ldot_line)), AnimationGroup(FadeIn(rdot), Flash(rdot, color=DARK_GRAY, line_stroke_width=1, flash_radius=0.1, line_length=0.05), Write(rdot_line)), lag_ratio=0.15), lag_ratio=0.5))\n        self.bring_to_back(ldot)\n        self.bring_to_back(rdot)\n        self.bring_to_back(ldot_line)\n        self.bring_to_back(rdot_line)\n        star = StarUtilities.create_star_object('6').move_to(rdot).set_z_index(1)\n        l1 = Line(vpos, ldot.get_center(), stroke_width=tree.edges['', 'r'].stroke_width)\n        l2 = Line(vpos, rdot.get_center(), stroke_width=tree.edges['', 'r'].stroke_width)\n        subtree.shift(UP * 0.5)\n        scale = self.camera.frame.height / (VGroup(tree, llb).height * height_scale)\n        animation = self.camera.frame.animate.move_to(VGroup(tree, llb)).set_height(VGroup(tree, llb).height * height_scale)\n        subtree.shift(DOWN * 0.5)\n        self.play(AnimationGroup(align_object_by_coords(subtree, tree.vertices['r'].get_center(), ldot.get_center(), animation=True), AnimationGroup(Write(star)), AnimationGroup(Write(l1), Write(l2), lag_ratio=0.1), lag_ratio=0.5), animation)\n        self.remove(ldot)\n        self.remove(rdot)\n        self.remove(ldot_line)\n        self.remove(rdot_line)\n        entire_tree = VGroup(tree, star, l1, l2, v)\n        align_object_by_coords(llb_compute, llb_compute[0][0].get_center(), llb[0][7].get_center())\n        llb_compute.shift(RIGHT * 1.23)\n        shift = RIGHT * 2.6\n        entire_tree.shift(shift)\n        animation = self.camera.frame.animate.move_to(VGroup(entire_tree, llb[0][8:]))\n        entire_tree.shift(-shift)\n        self.play(FadeOut(llb[0][0:8]), AnimationGroup(entire_tree.animate.shift(shift), FadeIn(llb_compute, shift=RIGHT * 0.2), lag_ratio=0.5), animation)\n        next_part = Tex('$$C_n = \\\\frac{\\\\left(2 \\\\cdot 1\\\\right) \\\\left(2 \\\\cdot 3\\\\right) \\\\ldots \\\\left(2 \\\\cdot (2n + 1)\\\\right)}{(n + 1)!}$$').scale(TEXT_SCALE)\n        align_object_by_coords(next_part, next_part[0][2].get_center(), llb_compute[0][0].get_center())\n        next_part.shift(LEFT * 0.5)\n\n        def return_symbol_transforms(a, b, i, j, n):\n            return [ReplacementTransform(a[0][i + k], b[0][j + k]) for k in range(n)]\n        tree.remove(tree.edges['', 'r'])\n        entire_tree.add(Line(tree.vertices[''].get_center(), v.get_center(), stroke_width=tree.edges['', 'r'].stroke_width))\n        self.play(*return_symbol_transforms(llb_compute, next_part, 0, 2, 24), *return_symbol_transforms(llb, next_part, 10, 27, 6), *return_symbol_transforms(llb, next_part, 8, 0, 2), Succession(Wait(0.2), FadeIn(next_part[0][26])))\n        more_next_part = Tex('$$C_n = \\\\frac{1}{n + 1} \\\\cdot \\\\binom{2n}{n}$$').scale(TEXT_SCALE)\n        align_object_by_coords(more_next_part, more_next_part[0][2].get_center(), next_part[0][2].get_center())\n        self.play(Transform(next_part[0][3:], more_next_part[0][3:]))\n        for o in self.mobjects:\n            self.remove(o)\n        mnp = more_next_part.copy().scale(1.5)\n        et = entire_tree.copy()\n        g = VGroup(mnp, et).arrange(buff=1.5)\n        self.play(Transform(more_next_part, mnp), Transform(entire_tree, et), self.camera.frame.animate.move_to(g))"}]}
{"messages": [{"role": "user", "content": "Display examples of Dyck paths, differentiate good from bad paths, and highlight a specific valid path with animated edges."}, {"role": "assistant", "content": "from utilities import *\n\nclass DyckPathExamples(MovingCameraScene):\n\n    def construct(self):\n        good_paths = VGroup(DyckPath([1, -1, 1, 1, -1, 1, -1, -1]), DyckPath([1, 1, 1, -1, -1, -1, 1, -1]), DyckPath([1, -1, 1, -1, 1, -1])).arrange()\n        good_paths[0].shift(UP + RIGHT * 0.5)\n        good_paths[1].shift(DOWN)\n        good_paths[2].shift(UP + LEFT * 0.5)\n        self.play(AnimationGroup(*[Write(p) for p in good_paths], lag_ratio=0.1))\n        good_paths = VGroup(good_paths[0], good_paths[2], good_paths[1])\n        self.play(good_paths.animate.arrange(DOWN, buff=0.54).move_to(LEFT * 3 + DOWN * 0.7), run_time=1.25)\n        dyck_paths = Tex('Dyck Paths').next_to(good_paths, UP, buff=0.7)\n        self.play(Write(dyck_paths))\n        bad_paths = VGroup(DyckPath([-1, 1, 1, -1, 1, -1]), DyckPath(list(reversed([-1, -1, 1, 1, 1, -1, -1]))), DyckPath([1, 1, -1, 1])).arrange(DOWN, buff=0.35).move_to(RIGHT * 3 + DOWN * 0.7)\n        cross = Tex('$\\\\times$').next_to(bad_paths, UP, buff=0.7).scale(2).set_color(RED)\n        self.play(AnimationGroup(AnimationGroup(*[Write(p) for p in bad_paths], lag_ratio=0.1), FadeIn(cross, shift=UP * 0.2), lag_ratio=0.1))\n        featured_path = good_paths[0]\n        self.play(self.camera.frame.animate.move_to(featured_path).set_width(featured_path.width * 1.5), FadeOut(good_paths[1]), FadeOut(good_paths[2]), FadeOut(bad_paths), FadeOut(cross), FadeOut(dyck_paths))\n        self.play(AnimationGroup(*list(map(lambda x: AnimationGroup(*x), zip([featured_path.path.edges[u, v].animate.set_color(GREEN if featured_path.deltas[u] == 1 else RED) for u, v in featured_path.path.edges], [Flash(featured_path.path.edges[u, v], line_width=0.04, flash_radius=0.05, line_stroke_width=1, line_length=0.04, color=GREEN if featured_path.deltas[u] == 1 else RED) for u, v in featured_path.path.edges]))), lag_ratio=0.1))"}]}
{"messages": [{"role": "user", "content": "Display a table of Dyck paths for increasing values of n, with paths scaled and organized in a grid."}, {"role": "assistant", "content": "from utilities import *\n\nclass AllDyckPaths(Scene):\n\n    def construct(self):\n        dp = [VGroup(*DyckPath.generate_dyck_paths(0)).arrange_in_grid(cols=1, buff=0.8).set_width(0.15), VGroup(*DyckPath.generate_dyck_paths(1)).arrange_in_grid(cols=1, buff=0.8).set_width(1), VGroup(*DyckPath.generate_dyck_paths(2)).arrange_in_grid(cols=1, buff=0.8).set_width(1.2), VGroup(*DyckPath.generate_dyck_paths(3)).arrange_in_grid(cols=1, buff=0.8).set_width(1.2), VGroup(*DyckPath.generate_dyck_paths(4)).arrange_in_grid(cols=2, buff=0.8).set_width(2.4)]\n        for graph in dp[2]:\n            for v in graph.path.vertices:\n                graph.path.vertices[v].scale(1.1)\n        for graph in dp[3]:\n            for v in graph.path.vertices:\n                graph.path.vertices[v].scale(1.4)\n        for graph in dp[4]:\n            for v in graph.path.vertices:\n                graph.path.vertices[v].scale(1.8)\n        table = Table([dp], element_to_mobject=lambda x: x, row_labels=[Tex('Dyck Paths').rotate(PI / 2)], col_labels=[Tex('1'), Tex('1'), Tex('2'), Tex('5'), Tex('14')], v_buff=0.4, h_buff=0.65, top_left_entry=Tex('$C_n$'), include_outer_lines=True)\n        table.remove(*table.get_vertical_lines())\n        self.play(FadeIn(table.get_entries()), AnimationGroup(Write(table.get_horizontal_lines()[0]), Write(table.get_horizontal_lines()[2]), Write(table.get_horizontal_lines()[1]), lag_ratio=0.25))"}]}
{"messages": [{"role": "user", "content": "Show a \"Full Binary Tree\" title, then zoom into a specific node and display its children, and finally display the entire tree."}, {"role": "assistant", "content": "from utilities import *\n\nclass FullBinaryTreeExample(MovingCameraScene):\n\n    def construct(self):\n        text = Tex('Full Binary Tree').scale(4.6)\n        tree = FullBinaryTree.generate_binary_trees(6)[50]\n        self.camera.frame.set_width(text.width * 1.5)\n        self.play(Write(text))\n        points = text[0][5].get_subpaths()[1]\n        avg = points[0]\n        for i in points[1:]:\n            avg += i\n        avg /= len(points)\n        diff = tree.vertices[''].get_center() - avg\n        tree.shift(-diff).shift(LEFT * 0.02)\n        self.add(tree.vertices[''])\n        self.play(self.camera.frame.animate.move_to(tree.vertices['']).scale(1 / 4), FadeOut(text))\n        show_first = [tree.vertices['l'], tree.vertices['r'], tree.edges['', 'l'], tree.edges['', 'r']]\n        self.play(AnimationGroup(self.camera.frame.animate.shift(DOWN * 0.5), AnimationGroup(*[Write(a) for a in show_first], lag_ratio=0.1), lag_ratio=0.3))\n        self.play(AnimationGroup(self.camera.frame.animate.move_to(tree).set_height(tree.height * 1.5), AnimationGroup(*[Write(a) for a in list(tree.vertices.values()) + list(tree.edges.values()) if a not in show_first + [tree.vertices['']]], lag_ratio=0.1, run_time=1.5), lag_ratio=0.3))"}]}
{"messages": [{"role": "user", "content": "Recursively decompose a Dyck path into its subpaths and visualize the process as a graph."}, {"role": "assistant", "content": "from utilities import *\n\nclass DyckToBinary(MovingCameraScene):\n\n    def construct(self):\n        dpath = DyckPath([1, -1, 1, 1, -1, -1, 1, 1, 1, -1, 1, -1, -1, -1])\n        self.camera.frame.set_width(dpath.width * 1.3)\n        self.play(Write(dpath, run_time=1.5))\n        all_paths = VGroup(dpath)\n        anim, todo = dpath.get_last_hill_animations()\n        self.play(anim)\n        todo()\n\n        def parallel_animate_subpath_creation(paths: List[DyckPath], all_paths, scale, vertices, edges):\n            return_paths = []\n            path_tuples = []\n            lines = []\n            for path in paths:\n                if len(path.deltas) == 0:\n                    continue\n                l_path, r_path = path.get_left_right_subpaths(scale)\n                vertices.append(l_path)\n                vertices.append(r_path)\n                avg = (path.get_center() + l_path.get_center()) / 2\n                avg = (path.get_center() + r_path.get_center()) / 2\n                return_paths.append(l_path)\n                return_paths.append(r_path)\n                self.bring_to_back(l_path)\n                l_pathcopy = l_path.copy().next_to(path, DOWN, buff=0.75).align_to(path, LEFT).scale(0.85)\n                l_path.fade(1)\n                self.bring_to_back(r_path)\n                r_pathcopy = r_path.copy().next_to(path, DOWN, buff=0.75).align_to(path, RIGHT).scale(0.85)\n                r_path.fade(1)\n                if l_pathcopy.height > r_pathcopy.height:\n                    r_pathcopy.align_to(l_pathcopy, DOWN)\n                else:\n                    l_pathcopy.align_to(r_pathcopy, DOWN)\n                all_paths.add(l_pathcopy)\n                all_paths.add(r_pathcopy)\n                lines.append(Line(path.get_center() * 0.5 + l_pathcopy.get_center() * 0.5, path.get_center() * 0.3 + l_pathcopy.get_center() * 0.7, stroke_width=3.3 * scale).set_opacity(0.3).scale(0.9))\n                edges.append((path, l_path, lines[-1]))\n                lines.append(Line(path.get_center() * 0.5 + r_pathcopy.get_center() * 0.5, path.get_center() * 0.3 + r_pathcopy.get_center() * 0.7, stroke_width=3.3 * scale).set_opacity(0.3).scale(0.9))\n                edges.append((path, r_path, lines[-1]))\n                path_tuples.append((path, l_path, r_path, l_pathcopy, r_pathcopy))\n            self.play(*[Transform(lp, lpc) for _, lp, rp, lpc, rpc in path_tuples], *[Transform(rp, rpc) for _, lp, rp, lpc, rpc in path_tuples], *[Succession(Wait(0.6), Write(line, run_time=0.5)) for line in lines], self.camera.frame.animate.move_to(all_paths).set_height(max(self.camera.frame.height, all_paths.height * 1.25)))\n            hill_anims = [lp.get_last_hill_animations() for _, lp, rp, lpc, rpc in path_tuples] + [rp.get_last_hill_animations() for _, lp, rp, lpc, rpc in path_tuples]\n            self.play(*[a for a, _ in hill_anims])\n            for _, todo in hill_anims:\n                todo()\n            for _, lp, rp, lpc, rpc in path_tuples:\n                all_paths.remove(lpc)\n                all_paths.remove(rpc)\n                all_paths.add(lp)\n                all_paths.add(rp)\n            return return_paths\n        vertices = [dpath]\n        edges = []\n        paths = parallel_animate_subpath_creation([dpath], all_paths, 1, vertices, edges)\n        paths = parallel_animate_subpath_creation(paths, all_paths, 1 * 0.75 ** 1, vertices, edges)\n        paths = parallel_animate_subpath_creation(paths, all_paths, 1 * 0.75 ** 2, vertices, edges)\n        paths = parallel_animate_subpath_creation(paths, all_paths, 1 * 0.75 ** 3, vertices, edges)\n        g = Graph([id(v) for v in vertices], [(id(u), id(v)) for u, v, _ in edges])\n        for path in all_paths:\n            g.vertices[id(path)].move_to(path).align_to(path, DOWN).scale(1.75)\n        for u, v, e in edges:\n            g.edges[id(u), id(v)].put_start_and_end_on(g.vertices[id(u)].get_center(), g.vertices[id(v)].get_center())\n        self.play(*[FadeTransform(path, g.vertices[id(path)]) for path in all_paths], self.camera.frame.animate.move_to(VGroup(*list(g.vertices.values()))).set_height(VGroup(*list(g.vertices.values())).height * 1.5), *[Transform(e, g.edges[id(u), id(v)]) for u, v, e in edges], run_time=1.5)"}]}
{"messages": [{"role": "user", "content": "Visualize the step-by-step evaluation of a mathematical expression by transforming its parts into a tree structure."}, {"role": "assistant", "content": "from utilities import *\n\nclass ExpressionExample(MovingCameraScene):\n\n    def construct(self):\n        expression = Tex('$(7+16) \\\\times ((9 - 3) \\\\div 2)$').scale(2)\n        g = Graph(['', 'l', 'r', 'll', 'lr', 'rl', 'rr', 'rll', 'rlr'], [('', 'l'), ('', 'r'), ('l', 'll'), ('l', 'lr'), ('r', 'rl'), ('r', 'rr'), ('rl', 'rll'), ('rl', 'rlr')], layout='tree', root_vertex='').flip().scale(3)\n        g_copy = g.copy()\n        g.suspend_updating()\n        for e in g.edges:\n            g.edges[e].scale(0.5)\n        align_object_by_coords(expression, expression[0][6].get_center(), g.vertices[''].get_center())\n        self.camera.frame.move_to(expression)\n        self.play(Write(expression, run_time=0.75))\n        self.play(AnimationGroup(AnimationGroup(expression[0][0].animate.fade(1), expression[0][5].animate.fade(1), expression[0][7].animate.fade(1), expression[0][15].animate.fade(1)), AnimationGroup(expression[0][1:5].animate.set_color(RED), Circumscribe(expression[0][1:5], color=RED), expression[0][8:15].animate.set_color(BLUE), Circumscribe(expression[0][8:15], color=BLUE)), lag_ratio=0.5))\n        group = VGroup(g.vertices[''], g.vertices['l'], g.vertices['r'])\n        self.play(AnimationGroup(AnimationGroup(align_object_by_coords(expression[0][0:6], expression[0][2].get_center(), g.vertices['l'].get_center(), animation=True), align_object_by_coords(expression[0][8:], expression[0][13].get_center(), g.vertices['r'].get_center(), animation=True)), AnimationGroup(Write(g.edges['', 'l']), Write(g.edges['', 'r'])), lag_ratio=0.5), self.camera.frame.animate.move_to(group).set_height(max(self.camera.frame.height, group.height * 2)))\n        self.play(AnimationGroup(AnimationGroup(expression[0][8].animate.fade(1), expression[0][12].animate.fade(1)), AnimationGroup(expression[0][2].animate.set_color(WHITE), expression[0][1:2].animate.set_color(RED), Circumscribe(expression[0][1:2], color=RED), expression[0][3:5].animate.set_color(BLUE), Circumscribe(expression[0][3:5], color=BLUE), expression[0][13].animate.set_color(WHITE), expression[0][9:12].animate.set_color(RED), Circumscribe(expression[0][9:12], color=RED), expression[0][14:15].animate.set_color(BLUE), Circumscribe(expression[0][14:15], color=BLUE)), lag_ratio=0.5))\n        group = VGroup(g.vertices[''], g.vertices['l'], g.vertices['r'], g.vertices['ll'], g.vertices['rr'])\n        self.play(AnimationGroup(AnimationGroup(align_object_by_coords(expression[0][1:2], expression[0][1:2].get_center(), g.vertices['ll'].get_center(), animation=True), align_object_by_coords(expression[0][3:5], expression[0][3:5].get_center(), g.vertices['lr'].get_center(), animation=True), align_object_by_coords(expression[0][9:12], expression[0][10].get_center(), g.vertices['rl'].get_center(), animation=True), align_object_by_coords(expression[0][14], expression[0][14].get_center(), g.vertices['rr'].get_center(), animation=True)), AnimationGroup(Write(g.edges['l', 'll']), Write(g.edges['l', 'lr']), Write(g.edges['r', 'rl']), Write(g.edges['r', 'rr'])), lag_ratio=0.5), self.camera.frame.animate.move_to(group).set_height(max(self.camera.frame.height, group.height * 1.6)))\n        self.play(expression[0][1].animate.set_color(WHITE), expression[0][3].animate.set_color(WHITE), expression[0][4].animate.set_color(WHITE), expression[0][10].animate.set_color(WHITE), expression[0][14].animate.set_color(WHITE), expression[0][9:10].animate.set_color(RED), Circumscribe(expression[0][9:10], color=RED), expression[0][11:12].animate.set_color(BLUE), Circumscribe(expression[0][11:12], color=BLUE))\n        group = VGroup(g.vertices[''], g.vertices['l'], g.vertices['r'], g.vertices['ll'], g.vertices['rr'], g.vertices['rll'], g.vertices['rlr'])\n        self.play(AnimationGroup(AnimationGroup(align_object_by_coords(expression[0][9], expression[0][9].get_center(), g.vertices['rll'].get_center(), animation=True), align_object_by_coords(expression[0][11], expression[0][11].get_center(), g.vertices['rlr'].get_center(), animation=True)), AnimationGroup(Write(g.edges['rl', 'rll']), Write(g.edges['rl', 'rlr'])), lag_ratio=0.5), self.camera.frame.animate.move_to(group).set_height(max(self.camera.frame.height, group.height * 1.4)))\n        for v in g.vertices:\n            g.vertices[v].scale(1.5)\n        self.play(*[Transform(g.edges[e], g_copy.edges[e]) for e in g_copy.edges], FadeTransform(expression[0][6], g.vertices['']), FadeTransform(expression[0][2], g.vertices['l']), FadeTransform(expression[0][13], g.vertices['r']), FadeTransform(expression[0][1], g.vertices['ll']), FadeTransform(expression[0][3:5], g.vertices['lr']), FadeTransform(expression[0][10], g.vertices['rl']), FadeTransform(expression[0][14], g.vertices['rr']), FadeTransform(expression[0][9], g.vertices['rll']), FadeTransform(expression[0][11], g.vertices['rlr']))"}]}
{"messages": [{"role": "user", "content": "Generate a scene showing a single triangulated polygon animate with its edges, followed by a grid of similar animated polygons."}, {"role": "assistant", "content": "from utilities import *\n\nclass TriangulatedPolygonExample(MovingCameraScene):\n    \"\"\"Note: this animation takes a few minutes to compute since we're creating a lot of shapes inefficiently.\"\"\"\n\n    def construct(self):\n        n = 8\n        count = 79\n        polygons = VGroup(*LinedPolygon.generate_triangulated_polygons(n))\n        for polygon in polygons:\n            polygon.rotate(PI / n)\n        p = polygons[count].scale(2.5)\n        self.play(Write(p.polygon), run_time=1)\n        self.play(Write(VGroup(*list(p.edges.values())), run_time=1.5))\n        triangles = create_polygon_triangles(p)\n        self.bring_to_back(triangles)\n        self.play(FadeIn(triangles, lag_ratio=0.05, run_time=1.5))\n        p.add_to_back(triangles)\n        polygons = VGroup(*LinedPolygon.generate_triangulated_polygons(n))\n        for polygon in polygons:\n            polygon.rotate(PI / n)\n            polygon.add_to_back(create_polygon_triangles(polygon))\n        polygons.arrange_in_grid(cols=17, buff=0.3)\n        polygons.scale(2.5)\n        pos = polygons[count].get_center()\n        polygons.remove(polygons[count])\n        align_object_by_coords(polygons, pos, p.get_center())\n\n        def dist(a, b):\n            x1, y1, z1 = a.get_center()\n            x2, y2, z2 = b.get_center()\n            return ((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) ** (1 / 2)\n        self.play(self.camera.frame.animate(run_time=2).set_width(polygons.width * 1.15).move_to(polygons), *[Succession(Wait(dist(p, q) / 35), Write(q)) for q in polygons])"}]}
{"messages": [{"role": "user", "content": "Display a table of full binary trees with their corresponding counts and illustrate the growth in size for trees with more nodes."}, {"role": "assistant", "content": "from utilities import *\n\nclass AllBinaryTrees(Scene):\n\n    def construct(self):\n        dp = [VGroup(*FullBinaryTree.generate_binary_trees(0)).arrange_in_grid(cols=1, buff=0.6).set_width(0.2), VGroup(*FullBinaryTree.generate_binary_trees(1)).arrange_in_grid(cols=1, buff=0.6).set_width(1), VGroup(*FullBinaryTree.generate_binary_trees(2)).arrange_in_grid(cols=1, buff=0.6).set_width(1), VGroup(*FullBinaryTree.generate_binary_trees(3)).arrange_in_grid(cols=2, buff=0.6).set_width(2), VGroup(*FullBinaryTree.generate_binary_trees(4)).arrange_in_grid(cols=3, buff=1.2).set_width(2.2)]\n        for graph in dp[2]:\n            for v in graph.vertices:\n                graph.vertices[v].scale(1.1)\n        for graph in dp[3]:\n            for v in graph.vertices:\n                graph.vertices[v].scale(1.2)\n        for graph in dp[4]:\n            for v in graph.vertices:\n                graph.vertices[v].scale(1.8)\n        table = Table([dp], element_to_mobject=lambda x: x, row_labels=[Tex('Full Binary Trees').rotate(PI / 2)], col_labels=[Tex('1'), Tex('1'), Tex('2'), Tex('5'), Tex('14')], v_buff=0.4, h_buff=0.65, top_left_entry=Tex('$C_n$'), include_outer_lines=True)\n        table.remove(*table.get_vertical_lines())\n        self.play(FadeIn(table.get_entries()), AnimationGroup(Write(table.get_horizontal_lines()[0]), Write(table.get_horizontal_lines()[2]), Write(table.get_horizontal_lines()[1]), lag_ratio=0.25))"}]}
{"messages": [{"role": "user", "content": "Display a table showing triangulated polygons with their corresponding number of triangulations."}, {"role": "assistant", "content": "from utilities import *\n\nclass AllTriangulatedPolygons(Scene):\n\n    def construct(self):\n        dp = [VGroup(*LinedPolygon.generate_triangulated_polygons(3)).arrange_in_grid(cols=1, buff=0.8).set_width(1), VGroup(*LinedPolygon.generate_triangulated_polygons(4)).arrange_in_grid(cols=1, buff=0.3).set_width(0.9), VGroup(*LinedPolygon.generate_triangulated_polygons(5)).arrange_in_grid(cols=1, buff=0.5).set_width(0.75), VGroup(*LinedPolygon.generate_triangulated_polygons(6)).arrange_in_grid(cols=2, buff=0.6).set_width(1.3)]\n        table = Table([dp], element_to_mobject=lambda x: x, row_labels=[Tex('Triangulations').rotate(PI / 2)], col_labels=[Tex('1'), Tex('2'), Tex('5'), Tex('14')], v_buff=0.4, h_buff=0.65, top_left_entry=Tex('$C_n$'), include_outer_lines=True)\n        table.remove(*table.get_vertical_lines())\n        self.play(FadeIn(table.get_entries()), AnimationGroup(Write(table.get_horizontal_lines()[0]), Write(table.get_horizontal_lines()[2]), Write(table.get_horizontal_lines()[1]), lag_ratio=0.25))"}]}
{"messages": [{"role": "user", "content": "Animate a triangulated polygon transforming into a sequence of arcs and points, then morphing into a mathematical expression with associated operators."}, {"role": "assistant", "content": "from utilities import *\n\nclass PolygonToExpressionExample(MovingCameraScene):\n\n    def construct(self):\n        polygon = LinedPolygon.generate_triangulated_polygons(6)[12].scale(2)\n        self.play(Write(polygon))\n        vertices = polygon.polygon.get_vertices()\n        red_line = Line(start=vertices[2], end=vertices[1], color=RED, stroke_width=8)\n        vertice_objects = VGroup(*[Dot().move_to(v) for v in vertices])\n        self.play(FadeIn(red_line), Flash(red_line, color=RED), FadeIn(vertice_objects))\n        vertex_labels = VGroup(Tex('1').move_to((vertices[2] + vertices[3]) / 2 * 1.3), Tex('2').move_to((vertices[3] + vertices[4]) / 2 * 1.3), Tex('3').move_to((vertices[4] + vertices[5]) / 2 * 1.3), Tex('4').move_to((vertices[5] + vertices[0]) / 2 * 1.3), Tex('5').move_to((vertices[0] + vertices[1]) / 2 * 1.3))\n        self.play(FadeIn(vertex_labels[0], shift=(vertices[2] + vertices[3]) / 2 * 0.2), FadeIn(vertex_labels[1], shift=(vertices[3] + vertices[4]) / 2 * 0.2), FadeIn(vertex_labels[2], shift=(vertices[4] + vertices[5]) / 2 * 0.2), FadeIn(vertex_labels[3], shift=(vertices[5] + vertices[0]) / 2 * 0.2), FadeIn(vertex_labels[4], shift=(vertices[0] + vertices[1]) / 2 * 0.2))\n        size = vertices[5] - vertices[4]\n        other_lines = Path([vertices[2], vertices[3], vertices[4], vertices[5], vertices[0], vertices[1]])\n        polygon.remove(polygon.polygon)\n        self.bring_to_back(other_lines)\n        self.play(FadeOut(red_line))\n        new_path = Path([vertices[4] - size * 2, vertices[4] - size * 1, vertices[4], vertices[4] + size * 1, vertices[4] + size * 2, vertices[4] + size * 3])\n        arcs = VGroup(ArcBetweenPoints(new_path[0], new_path[2], angle=-PI / 2), ArcBetweenPoints(new_path[0], new_path[3], angle=-PI / 1.3), ArcBetweenPoints(new_path[5], new_path[3], angle=PI / 2))\n        all_stuff = VGroup(arcs, vertice_objects)\n        self.play(Transform(other_lines, new_path), Transform(list(polygon.edges.values())[1], arcs[0]), Transform(list(polygon.edges.values())[2], arcs[1]), Transform(list(polygon.edges.values())[0], arcs[2]), vertex_labels[0].animate.next_to((new_path[0] + new_path[1]) / 2, DOWN, buff=0.4), vertex_labels[1].animate.next_to((new_path[1] + new_path[2]) / 2, DOWN, buff=0.4), vertex_labels[2].animate.next_to((new_path[2] + new_path[3]) / 2, DOWN, buff=0.4), vertex_labels[3].animate.next_to((new_path[3] + new_path[4]) / 2, DOWN, buff=0.4), vertex_labels[4].animate.next_to((new_path[4] + new_path[5]) / 2, DOWN, buff=0.4), vertice_objects[2].animate.move_to(new_path[0]), vertice_objects[3].animate.move_to(new_path[1]), vertice_objects[4].animate.move_to(new_path[2]), vertice_objects[5].animate.move_to(new_path[3]), vertice_objects[0].animate.move_to(new_path[4]), vertice_objects[1].animate.move_to(new_path[5]), self.camera.frame.animate.shift(DOWN), run_time=2)\n        parentheses = VGroup(Tex('(').next_to(new_path[0], DOWN, buff=0.4).shift(LEFT * 0.2), Tex('(').next_to(new_path[0], DOWN, buff=0.4).shift(RIGHT * 0.2), Tex(')').next_to(new_path[2], DOWN, buff=0.4), Tex('(').next_to(new_path[3], DOWN, buff=0.4).shift(RIGHT * 0.2), Tex(')').next_to(new_path[3], DOWN, buff=0.4).shift(LEFT * 0.2), Tex(')').next_to(new_path[5], DOWN, buff=0.4)).shift(UP * 0.05)\n        expression = Tex('$((1 + 2) \\\\times 3) - (4 \\\\div 5)$').scale(2).shift(2.5 * DOWN)\n        plus = expression[0][3].copy()\n        expression[0][3].fade(1)\n        times = expression[0][6].copy()\n        expression[0][6].fade(1)\n        minus = expression[0][9].copy()\n        expression[0][9].fade(1)\n        div = expression[0][12].copy()\n        expression[0][12].fade(1)\n        self.play(FadeIn(parentheses, lag_ratio=0.1))\n        self.play(FadeOut(vertice_objects), FadeOut(VGroup(*list(polygon.edges.values()))), FadeOut(other_lines), TransformMatchingShapes(VGroup(*vertex_labels, *parentheses), expression), Transform(vertice_objects[3], plus), Transform(vertice_objects[4], times), Transform(vertice_objects[5], minus), Transform(vertice_objects[0], div), self.camera.frame.animate.move_to(expression), run_time=1.5)"}]}
{"messages": [{"role": "user", "content": "Display pi, then animate its transformation into three famous mathematical equations sequentially."}, {"role": "assistant", "content": "from utilities import *\n\nclass Intro(MovingCameraScene):\n\n    def construct(self):\n        pi = Tex('$$\\\\pi$$').scale(8)\n        self.play(AnimationGroup(Write(pi), Flash(pi, color=WHITE, flash_radius=1.5), lag_ratio=0.5, run_time=1.5))\n        expressions = VGroup(Tex('$$\\\\sum_{n=1}^{\\\\infty} \\\\frac{1}{n^2} = \\\\frac{\\\\pi^2}{6}$$'), Tex('$$n! \\\\approx \\\\sqrt{2 \\\\pi n} \\\\left(\\\\frac{n}{e}\\\\right)^n$$'), Tex('$$e^{i \\\\pi} = -1$$')).scale(1.5)\n        self.play(AnimationGroup(Transform(pi, expressions[0][0][10]), AnimationGroup(FadeIn(expressions[0][0][:10]), FadeIn(expressions[0][0][11:])), lag_ratio=0.25))\n        self.remove(pi)\n        self.play(AnimationGroup(FadeOut(expressions[0][0]), Transform(expressions[0][0][10], expressions[1][0][6]), AnimationGroup(FadeIn(expressions[1][0][:6]), FadeIn(expressions[1][0][7:])), lag_ratio=0.25))\n        self.remove(expressions[0][0][10])\n        self.play(AnimationGroup(FadeOut(expressions[1][0]), Transform(expressions[1][0][6], expressions[2][0][2]), AnimationGroup(FadeIn(expressions[2][0][:2]), FadeIn(expressions[2][0][3:])), lag_ratio=0.25))"}]}
{"messages": [{"role": "user", "content": "Introduce Catalan numbers by displaying their name, formula, and sequence, then visualize examples of binary trees, Dyck paths, and triangulated polygons."}, {"role": "assistant", "content": "from utilities import *\n\nclass IntroCatalan(MovingCameraScene):\n\n    def construct(self):\n        catalan_numbers = Tex('Catalan numbers').scale(2)\n        catalan_formula = Tex('$$C_n = \\\\frac{1}{n + 1} \\\\cdot \\\\binom{2n}{n}$$').shift(DOWN)\n        self.play(Write(catalan_numbers))\n        self.play(catalan_numbers.animate.shift(UP), FadeIn(catalan_formula, shift=UP * 0.5))\n        catalan_sequence = Tex('$$= 1, 1, 2, 5, 14, 42, \\\\ldots$$').next_to(catalan_formula, DOWN).align_to(catalan_formula[0][2], LEFT)\n        self.play(FadeIn(catalan_sequence, shift=UP * 0.3, lag_ratio=0.05))\n        objects = VGroup(BinaryTree.generate_binary_trees(2)[0], DyckPath([1, -1, 1, 1, -1, 1, -1, -1]), LinedPolygon.generate_triangulated_polygons(7)[10])\n        StarUtilities.add_stars_to_graph(objects[0], no_labels=True)\n        objects[2].add_to_back(create_polygon_triangles(objects[2]))\n        for u, v in objects[1].path.edges:\n            objects[1].path.edges[u, v].set_color(GREEN if objects[1].deltas[u] == 1 else RED)\n        objects.arrange(buff=1.5).move_to(catalan_formula).shift(DOWN * 3.6)\n        self.play(AnimationGroup(AnimationGroup(self.camera.frame.animate.shift(DOWN * 3.1), catalan_numbers.animate.shift(UP * 2)), AnimationGroup(FadeIn(objects[0], shift=UP * 0.7), FadeIn(objects[1], shift=UP * 0.7), FadeIn(objects[2], shift=UP * 0.7), lag_ratio=0.1), lag_ratio=0.5))"}]}
{"messages": [{"role": "user", "content": "Generate a sequence of random Delaunay triangulations of scattered points, displaying each one briefly before clearing it."}, {"role": "assistant", "content": "from random import uniform\nfrom manim import *\nfrom scipy.spatial import Delaunay\n\nclass TransparentScene(MovingCameraScene):\n\n    def construct(self):\n        images = 10\n        for _ in range(images):\n            w = self.camera.frame.width * 1.25\n            h = self.camera.frame.height * 1.25\n            n = 30\n            k = 4\n            points = []\n            for _ in range(n):\n\n                def min_dist_to_other_points(p):\n                    min_dist = float('inf')\n                    for q in points:\n                        min_dist = min(min_dist, np.linalg.norm(np.array(p) - np.array(q)))\n                    return min_dist\n                sampled_points = [(uniform(-w / 2, w / 2), uniform(-h / 2, h / 2)) for _ in range(k)]\n                sampled_points.sort(key=min_dist_to_other_points)\n                points.append(sampled_points[-1])\n            tri = Delaunay(points)\n            edges = []\n            for s in tri.simplices:\n                for i in range(3):\n                    edges.append((points[s[i - 1]], points[s[i]]))\n            graph = Graph(vertices=points, edges=edges, layout={p: (*p, 0) for p in points})\n            for v in graph.vertices:\n                graph[v].scale(2.5)\n            self.add(graph)\n            self.wait()\n            for o in self.mobjects:\n                self.remove(o)"}]}
{"messages": [{"role": "user", "content": "Animate two SVG logos, a 't' and an 's', appearing with a gradient, then fading out."}, {"role": "assistant", "content": "from manim import *\n\nclass Logo(Scene):\n\n    def construct(self):\n        t = SVGMobject('logo-t.svg').scale(2).set_color_by_gradient((WHITE, WHITE, GRAY, DARK_GRAY))\n        s = SVGMobject('logo-s.svg').scale(2)\n        self.play(Write(t), Write(s), run_time=2)\n        self.wait(1)\n        self.play(FadeOut(t), FadeOut(s), run_time=1)"}]}
{"messages": [{"role": "user", "content": "Fade in the Manim logo's 'T' and 'S' components, with the 'T' having a gradient color, positioned towards the bottom right."}, {"role": "assistant", "content": "from manim import *\n\nclass LogoBottomCorner(Scene):\n\n    def construct(self):\n        t = SVGMobject('logo-t.svg').scale(0.7).set_color_by_gradient((WHITE, WHITE, GRAY, GRAY))\n        s = SVGMobject('logo-s.svg').scale(0.7)\n        s.shift(DOWN * 2.8 + RIGHT * 6)\n        t.shift(DOWN * 2.8 + RIGHT * 6)\n        self.play(FadeIn(t), FadeIn(s))"}]}
{"messages": [{"role": "user", "content": "Visualize the BFS and DFS traversal of a maze, highlighting the differences in their paths with color gradients."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\nfrom random import uniform, seed, randint\nfrom math import sin\n\nclass Intro(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.camera.background_color = BLACK\n        with open('maze/mask.txt') as f:\n            contents = f.read().splitlines()\n        dfs_order = {}\n        bfs_order = {}\n        dfs_order_inverse = {}\n        bfs_order_inverse = {}\n        diff_order = {}\n\n        def get_dfs_order(start):\n            queue = [start]\n            discovered = set(queue)\n            dfs_order[0] = start\n            dfs_order_inverse[start] = 0\n            i = 1\n            while len(queue) != 0:\n                x, y = queue.pop()\n                for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n                    nx, ny = (x + dx, y + dy)\n                    if (nx, ny) in discovered:\n                        continue\n                    if contents[ny][nx] == '#':\n                        continue\n                    dfs_order[i] = (nx, ny)\n                    dfs_order_inverse[nx, ny] = i\n                    queue.append((nx, ny))\n                    discovered.add((nx, ny))\n                    i += 1\n            return i\n\n        def get_bfs_order(start):\n            queue = [start]\n            discovered = set(queue)\n            bfs_order[0] = start\n            bfs_order_inverse[start] = 0\n            i = 1\n            while len(queue) != 0:\n                x, y = queue.pop(0)\n                for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n                    nx, ny = (x + dx, y + dy)\n                    if (nx, ny) in discovered:\n                        continue\n                    if contents[ny][nx] == '#':\n                        continue\n                    bfs_order[i] = (nx, ny)\n                    bfs_order_inverse[nx, ny] = i\n                    queue.append((nx, ny))\n                    discovered.add((nx, ny))\n                    i += 1\n            return i\n        maze, maze_dict = maze_to_vgroup(contents)\n        maze.rotate(-PI / 2)\n        width = len(contents[0])\n        height = len(contents)\n        start = (width // 2, height // 2 - 1)\n        number_of_tiles = get_bfs_order(start)\n        number_of_tiles = get_dfs_order(start)\n        colors = color_gradient((GREEN, RED), number_of_tiles)\n        diff_order = {}\n        for i in dfs_order_inverse:\n            diff_order[i] = (dfs_order_inverse[i] - bfs_order_inverse[i]) / number_of_tiles\n        self.camera.frame.set_width(maze.get_width() * 1.2).move_to(maze)\n        self.play(*[Succession(Wait(i / number_of_tiles * 2 / 3), FadeIn(maze_dict[bfs_order[i]], run_time=2 / 3)) for i in range(number_of_tiles)], Succession(Wait(2 / 3), AnimationGroup(*[FadeIn(maze_dict[x]) for x in maze_dict if x not in bfs_order.values()])))\n        s = 5.5\n        bfs = Tex('\\\\underline{BFS}').scale(s)\n        vs = Tex('vs.').scale(s)\n        dfs = Tex('\\\\underline{DFS}').scale(s)\n        g = VGroup(bfs, vs, dfs).arrange(RIGHT, buff=1).next_to(maze, UP * s)\n        vs.align_to(bfs[0][1], DOWN)\n        self.play(self.camera.frame.animate.move_to(VGroup(maze, bfs)), AnimationGroup(FadeIn(bfs, shift=DOWN), FadeIn(vs, shift=DOWN), FadeIn(dfs, shift=DOWN), lag_ratio=0.1))\n        offset = -bfs.get_center() + g.get_center()\n        title_s = 1.25\n        self.play(bfs.animate.move_to(g).scale(title_s), vs.animate.shift(offset).set_opacity(0), dfs.animate.shift(offset).set_opacity(0))\n        self.play(*[Succession(Wait(i / number_of_tiles * 4), maze_dict[bfs_order[i]].animate(run_time=0.5).set_fill(colors[i], 1)) for i in range(number_of_tiles)])\n        for x in range(width):\n            for y in range(height):\n                if contents[y][x] == '#':\n                    maze_dict[x, y].set_opacity(0)\n        maze.save_state()\n        for x in range(width):\n            for y in range(height):\n                if contents[y][x] == '#':\n                    maze_dict[x, y].set_opacity(1)\n        self.play(bfs.animate.shift(-offset * 2).scale(1 / title_s).set_opacity(0), MoveAndFadeThereBack(vs, -offset * 2), dfs.animate.shift(-offset * 2).set_opacity(1).scale(title_s), *[maze_dict[bfs_order[i]].animate(run_time=1).set_fill(BLACK, 0) for i in range(number_of_tiles)])\n        self.play(*[Succession(Wait(i / number_of_tiles * 6), maze_dict[dfs_order[i]].animate(run_time=0.5).set_fill(colors[i], 1)) for i in range(number_of_tiles)])\n        for x in range(width):\n            for y in range(height):\n                if contents[y][x] == '#':\n                    maze_dict[x, y].set_opacity(0)\n        mc = maze.copy()\n        for x in range(width):\n            for y in range(height):\n                if contents[y][x] == '#':\n                    maze_dict[x, y].set_opacity(1)\n        self.play(bfs.animate.shift(offset).set_opacity(1).scale(title_s), dfs.animate.shift(offset), *[maze_dict[x, y].animate(run_time=1).set_opacity(0) for x in range(width) for y in range(height) if contents[y][x] == '#'], *[maze_dict[x, y].animate(run_time=1).set_fill_color(DARKER_GRAY) for x in range(width) for y in range(height) if contents[y][x] != '#'])\n        self.play(bfs.animate.set_color(BLUE), dfs.animate.set_color(ORANGE), *[maze_dict[i].animate.set_fill_color(interpolate_color(DARK_GRAY, BLUE, diff_order[i])) for i in diff_order if diff_order[i] >= 0], *[maze_dict[i].animate.set_fill_color(interpolate_color(DARK_GRAY, ORANGE, abs(diff_order[i]))) for i in diff_order if diff_order[i] < 0])\n        self.play(bfs.animate.set_color(WHITE), dfs.animate.scale(1 / title_s).set_opacity(BIG_OPACITY).set_color(WHITE), maze.animate.restore())\n        bfs.set_z_index(10000000)\n        dfs.set_z_index(10000000)\n        d = Dot().next_to(maze, DOWN + RIGHT)\n        d2 = Dot().next_to(maze, UP + LEFT)\n        sq = Square(fill_color=BLACK, fill_opacity=1, stroke_color=WHITE, stroke_width=20).scale(100).next_to(d, LEFT, buff=0).set_z_index(100000000)\n        sq.rotate(-PI / 4, about_point=d.get_center()).set_z_index(2e-05)\n        sqcp = sq.copy().set_z_index(1e-05).set_stroke_width(0)\n        sq2 = Square(fill_color=BLACK, fill_opacity=1, stroke_color=WHITE, stroke_width=20).scale(100).next_to(d2, LEFT, buff=0).set_z_index(100000000)\n        sq2.rotate(-PI / 4, about_point=d2.get_center()).set_z_index(2e-05)\n        sq2cp = sq2.copy().set_z_index(1e-05).set_stroke_width(0)\n        self.add(sq)\n        self.add(sqcp)\n        sqcpcp = sqcp.copy()\n        sqcp.move_to(sq2cp)\n        sq2cp.move_to(sqcpcp)\n        sqq = sq.copy()\n        sq.move_to(sq2)\n        sq2.move_to(sqq)\n        maze_original = maze.copy()\n        mc_original = mc.copy()\n        for o in self.mobjects:\n            self.remove(o)\n        self.add(bfs)\n        self.add(dfs)\n\n        def maze_updater(obj, dt):\n            for o, u in zip(maze_original, obj):\n                n = Difference(o, sqcp, stroke_width=o.get_stroke_width(), color=o.get_color(), fill_opacity=o.get_fill_opacity(), stroke_color=o.get_stroke_color(), z_index=o.get_z_index())\n                n.set_opacity(o.get_fill_opacity())\n                u.become(n)\n\n        def mc_updater(obj, dt):\n            for o, u in zip(mc_original, obj):\n                n = Intersection(o, sqcp, stroke_width=o.get_stroke_width(), color=o.get_color(), fill_opacity=o.get_fill_opacity(), stroke_color=o.get_stroke_color(), z_index=o.get_z_index())\n                n.set_opacity(o.get_fill_opacity())\n                u.become(n)\n        self.add(mc)\n        mc.add_updater(maze_updater)\n        self.add(maze)\n        maze.add_updater(mc_updater)\n        sq.save_state()\n        sqcp.save_state()\n        self.play(bfs.animate.set_opacity(BIG_OPACITY).scale(1 / title_s), dfs.animate.set_opacity(1).scale(title_s), MoveAndFadeThereBackKindaTho(sq, sq2), sqcp.animate().move_to(sq2cp), run_time=2)\n        mc.remove_updater(maze_updater)\n        maze.remove_updater(mc_updater)\n        self.play(bfs.animate.set_opacity(1).scale(title_s), *[maze_dict[i].animate.set_fill_color(interpolate_color(DARK_GRAY, BLUE, diff_order[i])) for i in diff_order if diff_order[i] >= 0], *[maze_dict[i].animate.set_fill_color(interpolate_color(DARK_GRAY, ORANGE, abs(diff_order[i]))) for i in diff_order if diff_order[i] < 0])"}]}
{"messages": [{"role": "user", "content": "Visualize the mapping of archers to targets with animated arrows, then demonstrate a dynamic programming approach to finding the optimal subset, culminating in an illustration of the O(n^2) complexity."}, {"role": "assistant", "content": "from manim import *\nfrom utilities import *\n\nclass Intro(MovingCameraScene):\n\n    def construct(self):\n        mapping = [2, 0, 3, 1, 5, 6, 5]\n        N = len(mapping)\n        upper_dots = VGroup(*[Dot().shift(UP + RIGHT * (i - N / 2 + 0.5)) for i in range(N)])\n        lower_dots = VGroup(*[Square(fill_opacity=1, color=WHITE).set_width(Dot().width * 0.5).shift(DOWN + RIGHT * (i - N / 2 + 0.5)) for i in range(N)])\n        arrows = VGroup(*[Arrow(start=upper_dots[i].get_center(), end=lower_dots[v].get_center(), tip_length=0.2) for i, v in enumerate(mapping)])\n        self.camera.frame.set_width(Group(upper_dots, lower_dots, arrows).width * 1.5)\n        lucistnici = VGroup(Tex('$n$ lu\u010di\u0161tn\u00edk\u016f')).arrange().next_to(upper_dots, UP, buff=0.5).scale(0.6)\n        cile = VGroup(Tex('$n$ c\u00edl\u016f')).arrange().next_to(lower_dots, DOWN, buff=0.5).scale(0.6)\n        self.play(AnimationGroup(Write(upper_dots), Write(lower_dots), AnimationGroup(*[FadeIn(a) for a in arrows], lag_ratio=0.1), AnimationGroup(FadeIn(lucistnici, shift=UP * 0.1), FadeIn(cile, shift=DOWN * 0.1), lag_ratio=0), lag_ratio=0.25))\n        arrows[1].set_z_index(1)\n        arrows[2].set_z_index(1)\n        arrows[4].set_z_index(1)\n        arrows[6].set_z_index(1)\n        for a in arrows:\n            a.save_state()\n        for a in upper_dots:\n            a.save_state()\n        for a in lower_dots:\n            a.save_state()\n\n        def animate_combination(archers, colors):\n            mapping_set = set([mapping[i] for i in archers])\n            mapping_colors = {i: colors[index] for index, i in enumerate(archers)}\n            self.play(*[arrows[i].animate.set_color(mapping_colors[i]) for i in archers], *[arrows[i].animate.set_color(DARKER_GRAY) for i in range(N) if i not in archers], *[upper_dots[i].animate.set_color(mapping_colors[i]) for i in archers], *[upper_dots[i].animate.set_color(DARKER_GRAY) for i in range(N) if i not in archers], *[SwitchZIndex(arrows[i], 1) for i in archers], *[SwitchZIndex(arrows[i], 0) for i in range(N) if i not in archers])\n        animate_combination([1, 2, 4, 6], [GREEN] * 4)\n        self.wait(0.5)\n        animate_combination([1, 6], [GREEN] * 2)\n        self.wait(0.5)\n        animate_combination([0, 3, 4, 5], [GREEN] * 4)\n        self.wait(1)\n        animate_combination([1, 2, 4, 5, 6], colors=[GREEN] * 3 + [RED] * 2)\n        self.wait(0.5)\n        animate_combination([0, 1, 2, 3, 4, 5, 6], colors=[RED] * 7)\n        blob = get_gray_blob()\n        q = Tex('Jak naj\u00edt nejv\u011bt\u0161\u00ed skupinu?').set_z_index(150)\n        self.play(AnimationGroup(FadeIn(blob), FadeIn(q), lag_ratio=0.5))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(blob), FadeOut(q)), AnimationGroup(FadeOut(lucistnici), FadeOut(cile), AnimationGroup(*[a.animate.restore() for a in arrows]), AnimationGroup(*[a.animate.restore() for a in upper_dots]), AnimationGroup(*[a.animate.restore() for a in lower_dots])), lag_ratio=0.2))\n\n        def f(v):\n            return bin(v)[2:].rjust(N, '0')\n\n        def tex_above_upper_dots(v, bad):\n            g = VGroup(*[Tex('\\\\texttt{' + 'Ne' if i == '0' else 'Ano' + '}').scale(0.5).set_color(WHITE if v == 0 else RED if ii in bad else GREEN if i == '1' else DARKER_GRAY) for ii, i in enumerate(f(v))])\n            for i, a in enumerate(g):\n                a.next_to(upper_dots[i], UP, buff=0.3)\n            return g\n        g = tex_above_upper_dots(0, [])\n        brace = BraceBetweenPoints(Dot().next_to(g[0], (UP + LEFT) * 0.1).get_center(), Dot().next_to(g[-1], (UP + RIGHT) * 0.1).get_center(), direction=UP)\n        count = Tex('$n$').next_to(brace, UP).scale(0.75)\n        self.play(FadeIn(g, lag_ratio=0.1), FadeIn(brace, shift=UP * 0.2), FadeIn(count, shift=UP * 0.2), self.camera.frame.animate.move_to(VGroup(g, lower_dots, brace, count)))\n        for a in arrows:\n            a.save_state()\n        for a in upper_dots:\n            a.save_state()\n        for a in lower_dots:\n            a.save_state()\n        for i in range(1, 2 ** N):\n            set_thingy = set((mapping[i] for i, ll in enumerate(f(i)) if ll == '1'))\n            ok = f(i)\n            bad = []\n            for a in range(N):\n                for b in range(a, N):\n                    if ok[a] != '1' or ok[b] != '1':\n                        continue\n                    if mapping[a] > mapping[b]:\n                        bad.append(a)\n                        bad.append(b)\n            self.play(Transform(g, tex_above_upper_dots(i, bad)), *[a.animate.set_color(RED if j in bad else GREEN if f(i)[j] == '1' else DARKER_GRAY) for j, a in enumerate(arrows)], *[a.animate.set_color(RED if j in bad else GREEN if f(i)[j] == '1' else DARKER_GRAY) for j, a in enumerate(upper_dots)], *[SwitchZIndex(a, 1 if f(i)[j] == '1' else 0) for j, a in enumerate(arrows)], run_time=1 / i)\n        deltas = [3, 1, -2, -2, -2, 0, 1, 2, -1, 1, -2, 1, 1, -1, -1, 2, 0, 0, 1, -4, 0]\n        mapping_larger = [d + i for i, d in enumerate(deltas)]\n        N_larger = len(mapping_larger)\n        N_diff = (N_larger - N) // 2\n        upper_dots_larger = VGroup(*[Dot().shift(UP + RIGHT * (i - N_larger / 2 + 0.5)) for i in range(N_larger)])\n        lower_dots_larger = VGroup(*[Square(fill_opacity=1, color=WHITE).set_width(Dot().width * 0.5).shift(DOWN + RIGHT * (i - N_larger / 2 + 0.5)) for i in range(N_larger)])\n        arrows_larger = VGroup(*[Arrow(start=upper_dots_larger[i].get_center(), end=lower_dots_larger[v].get_center(), tip_length=0.2) for i, v in enumerate(mapping_larger)])\n        pozorovani = VGroup(Tex('\\\\large \\\\textbf{Pozorov\u00e1n\u00ed:} nejlep\u0161\u00ed \u0159e\u0161en\u00ed kon\u010d\u00edc\u00ed dan\u00fdm lu\u010di\u0161tn\u00edkem je roz\u0161\u00ed\u0159en\u00edm n\u011bjak\u00e9ho p\u0159edchoz\u00edho nejlep\u0161\u00edho \u0159e\u0161en\u00ed.')).next_to(upper_dots, UP, buff=0.5).scale(0.5)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(g, lag_ratio=0.1), FadeOut(brace), FadeOut(count)), AnimationGroup(AnimationGroup(*[a.animate.restore() for a in arrows]), AnimationGroup(*[a.animate.restore() for a in upper_dots]), AnimationGroup(*[a.animate.restore() for a in lower_dots]), self.camera.frame.animate.move_to(VGroup(lower_dots, upper_dots)).scale(1.3), FadeIn(arrows_larger[:N_diff]), FadeIn(arrows_larger[-N_diff:]), FadeIn(upper_dots_larger[:N_diff]), FadeIn(upper_dots_larger[-N_diff:]), FadeIn(lower_dots_larger[:N_diff]), FadeIn(lower_dots_larger[-N_diff:])), lag_ratio=0.5))\n        self.remove(*arrows)\n        self.remove(*upper_dots)\n        self.remove(*lower_dots)\n        self.add(arrows_larger)\n        self.add(upper_dots_larger)\n        self.add(lower_dots_larger)\n        target = 4 + N_diff\n\n        def build_arrow(i, j):\n            return CurvedArrow(Dot().next_to(upper_dots_larger[i], UP, buff=0.05).get_center(), Dot().next_to(upper_dots_larger[j], UP, buff=0.05).get_center(), tip_length=0.15, angle=1).set_color(GRAY)\n        curved_arrows = [build_arrow(target, target - i) for i in range(1, 11)]\n        self.play(arrows_larger[target].animate.set_color(ORANGE), upper_dots_larger[target].animate.set_color(ORANGE), self.camera.frame.animate.move_to(arrows_larger[target]))\n        pozorovani.next_to(arrows_larger[target], DOWN, buff=1)\n        self.play(AnimationGroup(*[Write(a) for a in curved_arrows], lag_ratio=0.1), FadeIn(pozorovani, shift=DOWN * 0.1), self.camera.frame.animate.shift(DOWN * 0.3))\n        curved_arrows[1].set_z_index(100)\n        arrows_larger[target - 2].set_z_index(100)\n        arrows_larger[target - 3].set_z_index(100)\n        arrows_larger[target - 5].set_z_index(100)\n        upper_dots_larger[target - 2].set_z_index(100)\n        upper_dots_larger[target - 3].set_z_index(100)\n        upper_dots_larger[target - 5].set_z_index(100)\n        self.play(arrows_larger[target - 2].animate.set_color(GREEN), arrows_larger[target - 3].animate.set_color(GREEN), arrows_larger[target - 5].animate.set_color(GREEN), upper_dots_larger[target - 2].animate.set_color(GREEN), upper_dots_larger[target - 3].animate.set_color(GREEN), upper_dots_larger[target - 5].animate.set_color(GREEN), arrows_larger[target - 1].animate.set_color(DARK_GRAY), arrows_larger[target - 4].animate.set_color(DARK_GRAY), upper_dots_larger[target - 1].animate.set_color(DARK_GRAY), upper_dots_larger[target - 4].animate.set_color(DARK_GRAY), AnimationGroup(*[a.animate.set_color(DARK_GRAY) for i, a in enumerate(curved_arrows) if i != 1]), curved_arrows[1].animate.set_color(WHITE))\n        arrows_larger[target + 1].set_z_index(1)\n        self.play(FadeOut(VGroup(*curved_arrows)), arrows_larger[target - 2].animate.set_color(WHITE), arrows_larger[target - 3].animate.set_color(WHITE), arrows_larger[target - 5].animate.set_color(WHITE), arrows_larger[target - 1].animate.set_color(WHITE), arrows_larger[target - 4].animate.set_color(WHITE), arrows_larger[target].animate.set_color(WHITE), arrows_larger[target + 1].animate.set_color(ORANGE), upper_dots_larger[target - 2].animate.set_color(WHITE), upper_dots_larger[target - 3].animate.set_color(WHITE), upper_dots_larger[target - 5].animate.set_color(WHITE), upper_dots_larger[target - 1].animate.set_color(WHITE), upper_dots_larger[target - 4].animate.set_color(WHITE), upper_dots_larger[target].animate.set_color(WHITE), upper_dots_larger[target + 1].animate.set_color(ORANGE), self.camera.frame.animate.shift(-upper_dots_larger[target].get_center() + upper_dots_larger[target + 1].get_center()), pozorovani.animate.shift(-upper_dots_larger[target].get_center() + upper_dots_larger[target + 1].get_center()))\n        a = build_arrow(target + 1, target).set_color(WHITE)\n        self.play(Write(a), arrows_larger[target - 2].animate.set_color(GREEN), arrows_larger[target - 3].animate.set_color(GREEN), arrows_larger[target - 5].animate.set_color(GREEN), arrows_larger[target].animate.set_color(GREEN), upper_dots_larger[target - 2].animate.set_color(GREEN), upper_dots_larger[target - 3].animate.set_color(GREEN), upper_dots_larger[target - 5].animate.set_color(GREEN), upper_dots_larger[target].animate.set_color(GREEN), arrows_larger[target - 1].animate.set_color(DARK_GRAY), arrows_larger[target - 4].animate.set_color(DARK_GRAY), upper_dots_larger[target - 1].animate.set_color(DARK_GRAY), upper_dots_larger[target - 4].animate.set_color(DARK_GRAY))\n        self.play(Transform(a, build_arrow(target + 1, target - 1).set_color(WHITE)), arrows_larger[target].animate.set_color(WHITE), upper_dots_larger[target].animate.set_color(WHITE), arrows_larger[target - 1].animate.set_color(GREEN), upper_dots_larger[target - 1].animate.set_color(GREEN), arrows_larger[target - 2].animate.set_color(DARK_GRAY), upper_dots_larger[target - 2].animate.set_color(DARK_GRAY))\n        self.play(Transform(a, build_arrow(target + 1, target - 2).set_color(WHITE)), arrows_larger[target - 1].animate.set_color(WHITE), upper_dots_larger[target - 1].animate.set_color(WHITE), arrows_larger[target - 2].animate.set_color(GREEN), upper_dots_larger[target - 2].animate.set_color(GREEN))\n        self.play(Transform(a, build_arrow(target + 1, target - 3).set_color(WHITE)), arrows_larger[target - 2].animate.set_color(WHITE), upper_dots_larger[target - 2].animate.set_color(WHITE))\n        self.play(Transform(a, build_arrow(target + 1, target - 4).set_color(WHITE)), arrows_larger[target - 3].animate.set_color(WHITE), upper_dots_larger[target - 3].animate.set_color(WHITE), arrows_larger[target - 4].animate.set_color(GREEN), upper_dots_larger[target - 4].animate.set_color(GREEN))\n        self.play(FadeOut(a), upper_dots_larger.animate.set_color(WHITE), arrows_larger.animate.set_color(WHITE))\n        todo = VGroup(upper_dots_larger, lower_dots_larger, arrows_larger)\n        self.play(todo.animate.align_to(Dot().move_to(self.camera.frame.get_center()), LEFT), run_time=1.5)\n        delta = -upper_dots_larger[target].get_center() + upper_dots_larger[target + 1].get_center()\n        to_fade = VGroup()\n        fr = 3\n        for i in range(len(upper_dots_larger)):\n            if i > len(upper_dots_larger) / 2:\n                t = Tex(f'$n\\\\kern-0.1em-\\\\kern-0.1em{len(upper_dots_larger) - i}$').next_to(upper_dots_larger[i], UP).scale(0.5)\n            else:\n                t = Tex(str(i)).next_to(upper_dots_larger[i], UP).scale(0.5)\n            p = Tex('+').next_to(upper_dots_larger[i], UP).scale(0.35)\n            if i == 0:\n                self.play(FadeIn(t))\n            else:\n                p.shift(-delta / 2)\n                if i > fr:\n                    to_fade.add(t)\n                    to_fade.add(p)\n                else:\n                    self.play(FadeIn(t), FadeIn(p), self.camera.frame.animate.shift(delta), pozorovani.animate.shift(delta))\n        tfl = len(to_fade)\n        self.play(self.camera.frame.animate.shift(delta * (len(upper_dots_larger) - 1 - fr)), pozorovani.animate.shift(delta * (len(upper_dots_larger) - 1 - fr)), *[Succession(Wait(smooth(i / tfl) * 1), FadeIn(to_fade[i])) for i in range(tfl)], run_time=1.5)\n        n2 = Tex('$\\\\approx \\\\qquad \\\\mathcal{O}(n^2)$').scale(0.5).next_to(to_fade, RIGHT, buff=0.45)\n        n2[0][1:].scale(1.5)\n        self.play(Write(n2))"}]}
{"messages": [{"role": "user", "content": "Visualize a sphere and a cube, then allow interactive camera control to save and replay camera positions."}, {"role": "assistant", "content": "import glob\nimport cv2\nimport open3d as o3d\nfrom manim import *\nfrom manim.opengl import *\nfrom manim.renderer.opengl_renderer import OpenGLCamera\nfrom pyglet.window import key\nfrom utilities import ColmapObject\nfrom assets.gaussian.pysift import *\n\nclass TestCameraScene(Scene):\n\n    def construct(self):\n        s = Sphere(resolution=5).shift(LEFT * 2)\n        c = Cube().shift(RIGHT * 2)\n        self.add(s, c)\n        cam2 = OpenGLCamera(euler_angles=[PI, PI, PI], focal_distance=5)\n        self.interactive_embed()\n\n    def on_key_press(self, symbol, modifiers):\n        if symbol == key.PLUS:\n            print('New position added!')\n            self.camera_states.append((self.camera.get_center(), np.array(self.camera.euler_angles)))\n        elif symbol == key.P:\n            print('Replaying!')\n            for pos, ang in self.camera_states:\n                print(pos)\n                self.play(self.camera.animate.move_to(ORIGIN).set_euler_angles(*ang).move_to(pos))\n        super().on_key_press(symbol, modifiers)"}]}
{"messages": [{"role": "user", "content": "Render a Colmap scene and allow interactive camera control."}, {"role": "assistant", "content": "import glob\nimport cv2\nimport open3d as o3d\nfrom manim import *\nfrom manim.opengl import *\nfrom manim.renderer.opengl_renderer import OpenGLCamera\nfrom pyglet.window import key\nfrom utilities import ColmapObject\nfrom assets.gaussian.pysift import *\n\nclass TestPyColmapScene(Scene):\n\n    def construct(self):\n        colmap = ColmapObject('assets/test/sparse/0', [np.array([5.95773, 2.50781, 8.62867]), np.array([3.70964, 3.14088, 7.81675]), np.array([2.82718, 0.187449, 11.3918])])\n        self.add(colmap)\n        self.interactive_embed()"}]}
{"messages": [{"role": "user", "content": "Load and display a gradient-colored point cloud from a file, allowing for interactive manipulation."}, {"role": "assistant", "content": "import glob\nimport cv2\nimport open3d as o3d\nfrom manim import *\nfrom manim.opengl import *\nfrom manim.renderer.opengl_renderer import OpenGLCamera\nfrom pyglet.window import key\nfrom utilities import ColmapObject\nfrom assets.gaussian.pysift import *\n\nclass TestPCDScene(Scene):\n\n    def construct(self):\n        pointcloud = OpenGLPMobject()\n        pcd = o3d.io.read_point_cloud('assets/sparse-test.pcd')\n        _, pcd = pcd.remove.remove_statistical_outlier()\n        points = [p for p in pcd.points]\n        pointcloud.add_points(points)\n        pointcloud.set_color_by_gradient((RED, GREEN, BLUE))\n        self.play(Create(pointcloud))\n        self.interactive_embed()"}]}
{"messages": [{"role": "user", "content": "Visualize a series of cameras from a Colmap dataset and allow interactive camera control."}, {"role": "assistant", "content": "import glob\nimport cv2\nimport open3d as o3d\nfrom manim import *\nfrom manim.opengl import *\nfrom manim.renderer.opengl_renderer import OpenGLCamera\nfrom pyglet.window import key\nfrom utilities import ColmapObject\nfrom assets.gaussian.pysift import *\n\nclass TestFocusCameraScene(Scene):\n\n    def construct(self):\n        colmap = ColmapObject('assets/test/sparse/0', [np.array([5.95773, 2.50781, 8.62867]), np.array([3.70964, 3.14088, 7.81675]), np.array([2.82718, 0.187449, 11.3918])])\n        cam = list(colmap.cameras.values())[0]\n        for c in colmap.cameras.values():\n            self.add(c)\n        self.camera.move_to(cam.image)\n        self.camera.set_height(self.camera.get_focal_distance())\n        a, b, c = cam.scipy_rotmat.as_euler('zxz')\n        self.camera.set_euler_angles(c, b, a)\n        self.interactive_embed()"}]}
{"messages": [{"role": "user", "content": "Display SIFT keypoints on an image and allow interactive exploration."}, {"role": "assistant", "content": "import glob\nimport cv2\nimport open3d as o3d\nfrom manim import *\nfrom manim.opengl import *\nfrom manim.renderer.opengl_renderer import OpenGLCamera\nfrom pyglet.window import key\nfrom utilities import ColmapObject\nfrom assets.gaussian.pysift import *\n\nclass SIFT(Scene):\n\n    def construct(self):\n        w, h = (6, 4)\n        scale = 100\n        img1 = cv2.imread('assets/hold/images-tiny/_0003.png', cv2.IMREAD_GRAYSCALE)\n        sift = cv2.SIFT()\n        pts = sift.detect(img1)\n        print(pts)\n        return\n        img = OpenGLImageMobject('assets/hold/images-tiny/_0002.png').stretch_to_fit_width(w).stretch_to_fit_height(h).move_to(ORIGIN)\n        self.camera.set_height(h)\n        self.add(img)\n        for k in kp1:\n            self.add(Dot().move_to(np.array([k.pt[0] / scale - w / 2, -(k.pt[1] / scale - h / 2), 0])).scale(1 / 5))\n        self.interactive_embed()"}]}
{"messages": [{"role": "user", "content": "Demonstrate SIFT feature detection by interactively highlighting image scales and corresponding dog images."}, {"role": "assistant", "content": "import glob\nimport cv2\nimport open3d as o3d\nfrom manim import *\nfrom manim.opengl import *\nfrom manim.renderer.opengl_renderer import OpenGLCamera\nfrom pyglet.window import key\nfrom utilities import ColmapObject\nfrom assets.gaussian.pysift import *\n\nclass SIFTTest(Scene):\n\n    def on_key_press(self, symbol, modifiers):\n        if symbol == key.NUM_0:\n            self.highlight_scale([0, 1])\n        if symbol == key.NUM_1:\n            self.highlight_scale([1, 2])\n        if symbol == key.NUM_2:\n            self.highlight_scale([2, 3])\n        if symbol == key.NUM_3:\n            self.highlight_scale([3, 4])\n        if symbol == key.NUM_4:\n            self.highlight_scale([4, 5])\n        if symbol == key.NUM_5:\n            self.play(self.current_scale.animate.restore(), self.current_dog.animate.restore())\n            self.current_scale.save_state()\n            self.current_dog.save_state()\n        super().on_key_press(symbol, modifiers)\n\n    def highlight_scale(self, indexes):\n        self.play(*[AnimationGroup(self.current_scale[j][0].animate.set_opacity(0.15), self.current_scale[j][1].animate.set_style(fill_opacity=0, stroke_opacity=0.15)) for j in range(len(self.current_scale)) if j not in indexes], *[AnimationGroup(self.current_dog[j][0].animate.set_opacity(0.15), self.current_dog[j][1].animate.set_style(fill_opacity=0, stroke_opacity=0.15)) for j in range(len(self.current_dog)) if j != indexes[0]])\n\n    def create_image_stack(self, paths):\n        w, _ = Image.open(paths[0]).size\n        scale = OpenGLGroup(*[OpenGLGroup(OpenGLImageMobject(p).set_width(w / 1000)) for p in reversed(paths)]).arrange(OUT, buff=0.5)\n        for s in scale:\n            s.add(SurroundingRectangle(s[0], color=WHITE, buff=0))\n        scale.save_state()\n        return scale\n\n    def construct(self):\n        self.input = OpenGLImageMobject('assets/gaussian/input.png')\n        self.gaussian_paths = [sorted(glob.glob(folder + '/*')) for folder in sorted(glob.glob('assets/gaussian/gaussians/*'))]\n        self.dog_paths = [sorted(glob.glob(folder + '/*')) for folder in sorted(glob.glob('assets/gaussian/dogs/*'))]\n        self.gaussian_scales = [self.create_image_stack(self.gaussian_paths[0])]\n        self.dogs = [self.create_image_stack(self.dog_paths[0]).next_to(self.gaussian_scales[0], RIGHT, buff=1)]\n        self.current_scale = self.gaussian_scales[0]\n        self.current_dog = self.dogs[0]\n        self.current_scale.save_state()\n        self.current_dog.save_state()\n        self.add(self.current_scale)\n        self.add(self.current_dog)\n        self.interactive_embed()"}]}
{"messages": [{"role": "user", "content": "Illustrate the Traveling Salesperson Problem by displaying a representation of the problem."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TestTSP(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        G = GetTSPIllustration()\n        self.add(G)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create and display an illustration of the Traveling Salesperson Problem."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TestColoring(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        G = GetTSPIllustration()\n        self.add(G)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display images of Kantorovich and Koopmans with their names and labels, indicating a connection to logistics and economics respectively."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TransparentNobel(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        img_scale = 0.4\n        text_scale = 0.9\n        subtext_scale = 0.65\n        kantorovich = ImageMobject('assets/kantorovich.jpg').set_height(self.camera.frame.get_height() * img_scale)\n        kantorovich.add(SurroundingRectangle(kantorovich, color=WHITE, buff=-0.01))\n        koopmans = ImageMobject('assets/koopmans.jpg').set_height(self.camera.frame.get_height() * img_scale)\n        koopmans.add(SurroundingRectangle(koopmans, color=WHITE, buff=-0.01))\n        a = Group(Group(kantorovich, Tex('\\\\textit{Kantorovich} (USSR)').scale(subtext_scale)).arrange(DOWN, buff=0.3), Group(koopmans, Tex('\\\\textit{Koopmans} (US)').scale(subtext_scale)).arrange(DOWN, buff=0.3)).scale(1.1).arrange(RIGHT, buff=5.5)\n        logistics = Tex('$\\\\leftarrow$ logistics').next_to(kantorovich, RIGHT).shift(UP * 0.7)\n        economics = Tex('economics $\\\\rightarrow$').next_to(koopmans, LEFT).shift(DOWN * 0.7)\n        self.play(FadeIn(a))\n        self.play(FadeIn(logistics))\n        self.play(FadeIn(economics))"}]}
{"messages": [{"role": "user", "content": "Present three achievements in computer science: winning a Nobel Prize, solving NP-hard problems, and achieving immortality, each illustrated with relevant images and text, and sequentially animate the scene to highlight each achievement before concluding with a focus on Linear Programming."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass Intro(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        img_scale = 0.4\n        text_scale = 1.1\n        subtext_scale = 0.75\n        kantorovich = ImageMobject('assets/kantorovich.jpg').set_height(self.camera.frame.get_height() * img_scale)\n        kantorovich.add(SurroundingRectangle(kantorovich, color=WHITE, buff=-0.01))\n        koopmans = ImageMobject('assets/koopmans.jpg').set_height(self.camera.frame.get_height() * img_scale)\n        koopmans.add(SurroundingRectangle(koopmans, color=WHITE, buff=-0.01))\n        a = Group(VGroup(Tex('\\\\underline{Win a Nobel Prize}').scale(text_scale), Tex('\\\\textit{Kantorovich, Koopmans (1975)}').scale(subtext_scale)).arrange(DOWN, buff=0.25), Group(kantorovich, koopmans).arrange()).arrange(DOWN, buff=0.5)\n        knapsack = ImageMobject('assets/midjourney/knapsack-out.png').set_height(self.camera.frame.get_height() * img_scale)\n        tsp = GetTSPIllustration().set_height(self.camera.frame.get_height() * img_scale)\n        b = Group(VGroup(Tex('\\\\underline{Solve NP-hard Problems}').scale(text_scale), Tex('\\\\textit{Knapsack, TSP, Vertex Cover, $\\\\ldots$}').scale(subtext_scale)).arrange(DOWN, buff=0.25), Group(knapsack, tsp).arrange(buff=0.5)).arrange(DOWN, buff=0.5)\n        transcendence = ImageMobject('assets/transcendence.png').set_height(self.camera.frame.get_height() * img_scale)\n        transcendence.add(SurroundingRectangle(transcendence, color=WHITE, buff=-0.01))\n        imm = Tex('\\\\underline{Achieve immortality}').scale(text_scale)\n        imm.align_to(b, UP)\n        imm[0][-1].align_to(b[0][0][0][-1], DOWN)\n        c = Group(VGroup(imm, Tex('\\\\textit{Sacrifices / Solving $\\\\mathrm{P}\\\\ \\\\text{vs.}\\\\ \\\\mathrm{NP}$}').scale(subtext_scale)).arrange(DOWN, buff=0.25), transcendence).arrange(DOWN, buff=0.5)\n        g = Group(a, b, c).arrange(buff=1).scale(0.65)\n        tspfaded = GetTSPIllustration(fade=True).set_height(self.camera.frame.get_height() * img_scale).move_to(tsp).scale(0.65)\n        self.camera.frame.move_to(a).scale(0.65)\n        self.play(AnimationGroup(Write(a[0][0], run_time=1), FadeIn(a[0][1], run_time=1), lag_ratio=0.5), Succession(Wait(0.5), FadeIn(a[1])))\n        self.play(a[0].animate.set_opacity(BIG_OPACITY), a[1][0].animate.set_opacity(BIG_OPACITY), a[1][1].animate.set_opacity(BIG_OPACITY), a[1][0][1].animate.set_color(DARKER_GRAY), a[1][1][1].animate.set_color(DARKER_GRAY), self.camera.frame.animate.move_to(b), AnimationGroup(Write(b[0][0], run_time=1), FadeIn(b[0][1], run_time=1), lag_ratio=0.5), Succession(Wait(0.5), FadeIn(b[1])))\n        tsp.save_state()\n        self.play(AnimationGroup(Write(c[0][0], run_time=1), FadeIn(c[0][1], run_time=1), lag_ratio=0.5), b[0].animate.set_opacity(BIG_OPACITY), b[1][0].animate.set_opacity(BIG_OPACITY), Transform(b[1][1], tspfaded), self.camera.frame.animate.move_to(c), Succession(Wait(0.5), FadeIn(c[1])))\n        self.play(self.camera.frame.animate.move_to(Group(a, b)).scale(1.25), FadeOut(c), a[0].animate.set_opacity(1), a[1][0].animate.set_opacity(1), a[1][1].animate.set_opacity(1), a[1][0][1].animate.set_color(WHITE), a[1][1][1].animate.set_color(WHITE), b[0].animate.set_opacity(1), b[1][0].animate.set_opacity(1), tsp.animate.restore())\n        lp = Tex('\\\\sc Linear Programming').scale(1.5).next_to(Group(a, b), UP, buff=0.85)\n        self.play(self.camera.frame.animate.move_to(Group(a, b, lp)), FadeIn(lp, shift=UP * 0.75))"}]}
{"messages": [{"role": "user", "content": "Illustrate the farmer's profit maximization problem by displaying the problem statement, then the constraints and objective function, and finally visualizing the feasible region and optimal solution."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass Duality(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        farm = ImageMobject('assets/midjourney/farm-12-16-out.png').set_height(self.camera.frame.get_height()).align_to(self.camera.frame, LEFT).set_z_index(5)\n        rect = ImageMobject('assets/midjourney/farm-12-16-rect.png').set_height(self.camera.frame.get_height()).align_to(farm, RIGHT).set_z_index(6)\n        rect_large = ImageMobject('assets/midjourney/farm-12-16-rect-large.png')\n        rect_small = ImageMobject('assets/midjourney/farm-12-16-rect-small.png').set_height(self.camera.frame.get_height()).align_to(farm, RIGHT).set_z_index(6)\n        farm.save_state()\n        rect.save_state()\n        icon_scale = 1.65\n        carrot = ImageMobject('assets/midjourney/carrot-cropped-flopped.png').set_height(0.45 * icon_scale)\n        potato = ImageMobject('assets/midjourney/potato-cropped.png').set_height(0.3 * icon_scale)\n        fertilizer = ImageMobject('assets/midjourney/fertilizer-cropped-flopped.png').set_height(0.3 * icon_scale)\n        farmer = ImageMobject('assets/midjourney/farmer-outline.png').set_z_index(10).set_height(1.05)\n        farmer_black = ImageMobject('assets/midjourney/farmer-black.png').set_z_index(9).set_height(1.05)\n        self.add(rect, farm)\n        fc = farm.copy()\n        farm.move_to(Dot().next_to(self.camera.frame, LEFT))\n        offset = 1\n        rect_played = rect.copy().next_to(fc, RIGHT, buff=0).shift(LEFT * offset * 2)\n        farm_played = farm.align_to(self.camera.frame, LEFT).shift(LEFT * offset)\n        title = Tex(\"\\\\underline{Farmer's Problem}\").scale(1.5)\n        goal = Tex('Goal: \\\\it maximize profit').scale(1.25)\n        points = VGroup(Tex('\\\\begin{itemize} \\\\item $3$ tons of potato seeds \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $4$ tons of carrot seeds \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $5$ tons of fertilizer (used 1:1) \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item ' + str(OF_INITIAL[0]) + '\\\\$/kg for O, ' + str(OF_INITIAL[1]) + '\\\\$/kg for O \\\\end{itemize}'))\n        for i in range(3):\n            align_object_by_coords(points[i + 1], points[i + 1][0][0], points[0][0][0])\n            points[i + 1].shift(DOWN * 0.75 * (i + 1))\n            if i == 2:\n                points[i + 1].shift(DOWN * 0.3)\n        guide = Dot().move_to(VGroup(Dot().align_to(rect_played, LEFT), Dot().align_to(self.camera.frame, RIGHT)))\n        potato.next_to(points[0][0][-1], RIGHT)\n        carrot.next_to(points[1][0][-1], RIGHT)\n        fertilizer.next_to(points[2][0][-1], RIGHT)\n        p2 = potato.copy().move_to(points[3][0][11])\n        c2 = carrot.copy().move_to(points[3][0][-1]).shift(RIGHT * 0.1)\n        points[3][0][11].scale(0.001).set_color(BLACK).set_opacity(0).set_z_index(-1)\n        points[3][0][-1].scale(0.001).set_color(BLACK).set_opacity(0).set_z_index(-1)\n        points[0][0][1].set_color(POTATO_COLOR)\n        points[1][0][1].set_color(CARROT_COLOR)\n        points[2][0][1].set_color(FERTILIZER_COLOR)\n        points[0][0][8:13 + 1].set_color(POTATO_COLOR)\n        points[1][0][8:13 + 1].set_color(CARROT_COLOR)\n        points[2][0][8:17 + 1].set_color(FERTILIZER_COLOR)\n        points[3][0][1:7 + 1].set_color(POTATO_COLOR)\n        points[3][0][13:19 + 1].set_color(CARROT_COLOR)\n        main_group = Group(Group(title, farmer).arrange(buff=0.4), Group(points, p2, c2, carrot, potato, fertilizer), goal).arrange(DOWN, buff=0.7).move_to(guide).set_z_index(10)\n        title.set_z_index(7)\n        farmer_copy = farmer.copy().move_to(title[0][0]).align_to(farmer, DOWN).set_opacity(0).set_z_index(1000)\n        farmer_black.move_to(farmer).set_z_index(999)\n        farmer_black_copy = farmer_black.copy().move_to(title[0][0]).align_to(farmer, DOWN).set_z_index(999)\n        sr1 = SurroundingRectangle(title, color=BLACK, fill_opacity=1).set_z_index(8)\n        sr2 = SurroundingRectangle(title, color=BLACK, fill_opacity=1).set_z_index(9).move_to(farmer_copy).align_to(Dot().move_to(farmer_copy), LEFT)\n        self.add(sr1, title)\n        self.play(rect.animate.next_to(fc, RIGHT, buff=0).shift(LEFT * offset * 2), farm.animate.align_to(self.camera.frame, LEFT).shift(LEFT * offset), ReplacementTransform(farmer_copy, farmer), ReplacementTransform(farmer_black_copy, farmer_black), FadeOut(sr1), sr2.animate.align_to(Dot().move_to(farmer), LEFT), run_time=2)\n        self.remove(farmer_black, sr2)\n        self.play(AnimationGroup(Write(points[0], run_time=1.25), FadeIn(potato, shift=0.1 * RIGHT), lag_ratio=0.5))\n        self.play(AnimationGroup(Write(points[1], run_time=1.25), FadeIn(carrot, shift=0.1 * RIGHT), lag_ratio=0.5))\n        self.play(Write(points[2][0][:17 + 1], run_time=1))\n        self.play(AnimationGroup(Write(points[2][0][17 + 1:], run_time=0.65), FadeIn(fertilizer, shift=0.1 * RIGHT), lag_ratio=0.3))\n        self.play(AnimationGroup(Write(points[3][0][:12 + 1]), FadeIn(p2, run_time=0.5), lag_ratio=0.5))\n        self.play(AnimationGroup(Write(points[3][0][12 + 1:]), FadeIn(c2, run_time=0.5), lag_ratio=0.5))\n        self.play(Write(goal[0][:5]), run_time=0.65)\n        self.play(Write(goal[0][5:]), run_time=1)\n        saved_x = (main_group.animate.set_x(0),)\n        rect2 = rect_small.copy().flip().align_to(self.camera.frame, RIGHT).shift(RIGHT * 0.1)\n        self.add(rect2)\n        offset2 = 0.5\n        equivalenece = SVGMobject('assets/iff.svg').set_height(0.6).set_z_index(10)\n        equivalenece.move_to(Dot().align_to(self.camera.frame, RIGHT))\n        equivalenece.set_opacity(0).shift(RIGHT * (0.65 - offset2))\n        self.play(rect.animate.restore(), farm.animate.restore(), main_group.animate.set_x(-main_group.get_x() - offset2 / 2), rect2.animate.shift(LEFT * (main_group.get_x() * 2 + offset2)), equivalenece.animate.shift(LEFT * (main_group.get_x() * 2 + offset2)).set_opacity(1))\n        guide2 = Dot().move_to(VGroup(Dot().move_to(equivalenece), Dot().align_to(self.camera.frame, RIGHT)))\n        var = ComplexTex('variables: $x_p, x_c$')\n        var[0][-5:-3].set_color(POTATO_COLOR)\n        var[0][-2:].set_color(CARROT_COLOR)\n        ineqs = ComplexTex('$$\\\\begin{aligned}\\n        x_p, x_c  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_p \\\\phantom{{}+ x_c} &\\\\le 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_c &\\\\le 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_p + x_c &\\\\le 5\\\\,000\\n                \\\\end{aligned}$$')\n        ineqs[0][0:2].set_color(POTATO_COLOR)\n        ineqs[0][3:3 + 2].set_color(CARROT_COLOR)\n        ineqs[0][7:7 + 2].set_color(POTATO_COLOR)\n        ineqs[0][10].set_color(POTATO_COLOR)\n        ineqs[0][11].set_color(POTATO_COLOR)\n        ineqs[0][12].set_color(POTATO_COLOR)\n        ineqs[0][13].set_color(POTATO_COLOR)\n        ineqs[0][14:14 + 2].set_color(CARROT_COLOR)\n        ineqs[0][17].set_color(CARROT_COLOR)\n        ineqs[0][18].set_color(CARROT_COLOR)\n        ineqs[0][19].set_color(CARROT_COLOR)\n        ineqs[0][20].set_color(CARROT_COLOR)\n        ineqs[0][21:21 + 2].set_color(POTATO_COLOR)\n        ineqs[0][24:24 + 2].set_color(CARROT_COLOR)\n        ineqs[0][27].set_color(FERTILIZER_COLOR)\n        ineqs[0][28].set_color(FERTILIZER_COLOR)\n        ineqs[0][29].set_color(FERTILIZER_COLOR)\n        ineqs[0][30].set_color(FERTILIZER_COLOR)\n        exp = ComplexTex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_p + ' + str(OF_INITIAL[1]) + ' x_c$$')\n        exp[0][3:3 + 5].set_color(POTATO_COLOR)\n        exp[0][-5:].set_color(CARROT_COLOR)\n        of = Tex('objective function').set_opacity(MED_OPACITY).scale(0.75)\n        theory_group = Group(var, ineqs, exp).arrange(DOWN, buff=0.75).move_to(guide2).set_z_index(10)\n        var.align_to(title, DOWN)\n        exp.align_to(goal, UP)\n        self.play(AnimationGroup(AnimationGroup(points[2].animate.set_opacity(BIG_OPACITY), points[3].animate.set_opacity(BIG_OPACITY), fertilizer.animate.set_opacity(BIG_OPACITY), p2.animate.set_opacity(BIG_OPACITY), c2.animate.set_opacity(BIG_OPACITY), goal.animate.set_opacity(BIG_OPACITY)), Write(var, run_time=1.25), lag_ratio=0.5))\n        self.play(Write(ineqs[0][:7]), run_time=1.25)\n        self.play(Write(ineqs[0][7:21]), run_time=1.5)\n        self.play(AnimationGroup(AnimationGroup(points[0].animate.set_opacity(BIG_OPACITY), points[1].animate.set_opacity(BIG_OPACITY), potato.animate.set_opacity(BIG_OPACITY), carrot.animate.set_opacity(BIG_OPACITY), points[2].animate.set_opacity(1), fertilizer.animate.set_opacity(1)), Write(ineqs[0][21:], run_time=1), lag_ratio=0.5))\n        self.play(AnimationGroup(AnimationGroup(points[2].animate.set_opacity(BIG_OPACITY), fertilizer.animate.set_opacity(BIG_OPACITY), points[3].animate.set_opacity(1), p2.animate.set_opacity(1), c2.animate.set_opacity(1), goal.animate.set_opacity(1)), Write(exp, run_time=1.5), lag_ratio=0.5))\n        g = VGroup(exp.copy(), of).arrange(UP, buff=0.15).move_to(exp)\n        self.play(Transform(exp, g[0]), FadeIn(of, shift=UP * 0.15))\n        self.play(points.animate.set_opacity(1), carrot.animate.set_opacity(1), potato.animate.set_opacity(1), fertilizer.animate.set_opacity(1))\n        theory_group.add(of)\n        of.set_z_index(10)\n        self.remove(rect, farm)\n        rect3 = rect.copy().flip().align_to(self.camera.frame, RIGHT).set_z_index(rect2.get_z_index() - 1).shift(RIGHT * 0.1)\n        self.add(rect3)\n        guide3 = Dot().move_to(main_group)\n        guide3.set_x(-guide3.get_x())\n        numberplane = NumberPlane(x_range=(-3 * 7.111111111111111, 3 * 7.111111111111111, 1), y_range=(-3 * 4.0, 3 * 4.0, 1), stroke_width=6, axis_config={'stroke_width': 4}, background_line_style={'stroke_color': GRAY, 'stroke_width': 3, 'stroke_opacity': 0.6})\n        numberplane.background_lines.set_z_index(rect3.get_z_index() - 1 + 0.1)\n        numberplane.axes.set_z_index(rect3.get_z_index() - 1 + 0.2)\n        area = FeasibleArea2D(dots_z_index=rect3.get_z_index() - 1 + 0.99).set_z_index(rect3.get_z_index() - 1 + 0.4)\n        i1 = Inequality2D(1, 0, '>=', 0).set_color(POTATO_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i2 = Inequality2D(0, 1, '>=', 0).set_color(CARROT_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i3 = Inequality2D(1, 1, '<=', 5).set_color(FERTILIZER_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i4 = Inequality2D(1, 0, '<=', 3).set_color(POTATO_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i5 = Inequality2D(0, 1, '<=', 4).set_color(CARROT_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i4_hp = i4.get_half_plane()\n        area.add_inequalities([i1, i2, i3, i4, i5])\n        of_arrow = Arrow(start=ORIGIN, end=np.array((*OF_INITIAL, 0)), buff=0).set_z_index(area.dots_z_index - 0.01)\n        of_arrow_shadow = of_arrow.copy().set_color(WHITE).set_z_index(of_arrow.get_z_index() - 1e-06)\n        optimum = list(solve_farm(OF_INITIAL))\n        optimum[0] /= 1000\n        optimum[1] /= 1000\n        sweep = AffineLine2D(OF_INITIAL).rotate(PI / 2)\n        sweep.crop_to_screen(self.camera.frame)\n        sweep.set_z_index(rect3.get_z_index() - 1 + 0.99).set_color(BLUE)\n        sweep_goal = AffineLine2D(OF_INITIAL).rotate(-PI / 2).move_to([*optimum, 0])\n        sweep_goal.set_z_index(rect3.get_z_index() - 1 + 0.99)\n        sweep_angle = Angle(sweep.line, of_arrow, dot=True).set_z_index(99).set_color(BLUE)\n        sweep.dots = VGroup()\n        sweep.add(sweep.dots)\n        sweep.lineextra = VGroup()\n        sweep.add(sweep.lineextra)\n\n        def sweep_updater(obj):\n            dots = sweep.get_area_border_intersection(area)\n            if len(dots) <= 1:\n                return\n            g = VGroup().set_z_index(100000)\n            for i in range(len(dots)):\n                for j in range(i + 1, len(dots)):\n                    d1, d2 = (dots[i], dots[j])\n                    g.add(Line(start=d1.get_center(), end=d2.get_center(), color=BLUE, stroke_width=LINE_STROKE + 2.5).set_z_index(100000))\n            sweep.lineextra.become(g).set_z_index(100000)\n            sweep.dots.become(dots).set_z_index(100000).set_color(BLUE)\n        sweep_updater(None)\n        sweep_dots_tmp = sweep.dots\n        sweep.remove(sweep.dots)\n        align_object_by_coords(VGroup(i1, i4_hp, i2, i3, i4, i5, area, numberplane, of_arrow, of_arrow_shadow, sweep, sweep_goal, sweep_angle, sweep_dots_tmp), area.dots.get_center(), guide3.get_center())\n        i1.crop_to_screen(self.camera.frame)\n        i2.crop_to_screen(self.camera.frame)\n        i3.crop_to_screen(self.camera.frame)\n        i4.crop_to_screen(self.camera.frame)\n        i5.crop_to_screen(self.camera.frame)\n        labels = VGroup(Tex('$x_p$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[0], DOWN, buff=0.33).align_to(self.camera.frame, RIGHT).shift(LEFT * 0.2).set_color(POTATO_COLOR), Tex('$x_c$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[1], LEFT, buff=0.23).align_to(self.camera.frame, UP).shift(DOWN * 0.35).set_color(CARROT_COLOR)).set_z_index(i1.get_z_index() + 1)\n        self.play(AnimationGroup(AnimationGroup(main_group.animate.shift(LEFT * theory_group.get_x() * 2), rect2.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(0), rect3.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(1), var.animate.shift(LEFT * theory_group.get_x() * 2), ineqs.animate.shift(LEFT * theory_group.get_x() * 2), exp.animate.shift(LEFT * theory_group.get_x() * 2), of.animate.shift(LEFT * theory_group.get_x() * 2), equivalenece.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(0)), AnimationGroup(FadeIn(numberplane.background_lines), FadeIn(numberplane.axes)), lag_ratio=0.5))\n        labels_tmp = labels.copy()\n        xptmp = var[0][10:10 + 2].copy()\n        xctmp = var[0][13:13 + 2].copy()\n        self.play(AnimationGroup(Transform(xptmp, labels_tmp[0]), Transform(xctmp, labels_tmp[1]), lag_ratio=0.25))\n        self.remove(xptmp, xctmp)\n        self.add(labels)\n        sr = SurroundingRectangle(VGroup(Dot().align_to(self.camera.frame, UP + RIGHT), Dot().align_to(self.camera.frame, DOWN + RIGHT), Dot().align_to(rect3, RIGHT)), fill_opacity=1).move_to(guide3).set_color_by_gradient((RED, GREEN)).set_opacity(0.35)\n        sr.set_sheen_direction(unit_vector(OF_INITIAL[0] * RIGHT + OF_INITIAL[1] * UP))\n        print('SR', list(Dot().align_to(self.camera.frame, UP + RIGHT).get_center()), list(Dot().align_to(self.camera.frame, DOWN + RIGHT).get_center()), list(Dot().align_to(rect3, RIGHT).get_center()), list(guide3.get_center()))\n        self.remove(main_group, rect2, equivalenece)\n        big_hl = CreateHighlight(ineqs)\n        hl = CreateHighlight(ineqs[0][7:7 + 7])\n        self.play(exp.animate.set_opacity(BIG_OPACITY), of.animate.set_opacity(BIG_OPACITY), FadeIn(big_hl))\n        self.play(AnimationGroup(Transform(big_hl, hl), Create(i4), lag_ratio=0.5))\n        self.remove(big_hl)\n        self.add(hl)\n        self.play(FadeIn(i4_hp))\n        self.play(AnimationGroup(FadeOut(hl), Create(i1), Create(i2), Create(i3), Create(i5), AnimationGroup(FadeOut(i4_hp), FadeIn(area)), lag_ratio=0.25))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(i1), FadeOut(i2), FadeOut(i3), FadeOut(i4), FadeOut(i5)), lag_ratio=0.5))\n        self.play(area.area.animate(rate_func=there_and_back, run_time=1.25).set_fill(BLUE, 0.5))\n        self.play(exp.animate.set_opacity(1), of.animate.set_opacity(MED_OPACITY), ineqs.animate.set_opacity(BIG_OPACITY))\n        self.add(sr)\n        thingy = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(OF_INITIAL[1], OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        self.play(AnimationGroup(thingy.animate(run_time=2).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 7), AnimationGroup(Write(of_arrow)), lag_ratio=0))\n        self.remove(thingy)\n        self.play(FadeIn(sweep), FadeIn(sweep_angle), FadeIn(sweep_dots_tmp), of_arrow.animate.set_color(BLUE))\n        sweep.add(sweep_dots_tmp)\n        dl = DashedLine(ORIGIN - 0.0001, ORIGIN + 0.0001).set_z_index(of_arrow.get_z_index() - 1e-05).set_color(BLUE)\n\n        def of_updater(obj):\n            start = of_arrow.get_start()\n            end = of_arrow.get_end()\n            point = intersection(line(start, end), line(sweep.line.get_start(), sweep.line.get_end()))\n            new_point = np.array([*point, 0])\n            of_arrow.put_start_and_end_on(new_point, new_point + np.array([*OF_INITIAL, 0]))\n            sweep_angle.become(Angle(sweep.line, of_arrow, dot=True).set_color(BLUE).set_z_index(99))\n\n        def dl_updater(obj):\n            start = of_arrow_shadow.get_start()\n            end = intersection(line(of_arrow_shadow.get_start(), of_arrow_shadow.get_end()), line(sweep.line.get_start(), sweep.line.get_end()))\n            end = np.array([*end, 0])\n            l = 0.085\n            lt = l * 2\n            dist = distance(start, end)\n            dist_rounded = int(dist / lt) * lt\n            if abs(dist) < 0.001:\n                return\n            end_rounded = (end - start) / dist * dist_rounded + start + l / 10\n            obj.become(DashedLine(end_rounded, start, dash_length=l, stroke_width=of_arrow.get_stroke_width() * 0.95).set_color(BLUE).set_z_index(of_arrow.get_z_index() - 0.0001))\n        dl.add_updater(dl_updater)\n        self.add(dl)\n        dummy = VMobject()\n        dummy.add_updater(sweep_updater)\n        dummy.add_updater(of_updater)\n        self.add(dummy)\n        self.camera.frame.save_state()\n        theory_group.save_state()\n        rect3.save_state()\n        self.play(FadeIn(of_arrow_shadow), sweep.animate(run_time=3).move_to(sweep_goal))\n        self.remove(dummy)\n        optimum = sweep.dots\n        sweep.remove(sweep.dots)\n        optimum_texts = VGroup(Tex('$1\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.8).move_to(optimum).align_to(numberplane.axes[0], UP).shift(DOWN * 0.35).set_z_index(100000), Tex('$4\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.8).move_to(optimum).align_to(numberplane.axes[1], RIGHT).shift(LEFT * 0.35).set_z_index(100000), Tex('$\\\\$8\\\\,000$').scale(0.8).next_to(optimum, UP + RIGHT).set_z_index(100000))\n        for i in range(3):\n            optimum_texts[i].add(CreateSR(optimum_texts[i]))\n        self.play(FadeIn(optimum_texts), FadeOut(sweep_angle), of_arrow.animate.set_opacity(0), ineqs.animate.set_opacity(1))\n        for i in [0, 1, 2]:\n            self.play(optimum_texts[i].animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        vm = CreateMeaning(var, '\\\\small variables $\\\\in \\\\mathbb{R}$')\n        vi = CreateMeaning(ineqs, '\\\\small s.t. linear \\\\par inequalities')\n        vo = CreateMeaning(VGroup(of, exp), '\\\\small maximizing \\\\par linear function')\n        dl.remove_updater(dl_updater)\n        self.play(FadeOut(optimum_texts), FadeOut(optimum), FadeOut(dl), FadeOut(sweep))\n        for o, rt in [(vm, 1.25), (vi, 1.5), (vo, 1.5)]:\n            self.play(AnimationGroup(FadeIn(o[0]), Write(o[1], run_time=rt), lag_ratio=0.5))\n        print(numberplane.get_center())\n        iextras = []\n        ipts = [[np.array([0, 0]), np.array([1, -2]), 0.5, None], [np.array([0, 0]), np.array([1, -0.5]), 0.5, None], [np.array([3, 0]), np.array([4, 1]), 0.25, None], [np.array([3, 2]), np.array([2, 3.5]), 0.25, '<='], [np.array([0, 4]), np.array([-1, 3.7]), 0.15, '<='], [np.array([0, 4]), np.array([-1, 3]), 0.15, '<='], [np.array([0, 4]), np.array([-1, 0]), 0.2, '<='], [np.array([1, 4]), np.array([0, 4.9]), 0.05, '<=']]\n        inorms = []\n        start = of_arrow_shadow.get_start()\n        for p1, p2, s, op in ipts:\n            a, b, c = Inequality2D.points_to_slope(p1, p2)\n            iq = Inequality2D(a, b, op or '>=', c).set_opacity(0).shift(of_arrow_shadow.get_start())\n            iextras.append(iq)\n            self.add(iq)\n            area.add_inequalities([iq])\n            d = p2 - p1\n            inorms.append((-d[1], d[0], 0) / np.linalg.norm(d))\n            ino = np.array((-d[1], d[0])) / np.linalg.norm(d)\n\n        def ineqs_complex_updater(obj, dt):\n            obj._update_area()\n            best_score = float('inf')\n            best_pos = None\n            for d in obj.dots:\n                score = d.get_center()[0] * OF_INITIAL[0] + d.get_center()[1] * OF_INITIAL[1]\n                if score < best_score:\n                    best_score = score\n                    best_pos = d.get_center()\n            of_arrow_shadow.put_start_and_end_on(best_pos, best_pos + of_arrow_shadow.get_end() - of_arrow_shadow.get_start())\n        self.add(area)\n        area.add_updater(ineqs_complex_updater)\n        self.play(*[iextras[i].animate.shift(inorms[i] * ipts[i][-2]) for i in range(len(ipts))], vi[1].animate.scale(1.25))\n        self.play(*[iextras[i].animate.shift(-inorms[i] * ipts[i][-2] * 1.1) for i in range(len(ipts))], FadeOut(vm, vi, vo))\n        area.remove_updater(ineqs_complex_updater)\n        area.remove_inequalities(iextras)\n\n        def of_line_updater(obj):\n            vector = of_arrow_shadow.get_end() - of_arrow_shadow.get_start()\n            x, y, _ = vector\n            optimum = list(solve_farm([x, y]))\n            optimum[0] /= 1000\n            optimum[1] /= 1000\n            sweep.line.become(AffineLine2D([x, y]).line.set_color(BLUE).rotate(PI / 2).move_to(of_arrow_shadow.get_start()).shift([*optimum, 0]))\n            op = '+' if y >= 0 else '-'\n            new_exp = Tex(f'$$\\\\max\\\\ {x:.1f}x_p {op} {abs(y):.1f}x_c$$').move_to(exp).align_to(exp, DOWN)\n            new_exp[0][3:3 + 5].set_color(POTATO_COLOR)\n            new_exp[0][9:9 + 5].set_color(CARROT_COLOR)\n            exp.become(new_exp)\n        sm = Tex('\\\\underline{Simplex Method}').set_z_index(10000000000).scale(1)\n        sm.add(CreateSR(sm, buff=0.17))\n        sm.align_to(self.camera.frame, RIGHT + UP).shift((LEFT * 1.2 + DOWN) * 0.25)\n        self.play(AnimationGroup(FadeIn(sm[1]), Write(sm[0]), lag_ratio=0.2))\n        self.play(FadeIn(optimum), FadeIn(dl), FadeIn(sweep))\n        srcp = sr.copy().set_z_index(sr.get_z_index() + 0.2)\n        thingy = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(OF_INITIAL[1], OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        thingy2 = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(-OF_INITIAL[1], -OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        thingy2.shift(-unit_vector(OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 18)\n        self.add(thingy, thingy2, srcp)\n        self.play(thingy.animate(run_time=2.5).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 9), thingy2.animate(run_time=2.5).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 9))\n        self.remove(thingy, thingy2, srcp)\n        dl.add_updater(dl_updater)\n        self.play(*[MyFlash(d, color=WHITE, z_index=d.get_z_index() + 1) for d in area.dots], MyFlash(optimum, color=BLUE, z_index=optimum.get_z_index() + 2))\n\n        def sr_updater(obj):\n            vector = of_arrow_shadow.get_end() - of_arrow_shadow.get_start()\n            obj.set_sheen_direction(unit_vector(vector))\n        sr.add_updater(sr_updater)\n        dummy = VMobject()\n        dummy.add_updater(of_line_updater)\n        dummy.add_updater(sweep_updater)\n        self.add(dummy)\n        angle = atan2(OF_INITIAL[1], OF_INITIAL[0])\n        self.play(Rotate(of_arrow_shadow, -angle, about_point=of_arrow_shadow.get_start()), run_time=2)\n        self.play(*[MyFlash(d, color=BLUE, z_index=d.get_z_index() + 1) for d in sweep.dots])\n        self.play(Rotate(of_arrow_shadow, +angle - 2 * PI, about_point=of_arrow_shadow.get_start()), run_time=5)\n        self.remove(dummy)\n        sr.remove_updater(sr_updater)\n        dl.remove_updater(dl_updater)\n        self.play(FadeOut(optimum), FadeOut(dl), FadeOut(sweep))\n        fade_rect = get_fade_rect()\n        of_arrow_shadow.set_z_index(fade_rect.get_z_index() - 1e-11)\n        of_arrow_shadow_2 = of_arrow_shadow.copy().set_color(BLUE).set_z_index(fade_rect.get_z_index() + 1)\n        of_dot = Dot().scale(OPTIMUM_DOT_SCALE).set_color(BLUE).move_to(of_arrow_shadow_2.get_start()).set_z_index(of_arrow_shadow_2.get_z_index())\n        trace = TracedPath(of_dot.get_center).set_color(BLUE).set_stroke_width(8).set_z_index(area.dots[0].get_z_index() - 1e-05)\n        G = VGroup(area, of_arrow_shadow, numberplane, labels[0])\n        l0 = Line(start=of_dot.get_center(), end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())\n        p0 = Tex('pivot \\\\#1').scale(0.75).next_to(l0, DOWN).shift(RIGHT * 1.5).set_z_index(l0.get_z_index())\n        sweep.move_to(of_arrow_shadow_2.get_start())\n        sweep.remove(sweep.lineextra)\n        self.play(FadeIn(of_arrow_shadow_2), FadeIn(of_dot))\n        self.play(VGroup(of_arrow_shadow_2, of_dot).animate.shift(RIGHT * 3), l0.animate.become(Line(start=of_dot.get_center() + RIGHT * 3, end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())), FadeIn(p0, run_time=1), run_time=2)\n        l1 = Line(start=of_dot.get_center(), end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())\n        us1 = 0.5\n        p1 = Tex('pivot \\\\#2').scale(0.75).next_to(l1, RIGHT).shift(UP * (1 - us1)).set_z_index(l1.get_z_index())\n        self.play(l0.animate.shift(DOWN * us1), p0.animate.shift(DOWN * us1), l1.animate.become(Line(start=of_dot.get_center() + UP * (2 - us1), end=of_dot.get_center() + DOWN * us1, color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())), G.animate.shift(DOWN * us1), FadeIn(p1, shift=DOWN * us1, run_time=1), VGroup(of_arrow_shadow_2, of_dot).animate.shift(UP * (2 - us1)), run_time=1.5)\n        l2 = Line(start=of_dot.get_center(), end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())\n        p2 = Tex('pivot \\\\#3').scale(0.75).next_to(l2.get_center(), UP + RIGHT).shift(LEFT).set_z_index(l1.get_z_index())\n        us2 = 1\n        self.play(l2.animate.become(Line(start=of_dot.get_center() + UP * (2 - us2) + LEFT * 2, end=of_dot.get_center() + DOWN * us2, color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())), l0.animate.shift(DOWN * us2), l1.animate.shift(DOWN * us2), p0.animate.shift(DOWN * us2), p1.animate.shift(DOWN * us2), G.animate.shift(DOWN * us2), FadeIn(p2, shift=DOWN * us2, run_time=1), VGroup(of_arrow_shadow_2, of_dot).animate.shift(UP * (2 - us2) + LEFT * 2), run_time=1.5)\n        self.play(MyFlash(of_dot, color=BLUE, z_index=optimum.get_z_index() + 2))\n        self.play(VGroup(numberplane, of_arrow_shadow, area, labels[0]).animate.shift(UP * (us1 + us2)), FadeOut(of_arrow_shadow_2, of_dot, l0, l1, l2, p0, p1, p2, shift=UP * (us1 + us2)))\n        VGroup(l0, l1, l2, p0, p1, p2).shift(UP * (us1 + us2))\n        ineqs2 = Tex('$$\\\\begin{aligned}\\n        x_1, x_2  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_1 \\\\phantom{{}+ x_2} &\\\\le 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_2 &\\\\le 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_1 + x_2 &\\\\le 5\\\\,000\\n                \\\\end{aligned}$$').align_to(ineqs, UP + RIGHT)\n        exp2 = Tex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_1 + ' + str(OF_INITIAL[1]) + ' x_2$$').align_to(exp, UP + LEFT)\n        var2 = Tex('variables: $x_1, x_2$').align_to(var, UP + LEFT)\n        labels2 = VGroup(Tex('$x_1$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[0], DOWN, buff=0.33).align_to(self.camera.frame, RIGHT).shift(LEFT * 0.2), Tex('$x_2$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[1], LEFT, buff=0.23).align_to(self.camera.frame, UP).shift(DOWN * 0.35)).set_z_index(i1.get_z_index() + 1)\n        labels2[0].align_to(labels[0], UP + LEFT)\n        labels2[1].align_to(labels[1], UP + LEFT)\n        self.play(Transform(ineqs, ineqs2), Transform(exp, exp2), Transform(var, var2), Transform(labels, labels2))\n        of_arrow_shadow_2 = of_arrow_shadow.copy().set_color(BLUE).set_z_index(fade_rect.get_z_index() + 1)\n        of_dot = Dot().scale(OPTIMUM_DOT_SCALE).set_color(BLUE).move_to(of_arrow_shadow_2.get_start()).set_z_index(of_arrow_shadow_2.get_z_index())\n        hl = CreateHighlight(ineqs[0][:7])\n        self.play(FadeIn(of_dot), FadeIn(of_arrow_shadow_2), MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1))\n        i1.set_color(YELLOW).set_opacity(0)\n        i2.set_color(YELLOW).set_opacity(0)\n        i3.set_color(YELLOW).set_opacity(0)\n        i4.set_color(YELLOW).set_opacity(0)\n        i5.set_color(YELLOW).set_opacity(0)\n        self.play(FadeIn(hl), i1.animate.set_opacity(1), i2.animate.set_opacity(1))\n        val = Tex('$(0, 0)$').scale(0.6).next_to(of_dot, UP).set_z_index(10000000000)\n        val.add(CreateSR(val))\n\n        def value_updater(obj, dt):\n            c = of_dot.get_center() - of_arrow_shadow.get_start()\n            x = int(round(c[0] * 1000))\n            y = int(round(c[1] * 1000))\n\n            def fmt(x):\n                x = str(x)\n                if len(x) == 4:\n                    return f'{x[0]}\\\\,{x[1:]}'\n                return x\n            val2 = Tex(f'$({fmt(x)}, {fmt(y)})$').scale(0.6).next_to(of_dot, UP).set_z_index(10000000000)\n            val2.add(CreateSR(val2))\n            val.become(val2)\n        hl2 = CreateHighlight(ineqs[0][7:14])\n        self.play(FadeIn(val))\n        self.play(FadeIn(p0), MyFlash(of_dot.copy().shift(RIGHT * 3), color=WHITE, z_index=of_dot.get_z_index() + 1))\n        val.add_updater(value_updater)\n        a_surprise_weapon_that_will_help_us_later = VGroup(ineqs.copy(), exp.copy(), var.copy(), of.copy())\n        self.play(of_arrow_shadow_2.animate.shift(RIGHT * 1.5), of_dot.animate.shift(RIGHT * 1.5), Transform(hl, CreateHighlight(ineqs[0][3:7])), i1.animate.set_opacity(0), run_time=1.5)\n        self.play(of_arrow_shadow_2.animate.shift(RIGHT * 1.5), of_dot.animate.shift(RIGHT * 1.5), FadeIn(hl2), i4.animate.set_opacity(1), run_time=1.5)\n        G = VGroup(area, of_arrow_shadow, numberplane, labels[0])\n        i1.line.put_start_and_end_on(i1.line.get_start() + UP * 5, i1.line.get_end() + DOWN * 5)\n        i3.line.put_start_and_end_on(i3.line.get_start() + (UP + LEFT) * 5, i3.line.get_end() + (DOWN + RIGHT) * 5)\n        p1.shift(DOWN * us1)\n        p2.shift(DOWN * us1)\n        self.play(G.animate.shift(DOWN * us1), p0.animate.shift(DOWN * us1), FadeIn(p1, shift=DOWN * us1), of_arrow_shadow_2.animate.shift(UP * (2 - us1)), of_dot.animate.shift(UP * (2 - us1)), Transform(hl, CreateHighlight(ineqs[0][21:])), i2.animate.set_opacity(0).shift(DOWN * us1), i3.animate.set_opacity(1).shift(DOWN * us1), run_time=1.5)\n        i2.shift(UP * us1)\n        p2.shift(DOWN * us2)\n        i5.shift(DOWN * us1)\n        self.play(G.animate.shift(DOWN * us2), FadeIn(p2, shift=DOWN * us2), p0.animate.shift(DOWN * us2), p1.animate.shift(DOWN * us2), of_arrow_shadow_2.animate.shift(UP * (2 - us2) + LEFT * 2), of_dot.animate.shift(UP * (2 - us2) + LEFT * 2), Transform(hl2, CreateHighlight(ineqs[0][14:21])), i4.animate.set_opacity(0).shift(DOWN * us2), i5.animate.set_opacity(1).shift(DOWN * us2), i3.animate.shift(DOWN * us2), run_time=1.5)\n        val.remove_updater(value_updater)\n        self.play(AnimationGroup(MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1), val.animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE), lag_ratio=0.25))\n        self.play(G.animate.shift(UP * (us1 + us2)), i5.animate.set_opacity(0).shift(UP * (us1 + us2)), i3.animate.set_opacity(0).shift(UP * (us1 + us2)), FadeOut(hl, hl2), FadeOut(val, of_arrow_shadow_2, of_dot, p0, p1, p2, shift=UP * (us1 + us2)))\n        ineqs3 = ComplexTex('$$\\\\begin{aligned}\\n        x_1, x_2, s_1, s_2, s_3  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_1 \\\\phantom{{}+ x_2} + s_1 \\\\phantom{{} + s_2 + s_3} &= 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_2 \\\\phantom{{} + s_1} + s_2 \\\\phantom{{} + s_3} &= 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_1 + x_2 \\\\phantom{{} + s_1 + s_2} + s_3 &= 5\\\\,000\\n                \\\\end{aligned}$$').move_to(ineqs).set_z_index(ineqs.get_z_index())\n        var3 = ComplexTex('variables: $x_1, x_2, s_1, s_2, s_3$').move_to(var).set_z_index(var.get_z_index())\n        space = 2.5\n        guide4 = -guide2.get_center() + RIGHT * (space / 2)\n        of3 = of.copy()\n        exp3 = exp2.copy().move_to(exp).set_z_index(exp.get_z_index())\n        theory_group_two = VGroup(of3, exp3, ineqs3, var3).move_to(guide4)\n        i1.shift(RIGHT * space / 2)\n        i2.shift(RIGHT * space / 2)\n        i3.shift(RIGHT * space / 2)\n        i4.shift(RIGHT * space / 2)\n        i5.shift(RIGHT * space / 2)\n        of_arrow_shadow_2.shift(RIGHT * space / 2)\n        of_dot.shift(RIGHT * space / 2)\n        VGroup(of3, exp3).align_to(of, UP)\n        VGroup(var3).align_to(var, UP)\n        VGroup(ineqs3).align_to(ineqs, UP)\n        self.remove(rect3)\n        rect_large.flip().set_height(rect3.get_height()).move_to(rect3).align_to(rect3, RIGHT).set_z_index(rect3.get_z_index())\n        self.add(rect_large)\n        var3[0][16:16 + 2].set_color(ORANGE)\n        var3[0][19:19 + 2].set_color(ORANGE)\n        var3[0][22:22 + 2].set_color(ORANGE)\n        ineqs3[0][6:6 + 2].set_color(ORANGE)\n        ineqs3[0][9:9 + 2].set_color(ORANGE)\n        ineqs3[0][12:12 + 2].set_color(ORANGE)\n        ineqs3[0][19:19 + 2].set_color(ORANGE)\n        ineqs3[0][29:29 + 2].set_color(ORANGE)\n        ineqs3[0][42:42 + 2].set_color(ORANGE)\n        slack = Tex('slack').scale(0.7).set_color(ORANGE).next_to(VGroup(var3[0][16:16 + 2], var3[0][22:22 + 2]), UP, buff=0.25).set_z_index(100000000000)\n        self.play(rect_large.animate.shift(RIGHT * space), VGroup(area, of_arrow_shadow, numberplane, sr, labels[1]).animate.shift(RIGHT * space / 2), Transform(exp, exp3), Transform(of, of3), AnimationGroup(Transform(var[0][:15], var3[0][:15]), AnimationGroup(FadeIn(var3[0][15:]), FadeIn(slack)), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][:5], ineqs3[0][:5]), Transform(ineqs[0][5:5 + 2], ineqs3[0][14:14 + 2])), FadeIn(ineqs3[0][5:5 + 9]), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][7:7 + 2], ineqs3[0][16:16 + 2]), Transform(ineqs[0][9:9 + 5], ineqs3[0][21:21 + 5])), FadeIn(ineqs3[0][18:18 + 3]), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][14:14 + 2], ineqs3[0][26:26 + 2]), Transform(ineqs[0][16:16 + 5], ineqs3[0][31:31 + 5])), FadeIn(ineqs3[0][28:28 + 3]), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][21:21 + 5], ineqs3[0][36:36 + 5]), Transform(ineqs[0][26:], ineqs3[0][44:])), FadeIn(ineqs3[0][41:41 + 3]), lag_ratio=0.5))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp3, ineqs3, var3, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, slack)\n        hl = CreateHighlight(VGroup(ineqs3[0][21], ineqs3[0][31], ineqs3[0][44]))\n        a = Tex('$0$')\n        a.add(Tex('$=$').scale(0.65).rotate(PI / 2).next_to(a, UP, buff=0.1))\n        a.set_color(YELLOW).set_z_index(1000000000).next_to(var3[0][-8:-8 + 2], DOWN, buff=0.1).set_color(WHITE)\n        b = a.copy().next_to(var3[0][-2:], DOWN, buff=0.1).set_color(WHITE)\n        of_arrow_shadow_2.shift(UP * -2 + LEFT * -2)\n        of_dot.shift(UP * -2 + LEFT * -2 + UP * (us1 + us2))\n        val = Tex('$(3\\\\,000, 2\\\\,000)$').scale(0.6).next_to(of_dot, UP).set_z_index(10000000000)\n        val.add(CreateSR(val))\n        self.play(FadeIn(val), FadeIn(of_dot), MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1), i4.animate.set_opacity(1), i3.animate.set_opacity(1))\n        hl1 = CreateHighlight(ineqs3[0][16:26])\n        hl2 = CreateHighlight(ineqs3[0][36:49])\n        self.play(FadeIn(hl1), FadeIn(hl2), var3[0][16:16 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), var3[0][22:22 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), var3[0][18:18 + 1].animate.set_opacity(BIG_OPACITY), var3[0][21:21 + 1].animate.set_opacity(BIG_OPACITY), ineqs3[0][6:6 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), ineqs3[0][12:12 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), ineqs3[0][8:8 + 1].animate.set_opacity(BIG_OPACITY), ineqs3[0][11:11 + 1].animate.set_opacity(BIG_OPACITY), ineqs3[0][18:18 + 1].animate.set_opacity(BIGGER_OPACITY), ineqs3[0][19:19 + 2].animate.set_color(YELLOW).set_opacity(BIGGER_OPACITY), ineqs3[0][41:41 + 1].animate.set_opacity(BIGGER_OPACITY), ineqs3[0][42:42 + 2].animate.set_color(YELLOW).set_opacity(BIGGER_OPACITY))\n        self.play(FadeOut(hl1), FadeOut(hl2), FadeOut(of_dot), FadeOut(val), i4.animate.set_opacity(0), i3.animate.set_opacity(0), var3[0][16:16 + 2].animate.set_color(ORANGE).set_opacity(1), var3[0][22:22 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][6:6 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][12:12 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][18:18 + 1].animate.set_opacity(1), ineqs3[0][19:19 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][41:41 + 1].animate.set_opacity(1), ineqs3[0][42:42 + 2].animate.set_color(ORANGE).set_opacity(1), var3[0][18:18 + 1].animate.set_opacity(1), var3[0][21:21 + 1].animate.set_opacity(1), ineqs3[0][8:8 + 1].animate.set_opacity(1), ineqs3[0][11:11 + 1].animate.set_opacity(1))\n        of_arrow_shadow_2 = of_arrow_shadow.copy().set_color(BLUE).set_z_index(fade_rect.get_z_index() + 1)\n        of_dot = Dot().scale(OPTIMUM_DOT_SCALE).set_color(BLUE).move_to(of_arrow_shadow_2.get_start()).set_z_index(of_arrow_shadow_2.get_z_index())\n        vars_buff = 0.25\n        nonbas_vars = VGroup(var3[0][10:10 + 2].copy().set_color(YELLOW), var3[0][13:13 + 2].copy().set_color(YELLOW)).arrange(buff=vars_buff)\n        bas_vars = VGroup(var3[0][16:16 + 2].copy().set_color(ORANGE), var3[0][19:19 + 2].copy().set_color(ORANGE), var3[0][22:22 + 2].copy().set_color(ORANGE)).arrange(buff=vars_buff)\n        VGroup(nonbas_vars, bas_vars).arrange(buff=1.5).move_to(var3).align_to(var3, DOWN)\n        nonbasic = Tex('tight').scale(0.7).next_to(nonbas_vars, UP, buff=0.25).set_z_index(rect_large.get_z_index() + 1).set_opacity(0)\n        basic = Tex('loose').scale(0.7).next_to(bas_vars, UP, buff=0.25).set_z_index(rect_large.get_z_index() + 1).set_opacity(0)\n        nonbasic.align_to(basic, UP)\n        nb = Tex('non-basic').scale(0.7).set_z_index(rect_large.get_z_index() + 1).set_opacity(0).move_to(nonbasic).align_to(nonbasic, UP)\n        bb = Tex('basic').scale(0.7).set_z_index(rect_large.get_z_index() + 1).set_opacity(0).move_to(basic).align_to(nonbasic, UP)\n        self.play(FadeIn(of_dot), FadeIn(of_arrow_shadow_2), MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1))\n        self.play(Succession(Wait(0.5), AnimationGroup(ineqs3[0][0:0 + 2].animate.set_color(YELLOW), ineqs3[0][3:3 + 2].animate.set_color(YELLOW), ineqs3[0][16:16 + 2].animate.set_color(YELLOW), ineqs3[0][26:26 + 2].animate.set_color(YELLOW), ineqs3[0][36:36 + 2].animate.set_color(YELLOW), ineqs3[0][39:39 + 2].animate.set_color(YELLOW), exp3[0][6:6 + 2].animate.set_color(YELLOW), exp3[0][12:12 + 2].animate.set_color(YELLOW), i1.animate.set_opacity(1), i2.animate.set_opacity(1))), AnimationGroup(AnimationGroup(FadeOut(var3[0][:10]), FadeOut(var3[0][12]), FadeOut(var3[0][15]), FadeOut(var3[0][18]), FadeOut(var3[0][21]), FadeOut(slack)), AnimationGroup(Transform(var3[0][10:10 + 2], nonbas_vars[0]), Transform(var3[0][13:13 + 2], nonbas_vars[1]), Transform(var3[0][16:16 + 2], bas_vars[0]), Transform(var3[0][19:19 + 2], bas_vars[1]), Transform(var3[0][22:22 + 2], bas_vars[2])), AnimationGroup(basic.animate.set_opacity(MED_OPACITY), nonbasic.animate.set_opacity(MED_OPACITY)), lag_ratio=0.5))\n        nb.set_opacity(MED_OPACITY)\n        bb.set_opacity(MED_OPACITY)\n        f = 0.3\n        self.play(FadeIn(nb, shift=DOWN * f), FadeOut(nonbasic, shift=DOWN * f))\n        self.play(FadeIn(bb, shift=DOWN * f), FadeOut(basic, shift=DOWN * f))\n        self.play(FadeOut(nb, shift=UP * f), FadeIn(nonbasic, shift=UP * f), FadeOut(bb, shift=UP * f), FadeIn(basic, shift=UP * f))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp3, ineqs3, bas_vars, nonbas_vars, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i1, i2)\n        self.play(AnimationGroup(FadeOut(ineqs3[0][:16]), ineqs3[0][16:].animate.move_to(ineqs3), lag_ratio=0.25))\n        ineqs4 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 3\\\\,000 - x_1 \\\\\\\\[-0.2em]\\n              s_2 &= 4\\\\,000 \\\\phantom{{} - x_1} - x_2 \\\\\\\\[-0.2em]\\n              s_3 &= 5\\\\,000 - x_1 - x_2\\n                \\\\end{aligned}$$').move_to(ineqs3).align_to(ineqs3, DOWN).set_z_index(ineqs3.get_z_index())\n        ineqs4[0][0:0 + 2].set_color(ORANGE)\n        ineqs4[0][10:10 + 2].set_color(ORANGE)\n        ineqs4[0][20:20 + 2].set_color(ORANGE)\n        ineqs4[0][8:8 + 2].set_color(YELLOW)\n        ineqs4[0][18:18 + 2].set_color(YELLOW)\n        ineqs4[0][28:28 + 2].set_color(YELLOW)\n        ineqs4[0][31:31 + 2].set_color(YELLOW)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(ineqs3[0][18]), FadeOut(ineqs3[0][28]), FadeOut(ineqs3[0][41])), AnimationGroup(Transform(ineqs3[0][19:19 + 2 + 5], ineqs4[0][0:0 + 2 + 5]), Transform(ineqs3[0][29:29 + 2 + 5], ineqs4[0][10:10 + 2 + 5]), Transform(ineqs3[0][42:42 + 2 + 5], ineqs4[0][20:20 + 2 + 5]), Transform(ineqs3[0][16:16 + 2], ineqs4[0][8:8 + 2]), Transform(ineqs3[0][26:26 + 2], ineqs4[0][18:18 + 2]), Transform(ineqs3[0][36:36 + 5], ineqs4[0][28:28 + 5])), AnimationGroup(FadeIn(ineqs4[0][7]), FadeIn(ineqs4[0][17]), FadeIn(ineqs4[0][27])), lag_ratio=0.5), run_time=2)\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp3, ineqs4, bas_vars, nonbas_vars, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i1, i2)\n        hl = CreateHighlight(VGroup(ineqs4[0][0], ineqs4[0][-12])).set_color(BLUE)\n        hlother = CreateHighlight(bas_vars).set_color(BLUE)\n        self.play(FadeIn(hl, hlother))\n        a.next_to(nonbas_vars[0], DOWN, buff=0.1)\n        b.next_to(nonbas_vars[1], DOWN, buff=0.1)\n        hl1 = CreateHighlight(VGroup(nonbas_vars[0], a)).set_color(BLUE)\n        hl2 = CreateHighlight(VGroup(nonbas_vars[1], b)).set_color(BLUE)\n        hlof = CreateHighlight(exp3[0][3:3 + 11]).set_color(BLUE)\n        zero = Tex('$$0$$').set_z_index(exp3.get_z_index()).move_to(exp3[0][3:3 + 11])\n        self.play(AnimationGroup(AnimationGroup(FadeOut(hlother), FadeIn(zero), nonbas_vars[0].animate.set_opacity(BIG_OPACITY), nonbas_vars[1].animate.set_opacity(BIG_OPACITY), exp3[0][3:3 + 11].animate.set_opacity(BIG_OPACITY / 2), exp3[0][8].animate.set_opacity(0), ineqs4[0][7:7 + 3].animate.set_opacity(BIG_OPACITY), ineqs4[0][17:17 + 3].animate.set_opacity(BIG_OPACITY), ineqs4[0][27:27 + 3].animate.set_opacity(BIG_OPACITY), ineqs4[0][30:30 + 3].animate.set_opacity(BIG_OPACITY)), AnimationGroup(FadeIn(hlof), Transform(hl, CreateHighlight(VGroup(ineqs4[0][0], ineqs4[0][3], ineqs4[0][-7], ineqs4[0][-12])).set_color(BLUE))), lag_ratio=0))\n        self.play(FadeOut(hlof, hl, zero), exp3[0][3:3 + 11].animate.set_opacity(1), ineqs4[0][7:7 + 3].animate.set_opacity(1), ineqs4[0][17:17 + 3].animate.set_opacity(1), ineqs4[0][27:27 + 3].animate.set_opacity(1), ineqs4[0][30:30 + 3].animate.set_opacity(1), nonbas_vars[0].animate.set_opacity(1), nonbas_vars[1].animate.set_opacity(1))\n        dpivot = Tex(\"\\\\textit{Dantzig's pivot rule}\").set_width(sm[0].get_width()).next_to(sm, DOWN, buff=0).set_z_index(10000000000)\n        self.play(AnimationGroup(Transform(sm[1], CreateSR(VGroup(sm[0], dpivot), buff=0.17)), FadeIn(dpivot), lag_ratio=0.5))\n        hl1 = CreateHighlight(exp3[0][3:3 + 5]).set_color(GREEN)\n        hl2 = CreateHighlight(exp3[0][9:9 + 5]).set_color(GREEN)\n        offset = -0.05\n        dashed_x = Arrow(of_dot.get_center(), [of_arrow_shadow_2.get_end()[0] - offset, of_dot.get_center()[1], 0], stroke_width=LINE_STROKE + 0.01, buff=0).set_color(GREEN).set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        dashed_y = Arrow(of_dot.get_center(), [of_dot.get_center()[0], of_arrow_shadow_2.get_end()[1] - offset, 0], buff=0, stroke_width=LINE_STROKE + 0.01).set_color(GREEN).set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        a = of_arrow_shadow_2.copy().set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        b = of_arrow_shadow_2.copy().set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        self.play(FadeIn(hl1), FadeIn(hl2))\n        self.play(Transform(a, dashed_x), Transform(b, dashed_y), run_time=1)\n        self.remove(a, b)\n        self.add(dashed_x, dashed_y)\n        self.play(FadeOut(dashed_x), FadeOut(hl1))\n        b = VGroup(nonbas_vars[1].copy(), bas_vars[0].copy(), bas_vars[1].copy(), bas_vars[2].copy())\n        b.arrange(buff=vars_buff)\n        b.move_to(bas_vars)\n        b[0].set_color(WHITE)\n        nb = VGroup(nonbas_vars[0].copy())\n        nb.move_to(nonbas_vars)\n        downshift = 1\n        self.play(AnimationGroup(FadeOut(dashed_y, shift=UP + DOWN * downshift), of_dot.animate.shift(UP + DOWN * downshift), of_arrow_shadow_2.animate.shift(UP + DOWN * downshift).set_opacity(1), i2.animate.set_opacity(0).shift(DOWN * downshift), of_arrow_shadow.animate.shift(DOWN * downshift), labels[0].animate.shift(DOWN * downshift), numberplane.animate.shift(DOWN * downshift), area.animate.shift(DOWN * downshift), FadeOut(hl2), Transform(nonbas_vars[0], nb[0]), Transform(nonbas_vars[1], b[0]), Transform(bas_vars[0], b[1]), Transform(bas_vars[1], b[2]), Transform(bas_vars[2], b[3]), ineqs4[0][18:18 + 2].animate.set_color(WHITE), ineqs4[0][31:31 + 2].animate.set_color(WHITE), exp3[0][-2:].animate.set_color(WHITE)))\n        self.remove(nonbas_vars[0], nonbas_vars[1])\n        self.remove(bas_vars[0], bas_vars[1], bas_vars[2])\n        self.add(b, nb)\n        nonbas_vars = nb\n        bas_vars = b\n        POSSIBLE_COLOR = GRAY\n        i3.set_color(POSSIBLE_COLOR).shift(DOWN * downshift)\n        i5.set_color(POSSIBLE_COLOR).shift(DOWN * downshift)\n        inter = intersection(line(i3.line.get_start(), i3.line.get_end()), line(i1.line.get_start(), i1.line.get_end()))\n        idot = area.dots[0].copy().move_to([*inter, 0])\n        inter = intersection(line(i5.line.get_start(), i5.line.get_end()), line(i1.line.get_start(), i1.line.get_end()))\n        idot_correct = area.dots[0].copy().move_to([*inter, 0]).set_z_index(area.dots[0].get_z_index() + 1)\n        hls2 = CreateHighlight(ineqs4[0][10:10 + 2]).set_color(POSSIBLE_COLOR)\n        hls3 = CreateHighlight(ineqs4[0][20:20 + 2]).set_color(POSSIBLE_COLOR)\n        hl1 = CreateHighlight(ineqs4[0][13:13 + 4]).set_color(POSSIBLE_COLOR)\n        hl2 = CreateHighlight(ineqs4[0][17:17 + 3]).set_color(POSSIBLE_COLOR)\n        hl3 = CreateHighlight(ineqs4[0][23:23 + 4]).set_color(POSSIBLE_COLOR)\n        hl4 = CreateHighlight(ineqs4[0][30:30 + 3]).set_color(POSSIBLE_COLOR)\n        self.play(AnimationGroup(FadeIn(hl2), FadeIn(hl4), lag_ratio=0.07))\n        self.play(AnimationGroup(AnimationGroup(ineqs4[0][10:10 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[2].animate.set_color(POSSIBLE_COLOR), i3.animate.set_opacity(1), FadeIn(hls2)), AnimationGroup(ineqs4[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[3].animate.set_color(POSSIBLE_COLOR), i5.animate.set_opacity(1), FadeIn(idot, hls3)), lag_ratio=0.07))\n        self.add(idot_correct)\n        G = VGroup(i5, i3, i1, labels[0], area, numberplane, of_arrow_shadow, of_dot, of_arrow_shadow_2, idot, idot_correct)\n        G.save_state()\n        labels[1].save_state()\n        self.play(G.animate.scale(1.75, about_point=idot_correct.get_center() + UP * 3).shift(RIGHT * 0.8), labels[1].animate.scale(1.75, about_point=idot_correct.get_center() + UP * 3).shift(RIGHT * 0.8))\n        self.play(ineqs4[0][10:10 + 2].animate.set_color(GREEN), bas_vars[2].animate.set_color(GREEN), i5.line.animate.set_color(GREEN).set_stroke_width(LINE_STROKE + 3), hls2.animate.set_color(GREEN), idot_correct.animate.set_color(GREEN), hl2.animate.set_color(GREEN), ineqs4[0][20:20 + 2].animate.set_color(RED), bas_vars[3].animate.set_color(RED), i3.line.animate.set_color(RED).set_stroke_width(LINE_STROKE + 3), hls3.animate.set_color(RED), idot.animate.set_color(RED), hl4.animate.set_color(RED))\n        correct = Tex('valid', color=GREEN).scale(0.85).set_z_index(idot.get_z_index()).next_to(idot_correct, LEFT + UP, buff=0.1)\n        oob = Tex('out of bounds', color=RED).scale(0.85).set_z_index(idot.get_z_index()).next_to(idot, RIGHT + UP, buff=0.1)\n        self.play(AnimationGroup(AnimationGroup(MyFlash(idot_correct, color=GREEN, z_index=idot_correct.get_z_index() + 1), FadeIn(correct)), AnimationGroup(MyFlash(idot, color=RED, z_index=idot_correct.get_z_index() + 1), FadeIn(oob)), lag_ratio=0.75))\n        self.play(FadeOut(correct), FadeOut(oob))\n        self.play(G.animate.restore(), labels[1].animate.restore(), ineqs4[0][10:10 + 2].animate.set_color(POSSIBLE_COLOR), ineqs4[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[2].animate.set_color(POSSIBLE_COLOR), bas_vars[3].animate.set_color(POSSIBLE_COLOR), hls2.animate.set_color(POSSIBLE_COLOR), hls3.animate.set_color(POSSIBLE_COLOR), hl2.animate.set_color(POSSIBLE_COLOR), hl4.animate.set_color(POSSIBLE_COLOR))\n        t1 = Tex('${} - 1\\\\,000$').set_z_index(ineqs4.get_z_index() + 1)\n        t1[0][1:].set_color(BLUE)\n        align_object_by_coords(t1, t1[0][0].get_center(), ineqs4[0][17].get_center())\n        t2 = Tex('${} - 1\\\\,000$').set_z_index(ineqs4.get_z_index() + 1)\n        t2[0][1:].set_color(BLUE)\n        align_object_by_coords(t2, t2[0][0].get_center(), ineqs4[0][30].get_center())\n        tmp1 = of_dot.copy()\n        tmp2 = of_dot.copy()\n        (ineqs4[0][18:18 + 2].set_opacity(0),)\n        (ineqs4[0][31:38 + 2].set_opacity(0),)\n        a = ineqs4[0][18:18 + 2].copy().set_opacity(1)\n        b = ineqs4[0][31:38 + 2].copy().set_opacity(1)\n        a.save_state()\n        b.save_state()\n        self.play(AnimationGroup(AnimationGroup(FadeOut(hl2), FadeOut(hl4)), AnimationGroup(Transform(tmp1, t1[0][1:]), Transform(tmp2, t2[0][1:]), a.animate.next_to(t1, RIGHT + DOWN, buff=0.015).shift(UP * 0.13).set_opacity(0.4).scale(0.7), b.animate.next_to(t2, RIGHT + DOWN, buff=0.015).shift(UP * 0.13).set_opacity(0.4).scale(0.7)), lag_ratio=0.5))\n        self.remove(tmp1, tmp2)\n        self.add(t1, t2)\n        ineqs4[0][17].set_opacity(0)\n        ineqs4[0][30].set_opacity(0)\n\n        def tupdater(obj, dt):\n            val = round((of_dot.get_center() - of_arrow_shadow.get_start())[1] * 1000)\n            tt1 = Tex('${} - ' + str(val)[0] + '\\\\,' + str(val)[1:] + '$').set_z_index(ineqs4.get_z_index() + 1)\n            tt1[0][1:].set_color(BLUE)\n            align_object_by_coords(tt1, tt1[0][0].get_center(), ineqs4[0][17].get_center())\n            obj.become(tt1)\n\n        def tupdater2(obj, dt):\n            val = round((of_dot.get_center() - of_arrow_shadow.get_start())[1] * 1000)\n            tt1 = Tex('${} - ' + str(val)[0] + '\\\\,' + str(val)[1:] + '$').set_z_index(ineqs4.get_z_index() + 1)\n            tt1[0][1:].set_color(BLUE)\n            align_object_by_coords(tt1, tt1[0][0].get_center(), ineqs4[0][30].get_center())\n            obj.become(tt1)\n        t1.add_updater(tupdater)\n        t2.add_updater(tupdater2)\n        downshift = 1.5\n        self.play(of_dot.animate.shift(UP * (3 - downshift)), of_arrow_shadow_2.animate.shift(UP * (3 - downshift)), VGroup(i3, i5, of_arrow_shadow, area, numberplane, labels[0], idot, idot_correct).animate.shift(DOWN * downshift), run_time=3)\n        t1.remove_updater(tupdater)\n        t2.remove_updater(tupdater2)\n        tupdater(t1, 0)\n        tupdater2(t2, 0)\n        self.remove(idot_correct)\n        hlll = CreateHighlight(VGroup(ineqs4[0][13:13 + 4], t1)).set_color(YELLOW)\n        self.play(bas_vars[2].animate.set_color(YELLOW), ineqs4[0][10:10 + 2].animate.set_color(YELLOW), ineqs4[0][20:20 + 2].animate.set_color(ORANGE), i5.animate.set_color(YELLOW), FadeIn(hlll), FadeOut(i3, idot), FadeOut(hls2, hls3))\n        t1.add_updater(tupdater)\n        t2.add_updater(tupdater2)\n        self.play(of_dot.animate.shift(UP * 0.5).set_color(RED), of_arrow_shadow_2.animate.shift(UP * 0.5).set_color(RED), hlll.animate.set_color(RED), run_time=1)\n        hls2.set_color(RED)\n        self.play(FadeIn(hls2))\n        self.play(of_dot.animate.shift(DOWN * 0.5).set_color(BLUE), of_arrow_shadow_2.animate.shift(DOWN * 0.5).set_color(BLUE), hlll.animate.set_color(YELLOW), FadeOut(hls2), run_time=1)\n        hls2.set_color(POSSIBLE_COLOR)\n        t1.remove_updater(tupdater)\n        t2.remove_updater(tupdater2)\n        self.play(bas_vars[2].animate.set_color(POSSIBLE_COLOR), ineqs4[0][10:10 + 2].animate.set_color(POSSIBLE_COLOR), ineqs4[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), i5.animate.set_color(POSSIBLE_COLOR), FadeOut(hlll), FadeIn(i3, idot), FadeIn(hls2, hls3), FadeOut(t1[0][1:]), FadeOut(t2[0][1:]), Succession(Wait(0.5), AnimationGroup(AnimationGroup(Transform(a, ineqs4[0][18:18 + 2].copy().set_opacity(1)), Transform(b, ineqs4[0][31:31 + 2].copy().set_opacity(1))), AnimationGroup(FadeIn(hl2), FadeIn(hl4)), lag_ratio=0.5)))\n        self.remove(t1, t2)\n        ineqs4[0][17:17 + 1].set_opacity(1)\n        ineqs4[0][30:30 + 1].set_opacity(1)\n        ineqs4[0][18:18 + 2].set_opacity(1)\n        ineqs4[0][31:31 + 2].set_opacity(1)\n        self.remove(a, b)\n        four = Tex('$-4\\\\,000$').move_to(hl1).align_to(ineqs4, RIGHT).shift(RIGHT * 0.5).set_z_index(ineqs4.get_z_index() + 1)\n        five = Tex('$-5\\\\,000$').move_to(hl3).align_to(ineqs4, RIGHT).shift(RIGHT * 0.5).set_z_index(ineqs4.get_z_index() + 1)\n        ff = VGroup(four, five).scale(0.9).arrange(RIGHT, buff=0.6).next_to(ineqs4, UP, buff=0.5)\n        gt = Tex('$>$', stroke_width=1.5).scale(0.5).move_to(VGroup(four, five)).set_z_index(ineqs4.get_z_index() + 1)\n        a = ineqs4[0][13:13 + 4].copy()\n        b = ineqs4[0][23:23 + 4].copy()\n        am = ineqs4[0][17:17 + 1].copy()\n        bm = ineqs4[0][30:30 + 1].copy()\n        ah = CreateHighlight(four).set_color(POSSIBLE_COLOR)\n        bh = CreateHighlight(five).set_color(POSSIBLE_COLOR)\n        self.play(AnimationGroup(AnimationGroup(Transform(a, four[0][1:]), Transform(am, four[0][0]), FadeIn(ah)), AnimationGroup(Transform(b, five[0][1:]), Transform(bm, five[0][0]), FadeIn(bh)), lag_ratio=0.25))\n        self.remove(a, am, b, bm)\n        self.add(four, five)\n        self.play(FadeIn(gt), ah.animate.set_color(GREEN), bh.animate.set_color(RED), ineqs4[0][10:10 + 2].animate.set_color(GREEN), bas_vars[2].animate.set_color(GREEN), i5.line.animate.set_color(GREEN), hls2.animate.set_color(GREEN), hl2.animate.set_color(GREEN), ineqs4[0][20:20 + 2].animate.set_color(RED), bas_vars[3].animate.set_color(RED), i3.line.animate.set_color(RED), hls3.animate.set_color(RED), idot.animate.set_color(RED), hl4.animate.set_color(RED))\n        nb = VGroup(nonbas_vars[0].copy(), bas_vars[2].copy().set_color(YELLOW))\n        nb.arrange(buff=vars_buff)\n        nb.move_to(nonbas_vars)\n        b = VGroup(bas_vars[0].copy(), bas_vars[1].copy(), bas_vars[3].copy().set_color(ORANGE))\n        b.arrange(buff=vars_buff)\n        b.move_to(bas_vars)\n        self.play(FadeOut(five, bh, hl4, hls3), FadeOut(i3), FadeOut(gt), FadeOut(idot), ineqs4[0][20:20 + 2].animate.set_color(ORANGE))\n        self.play(Transform(nonbas_vars[0], nb[0]), Transform(bas_vars[2], nb[1]), Transform(bas_vars[0], b[0]), Transform(bas_vars[1], b[1]), Transform(bas_vars[3], b[2]), ineqs4[0][10:10 + 2].animate.set_color(YELLOW), FadeOut(four, ah, hl2, hls2), i5.animate.set_color(YELLOW))\n        hlp1 = CreateHighlight(ineqs4[0][10:10 + 2]).set_color(POSSIBLE_COLOR).set_color(RED)\n        hlp2 = hl2.set_color(RED)\n        hlp3 = hl4.set_color(RED)\n        hlp4 = CreateHighlight(exp3[0][-5:]).set_color(POSSIBLE_COLOR).set_color(RED)\n        t1 = Tex('tight').scale(0.6).next_to(hlp1, LEFT).set_z_index(hlp1.get_z_index()).set_color(RED)\n        l1 = Tex('loose').scale(0.6).next_to(hlp2, RIGHT).set_z_index(hlp2.get_z_index()).set_color(RED)\n        l2 = Tex('loose').scale(0.6).next_to(hlp3, RIGHT).set_z_index(hlp3.get_z_index()).set_color(RED)\n        l3 = Tex('loose').scale(0.6).next_to(hlp4, RIGHT).set_z_index(hlp4.get_z_index()).set_color(RED)\n        self.play(FadeIn(hlp1, hlp2, hlp3, hlp4), FadeIn(t1, shift=LEFT * 0.25), FadeIn(l1, shift=RIGHT * 0.25), FadeIn(l2, shift=RIGHT * 0.25), FadeIn(l3, shift=RIGHT * 0.25))\n        ineqs5 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 3\\\\,000 - x_1 \\\\\\\\[-0.2em]\\n              x_2 &= 4\\\\,000 \\\\phantom{{} - x_1} - s_2 \\\\\\\\[-0.2em]\\n              s_3 &= 5\\\\,000 - x_1 - (4\\\\,000 - s_2)\\n                \\\\end{aligned}$$').set_z_index(ineqs4.get_z_index())\n        align_object_by_coords(ineqs5, ineqs5[0][0].get_center(), ineqs4[0][0].get_center())\n        ineqs5[0][0:0 + 2].set_color(ORANGE)\n        ineqs5[0][20:20 + 2].set_color(ORANGE)\n        ineqs5[0][8:8 + 2].set_color(YELLOW)\n        ineqs5[0][18:18 + 2].set_color(YELLOW)\n        ineqs5[0][28:28 + 2].set_color(YELLOW)\n        ineqs5[0][37:37 + 2].set_color(YELLOW)\n        ineqs6 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 3\\\\,000 - x_1 \\\\\\\\[-0.2em]\\n              x_2 &= 4\\\\,000 \\\\phantom{{} - x_1} - s_2 \\\\\\\\[-0.2em]\\n              s_3 &= 1\\\\,000 - x_1 + s_2\\n                \\\\end{aligned}$$').set_z_index(ineqs4.get_z_index())\n        align_object_by_coords(ineqs6, ineqs6[0][0].get_center(), ineqs4[0][0].get_center())\n        ineqs6[0][0:0 + 2].set_color(ORANGE)\n        ineqs6[0][20:20 + 2].set_color(ORANGE)\n        ineqs6[0][8:8 + 2].set_color(YELLOW)\n        ineqs6[0][18:18 + 2].set_color(YELLOW)\n        ineqs6[0][28:28 + 2].set_color(YELLOW)\n        ineqs6[0][31:31 + 2].set_color(YELLOW)\n        self.play(AnimationGroup(FadeOut(hlp1, hlp2), FadeOut(t1, l1), AnimationGroup(ineqs4[0][18:18 + 2].animate.move_to(ineqs5[0][10:10 + 2]), ineqs4[0][10:10 + 2].animate.move_to(ineqs5[0][18:18 + 2])), lag_ratio=0.5))\n        exp4 = Tex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_1 + ' + str(OF_INITIAL[1]) + ' (4\\\\,000 - s_2)$$').set_z_index(exp3.get_z_index())\n        exp4[0][6:6 + 2].set_color(YELLOW)\n        align_object_by_coords(exp4, exp4[0][0].get_center(), exp3[0][0].get_center())\n        exp4[0][18:18 + 2].set_color(YELLOW)\n        exp5 = Tex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_1 - ' + str(OF_INITIAL[1]) + ' s_2 + 6\\\\,800$$').set_z_index(exp3.get_z_index())\n        exp5[0][6:6 + 2].set_color(YELLOW)\n        exp5[0][12:12 + 2].set_color(YELLOW)\n        exp5.move_to(exp3)\n        exp5.shift(UP * (exp3[0][0].get_center() - exp5[0][0].get_center())[1])\n        offset = RIGHT * 0.65\n        self.play(AnimationGroup(AnimationGroup(AnimationGroup(FadeOut(hlp3), FadeOut(l2), FadeOut(ineqs4[0][31:31 + 2])), AnimationGroup(Transform(ineqs4[0][13:13 + 5].copy(), ineqs5[0][32:32 + 5]), Transform(ineqs4[0][10:10 + 2].copy(), ineqs5[0][37:37 + 2]), rect_large.animate.shift(offset), Group(area, of_arrow_shadow, numberplane, sr, labels[1], of_dot, of_arrow_shadow_2, i1).animate.shift(offset / 2), Group(sm, dpivot).animate.shift(offset / 4)), AnimationGroup(FadeIn(ineqs5[0][31]), FadeIn(ineqs5[0][39])), lag_ratio=0.5), AnimationGroup(AnimationGroup(FadeOut(hlp4), FadeOut(l3), FadeOut(exp3[0][-2:])), AnimationGroup(Transform(ineqs4[0][13:13 + 5].copy(), exp4[0][13:13 + 5]), Transform(ineqs4[0][10:10 + 2].copy(), exp4[0][18:18 + 2])), AnimationGroup(FadeIn(exp4[0][12]), FadeIn(exp4[0][20])), lag_ratio=0.5), lag_ratio=0.5))\n        nonbas_vars = nb\n        bas_vars = b\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp4, ineqs5, bas_vars, nonbas_vars, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i1, i5, dpivot)\n        self.play(AnimationGroup(AnimationGroup(AnimationGroup(FadeOut(ineqs5[0][30]), FadeOut(ineqs5[0][31]), FadeOut(ineqs5[0][39])), AnimationGroup(Transform(ineqs5[0][36:36 + 3], ineqs6[0][30:30 + 3]), AnimationGroup(ineqs5[0][32:32 + 4].animate.move_to(ineqs6[0][23:23 + 4]).set_opacity(0), Transform(ineqs5[0][23], ineqs6[0][23]), lag_ratio=0.1)), lag_ratio=0.5), AnimationGroup(AnimationGroup(FadeOut(exp4[0][12]), FadeOut(exp4[0][20]), FadeOut(exp4[0][8])), AnimationGroup(Transform(exp4[0][17], exp5[0][8]), Transform(exp4[0][18:18 + 2], exp5[0][12:12 + 2]), FadeTransform(exp4[0][13:13 + 4], exp5[0][15:15 + 4]), Transform(exp4[0][9:9 + 3], exp5[0][9:9 + 3]), Transform(exp4[0][:8], exp5[0][:8]), rect_large.animate.shift(-offset), Group(area, of_arrow_shadow, numberplane, sr, labels[1], of_dot, of_arrow_shadow_2, i1, trace).animate.shift(offset / 2 * -1), Group(sm, dpivot).animate.shift(-offset / 4)), AnimationGroup(FadeIn(exp5[0][14])), lag_ratio=0.5), lag_ratio=0.5))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp5, ineqs6, bas_vars, nonbas_vars, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i1, i5, dpivot)\n        hl1 = CreateHighlight(VGroup(ineqs6[0][0], ineqs6[0][3], ineqs6[0][10], ineqs6[0][21], ineqs6[0][26])).set_color(BLUE)\n        hl2 = CreateHighlight(exp5[0][-4:]).set_color(BLUE)\n        self.play(FadeIn(hl1, hl2), ineqs6[0][7:7 + 3].animate.set_opacity(BIG_OPACITY), ineqs6[0][17:17 + 3].animate.set_opacity(BIG_OPACITY), ineqs6[0][27:27 + 6].animate.set_opacity(BIG_OPACITY), exp5[0][3:3 + 12].animate.set_opacity(BIG_OPACITY), nonbas_vars.animate.set_opacity(BIG_OPACITY))\n        self.play(VGroup(exp5[0][-4:], hl2).animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        self.play(FadeOut(hl1, hl2), ineqs6[0][7:7 + 3].animate.set_opacity(1), ineqs6[0][17:17 + 3].animate.set_opacity(1), ineqs6[0][27:27 + 6].animate.set_opacity(1), exp5[0][3:3 + 12].animate.set_opacity(1), nonbas_vars.animate.set_opacity(1))\n        hl1 = CreateHighlight(exp5[0][3:3 + 5]).set_color(GREEN)\n        hl2 = CreateHighlight(exp5[0][9:9 + 5]).set_color(RED)\n        steps = ComplexTex(\"\\\\begin{enumerate}\\n                \\\\setlength{\\\\itemsep}{4pt}\\n                \\\\setlength{\\\\parskip}{0pt}\\n                \\\\item \\\\textbf{loosen variable} (Dantzig's rule)\\n                \\\\item \\\\textbf{tighten variable} (largest non-positive ratio)\\n                \\\\item \\\\textbf{fix equalities} (swap + substitute)\\n                \\\\end{enumerate}\")\n        rect_down = rect_large.copy().move_to(ORIGIN).rotate(PI / 2).align_to(ORIGIN, UP).shift(DOWN + RIGHT * 3.5).set_z_index(rect_large.get_z_index() - 0.0001).shift(DOWN * 0.7)\n        of_arrow_shadow.set_z_index(rect_down.get_z_index() - 1e-05)\n        g = VGroup(of_dot, of_arrow_shadow_2, i1, i5, area, numberplane, of_arrow_shadow)\n        rect_down.save_state()\n        rect_down.align_to(Dot().next_to(self.camera.frame, DOWN), UP)\n        self.add(rect_down)\n        self.play(rect_down.animate.restore(), g.animate.shift(UP * 0.5))\n        VGroup(i2, i3, i4).shift(UP * 0.5)\n        steps = ComplexTex(\"\\\\begin{enumerate}\\n                \\\\setlength{\\\\itemsep}{4pt}\\n                \\\\setlength{\\\\parskip}{0pt}\\n                \\\\item \\\\textbf{loosen} (Dantzig's rule)\\n                \\\\item \\\\textbf{tighten} (largest non-positive ratio)\\n                \\\\item \\\\textbf{fix} (swap + substitute)\\n                \\\\end{enumerate}\").scale(0.65).set_z_index(rect_down.get_z_index() + 1)\n        steps.next_to(rect_large, RIGHT, buff=0.5).align_to(rect_down, UP).shift(DOWN * 0.5)\n        self.play(FadeIn(steps[0][:23]))\n        self.play(FadeIn(steps[0][23:58]))\n        self.play(FadeIn(steps[0][58:]))\n        offset = -0.05\n        dashed_x = Arrow(of_dot.get_center(), [of_arrow_shadow_2.get_end()[0] - offset, of_dot.get_center()[1], 0], stroke_width=LINE_STROKE + 0.01, buff=0).set_color(GREEN).set_z_index(of_dot.get_z_index() - 1e-06)\n        dashed_y = Arrow(of_dot.get_center(), [of_dot.get_center()[0], of_arrow_shadow_2.get_end()[1] - offset, 0], buff=0, stroke_width=LINE_STROKE + 0.01).set_color(RED).set_z_index(of_dot.get_z_index() - 1e-06)\n        a = of_arrow_shadow_2.copy().set_z_index(of_dot.get_z_index() - 1e-06)\n        b = of_arrow_shadow_2.copy().set_z_index(of_dot.get_z_index() - 1e-06)\n        self.play(steps[0][23:58].animate.set_opacity(BIG_OPACITY), steps[0][58:].animate.set_opacity(BIG_OPACITY))\n        self.play(FadeIn(hl1), FadeIn(hl2))\n        self.play(Transform(a, dashed_x), Transform(b, dashed_y), run_time=1)\n        self.remove(a, b)\n        self.add(dashed_x, dashed_y)\n        self.play(FadeOut(dashed_y), FadeOut(hl2))\n        nb = VGroup(nonbas_vars[1].copy())\n        nb.move_to(nonbas_vars)\n        b = VGroup(nonbas_vars[0].copy().set_color(WHITE), bas_vars[0].copy(), bas_vars[1].copy(), bas_vars[2].copy())\n        b.arrange(buff=vars_buff)\n        b.move_to(bas_vars)\n        b[0].set_color(WHITE)\n        self.play(Transform(nonbas_vars[0], b[0]), Transform(nonbas_vars[1], nb[0]), Transform(bas_vars[0], b[1]), Transform(bas_vars[1], b[2]), Transform(bas_vars[2], b[3]), ineqs6[0][8:8 + 2].animate.set_color(WHITE), ineqs6[0][28:28 + 2].animate.set_color(WHITE), i1.animate.set_opacity(0), of_dot.animate.shift(RIGHT * 0.5), of_arrow_shadow_2.animate.shift(RIGHT * 0.5), FadeOut(dashed_x, shift=RIGHT * 0.5), FadeOut(hl1), exp5[0][6:6 + 2].animate.set_color(WHITE))\n        self.remove(nonbas_vars[0], nonbas_vars[1])\n        self.remove(bas_vars[0], bas_vars[1], bas_vars[2])\n        self.add(b, nb)\n        nonbas_vars = nb\n        bas_vars = b\n        i3.set_color(POSSIBLE_COLOR).set_opacity(0)\n        i4.set_color(POSSIBLE_COLOR).set_opacity(0)\n        inter = intersection(line(i5.line.get_start(), i5.line.get_end()), line(i4.line.get_start(), i4.line.get_end()))\n        idot = area.dots[0].copy().move_to([*inter, 0])\n        hls1 = CreateHighlight(ineqs6[0][0:0 + 2]).set_color(POSSIBLE_COLOR)\n        hls3 = CreateHighlight(ineqs6[0][20:20 + 2]).set_color(POSSIBLE_COLOR)\n        hl1 = CreateHighlight(ineqs6[0][3:3 + 4]).set_color(POSSIBLE_COLOR)\n        hl2 = CreateHighlight(ineqs6[0][7:7 + 3]).set_color(POSSIBLE_COLOR)\n        hl3 = CreateHighlight(ineqs6[0][23:23 + 4]).set_color(POSSIBLE_COLOR)\n        hl4 = CreateHighlight(ineqs6[0][27:27 + 3]).set_color(POSSIBLE_COLOR)\n        self.play(steps[0][:23].animate.set_opacity(BIG_OPACITY), steps[0][23:58].animate.set_opacity(1), steps[0][58:].animate.set_opacity(BIG_OPACITY))\n        self.play(AnimationGroup(AnimationGroup(FadeIn(hl2), ineqs6[0][0:0 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[2].animate.set_color(POSSIBLE_COLOR), i4.animate.set_opacity(1), FadeIn(hls1, idot)), AnimationGroup(FadeIn(hl4), ineqs6[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[3].animate.set_color(POSSIBLE_COLOR), i3.animate.set_opacity(1), FadeIn(hls3)), lag_ratio=0.07))\n        four = Tex('$-3\\\\,000$').move_to(hl1).align_to(ineqs6, RIGHT).shift(RIGHT * 0.5).set_z_index(ineqs6.get_z_index() + 1)\n        five = Tex('$-1\\\\,000$').move_to(hl3).align_to(ineqs6, RIGHT).shift(RIGHT * 0.5).set_z_index(ineqs6.get_z_index() + 1)\n        ff = VGroup(four, five).scale(0.9).arrange(RIGHT, buff=0.6).next_to(ineqs6, UP, buff=0.5)\n        gt = Tex('$<$', stroke_width=1.5).scale(0.5).move_to(VGroup(four, five)).set_z_index(ineqs6.get_z_index() + 1)\n        a = ineqs6[0][3:3 + 4].copy()\n        b = ineqs6[0][23:23 + 4].copy()\n        am = ineqs6[0][7:7 + 1].copy()\n        bm = ineqs6[0][27:27 + 1].copy()\n        ah = CreateHighlight(four).set_color(POSSIBLE_COLOR)\n        bh = CreateHighlight(five).set_color(POSSIBLE_COLOR)\n        self.play(AnimationGroup(AnimationGroup(Transform(a, four[0][1:]), Transform(am, four[0][0]), FadeIn(ah)), AnimationGroup(Transform(b, five[0][1:]), Transform(bm, five[0][0]), FadeIn(bh)), lag_ratio=0.25))\n        inter = intersection(line(i5.line.get_start(), i5.line.get_end()), line(i3.line.get_start(), i3.line.get_end()))\n        idot_correct = area.dots[0].copy().move_to([*inter, 0]).set_z_index(area.dots[0].get_z_index() + 1)\n        self.add(idot_correct)\n        self.remove(a, am, b, bm)\n        self.add(four, five)\n        self.play(FadeIn(gt), bh.animate.set_color(GREEN), ah.animate.set_color(RED), ineqs6[0][20:20 + 2].animate.set_color(GREEN), bas_vars[3].animate.set_color(GREEN), i3.line.animate.set_color(GREEN), hls3.animate.set_color(GREEN), idot_correct.animate.set_color(GREEN), hl4.animate.set_color(GREEN), ineqs6[0][0:0 + 2].animate.set_color(RED), bas_vars[2].animate.set_color(RED), i4.line.animate.set_color(RED), hls1.animate.set_color(RED), idot.animate.set_color(RED), hl2.animate.set_color(RED))\n        nb = VGroup(nonbas_vars[0].copy(), bas_vars[3].copy().set_color(YELLOW))\n        nb.arrange(buff=vars_buff)\n        nb.move_to(nonbas_vars)\n        b = VGroup(bas_vars[0].copy(), bas_vars[1].copy(), bas_vars[2].copy().set_color(ORANGE))\n        b.arrange(buff=vars_buff)\n        b.move_to(bas_vars)\n        self.play(FadeOut(four, ah, hl2, hls1), FadeOut(idot), FadeOut(i4), FadeOut(gt), ineqs6[0][0:0 + 2].animate.set_color(ORANGE), bas_vars[2].animate.set_color(ORANGE))\n        self.play(FadeOut(five, bh, hl4, hls3), ineqs6[0][20:20 + 2].animate.set_color(YELLOW), i3.animate.set_color(YELLOW), Transform(nonbas_vars[0], nb[0]), Transform(bas_vars[3], nb[1]), Transform(bas_vars[0], b[0]), Transform(bas_vars[1], b[1]), Transform(bas_vars[2], b[2]), of_dot.animate.shift(RIGHT * 0.5), of_arrow_shadow_2.animate.shift(RIGHT * 0.5))\n        nonbas_vars = nb\n        bas_vars = b\n        hlp1 = hls3.set_color(RED)\n        hlp2 = hl2.set_color(RED)\n        hlp3 = hl4.set_color(RED)\n        hlp4 = CreateHighlight(exp5[0][3:3 + 5]).set_color(POSSIBLE_COLOR).set_color(RED)\n        self.play(steps[0][:23].animate.set_opacity(BIG_OPACITY), steps[0][23:58].animate.set_opacity(BIG_OPACITY), steps[0][58:].animate.set_opacity(1))\n        self.play(FadeIn(hlp1, hlp2, hlp3, hlp4))\n        ineqs7 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 3\\\\,000 - x_1 \\\\\\\\[-0.2em]\\n              x_2 &= 4\\\\,000 \\\\phantom{{} - s_1} - s_2 \\\\\\\\[-0.2em]\\n              x_1 &= 1\\\\,000 - s_3 + s_2\\n                \\\\end{aligned}$$').set_z_index(ineqs4.get_z_index())\n        align_object_by_coords(ineqs7, ineqs7[0][0].get_center(), ineqs6[0][0].get_center())\n        ineqs7[0][0:0 + 2].set_color(ORANGE)\n        ineqs7[0][8:8 + 2].set_color(WHITE)\n        ineqs7[0][18:18 + 2].set_color(YELLOW)\n        ineqs7[0][20:20 + 2].set_color(WHITE)\n        ineqs7[0][28:28 + 2].set_color(YELLOW)\n        ineqs7[0][31:31 + 2].set_color(YELLOW)\n        self.play(AnimationGroup(FadeOut(hlp1, hlp3), AnimationGroup(ineqs6[0][20:20 + 2].animate.move_to(ineqs7[0][28:28 + 2]), ineqs6[0][28:28 + 2].animate.move_to(ineqs7[0][20:20 + 2]), ineqs6[0][30:].animate.move_to(ineqs7[0][30:]), ineqs6[0][17:17 + 3].animate.move_to(ineqs7[0][17:17 + 3])), lag_ratio=0.5))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp5, ineqs7, bas_vars, nonbas_vars, rect_large, rect_down, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i3, i5, dpivot, steps, hlp2, hlp4)\n        ineqs8 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 2\\\\,000 + s_3 - s_2 \\\\\\\\[-0.2em]\\n              x_2 &= 4\\\\,000 \\\\phantom{{} - s_1} - s_2 \\\\\\\\[-0.2em]\\n              x_1 &= 1\\\\,000 - s_3 + s_2\\n                \\\\end{aligned}$$').set_z_index(ineqs4.get_z_index())\n        align_object_by_coords(ineqs8, ineqs8[0][0].get_center(), ineqs7[0][0].get_center())\n        ineqs8[0][0:0 + 2].set_color(ORANGE)\n        ineqs8[0][8:8 + 2].set_color(YELLOW)\n        ineqs8[0][11:11 + 2].set_color(YELLOW)\n        ineqs8[0][21:21 + 2].set_color(YELLOW)\n        ineqs8[0][31:31 + 2].set_color(YELLOW)\n        ineqs8[0][34:34 + 2].set_color(YELLOW)\n        exp6 = Tex('$$\\\\max\\\\ -1.2 s_3 - 0.5 s_2 + 8\\\\,000$$').set_z_index(exp5.get_z_index())\n        exp6[0][7:7 + 2].set_color(YELLOW)\n        exp6[0][13:13 + 2].set_color(YELLOW)\n        exp6.move_to(exp5)\n        self.play(AnimationGroup(AnimationGroup(ineqs7[0][23:].copy().animate.align_to(ineqs7[0][3:9 + 1], DOWN).set_opacity(0), Succession(Wait(0.25), AnimationGroup(AnimationGroup(FadeOut(ineqs7[0][3:9 + 1]), FadeOut(hlp2)), FadeIn(ineqs8[0][3:13]), lag_ratio=0.2, run_time=0.75))), AnimationGroup(ineqs7[0][23:].copy().animate.move_to(exp5[0][3:]).set_opacity(0), Succession(Wait(0.25), AnimationGroup(AnimationGroup(FadeOut(exp5), FadeOut(hlp4)), FadeIn(exp6), lag_ratio=0.2, run_time=0.75))), lag_ratio=0.75))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp6, ineqs8, bas_vars, nonbas_vars, rect_large, rect_down, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i3, i5, dpivot, steps)\n        self.play(steps[0][:23].animate.set_opacity(1), steps[0][23:58].animate.set_opacity(1), steps[0][58:].animate.set_opacity(1))\n        hl1 = CreateHighlight(exp6[0][4:4 + 5]).set_color(RED)\n        hl2 = CreateHighlight(exp6[0][10:10 + 5]).align_to(hl1, DOWN).set_color(RED)\n        self.play(FadeIn(hl1, hl2), steps[0][:23].animate.set_opacity(1), steps[0][23:58].animate.set_opacity(BIG_OPACITY), steps[0][58:].animate.set_opacity(BIG_OPACITY))\n        self.play(FadeOut(hl1, hl2), steps[0][:23].animate.set_opacity(1), steps[0][23:58].animate.set_opacity(1), steps[0][58:].animate.set_opacity(1))\n        hl1 = CreateHighlight(VGroup(ineqs8[0][0], ineqs8[0][6], ineqs8[0][23], ineqs8[0][24])).set_color(BLUE)\n        hl2 = CreateHighlight(exp6[0][-4:]).set_color(BLUE)\n        hltg = VGroup(ineqs8[0][13:13 + 7], ineqs8[0][23:23 + 7])\n        hlt = CreateHighlight(hltg).set_color(BLUE)\n        self.play(FadeIn(hl1, hl2), nonbas_vars.animate.set_opacity(BIG_OPACITY), ineqs8[0][7:7 + 6].animate.set_opacity(BIG_OPACITY), ineqs8[0][20:20 + 3].animate.set_opacity(BIG_OPACITY), ineqs8[0][30:30 + 6].animate.set_opacity(BIG_OPACITY), exp6[0][3:3 + 13].animate.set_opacity(BIG_OPACITY))\n        self.play(VGroup(exp6[0][-4:], hl2).animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        self.play(ineqs8[0][:7].animate.set_opacity(BIG_OPACITY), Transform(hl1, hlt))\n        self.play(VGroup(hltg, hl1).animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        self.play(FadeOut(hl1, hl2), nonbas_vars.animate.set_opacity(1), ineqs8[0][:7].animate.set_opacity(1), ineqs8[0][7:7 + 6].animate.set_opacity(1), ineqs8[0][20:20 + 3].animate.set_opacity(1), ineqs8[0][30:30 + 6].animate.set_opacity(1), exp6[0][3:3 + 13].animate.set_opacity(1))\n        self.next_section()\n        a_surprise_weapon_that_will_help_us_later.move_to(VGroup(ineqs8, exp6, nonbas_vars, bas_vars, of3, nonbasic, basic))\n        ineqs_base, exp_base, var_base, of_base = a_surprise_weapon_that_will_help_us_later\n        labels[0].shift(UP * 0.5)\n        labels[0].set_z_index(rect_down.get_z_index() - 0.0001)\n        dist = UP * 1.5\n        optimum_texts = VGroup(Tex('$1\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.6).move_to(of_dot.copy().shift(dist)).align_to(numberplane.axes[0], UP).shift(DOWN * 0.25).set_z_index(100000), Tex('$4\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.6).move_to(of_dot.copy().shift(dist)).align_to(numberplane.axes[1], RIGHT).shift(LEFT * 0.25).set_z_index(100000), Tex('$\\\\$8\\\\,000$').scale(1).next_to(of_dot.copy().shift(dist), UP + RIGHT).set_z_index(100000))\n        sweep.move_to(of_dot.copy())\n        dl_updater(dl)\n        sweep.shift(dist)\n        dl.shift(dist)\n        geom = Tex('\\\\textbf{Geometric}').set_z_index(100000).scale(0.6).rotate(atan2(OF_INITIAL[1], OF_INITIAL[0])).set_color(BLUE)\n        simp = Tex('\\\\textbf{Simplex}').set_z_index(100000).scale(0.6).rotate(PI / 2).set_color(ORANGE)\n        pts = [of_arrow_shadow.get_start(), of_arrow_shadow.get_start() + UP * 4, of_arrow_shadow.get_start() + UP * 4 + RIGHT * 1]\n        pline1 = Line(pts[0], pts[1], stroke_width=of_arrow.get_stroke_width() * 1.0).set_color(ORANGE).set_z_index(of_arrow.get_z_index() - 0.0001).shift(dist)\n        plineunder1 = Line(pts[0], pts[1], stroke_width=of_arrow.get_stroke_width() * 0.9).set_color(GRAY).set_z_index(of_arrow.get_z_index() - 0.0002).shift(dist)\n        pline2 = Line(pts[1], pts[2], stroke_width=of_arrow.get_stroke_width() * 1.0).set_color(ORANGE).set_z_index(of_arrow.get_z_index() - 0.0001).shift(dist)\n        plineunder2 = Line(pts[1], pts[2], stroke_width=of_arrow.get_stroke_width() * 0.9).set_color(GRAY).set_z_index(of_arrow.get_z_index() - 0.0002).shift(dist)\n        geom.move_to(dl.get_start()).rotate(-PI / 2).shift(np.array([*OF_INITIAL, 0]) * 0.15)\n        simp.move_to(of_arrow_shadow.get_start()).shift(dist + UP * 2).shift(LEFT * 0.2)\n        for i in range(3):\n            optimum_texts[i].add(CreateSR(optimum_texts[i]))\n        of_dot.set_sheen_direction(unit_vector(OF_INITIAL[0] * RIGHT + OF_INITIAL[1] * UP))\n        self.play(Succession(Wait(0.25), AnimationGroup(FadeIn(ineqs_base, exp_base, var_base, of_base, shift=dist * self.camera.frame.height), FadeOut(ineqs8, exp6, nonbas_vars, bas_vars, of3, nonbasic, basic, shift=dist * self.camera.frame.height), run_time=1.5)), Succession(Wait(0.25), rect_down.animate.align_to(Dot().next_to(self.camera.frame, DOWN), UP), run_time=1.5), Succession(Wait(0.25), VGroup(sm, dpivot).animate.align_to(Dot().next_to(self.camera.frame, UP), DOWN).set_opacity(0), run_time=1.5), Succession(Wait(0.25), VGroup(numberplane, of_arrow_shadow, area, labels[0]).animate.shift(dist), run_time=1.5), Succession(Wait(0.25), of_dot.animate.shift(dist).set_color_by_gradient((ORANGE, ORANGE, BLUE, BLUE)), run_time=1.5), Succession(Wait(0.25), FadeOut(i3, i5, of_arrow_shadow_2, shift=dist), run_time=1.5), Succession(Wait(0.25), FadeIn(optimum_texts[2], sweep, dl, simp, geom, pline1, pline2, shift=dist), run_time=1.5), AnimationGroup(FadeOut(steps[0][:23], run_time=0.5), FadeOut(steps[0][23:58], run_time=0.5), FadeOut(steps[0][58:], run_time=0.5), lag_ratio=0.2, run_time=1))\n        hl1 = CreateHighlight(ineqs_base[0][7:])\n        hlq = Tex('$\\\\le\\\\ ?$').set_z_index(ineqs_base.get_z_index()).next_to(exp_base, RIGHT, buff=0.3).align_to(exp_base[0][-6], DOWN).shift(DOWN * 0.03)\n        hl2 = CreateHighlight(VGroup(exp_base[0][3:], hlq))\n        self.play(FadeIn(hl1))\n        self.play(FadeIn(hl2), FadeIn(hlq))\n        self.play(FadeOut(hl1, hl2, hlq))\n        a = Tex('$1.2\\\\ \\\\times$').set_z_index(ineqs_base.get_z_index()).set_color(DUAL_COLOR).next_to(ineqs_base[0][7], LEFT).align_to(ineqs_base[0][7], DOWN)\n        b = Tex('$1.7\\\\ \\\\times$').set_z_index(ineqs_base.get_z_index()).set_color(DUAL_COLOR).next_to(ineqs_base[0][14], LEFT).align_to(ineqs_base[0][14], DOWN).align_to(a, RIGHT)\n        self.play(FadeIn(a, shift=0.2 * LEFT))\n        self.play(FadeIn(b, shift=0.2 * LEFT))\n        an = Tex('$3\\\\,600$').set_color(DUAL_COLOR).set_z_index(ineqs_base.get_z_index()).move_to(ineqs_base[0][10:10 + 4])\n        bn = Tex('$6\\\\,800$').set_color(DUAL_COLOR).set_z_index(ineqs_base.get_z_index()).move_to(ineqs_base[0][17:17 + 4])\n        self.play(AnimationGroup(AnimationGroup(FadeOut(a[0][-1]), FadeOut(b[0][-1])), AnimationGroup(a[0][:3].animate.next_to(ineqs_base[0][7], LEFT, buff=0.09).align_to(ineqs_base[0][7], DOWN), b[0][:3].animate.next_to(ineqs_base[0][14], LEFT, buff=0.09).align_to(ineqs_base[0][14], DOWN), ineqs_base[0][7:21].animate.set_color(DUAL_COLOR), ineqs_base[0][10:10 + 4].animate.set_opacity(0), ineqs_base[0][17:17 + 4].animate.set_opacity(0), FadeIn(an), FadeIn(bn)), lag_ratio=0.5))\n        t = Tex('${} \\\\le 10\\\\,400$').set_z_index(ineqs_base.get_z_index()).next_to(exp_base, RIGHT, buff=0.3).align_to(exp_base[0][-6], DOWN).shift(DOWN * 0.03).set_color(DUAL_COLOR)\n        expcp = exp_base.copy()\n        VGroup(expcp, t).move_to(exp_base)\n        expcp[0][3:3 + 5].set_color(DUAL_COLOR)\n        expcp[0][9:9 + 5].set_color(DUAL_COLOR)\n        exp_base.save_state()\n        self.play(Transform(exp_base, expcp), Succession(Wait(0.25), AnimationGroup(Addd(an.copy(), t), Addd(bn.copy(), t))), Succession(Wait(0.5), FadeIn(t)))\n        self.play(FadeOut(a[0][:3]), FadeOut(b[0][:3]), ineqs_base[0][10:10 + 4].animate.set_opacity(1).set_color(WHITE), ineqs_base[0][17:17 + 4].animate.set_opacity(1).set_color(WHITE), ineqs_base[0][7:10].animate.set_color(WHITE), ineqs_base[0][14:17].animate.set_color(WHITE), FadeOut(an), FadeOut(bn))\n        a = Tex('$0.2\\\\ \\\\times$').set_z_index(ineqs_base.get_z_index()).set_color(DUAL_COLOR).next_to(ineqs_base[0][7], LEFT).align_to(ineqs_base[0][7], DOWN)\n        b = Tex('$0.7\\\\ \\\\times$').set_z_index(ineqs_base.get_z_index()).set_color(DUAL_COLOR).next_to(ineqs_base[0][14], LEFT).align_to(ineqs_base[0][14], DOWN).align_to(a, RIGHT)\n        c = Tex('$1.0\\\\ \\\\times$').set_z_index(ineqs_base.get_z_index()).set_color(DUAL_COLOR).next_to(ineqs_base[0][21], LEFT).align_to(ineqs_base[0][21], DOWN).align_to(b, RIGHT)\n        self.play(FadeIn(a, shift=0.2 * LEFT))\n        self.play(FadeIn(b, shift=0.2 * LEFT))\n        self.play(FadeIn(c, shift=0.2 * LEFT))\n        an = Tex('$0\\\\,600$').set_color(DUAL_COLOR).set_z_index(ineqs_base.get_z_index()).move_to(ineqs_base[0][10:10 + 4])\n        an[0][0].set_opacity(0)\n        bn = Tex('$2\\\\,800$').set_color(DUAL_COLOR).set_z_index(ineqs_base.get_z_index()).move_to(ineqs_base[0][17:17 + 4])\n        cn = Tex('$5\\\\,000$').set_color(DUAL_COLOR).set_z_index(ineqs_base.get_z_index()).move_to(ineqs_base[0][27:27 + 4])\n        self.play(AnimationGroup(AnimationGroup(FadeOut(a[0][-1]), FadeOut(b[0][-1]), FadeOut(c)), AnimationGroup(a[0][:3].animate.next_to(ineqs_base[0][7], LEFT, buff=0.09).align_to(ineqs_base[0][7], DOWN), b[0][:3].animate.next_to(ineqs_base[0][14], LEFT, buff=0.09).align_to(ineqs_base[0][14], DOWN), ineqs_base[0][7:].animate.set_color(DUAL_COLOR), ineqs_base[0][10:10 + 4].animate.set_opacity(0), ineqs_base[0][17:17 + 4].animate.set_opacity(0), ineqs_base[0][27:27 + 4].animate.set_opacity(0), FadeIn(an), FadeIn(bn), FadeIn(cn)), lag_ratio=0.5))\n        t2 = Tex('${} \\\\le 8\\\\,400$').set_z_index(ineqs_base.get_z_index()).next_to(exp_base, RIGHT, buff=0.3).align_to(exp_base[0][-6], DOWN).shift(DOWN * 0.03).set_color(DUAL_COLOR)\n        self.play(Succession(Wait(0.25), AnimationGroup(Addd(an.copy(), t2), Addd(bn.copy(), t2), Addd(cn.copy(), t2))), Succession(Wait(0.5), AnimationGroup(FadeOut(t[0][-5:]), FadeIn(t2[0][-4:]))))\n        vary = Tex('variables: $y_1, y_2, y_3$').move_to(var_base)\n        vary.set_x(-vary.get_x())\n        ineqsy = Tex('$$\\\\begin{aligned}\\n        y_1, y_2, y_3  &\\\\ge 0 \\\\\\\\[0.3em]\\n              y_1 \\\\phantom{{} + y_2} + y_3 &\\\\ge 1.2 \\\\\\\\[-0.2em]\\n              \\\\phantom{y_1 + {}} y_2 + y_3 &\\\\ge 1.7\\n                \\\\end{aligned}$$').move_to(ineqs_base)\n        ineqsy.set_x(-ineqsy.get_x()).align_to(ineqs_base, UP)\n        ofy = of_base.copy()\n        expy = Tex('$$\\\\begin{aligned}\\\\min\\\\ 3\\\\,000 & y_1 \\\\\\\\[-0.27em] {} + 4\\\\,000 & y_2 \\\\\\\\[-0.27em] {} + 5\\\\,000 & y_3\\\\end{aligned}$$')\n        VGroup(ofy, expy).arrange(DOWN, buff=0.15).move_to(of3).align_to(exp_base, DOWN)\n        expy.set_x(-expy.get_x())\n        ofy.set_x(-ofy.get_x())\n        VGroup(ofy, expy).shift(DOWN * 0.45)\n        spacing2 = rect_large.get_x() + rect_large.width / 2 - 0.04\n        self.play(FadeOut(a[0][:3]), FadeOut(b[0][:3]), ineqs_base[0][10:10 + 4].animate.set_opacity(1).set_color(WHITE), ineqs_base[0][17:17 + 4].animate.set_opacity(1).set_color(WHITE), ineqs_base[0][27:27 + 4].animate.set_opacity(1).set_color(WHITE), ineqs_base[0][7:10].animate.set_color(WHITE), ineqs_base[0][14:17].animate.set_color(WHITE), ineqs_base[0][21:27].animate.set_color(WHITE), FadeOut(an), FadeOut(bn), FadeOut(cn), rect_large.animate.shift(LEFT * spacing2), FadeOut(area, of_arrow_shadow, numberplane, of_dot, optimum_texts[2], sweep, dl, simp, geom, pline1, pline2, labels, sr), FadeOut(t[0][:-5]), FadeOut(t2[0][-4:]), exp_base.animate.restore())\n        a = Tex('$y_1\\\\ \\\\times$').set_z_index(ineqs_base.get_z_index()).set_color(DUAL_COLOR).next_to(ineqs_base[0][7], LEFT).align_to(ineqs_base[0][8], DOWN).shift(DOWN * 0.05)\n        b = Tex('$y_2\\\\ \\\\times$').set_z_index(ineqs_base.get_z_index()).set_color(DUAL_COLOR).next_to(ineqs_base[0][14], LEFT).align_to(ineqs_base[0][15], DOWN).align_to(a, RIGHT).shift(DOWN * 0.05)\n        c = Tex('$y_3\\\\ \\\\times$').set_z_index(ineqs_base.get_z_index()).set_color(DUAL_COLOR).next_to(ineqs_base[0][21], LEFT).align_to(ineqs_base[0][22], DOWN).align_to(b, RIGHT).shift(DOWN * 0.05)\n        self.play(AnimationGroup(FadeIn(a), FadeIn(b), FadeIn(c), lag_ratio=0.1))\n        acp = a.copy().set_opacity(0.5)\n        bcp = b.copy().set_opacity(0.5)\n        ccp = c.copy().set_opacity(0.5)\n        self.add(acp, bcp, ccp)\n        vary[0][10:10 + 2].set_color(DUAL_COLOR)\n        vary[0][13:13 + 2].set_color(DUAL_COLOR)\n        vary[0][16:16 + 2].set_color(DUAL_COLOR)\n        ineqsy[0][0:0 + 2].set_color(DUAL_COLOR)\n        ineqsy[0][3:3 + 2].set_color(DUAL_COLOR)\n        ineqsy[0][6:6 + 2].set_color(DUAL_COLOR)\n        ineqsy[0][10:10 + 2].set_color(DUAL_COLOR)\n        ineqsy[0][13:13 + 2].set_color(DUAL_COLOR)\n        ineqsy[0][19:19 + 2].set_color(DUAL_COLOR)\n        ineqsy[0][22:22 + 2].set_color(DUAL_COLOR)\n        expy[0][7:7 + 2].set_color(DUAL_COLOR)\n        expy[0][14:14 + 2].set_color(DUAL_COLOR)\n        expy[0][21:21 + 2].set_color(DUAL_COLOR)\n        expy[0][14:14 + 2].set_color(DUAL_COLOR)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(a[0][-1]), FadeOut(b[0][-1]), FadeOut(c[0][-1])), AnimationGroup(Transform(a[0][:2], vary[0][10:10 + 2]), Transform(b[0][:2], vary[0][13:13 + 2]), Transform(c[0][:2], vary[0][16:16 + 2])), AnimationGroup(FadeIn(vary[0][:10]), FadeIn(vary[0][12]), FadeIn(vary[0][15])), lag_ratio=0.5))\n        self.play(FadeIn(ineqsy[0][:10]))\n        hl1 = CreateHighlight(VGroup(ineqs_base[0][21:21 + 2], ineqs_base[0][7:7 + 2])).set_color(GRAY)\n        hl3 = CreateHighlight(exp_base[0][3:3 + 5]).set_color(GRAY)\n        self.play(FadeIn(hl1, hl3))\n        self.play(FadeIn(ineqsy[0][10:19]))\n        self.play(AnimationGroup(AnimationGroup(Transform(hl1, CreateHighlight(VGroup(ineqs_base[0][24:24 + 2], ineqs_base[0][14:14 + 2])).set_color(GRAY)), Transform(hl3, CreateHighlight(exp_base[0][9:9 + 5]).set_color(GRAY))), FadeIn(ineqsy[0][19:]), lag_ratio=0.5))\n        self.play(AnimationGroup(FadeOut(hl3), Transform(hl1, CreateHighlight(VGroup(ineqs_base[0][10:10 + 4], ineqs_base[0][17:17 + 4], ineqs_base[0][27:27 + 4])).set_color(GRAY)), FadeIn(expy, ofy), lag_ratio=0.5))\n        self.play(FadeOut(hl1, acp, bcp, ccp))\n        primal = VGroup(var_base, ineqs_base, exp_base)\n        primal_correct = VGroup(var_base, ineqs_base, exp_base).copy().arrange(DOWN, buff=0.7).move_to(primal).align_to(primal, UP).shift(DOWN * 1)\n        primal_correct[0][0][10:10 + 2].set_color(PRIMAL_COLOR)\n        primal_correct[0][0][13:13 + 2].set_color(PRIMAL_COLOR)\n        primal_correct[1][0][0:0 + 2].set_color(PRIMAL_COLOR)\n        primal_correct[1][0][3:3 + 2].set_color(PRIMAL_COLOR)\n        primal_correct[1][0][7:7 + 2].set_color(PRIMAL_COLOR)\n        primal_correct[1][0][14:14 + 2].set_color(PRIMAL_COLOR)\n        primal_correct[1][0][21:21 + 2].set_color(PRIMAL_COLOR)\n        primal_correct[1][0][24:24 + 2].set_color(PRIMAL_COLOR)\n        primal_correct[2][0][6:6 + 2].set_color(PRIMAL_COLOR)\n        primal_correct[2][0][12:12 + 2].set_color(PRIMAL_COLOR)\n        dual = VGroup(vary, ineqsy, expy)\n        dual_correct = VGroup(vary, ineqsy, expy).copy().arrange(DOWN, buff=0.6).move_to(dual).align_to(dual, UP).shift(DOWN * 1)\n        self.wait()\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(primal, dual, of_base, ofy, rect_large)\n        primal_text = Tex('\\\\underline{Primal}').move_to(var_base).set_z_index(var_base.get_z_index()).set_color(PRIMAL_COLOR).scale(1.25)\n        dual_text = Tex('\\\\underline{Dual}').move_to(vary).set_z_index(var_base.get_z_index()).set_color(DUAL_COLOR).scale(1.25)\n        leq = SVGMobject('assets/leq.svg').set_width(0.8).set_z_index(100000000)\n        eq = SVGMobject('assets/eq.svg').set_width(0.8).set_z_index(100000000)\n        self.play(AnimationGroup(FadeOut(of_base, ofy), AnimationGroup(Transform(primal, primal_correct), Transform(dual, dual_correct)), AnimationGroup(Write(primal_text), Write(dual_text), run_time=1), lag_ratio=0.5))\n        self.play(FadeIn(leq))\n        wdt = Tex('Weak', 'Duality', 'Theorem').arrange(DOWN, buff=0.15).set_z_index(var_base.get_z_index())\n        wdt[1].shift(DOWN * 0.04)\n        wdt.add(CreateSR(wdt).set_opacity(1).scale(1.1))\n        leqcp = leq.copy()\n        VGroup(wdt, leqcp).arrange(DOWN, buff=0.35)\n        self.play(Succession(Wait(0.5), FadeIn(wdt)), Transform(leq, leqcp), VGroup(primal, primal_text).animate.shift(LEFT * 0.5), VGroup(dual, dual_text).animate.shift(RIGHT * 0.5))\n        eq.move_to(leq)\n        strong = Tex('Strong').set_z_index(var_base.get_z_index()).move_to(wdt[0]).align_to(wdt[0], UP)\n        self.play(Transform(leq, eq))\n        self.play(FadeOut(wdt[0], shift=RIGHT * 2), FadeIn(strong, shift=RIGHT * 2))"}]}
{"messages": [{"role": "user", "content": "Visualize the process of solving a farmer's crop profit maximization problem using linear programming, from defining constraints to illustrating the simplex method with graphical and tabular representations."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass FarmerBandaid(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        farm = ImageMobject('assets/midjourney/farm-12-16-out.png').set_height(self.camera.frame.get_height()).align_to(self.camera.frame, LEFT).set_z_index(5)\n        rect = ImageMobject('assets/midjourney/farm-12-16-rect.png').set_height(self.camera.frame.get_height()).align_to(farm, RIGHT).set_z_index(6)\n        rect_large = ImageMobject('assets/midjourney/farm-12-16-rect-large.png')\n        rect_small = ImageMobject('assets/midjourney/farm-12-16-rect-small.png').set_height(self.camera.frame.get_height()).align_to(farm, RIGHT).set_z_index(6)\n        farm.save_state()\n        rect.save_state()\n        icon_scale = 1.65\n        carrot = ImageMobject('assets/midjourney/carrot-cropped-flopped.png').set_height(0.45 * icon_scale)\n        potato = ImageMobject('assets/midjourney/potato-cropped.png').set_height(0.3 * icon_scale)\n        fertilizer = ImageMobject('assets/midjourney/fertilizer-cropped-flopped.png').set_height(0.3 * icon_scale)\n        farmer = ImageMobject('assets/midjourney/farmer-outline.png').set_z_index(10).set_height(1.05)\n        farmer_black = ImageMobject('assets/midjourney/farmer-black.png').set_z_index(9).set_height(1.05)\n        self.add(rect, farm)\n        fc = farm.copy()\n        farm.move_to(Dot().next_to(self.camera.frame, LEFT))\n        offset = 1\n        rect_played = rect.copy().next_to(fc, RIGHT, buff=0).shift(LEFT * offset * 2)\n        farm_played = farm.align_to(self.camera.frame, LEFT).shift(LEFT * offset)\n        title = Tex(\"\\\\underline{Farmer's Problem}\").scale(1.5)\n        goal = Tex('Goal: \\\\it maximize profit').scale(1.25)\n        points = VGroup(Tex('\\\\begin{itemize} \\\\item $3$ tons of potato seeds \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $4$ tons of carrot seeds \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $5$ tons of fertilizer (used 1:1) \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item ' + str(OF_INITIAL[0]) + '\\\\$/kg for O, ' + str(OF_INITIAL[1]) + '\\\\$/kg for O \\\\end{itemize}'))\n        for i in range(3):\n            align_object_by_coords(points[i + 1], points[i + 1][0][0], points[0][0][0])\n            points[i + 1].shift(DOWN * 0.75 * (i + 1))\n            if i == 2:\n                points[i + 1].shift(DOWN * 0.3)\n        guide = Dot().move_to(VGroup(Dot().align_to(rect_played, LEFT), Dot().align_to(self.camera.frame, RIGHT)))\n        potato.next_to(points[0][0][-1], RIGHT)\n        carrot.next_to(points[1][0][-1], RIGHT)\n        fertilizer.next_to(points[2][0][-1], RIGHT)\n        p2 = potato.copy().move_to(points[3][0][11])\n        c2 = carrot.copy().move_to(points[3][0][-1]).shift(RIGHT * 0.1)\n        points[3][0][11].scale(0.001).set_color(BLACK).set_opacity(0).set_z_index(-1)\n        points[3][0][-1].scale(0.001).set_color(BLACK).set_opacity(0).set_z_index(-1)\n        points[0][0][1].set_color(POTATO_COLOR)\n        points[1][0][1].set_color(CARROT_COLOR)\n        points[2][0][1].set_color(FERTILIZER_COLOR)\n        points[0][0][8:13 + 1].set_color(POTATO_COLOR)\n        points[1][0][8:13 + 1].set_color(CARROT_COLOR)\n        points[2][0][8:17 + 1].set_color(FERTILIZER_COLOR)\n        points[3][0][1:7 + 1].set_color(POTATO_COLOR)\n        points[3][0][13:19 + 1].set_color(CARROT_COLOR)\n        main_group = Group(Group(title, farmer).arrange(buff=0.4), Group(points, p2, c2, carrot, potato, fertilizer), goal).arrange(DOWN, buff=0.7).move_to(guide).set_z_index(10)\n        title.set_z_index(7)\n        farmer_copy = farmer.copy().move_to(title[0][0]).align_to(farmer, DOWN).set_opacity(0).set_z_index(1000)\n        farmer_black.move_to(farmer).set_z_index(999)\n        farmer_black_copy = farmer_black.copy().move_to(title[0][0]).align_to(farmer, DOWN).set_z_index(999)\n        sr1 = SurroundingRectangle(title, color=BLACK, fill_opacity=1).set_z_index(8)\n        sr2 = SurroundingRectangle(title, color=BLACK, fill_opacity=1).set_z_index(9).move_to(farmer_copy).align_to(Dot().move_to(farmer_copy), LEFT)\n        self.add(sr1, title)\n        self.play(rect.animate.next_to(fc, RIGHT, buff=0).shift(LEFT * offset * 2), farm.animate.align_to(self.camera.frame, LEFT).shift(LEFT * offset), ReplacementTransform(farmer_copy, farmer), ReplacementTransform(farmer_black_copy, farmer_black), FadeOut(sr1), sr2.animate.align_to(Dot().move_to(farmer), LEFT), run_time=2)\n        self.remove(farmer_black, sr2)\n        self.play(AnimationGroup(Write(points[0], run_time=1.25), FadeIn(potato, shift=0.1 * RIGHT), lag_ratio=0.5))\n        self.play(AnimationGroup(Write(points[1], run_time=1.25), FadeIn(carrot, shift=0.1 * RIGHT), lag_ratio=0.5))\n        self.play(Write(points[2][0][:17 + 1], run_time=1))\n        self.play(AnimationGroup(Write(points[2][0][17 + 1:], run_time=0.65), FadeIn(fertilizer, shift=0.1 * RIGHT), lag_ratio=0.3))\n        self.play(AnimationGroup(Write(points[3][0][:12 + 1]), FadeIn(p2, run_time=0.5), lag_ratio=0.5))\n        self.play(AnimationGroup(Write(points[3][0][12 + 1:]), FadeIn(c2, run_time=0.5), lag_ratio=0.5))\n        self.play(Write(goal[0][:5]), run_time=0.65)\n        self.play(Write(goal[0][5:]), run_time=1)\n        saved_x = (main_group.animate.set_x(0),)\n        rect2 = rect_small.copy().flip().align_to(self.camera.frame, RIGHT).shift(RIGHT * 0.1)\n        self.add(rect2)\n        offset2 = 0.5\n        equivalenece = SVGMobject('assets/iff.svg').set_height(0.6).set_z_index(10)\n        equivalenece.move_to(Dot().align_to(self.camera.frame, RIGHT))\n        equivalenece.set_opacity(0).shift(RIGHT * (0.65 - offset2))\n        self.play(rect.animate.restore(), farm.animate.restore(), main_group.animate.set_x(-main_group.get_x() - offset2 / 2), rect2.animate.shift(LEFT * (main_group.get_x() * 2 + offset2)), equivalenece.animate.shift(LEFT * (main_group.get_x() * 2 + offset2)).set_opacity(1))\n        guide2 = Dot().move_to(VGroup(Dot().move_to(equivalenece), Dot().align_to(self.camera.frame, RIGHT)))\n        var = ComplexTex('variables: $x_p, x_c$')\n        var[0][-5:-3].set_color(POTATO_COLOR)\n        var[0][-2:].set_color(CARROT_COLOR)\n        ineqs = ComplexTex('$$\\\\begin{aligned}\\n        x_p, x_c  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_p \\\\phantom{{}+ x_c} &\\\\le 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_c &\\\\le 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_p + x_c &\\\\le 5\\\\,000\\n                \\\\end{aligned}$$')\n        ineqs[0][0:2].set_color(POTATO_COLOR)\n        ineqs[0][3:3 + 2].set_color(CARROT_COLOR)\n        ineqs[0][7:7 + 2].set_color(POTATO_COLOR)\n        ineqs[0][10].set_color(POTATO_COLOR)\n        ineqs[0][11].set_color(POTATO_COLOR)\n        ineqs[0][12].set_color(POTATO_COLOR)\n        ineqs[0][13].set_color(POTATO_COLOR)\n        ineqs[0][14:14 + 2].set_color(CARROT_COLOR)\n        ineqs[0][17].set_color(CARROT_COLOR)\n        ineqs[0][18].set_color(CARROT_COLOR)\n        ineqs[0][19].set_color(CARROT_COLOR)\n        ineqs[0][20].set_color(CARROT_COLOR)\n        ineqs[0][21:21 + 2].set_color(POTATO_COLOR)\n        ineqs[0][24:24 + 2].set_color(CARROT_COLOR)\n        ineqs[0][27].set_color(FERTILIZER_COLOR)\n        ineqs[0][28].set_color(FERTILIZER_COLOR)\n        ineqs[0][29].set_color(FERTILIZER_COLOR)\n        ineqs[0][30].set_color(FERTILIZER_COLOR)\n        exp = ComplexTex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_p + ' + str(OF_INITIAL[1]) + ' x_c$$')\n        exp[0][3:3 + 5].set_color(POTATO_COLOR)\n        exp[0][-5:].set_color(CARROT_COLOR)\n        of = Tex('objective function').set_opacity(MED_OPACITY).scale(0.75)\n        theory_group = Group(var, ineqs, exp).arrange(DOWN, buff=0.75).move_to(guide2).set_z_index(10)\n        var.align_to(title, DOWN)\n        exp.align_to(goal, UP)\n        self.play(AnimationGroup(AnimationGroup(points[2].animate.set_opacity(BIG_OPACITY), points[3].animate.set_opacity(BIG_OPACITY), fertilizer.animate.set_opacity(BIG_OPACITY), p2.animate.set_opacity(BIG_OPACITY), c2.animate.set_opacity(BIG_OPACITY), goal.animate.set_opacity(BIG_OPACITY)), Write(var, run_time=1.25), lag_ratio=0.5))\n        self.play(Write(ineqs[0][:7]), run_time=1.25)\n        self.play(Write(ineqs[0][7:21]), run_time=1.5)\n        self.play(AnimationGroup(AnimationGroup(points[0].animate.set_opacity(BIG_OPACITY), points[1].animate.set_opacity(BIG_OPACITY), potato.animate.set_opacity(BIG_OPACITY), carrot.animate.set_opacity(BIG_OPACITY), points[2].animate.set_opacity(1), fertilizer.animate.set_opacity(1)), Write(ineqs[0][21:], run_time=1), lag_ratio=0.5))\n        self.play(AnimationGroup(AnimationGroup(points[2].animate.set_opacity(BIG_OPACITY), fertilizer.animate.set_opacity(BIG_OPACITY), points[3].animate.set_opacity(1), p2.animate.set_opacity(1), c2.animate.set_opacity(1), goal.animate.set_opacity(1)), lag_ratio=0.5))\n        self.play(Write(exp, run_time=1.5))\n        g = VGroup(exp.copy(), of).arrange(UP, buff=0.15).move_to(exp)\n        self.play(Transform(exp, g[0]), FadeIn(of, shift=UP * 0.15))\n        self.play(points.animate.set_opacity(1), carrot.animate.set_opacity(1), potato.animate.set_opacity(1), fertilizer.animate.set_opacity(1))\n        theory_group.add(of)\n        of.set_z_index(10)\n        self.remove(rect, farm)\n        rect3 = rect.copy().flip().align_to(self.camera.frame, RIGHT).set_z_index(rect2.get_z_index() - 1).shift(RIGHT * 0.1)\n        self.add(rect3)\n        guide3 = Dot().move_to(main_group)\n        guide3.set_x(-guide3.get_x())\n        numberplane = NumberPlane(x_range=(-3 * 7.111111111111111, 3 * 7.111111111111111, 1), y_range=(-3 * 4.0, 3 * 4.0, 1), stroke_width=6, axis_config={'stroke_width': 4}, background_line_style={'stroke_color': GRAY, 'stroke_width': 3, 'stroke_opacity': 0.6})\n        numberplane.background_lines.set_z_index(rect3.get_z_index() - 1 + 0.1)\n        numberplane.axes.set_z_index(rect3.get_z_index() - 1 + 0.2)\n        area = FeasibleArea2D(dots_z_index=rect3.get_z_index() - 1 + 0.99).set_z_index(rect3.get_z_index() - 1 + 0.4)\n        i1 = Inequality2D(1, 0, '>=', 0).set_color(POTATO_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i2 = Inequality2D(0, 1, '>=', 0).set_color(CARROT_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i3 = Inequality2D(1, 1, '<=', 5).set_color(FERTILIZER_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i4 = Inequality2D(1, 0, '<=', 3).set_color(POTATO_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i5 = Inequality2D(0, 1, '<=', 4).set_color(CARROT_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i4_hp = i4.get_half_plane()\n        area.add_inequalities([i1, i2, i3, i4, i5])\n        of_arrow = Arrow(start=ORIGIN, end=np.array((*OF_INITIAL, 0)), buff=0).set_z_index(area.dots_z_index - 0.01)\n        of_arrow_shadow = of_arrow.copy().set_color(WHITE).set_z_index(of_arrow.get_z_index() - 1e-06)\n        optimum = list(solve_farm(OF_INITIAL))\n        optimum[0] /= 1000\n        optimum[1] /= 1000\n        sweep = AffineLine2D(OF_INITIAL).rotate(PI / 2)\n        sweep.crop_to_screen(self.camera.frame)\n        sweep.set_z_index(rect3.get_z_index() - 1 + 0.99).set_color(BLUE)\n        sweep_goal = AffineLine2D(OF_INITIAL).rotate(-PI / 2).move_to([*optimum, 0])\n        sweep_goal.set_z_index(rect3.get_z_index() - 1 + 0.99)\n        sweep_angle = Angle(sweep.line, of_arrow, dot=True).set_z_index(99).set_color(BLUE)\n        sweep.dots = VGroup()\n        sweep.add(sweep.dots)\n        sweep.lineextra = VGroup()\n        sweep.add(sweep.lineextra)\n\n        def sweep_updater(obj):\n            dots = sweep.get_area_border_intersection(area)\n            if len(dots) <= 1:\n                return\n            g = VGroup().set_z_index(100000)\n            for i in range(len(dots)):\n                for j in range(i + 1, len(dots)):\n                    d1, d2 = (dots[i], dots[j])\n                    g.add(Line(start=d1.get_center(), end=d2.get_center(), color=BLUE, stroke_width=LINE_STROKE + 2.5).set_z_index(100000))\n            sweep.lineextra.become(g).set_z_index(100000)\n            sweep.dots.become(dots).set_z_index(100000).set_color(BLUE)\n        sweep_updater(None)\n        sweep_dots_tmp = sweep.dots\n        sweep.remove(sweep.dots)\n        align_object_by_coords(VGroup(i1, i4_hp, i2, i3, i4, i5, area, numberplane, of_arrow, of_arrow_shadow, sweep, sweep_goal, sweep_angle, sweep_dots_tmp), area.dots.get_center(), guide3.get_center())\n        i1.crop_to_screen(self.camera.frame)\n        i2.crop_to_screen(self.camera.frame)\n        i3.crop_to_screen(self.camera.frame)\n        i4.crop_to_screen(self.camera.frame)\n        i5.crop_to_screen(self.camera.frame)\n        labels = VGroup(Tex('$x_p$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[0], DOWN, buff=0.33).align_to(self.camera.frame, RIGHT).shift(LEFT * 0.2).set_color(POTATO_COLOR), Tex('$x_c$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[1], LEFT, buff=0.23).align_to(self.camera.frame, UP).shift(DOWN * 0.35).set_color(CARROT_COLOR)).set_z_index(i1.get_z_index() + 1)\n        self.play(AnimationGroup(AnimationGroup(main_group.animate.shift(LEFT * theory_group.get_x() * 2), rect2.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(0), rect3.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(1), var.animate.shift(LEFT * theory_group.get_x() * 2), ineqs.animate.shift(LEFT * theory_group.get_x() * 2), exp.animate.shift(LEFT * theory_group.get_x() * 2), of.animate.shift(LEFT * theory_group.get_x() * 2), equivalenece.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(0)), lag_ratio=0.5))\n        self.play(FadeIn(numberplane.background_lines), FadeIn(numberplane.axes))\n        labels_tmp = labels.copy()\n        xptmp = var[0][10:10 + 2].copy()\n        xctmp = var[0][13:13 + 2].copy()\n        self.play(AnimationGroup(Transform(xptmp, labels_tmp[0]), Transform(xctmp, labels_tmp[1]), lag_ratio=0.25))\n        self.remove(xptmp, xctmp)\n        self.add(labels)\n        sr = SurroundingRectangle(VGroup(Dot().align_to(self.camera.frame, UP + RIGHT), Dot().align_to(self.camera.frame, DOWN + RIGHT), Dot().align_to(rect3, RIGHT)), fill_opacity=1).move_to(guide3).set_color_by_gradient((RED, GREEN)).set_opacity(0.35)\n        sr.set_sheen_direction(unit_vector(OF_INITIAL[0] * RIGHT + OF_INITIAL[1] * UP))\n        self.remove(main_group, rect2, equivalenece)\n        big_hl = CreateHighlight(ineqs)\n        hl = CreateHighlight(ineqs[0][7:7 + 7])\n        self.play(exp.animate.set_opacity(BIG_OPACITY), of.animate.set_opacity(BIG_OPACITY), FadeIn(big_hl))\n        self.play(AnimationGroup(Transform(big_hl, hl), Create(i4), lag_ratio=0.5))\n        self.remove(big_hl)\n        self.add(hl)\n        self.play(FadeIn(i4_hp))\n        self.play(AnimationGroup(FadeOut(hl), Create(i1), Create(i2), Create(i3), Create(i5), AnimationGroup(FadeOut(i4_hp), FadeIn(area)), lag_ratio=0.25))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(i1), FadeOut(i2), FadeOut(i3), FadeOut(i4), FadeOut(i5)), lag_ratio=0.5))\n        self.play(area.area.animate(rate_func=there_and_back, run_time=1.25).set_fill(BLUE, 0.5))\n        self.play(exp.animate.set_opacity(1), of.animate.set_opacity(MED_OPACITY), ineqs.animate.set_opacity(BIG_OPACITY))\n        self.add(sr)\n        thingy = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(OF_INITIAL[1], OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        self.play(AnimationGroup(thingy.animate(run_time=2).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 7), AnimationGroup(Write(of_arrow)), lag_ratio=0))\n        self.remove(thingy)\n        self.play(FadeIn(sweep), FadeIn(sweep_angle), FadeIn(sweep_dots_tmp), of_arrow.animate.set_color(BLUE))\n        sweep.add(sweep_dots_tmp)\n        dl = DashedLine(ORIGIN - 0.0001, ORIGIN + 0.0001).set_z_index(of_arrow.get_z_index() - 1e-05).set_color(BLUE)\n\n        def of_updater(obj):\n            start = of_arrow.get_start()\n            end = of_arrow.get_end()\n            point = intersection(line(start, end), line(sweep.line.get_start(), sweep.line.get_end()))\n            new_point = np.array([*point, 0])\n            of_arrow.put_start_and_end_on(new_point, new_point + np.array([*OF_INITIAL, 0]))\n            sweep_angle.become(Angle(sweep.line, of_arrow, dot=True).set_color(BLUE).set_z_index(99))\n\n        def dl_updater(obj):\n            start = of_arrow_shadow.get_start()\n            end = intersection(line(of_arrow_shadow.get_start(), of_arrow_shadow.get_end()), line(sweep.line.get_start(), sweep.line.get_end()))\n            end = np.array([*end, 0])\n            l = 0.085\n            lt = l * 2\n            dist = distance(start, end)\n            dist_rounded = int(dist / lt) * lt\n            if abs(dist) < 0.001:\n                return\n            end_rounded = (end - start) / dist * dist_rounded + start + l / 10\n            obj.become(DashedLine(end_rounded, start, dash_length=l, stroke_width=of_arrow.get_stroke_width() * 0.95).set_color(BLUE).set_z_index(of_arrow.get_z_index() - 0.0001))\n        dl.add_updater(dl_updater)\n        self.add(dl)\n        dummy = VMobject()\n        dummy.add_updater(sweep_updater)\n        dummy.add_updater(of_updater)\n        self.add(dummy)\n        self.camera.frame.save_state()\n        theory_group.save_state()\n        rect3.save_state()\n        self.play(FadeIn(of_arrow_shadow), sweep.animate(run_time=3).move_to(sweep_goal))\n        self.remove(dummy)\n        optimum = sweep.dots\n        sweep.remove(sweep.dots)\n        optimum_texts = VGroup(Tex('$1\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.8).move_to(optimum).align_to(numberplane.axes[0], UP).shift(DOWN * 0.35).set_z_index(100000), Tex('$4\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.8).move_to(optimum).align_to(numberplane.axes[1], RIGHT).shift(LEFT * 0.35).set_z_index(100000), Tex('$\\\\$8\\\\,000$').scale(0.8).next_to(optimum, UP + RIGHT).set_z_index(100000))\n        for i in range(3):\n            optimum_texts[i].add(CreateSR(optimum_texts[i]))\n        self.play(FadeIn(optimum_texts), FadeOut(sweep_angle), of_arrow.animate.set_opacity(0), ineqs.animate.set_opacity(1))\n        for i in [0, 1, 2]:\n            self.play(optimum_texts[i].animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        vm = CreateMeaning(var, '\\\\small variables $\\\\in \\\\mathbb{R}$')\n        vi = CreateMeaning(ineqs, '\\\\small s.t. linear \\\\par inequalities')\n        vo = CreateMeaning(VGroup(of, exp), '\\\\small maximizing \\\\par linear function')\n        dl.remove_updater(dl_updater)\n        self.play(FadeOut(optimum_texts), FadeOut(optimum), FadeOut(dl), FadeOut(sweep))\n        for o, rt in [(vm, 1.25), (vi, 1.5), (vo, 1.5)]:\n            self.play(AnimationGroup(FadeIn(o[0]), Write(o[1], run_time=rt), lag_ratio=0.5))\n        print('NUMBERPLANE CENTER', numberplane.get_center())\n        iextras = []\n        ipts = [[np.array([0, 0]), np.array([1, -2]), 0.5, None], [np.array([0, 0]), np.array([1, -0.5]), 0.5, None], [np.array([3, 0]), np.array([4, 1]), 0.25, None], [np.array([3, 2]), np.array([2, 3.5]), 0.25, '<='], [np.array([0, 4]), np.array([-1, 3.7]), 0.15, '<='], [np.array([0, 4]), np.array([-1, 3]), 0.15, '<='], [np.array([0, 4]), np.array([-1, 0]), 0.2, '<='], [np.array([1, 4]), np.array([0, 4.9]), 0.05, '<=']]\n        inorms = []\n        start = of_arrow_shadow.get_start()\n        for p1, p2, s, op in ipts:\n            a, b, c = Inequality2D.points_to_slope(p1, p2)\n            iq = Inequality2D(a, b, op or '>=', c).set_opacity(0).shift(of_arrow_shadow.get_start())\n            iextras.append(iq)\n            self.add(iq)\n            area.add_inequalities([iq])\n            d = p2 - p1\n            inorms.append((-d[1], d[0], 0) / np.linalg.norm(d))\n            ino = np.array((-d[1], d[0])) / np.linalg.norm(d)\n\n        def ineqs_complex_updater(obj, dt):\n            obj._update_area()\n            best_score = float('inf')\n            best_pos = None\n        self.add(area)\n        area.add_updater(ineqs_complex_updater)\n        of_arrow_shadow.save_state()\n        self.play(*[iextras[i].animate.shift(inorms[i] * ipts[i][-2]) for i in range(len(ipts))], vi[1].animate.scale(1.25), of_arrow_shadow.animate.put_start_and_end_on(np.array([1.4983125140164602, -1.627322003750033, 0.0]), np.array([1.4983125140164602, -1.627322003750033, 0.0]) + of_arrow_shadow.get_end() - of_arrow_shadow.get_start()))\n        self.play(*[iextras[i].animate.shift(-inorms[i] * ipts[i][-2] * 1.1) for i in range(len(ipts))], FadeOut(vm, vi, vo), of_arrow_shadow.animate.restore())\n        area.remove_updater(ineqs_complex_updater)\n        area.remove_inequalities(iextras)\n\n        def of_line_updater(obj):\n            vector = of_arrow_shadow.get_end() - of_arrow_shadow.get_start()\n            x, y, _ = vector\n            optimum = list(solve_farm([x, y]))\n            optimum[0] /= 1000\n            optimum[1] /= 1000\n            sweep.line.become(AffineLine2D([x, y]).line.set_color(BLUE).rotate(PI / 2).move_to(of_arrow_shadow.get_start()).shift([*optimum, 0]))\n            op = '+' if y >= 0 else '-'\n            new_exp = Tex(f'$$\\\\max\\\\ {x:.1f}x_p {op} {abs(y):.1f}x_c$$').move_to(exp).align_to(exp, DOWN)\n            new_exp[0][3:3 + 5].set_color(POTATO_COLOR)\n            new_exp[0][9:9 + 5].set_color(CARROT_COLOR)\n            exp.become(new_exp)\n        sm = Tex('\\\\underline{Simplex Method}').set_z_index(10000000000).scale(1)\n        sm.add(CreateSR(sm, buff=0.17))\n        sm.align_to(self.camera.frame, RIGHT + UP).shift((LEFT * 1.2 + DOWN) * 0.25)\n        self.play(AnimationGroup(FadeIn(sm[1]), Write(sm[0]), lag_ratio=0.2))\n        self.play(FadeIn(optimum), FadeIn(dl), FadeIn(sweep))\n        srcp = sr.copy().set_z_index(sr.get_z_index() + 0.2)\n        thingy = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(OF_INITIAL[1], OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        thingy2 = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(-OF_INITIAL[1], -OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        thingy2.shift(-unit_vector(OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 18)\n        self.add(thingy, thingy2, srcp)\n        self.play(thingy.animate(run_time=2.5).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 9), thingy2.animate(run_time=2.5).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 9))\n        self.remove(thingy, thingy2, srcp)\n        dl.add_updater(dl_updater)\n        self.play(*[MyFlash(d, color=WHITE, z_index=d.get_z_index() + 1) for d in area.dots], MyFlash(optimum, color=BLUE, z_index=optimum.get_z_index() + 2))\n\n        def sr_updater(obj):\n            vector = of_arrow_shadow.get_end() - of_arrow_shadow.get_start()\n            obj.set_sheen_direction(unit_vector(vector))\n        sr.add_updater(sr_updater)\n        dummy = VMobject()\n        dummy.add_updater(of_line_updater)\n        dummy.add_updater(sweep_updater)\n        self.add(dummy)\n        angle = atan2(OF_INITIAL[1], OF_INITIAL[0])\n        self.play(Rotate(of_arrow_shadow, -angle, about_point=of_arrow_shadow.get_start()), run_time=2)\n        self.play(*[MyFlash(d, color=BLUE, z_index=d.get_z_index() + 1) for d in sweep.dots])\n        self.play(Rotate(of_arrow_shadow, +angle - 2 * PI, about_point=of_arrow_shadow.get_start()), run_time=5)\n        self.remove(dummy)\n        sr.remove_updater(sr_updater)\n        dl.remove_updater(dl_updater)\n        self.play(FadeOut(optimum), FadeOut(dl), FadeOut(sweep))\n        fade_rect = get_fade_rect()\n        of_arrow_shadow.set_z_index(fade_rect.get_z_index() - 1e-11)\n        of_arrow_shadow_2 = of_arrow_shadow.copy().set_color(BLUE).set_z_index(fade_rect.get_z_index() + 1)\n        of_dot = Dot().scale(OPTIMUM_DOT_SCALE).set_color(BLUE).move_to(of_arrow_shadow_2.get_start()).set_z_index(of_arrow_shadow_2.get_z_index())\n        trace = TracedPath(of_dot.get_center).set_color(BLUE).set_stroke_width(8).set_z_index(area.dots[0].get_z_index() - 1e-05)\n        G = VGroup(area, of_arrow_shadow, numberplane, labels[0])\n        l0 = Line(start=of_dot.get_center(), end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())\n        p0 = Tex('pivot \\\\#1').scale(0.75).next_to(l0, DOWN).shift(RIGHT * 1.5).set_z_index(l0.get_z_index())\n        sweep.move_to(of_arrow_shadow_2.get_start())\n        sweep.remove(sweep.lineextra)\n        self.play(FadeIn(of_arrow_shadow_2), FadeIn(of_dot))\n        self.play(VGroup(of_arrow_shadow_2, of_dot).animate.shift(RIGHT * 3), l0.animate.become(Line(start=of_dot.get_center() + RIGHT * 3, end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())), FadeIn(p0, run_time=1), run_time=2)\n        l1 = Line(start=of_dot.get_center(), end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())\n        us1 = 0.5\n        p1 = Tex('pivot \\\\#2').scale(0.75).next_to(l1, RIGHT).shift(UP * (1 - us1)).set_z_index(l1.get_z_index())\n        self.play(l0.animate.shift(DOWN * us1), p0.animate.shift(DOWN * us1), l1.animate.become(Line(start=of_dot.get_center() + UP * (2 - us1), end=of_dot.get_center() + DOWN * us1, color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())), G.animate.shift(DOWN * us1), FadeIn(p1, shift=DOWN * us1, run_time=1), VGroup(of_arrow_shadow_2, of_dot).animate.shift(UP * (2 - us1)), run_time=1.5)\n        l2 = Line(start=of_dot.get_center(), end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())\n        p2 = Tex('pivot \\\\#3').scale(0.75).next_to(l2.get_center(), UP + RIGHT).shift(LEFT).set_z_index(l1.get_z_index())\n        us2 = 1\n        self.play(l2.animate.become(Line(start=of_dot.get_center() + UP * (2 - us2) + LEFT * 2, end=of_dot.get_center() + DOWN * us2, color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())), l0.animate.shift(DOWN * us2), l1.animate.shift(DOWN * us2), p0.animate.shift(DOWN * us2), p1.animate.shift(DOWN * us2), G.animate.shift(DOWN * us2), FadeIn(p2, shift=DOWN * us2, run_time=1), VGroup(of_arrow_shadow_2, of_dot).animate.shift(UP * (2 - us2) + LEFT * 2), run_time=1.5)\n        self.play(MyFlash(of_dot, color=BLUE, z_index=optimum.get_z_index() + 2))\n        self.play(VGroup(numberplane, of_arrow_shadow, area, labels[0]).animate.shift(UP * (us1 + us2)), FadeOut(of_arrow_shadow_2, of_dot, l0, l1, l2, p0, p1, p2, shift=UP * (us1 + us2)))\n        VGroup(l0, l1, l2, p0, p1, p2).shift(UP * (us1 + us2))\n        ineqs2 = Tex('$$\\\\begin{aligned}\\n        x_1, x_2  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_1 \\\\phantom{{}+ x_2} &\\\\le 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_2 &\\\\le 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_1 + x_2 &\\\\le 5\\\\,000\\n                \\\\end{aligned}$$').align_to(ineqs, UP + RIGHT)\n        exp2 = Tex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_1 + ' + str(OF_INITIAL[1]) + ' x_2$$').align_to(exp, UP + LEFT)\n        var2 = Tex('variables: $x_1, x_2$').align_to(var, UP + LEFT)\n        labels2 = VGroup(Tex('$x_1$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[0], DOWN, buff=0.33).align_to(self.camera.frame, RIGHT).shift(LEFT * 0.2), Tex('$x_2$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[1], LEFT, buff=0.23).align_to(self.camera.frame, UP).shift(DOWN * 0.35)).set_z_index(i1.get_z_index() + 1)\n        labels2[0].align_to(labels[0], UP + LEFT)\n        labels2[1].align_to(labels[1], UP + LEFT)\n        self.play(Transform(ineqs, ineqs2), Transform(exp, exp2), Transform(var, var2), Transform(labels, labels2))\n        of_arrow_shadow_2 = of_arrow_shadow.copy().set_color(BLUE).set_z_index(fade_rect.get_z_index() + 1)\n        of_dot = Dot().scale(OPTIMUM_DOT_SCALE).set_color(BLUE).move_to(of_arrow_shadow_2.get_start()).set_z_index(of_arrow_shadow_2.get_z_index())\n        hl = CreateHighlight(ineqs[0][:7])\n        self.play(FadeIn(of_dot), FadeIn(of_arrow_shadow_2), MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1))\n        i1.set_color(YELLOW).set_opacity(0)\n        i2.set_color(YELLOW).set_opacity(0)\n        i3.set_color(YELLOW).set_opacity(0)\n        i4.set_color(YELLOW).set_opacity(0)\n        i5.set_color(YELLOW).set_opacity(0)\n        self.play(FadeIn(hl), i1.animate.set_opacity(1), i2.animate.set_opacity(1))\n        val = Tex('$(0, 0)$').scale(0.6).next_to(of_dot, UP).set_z_index(10000000000)\n        val.add(CreateSR(val))\n\n        def value_updater(obj, dt):\n            c = of_dot.get_center() - of_arrow_shadow.get_start()\n            x = int(round(c[0] * 1000))\n            y = int(round(c[1] * 1000))\n\n            def fmt(x):\n                x = str(x)\n                if len(x) == 4:\n                    return f'{x[0]}\\\\,{x[1:]}'\n                return x\n            val2 = Tex(f'$({fmt(x)}, {fmt(y)})$').scale(0.6).next_to(of_dot, UP).set_z_index(10000000000)\n            val2.add(CreateSR(val2))\n            val.become(val2)\n        hl2 = CreateHighlight(ineqs[0][7:14])\n        self.play(FadeIn(val))\n        self.play(FadeIn(p0), MyFlash(of_dot.copy().shift(RIGHT * 3), color=WHITE, z_index=of_dot.get_z_index() + 1))\n        val.add_updater(value_updater)\n        a_surprise_weapon_that_will_help_us_later = VGroup(ineqs.copy(), exp.copy(), var.copy(), of.copy())\n        self.play(of_arrow_shadow_2.animate.shift(RIGHT * 1.5), of_dot.animate.shift(RIGHT * 1.5), Transform(hl, CreateHighlight(ineqs[0][3:7])), i1.animate.set_opacity(0), run_time=1.5)\n        self.play(of_arrow_shadow_2.animate.shift(RIGHT * 1.5), of_dot.animate.shift(RIGHT * 1.5), FadeIn(hl2), i4.animate.set_opacity(1), run_time=1.5)\n        G = VGroup(area, of_arrow_shadow, numberplane, labels[0])\n        i1.line.put_start_and_end_on(i1.line.get_start() + UP * 5, i1.line.get_end() + DOWN * 5)\n        i3.line.put_start_and_end_on(i3.line.get_start() + (UP + LEFT) * 5, i3.line.get_end() + (DOWN + RIGHT) * 5)\n        p1.shift(DOWN * us1)\n        p2.shift(DOWN * us1)\n        self.play(G.animate.shift(DOWN * us1), p0.animate.shift(DOWN * us1), FadeIn(p1, shift=DOWN * us1), of_arrow_shadow_2.animate.shift(UP * (2 - us1)), of_dot.animate.shift(UP * (2 - us1)), Transform(hl, CreateHighlight(ineqs[0][21:])), i2.animate.set_opacity(0).shift(DOWN * us1), i3.animate.set_opacity(1).shift(DOWN * us1), run_time=1.5)\n        i2.shift(UP * us1)\n        p2.shift(DOWN * us2)\n        i5.shift(DOWN * us1)\n        self.play(G.animate.shift(DOWN * us2), FadeIn(p2, shift=DOWN * us2), p0.animate.shift(DOWN * us2), p1.animate.shift(DOWN * us2), of_arrow_shadow_2.animate.shift(UP * (2 - us2) + LEFT * 2), of_dot.animate.shift(UP * (2 - us2) + LEFT * 2), Transform(hl2, CreateHighlight(ineqs[0][14:21])), i4.animate.set_opacity(0).shift(DOWN * us2), i5.animate.set_opacity(1).shift(DOWN * us2), i3.animate.shift(DOWN * us2), run_time=1.5)\n        val.remove_updater(value_updater)\n        self.play(AnimationGroup(MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1), val.animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE), lag_ratio=0.25))\n        self.play(G.animate.shift(UP * (us1 + us2)), i5.animate.set_opacity(0).shift(UP * (us1 + us2)), i3.animate.set_opacity(0).shift(UP * (us1 + us2)), FadeOut(hl, hl2), FadeOut(val, of_arrow_shadow_2, of_dot, p0, p1, p2, shift=UP * (us1 + us2)))\n        ineqs3 = ComplexTex('$$\\\\begin{aligned}\\n        x_1, x_2, s_1, s_2, s_3  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_1 \\\\phantom{{}+ x_2} + s_1 \\\\phantom{{} + s_2 + s_3} &= 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_2 \\\\phantom{{} + s_1} + s_2 \\\\phantom{{} + s_3} &= 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_1 + x_2 \\\\phantom{{} + s_1 + s_2} + s_3 &= 5\\\\,000\\n                \\\\end{aligned}$$').move_to(ineqs).set_z_index(ineqs.get_z_index())\n        var3 = ComplexTex('variables: $x_1, x_2, s_1, s_2, s_3$').move_to(var).set_z_index(var.get_z_index())\n        space = 2.5\n        guide4 = -guide2.get_center() + RIGHT * (space / 2)\n        of3 = of.copy()\n        exp3 = exp2.copy().move_to(exp).set_z_index(exp.get_z_index())\n        theory_group_two = VGroup(of3, exp3, ineqs3, var3).move_to(guide4)\n        i1.shift(RIGHT * space / 2)\n        i2.shift(RIGHT * space / 2)\n        i3.shift(RIGHT * space / 2)\n        i4.shift(RIGHT * space / 2)\n        i5.shift(RIGHT * space / 2)\n        of_arrow_shadow_2.shift(RIGHT * space / 2)\n        of_dot.shift(RIGHT * space / 2)\n        VGroup(of3, exp3).align_to(of, UP)\n        VGroup(var3).align_to(var, UP)\n        VGroup(ineqs3).align_to(ineqs, UP)\n        self.remove(rect3)\n        rect_large.flip().set_height(rect3.get_height()).move_to(rect3).align_to(rect3, RIGHT).set_z_index(rect3.get_z_index())\n        self.add(rect_large)\n        var3[0][16:16 + 2].set_color(ORANGE)\n        var3[0][19:19 + 2].set_color(ORANGE)\n        var3[0][22:22 + 2].set_color(ORANGE)\n        ineqs3[0][6:6 + 2].set_color(ORANGE)\n        ineqs3[0][9:9 + 2].set_color(ORANGE)\n        ineqs3[0][12:12 + 2].set_color(ORANGE)\n        ineqs3[0][19:19 + 2].set_color(ORANGE)\n        ineqs3[0][29:29 + 2].set_color(ORANGE)\n        ineqs3[0][42:42 + 2].set_color(ORANGE)\n        slack = Tex('slack').scale(0.7).set_color(ORANGE).next_to(VGroup(var3[0][16:16 + 2], var3[0][22:22 + 2]), UP, buff=0.25).set_z_index(100000000000)\n        self.play(rect_large.animate.shift(RIGHT * space), VGroup(area, of_arrow_shadow, numberplane, sr, labels[1]).animate.shift(RIGHT * space / 2), Transform(exp, exp3), Transform(of, of3), AnimationGroup(Transform(var[0][:15], var3[0][:15]), AnimationGroup(FadeIn(var3[0][15:]), FadeIn(slack)), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][:5], ineqs3[0][:5]), Transform(ineqs[0][5:5 + 2], ineqs3[0][14:14 + 2])), FadeIn(ineqs3[0][5:5 + 9]), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][7:7 + 2], ineqs3[0][16:16 + 2]), Transform(ineqs[0][9:9 + 5], ineqs3[0][21:21 + 5])), FadeIn(ineqs3[0][18:18 + 3]), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][14:14 + 2], ineqs3[0][26:26 + 2]), Transform(ineqs[0][16:16 + 5], ineqs3[0][31:31 + 5])), FadeIn(ineqs3[0][28:28 + 3]), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][21:21 + 5], ineqs3[0][36:36 + 5]), Transform(ineqs[0][26:], ineqs3[0][44:])), FadeIn(ineqs3[0][41:41 + 3]), lag_ratio=0.5))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp3, ineqs3, var3, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, slack)\n        hl = CreateHighlight(VGroup(ineqs3[0][21], ineqs3[0][31], ineqs3[0][44]))\n        a = Tex('$0$')\n        a.add(Tex('$=$').scale(0.65).rotate(PI / 2).next_to(a, UP, buff=0.1))\n        a.set_color(YELLOW).set_z_index(1000000000).next_to(var3[0][-8:-8 + 2], DOWN, buff=0.1).set_color(WHITE)\n        b = a.copy().next_to(var3[0][-2:], DOWN, buff=0.1).set_color(WHITE)\n        of_arrow_shadow_2.shift(UP * -2 + LEFT * -2)\n        of_dot.shift(UP * -2 + LEFT * -2 + UP * (us1 + us2))\n        val = Tex('$(3\\\\,000, 2\\\\,000)$').scale(0.6).next_to(of_dot, UP).set_z_index(10000000000)\n        val.add(CreateSR(val))\n        self.play(FadeIn(val), FadeIn(of_dot), MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1), i4.animate.set_opacity(1), i3.animate.set_opacity(1))\n        hl1 = CreateHighlight(ineqs3[0][16:26])\n        hl2 = CreateHighlight(ineqs3[0][36:49])\n        self.play(FadeIn(hl1), FadeIn(hl2), var3[0][16:16 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), var3[0][22:22 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), var3[0][18:18 + 1].animate.set_opacity(BIG_OPACITY), var3[0][21:21 + 1].animate.set_opacity(BIG_OPACITY), ineqs3[0][6:6 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), ineqs3[0][12:12 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), ineqs3[0][8:8 + 1].animate.set_opacity(BIG_OPACITY), ineqs3[0][11:11 + 1].animate.set_opacity(BIG_OPACITY), ineqs3[0][18:18 + 1].animate.set_opacity(BIGGER_OPACITY), ineqs3[0][19:19 + 2].animate.set_color(YELLOW).set_opacity(BIGGER_OPACITY), ineqs3[0][41:41 + 1].animate.set_opacity(BIGGER_OPACITY), ineqs3[0][42:42 + 2].animate.set_color(YELLOW).set_opacity(BIGGER_OPACITY))\n        self.play(FadeOut(hl1), FadeOut(hl2), FadeOut(of_dot), FadeOut(val), i4.animate.set_opacity(0), i3.animate.set_opacity(0), var3[0][16:16 + 2].animate.set_color(ORANGE).set_opacity(1), var3[0][22:22 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][6:6 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][12:12 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][18:18 + 1].animate.set_opacity(1), ineqs3[0][19:19 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][41:41 + 1].animate.set_opacity(1), ineqs3[0][42:42 + 2].animate.set_color(ORANGE).set_opacity(1), var3[0][18:18 + 1].animate.set_opacity(1), var3[0][21:21 + 1].animate.set_opacity(1), ineqs3[0][8:8 + 1].animate.set_opacity(1), ineqs3[0][11:11 + 1].animate.set_opacity(1))\n        of_arrow_shadow_2 = of_arrow_shadow.copy().set_color(BLUE).set_z_index(fade_rect.get_z_index() + 1)\n        of_dot = Dot().scale(OPTIMUM_DOT_SCALE).set_color(BLUE).move_to(of_arrow_shadow_2.get_start()).set_z_index(of_arrow_shadow_2.get_z_index())\n        vars_buff = 0.25\n        nonbas_vars = VGroup(var3[0][10:10 + 2].copy().set_color(YELLOW), var3[0][13:13 + 2].copy().set_color(YELLOW)).arrange(buff=vars_buff)\n        bas_vars = VGroup(var3[0][16:16 + 2].copy().set_color(ORANGE), var3[0][19:19 + 2].copy().set_color(ORANGE), var3[0][22:22 + 2].copy().set_color(ORANGE)).arrange(buff=vars_buff)\n        VGroup(nonbas_vars, bas_vars).arrange(buff=1.5).move_to(var3).align_to(var3, DOWN)\n        nonbasic = Tex('tight').scale(0.7).next_to(nonbas_vars, UP, buff=0.25).set_z_index(rect_large.get_z_index() + 1).set_opacity(0)\n        basic = Tex('loose').scale(0.7).next_to(bas_vars, UP, buff=0.25).set_z_index(rect_large.get_z_index() + 1).set_opacity(0)\n        nonbasic.align_to(basic, UP)\n        nb = Tex('non-basic').scale(0.7).set_z_index(rect_large.get_z_index() + 1).set_opacity(0).move_to(nonbasic).align_to(nonbasic, UP)\n        bb = Tex('basic').scale(0.7).set_z_index(rect_large.get_z_index() + 1).set_opacity(0).move_to(basic).align_to(nonbasic, UP)\n        self.play(FadeIn(of_dot), FadeIn(of_arrow_shadow_2), MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1))\n        self.play(Succession(Wait(0.5), AnimationGroup(ineqs3[0][0:0 + 2].animate.set_color(YELLOW), ineqs3[0][3:3 + 2].animate.set_color(YELLOW), ineqs3[0][16:16 + 2].animate.set_color(YELLOW), ineqs3[0][26:26 + 2].animate.set_color(YELLOW), ineqs3[0][36:36 + 2].animate.set_color(YELLOW), ineqs3[0][39:39 + 2].animate.set_color(YELLOW), exp3[0][6:6 + 2].animate.set_color(YELLOW), exp3[0][12:12 + 2].animate.set_color(YELLOW), i1.animate.set_opacity(1), i2.animate.set_opacity(1))), AnimationGroup(AnimationGroup(FadeOut(var3[0][:10]), FadeOut(var3[0][12]), FadeOut(var3[0][15]), FadeOut(var3[0][18]), FadeOut(var3[0][21]), FadeOut(slack)), AnimationGroup(Transform(var3[0][10:10 + 2], nonbas_vars[0]), Transform(var3[0][13:13 + 2], nonbas_vars[1]), Transform(var3[0][16:16 + 2], bas_vars[0]), Transform(var3[0][19:19 + 2], bas_vars[1]), Transform(var3[0][22:22 + 2], bas_vars[2])), AnimationGroup(basic.animate.set_opacity(MED_OPACITY), nonbasic.animate.set_opacity(MED_OPACITY)), lag_ratio=0.5))\n        nb.set_opacity(MED_OPACITY)\n        bb.set_opacity(MED_OPACITY)\n        f = 0.3\n        self.play(FadeIn(nb, shift=DOWN * f), FadeOut(nonbasic, shift=DOWN * f))\n        self.play(FadeIn(bb, shift=DOWN * f), FadeOut(basic, shift=DOWN * f))\n        self.play(FadeOut(nb, shift=UP * f), FadeIn(nonbasic, shift=UP * f), FadeOut(bb, shift=UP * f), FadeIn(basic, shift=UP * f))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp3, ineqs3, bas_vars, nonbas_vars, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i1, i2)\n        self.play(AnimationGroup(FadeOut(ineqs3[0][:16]), ineqs3[0][16:].animate.move_to(ineqs3), lag_ratio=0.25))\n        ineqs4 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 3\\\\,000 - x_1 \\\\\\\\[-0.2em]\\n              s_2 &= 4\\\\,000 \\\\phantom{{} - x_1} - x_2 \\\\\\\\[-0.2em]\\n              s_3 &= 5\\\\,000 - x_1 - x_2\\n                \\\\end{aligned}$$').move_to(ineqs3).align_to(ineqs3, DOWN).set_z_index(ineqs3.get_z_index())\n        ineqs4[0][0:0 + 2].set_color(ORANGE)\n        ineqs4[0][10:10 + 2].set_color(ORANGE)\n        ineqs4[0][20:20 + 2].set_color(ORANGE)\n        ineqs4[0][8:8 + 2].set_color(YELLOW)\n        ineqs4[0][18:18 + 2].set_color(YELLOW)\n        ineqs4[0][28:28 + 2].set_color(YELLOW)\n        ineqs4[0][31:31 + 2].set_color(YELLOW)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(ineqs3[0][18]), FadeOut(ineqs3[0][28]), FadeOut(ineqs3[0][41])), AnimationGroup(Transform(ineqs3[0][19:19 + 2 + 5], ineqs4[0][0:0 + 2 + 5]), Transform(ineqs3[0][29:29 + 2 + 5], ineqs4[0][10:10 + 2 + 5]), Transform(ineqs3[0][42:42 + 2 + 5], ineqs4[0][20:20 + 2 + 5]), Transform(ineqs3[0][16:16 + 2], ineqs4[0][8:8 + 2]), Transform(ineqs3[0][26:26 + 2], ineqs4[0][18:18 + 2]), Transform(ineqs3[0][36:36 + 5], ineqs4[0][28:28 + 5])), AnimationGroup(FadeIn(ineqs4[0][7]), FadeIn(ineqs4[0][17]), FadeIn(ineqs4[0][27])), lag_ratio=0.5), run_time=2)\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp3, ineqs4, bas_vars, nonbas_vars, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i1, i2)\n        hl = CreateHighlight(VGroup(ineqs4[0][0], ineqs4[0][-12])).set_color(BLUE)\n        hlother = CreateHighlight(bas_vars).set_color(BLUE)\n        self.play(FadeIn(hl, hlother))\n        a.next_to(nonbas_vars[0], DOWN, buff=0.1)\n        b.next_to(nonbas_vars[1], DOWN, buff=0.1)\n        hl1 = CreateHighlight(VGroup(nonbas_vars[0], a)).set_color(BLUE)\n        hl2 = CreateHighlight(VGroup(nonbas_vars[1], b)).set_color(BLUE)\n        hlof = CreateHighlight(exp3[0][3:3 + 11]).set_color(BLUE)\n        zero = Tex('$$0$$').set_z_index(exp3.get_z_index()).move_to(exp3[0][3:3 + 11])\n        self.play(AnimationGroup(AnimationGroup(FadeOut(hlother), FadeIn(zero), nonbas_vars[0].animate.set_opacity(BIG_OPACITY), nonbas_vars[1].animate.set_opacity(BIG_OPACITY), exp3[0][3:3 + 11].animate.set_opacity(BIG_OPACITY / 2), exp3[0][8].animate.set_opacity(0), ineqs4[0][7:7 + 3].animate.set_opacity(BIG_OPACITY), ineqs4[0][17:17 + 3].animate.set_opacity(BIG_OPACITY), ineqs4[0][27:27 + 3].animate.set_opacity(BIG_OPACITY), ineqs4[0][30:30 + 3].animate.set_opacity(BIG_OPACITY)), AnimationGroup(FadeIn(hlof), Transform(hl, CreateHighlight(VGroup(ineqs4[0][0], ineqs4[0][3], ineqs4[0][-7], ineqs4[0][-12])).set_color(BLUE))), lag_ratio=0))\n        self.play(FadeOut(hlof, hl, zero), exp3[0][3:3 + 11].animate.set_opacity(1), ineqs4[0][7:7 + 3].animate.set_opacity(1), ineqs4[0][17:17 + 3].animate.set_opacity(1), ineqs4[0][27:27 + 3].animate.set_opacity(1), ineqs4[0][30:30 + 3].animate.set_opacity(1), nonbas_vars[0].animate.set_opacity(1), nonbas_vars[1].animate.set_opacity(1))\n        dpivot = Tex(\"\\\\textit{Dantzig's pivot rule}\").set_width(sm[0].get_width()).next_to(sm, DOWN, buff=0).set_z_index(10000000000)\n        self.play(AnimationGroup(Transform(sm[1], CreateSR(VGroup(sm[0], dpivot), buff=0.17)), FadeIn(dpivot), lag_ratio=0.5))\n        hl1 = CreateHighlight(exp3[0][3:3 + 5]).set_color(GREEN)\n        hl2 = CreateHighlight(exp3[0][9:9 + 5]).set_color(GREEN)\n        offset = -0.05\n        dashed_x = Arrow(of_dot.get_center(), [of_arrow_shadow_2.get_end()[0] - offset, of_dot.get_center()[1], 0], stroke_width=LINE_STROKE + 0.01, buff=0).set_color(GREEN).set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        dashed_y = Arrow(of_dot.get_center(), [of_dot.get_center()[0], of_arrow_shadow_2.get_end()[1] - offset, 0], buff=0, stroke_width=LINE_STROKE + 0.01).set_color(GREEN).set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        a = of_arrow_shadow_2.copy().set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        b = of_arrow_shadow_2.copy().set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        self.play(FadeIn(hl1), FadeIn(hl2))\n        self.play(Transform(a, dashed_x), Transform(b, dashed_y), run_time=1)\n        self.remove(a, b)\n        self.add(dashed_x, dashed_y)\n        self.play(FadeOut(dashed_x), FadeOut(hl1))\n        b = VGroup(nonbas_vars[1].copy(), bas_vars[0].copy(), bas_vars[1].copy(), bas_vars[2].copy())\n        b.arrange(buff=vars_buff)\n        b.move_to(bas_vars)\n        b[0].set_color(WHITE)\n        nb = VGroup(nonbas_vars[0].copy())\n        nb.move_to(nonbas_vars)\n        downshift = 1\n        self.play(AnimationGroup(FadeOut(dashed_y, shift=UP + DOWN * downshift), of_dot.animate.shift(UP + DOWN * downshift), of_arrow_shadow_2.animate.shift(UP + DOWN * downshift).set_opacity(1), i2.animate.set_opacity(0).shift(DOWN * downshift), of_arrow_shadow.animate.shift(DOWN * downshift), labels[0].animate.shift(DOWN * downshift), numberplane.animate.shift(DOWN * downshift), area.animate.shift(DOWN * downshift), FadeOut(hl2), Transform(nonbas_vars[0], nb[0]), Transform(nonbas_vars[1], b[0]), Transform(bas_vars[0], b[1]), Transform(bas_vars[1], b[2]), Transform(bas_vars[2], b[3]), ineqs4[0][18:18 + 2].animate.set_color(WHITE), ineqs4[0][31:31 + 2].animate.set_color(WHITE), exp3[0][-2:].animate.set_color(WHITE)))\n        self.remove(nonbas_vars[0], nonbas_vars[1])\n        self.remove(bas_vars[0], bas_vars[1], bas_vars[2])\n        self.add(b, nb)\n        nonbas_vars = nb\n        bas_vars = b\n        POSSIBLE_COLOR = GRAY\n        i3.set_color(POSSIBLE_COLOR).shift(DOWN * downshift)\n        i5.set_color(POSSIBLE_COLOR).shift(DOWN * downshift)\n        inter = intersection(line(i3.line.get_start(), i3.line.get_end()), line(i1.line.get_start(), i1.line.get_end()))\n        idot = area.dots[0].copy().move_to([*inter, 0])\n        inter = intersection(line(i5.line.get_start(), i5.line.get_end()), line(i1.line.get_start(), i1.line.get_end()))\n        idot_correct = area.dots[0].copy().move_to([*inter, 0]).set_z_index(area.dots[0].get_z_index() + 1)\n        hls2 = CreateHighlight(ineqs4[0][10:10 + 2]).set_color(POSSIBLE_COLOR)\n        hls3 = CreateHighlight(ineqs4[0][20:20 + 2]).set_color(POSSIBLE_COLOR)\n        hl1 = CreateHighlight(ineqs4[0][13:13 + 4]).set_color(POSSIBLE_COLOR)\n        hl2 = CreateHighlight(ineqs4[0][17:17 + 3]).set_color(POSSIBLE_COLOR)\n        hl3 = CreateHighlight(ineqs4[0][23:23 + 4]).set_color(POSSIBLE_COLOR)\n        hl4 = CreateHighlight(ineqs4[0][30:30 + 3]).set_color(POSSIBLE_COLOR)\n        self.play(AnimationGroup(FadeIn(hl2), FadeIn(hl4), lag_ratio=0.07))\n        self.play(AnimationGroup(AnimationGroup(ineqs4[0][10:10 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[2].animate.set_color(POSSIBLE_COLOR), i3.animate.set_opacity(1), FadeIn(hls2)), AnimationGroup(ineqs4[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[3].animate.set_color(POSSIBLE_COLOR), i5.animate.set_opacity(1), FadeIn(idot, hls3)), lag_ratio=0.07))\n        self.add(idot_correct)\n        G = VGroup(i5, i3, i1, labels[0], area, numberplane, of_arrow_shadow, of_dot, of_arrow_shadow_2, idot, idot_correct)\n        G.save_state()\n        labels[1].save_state()\n        self.play(G.animate.scale(1.75, about_point=idot_correct.get_center() + UP * 3).shift(RIGHT * 0.8), labels[1].animate.scale(1.75, about_point=idot_correct.get_center() + UP * 3).shift(RIGHT * 0.8))\n        self.play(ineqs4[0][10:10 + 2].animate.set_color(GREEN), bas_vars[2].animate.set_color(GREEN), i5.line.animate.set_color(GREEN).set_stroke_width(LINE_STROKE + 3), hls2.animate.set_color(GREEN), idot_correct.animate.set_color(GREEN), hl2.animate.set_color(GREEN), ineqs4[0][20:20 + 2].animate.set_color(RED), bas_vars[3].animate.set_color(RED), i3.line.animate.set_color(RED).set_stroke_width(LINE_STROKE + 3), hls3.animate.set_color(RED), idot.animate.set_color(RED), hl4.animate.set_color(RED))\n        correct = Tex('valid', color=GREEN).scale(0.85).set_z_index(idot.get_z_index()).next_to(idot_correct, LEFT + UP, buff=0.1)\n        oob = Tex('out of bounds', color=RED).scale(0.85).set_z_index(idot.get_z_index()).next_to(idot, RIGHT + UP, buff=0.1)\n        self.play(AnimationGroup(AnimationGroup(MyFlash(idot_correct, color=GREEN, z_index=idot_correct.get_z_index() + 1), FadeIn(correct)), AnimationGroup(MyFlash(idot, color=RED, z_index=idot_correct.get_z_index() + 1), FadeIn(oob)), lag_ratio=0.75))\n        self.play(FadeOut(correct), FadeOut(oob))\n        self.play(G.animate.restore(), labels[1].animate.restore(), ineqs4[0][10:10 + 2].animate.set_color(POSSIBLE_COLOR), ineqs4[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[2].animate.set_color(POSSIBLE_COLOR), bas_vars[3].animate.set_color(POSSIBLE_COLOR), hls2.animate.set_color(POSSIBLE_COLOR), hls3.animate.set_color(POSSIBLE_COLOR), hl2.animate.set_color(POSSIBLE_COLOR), hl4.animate.set_color(POSSIBLE_COLOR))\n        t1 = Tex('${} - 1\\\\,000$').set_z_index(ineqs4.get_z_index() + 1)\n        t1[0][1:].set_color(BLUE)\n        align_object_by_coords(t1, t1[0][0].get_center(), ineqs4[0][17].get_center())\n        t2 = Tex('${} - 1\\\\,000$').set_z_index(ineqs4.get_z_index() + 1)\n        t2[0][1:].set_color(BLUE)\n        align_object_by_coords(t2, t2[0][0].get_center(), ineqs4[0][30].get_center())\n        tmp1 = of_dot.copy()\n        tmp2 = of_dot.copy()\n        (ineqs4[0][18:18 + 2].set_opacity(0),)\n        (ineqs4[0][31:38 + 2].set_opacity(0),)\n        a = ineqs4[0][18:18 + 2].copy().set_opacity(1)\n        b = ineqs4[0][31:38 + 2].copy().set_opacity(1)\n        a.save_state()\n        b.save_state()\n        self.play(AnimationGroup(AnimationGroup(FadeOut(hl2), FadeOut(hl4)), AnimationGroup(Transform(tmp1, t1[0][1:]), Transform(tmp2, t2[0][1:]), a.animate.next_to(t1, RIGHT + DOWN, buff=0.015).shift(UP * 0.13).set_opacity(0.4).scale(0.7), b.animate.next_to(t2, RIGHT + DOWN, buff=0.015).shift(UP * 0.13).set_opacity(0.4).scale(0.7)), lag_ratio=0.5))\n        self.remove(tmp1, tmp2)\n        self.add(t1, t2)\n        ineqs4[0][17].set_opacity(0)\n        ineqs4[0][30].set_opacity(0)\n\n        def tupdater(obj, dt):\n            val = round((of_dot.get_center() - of_arrow_shadow.get_start())[1] * 1000)\n            tt1 = Tex('${} - ' + str(val)[0] + '\\\\,' + str(val)[1:] + '$').set_z_index(ineqs4.get_z_index() + 1)\n            tt1[0][1:].set_color(BLUE)\n            align_object_by_coords(tt1, tt1[0][0].get_center(), ineqs4[0][17].get_center())\n            obj.become(tt1)\n\n        def tupdater2(obj, dt):\n            val = round((of_dot.get_center() - of_arrow_shadow.get_start())[1] * 1000)\n            tt1 = Tex('${} - ' + str(val)[0] + '\\\\,' + str(val)[1:] + '$').set_z_index(ineqs4.get_z_index() + 1)\n            tt1[0][1:].set_color(BLUE)\n            align_object_by_coords(tt1, tt1[0][0].get_center(), ineqs4[0][30].get_center())\n            obj.become(tt1)\n        t1.add_updater(tupdater)\n        t2.add_updater(tupdater2)\n        downshift = 1.5\n        self.play(of_dot.animate.shift(UP * (3 - downshift)), of_arrow_shadow_2.animate.shift(UP * (3 - downshift)), VGroup(i3, i5, of_arrow_shadow, area, numberplane, labels[0], idot, idot_correct).animate.shift(DOWN * downshift), run_time=3)\n        t1.remove_updater(tupdater)\n        t2.remove_updater(tupdater2)\n        tupdater(t1, 0)\n        tupdater2(t2, 0)\n        self.remove(idot_correct)\n        hlll = CreateHighlight(VGroup(ineqs4[0][13:13 + 4], t1)).set_color(YELLOW)\n        self.play(bas_vars[2].animate.set_color(YELLOW), ineqs4[0][10:10 + 2].animate.set_color(YELLOW), ineqs4[0][20:20 + 2].animate.set_color(ORANGE), i5.animate.set_color(YELLOW), FadeIn(hlll), FadeOut(i3, idot), FadeOut(hls2, hls3))\n        t1.add_updater(tupdater)\n        t2.add_updater(tupdater2)\n        self.play(of_dot.animate.shift(UP * 0.5).set_color(RED), of_arrow_shadow_2.animate.shift(UP * 0.5).set_color(RED), hlll.animate.set_color(RED), run_time=1)\n        hls2.set_color(RED)\n        self.play(FadeIn(hls2))\n        self.play(of_dot.animate.shift(DOWN * 0.5).set_color(BLUE), of_arrow_shadow_2.animate.shift(DOWN * 0.5).set_color(BLUE), hlll.animate.set_color(YELLOW), FadeOut(hls2), run_time=1)\n        hls2.set_color(POSSIBLE_COLOR)\n        t1.remove_updater(tupdater)\n        t2.remove_updater(tupdater2)\n        self.play(bas_vars[2].animate.set_color(POSSIBLE_COLOR), ineqs4[0][10:10 + 2].animate.set_color(POSSIBLE_COLOR), ineqs4[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), i5.animate.set_color(POSSIBLE_COLOR), FadeOut(hlll), FadeIn(i3, idot), FadeIn(hls2, hls3), FadeOut(t1[0][1:]), FadeOut(t2[0][1:]), Succession(Wait(0.5), AnimationGroup(AnimationGroup(Transform(a, ineqs4[0][18:18 + 2].copy().set_opacity(1)), Transform(b, ineqs4[0][31:31 + 2].copy().set_opacity(1))), AnimationGroup(FadeIn(hl2), FadeIn(hl4)), lag_ratio=0.5)))\n        self.remove(t1, t2)\n        t1.set_opacity(0)\n        t1[0][0].set_opacity(0)\n        t2.set_opacity(0)\n        t2[0][0].set_opacity(0)\n        ineqs4[0][17:17 + 1].set_opacity(1)\n        ineqs4[0][30:30 + 1].set_opacity(1)\n        ineqs4[0][18:18 + 2].set_opacity(1)\n        ineqs4[0][31:31 + 2].set_opacity(1)\n        self.remove(a, b)\n        four = Tex('$-4\\\\,000$').move_to(hl1).align_to(ineqs4, RIGHT).shift(RIGHT * 0.5).set_z_index(ineqs4.get_z_index() + 1)\n        five = Tex('$-5\\\\,000$').move_to(hl3).align_to(ineqs4, RIGHT).shift(RIGHT * 0.5).set_z_index(ineqs4.get_z_index() + 1)\n        ff = VGroup(four, five).scale(0.9).arrange(RIGHT, buff=0.6).next_to(ineqs4, UP, buff=0.5)\n        gt = Tex('$>$', stroke_width=1.5).scale(0.5).move_to(VGroup(four, five)).set_z_index(ineqs4.get_z_index() + 1)\n        a = ineqs4[0][13:13 + 4].copy()\n        b = ineqs4[0][23:23 + 4].copy()\n        am = ineqs4[0][17:17 + 1].copy()\n        bm = ineqs4[0][30:30 + 1].copy()\n        ah = CreateHighlight(four).set_color(POSSIBLE_COLOR)\n        bh = CreateHighlight(five).set_color(POSSIBLE_COLOR)\n        self.play(AnimationGroup(AnimationGroup(Transform(a, four[0][1:]), Transform(am, four[0][0]), FadeIn(ah)), AnimationGroup(Transform(b, five[0][1:]), Transform(bm, five[0][0]), FadeIn(bh)), lag_ratio=0.25))\n        self.remove(a, am, b, bm)\n        self.add(four, five)\n        self.play(FadeIn(gt), ah.animate.set_color(GREEN), bh.animate.set_color(RED), ineqs4[0][10:10 + 2].animate.set_color(GREEN), bas_vars[2].animate.set_color(GREEN), i5.line.animate.set_color(GREEN), hls2.animate.set_color(GREEN), hl2.animate.set_color(GREEN), ineqs4[0][20:20 + 2].animate.set_color(RED), bas_vars[3].animate.set_color(RED), i3.line.animate.set_color(RED), hls3.animate.set_color(RED), idot.animate.set_color(RED), hl4.animate.set_color(RED))\n        nb = VGroup(nonbas_vars[0].copy(), bas_vars[2].copy().set_color(YELLOW))\n        nb.arrange(buff=vars_buff)\n        nb.move_to(nonbas_vars)\n        b = VGroup(bas_vars[0].copy(), bas_vars[1].copy(), bas_vars[3].copy().set_color(ORANGE))\n        b.arrange(buff=vars_buff)\n        b.move_to(bas_vars)\n        self.play(FadeOut(five, bh, hl4, hls3), FadeOut(i3), FadeOut(gt), FadeOut(idot), ineqs4[0][20:20 + 2].animate.set_color(ORANGE))\n        self.play(Transform(nonbas_vars[0], nb[0]), Transform(bas_vars[2], nb[1]), Transform(bas_vars[0], b[0]), Transform(bas_vars[1], b[1]), Transform(bas_vars[3], b[2]), ineqs4[0][10:10 + 2].animate.set_color(YELLOW), FadeOut(four, ah, hl2, hls2), i5.animate.set_color(YELLOW))\n        self.next_section()\n        six = Tex('largest non-positive ratio').set_z_index(ineqs4.get_z_index() + 1).scale(0.9).next_to(ineqs4, UP, buff=0.5)\n        ch = CreateHighlight(six).set_color(POSSIBLE_COLOR)\n        VGroup(hl1, hl2, hl3, hl4).set_color(POSSIBLE_COLOR)\n        self.play(Write(six, run_time=1.5), FadeIn(ch), FadeIn(hl1, hl2, hl3, hl4))\n        self.play(FadeOut(six), FadeOut(ch), FadeOut(hl1, hl2, hl3, hl4))"}]}
{"messages": [{"role": "user", "content": "Visualize the steps of solving a linear programming problem, from defining the farmer's problem to graphing the feasible region and optimizing the objective function."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TransparentFarmerBandaid(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.next_section(skip_animations=True)\n        farm = ImageMobject('assets/midjourney/farm-12-16-out.png').set_height(self.camera.frame.get_height()).align_to(self.camera.frame, LEFT).set_z_index(5)\n        rect = ImageMobject('assets/midjourney/farm-12-16-rect.png').set_height(self.camera.frame.get_height()).align_to(farm, RIGHT).set_z_index(6)\n        rect_large = ImageMobject('assets/midjourney/farm-12-16-rect-large.png')\n        rect_small = ImageMobject('assets/midjourney/farm-12-16-rect-small.png').set_height(self.camera.frame.get_height()).align_to(farm, RIGHT).set_z_index(6)\n        farm.save_state()\n        rect.save_state()\n        icon_scale = 1.65\n        carrot = ImageMobject('assets/midjourney/carrot-cropped-flopped.png').set_height(0.45 * icon_scale)\n        potato = ImageMobject('assets/midjourney/potato-cropped.png').set_height(0.3 * icon_scale)\n        fertilizer = ImageMobject('assets/midjourney/fertilizer-cropped-flopped.png').set_height(0.3 * icon_scale)\n        farmer = ImageMobject('assets/midjourney/farmer-outline.png').set_z_index(10).set_height(1.05)\n        farmer_black = ImageMobject('assets/midjourney/farmer-black.png').set_z_index(9).set_height(1.05)\n        self.add(rect, farm)\n        fc = farm.copy()\n        farm.move_to(Dot().next_to(self.camera.frame, LEFT))\n        offset = 1\n        rect_played = rect.copy().next_to(fc, RIGHT, buff=0).shift(LEFT * offset * 2)\n        farm_played = farm.align_to(self.camera.frame, LEFT).shift(LEFT * offset)\n        title = Tex(\"\\\\underline{Farmer's Problem}\").scale(1.5)\n        goal = Tex('Goal: \\\\it maximize profit').scale(1.25)\n        points = VGroup(Tex('\\\\begin{itemize} \\\\item $3$ tons of potato seeds \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $4$ tons of carrot seeds \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $5$ tons of fertilizer (used 1:1) \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item ' + str(OF_INITIAL[0]) + '\\\\$/kg for O, ' + str(OF_INITIAL[1]) + '\\\\$/kg for O \\\\end{itemize}'))\n        for i in range(3):\n            align_object_by_coords(points[i + 1], points[i + 1][0][0], points[0][0][0])\n            points[i + 1].shift(DOWN * 0.75 * (i + 1))\n            if i == 2:\n                points[i + 1].shift(DOWN * 0.3)\n        guide = Dot().move_to(VGroup(Dot().align_to(rect_played, LEFT), Dot().align_to(self.camera.frame, RIGHT)))\n        potato.next_to(points[0][0][-1], RIGHT)\n        carrot.next_to(points[1][0][-1], RIGHT)\n        fertilizer.next_to(points[2][0][-1], RIGHT)\n        p2 = potato.copy().move_to(points[3][0][11])\n        c2 = carrot.copy().move_to(points[3][0][-1]).shift(RIGHT * 0.1)\n        points[3][0][11].scale(0.001).set_color(BLACK).set_opacity(0).set_z_index(-1)\n        points[3][0][-1].scale(0.001).set_color(BLACK).set_opacity(0).set_z_index(-1)\n        points[0][0][1].set_color(POTATO_COLOR)\n        points[1][0][1].set_color(CARROT_COLOR)\n        points[2][0][1].set_color(FERTILIZER_COLOR)\n        points[0][0][8:13 + 1].set_color(POTATO_COLOR)\n        points[1][0][8:13 + 1].set_color(CARROT_COLOR)\n        points[2][0][8:17 + 1].set_color(FERTILIZER_COLOR)\n        points[3][0][1:7 + 1].set_color(POTATO_COLOR)\n        points[3][0][13:19 + 1].set_color(CARROT_COLOR)\n        main_group = Group(Group(title, farmer).arrange(buff=0.4), Group(points, p2, c2, carrot, potato, fertilizer), goal).arrange(DOWN, buff=0.7).move_to(guide).set_z_index(10)\n        title.set_z_index(7)\n        farmer_copy = farmer.copy().move_to(title[0][0]).align_to(farmer, DOWN).set_opacity(0).set_z_index(1000)\n        farmer_black.move_to(farmer).set_z_index(999)\n        farmer_black_copy = farmer_black.copy().move_to(title[0][0]).align_to(farmer, DOWN).set_z_index(999)\n        sr1 = SurroundingRectangle(title, color=BLACK, fill_opacity=1).set_z_index(8)\n        sr2 = SurroundingRectangle(title, color=BLACK, fill_opacity=1).set_z_index(9).move_to(farmer_copy).align_to(Dot().move_to(farmer_copy), LEFT)\n        self.add(sr1, title)\n        self.play(rect.animate.next_to(fc, RIGHT, buff=0).shift(LEFT * offset * 2), farm.animate.align_to(self.camera.frame, LEFT).shift(LEFT * offset), ReplacementTransform(farmer_copy, farmer), ReplacementTransform(farmer_black_copy, farmer_black), FadeOut(sr1), sr2.animate.align_to(Dot().move_to(farmer), LEFT), run_time=2)\n        self.remove(farmer_black, sr2)\n        self.play(AnimationGroup(Write(points[0], run_time=1.25), FadeIn(potato, shift=0.1 * RIGHT), lag_ratio=0.5))\n        self.play(AnimationGroup(Write(points[1], run_time=1.25), FadeIn(carrot, shift=0.1 * RIGHT), lag_ratio=0.5))\n        self.play(Write(points[2][0][:17 + 1], run_time=1))\n        self.play(AnimationGroup(Write(points[2][0][17 + 1:], run_time=0.65), FadeIn(fertilizer, shift=0.1 * RIGHT), lag_ratio=0.3))\n        self.play(AnimationGroup(Write(points[3][0][:12 + 1]), FadeIn(p2, run_time=0.5), lag_ratio=0.5))\n        self.play(AnimationGroup(Write(points[3][0][12 + 1:]), FadeIn(c2, run_time=0.5), lag_ratio=0.5))\n        self.play(Write(goal[0][:5]), run_time=0.65)\n        self.play(Write(goal[0][5:]), run_time=1)\n        saved_x = (main_group.animate.set_x(0),)\n        rect2 = rect_small.copy().flip().align_to(self.camera.frame, RIGHT).shift(RIGHT * 0.1)\n        self.add(rect2)\n        offset2 = 0.5\n        equivalenece = SVGMobject('assets/iff.svg').set_height(0.6).set_z_index(10)\n        equivalenece.move_to(Dot().align_to(self.camera.frame, RIGHT))\n        equivalenece.set_opacity(0).shift(RIGHT * (0.65 - offset2))\n        self.play(rect.animate.restore(), farm.animate.restore(), main_group.animate.set_x(-main_group.get_x() - offset2 / 2), rect2.animate.shift(LEFT * (main_group.get_x() * 2 + offset2)), equivalenece.animate.shift(LEFT * (main_group.get_x() * 2 + offset2)).set_opacity(1))\n        guide2 = Dot().move_to(VGroup(Dot().move_to(equivalenece), Dot().align_to(self.camera.frame, RIGHT)))\n        var = ComplexTex('variables: $x_p, x_c$')\n        var[0][-5:-3].set_color(POTATO_COLOR)\n        var[0][-2:].set_color(CARROT_COLOR)\n        ineqs = ComplexTex('$$\\\\begin{aligned}\\n        x_p, x_c  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_p \\\\phantom{{}+ x_c} &\\\\le 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_c &\\\\le 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_p + x_c &\\\\le 5\\\\,000\\n                \\\\end{aligned}$$')\n        ineqs[0][0:2].set_color(POTATO_COLOR)\n        ineqs[0][3:3 + 2].set_color(CARROT_COLOR)\n        ineqs[0][7:7 + 2].set_color(POTATO_COLOR)\n        ineqs[0][10].set_color(POTATO_COLOR)\n        ineqs[0][11].set_color(POTATO_COLOR)\n        ineqs[0][12].set_color(POTATO_COLOR)\n        ineqs[0][13].set_color(POTATO_COLOR)\n        ineqs[0][14:14 + 2].set_color(CARROT_COLOR)\n        ineqs[0][17].set_color(CARROT_COLOR)\n        ineqs[0][18].set_color(CARROT_COLOR)\n        ineqs[0][19].set_color(CARROT_COLOR)\n        ineqs[0][20].set_color(CARROT_COLOR)\n        ineqs[0][21:21 + 2].set_color(POTATO_COLOR)\n        ineqs[0][24:24 + 2].set_color(CARROT_COLOR)\n        ineqs[0][27].set_color(FERTILIZER_COLOR)\n        ineqs[0][28].set_color(FERTILIZER_COLOR)\n        ineqs[0][29].set_color(FERTILIZER_COLOR)\n        ineqs[0][30].set_color(FERTILIZER_COLOR)\n        exp = ComplexTex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_p + ' + str(OF_INITIAL[1]) + ' x_c$$')\n        exp[0][3:3 + 5].set_color(POTATO_COLOR)\n        exp[0][-5:].set_color(CARROT_COLOR)\n        of = Tex('objective function').set_opacity(MED_OPACITY).scale(0.75)\n        theory_group = Group(var, ineqs, exp).arrange(DOWN, buff=0.75).move_to(guide2).set_z_index(10)\n        var.align_to(title, DOWN)\n        exp.align_to(goal, UP)\n        self.play(AnimationGroup(AnimationGroup(points[2].animate.set_opacity(BIG_OPACITY), points[3].animate.set_opacity(BIG_OPACITY), fertilizer.animate.set_opacity(BIG_OPACITY), p2.animate.set_opacity(BIG_OPACITY), c2.animate.set_opacity(BIG_OPACITY), goal.animate.set_opacity(BIG_OPACITY)), Write(var, run_time=1.25), lag_ratio=0.5))\n        self.play(Write(ineqs[0][:7]), run_time=1.25)\n        self.play(Write(ineqs[0][7:21]), run_time=1.5)\n        self.play(AnimationGroup(AnimationGroup(points[0].animate.set_opacity(BIG_OPACITY), points[1].animate.set_opacity(BIG_OPACITY), potato.animate.set_opacity(BIG_OPACITY), carrot.animate.set_opacity(BIG_OPACITY), points[2].animate.set_opacity(1), fertilizer.animate.set_opacity(1)), Write(ineqs[0][21:], run_time=1), lag_ratio=0.5))\n        self.play(AnimationGroup(AnimationGroup(points[2].animate.set_opacity(BIG_OPACITY), fertilizer.animate.set_opacity(BIG_OPACITY), points[3].animate.set_opacity(1), p2.animate.set_opacity(1), c2.animate.set_opacity(1), goal.animate.set_opacity(1)), lag_ratio=0.5))\n        self.play(Write(exp, run_time=1.5))\n        g = VGroup(exp.copy(), of).arrange(UP, buff=0.15).move_to(exp)\n        self.play(Transform(exp, g[0]), FadeIn(of, shift=UP * 0.15))\n        self.play(points.animate.set_opacity(1), carrot.animate.set_opacity(1), potato.animate.set_opacity(1), fertilizer.animate.set_opacity(1))\n        theory_group.add(of)\n        of.set_z_index(10)\n        self.remove(rect, farm)\n        rect3 = rect.copy().flip().align_to(self.camera.frame, RIGHT).set_z_index(rect2.get_z_index() - 1).shift(RIGHT * 0.1)\n        self.add(rect3)\n        guide3 = Dot().move_to(main_group)\n        guide3.set_x(-guide3.get_x())\n        numberplane = NumberPlane(x_range=(-3 * 7.111111111111111, 3 * 7.111111111111111, 1), y_range=(-3 * 4.0, 3 * 4.0, 1), stroke_width=6, axis_config={'stroke_width': 4}, background_line_style={'stroke_color': GRAY, 'stroke_width': 3, 'stroke_opacity': 0.6})\n        numberplane.background_lines.set_z_index(rect3.get_z_index() - 1 + 0.1)\n        numberplane.axes.set_z_index(rect3.get_z_index() - 1 + 0.2)\n        area = FeasibleArea2D(dots_z_index=rect3.get_z_index() - 1 + 0.99).set_z_index(rect3.get_z_index() - 1 + 0.4)\n        i1 = Inequality2D(1, 0, '>=', 0).set_color(POTATO_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i2 = Inequality2D(0, 1, '>=', 0).set_color(CARROT_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i3 = Inequality2D(1, 1, '<=', 5).set_color(FERTILIZER_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i4 = Inequality2D(1, 0, '<=', 3).set_color(POTATO_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i5 = Inequality2D(0, 1, '<=', 4).set_color(CARROT_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i4_hp = i4.get_half_plane()\n        area.add_inequalities([i1, i2, i3, i4, i5])\n        of_arrow = Arrow(start=ORIGIN, end=np.array((*OF_INITIAL, 0)), buff=0).set_z_index(area.dots_z_index - 0.01)\n        of_arrow_shadow = of_arrow.copy().set_color(WHITE).set_z_index(of_arrow.get_z_index() - 1e-06)\n        optimum = list(solve_farm(OF_INITIAL))\n        optimum[0] /= 1000\n        optimum[1] /= 1000\n        sweep = AffineLine2D(OF_INITIAL).rotate(PI / 2)\n        sweep.crop_to_screen(self.camera.frame)\n        sweep.set_z_index(rect3.get_z_index() - 1 + 0.99).set_color(BLUE)\n        sweep_goal = AffineLine2D(OF_INITIAL).rotate(-PI / 2).move_to([*optimum, 0])\n        sweep_goal.set_z_index(rect3.get_z_index() - 1 + 0.99)\n        sweep_angle = Angle(sweep.line, of_arrow, dot=True).set_z_index(99).set_color(BLUE)\n        sweep.dots = VGroup()\n        sweep.add(sweep.dots)\n        sweep.lineextra = VGroup()\n        sweep.add(sweep.lineextra)\n\n        def sweep_updater(obj):\n            dots = sweep.get_area_border_intersection(area)\n            if len(dots) <= 1:\n                return\n            g = VGroup().set_z_index(100000)\n            for i in range(len(dots)):\n                for j in range(i + 1, len(dots)):\n                    d1, d2 = (dots[i], dots[j])\n                    g.add(Line(start=d1.get_center(), end=d2.get_center(), color=BLUE, stroke_width=LINE_STROKE + 2.5).set_z_index(100000))\n            sweep.lineextra.become(g).set_z_index(100000)\n            sweep.dots.become(dots).set_z_index(100000).set_color(BLUE)\n        sweep_updater(None)\n        sweep_dots_tmp = sweep.dots\n        sweep.remove(sweep.dots)\n        align_object_by_coords(VGroup(i1, i4_hp, i2, i3, i4, i5, area, numberplane, of_arrow, of_arrow_shadow, sweep, sweep_goal, sweep_angle, sweep_dots_tmp), area.dots.get_center(), guide3.get_center())\n        i1.crop_to_screen(self.camera.frame)\n        i2.crop_to_screen(self.camera.frame)\n        i3.crop_to_screen(self.camera.frame)\n        i4.crop_to_screen(self.camera.frame)\n        i5.crop_to_screen(self.camera.frame)\n        labels = VGroup(Tex('$x_p$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[0], DOWN, buff=0.33).align_to(self.camera.frame, RIGHT).shift(LEFT * 0.2).set_color(POTATO_COLOR), Tex('$x_c$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[1], LEFT, buff=0.23).align_to(self.camera.frame, UP).shift(DOWN * 0.35).set_color(CARROT_COLOR)).set_z_index(i1.get_z_index() + 1)\n        self.play(AnimationGroup(AnimationGroup(main_group.animate.shift(LEFT * theory_group.get_x() * 2), rect2.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(0), rect3.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(1), var.animate.shift(LEFT * theory_group.get_x() * 2), ineqs.animate.shift(LEFT * theory_group.get_x() * 2), exp.animate.shift(LEFT * theory_group.get_x() * 2), of.animate.shift(LEFT * theory_group.get_x() * 2), equivalenece.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(0)), lag_ratio=0.5))\n        self.play(FadeIn(numberplane.background_lines), FadeIn(numberplane.axes))\n        labels_tmp = labels.copy()\n        xptmp = var[0][10:10 + 2].copy()\n        xctmp = var[0][13:13 + 2].copy()\n        self.play(AnimationGroup(Transform(xptmp, labels_tmp[0]), Transform(xctmp, labels_tmp[1]), lag_ratio=0.25))\n        self.remove(xptmp, xctmp)\n        self.add(labels)\n        sr = SurroundingRectangle(VGroup(Dot().align_to(self.camera.frame, UP + RIGHT), Dot().align_to(self.camera.frame, DOWN + RIGHT), Dot().align_to(rect3, RIGHT)), fill_opacity=1).move_to(guide3).set_color_by_gradient((RED, GREEN)).set_opacity(0.35)\n        sr.set_sheen_direction(unit_vector(OF_INITIAL[0] * RIGHT + OF_INITIAL[1] * UP))\n        self.remove(main_group, rect2, equivalenece)\n        big_hl = CreateHighlight(ineqs)\n        hl = CreateHighlight(ineqs[0][7:7 + 7])\n        self.play(exp.animate.set_opacity(BIG_OPACITY), of.animate.set_opacity(BIG_OPACITY), FadeIn(big_hl))\n        self.play(AnimationGroup(Transform(big_hl, hl), Create(i4), lag_ratio=0.5))\n        self.remove(big_hl)\n        self.add(hl)\n        self.play(FadeIn(i4_hp))\n        self.play(AnimationGroup(FadeOut(hl), Create(i1), Create(i2), Create(i3), Create(i5), AnimationGroup(FadeOut(i4_hp), FadeIn(area)), lag_ratio=0.25))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(i1), FadeOut(i2), FadeOut(i3), FadeOut(i4), FadeOut(i5)), lag_ratio=0.5))\n        self.play(area.area.animate(rate_func=there_and_back, run_time=1.25).set_fill(BLUE, 0.5))\n        self.play(exp.animate.set_opacity(1), of.animate.set_opacity(MED_OPACITY), ineqs.animate.set_opacity(BIG_OPACITY))\n        self.add(sr)\n        thingy = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(OF_INITIAL[1], OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        self.play(AnimationGroup(thingy.animate(run_time=2).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 7), AnimationGroup(Write(of_arrow)), lag_ratio=0))\n        self.remove(thingy)\n        self.play(FadeIn(sweep), FadeIn(sweep_angle), FadeIn(sweep_dots_tmp), of_arrow.animate.set_color(BLUE))\n        sweep.add(sweep_dots_tmp)\n        dl = DashedLine(ORIGIN - 0.0001, ORIGIN + 0.0001).set_z_index(of_arrow.get_z_index() - 1e-05).set_color(BLUE)\n\n        def of_updater(obj):\n            start = of_arrow.get_start()\n            end = of_arrow.get_end()\n            point = intersection(line(start, end), line(sweep.line.get_start(), sweep.line.get_end()))\n            new_point = np.array([*point, 0])\n            of_arrow.put_start_and_end_on(new_point, new_point + np.array([*OF_INITIAL, 0]))\n            sweep_angle.become(Angle(sweep.line, of_arrow, dot=True).set_color(BLUE).set_z_index(99))\n\n        def dl_updater(obj):\n            start = of_arrow_shadow.get_start()\n            end = intersection(line(of_arrow_shadow.get_start(), of_arrow_shadow.get_end()), line(sweep.line.get_start(), sweep.line.get_end()))\n            end = np.array([*end, 0])\n            l = 0.085\n            lt = l * 2\n            dist = distance(start, end)\n            dist_rounded = int(dist / lt) * lt\n            if abs(dist) < 0.001:\n                return\n            end_rounded = (end - start) / dist * dist_rounded + start + l / 10\n            obj.become(DashedLine(end_rounded, start, dash_length=l, stroke_width=of_arrow.get_stroke_width() * 0.95).set_color(BLUE).set_z_index(of_arrow.get_z_index() - 0.0001))\n        dl.add_updater(dl_updater)\n        self.add(dl)\n        dummy = VMobject()\n        dummy.add_updater(sweep_updater)\n        dummy.add_updater(of_updater)\n        self.add(dummy)\n        self.camera.frame.save_state()\n        theory_group.save_state()\n        rect3.save_state()\n        self.play(FadeIn(of_arrow_shadow), sweep.animate(run_time=3).move_to(sweep_goal))\n        self.remove(dummy)\n        optimum = sweep.dots\n        sweep.remove(sweep.dots)\n        optimum_texts = VGroup(Tex('$1\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.8).move_to(optimum).align_to(numberplane.axes[0], UP).shift(DOWN * 0.35).set_z_index(100000), Tex('$4\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.8).move_to(optimum).align_to(numberplane.axes[1], RIGHT).shift(LEFT * 0.35).set_z_index(100000), Tex('$\\\\$8\\\\,000$').scale(0.8).next_to(optimum, UP + RIGHT).set_z_index(100000))\n        for i in range(3):\n            optimum_texts[i].add(CreateSR(optimum_texts[i]))\n        self.play(FadeIn(optimum_texts), FadeOut(sweep_angle), of_arrow.animate.set_opacity(0), ineqs.animate.set_opacity(1))\n        for i in [0, 1, 2]:\n            self.play(optimum_texts[i].animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        vm = CreateMeaning(var, '\\\\small variables $\\\\in \\\\mathbb{R}$')\n        vi = CreateMeaning(ineqs, '\\\\small s.t. linear \\\\par inequalities')\n        vo = CreateMeaning(VGroup(of, exp), '\\\\small maximizing \\\\par linear function')\n        dl.remove_updater(dl_updater)\n        self.play(FadeOut(optimum_texts), FadeOut(optimum), FadeOut(dl), FadeOut(sweep))\n        for o, rt in [(vm, 1.25), (vi, 1.5), (vo, 1.5)]:\n            self.play(AnimationGroup(FadeIn(o[0]), Write(o[1], run_time=rt), lag_ratio=0.5))\n        print('NUMBERPLANE CENTER', numberplane.get_center())\n        iextras = []\n        ipts = [[np.array([0, 0]), np.array([1, -2]), 0.5, None], [np.array([0, 0]), np.array([1, -0.5]), 0.5, None], [np.array([3, 0]), np.array([4, 1]), 0.25, None], [np.array([3, 2]), np.array([2, 3.5]), 0.25, '<='], [np.array([0, 4]), np.array([-1, 3.7]), 0.15, '<='], [np.array([0, 4]), np.array([-1, 3]), 0.15, '<='], [np.array([0, 4]), np.array([-1, 0]), 0.2, '<='], [np.array([1, 4]), np.array([0, 4.9]), 0.05, '<=']]\n        inorms = []\n        start = of_arrow_shadow.get_start()\n        for p1, p2, s, op in ipts:\n            a, b, c = Inequality2D.points_to_slope(p1, p2)\n            iq = Inequality2D(a, b, op or '>=', c).set_opacity(0).shift(of_arrow_shadow.get_start())\n            iextras.append(iq)\n            self.add(iq)\n            area.add_inequalities([iq])\n            d = p2 - p1\n            inorms.append((-d[1], d[0], 0) / np.linalg.norm(d))\n            ino = np.array((-d[1], d[0])) / np.linalg.norm(d)\n\n        def ineqs_complex_updater(obj, dt):\n            obj._update_area()\n            best_score = float('inf')\n            best_pos = None\n        self.add(area)\n        area.add_updater(ineqs_complex_updater)\n        of_arrow_shadow.save_state()\n        self.play(*[iextras[i].animate.shift(inorms[i] * ipts[i][-2]) for i in range(len(ipts))], vi[1].animate.scale(1.25), of_arrow_shadow.animate.put_start_and_end_on(np.array([1.4983125140164602, -1.627322003750033, 0.0]), np.array([1.4983125140164602, -1.627322003750033, 0.0]) + of_arrow_shadow.get_end() - of_arrow_shadow.get_start()))\n        self.next_section()\n        for o in self.mobjects:\n            self.remove(o)\n        self.add(vm, vi, vo, of, exp, ineqs, var, rect3)\n        g = Group(vm, vi, vo, of, exp, ineqs, var, rect3)\n        gc = g.get_center()\n        self.play(g.animate.next_to(self.camera.frame, LEFT, buff=0.001), run_time=5)\n        self.play(g.animate.move_to(gc), run_time=5)"}]}
{"messages": [{"role": "user", "content": "Visualize the farmer's optimization problem by showing the objective function and constraints on a graph."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass FarmerRotateBandaid(MovingCameraScene):\n\n    def construct(self):\n        self.next_section(skip_animations=True)\n        farm = ImageMobject('assets/midjourney/farm-12-16-out.png').set_height(self.camera.frame.get_height()).align_to(self.camera.frame, LEFT).set_z_index(5)\n        rect = ImageMobject('assets/midjourney/farm-12-16-rect.png').set_height(self.camera.frame.get_height()).align_to(farm, RIGHT).set_z_index(6)\n        rect_large = ImageMobject('assets/midjourney/farm-12-16-rect-large.png')\n        rect_small = ImageMobject('assets/midjourney/farm-12-16-rect-small.png').set_height(self.camera.frame.get_height()).align_to(farm, RIGHT).set_z_index(6)\n        farm.save_state()\n        rect.save_state()\n        icon_scale = 1.65\n        carrot = ImageMobject('assets/midjourney/carrot-cropped-flopped.png').set_height(0.45 * icon_scale)\n        potato = ImageMobject('assets/midjourney/potato-cropped.png').set_height(0.3 * icon_scale)\n        fertilizer = ImageMobject('assets/midjourney/fertilizer-cropped-flopped.png').set_height(0.3 * icon_scale)\n        farmer = ImageMobject('assets/midjourney/farmer-outline.png').set_z_index(10).set_height(1.05)\n        farmer_black = ImageMobject('assets/midjourney/farmer-black.png').set_z_index(9).set_height(1.05)\n        self.add(rect, farm)\n        fc = farm.copy()\n        farm.move_to(Dot().next_to(self.camera.frame, LEFT))\n        offset = 1\n        rect_played = rect.copy().next_to(fc, RIGHT, buff=0).shift(LEFT * offset * 2)\n        farm_played = farm.align_to(self.camera.frame, LEFT).shift(LEFT * offset)\n        title = Tex(\"\\\\underline{Farmer's Problem}\").scale(1.5)\n        goal = Tex('Goal: \\\\it maximize profit').scale(1.25)\n        points = VGroup(Tex('\\\\begin{itemize} \\\\item $3$ tons of potato seeds \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $4$ tons of carrot seeds \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $5$ tons of fertilizer (used 1:1) \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item ' + str(OF_INITIAL[0]) + '\\\\$/kg for O, ' + str(OF_INITIAL[1]) + '\\\\$/kg for O \\\\end{itemize}'))\n        for i in range(3):\n            align_object_by_coords(points[i + 1], points[i + 1][0][0], points[0][0][0])\n            points[i + 1].shift(DOWN * 0.75 * (i + 1))\n            if i == 2:\n                points[i + 1].shift(DOWN * 0.3)\n        guide = Dot().move_to(VGroup(Dot().align_to(rect_played, LEFT), Dot().align_to(self.camera.frame, RIGHT)))\n        potato.next_to(points[0][0][-1], RIGHT)\n        carrot.next_to(points[1][0][-1], RIGHT)\n        fertilizer.next_to(points[2][0][-1], RIGHT)\n        p2 = potato.copy().move_to(points[3][0][11])\n        c2 = carrot.copy().move_to(points[3][0][-1]).shift(RIGHT * 0.1)\n        points[3][0][11].scale(0.001).set_color(BLACK).set_opacity(0).set_z_index(-1)\n        points[3][0][-1].scale(0.001).set_color(BLACK).set_opacity(0).set_z_index(-1)\n        points[0][0][1].set_color(POTATO_COLOR)\n        points[1][0][1].set_color(CARROT_COLOR)\n        points[2][0][1].set_color(FERTILIZER_COLOR)\n        points[0][0][8:13 + 1].set_color(POTATO_COLOR)\n        points[1][0][8:13 + 1].set_color(CARROT_COLOR)\n        points[2][0][8:17 + 1].set_color(FERTILIZER_COLOR)\n        points[3][0][1:7 + 1].set_color(POTATO_COLOR)\n        points[3][0][13:19 + 1].set_color(CARROT_COLOR)\n        main_group = Group(Group(title, farmer).arrange(buff=0.4), Group(points, p2, c2, carrot, potato, fertilizer), goal).arrange(DOWN, buff=0.7).move_to(guide).set_z_index(10)\n        title.set_z_index(7)\n        farmer_copy = farmer.copy().move_to(title[0][0]).align_to(farmer, DOWN).set_opacity(0).set_z_index(1000)\n        farmer_black.move_to(farmer).set_z_index(999)\n        farmer_black_copy = farmer_black.copy().move_to(title[0][0]).align_to(farmer, DOWN).set_z_index(999)\n        sr1 = SurroundingRectangle(title, color=BLACK, fill_opacity=1).set_z_index(8)\n        sr2 = SurroundingRectangle(title, color=BLACK, fill_opacity=1).set_z_index(9).move_to(farmer_copy).align_to(Dot().move_to(farmer_copy), LEFT)\n        self.add(sr1, title)\n        self.play(rect.animate.next_to(fc, RIGHT, buff=0).shift(LEFT * offset * 2), farm.animate.align_to(self.camera.frame, LEFT).shift(LEFT * offset), ReplacementTransform(farmer_copy, farmer), ReplacementTransform(farmer_black_copy, farmer_black), FadeOut(sr1), sr2.animate.align_to(Dot().move_to(farmer), LEFT), run_time=2)\n        self.remove(farmer_black, sr2)\n        self.play(AnimationGroup(Write(points[0], run_time=1.25), FadeIn(potato, shift=0.1 * RIGHT), lag_ratio=0.5))\n        self.play(AnimationGroup(Write(points[1], run_time=1.25), FadeIn(carrot, shift=0.1 * RIGHT), lag_ratio=0.5))\n        self.play(Write(points[2][0][:17 + 1], run_time=1))\n        self.play(AnimationGroup(Write(points[2][0][17 + 1:], run_time=0.65), FadeIn(fertilizer, shift=0.1 * RIGHT), lag_ratio=0.3))\n        self.play(AnimationGroup(Write(points[3][0][:12 + 1]), FadeIn(p2, run_time=0.5), lag_ratio=0.5))\n        self.play(AnimationGroup(Write(points[3][0][12 + 1:]), FadeIn(c2, run_time=0.5), lag_ratio=0.5))\n        self.play(Write(goal[0][:5]), run_time=0.65)\n        self.play(Write(goal[0][5:]), run_time=1)\n        saved_x = (main_group.animate.set_x(0),)\n        rect2 = rect_small.copy().flip().align_to(self.camera.frame, RIGHT).shift(RIGHT * 0.1)\n        self.add(rect2)\n        offset2 = 0.5\n        equivalenece = SVGMobject('assets/iff.svg').set_height(0.6).set_z_index(10)\n        equivalenece.move_to(Dot().align_to(self.camera.frame, RIGHT))\n        equivalenece.set_opacity(0).shift(RIGHT * (0.65 - offset2))\n        self.play(rect.animate.restore(), farm.animate.restore(), main_group.animate.set_x(-main_group.get_x() - offset2 / 2), rect2.animate.shift(LEFT * (main_group.get_x() * 2 + offset2)), equivalenece.animate.shift(LEFT * (main_group.get_x() * 2 + offset2)).set_opacity(1))\n        guide2 = Dot().move_to(VGroup(Dot().move_to(equivalenece), Dot().align_to(self.camera.frame, RIGHT)))\n        var = ComplexTex('variables: $x_p, x_c$')\n        var[0][-5:-3].set_color(POTATO_COLOR)\n        var[0][-2:].set_color(CARROT_COLOR)\n        ineqs = ComplexTex('$$\\\\begin{aligned}\\n        x_p, x_c  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_p \\\\phantom{{}+ x_c} &\\\\le 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_c &\\\\le 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_p + x_c &\\\\le 5\\\\,000\\n                \\\\end{aligned}$$')\n        ineqs[0][0:2].set_color(POTATO_COLOR)\n        ineqs[0][3:3 + 2].set_color(CARROT_COLOR)\n        ineqs[0][7:7 + 2].set_color(POTATO_COLOR)\n        ineqs[0][10].set_color(POTATO_COLOR)\n        ineqs[0][11].set_color(POTATO_COLOR)\n        ineqs[0][12].set_color(POTATO_COLOR)\n        ineqs[0][13].set_color(POTATO_COLOR)\n        ineqs[0][14:14 + 2].set_color(CARROT_COLOR)\n        ineqs[0][17].set_color(CARROT_COLOR)\n        ineqs[0][18].set_color(CARROT_COLOR)\n        ineqs[0][19].set_color(CARROT_COLOR)\n        ineqs[0][20].set_color(CARROT_COLOR)\n        ineqs[0][21:21 + 2].set_color(POTATO_COLOR)\n        ineqs[0][24:24 + 2].set_color(CARROT_COLOR)\n        ineqs[0][27].set_color(FERTILIZER_COLOR)\n        ineqs[0][28].set_color(FERTILIZER_COLOR)\n        ineqs[0][29].set_color(FERTILIZER_COLOR)\n        ineqs[0][30].set_color(FERTILIZER_COLOR)\n        exp = ComplexTex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_p + ' + str(OF_INITIAL[1]) + ' x_c$$')\n        exp[0][3:3 + 5].set_color(POTATO_COLOR)\n        exp[0][-5:].set_color(CARROT_COLOR)\n        of = Tex('objective function').set_opacity(MED_OPACITY).scale(0.75)\n        theory_group = Group(var, ineqs, exp).arrange(DOWN, buff=0.75).move_to(guide2).set_z_index(10)\n        var.align_to(title, DOWN)\n        exp.align_to(goal, UP)\n        self.play(AnimationGroup(AnimationGroup(points[2].animate.set_opacity(BIG_OPACITY), points[3].animate.set_opacity(BIG_OPACITY), fertilizer.animate.set_opacity(BIG_OPACITY), p2.animate.set_opacity(BIG_OPACITY), c2.animate.set_opacity(BIG_OPACITY), goal.animate.set_opacity(BIG_OPACITY)), Write(var, run_time=1.25), lag_ratio=0.5))\n        self.play(Write(ineqs[0][:7]), run_time=1.25)\n        self.play(Write(ineqs[0][7:21]), run_time=1.5)\n        self.play(AnimationGroup(AnimationGroup(points[0].animate.set_opacity(BIG_OPACITY), points[1].animate.set_opacity(BIG_OPACITY), potato.animate.set_opacity(BIG_OPACITY), carrot.animate.set_opacity(BIG_OPACITY), points[2].animate.set_opacity(1), fertilizer.animate.set_opacity(1)), Write(ineqs[0][21:], run_time=1), lag_ratio=0.5))\n        self.play(AnimationGroup(AnimationGroup(points[2].animate.set_opacity(BIG_OPACITY), fertilizer.animate.set_opacity(BIG_OPACITY), points[3].animate.set_opacity(1), p2.animate.set_opacity(1), c2.animate.set_opacity(1), goal.animate.set_opacity(1)), lag_ratio=0.5))\n        self.play(Write(exp, run_time=1.5))\n        g = VGroup(exp.copy(), of).arrange(UP, buff=0.15).move_to(exp)\n        self.play(Transform(exp, g[0]), FadeIn(of, shift=UP * 0.15))\n        self.play(points.animate.set_opacity(1), carrot.animate.set_opacity(1), potato.animate.set_opacity(1), fertilizer.animate.set_opacity(1))\n        theory_group.add(of)\n        of.set_z_index(10)\n        self.remove(rect, farm)\n        rect3 = rect.copy().flip().align_to(self.camera.frame, RIGHT).set_z_index(rect2.get_z_index() - 1).shift(RIGHT * 0.1)\n        self.add(rect3)\n        guide3 = Dot().move_to(main_group)\n        guide3.set_x(-guide3.get_x())\n        numberplane = NumberPlane(x_range=(-3 * 7.111111111111111, 3 * 7.111111111111111, 1), y_range=(-3 * 4.0, 3 * 4.0, 1), stroke_width=6, axis_config={'stroke_width': 4}, background_line_style={'stroke_color': GRAY, 'stroke_width': 3, 'stroke_opacity': 0.6})\n        numberplane.background_lines.set_z_index(rect3.get_z_index() - 1 + 0.1)\n        numberplane.axes.set_z_index(rect3.get_z_index() - 1 + 0.2)\n        area = FeasibleArea2D(dots_z_index=rect3.get_z_index() - 1 + 0.99).set_z_index(rect3.get_z_index() - 1 + 0.4)\n        i1 = Inequality2D(1, 0, '>=', 0).set_color(POTATO_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i2 = Inequality2D(0, 1, '>=', 0).set_color(CARROT_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i3 = Inequality2D(1, 1, '<=', 5).set_color(FERTILIZER_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i4 = Inequality2D(1, 0, '<=', 3).set_color(POTATO_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i5 = Inequality2D(0, 1, '<=', 4).set_color(CARROT_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i4_hp = i4.get_half_plane()\n        area.add_inequalities([i1, i2, i3, i4, i5])\n        of_arrow = Arrow(start=ORIGIN, end=np.array((*OF_INITIAL, 0)), buff=0).set_z_index(area.dots_z_index - 0.01)\n        of_arrow_shadow = of_arrow.copy().set_color(WHITE).set_z_index(of_arrow.get_z_index() - 1e-06)\n        optimum = list(solve_farm(OF_INITIAL))\n        optimum[0] /= 1000\n        optimum[1] /= 1000\n        sweep = AffineLine2D(OF_INITIAL).rotate(PI / 2)\n        sweep.crop_to_screen(self.camera.frame)\n        sweep.set_z_index(rect3.get_z_index() - 1 + 0.99).set_color(BLUE)\n        sweep_goal = AffineLine2D(OF_INITIAL).rotate(-PI / 2).move_to([*optimum, 0])\n        sweep_goal.set_z_index(rect3.get_z_index() - 1 + 0.99)\n        sweep_angle = Angle(sweep.line, of_arrow, dot=True).set_z_index(99).set_color(BLUE)\n        sweep.dots = VGroup()\n        sweep.add(sweep.dots)\n        sweep.lineextra = VGroup()\n        sweep.add(sweep.lineextra)\n\n        def sweep_updater(obj):\n            dots = sweep.get_area_border_intersection(area)\n            if len(dots) <= 1:\n                return\n            g = VGroup().set_z_index(100000)\n            for i in range(len(dots)):\n                for j in range(i + 1, len(dots)):\n                    d1, d2 = (dots[i], dots[j])\n                    g.add(Line(start=d1.get_center(), end=d2.get_center(), color=BLUE, stroke_width=LINE_STROKE + 2.5).set_z_index(100000))\n            sweep.lineextra.become(g).set_z_index(100000)\n            sweep.dots.become(dots).set_z_index(100000).set_color(BLUE)\n        sweep_updater(None)\n        sweep_dots_tmp = sweep.dots\n        sweep.remove(sweep.dots)\n        align_object_by_coords(VGroup(i1, i4_hp, i2, i3, i4, i5, area, numberplane, of_arrow, of_arrow_shadow, sweep, sweep_goal, sweep_angle, sweep_dots_tmp), area.dots.get_center(), guide3.get_center())\n        i1.crop_to_screen(self.camera.frame)\n        i2.crop_to_screen(self.camera.frame)\n        i3.crop_to_screen(self.camera.frame)\n        i4.crop_to_screen(self.camera.frame)\n        i5.crop_to_screen(self.camera.frame)\n        labels = VGroup(Tex('$x_p$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[0], DOWN, buff=0.33).align_to(self.camera.frame, RIGHT).shift(LEFT * 0.2).set_color(POTATO_COLOR), Tex('$x_c$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[1], LEFT, buff=0.23).align_to(self.camera.frame, UP).shift(DOWN * 0.35).set_color(CARROT_COLOR)).set_z_index(i1.get_z_index() + 1)\n        self.play(AnimationGroup(AnimationGroup(main_group.animate.shift(LEFT * theory_group.get_x() * 2), rect2.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(0), rect3.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(1), var.animate.shift(LEFT * theory_group.get_x() * 2), ineqs.animate.shift(LEFT * theory_group.get_x() * 2), exp.animate.shift(LEFT * theory_group.get_x() * 2), of.animate.shift(LEFT * theory_group.get_x() * 2), equivalenece.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(0)), lag_ratio=0.5))\n        self.play(FadeIn(numberplane.background_lines), FadeIn(numberplane.axes))\n        labels_tmp = labels.copy()\n        xptmp = var[0][10:10 + 2].copy()\n        xctmp = var[0][13:13 + 2].copy()\n        self.play(AnimationGroup(Transform(xptmp, labels_tmp[0]), Transform(xctmp, labels_tmp[1]), lag_ratio=0.25))\n        self.remove(xptmp, xctmp)\n        self.add(labels)\n        sr = SurroundingRectangle(VGroup(Dot().align_to(self.camera.frame, UP + RIGHT), Dot().align_to(self.camera.frame, DOWN + RIGHT), Dot().align_to(rect3, RIGHT)), fill_opacity=1).move_to(guide3).set_color_by_gradient((RED, GREEN)).set_opacity(0.35)\n        sr.set_sheen_direction(unit_vector(OF_INITIAL[0] * RIGHT + OF_INITIAL[1] * UP))\n        self.remove(main_group, rect2, equivalenece)\n        big_hl = CreateHighlight(ineqs)\n        hl = CreateHighlight(ineqs[0][7:7 + 7])\n        self.play(exp.animate.set_opacity(BIG_OPACITY), of.animate.set_opacity(BIG_OPACITY), FadeIn(big_hl))\n        self.play(AnimationGroup(Transform(big_hl, hl), Create(i4), lag_ratio=0.5))\n        self.remove(big_hl)\n        self.add(hl)\n        self.play(FadeIn(i4_hp))\n        self.play(AnimationGroup(FadeOut(hl), Create(i1), Create(i2), Create(i3), Create(i5), AnimationGroup(FadeOut(i4_hp), FadeIn(area)), lag_ratio=0.25))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(i1), FadeOut(i2), FadeOut(i3), FadeOut(i4), FadeOut(i5)), lag_ratio=0.5))\n        self.play(area.area.animate(rate_func=there_and_back, run_time=1.25).set_fill(BLUE, 0.5))\n        self.play(exp.animate.set_opacity(1), of.animate.set_opacity(MED_OPACITY), ineqs.animate.set_opacity(BIG_OPACITY))\n        self.add(sr)\n        thingy = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(OF_INITIAL[1], OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        self.play(AnimationGroup(thingy.animate(run_time=2).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 7), AnimationGroup(Write(of_arrow)), lag_ratio=0))\n        self.remove(thingy)\n        self.play(FadeIn(sweep), FadeIn(sweep_angle), FadeIn(sweep_dots_tmp), of_arrow.animate.set_color(BLUE))\n        sweep.add(sweep_dots_tmp)\n        dl = DashedLine(ORIGIN - 0.0001, ORIGIN + 0.0001).set_z_index(of_arrow.get_z_index() - 1e-05).set_color(BLUE)\n\n        def of_updater(obj):\n            start = of_arrow.get_start()\n            end = of_arrow.get_end()\n            point = intersection(line(start, end), line(sweep.line.get_start(), sweep.line.get_end()))\n            new_point = np.array([*point, 0])\n            of_arrow.put_start_and_end_on(new_point, new_point + np.array([*OF_INITIAL, 0]))\n            sweep_angle.become(Angle(sweep.line, of_arrow, dot=True).set_color(BLUE).set_z_index(99))\n\n        def dl_updater(obj):\n            start = of_arrow_shadow.get_start()\n            end = intersection(line(of_arrow_shadow.get_start(), of_arrow_shadow.get_end()), line(sweep.line.get_start(), sweep.line.get_end()))\n            end = np.array([*end, 0])\n            l = 0.085\n            lt = l * 2\n            dist = distance(start, end)\n            dist_rounded = int(dist / lt) * lt\n            if abs(dist) < 0.001:\n                return\n            end_rounded = (end - start) / dist * dist_rounded + start + l / 10\n            obj.become(DashedLine(end_rounded, start, dash_length=l, stroke_width=of_arrow.get_stroke_width() * 0.95).set_color(BLUE).set_z_index(of_arrow.get_z_index() - 0.0001))\n        dl.add_updater(dl_updater)\n        self.add(dl)\n        dummy = VMobject()\n        dummy.add_updater(sweep_updater)\n        dummy.add_updater(of_updater)\n        self.add(dummy)\n        self.camera.frame.save_state()\n        theory_group.save_state()\n        rect3.save_state()\n        self.play(FadeIn(of_arrow_shadow), sweep.animate(run_time=3).move_to(sweep_goal))\n        self.remove(dummy)\n        optimum = sweep.dots\n        sweep.remove(sweep.dots)\n        optimum_texts = VGroup(Tex('$1\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.8).move_to(optimum).align_to(numberplane.axes[0], UP).shift(DOWN * 0.35).set_z_index(100000), Tex('$4\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.8).move_to(optimum).align_to(numberplane.axes[1], RIGHT).shift(LEFT * 0.35).set_z_index(100000), Tex('$\\\\$8\\\\,000$').scale(0.8).next_to(optimum, UP + RIGHT).set_z_index(100000))\n        for i in range(3):\n            optimum_texts[i].add(CreateSR(optimum_texts[i]))\n        self.play(FadeIn(optimum_texts), FadeOut(sweep_angle), of_arrow.animate.set_opacity(0), ineqs.animate.set_opacity(1))\n        for i in [0, 1, 2]:\n            self.play(optimum_texts[i].animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        vm = CreateMeaning(var, '\\\\small variables $\\\\in \\\\mathbb{R}$')\n        vi = CreateMeaning(ineqs, '\\\\small s.t. linear \\\\par inequalities')\n        vo = CreateMeaning(VGroup(of, exp), '\\\\small maximizing \\\\par linear function')\n        dl.remove_updater(dl_updater)\n        self.play(FadeOut(optimum_texts), FadeOut(optimum), FadeOut(dl), FadeOut(sweep))\n        for o, rt in [(vm, 1.25), (vi, 1.5), (vo, 1.5)]:\n            self.play(AnimationGroup(FadeIn(o[0]), Write(o[1], run_time=rt), lag_ratio=0.5))\n        print('NUMBERPLANE CENTER', numberplane.get_center())\n        iextras = []\n        ipts = [[np.array([0, 0]), np.array([1, -2]), 0.5, None], [np.array([0, 0]), np.array([1, -0.5]), 0.5, None], [np.array([3, 0]), np.array([4, 1]), 0.25, None], [np.array([3, 2]), np.array([2, 3.5]), 0.25, '<='], [np.array([0, 4]), np.array([-1, 3.7]), 0.15, '<='], [np.array([0, 4]), np.array([-1, 3]), 0.15, '<='], [np.array([0, 4]), np.array([-1, 0]), 0.2, '<='], [np.array([1, 4]), np.array([0, 4.9]), 0.05, '<=']]\n        inorms = []\n        start = of_arrow_shadow.get_start()\n        for p1, p2, s, op in ipts:\n            a, b, c = Inequality2D.points_to_slope(p1, p2)\n            iq = Inequality2D(a, b, op or '>=', c).set_opacity(0).shift(of_arrow_shadow.get_start())\n            iextras.append(iq)\n            self.add(iq)\n            area.add_inequalities([iq])\n            d = p2 - p1\n            inorms.append((-d[1], d[0], 0) / np.linalg.norm(d))\n            ino = np.array((-d[1], d[0])) / np.linalg.norm(d)\n\n        def ineqs_complex_updater(obj, dt):\n            obj._update_area()\n            best_score = float('inf')\n            best_pos = None\n        self.add(area)\n        area.add_updater(ineqs_complex_updater)\n        of_arrow_shadow.save_state()\n        self.play(*[iextras[i].animate.shift(inorms[i] * ipts[i][-2]) for i in range(len(ipts))], vi[1].animate.scale(1.25), of_arrow_shadow.animate.put_start_and_end_on(np.array([1.4983125140164602, -1.627322003750033, 0.0]), np.array([1.4983125140164602, -1.627322003750033, 0.0]) + of_arrow_shadow.get_end() - of_arrow_shadow.get_start()))\n        self.play(*[iextras[i].animate.shift(-inorms[i] * ipts[i][-2] * 1.1) for i in range(len(ipts))], FadeOut(vm, vi, vo), of_arrow_shadow.animate.restore())\n        area.remove_updater(ineqs_complex_updater)\n        area.remove_inequalities(iextras)\n\n        def of_line_updater(obj):\n            vector = of_arrow_shadow.get_end() - of_arrow_shadow.get_start()\n            x, y, _ = vector\n            optimum = list(solve_farm([x, y]))\n            optimum[0] /= 1000\n            optimum[1] /= 1000\n            sweep.line.become(AffineLine2D([x, y]).line.set_color(BLUE).rotate(PI / 2).move_to(of_arrow_shadow.get_start()).shift([*optimum, 0]))\n            op = '+' if y >= 0 else '-'\n            new_exp = Tex(f'$$\\\\max\\\\ {x:.1f}x_p {op} {abs(y):.1f}x_c$$').move_to(exp).align_to(exp, DOWN)\n            new_exp[0][3:3 + 5].set_color(POTATO_COLOR)\n            new_exp[0][9:9 + 5].set_color(CARROT_COLOR)\n            exp.become(new_exp)\n        sm = Tex('\\\\underline{Simplex Method}').set_z_index(10000000000).scale(1)\n        sm.add(CreateSR(sm, buff=0.17))\n        sm.align_to(self.camera.frame, RIGHT + UP).shift((LEFT * 1.2 + DOWN) * 0.25)\n        self.play(AnimationGroup(FadeIn(sm[1]), Write(sm[0]), lag_ratio=0.2))\n        self.play(FadeIn(optimum), FadeIn(dl), FadeIn(sweep))\n        srcp = sr.copy().set_z_index(sr.get_z_index() + 0.2)\n        thingy = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(OF_INITIAL[1], OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        thingy2 = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(-OF_INITIAL[1], -OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        thingy2.shift(-unit_vector(OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 18)\n        self.add(thingy, thingy2, srcp)\n        self.play(thingy.animate(run_time=2.5).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 9), thingy2.animate(run_time=2.5).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 9))\n        self.remove(thingy, thingy2, srcp)\n        dl.add_updater(dl_updater)\n        self.play(*[MyFlash(d, color=WHITE, z_index=d.get_z_index() + 1) for d in area.dots], MyFlash(optimum, color=BLUE, z_index=optimum.get_z_index() + 2))\n\n        def sr_updater(obj):\n            vector = of_arrow_shadow.get_end() - of_arrow_shadow.get_start()\n            obj.set_sheen_direction(unit_vector(vector))\n        sr.add_updater(sr_updater)\n        dummy = VMobject()\n        dummy.add_updater(of_line_updater)\n        dummy.add_updater(sweep_updater)\n        self.add(dummy)\n        angle = atan2(OF_INITIAL[1], OF_INITIAL[0])\n        self.play(Rotate(of_arrow_shadow, -angle, about_point=of_arrow_shadow.get_start()), run_time=2)\n        self.play(*[MyFlash(d, color=BLUE, z_index=d.get_z_index() + 1) for d in sweep.dots])\n        self.next_section()\n        dooepajf = of_arrow_shadow.get_start()\n\n        def rf1(x):\n            x *= 5\n            if x < 2.083 - 0.15:\n                return 0\n            else:\n                return smooth((x - (2.083 - 0.15)) * 2)\n\n        def rf2(x):\n            x *= 5\n            if x < 2.683 - 0.15:\n                return 0\n            else:\n                return smooth((x - (2.683 - 0.15)) * 2)\n\n        def rf3(x):\n            x *= 5\n            if x < 3.5 - 0.15:\n                return 0\n            else:\n                return smooth((x - (3.5 - 0.15)) * 2)\n        self.play(Rotate(of_arrow_shadow, +angle - 2 * PI, about_point=of_arrow_shadow.get_start(), run_time=5), MyFlash(Dot().move_to(dooepajf), color=BLUE, z_index=sweep.dots[0].get_z_index() + 1, run_time=5, rate_func=rf1), MyFlash(Dot().move_to(dooepajf + UP * 4), color=BLUE, z_index=sweep.dots[0].get_z_index() + 1, run_time=5, rate_func=rf2), MyFlash(Dot().move_to(dooepajf + UP * 4 + RIGHT * 1), color=BLUE, z_index=sweep.dots[0].get_z_index() + 1, run_time=5, rate_func=rf3))"}]}
{"messages": [{"role": "user", "content": "Visualize the farmer's problem, showing the goal, constraints, and then transforming into a graphical representation of the linear programming problem with the simplex method."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass Farmer(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        farm = ImageMobject('assets/midjourney/farm-12-16-out.png').set_height(self.camera.frame.get_height()).align_to(self.camera.frame, LEFT).set_z_index(5)\n        rect = ImageMobject('assets/midjourney/farm-12-16-rect.png').set_height(self.camera.frame.get_height()).align_to(farm, RIGHT).set_z_index(6)\n        rect_large = ImageMobject('assets/midjourney/farm-12-16-rect-large.png')\n        rect_small = ImageMobject('assets/midjourney/farm-12-16-rect-small.png').set_height(self.camera.frame.get_height()).align_to(farm, RIGHT).set_z_index(6)\n        farm.save_state()\n        rect.save_state()\n        icon_scale = 1.65\n        carrot = ImageMobject('assets/midjourney/carrot-cropped-flopped.png').set_height(0.45 * icon_scale)\n        potato = ImageMobject('assets/midjourney/potato-cropped.png').set_height(0.3 * icon_scale)\n        fertilizer = ImageMobject('assets/midjourney/fertilizer-cropped-flopped.png').set_height(0.3 * icon_scale)\n        farmer = ImageMobject('assets/midjourney/farmer-outline.png').set_z_index(10).set_height(1.05)\n        farmer_black = ImageMobject('assets/midjourney/farmer-black.png').set_z_index(9).set_height(1.05)\n        self.add(rect, farm)\n        fc = farm.copy()\n        farm.move_to(Dot().next_to(self.camera.frame, LEFT))\n        offset = 1\n        rect_played = rect.copy().next_to(fc, RIGHT, buff=0).shift(LEFT * offset * 2)\n        farm_played = farm.align_to(self.camera.frame, LEFT).shift(LEFT * offset)\n        title = Tex(\"\\\\underline{Farmer's Problem}\").scale(1.5)\n        goal = Tex('Goal: \\\\it maximize profit').scale(1.25)\n        points = VGroup(Tex('\\\\begin{itemize} \\\\item $3$ tons of potato seeds \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $4$ tons of carrot seeds \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item $5$ tons of fertilizer (used 1:1) \\\\end{itemize}'), Tex('\\\\begin{itemize} \\\\item ' + str(OF_INITIAL[0]) + '\\\\$/kg for O, ' + str(OF_INITIAL[1]) + '\\\\$/kg for O \\\\end{itemize}'))\n        for i in range(3):\n            align_object_by_coords(points[i + 1], points[i + 1][0][0], points[0][0][0])\n            points[i + 1].shift(DOWN * 0.75 * (i + 1))\n            if i == 2:\n                points[i + 1].shift(DOWN * 0.3)\n        guide = Dot().move_to(VGroup(Dot().align_to(rect_played, LEFT), Dot().align_to(self.camera.frame, RIGHT)))\n        potato.next_to(points[0][0][-1], RIGHT)\n        carrot.next_to(points[1][0][-1], RIGHT)\n        fertilizer.next_to(points[2][0][-1], RIGHT)\n        p2 = potato.copy().move_to(points[3][0][11])\n        c2 = carrot.copy().move_to(points[3][0][-1]).shift(RIGHT * 0.1)\n        points[3][0][11].scale(0.001).set_color(BLACK).set_opacity(0).set_z_index(-1)\n        points[3][0][-1].scale(0.001).set_color(BLACK).set_opacity(0).set_z_index(-1)\n        points[0][0][1].set_color(POTATO_COLOR)\n        points[1][0][1].set_color(CARROT_COLOR)\n        points[2][0][1].set_color(FERTILIZER_COLOR)\n        points[0][0][8:13 + 1].set_color(POTATO_COLOR)\n        points[1][0][8:13 + 1].set_color(CARROT_COLOR)\n        points[2][0][8:17 + 1].set_color(FERTILIZER_COLOR)\n        points[3][0][1:7 + 1].set_color(POTATO_COLOR)\n        points[3][0][13:19 + 1].set_color(CARROT_COLOR)\n        main_group = Group(Group(title, farmer).arrange(buff=0.4), Group(points, p2, c2, carrot, potato, fertilizer), goal).arrange(DOWN, buff=0.7).move_to(guide).set_z_index(10)\n        title.set_z_index(7)\n        farmer_copy = farmer.copy().move_to(title[0][0]).align_to(farmer, DOWN).set_opacity(0).set_z_index(1000)\n        farmer_black.move_to(farmer).set_z_index(999)\n        farmer_black_copy = farmer_black.copy().move_to(title[0][0]).align_to(farmer, DOWN).set_z_index(999)\n        sr1 = SurroundingRectangle(title, color=BLACK, fill_opacity=1).set_z_index(8)\n        sr2 = SurroundingRectangle(title, color=BLACK, fill_opacity=1).set_z_index(9).move_to(farmer_copy).align_to(Dot().move_to(farmer_copy), LEFT)\n        self.add(sr1, title)\n        self.play(rect.animate.next_to(fc, RIGHT, buff=0).shift(LEFT * offset * 2), farm.animate.align_to(self.camera.frame, LEFT).shift(LEFT * offset), ReplacementTransform(farmer_copy, farmer), ReplacementTransform(farmer_black_copy, farmer_black), FadeOut(sr1), sr2.animate.align_to(Dot().move_to(farmer), LEFT), run_time=2)\n        self.remove(farmer_black, sr2)\n        self.play(AnimationGroup(Write(points[0], run_time=1.25), FadeIn(potato, shift=0.1 * RIGHT), lag_ratio=0.5))\n        self.play(AnimationGroup(Write(points[1], run_time=1.25), FadeIn(carrot, shift=0.1 * RIGHT), lag_ratio=0.5))\n        self.play(Write(points[2][0][:17 + 1], run_time=1))\n        self.play(AnimationGroup(Write(points[2][0][17 + 1:], run_time=0.65), FadeIn(fertilizer, shift=0.1 * RIGHT), lag_ratio=0.3))\n        self.play(AnimationGroup(Write(points[3][0][:12 + 1]), FadeIn(p2, run_time=0.5), lag_ratio=0.5))\n        self.play(AnimationGroup(Write(points[3][0][12 + 1:]), FadeIn(c2, run_time=0.5), lag_ratio=0.5))\n        self.play(Write(goal[0][:5]), run_time=0.65)\n        self.play(Write(goal[0][5:]), run_time=1)\n        saved_x = (main_group.animate.set_x(0),)\n        rect2 = rect_small.copy().flip().align_to(self.camera.frame, RIGHT).shift(RIGHT * 0.1)\n        self.add(rect2)\n        offset2 = 0.5\n        equivalenece = SVGMobject('assets/iff.svg').set_height(0.6).set_z_index(10)\n        equivalenece.move_to(Dot().align_to(self.camera.frame, RIGHT))\n        equivalenece.set_opacity(0).shift(RIGHT * (0.65 - offset2))\n        self.play(rect.animate.restore(), farm.animate.restore(), main_group.animate.set_x(-main_group.get_x() - offset2 / 2), rect2.animate.shift(LEFT * (main_group.get_x() * 2 + offset2)), equivalenece.animate.shift(LEFT * (main_group.get_x() * 2 + offset2)).set_opacity(1))\n        guide2 = Dot().move_to(VGroup(Dot().move_to(equivalenece), Dot().align_to(self.camera.frame, RIGHT)))\n        var = ComplexTex('variables: $x_p, x_c$')\n        var[0][-5:-3].set_color(POTATO_COLOR)\n        var[0][-2:].set_color(CARROT_COLOR)\n        ineqs = ComplexTex('$$\\\\begin{aligned}\\n        x_p, x_c  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_p \\\\phantom{{}+ x_c} &\\\\le 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_c &\\\\le 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_p + x_c &\\\\le 5\\\\,000\\n                \\\\end{aligned}$$')\n        ineqs[0][0:2].set_color(POTATO_COLOR)\n        ineqs[0][3:3 + 2].set_color(CARROT_COLOR)\n        ineqs[0][7:7 + 2].set_color(POTATO_COLOR)\n        ineqs[0][10].set_color(POTATO_COLOR)\n        ineqs[0][11].set_color(POTATO_COLOR)\n        ineqs[0][12].set_color(POTATO_COLOR)\n        ineqs[0][13].set_color(POTATO_COLOR)\n        ineqs[0][14:14 + 2].set_color(CARROT_COLOR)\n        ineqs[0][17].set_color(CARROT_COLOR)\n        ineqs[0][18].set_color(CARROT_COLOR)\n        ineqs[0][19].set_color(CARROT_COLOR)\n        ineqs[0][20].set_color(CARROT_COLOR)\n        ineqs[0][21:21 + 2].set_color(POTATO_COLOR)\n        ineqs[0][24:24 + 2].set_color(CARROT_COLOR)\n        ineqs[0][27].set_color(FERTILIZER_COLOR)\n        ineqs[0][28].set_color(FERTILIZER_COLOR)\n        ineqs[0][29].set_color(FERTILIZER_COLOR)\n        ineqs[0][30].set_color(FERTILIZER_COLOR)\n        exp = ComplexTex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_p + ' + str(OF_INITIAL[1]) + ' x_c$$')\n        exp[0][3:3 + 5].set_color(POTATO_COLOR)\n        exp[0][-5:].set_color(CARROT_COLOR)\n        of = Tex('objective function').set_opacity(MED_OPACITY).scale(0.75)\n        theory_group = Group(var, ineqs, exp).arrange(DOWN, buff=0.75).move_to(guide2).set_z_index(10)\n        var.align_to(title, DOWN)\n        exp.align_to(goal, UP)\n        self.play(AnimationGroup(AnimationGroup(points[2].animate.set_opacity(BIG_OPACITY), points[3].animate.set_opacity(BIG_OPACITY), fertilizer.animate.set_opacity(BIG_OPACITY), p2.animate.set_opacity(BIG_OPACITY), c2.animate.set_opacity(BIG_OPACITY), goal.animate.set_opacity(BIG_OPACITY)), Write(var, run_time=1.25), lag_ratio=0.5))\n        self.play(Write(ineqs[0][:7]), run_time=1.25)\n        self.play(Write(ineqs[0][7:21]), run_time=1.5)\n        self.play(AnimationGroup(AnimationGroup(points[0].animate.set_opacity(BIG_OPACITY), points[1].animate.set_opacity(BIG_OPACITY), potato.animate.set_opacity(BIG_OPACITY), carrot.animate.set_opacity(BIG_OPACITY), points[2].animate.set_opacity(1), fertilizer.animate.set_opacity(1)), Write(ineqs[0][21:], run_time=1), lag_ratio=0.5))\n        self.play(AnimationGroup(AnimationGroup(points[2].animate.set_opacity(BIG_OPACITY), fertilizer.animate.set_opacity(BIG_OPACITY), points[3].animate.set_opacity(1), p2.animate.set_opacity(1), c2.animate.set_opacity(1), goal.animate.set_opacity(1)), lag_ratio=0.5))\n        self.play(Write(exp, run_time=1.5))\n        g = VGroup(exp.copy(), of).arrange(UP, buff=0.15).move_to(exp)\n        self.play(Transform(exp, g[0]), FadeIn(of, shift=UP * 0.15))\n        self.play(points.animate.set_opacity(1), carrot.animate.set_opacity(1), potato.animate.set_opacity(1), fertilizer.animate.set_opacity(1))\n        theory_group.add(of)\n        of.set_z_index(10)\n        self.remove(rect, farm)\n        rect3 = rect.copy().flip().align_to(self.camera.frame, RIGHT).set_z_index(rect2.get_z_index() - 1).shift(RIGHT * 0.1)\n        self.add(rect3)\n        guide3 = Dot().move_to(main_group)\n        guide3.set_x(-guide3.get_x())\n        numberplane = NumberPlane(x_range=(-3 * 7.111111111111111, 3 * 7.111111111111111, 1), y_range=(-3 * 4.0, 3 * 4.0, 1), stroke_width=6, axis_config={'stroke_width': 4}, background_line_style={'stroke_color': GRAY, 'stroke_width': 3, 'stroke_opacity': 0.6})\n        numberplane.background_lines.set_z_index(rect3.get_z_index() - 1 + 0.1)\n        numberplane.axes.set_z_index(rect3.get_z_index() - 1 + 0.2)\n        area = FeasibleArea2D(dots_z_index=rect3.get_z_index() - 1 + 0.99).set_z_index(rect3.get_z_index() - 1 + 0.4)\n        i1 = Inequality2D(1, 0, '>=', 0).set_color(POTATO_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i2 = Inequality2D(0, 1, '>=', 0).set_color(CARROT_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i3 = Inequality2D(1, 1, '<=', 5).set_color(FERTILIZER_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i4 = Inequality2D(1, 0, '<=', 3).set_color(POTATO_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i5 = Inequality2D(0, 1, '<=', 4).set_color(CARROT_COLOR).set_z_index(rect3.get_z_index() - 1 + 0.5)\n        i4_hp = i4.get_half_plane()\n        area.add_inequalities([i1, i2, i3, i4, i5])\n        of_arrow = Arrow(start=ORIGIN, end=np.array((*OF_INITIAL, 0)), buff=0).set_z_index(area.dots_z_index - 0.01)\n        of_arrow_shadow = of_arrow.copy().set_color(WHITE).set_z_index(of_arrow.get_z_index() - 1e-06)\n        optimum = list(solve_farm(OF_INITIAL))\n        optimum[0] /= 1000\n        optimum[1] /= 1000\n        sweep = AffineLine2D(OF_INITIAL).rotate(PI / 2)\n        sweep.crop_to_screen(self.camera.frame)\n        sweep.set_z_index(rect3.get_z_index() - 1 + 0.99).set_color(BLUE)\n        sweep_goal = AffineLine2D(OF_INITIAL).rotate(-PI / 2).move_to([*optimum, 0])\n        sweep_goal.set_z_index(rect3.get_z_index() - 1 + 0.99)\n        sweep_angle = Angle(sweep.line, of_arrow, dot=True).set_z_index(99).set_color(BLUE)\n        sweep.dots = VGroup()\n        sweep.add(sweep.dots)\n        sweep.lineextra = VGroup()\n        sweep.add(sweep.lineextra)\n\n        def sweep_updater(obj):\n            dots = sweep.get_area_border_intersection(area)\n            if len(dots) <= 1:\n                return\n            g = VGroup().set_z_index(100000)\n            for i in range(len(dots)):\n                for j in range(i + 1, len(dots)):\n                    d1, d2 = (dots[i], dots[j])\n                    g.add(Line(start=d1.get_center(), end=d2.get_center(), color=BLUE, stroke_width=LINE_STROKE + 2.5).set_z_index(100000))\n            sweep.lineextra.become(g).set_z_index(100000)\n            sweep.dots.become(dots).set_z_index(100000).set_color(BLUE)\n        sweep_updater(None)\n        sweep_dots_tmp = sweep.dots\n        sweep.remove(sweep.dots)\n        align_object_by_coords(VGroup(i1, i4_hp, i2, i3, i4, i5, area, numberplane, of_arrow, of_arrow_shadow, sweep, sweep_goal, sweep_angle, sweep_dots_tmp), area.dots.get_center(), guide3.get_center())\n        i1.crop_to_screen(self.camera.frame)\n        i2.crop_to_screen(self.camera.frame)\n        i3.crop_to_screen(self.camera.frame)\n        i4.crop_to_screen(self.camera.frame)\n        i5.crop_to_screen(self.camera.frame)\n        labels = VGroup(Tex('$x_p$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[0], DOWN, buff=0.33).align_to(self.camera.frame, RIGHT).shift(LEFT * 0.2).set_color(POTATO_COLOR), Tex('$x_c$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[1], LEFT, buff=0.23).align_to(self.camera.frame, UP).shift(DOWN * 0.35).set_color(CARROT_COLOR)).set_z_index(i1.get_z_index() + 1)\n        self.play(AnimationGroup(AnimationGroup(main_group.animate.shift(LEFT * theory_group.get_x() * 2), rect2.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(0), rect3.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(1), var.animate.shift(LEFT * theory_group.get_x() * 2), ineqs.animate.shift(LEFT * theory_group.get_x() * 2), exp.animate.shift(LEFT * theory_group.get_x() * 2), of.animate.shift(LEFT * theory_group.get_x() * 2), equivalenece.animate.shift(LEFT * theory_group.get_x() * 2).set_opacity(0)), lag_ratio=0.5))\n        self.play(FadeIn(numberplane.background_lines), FadeIn(numberplane.axes))\n        labels_tmp = labels.copy()\n        xptmp = var[0][10:10 + 2].copy()\n        xctmp = var[0][13:13 + 2].copy()\n        self.play(AnimationGroup(Transform(xptmp, labels_tmp[0]), Transform(xctmp, labels_tmp[1]), lag_ratio=0.25))\n        self.remove(xptmp, xctmp)\n        self.add(labels)\n        sr = SurroundingRectangle(VGroup(Dot().align_to(self.camera.frame, UP + RIGHT), Dot().align_to(self.camera.frame, DOWN + RIGHT), Dot().align_to(rect3, RIGHT)), fill_opacity=1).move_to(guide3).set_color_by_gradient((RED, GREEN)).set_opacity(0.35)\n        sr.set_sheen_direction(unit_vector(OF_INITIAL[0] * RIGHT + OF_INITIAL[1] * UP))\n        self.remove(main_group, rect2, equivalenece)\n        big_hl = CreateHighlight(ineqs)\n        hl = CreateHighlight(ineqs[0][7:7 + 7])\n        self.play(exp.animate.set_opacity(BIG_OPACITY), of.animate.set_opacity(BIG_OPACITY), FadeIn(big_hl))\n        self.play(AnimationGroup(Transform(big_hl, hl), Create(i4), lag_ratio=0.5))\n        self.remove(big_hl)\n        self.add(hl)\n        self.play(FadeIn(i4_hp))\n        self.play(AnimationGroup(FadeOut(hl), Create(i1), Create(i2), Create(i3), Create(i5), AnimationGroup(FadeOut(i4_hp), FadeIn(area)), lag_ratio=0.25))\n        self.play(AnimationGroup(AnimationGroup(FadeOut(i1), FadeOut(i2), FadeOut(i3), FadeOut(i4), FadeOut(i5)), lag_ratio=0.5))\n        self.play(area.area.animate(rate_func=there_and_back, run_time=1.25).set_fill(BLUE, 0.5))\n        self.play(exp.animate.set_opacity(1), of.animate.set_opacity(MED_OPACITY), ineqs.animate.set_opacity(BIG_OPACITY))\n        self.add(sr)\n        thingy = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(OF_INITIAL[1], OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        self.play(AnimationGroup(thingy.animate(run_time=2).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 7), AnimationGroup(Write(of_arrow)), lag_ratio=0))\n        self.remove(thingy)\n        self.play(FadeIn(sweep), FadeIn(sweep_angle), FadeIn(sweep_dots_tmp), of_arrow.animate.set_color(BLUE))\n        sweep.add(sweep_dots_tmp)\n        dl = DashedLine(ORIGIN - 0.0001, ORIGIN + 0.0001).set_z_index(of_arrow.get_z_index() - 1e-05).set_color(BLUE)\n\n        def of_updater(obj):\n            start = of_arrow.get_start()\n            end = of_arrow.get_end()\n            point = intersection(line(start, end), line(sweep.line.get_start(), sweep.line.get_end()))\n            new_point = np.array([*point, 0])\n            of_arrow.put_start_and_end_on(new_point, new_point + np.array([*OF_INITIAL, 0]))\n            sweep_angle.become(Angle(sweep.line, of_arrow, dot=True).set_color(BLUE).set_z_index(99))\n\n        def dl_updater(obj):\n            start = of_arrow_shadow.get_start()\n            end = intersection(line(of_arrow_shadow.get_start(), of_arrow_shadow.get_end()), line(sweep.line.get_start(), sweep.line.get_end()))\n            end = np.array([*end, 0])\n            l = 0.085\n            lt = l * 2\n            dist = distance(start, end)\n            dist_rounded = int(dist / lt) * lt\n            if abs(dist) < 0.001:\n                return\n            end_rounded = (end - start) / dist * dist_rounded + start + l / 10\n            obj.become(DashedLine(end_rounded, start, dash_length=l, stroke_width=of_arrow.get_stroke_width() * 0.95).set_color(BLUE).set_z_index(of_arrow.get_z_index() - 0.0001))\n        dl.add_updater(dl_updater)\n        self.add(dl)\n        dummy = VMobject()\n        dummy.add_updater(sweep_updater)\n        dummy.add_updater(of_updater)\n        self.add(dummy)\n        self.camera.frame.save_state()\n        theory_group.save_state()\n        rect3.save_state()\n        self.play(FadeIn(of_arrow_shadow), sweep.animate(run_time=3).move_to(sweep_goal))\n        self.remove(dummy)\n        optimum = sweep.dots\n        sweep.remove(sweep.dots)\n        optimum_texts = VGroup(Tex('$1\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.8).move_to(optimum).align_to(numberplane.axes[0], UP).shift(DOWN * 0.35).set_z_index(100000), Tex('$4\\\\,000\\\\ \\\\mathrm{kg}$').scale(0.8).move_to(optimum).align_to(numberplane.axes[1], RIGHT).shift(LEFT * 0.35).set_z_index(100000), Tex('$\\\\$8\\\\,000$').scale(0.8).next_to(optimum, UP + RIGHT).set_z_index(100000))\n        for i in range(3):\n            optimum_texts[i].add(CreateSR(optimum_texts[i]))\n        self.play(FadeIn(optimum_texts), FadeOut(sweep_angle), of_arrow.animate.set_opacity(0), ineqs.animate.set_opacity(1))\n        for i in [0, 1, 2]:\n            self.play(optimum_texts[i].animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        vm = CreateMeaning(var, '\\\\small variables $\\\\in \\\\mathbb{R}$')\n        vi = CreateMeaning(ineqs, '\\\\small s.t. linear \\\\par inequalities')\n        vo = CreateMeaning(VGroup(of, exp), '\\\\small maximizing \\\\par linear function')\n        dl.remove_updater(dl_updater)\n        self.play(FadeOut(optimum_texts), FadeOut(optimum), FadeOut(dl), FadeOut(sweep))\n        for o, rt in [(vm, 1.25), (vi, 1.5), (vo, 1.5)]:\n            self.play(AnimationGroup(FadeIn(o[0]), Write(o[1], run_time=rt), lag_ratio=0.5))\n        print('NUMBERPLANE CENTER', numberplane.get_center())\n        iextras = []\n        ipts = [[np.array([0, 0]), np.array([1, -2]), 0.5, None], [np.array([0, 0]), np.array([1, -0.5]), 0.5, None], [np.array([3, 0]), np.array([4, 1]), 0.25, None], [np.array([3, 2]), np.array([2, 3.5]), 0.25, '<='], [np.array([0, 4]), np.array([-1, 3.7]), 0.15, '<='], [np.array([0, 4]), np.array([-1, 3]), 0.15, '<='], [np.array([0, 4]), np.array([-1, 0]), 0.2, '<='], [np.array([1, 4]), np.array([0, 4.9]), 0.05, '<=']]\n        inorms = []\n        start = of_arrow_shadow.get_start()\n        for p1, p2, s, op in ipts:\n            a, b, c = Inequality2D.points_to_slope(p1, p2)\n            iq = Inequality2D(a, b, op or '>=', c).set_opacity(0).shift(of_arrow_shadow.get_start())\n            iextras.append(iq)\n            self.add(iq)\n            area.add_inequalities([iq])\n            d = p2 - p1\n            inorms.append((-d[1], d[0], 0) / np.linalg.norm(d))\n            ino = np.array((-d[1], d[0])) / np.linalg.norm(d)\n\n        def ineqs_complex_updater(obj, dt):\n            obj._update_area()\n            best_score = float('inf')\n            best_pos = None\n        self.add(area)\n        area.add_updater(ineqs_complex_updater)\n        of_arrow_shadow.save_state()\n        self.play(*[iextras[i].animate.shift(inorms[i] * ipts[i][-2]) for i in range(len(ipts))], vi[1].animate.scale(1.25), of_arrow_shadow.animate.put_start_and_end_on(np.array([1.4983125140164602, -1.627322003750033, 0.0]), np.array([1.4983125140164602, -1.627322003750033, 0.0]) + of_arrow_shadow.get_end() - of_arrow_shadow.get_start()))\n        self.play(*[iextras[i].animate.shift(-inorms[i] * ipts[i][-2] * 1.1) for i in range(len(ipts))], FadeOut(vm, vi, vo), of_arrow_shadow.animate.restore())\n        area.remove_updater(ineqs_complex_updater)\n        area.remove_inequalities(iextras)\n\n        def of_line_updater(obj):\n            vector = of_arrow_shadow.get_end() - of_arrow_shadow.get_start()\n            x, y, _ = vector\n            optimum = list(solve_farm([x, y]))\n            optimum[0] /= 1000\n            optimum[1] /= 1000\n            sweep.line.become(AffineLine2D([x, y]).line.set_color(BLUE).rotate(PI / 2).move_to(of_arrow_shadow.get_start()).shift([*optimum, 0]))\n            op = '+' if y >= 0 else '-'\n            new_exp = Tex(f'$$\\\\max\\\\ {x:.1f}x_p {op} {abs(y):.1f}x_c$$').move_to(exp).align_to(exp, DOWN)\n            new_exp[0][3:3 + 5].set_color(POTATO_COLOR)\n            new_exp[0][9:9 + 5].set_color(CARROT_COLOR)\n            exp.become(new_exp)\n        sm = Tex('\\\\underline{Simplex Method}').set_z_index(10000000000).scale(1)\n        sm.add(CreateSR(sm, buff=0.17))\n        sm.align_to(self.camera.frame, RIGHT + UP).shift((LEFT * 1.2 + DOWN) * 0.25)\n        self.play(AnimationGroup(FadeIn(sm[1]), Write(sm[0]), lag_ratio=0.2))\n        self.play(FadeIn(optimum), FadeIn(dl), FadeIn(sweep))\n        srcp = sr.copy().set_z_index(sr.get_z_index() + 0.2)\n        thingy = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(OF_INITIAL[1], OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        thingy2 = ImageMobject('assets/thingy.png').set_height(sr.get_height() * 2).move_to(sr).rotate(atan2(-OF_INITIAL[1], -OF_INITIAL[0]) - PI / 2).set_z_index(sr.get_z_index() + 0.1)\n        thingy2.shift(-unit_vector(OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 18)\n        self.add(thingy, thingy2, srcp)\n        self.play(thingy.animate(run_time=2.5).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 9), thingy2.animate(run_time=2.5).shift((OF_INITIAL[1] * UP + OF_INITIAL[0] * RIGHT) * 9))\n        self.remove(thingy, thingy2, srcp)\n        dl.add_updater(dl_updater)\n        self.play(*[MyFlash(d, color=WHITE, z_index=d.get_z_index() + 1) for d in area.dots], MyFlash(optimum, color=BLUE, z_index=optimum.get_z_index() + 2))\n\n        def sr_updater(obj):\n            vector = of_arrow_shadow.get_end() - of_arrow_shadow.get_start()\n            obj.set_sheen_direction(unit_vector(vector))\n        sr.add_updater(sr_updater)\n        dummy = VMobject()\n        dummy.add_updater(of_line_updater)\n        dummy.add_updater(sweep_updater)\n        self.add(dummy)\n        angle = atan2(OF_INITIAL[1], OF_INITIAL[0])\n        self.play(Rotate(of_arrow_shadow, -angle, about_point=of_arrow_shadow.get_start()), run_time=2)\n        self.play(*[MyFlash(d, color=BLUE, z_index=d.get_z_index() + 1) for d in sweep.dots])\n        self.play(Rotate(of_arrow_shadow, +angle - 2 * PI, about_point=of_arrow_shadow.get_start()), run_time=5)\n        self.remove(dummy)\n        sr.remove_updater(sr_updater)\n        dl.remove_updater(dl_updater)\n        self.play(FadeOut(optimum), FadeOut(dl), FadeOut(sweep))\n        fade_rect = get_fade_rect()\n        of_arrow_shadow.set_z_index(fade_rect.get_z_index() - 1e-11)\n        of_arrow_shadow_2 = of_arrow_shadow.copy().set_color(BLUE).set_z_index(fade_rect.get_z_index() + 1)\n        of_dot = Dot().scale(OPTIMUM_DOT_SCALE).set_color(BLUE).move_to(of_arrow_shadow_2.get_start()).set_z_index(of_arrow_shadow_2.get_z_index())\n        trace = TracedPath(of_dot.get_center).set_color(BLUE).set_stroke_width(8).set_z_index(area.dots[0].get_z_index() - 1e-05)\n        G = VGroup(area, of_arrow_shadow, numberplane, labels[0])\n        l0 = Line(start=of_dot.get_center(), end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())\n        p0 = Tex('pivot \\\\#1').scale(0.75).next_to(l0, DOWN).shift(RIGHT * 1.5).set_z_index(l0.get_z_index())\n        sweep.move_to(of_arrow_shadow_2.get_start())\n        sweep.remove(sweep.lineextra)\n        self.play(FadeIn(of_arrow_shadow_2), FadeIn(of_dot))\n        self.play(VGroup(of_arrow_shadow_2, of_dot).animate.shift(RIGHT * 3), l0.animate.become(Line(start=of_dot.get_center() + RIGHT * 3, end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())), FadeIn(p0, run_time=1), run_time=2)\n        l1 = Line(start=of_dot.get_center(), end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())\n        us1 = 0.5\n        p1 = Tex('pivot \\\\#2').scale(0.75).next_to(l1, RIGHT).shift(UP * (1 - us1)).set_z_index(l1.get_z_index())\n        self.play(l0.animate.shift(DOWN * us1), p0.animate.shift(DOWN * us1), l1.animate.become(Line(start=of_dot.get_center() + UP * (2 - us1), end=of_dot.get_center() + DOWN * us1, color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())), G.animate.shift(DOWN * us1), FadeIn(p1, shift=DOWN * us1, run_time=1), VGroup(of_arrow_shadow_2, of_dot).animate.shift(UP * (2 - us1)), run_time=1.5)\n        l2 = Line(start=of_dot.get_center(), end=of_dot.get_center(), color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())\n        p2 = Tex('pivot \\\\#3').scale(0.75).next_to(l2.get_center(), UP + RIGHT).shift(LEFT).set_z_index(l1.get_z_index())\n        us2 = 1\n        self.play(l2.animate.become(Line(start=of_dot.get_center() + UP * (2 - us2) + LEFT * 2, end=of_dot.get_center() + DOWN * us2, color=trace.get_color(), stroke_width=trace.get_stroke_width()).set_z_index(trace.get_z_index())), l0.animate.shift(DOWN * us2), l1.animate.shift(DOWN * us2), p0.animate.shift(DOWN * us2), p1.animate.shift(DOWN * us2), G.animate.shift(DOWN * us2), FadeIn(p2, shift=DOWN * us2, run_time=1), VGroup(of_arrow_shadow_2, of_dot).animate.shift(UP * (2 - us2) + LEFT * 2), run_time=1.5)\n        self.play(MyFlash(of_dot, color=BLUE, z_index=optimum.get_z_index() + 2))\n        self.play(VGroup(numberplane, of_arrow_shadow, area, labels[0]).animate.shift(UP * (us1 + us2)), FadeOut(of_arrow_shadow_2, of_dot, l0, l1, l2, p0, p1, p2, shift=UP * (us1 + us2)))\n        VGroup(l0, l1, l2, p0, p1, p2).shift(UP * (us1 + us2))\n        ineqs2 = Tex('$$\\\\begin{aligned}\\n        x_1, x_2  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_1 \\\\phantom{{}+ x_2} &\\\\le 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_2 &\\\\le 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_1 + x_2 &\\\\le 5\\\\,000\\n                \\\\end{aligned}$$').align_to(ineqs, UP + RIGHT)\n        exp2 = Tex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_1 + ' + str(OF_INITIAL[1]) + ' x_2$$').align_to(exp, UP + LEFT)\n        var2 = Tex('variables: $x_1, x_2$').align_to(var, UP + LEFT)\n        labels2 = VGroup(Tex('$x_1$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[0], DOWN, buff=0.33).align_to(self.camera.frame, RIGHT).shift(LEFT * 0.2), Tex('$x_2$').scale(1.2).move_to(numberplane).next_to(numberplane.axes[1], LEFT, buff=0.23).align_to(self.camera.frame, UP).shift(DOWN * 0.35)).set_z_index(i1.get_z_index() + 1)\n        labels2[0].align_to(labels[0], UP + LEFT)\n        labels2[1].align_to(labels[1], UP + LEFT)\n        iindexes = [0, 3, 7, 14, 21, 24]\n        eindexes = [6, 12]\n        vindexes = [10, 13]\n        self.play(Transform(ineqs, ineqs2), Transform(exp, exp2), Transform(var, var2), Transform(labels, labels2), *[MyFlash(ineqs2[0][i + 1], z_index=ineqs.get_z_index() - 1, color=WHITE, opacity=0.5, line_length=0.08) for i in iindexes], *[MyFlash(exp2[0][i + 1], z_index=exp.get_z_index() - 1, color=WHITE, opacity=0.5, line_length=0.08) for i in eindexes], *[MyFlash(var2[0][i + 1], z_index=var.get_z_index() - 1, color=WHITE, opacity=0.5, line_length=0.08) for i in vindexes], MyFlash(labels2[0][0][1], z_index=labels.get_z_index() - 1, color=WHITE, opacity=0.5, line_length=0.08), MyFlash(labels2[1][0][1], z_index=labels.get_z_index() - 1, color=WHITE, opacity=0.5, line_length=0.08))\n        of_arrow_shadow_2 = of_arrow_shadow.copy().set_color(BLUE).set_z_index(fade_rect.get_z_index() + 1)\n        of_dot = Dot().scale(OPTIMUM_DOT_SCALE).set_color(BLUE).move_to(of_arrow_shadow_2.get_start()).set_z_index(of_arrow_shadow_2.get_z_index())\n        hl = CreateHighlight(ineqs[0][:7])\n        self.play(FadeIn(of_dot), FadeIn(of_arrow_shadow_2), MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1))\n        i1.set_color(YELLOW).set_opacity(0)\n        i2.set_color(YELLOW).set_opacity(0)\n        i3.set_color(YELLOW).set_opacity(0)\n        i4.set_color(YELLOW).set_opacity(0)\n        i5.set_color(YELLOW).set_opacity(0)\n        self.play(FadeIn(hl), i1.animate.set_opacity(1), i2.animate.set_opacity(1))\n        val = Tex('$(0, 0)$').scale(0.6).next_to(of_dot, UP).set_z_index(10000000000)\n        val.add(CreateSR(val))\n\n        def value_updater(obj, dt):\n            c = of_dot.get_center() - of_arrow_shadow.get_start()\n            x = int(round(c[0] * 1000))\n            y = int(round(c[1] * 1000))\n\n            def fmt(x):\n                x = str(x)\n                if len(x) == 4:\n                    return f'{x[0]}\\\\,{x[1:]}'\n                return x\n            val2 = Tex(f'$({fmt(x)}, {fmt(y)})$').scale(0.6).next_to(of_dot, UP).set_z_index(10000000000)\n            val2.add(CreateSR(val2))\n            val.become(val2)\n        hl2 = CreateHighlight(ineqs[0][7:14])\n        self.play(FadeIn(val))\n        self.play(FadeIn(p0), MyFlash(of_dot.copy().shift(RIGHT * 3), color=WHITE, z_index=of_dot.get_z_index() + 1))\n        val.add_updater(value_updater)\n        a_surprise_weapon_that_will_help_us_later = VGroup(ineqs.copy(), exp.copy(), var.copy(), of.copy())\n        self.play(of_arrow_shadow_2.animate.shift(RIGHT * 1.5), of_dot.animate.shift(RIGHT * 1.5), Transform(hl, CreateHighlight(ineqs[0][3:7])), i1.animate.set_opacity(0), run_time=1.5)\n        self.play(of_arrow_shadow_2.animate.shift(RIGHT * 1.5), of_dot.animate.shift(RIGHT * 1.5), FadeIn(hl2), i4.animate.set_opacity(1), run_time=1.5)\n        G = VGroup(area, of_arrow_shadow, numberplane, labels[0])\n        i1.line.put_start_and_end_on(i1.line.get_start() + UP * 5, i1.line.get_end() + DOWN * 5)\n        i3.line.put_start_and_end_on(i3.line.get_start() + (UP + LEFT) * 5, i3.line.get_end() + (DOWN + RIGHT) * 5)\n        p1.shift(DOWN * us1)\n        p2.shift(DOWN * us1)\n        self.play(G.animate.shift(DOWN * us1), p0.animate.shift(DOWN * us1), FadeIn(p1, shift=DOWN * us1), of_arrow_shadow_2.animate.shift(UP * (2 - us1)), of_dot.animate.shift(UP * (2 - us1)), Transform(hl, CreateHighlight(ineqs[0][21:])), i2.animate.set_opacity(0).shift(DOWN * us1), i3.animate.set_opacity(1).shift(DOWN * us1), run_time=1.5)\n        i2.shift(UP * us1)\n        p2.shift(DOWN * us2)\n        i5.shift(DOWN * us1)\n        self.play(G.animate.shift(DOWN * us2), FadeIn(p2, shift=DOWN * us2), p0.animate.shift(DOWN * us2), p1.animate.shift(DOWN * us2), of_arrow_shadow_2.animate.shift(UP * (2 - us2) + LEFT * 2), of_dot.animate.shift(UP * (2 - us2) + LEFT * 2), Transform(hl2, CreateHighlight(ineqs[0][14:21])), i4.animate.set_opacity(0).shift(DOWN * us2), i5.animate.set_opacity(1).shift(DOWN * us2), i3.animate.shift(DOWN * us2), run_time=1.5)\n        val.remove_updater(value_updater)\n        self.play(AnimationGroup(MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1), val.animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE), lag_ratio=0.25))\n        self.play(G.animate.shift(UP * (us1 + us2)), i5.animate.set_opacity(0).shift(UP * (us1 + us2)), i3.animate.set_opacity(0).shift(UP * (us1 + us2)), FadeOut(hl, hl2), FadeOut(val, of_arrow_shadow_2, of_dot, p0, p1, p2, shift=UP * (us1 + us2)))\n        ineqs3 = ComplexTex('$$\\\\begin{aligned}\\n        x_1, x_2, s_1, s_2, s_3  &\\\\ge 0 \\\\\\\\[0.3em]\\n              x_1 \\\\phantom{{}+ x_2} + s_1 \\\\phantom{{} + s_2 + s_3} &= 3\\\\,000 \\\\\\\\[-0.2em]\\n              x_2 \\\\phantom{{} + s_1} + s_2 \\\\phantom{{} + s_3} &= 4\\\\,000 \\\\\\\\[-0.2em]\\n              x_1 + x_2 \\\\phantom{{} + s_1 + s_2} + s_3 &= 5\\\\,000\\n                \\\\end{aligned}$$').move_to(ineqs).set_z_index(ineqs.get_z_index())\n        var3 = ComplexTex('variables: $x_1, x_2, s_1, s_2, s_3$').move_to(var).set_z_index(var.get_z_index())\n        space = 2.5\n        guide4 = -guide2.get_center() + RIGHT * (space / 2)\n        of3 = of.copy()\n        exp3 = exp2.copy().move_to(exp).set_z_index(exp.get_z_index())\n        theory_group_two = VGroup(of3, exp3, ineqs3, var3).move_to(guide4)\n        i1.shift(RIGHT * space / 2)\n        i2.shift(RIGHT * space / 2)\n        i3.shift(RIGHT * space / 2)\n        i4.shift(RIGHT * space / 2)\n        i5.shift(RIGHT * space / 2)\n        of_arrow_shadow_2.shift(RIGHT * space / 2)\n        of_dot.shift(RIGHT * space / 2)\n        VGroup(of3, exp3).align_to(of, UP)\n        VGroup(var3).align_to(var, UP)\n        VGroup(ineqs3).align_to(ineqs, UP)\n        self.remove(rect3)\n        rect_large.flip().set_height(rect3.get_height()).move_to(rect3).align_to(rect3, RIGHT).set_z_index(rect3.get_z_index())\n        self.add(rect_large)\n        var3[0][16:16 + 2].set_color(ORANGE)\n        var3[0][19:19 + 2].set_color(ORANGE)\n        var3[0][22:22 + 2].set_color(ORANGE)\n        ineqs3[0][6:6 + 2].set_color(ORANGE)\n        ineqs3[0][9:9 + 2].set_color(ORANGE)\n        ineqs3[0][12:12 + 2].set_color(ORANGE)\n        ineqs3[0][19:19 + 2].set_color(ORANGE)\n        ineqs3[0][29:29 + 2].set_color(ORANGE)\n        ineqs3[0][42:42 + 2].set_color(ORANGE)\n        slack = Tex('slack').scale(0.7).set_color(ORANGE).next_to(VGroup(var3[0][16:16 + 2], var3[0][22:22 + 2]), UP, buff=0.25).set_z_index(100000000000)\n        self.play(rect_large.animate.shift(RIGHT * space), VGroup(area, of_arrow_shadow, numberplane, sr, labels[1]).animate.shift(RIGHT * space / 2), Transform(exp, exp3), Transform(of, of3), AnimationGroup(Transform(var[0][:15], var3[0][:15]), AnimationGroup(FadeIn(var3[0][15:]), FadeIn(slack)), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][:5], ineqs3[0][:5]), Transform(ineqs[0][5:5 + 2], ineqs3[0][14:14 + 2])), FadeIn(ineqs3[0][5:5 + 9]), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][7:7 + 2], ineqs3[0][16:16 + 2]), Transform(ineqs[0][9:9 + 5], ineqs3[0][21:21 + 5])), FadeIn(ineqs3[0][18:18 + 3]), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][14:14 + 2], ineqs3[0][26:26 + 2]), Transform(ineqs[0][16:16 + 5], ineqs3[0][31:31 + 5])), FadeIn(ineqs3[0][28:28 + 3]), lag_ratio=0.5), AnimationGroup(AnimationGroup(Transform(ineqs[0][21:21 + 5], ineqs3[0][36:36 + 5]), Transform(ineqs[0][26:], ineqs3[0][44:])), FadeIn(ineqs3[0][41:41 + 3]), lag_ratio=0.5))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp3, ineqs3, var3, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, slack)\n        hl = CreateHighlight(VGroup(ineqs3[0][21], ineqs3[0][31], ineqs3[0][44]))\n        a = Tex('$0$')\n        a.add(Tex('$=$').scale(0.65).rotate(PI / 2).next_to(a, UP, buff=0.1))\n        a.set_color(YELLOW).set_z_index(1000000000).next_to(var3[0][-8:-8 + 2], DOWN, buff=0.1).set_color(WHITE)\n        b = a.copy().next_to(var3[0][-2:], DOWN, buff=0.1).set_color(WHITE)\n        of_arrow_shadow_2.shift(UP * -2 + LEFT * -2)\n        of_dot.shift(UP * -2 + LEFT * -2 + UP * (us1 + us2))\n        val = Tex('$(3\\\\,000, 2\\\\,000)$').scale(0.6).next_to(of_dot, UP).set_z_index(10000000000)\n        val.add(CreateSR(val))\n        self.play(FadeIn(val), FadeIn(of_dot), MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1), i4.animate.set_opacity(1), i3.animate.set_opacity(1))\n        hl1 = CreateHighlight(ineqs3[0][16:26])\n        hl2 = CreateHighlight(ineqs3[0][36:49])\n        self.play(FadeIn(hl1), FadeIn(hl2), var3[0][16:16 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), var3[0][22:22 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), var3[0][18:18 + 1].animate.set_opacity(BIG_OPACITY), var3[0][21:21 + 1].animate.set_opacity(BIG_OPACITY), ineqs3[0][6:6 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), ineqs3[0][12:12 + 2].animate.set_color(YELLOW).set_opacity(BIG_OPACITY), ineqs3[0][8:8 + 1].animate.set_opacity(BIG_OPACITY), ineqs3[0][11:11 + 1].animate.set_opacity(BIG_OPACITY), ineqs3[0][18:18 + 1].animate.set_opacity(BIGGER_OPACITY), ineqs3[0][19:19 + 2].animate.set_color(YELLOW).set_opacity(BIGGER_OPACITY), ineqs3[0][41:41 + 1].animate.set_opacity(BIGGER_OPACITY), ineqs3[0][42:42 + 2].animate.set_color(YELLOW).set_opacity(BIGGER_OPACITY))\n        self.play(FadeOut(hl1), FadeOut(hl2), FadeOut(of_dot), FadeOut(val), i4.animate.set_opacity(0), i3.animate.set_opacity(0), var3[0][16:16 + 2].animate.set_color(ORANGE).set_opacity(1), var3[0][22:22 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][6:6 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][12:12 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][18:18 + 1].animate.set_opacity(1), ineqs3[0][19:19 + 2].animate.set_color(ORANGE).set_opacity(1), ineqs3[0][41:41 + 1].animate.set_opacity(1), ineqs3[0][42:42 + 2].animate.set_color(ORANGE).set_opacity(1), var3[0][18:18 + 1].animate.set_opacity(1), var3[0][21:21 + 1].animate.set_opacity(1), ineqs3[0][8:8 + 1].animate.set_opacity(1), ineqs3[0][11:11 + 1].animate.set_opacity(1))\n        of_arrow_shadow_2 = of_arrow_shadow.copy().set_color(BLUE).set_z_index(fade_rect.get_z_index() + 1)\n        of_dot = Dot().scale(OPTIMUM_DOT_SCALE).set_color(BLUE).move_to(of_arrow_shadow_2.get_start()).set_z_index(of_arrow_shadow_2.get_z_index())\n        vars_buff = 0.25\n        nonbas_vars = VGroup(var3[0][10:10 + 2].copy().set_color(YELLOW), var3[0][13:13 + 2].copy().set_color(YELLOW)).arrange(buff=vars_buff)\n        bas_vars = VGroup(var3[0][16:16 + 2].copy().set_color(ORANGE), var3[0][19:19 + 2].copy().set_color(ORANGE), var3[0][22:22 + 2].copy().set_color(ORANGE)).arrange(buff=vars_buff)\n        VGroup(nonbas_vars, bas_vars).arrange(buff=1.5).move_to(var3).align_to(var3, DOWN)\n        nonbasic = Tex('tight').scale(0.7).next_to(nonbas_vars, UP, buff=0.25).set_z_index(rect_large.get_z_index() + 1).set_opacity(0)\n        basic = Tex('loose').scale(0.7).next_to(bas_vars, UP, buff=0.25).set_z_index(rect_large.get_z_index() + 1).set_opacity(0)\n        nonbasic.align_to(basic, UP)\n        nb = Tex('non-basic').scale(0.7).set_z_index(rect_large.get_z_index() + 1).set_opacity(0).move_to(nonbasic).align_to(nonbasic, UP)\n        bb = Tex('basic').scale(0.7).set_z_index(rect_large.get_z_index() + 1).set_opacity(0).move_to(basic).align_to(nonbasic, UP)\n        self.play(FadeIn(of_dot), FadeIn(of_arrow_shadow_2), MyFlash(of_dot, color=BLUE, z_index=of_dot.get_z_index() + 1))\n        self.play(Succession(Wait(0.5), AnimationGroup(ineqs3[0][0:0 + 2].animate.set_color(YELLOW), ineqs3[0][3:3 + 2].animate.set_color(YELLOW), ineqs3[0][16:16 + 2].animate.set_color(YELLOW), ineqs3[0][26:26 + 2].animate.set_color(YELLOW), ineqs3[0][36:36 + 2].animate.set_color(YELLOW), ineqs3[0][39:39 + 2].animate.set_color(YELLOW), exp3[0][6:6 + 2].animate.set_color(YELLOW), exp3[0][12:12 + 2].animate.set_color(YELLOW), i1.animate.set_opacity(1), i2.animate.set_opacity(1))), AnimationGroup(AnimationGroup(FadeOut(var3[0][:10]), FadeOut(var3[0][12]), FadeOut(var3[0][15]), FadeOut(var3[0][18]), FadeOut(var3[0][21]), FadeOut(slack)), AnimationGroup(Transform(var3[0][10:10 + 2], nonbas_vars[0]), Transform(var3[0][13:13 + 2], nonbas_vars[1]), Transform(var3[0][16:16 + 2], bas_vars[0]), Transform(var3[0][19:19 + 2], bas_vars[1]), Transform(var3[0][22:22 + 2], bas_vars[2])), AnimationGroup(basic.animate.set_opacity(MED_OPACITY), nonbasic.animate.set_opacity(MED_OPACITY)), lag_ratio=0.5))\n        nb.set_opacity(MED_OPACITY)\n        bb.set_opacity(MED_OPACITY)\n        f = 0.3\n        self.play(FadeIn(nb, shift=DOWN * f), FadeOut(nonbasic, shift=DOWN * f))\n        self.play(FadeIn(bb, shift=DOWN * f), FadeOut(basic, shift=DOWN * f))\n        self.play(FadeOut(nb, shift=UP * f), FadeIn(nonbasic, shift=UP * f), FadeOut(bb, shift=UP * f), FadeIn(basic, shift=UP * f))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp3, ineqs3, bas_vars, nonbas_vars, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i1, i2)\n        self.play(AnimationGroup(FadeOut(ineqs3[0][:16]), ineqs3[0][16:].animate.move_to(ineqs3), lag_ratio=0.25))\n        ineqs4 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 3\\\\,000 - x_1 \\\\\\\\[-0.2em]\\n              s_2 &= 4\\\\,000 \\\\phantom{{} - x_1} - x_2 \\\\\\\\[-0.2em]\\n              s_3 &= 5\\\\,000 - x_1 - x_2\\n                \\\\end{aligned}$$').move_to(ineqs3).align_to(ineqs3, DOWN).set_z_index(ineqs3.get_z_index())\n        ineqs4[0][0:0 + 2].set_color(ORANGE)\n        ineqs4[0][10:10 + 2].set_color(ORANGE)\n        ineqs4[0][20:20 + 2].set_color(ORANGE)\n        ineqs4[0][8:8 + 2].set_color(YELLOW)\n        ineqs4[0][18:18 + 2].set_color(YELLOW)\n        ineqs4[0][28:28 + 2].set_color(YELLOW)\n        ineqs4[0][31:31 + 2].set_color(YELLOW)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(ineqs3[0][18]), FadeOut(ineqs3[0][28]), FadeOut(ineqs3[0][41])), AnimationGroup(Transform(ineqs3[0][19:19 + 2 + 5], ineqs4[0][0:0 + 2 + 5]), Transform(ineqs3[0][29:29 + 2 + 5], ineqs4[0][10:10 + 2 + 5]), Transform(ineqs3[0][42:42 + 2 + 5], ineqs4[0][20:20 + 2 + 5]), Transform(ineqs3[0][16:16 + 2], ineqs4[0][8:8 + 2]), Transform(ineqs3[0][26:26 + 2], ineqs4[0][18:18 + 2]), Transform(ineqs3[0][36:36 + 5], ineqs4[0][28:28 + 5])), AnimationGroup(FadeIn(ineqs4[0][7]), FadeIn(ineqs4[0][17]), FadeIn(ineqs4[0][27])), lag_ratio=0.5), run_time=2)\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp3, ineqs4, bas_vars, nonbas_vars, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i1, i2)\n        hl = CreateHighlight(VGroup(ineqs4[0][0], ineqs4[0][-12])).set_color(BLUE)\n        hlother = CreateHighlight(bas_vars).set_color(BLUE)\n        self.play(FadeIn(hl, hlother))\n        a.next_to(nonbas_vars[0], DOWN, buff=0.1)\n        b.next_to(nonbas_vars[1], DOWN, buff=0.1)\n        hl1 = CreateHighlight(VGroup(nonbas_vars[0], a)).set_color(BLUE)\n        hl2 = CreateHighlight(VGroup(nonbas_vars[1], b)).set_color(BLUE)\n        hlof = CreateHighlight(exp3[0][3:3 + 11]).set_color(BLUE)\n        zero = Tex('$$0$$').set_z_index(exp3.get_z_index()).move_to(exp3[0][3:3 + 11])\n        self.play(AnimationGroup(AnimationGroup(FadeOut(hlother), nonbas_vars[0].animate.set_opacity(BIG_OPACITY), nonbas_vars[1].animate.set_opacity(BIG_OPACITY), exp3[0][3:3 + 11].animate.set_opacity(BIG_OPACITY / 2), exp3[0][8].animate.set_opacity(0), ineqs4[0][7:7 + 3].animate.set_opacity(BIG_OPACITY), ineqs4[0][17:17 + 3].animate.set_opacity(BIG_OPACITY), ineqs4[0][27:27 + 3].animate.set_opacity(BIG_OPACITY), ineqs4[0][30:30 + 3].animate.set_opacity(BIG_OPACITY)), AnimationGroup(FadeIn(hlof), FadeIn(zero), Transform(hl, CreateHighlight(VGroup(ineqs4[0][0], ineqs4[0][3], ineqs4[0][-7], ineqs4[0][-12])).set_color(BLUE))), lag_ratio=1.25))\n        self.play(FadeOut(hlof, hl, zero), exp3[0][3:3 + 11].animate.set_opacity(1), ineqs4[0][7:7 + 3].animate.set_opacity(1), ineqs4[0][17:17 + 3].animate.set_opacity(1), ineqs4[0][27:27 + 3].animate.set_opacity(1), ineqs4[0][30:30 + 3].animate.set_opacity(1), nonbas_vars[0].animate.set_opacity(1), nonbas_vars[1].animate.set_opacity(1))\n        dpivot = Tex(\"\\\\textit{Dantzig's pivot rule}\").set_width(sm[0].get_width()).next_to(sm, DOWN, buff=0).set_z_index(10000000000)\n        self.play(AnimationGroup(Transform(sm[1], CreateSR(VGroup(sm[0], dpivot), buff=0.17)), FadeIn(dpivot), lag_ratio=0.5))\n        hl1 = CreateHighlight(exp3[0][3:3 + 5]).set_color(GREEN)\n        hl2 = CreateHighlight(exp3[0][9:9 + 5]).set_color(GREEN)\n        offset = -0.05\n        dashed_x = Arrow(of_dot.get_center(), [of_arrow_shadow_2.get_end()[0] - offset, of_dot.get_center()[1], 0], stroke_width=LINE_STROKE + 0.01, buff=0).set_color(GREEN).set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        dashed_y = Arrow(of_dot.get_center(), [of_dot.get_center()[0], of_arrow_shadow_2.get_end()[1] - offset, 0], buff=0, stroke_width=LINE_STROKE + 0.01).set_color(GREEN).set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        a = of_arrow_shadow_2.copy().set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        b = of_arrow_shadow_2.copy().set_z_index(of_arrow_shadow.get_z_index() - 0.001)\n        self.play(FadeIn(hl1), FadeIn(hl2))\n        self.play(Transform(a, dashed_x), Transform(b, dashed_y), run_time=1)\n        self.remove(a, b)\n        self.add(dashed_x, dashed_y)\n        self.play(FadeOut(dashed_x), FadeOut(hl1))\n        b = VGroup(nonbas_vars[1].copy(), bas_vars[0].copy(), bas_vars[1].copy(), bas_vars[2].copy())\n        b.arrange(buff=vars_buff)\n        b.move_to(bas_vars)\n        b[0].set_color(WHITE)\n        nb = VGroup(nonbas_vars[0].copy())\n        nb.move_to(nonbas_vars)\n        downshift = 1\n        self.play(AnimationGroup(FadeOut(dashed_y, shift=UP + DOWN * downshift), of_dot.animate.shift(UP + DOWN * downshift), of_arrow_shadow_2.animate.shift(UP + DOWN * downshift).set_opacity(1), i2.animate.set_opacity(0).shift(DOWN * downshift), of_arrow_shadow.animate.shift(DOWN * downshift), labels[0].animate.shift(DOWN * downshift), numberplane.animate.shift(DOWN * downshift), area.animate.shift(DOWN * downshift), FadeOut(hl2), Transform(nonbas_vars[0], nb[0]), Transform(nonbas_vars[1], b[0]), Transform(bas_vars[0], b[1]), Transform(bas_vars[1], b[2]), Transform(bas_vars[2], b[3]), ineqs4[0][18:18 + 2].animate.set_color(WHITE), ineqs4[0][31:31 + 2].animate.set_color(WHITE), exp3[0][-2:].animate.set_color(WHITE)))\n        self.remove(nonbas_vars[0], nonbas_vars[1])\n        self.remove(bas_vars[0], bas_vars[1], bas_vars[2])\n        self.add(b, nb)\n        nonbas_vars = nb\n        bas_vars = b\n        POSSIBLE_COLOR = GRAY\n        i3.set_color(POSSIBLE_COLOR).shift(DOWN * downshift)\n        i5.set_color(POSSIBLE_COLOR).shift(DOWN * downshift)\n        inter = intersection(line(i3.line.get_start(), i3.line.get_end()), line(i1.line.get_start(), i1.line.get_end()))\n        idot = area.dots[0].copy().move_to([*inter, 0])\n        inter = intersection(line(i5.line.get_start(), i5.line.get_end()), line(i1.line.get_start(), i1.line.get_end()))\n        idot_correct = area.dots[0].copy().move_to([*inter, 0]).set_z_index(area.dots[0].get_z_index() + 1)\n        hls2 = CreateHighlight(ineqs4[0][10:10 + 2]).set_color(POSSIBLE_COLOR)\n        hls3 = CreateHighlight(ineqs4[0][20:20 + 2]).set_color(POSSIBLE_COLOR)\n        hl1 = CreateHighlight(ineqs4[0][13:13 + 4]).set_color(POSSIBLE_COLOR)\n        hl2 = CreateHighlight(ineqs4[0][17:17 + 3]).set_color(POSSIBLE_COLOR)\n        hl3 = CreateHighlight(ineqs4[0][23:23 + 4]).set_color(POSSIBLE_COLOR)\n        hl4 = CreateHighlight(ineqs4[0][30:30 + 3]).set_color(POSSIBLE_COLOR)\n        self.play(AnimationGroup(FadeIn(hl2), FadeIn(hl4), lag_ratio=0.07))\n        self.play(AnimationGroup(AnimationGroup(ineqs4[0][10:10 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[2].animate.set_color(POSSIBLE_COLOR), i3.animate.set_opacity(1), FadeIn(hls2)), AnimationGroup(ineqs4[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[3].animate.set_color(POSSIBLE_COLOR), i5.animate.set_opacity(1), FadeIn(idot, hls3)), lag_ratio=0.07))\n        self.add(idot_correct)\n        G = VGroup(i5, i3, i1, labels[0], area, numberplane, of_arrow_shadow, of_dot, of_arrow_shadow_2, idot, idot_correct)\n        G.save_state()\n        labels[1].save_state()\n        self.play(G.animate.scale(1.75, about_point=idot_correct.get_center() + UP * 3).shift(RIGHT * 0.8), labels[1].animate.scale(1.75, about_point=idot_correct.get_center() + UP * 3).shift(RIGHT * 0.8))\n        self.play(ineqs4[0][10:10 + 2].animate.set_color(GREEN), bas_vars[2].animate.set_color(GREEN), i5.line.animate.set_color(GREEN).set_stroke_width(LINE_STROKE + 3), hls2.animate.set_color(GREEN), idot_correct.animate.set_color(GREEN), hl2.animate.set_color(GREEN), ineqs4[0][20:20 + 2].animate.set_color(RED), bas_vars[3].animate.set_color(RED), i3.line.animate.set_color(RED).set_stroke_width(LINE_STROKE + 3), hls3.animate.set_color(RED), idot.animate.set_color(RED), hl4.animate.set_color(RED))\n        correct = Tex('valid', color=GREEN).scale(0.85).set_z_index(idot.get_z_index()).next_to(idot_correct, LEFT + UP, buff=0.1)\n        oob = Tex('out of bounds', color=RED).scale(0.85).set_z_index(idot.get_z_index()).next_to(idot, RIGHT + UP, buff=0.1)\n        self.play(AnimationGroup(AnimationGroup(MyFlash(idot_correct, color=GREEN, z_index=idot_correct.get_z_index() + 1), FadeIn(correct)), AnimationGroup(MyFlash(idot, color=RED, z_index=idot_correct.get_z_index() + 1), FadeIn(oob)), lag_ratio=0.75))\n        self.play(FadeOut(correct), FadeOut(oob))\n        self.play(G.animate.restore(), labels[1].animate.restore(), ineqs4[0][10:10 + 2].animate.set_color(POSSIBLE_COLOR), ineqs4[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[2].animate.set_color(POSSIBLE_COLOR), bas_vars[3].animate.set_color(POSSIBLE_COLOR), hls2.animate.set_color(POSSIBLE_COLOR), hls3.animate.set_color(POSSIBLE_COLOR), hl2.animate.set_color(POSSIBLE_COLOR), hl4.animate.set_color(POSSIBLE_COLOR))\n        t1 = Tex('${} - 1\\\\,000$').set_z_index(ineqs4.get_z_index() + 1)\n        t1[0][1:].set_color(BLUE)\n        align_object_by_coords(t1, t1[0][0].get_center(), ineqs4[0][17].get_center())\n        t2 = Tex('${} - 1\\\\,000$').set_z_index(ineqs4.get_z_index() + 1)\n        t2[0][1:].set_color(BLUE)\n        align_object_by_coords(t2, t2[0][0].get_center(), ineqs4[0][30].get_center())\n        tmp1 = of_dot.copy()\n        tmp2 = of_dot.copy()\n        (ineqs4[0][18:18 + 2].set_opacity(0),)\n        (ineqs4[0][31:38 + 2].set_opacity(0),)\n        a = ineqs4[0][18:18 + 2].copy().set_opacity(1)\n        b = ineqs4[0][31:38 + 2].copy().set_opacity(1)\n        a.save_state()\n        b.save_state()\n        self.play(AnimationGroup(AnimationGroup(FadeOut(hl2), FadeOut(hl4)), AnimationGroup(Transform(tmp1, t1[0][1:]), Transform(tmp2, t2[0][1:]), a.animate.next_to(t1, RIGHT + DOWN, buff=0.015).shift(UP * 0.13).set_opacity(0.4).scale(0.7), b.animate.next_to(t2, RIGHT + DOWN, buff=0.015).shift(UP * 0.13).set_opacity(0.4).scale(0.7)), lag_ratio=0.5))\n        self.remove(tmp1, tmp2)\n        self.add(t1, t2)\n        ineqs4[0][17].set_opacity(0)\n        ineqs4[0][30].set_opacity(0)\n\n        def tupdater(obj, dt):\n            val = round((of_dot.get_center() - of_arrow_shadow.get_start())[1] * 1000)\n            tt1 = Tex('${} - ' + str(val)[0] + '\\\\,' + str(val)[1:] + '$').set_z_index(ineqs4.get_z_index() + 1)\n            tt1[0][1:].set_color(BLUE)\n            align_object_by_coords(tt1, tt1[0][0].get_center(), ineqs4[0][17].get_center())\n            obj.become(tt1)\n\n        def tupdater2(obj, dt):\n            val = round((of_dot.get_center() - of_arrow_shadow.get_start())[1] * 1000)\n            tt1 = Tex('${} - ' + str(val)[0] + '\\\\,' + str(val)[1:] + '$').set_z_index(ineqs4.get_z_index() + 1)\n            tt1[0][1:].set_color(BLUE)\n            align_object_by_coords(tt1, tt1[0][0].get_center(), ineqs4[0][30].get_center())\n            obj.become(tt1)\n        t1.add_updater(tupdater)\n        t2.add_updater(tupdater2)\n        downshift = 1.5\n        self.play(of_dot.animate.shift(UP * (3 - downshift)), of_arrow_shadow_2.animate.shift(UP * (3 - downshift)), VGroup(i3, i5, of_arrow_shadow, area, numberplane, labels[0], idot, idot_correct).animate.shift(DOWN * downshift), run_time=3)\n        t1.remove_updater(tupdater)\n        t2.remove_updater(tupdater2)\n        tupdater(t1, 0)\n        tupdater2(t2, 0)\n        self.remove(idot_correct)\n        hlll = CreateHighlight(VGroup(ineqs4[0][13:13 + 4], t1)).set_color(YELLOW)\n        self.play(bas_vars[2].animate.set_color(YELLOW), ineqs4[0][10:10 + 2].animate.set_color(YELLOW), ineqs4[0][20:20 + 2].animate.set_color(ORANGE), i5.animate.set_color(YELLOW), FadeIn(hlll), FadeOut(i3, idot), FadeOut(hls2, hls3))\n        t1.add_updater(tupdater)\n        t2.add_updater(tupdater2)\n        self.play(of_dot.animate.shift(UP * 0.5).set_color(RED), of_arrow_shadow_2.animate.shift(UP * 0.5).set_color(RED), hlll.animate.set_color(RED), run_time=1)\n        hls2.set_color(RED)\n        self.play(FadeIn(hls2))\n        self.play(of_dot.animate.shift(DOWN * 0.5).set_color(BLUE), of_arrow_shadow_2.animate.shift(DOWN * 0.5).set_color(BLUE), hlll.animate.set_color(YELLOW), FadeOut(hls2), run_time=1)\n        hls2.set_color(POSSIBLE_COLOR)\n        t1.remove_updater(tupdater)\n        t2.remove_updater(tupdater2)\n        self.play(bas_vars[2].animate.set_color(POSSIBLE_COLOR), ineqs4[0][10:10 + 2].animate.set_color(POSSIBLE_COLOR), ineqs4[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), i5.animate.set_color(POSSIBLE_COLOR), FadeOut(hlll), FadeIn(i3, idot), FadeIn(hls2, hls3), FadeOut(t1[0][1:]), FadeOut(t2[0][1:]), Succession(Wait(0.5), AnimationGroup(AnimationGroup(Transform(a, ineqs4[0][18:18 + 2].copy().set_opacity(1)), Transform(b, ineqs4[0][31:31 + 2].copy().set_opacity(1))), AnimationGroup(FadeIn(hl2), FadeIn(hl4)), lag_ratio=0.5)))\n        self.remove(t1, t2)\n        t1.set_opacity(0)\n        t1[0][0].set_opacity(0)\n        t2.set_opacity(0)\n        t2[0][0].set_opacity(0)\n        ineqs4[0][17:17 + 1].set_opacity(1)\n        ineqs4[0][30:30 + 1].set_opacity(1)\n        ineqs4[0][18:18 + 2].set_opacity(1)\n        ineqs4[0][31:31 + 2].set_opacity(1)\n        self.remove(a, b)\n        four = Tex('$-4\\\\,000$').move_to(hl1).align_to(ineqs4, RIGHT).shift(RIGHT * 0.5).set_z_index(ineqs4.get_z_index() + 1)\n        five = Tex('$-5\\\\,000$').move_to(hl3).align_to(ineqs4, RIGHT).shift(RIGHT * 0.5).set_z_index(ineqs4.get_z_index() + 1)\n        ff = VGroup(four, five).scale(0.9).arrange(RIGHT, buff=0.6).next_to(ineqs4, UP, buff=0.5)\n        gt = Tex('$>$', stroke_width=1.5).scale(0.5).move_to(VGroup(four, five)).set_z_index(ineqs4.get_z_index() + 1)\n        a = ineqs4[0][13:13 + 4].copy()\n        b = ineqs4[0][23:23 + 4].copy()\n        am = ineqs4[0][17:17 + 1].copy()\n        bm = ineqs4[0][30:30 + 1].copy()\n        ah = CreateHighlight(four).set_color(POSSIBLE_COLOR)\n        bh = CreateHighlight(five).set_color(POSSIBLE_COLOR)\n        fix1 = hls2.copy()\n        fix2 = hls3.copy()\n        self.remove(hls2, hls3)\n        self.add(fix1, fix2)\n        self.play(AnimationGroup(AnimationGroup(Transform(fix1, hl1), Transform(fix2, hl3)), AnimationGroup(AnimationGroup(Transform(a, four[0][1:]), Transform(am, four[0][0]), FadeIn(ah)), AnimationGroup(Transform(b, five[0][1:]), Transform(bm, five[0][0]), FadeIn(bh)), lag_ratio=0.25), lag_ratio=0.75))\n        self.remove(fix1, fix2)\n        self.add(hl1, hl3)\n        self.remove(a, am, b, bm)\n        self.add(four, five)\n        self.play(FadeIn(gt), ah.animate.set_color(GREEN), bh.animate.set_color(RED), ineqs4[0][10:10 + 2].animate.set_color(GREEN), bas_vars[2].animate.set_color(GREEN), i5.line.animate.set_color(GREEN), hl1.animate.set_color(GREEN), hl2.animate.set_color(GREEN), ineqs4[0][20:20 + 2].animate.set_color(RED), bas_vars[3].animate.set_color(RED), i3.line.animate.set_color(RED), hl3.animate.set_color(RED), idot.animate.set_color(RED), hl4.animate.set_color(RED))\n        nb = VGroup(nonbas_vars[0].copy(), bas_vars[2].copy().set_color(YELLOW))\n        nb.arrange(buff=vars_buff)\n        nb.move_to(nonbas_vars)\n        b = VGroup(bas_vars[0].copy(), bas_vars[1].copy(), bas_vars[3].copy().set_color(ORANGE))\n        b.arrange(buff=vars_buff)\n        b.move_to(bas_vars)\n        self.play(FadeOut(five, bh, hl4, hl3), FadeOut(i3), FadeOut(gt), FadeOut(idot), ineqs4[0][20:20 + 2].animate.set_color(ORANGE))\n        self.play(Transform(nonbas_vars[0], nb[0]), Transform(bas_vars[2], nb[1]), Transform(bas_vars[0], b[0]), Transform(bas_vars[1], b[1]), Transform(bas_vars[3], b[2]), ineqs4[0][10:10 + 2].animate.set_color(YELLOW), FadeOut(four, ah, hl2, hl1), i5.animate.set_color(YELLOW))\n        area.save_state()\n        i3.shift(UP * 3)\n        i2.shift(UP * 1.5)\n        i1.shift(UP * 1.5)\n        self.play(of_dot.animate.shift(UP * 3), of_arrow_shadow_2.animate.shift(UP * 3), VGroup(i5, of_arrow_shadow, area, numberplane, labels[0]).animate.shift(UP * 3))\n        ORIGIN_OFFSET = of_arrow_shadow.get_start()\n        ineqs_tmp = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 3\\\\,000 - x_1 \\\\\\\\[-0.2em]\\n              s_2 &= 4\\\\,000 \\\\phantom{{} - x_1} - x_2 \\\\\\\\[-0.2em]\\n              s_3 &= 5\\\\,000 - x_1 - x_2 \\\\\\\\[-0.2em]\\n              s_4 &= 2\\\\,000 - x_1 + 2.0x_2\\n                \\\\end{aligned}$$').move_to(ineqs3).align_to(ineqs3, DOWN).set_z_index(ineqs3.get_z_index())\n        align_object_by_coords(ineqs_tmp, ineqs_tmp[0][0].get_center(), ineqs4[0][0].get_center())\n        ineqs_tmp[0][33:33 + 2].set_color(GRAY)\n        ineqs_tmp[0][41:41 + 2].set_color(YELLOW)\n        i6 = Inequality2D(1, -2, '<=', 2).set_color(GRAY).shift(ORIGIN_OFFSET).set_z_index(i5.get_z_index())\n        i6.crop_to_screen(self.camera.frame)\n        ac = area.copy()\n        ac.clear_inequalities()\n        ac.add_inequalities([i1, i2, i3, i4, i5, i6])\n        inter2 = intersection(line(i6.line.get_start(), i6.line.get_end()), line(i1.line.get_start(), i1.line.get_end()))\n        idot2 = area.dots[0].copy().move_to([*inter2, 0]).scale(1.5)\n        ca = CurvedArrow(start_point=of_arrow_shadow.get_start(), end_point=idot2.get_center() + LEFT * 0.1 + UP * 0.1, angle=PI / 1.5).set_z_index(idot2.get_z_index())\n        hlpos = CreateHighlight(ineqs_tmp[0][43:]).set_color(POSSIBLE_COLOR)\n        hl_two_thousand = CreateHighlight(ineqs_tmp[0][36:36 + 4]).set_color(POSSIBLE_COLOR)\n        six = Tex('$1\\\\,000$').set_z_index(ineqs_tmp.get_z_index() + 1).scale(0.9).next_to(ineqs_tmp, UP, buff=0.5)\n        ch = CreateHighlight(six).set_color(POSSIBLE_COLOR)\n        self.play(Create(i6), FadeOut(area), FadeIn(ac), FadeIn(idot2), FadeIn(ineqs_tmp[0][33:]), FadeIn(hlpos, hl_two_thousand), ineqs4.animate.set_opacity(BIG_OPACITY))\n        self.play(AnimationGroup(AnimationGroup(Addd(ineqs_tmp[0][43:43 + 4].copy(), six, lor=LEFT), Addd(ineqs_tmp[0][36:36 + 4].copy(), six, lor=RIGHT)), FadeIn(six, ch), lag_ratio=0.25))\n        aerr = Tex(\"can't be\").set_z_index(ineqs_tmp.get_z_index() + 1).scale(0.75).next_to(ch, LEFT).set_color(RED)\n        berr = Tex('positive!').set_z_index(ineqs_tmp.get_z_index() + 1).scale(0.75).next_to(ch, RIGHT).set_color(RED)\n        self.play(Write(ca), ineqs_tmp[0][33:33 + 2].animate.set_color(RED), VGroup(ch).animate.set_color(RED), hlpos.animate.set_color(RED), hl_two_thousand.animate.set_color(RED), idot2.animate.set_color(RED), i6.animate.set_color(RED), FadeIn(aerr), FadeIn(berr))\n        area.set_opacity(0)\n        self.play(of_dot.animate.shift(DOWN * 3), of_arrow_shadow_2.animate.shift(DOWN * 3), VGroup(i5, of_arrow_shadow, numberplane, labels[0]).animate.shift(DOWN * 3), area.animate.restore(), FadeOut(ineqs_tmp[0][33:], shift=DOWN * 3), FadeOut(ac, shift=DOWN * 3), FadeOut(ca, shift=DOWN * 3), FadeOut(aerr, berr), FadeOut(idot2, shift=DOWN * 3), FadeOut(ineqs_tmp[0][33:]), FadeOut(hlpos, hl_two_thousand), FadeOut(i6, shift=DOWN * 3), ineqs4.animate.set_opacity(1), FadeOut(six, ch))\n        i3.shift(DOWN * 3)\n        i2.shift(DOWN * 1.5)\n        i1.shift(DOWN * 1.5)\n        hlp1 = CreateHighlight(ineqs4[0][10:10 + 2]).set_color(POSSIBLE_COLOR).set_color(RED)\n        hlp2 = hl2.set_color(RED)\n        hlp3 = hl4.set_color(RED)\n        hlp4 = CreateHighlight(exp3[0][-5:]).set_color(POSSIBLE_COLOR).set_color(RED)\n        t1 = Tex('tight').scale(0.6).next_to(hlp1, LEFT).set_z_index(hlp1.get_z_index()).set_color(RED)\n        l1 = Tex('loose').scale(0.6).next_to(hlp2, RIGHT).set_z_index(hlp2.get_z_index()).set_color(RED)\n        l2 = Tex('loose').scale(0.6).next_to(hlp3, RIGHT).set_z_index(hlp3.get_z_index()).set_color(RED)\n        l3 = Tex('loose').scale(0.6).next_to(hlp4, RIGHT).set_z_index(hlp4.get_z_index()).set_color(RED)\n        self.play(FadeIn(hlp1, hlp2, hlp3, hlp4), FadeIn(t1, shift=LEFT * 0.25), FadeIn(l1, shift=RIGHT * 0.25), FadeIn(l2, shift=RIGHT * 0.25), FadeIn(l3, shift=RIGHT * 0.25))\n        ineqs5 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 3\\\\,000 - x_1 \\\\\\\\[-0.2em]\\n              x_2 &= 4\\\\,000 \\\\phantom{{} - x_1} - s_2 \\\\\\\\[-0.2em]\\n              s_3 &= 5\\\\,000 - x_1 - (4\\\\,000 - s_2)\\n                \\\\end{aligned}$$').set_z_index(ineqs4.get_z_index())\n        align_object_by_coords(ineqs5, ineqs5[0][0].get_center(), ineqs4[0][0].get_center())\n        ineqs5[0][0:0 + 2].set_color(ORANGE)\n        ineqs5[0][20:20 + 2].set_color(ORANGE)\n        ineqs5[0][8:8 + 2].set_color(YELLOW)\n        ineqs5[0][18:18 + 2].set_color(YELLOW)\n        ineqs5[0][28:28 + 2].set_color(YELLOW)\n        ineqs5[0][37:37 + 2].set_color(YELLOW)\n        ineqs6 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 3\\\\,000 - x_1 \\\\\\\\[-0.2em]\\n              x_2 &= 4\\\\,000 \\\\phantom{{} - x_1} - s_2 \\\\\\\\[-0.2em]\\n              s_3 &= 1\\\\,000 - x_1 + s_2\\n                \\\\end{aligned}$$').set_z_index(ineqs4.get_z_index())\n        align_object_by_coords(ineqs6, ineqs6[0][0].get_center(), ineqs4[0][0].get_center())\n        ineqs6[0][0:0 + 2].set_color(ORANGE)\n        ineqs6[0][20:20 + 2].set_color(ORANGE)\n        ineqs6[0][8:8 + 2].set_color(YELLOW)\n        ineqs6[0][18:18 + 2].set_color(YELLOW)\n        ineqs6[0][28:28 + 2].set_color(YELLOW)\n        ineqs6[0][31:31 + 2].set_color(YELLOW)\n        self.play(AnimationGroup(FadeOut(hlp1, hlp2), FadeOut(t1, l1), AnimationGroup(ineqs4[0][18:18 + 2].animate.move_to(ineqs5[0][10:10 + 2]), ineqs4[0][10:10 + 2].animate.move_to(ineqs5[0][18:18 + 2])), lag_ratio=0.5))\n        exp4 = Tex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_1 + ' + str(OF_INITIAL[1]) + ' (4\\\\,000 - s_2)$$').set_z_index(exp3.get_z_index())\n        exp4[0][6:6 + 2].set_color(YELLOW)\n        align_object_by_coords(exp4, exp4[0][0].get_center(), exp3[0][0].get_center())\n        exp4[0][18:18 + 2].set_color(YELLOW)\n        exp5 = Tex('$$\\\\max\\\\ ' + str(OF_INITIAL[0]) + 'x_1 - ' + str(OF_INITIAL[1]) + ' s_2 + 6\\\\,800$$').set_z_index(exp3.get_z_index())\n        exp5[0][6:6 + 2].set_color(YELLOW)\n        exp5[0][12:12 + 2].set_color(YELLOW)\n        exp5.move_to(exp3)\n        exp5.shift(UP * (exp3[0][0].get_center() - exp5[0][0].get_center())[1])\n        offset = RIGHT * 0.65\n        self.play(AnimationGroup(AnimationGroup(AnimationGroup(FadeOut(hlp3), FadeOut(l2), FadeOut(ineqs4[0][31:31 + 2])), AnimationGroup(Transform(ineqs4[0][13:13 + 5].copy(), ineqs5[0][32:32 + 5]), Transform(ineqs4[0][10:10 + 2].copy(), ineqs5[0][37:37 + 2]), rect_large.animate.shift(offset), Group(area, of_arrow_shadow, numberplane, sr, labels[1], of_dot, of_arrow_shadow_2, i1).animate.shift(offset / 2), Group(sm, dpivot).animate.shift(offset / 4)), AnimationGroup(FadeIn(ineqs5[0][31]), FadeIn(ineqs5[0][39])), lag_ratio=0.5), AnimationGroup(AnimationGroup(FadeOut(hlp4), FadeOut(l3), FadeOut(exp3[0][-2:])), AnimationGroup(Transform(ineqs4[0][13:13 + 5].copy(), exp4[0][13:13 + 5]), Transform(ineqs4[0][10:10 + 2].copy(), exp4[0][18:18 + 2])), AnimationGroup(FadeIn(exp4[0][12]), FadeIn(exp4[0][20])), lag_ratio=0.5), lag_ratio=0.5))\n        nonbas_vars = nb\n        bas_vars = b\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp4, ineqs5, bas_vars, nonbas_vars, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i1, i5, dpivot)\n        self.play(AnimationGroup(AnimationGroup(AnimationGroup(FadeOut(ineqs5[0][30]), FadeOut(ineqs5[0][31]), FadeOut(ineqs5[0][39])), AnimationGroup(Transform(ineqs5[0][36:36 + 3], ineqs6[0][30:30 + 3]), AnimationGroup(ineqs5[0][32:32 + 4].animate.move_to(ineqs6[0][23:23 + 4]).set_opacity(0), Transform(ineqs5[0][23], ineqs6[0][23]), lag_ratio=0.1)), lag_ratio=0.5), AnimationGroup(AnimationGroup(FadeOut(exp4[0][12]), FadeOut(exp4[0][20]), FadeOut(exp4[0][8])), AnimationGroup(Transform(exp4[0][17], exp5[0][8]), Transform(exp4[0][18:18 + 2], exp5[0][12:12 + 2]), FadeTransform(exp4[0][13:13 + 4], exp5[0][15:15 + 4]), Transform(exp4[0][9:9 + 3], exp5[0][9:9 + 3]), Transform(exp4[0][:8], exp5[0][:8]), rect_large.animate.shift(-offset), Group(area, of_arrow_shadow, numberplane, sr, labels[1], of_dot, of_arrow_shadow_2, i1, trace).animate.shift(offset / 2 * -1), Group(sm, dpivot).animate.shift(-offset / 4)), AnimationGroup(FadeIn(exp5[0][14])), lag_ratio=0.5), lag_ratio=0.5))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp5, ineqs6, bas_vars, nonbas_vars, rect_large, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i1, i5, dpivot)\n        hl1 = CreateHighlight(VGroup(ineqs6[0][0], ineqs6[0][3], ineqs6[0][10], ineqs6[0][21], ineqs6[0][26])).set_color(BLUE)\n        hl2 = CreateHighlight(exp5[0][-4:]).set_color(BLUE)\n        self.play(FadeIn(hl1, hl2), ineqs6[0][7:7 + 3].animate.set_opacity(BIG_OPACITY), ineqs6[0][17:17 + 3].animate.set_opacity(BIG_OPACITY), ineqs6[0][27:27 + 6].animate.set_opacity(BIG_OPACITY), exp5[0][3:3 + 12].animate.set_opacity(BIG_OPACITY), nonbas_vars.animate.set_opacity(BIG_OPACITY))\n        self.play(VGroup(exp5[0][-4:], hl2).animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        self.play(FadeOut(hl1, hl2), ineqs6[0][7:7 + 3].animate.set_opacity(1), ineqs6[0][17:17 + 3].animate.set_opacity(1), ineqs6[0][27:27 + 6].animate.set_opacity(1), exp5[0][3:3 + 12].animate.set_opacity(1), nonbas_vars.animate.set_opacity(1))\n        hl1 = CreateHighlight(exp5[0][3:3 + 5]).set_color(GREEN)\n        hl2 = CreateHighlight(exp5[0][9:9 + 5]).set_color(RED)\n        steps = ComplexTex(\"\\\\begin{enumerate}\\n                \\\\setlength{\\\\itemsep}{4pt}\\n                \\\\setlength{\\\\parskip}{0pt}\\n                \\\\item \\\\textbf{loosen variable} (Dantzig's rule)\\n                \\\\item \\\\textbf{tighten variable} (largest non-positive ratio)\\n                \\\\item \\\\textbf{fix equalities} (swap + substitute)\\n                \\\\end{enumerate}\")\n        rect_down = rect_large.copy().move_to(ORIGIN).rotate(PI / 2).align_to(ORIGIN, UP).shift(DOWN + RIGHT * 3.5).set_z_index(rect_large.get_z_index() - 0.0001).shift(DOWN * 0.7)\n        of_arrow_shadow.set_z_index(rect_down.get_z_index() - 1e-05)\n        g = VGroup(of_dot, of_arrow_shadow_2, i1, i5, area, numberplane, of_arrow_shadow)\n        rect_down.save_state()\n        rect_down.align_to(Dot().next_to(self.camera.frame, DOWN), UP)\n        self.add(rect_down)\n        self.play(rect_down.animate.restore(), g.animate.shift(UP * 0.5))\n        VGroup(i2, i3, i4).shift(UP * 0.5)\n        steps = ComplexTex(\"\\\\begin{enumerate}\\n                \\\\setlength{\\\\itemsep}{4pt}\\n                \\\\setlength{\\\\parskip}{0pt}\\n                \\\\item \\\\textbf{loosen} (Dantzig's rule)\\n                \\\\item \\\\textbf{tighten} (largest non-positive ratio)\\n                \\\\item \\\\textbf{fix} (swap + substitute)\\n                \\\\end{enumerate}\").scale(0.65).set_z_index(rect_down.get_z_index() + 1)\n        steps.next_to(rect_large, RIGHT, buff=0.5).align_to(rect_down, UP).shift(DOWN * 0.5)\n        self.play(FadeIn(steps[0][:23]))\n        self.play(FadeIn(steps[0][23:58]))\n        self.play(FadeIn(steps[0][58:]))\n        offset = -0.05\n        dashed_x = Arrow(of_dot.get_center(), [of_arrow_shadow_2.get_end()[0] - offset, of_dot.get_center()[1], 0], stroke_width=LINE_STROKE + 0.01, buff=0).set_color(GREEN).set_z_index(of_dot.get_z_index() - 1e-06)\n        dashed_y = Arrow(of_dot.get_center(), [of_dot.get_center()[0], of_arrow_shadow_2.get_end()[1] - offset, 0], buff=0, stroke_width=LINE_STROKE + 0.01).set_color(RED).set_z_index(of_dot.get_z_index() - 1e-06)\n        a = of_arrow_shadow_2.copy().set_z_index(of_dot.get_z_index() - 1e-06)\n        b = of_arrow_shadow_2.copy().set_z_index(of_dot.get_z_index() - 1e-06)\n        self.play(steps[0][23:58].animate.set_opacity(BIG_OPACITY), steps[0][58:].animate.set_opacity(BIG_OPACITY))\n        self.play(FadeIn(hl1), FadeIn(hl2))\n        self.play(Transform(a, dashed_x), Transform(b, dashed_y), run_time=1)\n        self.remove(a, b)\n        self.add(dashed_x, dashed_y)\n        self.play(FadeOut(dashed_y), FadeOut(hl2))\n        nb = VGroup(nonbas_vars[1].copy())\n        nb.move_to(nonbas_vars)\n        b = VGroup(nonbas_vars[0].copy().set_color(WHITE), bas_vars[0].copy(), bas_vars[1].copy(), bas_vars[2].copy())\n        b.arrange(buff=vars_buff)\n        b.move_to(bas_vars)\n        b[0].set_color(WHITE)\n        self.play(Transform(nonbas_vars[0], b[0]), Transform(nonbas_vars[1], nb[0]), Transform(bas_vars[0], b[1]), Transform(bas_vars[1], b[2]), Transform(bas_vars[2], b[3]), ineqs6[0][8:8 + 2].animate.set_color(WHITE), ineqs6[0][28:28 + 2].animate.set_color(WHITE), i1.animate.set_opacity(0), of_dot.animate.shift(RIGHT * 0.5), of_arrow_shadow_2.animate.shift(RIGHT * 0.5), FadeOut(dashed_x, shift=RIGHT * 0.5), FadeOut(hl1), exp5[0][6:6 + 2].animate.set_color(WHITE))\n        self.remove(nonbas_vars[0], nonbas_vars[1])\n        self.remove(bas_vars[0], bas_vars[1], bas_vars[2])\n        self.add(b, nb)\n        nonbas_vars = nb\n        bas_vars = b\n        i3.set_color(POSSIBLE_COLOR).set_opacity(0)\n        i4.set_color(POSSIBLE_COLOR).set_opacity(0)\n        inter = intersection(line(i5.line.get_start(), i5.line.get_end()), line(i4.line.get_start(), i4.line.get_end()))\n        idot = area.dots[0].copy().move_to([*inter, 0])\n        hls1 = CreateHighlight(ineqs6[0][0:0 + 2]).set_color(POSSIBLE_COLOR)\n        hls3 = CreateHighlight(ineqs6[0][20:20 + 2]).set_color(POSSIBLE_COLOR)\n        hl1 = CreateHighlight(ineqs6[0][3:3 + 4]).set_color(POSSIBLE_COLOR)\n        hl2 = CreateHighlight(ineqs6[0][7:7 + 3]).set_color(POSSIBLE_COLOR)\n        hl3 = CreateHighlight(ineqs6[0][23:23 + 4]).set_color(POSSIBLE_COLOR)\n        hl4 = CreateHighlight(ineqs6[0][27:27 + 3]).set_color(POSSIBLE_COLOR)\n        self.play(steps[0][:23].animate.set_opacity(BIG_OPACITY), steps[0][23:58].animate.set_opacity(1), steps[0][58:].animate.set_opacity(BIG_OPACITY))\n        self.play(AnimationGroup(AnimationGroup(FadeIn(hl2), ineqs6[0][0:0 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[2].animate.set_color(POSSIBLE_COLOR), i4.animate.set_opacity(1), FadeIn(hls1, idot)), AnimationGroup(FadeIn(hl4), ineqs6[0][20:20 + 2].animate.set_color(POSSIBLE_COLOR), bas_vars[3].animate.set_color(POSSIBLE_COLOR), i3.animate.set_opacity(1), FadeIn(hls3)), lag_ratio=0.07))\n        four = Tex('$-3\\\\,000$').move_to(hl1).align_to(ineqs6, RIGHT).shift(RIGHT * 0.5).set_z_index(ineqs6.get_z_index() + 1)\n        five = Tex('$-1\\\\,000$').move_to(hl3).align_to(ineqs6, RIGHT).shift(RIGHT * 0.5).set_z_index(ineqs6.get_z_index() + 1)\n        ff = VGroup(four, five).scale(0.9).arrange(RIGHT, buff=0.6).next_to(ineqs6, UP, buff=0.5)\n        gt = Tex('$<$', stroke_width=1.5).scale(0.5).move_to(VGroup(four, five)).set_z_index(ineqs6.get_z_index() + 1)\n        a = ineqs6[0][3:3 + 4].copy()\n        b = ineqs6[0][23:23 + 4].copy()\n        am = ineqs6[0][7:7 + 1].copy()\n        bm = ineqs6[0][27:27 + 1].copy()\n        ah = CreateHighlight(four).set_color(POSSIBLE_COLOR)\n        bh = CreateHighlight(five).set_color(POSSIBLE_COLOR)\n        fix1 = hls1.copy()\n        fix2 = hls3.copy()\n        self.remove(hls1, hls3)\n        self.add(fix1, fix2)\n        hl1.scale(0.95)\n        hl3.scale(0.95)\n        self.play(AnimationGroup(AnimationGroup(Transform(fix1, hl1), Transform(fix2, hl3)), AnimationGroup(AnimationGroup(Transform(a, four[0][1:]), Transform(am, four[0][0]), FadeIn(ah)), AnimationGroup(Transform(b, five[0][1:]), Transform(bm, five[0][0]), FadeIn(bh)), lag_ratio=0.25), lag_ratio=0.75))\n        inter = intersection(line(i5.line.get_start(), i5.line.get_end()), line(i3.line.get_start(), i3.line.get_end()))\n        idot_correct = area.dots[0].copy().move_to([*inter, 0]).set_z_index(area.dots[0].get_z_index() + 1)\n        self.add(idot_correct)\n        self.remove(a, am, b, bm)\n        self.add(four, five)\n        self.remove(fix1, fix2)\n        self.add(hl1, hl3)\n        self.play(FadeIn(gt), bh.animate.set_color(GREEN), ah.animate.set_color(RED), ineqs6[0][20:20 + 2].animate.set_color(GREEN), bas_vars[3].animate.set_color(GREEN), i3.line.animate.set_color(GREEN), hl3.animate.set_color(GREEN), idot_correct.animate.set_color(GREEN), hl4.animate.set_color(GREEN), ineqs6[0][0:0 + 2].animate.set_color(RED), bas_vars[2].animate.set_color(RED), i4.line.animate.set_color(RED), hl1.animate.set_color(RED), idot.animate.set_color(RED), hl2.animate.set_color(RED))\n        nb = VGroup(nonbas_vars[0].copy(), bas_vars[3].copy().set_color(YELLOW))\n        nb.arrange(buff=vars_buff)\n        nb.move_to(nonbas_vars)\n        b = VGroup(bas_vars[0].copy(), bas_vars[1].copy(), bas_vars[2].copy().set_color(ORANGE))\n        b.arrange(buff=vars_buff)\n        b.move_to(bas_vars)\n        self.play(FadeOut(four, ah, hl2, hl1), FadeOut(idot), FadeOut(i4), FadeOut(gt), ineqs6[0][0:0 + 2].animate.set_color(ORANGE), bas_vars[2].animate.set_color(ORANGE))\n        self.play(FadeOut(five, bh, hl4, hl3), ineqs6[0][20:20 + 2].animate.set_color(YELLOW), i3.animate.set_color(YELLOW), Transform(nonbas_vars[0], nb[0]), Transform(bas_vars[3], nb[1]), Transform(bas_vars[0], b[0]), Transform(bas_vars[1], b[1]), Transform(bas_vars[2], b[2]), of_dot.animate.shift(RIGHT * 0.5), of_arrow_shadow_2.animate.shift(RIGHT * 0.5))\n        hl1.scale(1 / 0.95)\n        hl3.scale(1 / 0.95)\n        nonbas_vars = nb\n        bas_vars = b\n        hlp1 = hls3.set_color(RED)\n        hlp2 = hl2.set_color(RED)\n        hlp3 = hl4.set_color(RED)\n        hlp4 = CreateHighlight(exp5[0][3:3 + 5]).set_color(POSSIBLE_COLOR).set_color(RED)\n        self.play(steps[0][:23].animate.set_opacity(BIG_OPACITY), steps[0][23:58].animate.set_opacity(BIG_OPACITY), steps[0][58:].animate.set_opacity(1))\n        self.play(FadeIn(hlp1, hlp2, hlp3, hlp4))\n        ineqs7 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 3\\\\,000 - x_1 \\\\\\\\[-0.2em]\\n              x_2 &= 4\\\\,000 \\\\phantom{{} - s_1} - s_2 \\\\\\\\[-0.2em]\\n              x_1 &= 1\\\\,000 - s_3 + s_2\\n                \\\\end{aligned}$$').set_z_index(ineqs4.get_z_index())\n        align_object_by_coords(ineqs7, ineqs7[0][0].get_center(), ineqs6[0][0].get_center())\n        ineqs7[0][0:0 + 2].set_color(ORANGE)\n        ineqs7[0][8:8 + 2].set_color(WHITE)\n        ineqs7[0][18:18 + 2].set_color(YELLOW)\n        ineqs7[0][20:20 + 2].set_color(WHITE)\n        ineqs7[0][28:28 + 2].set_color(YELLOW)\n        ineqs7[0][31:31 + 2].set_color(YELLOW)\n        self.play(AnimationGroup(FadeOut(hlp1, hlp3), AnimationGroup(ineqs6[0][20:20 + 2].animate.move_to(ineqs7[0][28:28 + 2]), ineqs6[0][28:28 + 2].animate.move_to(ineqs7[0][20:20 + 2]), ineqs6[0][30:].animate.move_to(ineqs7[0][30:]), ineqs6[0][17:17 + 3].animate.move_to(ineqs7[0][17:17 + 3])), lag_ratio=0.5))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp5, ineqs7, bas_vars, nonbas_vars, rect_large, rect_down, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i3, i5, dpivot, steps, hlp2, hlp4)\n        ineqs8 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 2\\\\,000 + s_3 - s_2 \\\\\\\\[-0.2em]\\n              x_2 &= 4\\\\,000 \\\\phantom{{} - s_1} - s_2 \\\\\\\\[-0.2em]\\n              x_1 &= 1\\\\,000 - s_3 + s_2\\n                \\\\end{aligned}$$').set_z_index(ineqs4.get_z_index())\n        align_object_by_coords(ineqs8, ineqs8[0][0].get_center(), ineqs7[0][0].get_center())\n        ineqs8[0][0:0 + 2].set_color(ORANGE)\n        ineqs8[0][8:8 + 2].set_color(YELLOW)\n        ineqs8[0][11:11 + 2].set_color(YELLOW)\n        ineqs8[0][21:21 + 2].set_color(YELLOW)\n        ineqs8[0][31:31 + 2].set_color(YELLOW)\n        ineqs8[0][34:34 + 2].set_color(YELLOW)\n        exp6 = Tex('$$\\\\max\\\\ -1.2 s_3 - 0.5 s_2 + 8\\\\,000$$').set_z_index(exp5.get_z_index())\n        exp6[0][7:7 + 2].set_color(YELLOW)\n        exp6[0][13:13 + 2].set_color(YELLOW)\n        exp6.move_to(exp5)\n        self.play(AnimationGroup(AnimationGroup(ineqs7[0][23:].copy().animate.align_to(ineqs7[0][3:9 + 1], DOWN).set_opacity(0), Succession(Wait(0.25), AnimationGroup(AnimationGroup(FadeOut(ineqs7[0][3:9 + 1]), FadeOut(hlp2)), FadeIn(ineqs8[0][3:13]), lag_ratio=0.2, run_time=0.75))), AnimationGroup(ineqs7[0][23:].copy().animate.move_to(exp5[0][3:]).set_opacity(0), Succession(Wait(0.25), AnimationGroup(AnimationGroup(FadeOut(exp5), FadeOut(hlp4)), FadeIn(exp6), lag_ratio=0.2, run_time=0.75))), lag_ratio=0.75))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(of3, exp6, ineqs8, bas_vars, nonbas_vars, rect_large, rect_down, area, of_arrow_shadow, numberplane, sr, labels, sm, basic, nonbasic, of_dot, of_arrow_shadow_2, i3, i5, dpivot, steps)\n        self.play(steps[0][:23].animate.set_opacity(1), steps[0][23:58].animate.set_opacity(1), steps[0][58:].animate.set_opacity(1))\n        hl1 = CreateHighlight(exp6[0][4:4 + 5]).set_color(RED)\n        hl2 = CreateHighlight(exp6[0][10:10 + 5]).align_to(hl1, DOWN).set_color(RED)\n        self.play(FadeIn(hl1, hl2), steps[0][:23].animate.set_opacity(1), steps[0][23:58].animate.set_opacity(BIG_OPACITY), steps[0][58:].animate.set_opacity(BIG_OPACITY))\n        self.play(FadeOut(hl1, hl2), steps[0][:23].animate.set_opacity(1), steps[0][23:58].animate.set_opacity(1), steps[0][58:].animate.set_opacity(1))\n        hl1 = CreateHighlight(VGroup(ineqs8[0][0], ineqs8[0][6], ineqs8[0][23], ineqs8[0][24])).set_color(BLUE)\n        hl2 = CreateHighlight(exp6[0][-4:]).set_color(BLUE)\n        hltg = VGroup(ineqs8[0][13:13 + 7], ineqs8[0][23:23 + 7])\n        hlt = CreateHighlight(hltg).set_color(BLUE)\n        self.play(FadeIn(hl1, hl2), nonbas_vars.animate.set_opacity(BIG_OPACITY), ineqs8[0][7:7 + 6].animate.set_opacity(BIG_OPACITY), ineqs8[0][20:20 + 3].animate.set_opacity(BIG_OPACITY), ineqs8[0][30:30 + 6].animate.set_opacity(BIG_OPACITY), exp6[0][3:3 + 13].animate.set_opacity(BIG_OPACITY))\n        self.play(VGroup(exp6[0][-4:], hl2).animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        self.play(ineqs8[0][:7].animate.set_opacity(BIG_OPACITY), Transform(hl1, hlt))\n        self.play(VGroup(hltg, hl1).animate(rate_func=there_and_back).scale(THERE_AND_BACK_SCALE))\n        self.play(FadeOut(hl1, hl2), nonbas_vars.animate.set_opacity(1), ineqs8[0][7:7 + 6].animate.set_opacity(1), ineqs8[0][20:20 + 3].animate.set_opacity(1), ineqs8[0][30:30 + 6].animate.set_opacity(1), exp6[0][3:3 + 13].animate.set_opacity(1))"}]}
{"messages": [{"role": "user", "content": "Display a system of equations with specific terms colored orange and yellow."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TestSteps(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        ineqs8 = ComplexTex('$$\\\\begin{aligned}\\n              s_1 &= 2\\\\,000 + s_3 - s_2 \\\\\\\\[-0.2em]\\n              x_2 &= 4\\\\,000 \\\\phantom{{} - x_1} - s_2 \\\\\\\\[-0.2em]\\n              x_1 &= 1\\\\,000 - s_3 + s_2\\n                \\\\end{aligned}$$')\n        ineqs8[0][0:0 + 2].set_color(ORANGE)\n        ineqs8[0][8:8 + 2].set_color(YELLOW)\n        ineqs8[0][11:11 + 2].set_color(YELLOW)\n        ineqs8[0][21:21 + 2].set_color(YELLOW)\n        ineqs8[0][31:31 + 2].set_color(YELLOW)\n        ineqs8[0][34:34 + 2].set_color(YELLOW)\n        self.add(ineqs8)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a 3D feasible area with inequalities and a moving arrow while rotating the camera."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass Pain3D(ThreeDScene):\n\n    def construct(self):\n        TEST = False\n        offset = np.array([1.12563452, -2, 0])\n        axes = ThreeDAxes(x_range=(-2 * 7.111111111111111, 2 * 7.111111111111111, 1), y_range=(-2 * 7.111111111111111, 2 * 7.111111111111111, 1), z_range=(-2 * 7.111111111111111, 2 * 7.111111111111111, 1), x_length=6 * 7.111111111111111, y_length=6 * 7.111111111111111, z_length=3 * 7.111111111111111, axis_config={'stroke_width': 4, 'include_ticks': False}, num_axis_pieces=100, stroke_width=6, tips=False)\n        axes.z_axis.set_opacity(0)\n        area = FeasibleArea3D(test=TEST)\n        seed(48879)\n        area.add_inequalities([Inequality3D(-1, 0, 0, '<=', 0), Inequality3D(0, -1, 0, '<=', 0), Inequality3D(1, 1, 0, '<=', 5), Inequality3D(1, 0, 0, '<=', 3), Inequality3D(0, 1, 0, '<=', 4), Inequality3D(0, 0, 1, '<=', 1.5), Inequality3D(0, 0, -1, '<=', 1.5), Inequality3D(-2.0, -1, 0, '<=', -1.118033988749895), Inequality3D(-0.5, -1, 0, '<=', -0.5590169943749475), Inequality3D(1.0, -1, 0, '<=', 2.646446609406726), Inequality3D(1.5000000000000002, 1, 0, '<=', 6.0493060905670015), Inequality3D(-0.2999999999999998, 1, 0, '<=', 3.8433954023663417), Inequality3D(-1.0, 1, 0, '<=', 3.787867965644036), Inequality3D(-4.0, 1, 0, '<=', 3.175378874876468), Inequality3D(0.8999999999999999, 1, 0, '<=', 4.832731879764632)])\n        sorted_dots = sorted(list(area.dots), key=lambda x: tuple(x.get_center()))\n        center = np.array((1.5, 2, 0))\n        additional_ineqs = []\n        for i in range(len(sorted_dots)):\n            s = uniform(0.07, 0.15)\n            norm = center - sorted_dots[i].get_center()\n            d = np.dot(norm, sorted_dots[i].get_center() + norm * s)\n            additional_ineqs.append(Inequality3D(*-norm, '<=', -d))\n        top = Inequality3D(0, 0, 1, '<=', 0.01)\n        bottom = Inequality3D(0, 0, -1, '<=', 0.01)\n        additional_ineqs.append(top)\n        additional_ineqs.append(bottom)\n        OF_BIG = np.array((1.2, 1.7, 1.1))\n        vt = ValueTracker()\n        vt.set_value(0.0035)\n        ORIG_OFFSET = -offset - center\n        PREV_V = [0]\n\n        def please_for_the_love_of_god_end_my_suffering_updater(obj, dt):\n            \"\"\"Feeling cute might nuke my CPU idk hehe \ud83d\ude0a.\"\"\"\n            v = vt.get_value()\n            if v == PREV_V[0]:\n                return\n            PREV_V[0] = v\n            top.d = v\n            bottom.d = v\n            for o in area.dots:\n                o.set_opacity(0)\n            for o in area.edges:\n                o.set_opacity(0)\n            v /= 1.4\n            area._update_area(shift=offset + ORIG_OFFSET * v)\n            min_dot = min([(np.dot(OF_BIG, d.get_center()), d.get_center()) for d in area.dots])[1]\n            ofa, ofb, ofc = OF_BIG\n            arrow.become(Arrow3D(start=min_dot, end=min_dot + np.array([ofa, ofb, ofc * v]), resolution=8, base_radius=0.17 - 0.04 * v, height=0.35, thickness=0.025))\n        area.add_inequalities(additional_ineqs)\n        axes.shift(offset)\n        area.shift(offset)\n        min_dot = min([(np.dot(OF_BIG, d.get_center()), d.get_center()) for d in area.dots])[1]\n        arrow = Arrow3D(start=min_dot, end=min_dot + OF_BIG, resolution=8)\n        labels = VGroup(Tex('$x_p$').scale(1.2).move_to(axes).next_to(axes.x_axis, DOWN, buff=0.33).align_to(config.right_side, RIGHT).shift(LEFT * 0.2).set_color(POTATO_COLOR), Tex('$x_c$').scale(1.2).move_to(axes).next_to(axes.y_axis, LEFT, buff=0.23).align_to(config.top, UP).shift(DOWN * 0.35).set_color(CARROT_COLOR))\n        self.add(axes, area, arrow, labels)\n        self.add(vt)\n        please_for_the_love_of_god_end_my_suffering_updater(vt, 0)\n        vt.add_updater(please_for_the_love_of_god_end_my_suffering_updater)\n        extra_anims = [axes.x_axis.animate.shift(ORIG_OFFSET), axes.y_axis.animate.shift(ORIG_OFFSET), axes.z_axis.animate.set_opacity(1).shift(ORIG_OFFSET), vt.animate.set_value(1.4), FadeOut(labels, shift=ORIG_OFFSET)]\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES, added_anims=extra_anims, run_time=5 if not TEST else 1)\n        vt.remove_updater(please_for_the_love_of_god_end_my_suffering_updater)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(19.36)\n        vt.add_updater(please_for_the_love_of_god_end_my_suffering_updater)\n        extra_anims = [axes.x_axis.animate.shift(-ORIG_OFFSET), axes.y_axis.animate.shift(-ORIG_OFFSET), axes.z_axis.animate.set_opacity(0).shift(-ORIG_OFFSET), vt.animate.set_value(0.0035), FadeIn(labels, shift=-ORIG_OFFSET)]\n        self.move_camera(phi=0, theta=3 * PI / 2, added_anims=extra_anims, run_time=3 if not TEST else 1)"}]}
{"messages": [{"role": "user", "content": "Write \"1939\" on the screen, scaled and positioned towards the top right."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass Transparent1939(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        n = Tex('1939').scale(1.5).align_to(self.camera.frame, UP + RIGHT)\n        n.shift(DOWN * 0.9 + LEFT * 1.6)\n        self.play(Write(n))"}]}
{"messages": [{"role": "user", "content": "Animate a student silhouette transitioning through different poses while a professor silhouette appears with a name and image."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TransparentSilhouettes(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        scale = 2\n        student = SVGMobject('assets/silhouettes/student-cropped.svg').set_color(WHITE).scale(scale)\n        sitting = SVGMobject('assets/silhouettes/sitting-cropped.svg').set_color(WHITE).scale(scale).scale(0.7).align_to(student, DOWN)\n        returning = SVGMobject('assets/silhouettes/returning-cropped.svg').set_color(WHITE).scale(scale)\n        looking_up = SVGMobject('assets/silhouettes/looking-up-cropped.svg').set_color(WHITE).scale(scale).scale(0.7).align_to(student, DOWN)\n        professor = SVGMobject('assets/silhouettes/professor-cropped.svg').set_color(WHITE).scale(scale)\n        self.play(FadeIn(student, shift=0.25 * RIGHT))\n        return_distance = 5.5\n        self.play(FadeOut(student, shift=RIGHT * return_distance), FadeIn(sitting, shift=RIGHT * return_distance), run_time=1.5)\n        self.play(FadeOut(sitting, shift=LEFT * return_distance), FadeIn(returning, shift=LEFT * return_distance), run_time=1.5)\n        self.play(FadeOut(returning, shift=RIGHT * return_distance), FadeIn(sitting, shift=RIGHT * return_distance), run_time=1.5)\n        prof_distance = 4\n        professor.shift(LEFT * prof_distance)\n        self.play(AnimationGroup(Succession(Wait(0.3), AnimationGroup(FadeIn(looking_up), FadeOut(sitting), lag_ratio=0.1, run_time=0.7)), self.camera.frame.animate.shift(LEFT * prof_distance / 2), FadeIn(professor)), run_time=1.5)\n        name = Tex('\\\\sc George B. Dantzig').next_to(looking_up, UP, buff=0.5)\n        dantzig = ImageMobject('assets/dantzig-border.png').set_height(looking_up.get_height()).align_to(self.camera.frame, LEFT).set_z_index(5).set_z_index(1)\n        g = Group(dantzig, looking_up.copy()).arrange(buff=0.75).move_to(looking_up)\n        self.play(AnimationGroup(AnimationGroup(self.camera.frame.animate.shift(RIGHT * prof_distance / 2).scale(0.65), FadeOut(professor)), FadeIn(name, shift=UP * 0.15), lag_ratio=0.75))\n        self.play(AnimationGroup(Transform(looking_up, g[1]), FadeIn(g[0]), lag_ratio=0.25))"}]}
{"messages": [{"role": "user", "content": "Animate a paused icon with a rotating dot tracing its center, appearing to spin around it."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TransparentPauseV2(MovingCameraScene):\n\n    def construct(self):\n        pause = SVGMobject('assets/pause_v2.svg').scale(0.6).set_z_index(1000)\n        d = Dot().shift(UP * 0.6).scale(1.5).set_z_index(10001)\n        d2 = Dot().shift(UP * 0.6).scale(1.25).set_z_index(10001)\n        trace = TracedPath(d.get_center, stroke_width=9).set_color(WHITE).set_z_index(10001)\n        self.add(trace, pause, d, d2)\n        self.play(Rotate(d, 2 * PI, about_point=ORIGIN), run_time=5, rate_func=linear)"}]}
{"messages": [{"role": "user", "content": "Animate a pause icon moving from one end of a gray line to the other while its path is traced in white."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TransparentPause(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        line = Line(3 * LEFT, 3 * RIGHT, stroke_width=6).shift(UP * 0).set_color(GRAY)\n        d1 = Dot().move_to(line.get_left()).scale(1.5)\n        d2 = Dot().move_to(line.get_right()).scale(1.5)\n        pause = SVGMobject('assets/pause.svg').move_to(line.get_left()).scale(0.3).set_z_index(1000)\n        self.add(line, pause, d1, d2)\n        trace = TracedPath(pause.get_center).set_color(WHITE).set_stroke_width(8)\n        self.add(trace)\n        self.play(pause.animate(rate_func=linear, run_time=5).move_to(d2))"}]}
{"messages": [{"role": "user", "content": "Animate a pause button moving across a line, tracing its path as it moves from the start to the middle and then to the end."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TransparentPauseWithHint(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        line = Line(3 * LEFT, 3 * RIGHT, stroke_width=6).shift(UP * 0).set_color(GRAY)\n        d1 = Dot().move_to(line.get_left()).scale(1.5)\n        d2 = Dot().move_to(line.get_right()).scale(1.5)\n        dmiddle = Dot().move_to(VGroup(d1, d2)).scale(1.5)\n        hint = Tex('\\\\bf Hint').next_to(dmiddle, UP, buff=0.45)\n        pause = SVGMobject('assets/pause.svg').move_to(line.get_left()).scale(0.3).set_z_index(1000)\n        self.add(line, pause, d1, d2, dmiddle, hint)\n        trace = TracedPath(pause.get_center).set_color(WHITE).set_stroke_width(8)\n        self.add(trace)\n        self.play(pause.animate(rate_func=linear, run_time=4).move_to(dmiddle))\n        self.play(pause.animate(rate_func=linear, run_time=4).move_to(d2))"}]}
{"messages": [{"role": "user", "content": "Display two characters, one speaking about an optimum value and the other responding about a McDonalds, with each speech bubble highlighted."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TransparentFunnyXD(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        l = SVGMobject('assets/l_char.svg').set_color(WHITE).set(height=0.35 * self.camera.frame.height).set_z_index(1000)\n        r = SVGMobject('assets/r_char.svg').set_color(WHITE).set(height=0.35 * self.camera.frame.height).set_z_index(1000)\n        VGroup(l, r).arrange(buff=6).align_to(self.camera.frame, DOWN)\n        ltext = Tex('The optimum is $8\\\\,000$!').set_z_index(10)\n        ltext.add(SurroundingRectangle(ltext, color=WHITE, fill_opacity=0.75, fill_color=BLACK, corner_radius=0.2, buff=0.3))\n        rtext = Tex('Sir this is a McDonalds.').set_z_index(10)\n        rtext.add(SurroundingRectangle(VGroup(rtext, ltext[0][4]), color=WHITE, fill_opacity=0.75, fill_color=BLACK, corner_radius=0.2, buff=0.3))\n        self.add(l, r)\n        ltext.next_to(l, UP, buff=1).shift(RIGHT * 0.5)\n        rtext.next_to(r, UP, buff=1).shift(LEFT * 0.5)\n        self.play(FadeIn(l, shift=RIGHT), FadeIn(r, shift=LEFT))\n        self.play(Wiggle(l), Succession(Wait(0.25), FadeIn(ltext, shift=UP)))\n        self.play(Wiggle(r), Succession(Wait(0.25), FadeIn(rtext, shift=UP)))"}]}
{"messages": [{"role": "user", "content": "Visualize the feasible region of a system of linear inequalities and its integer solutions, then pose questions about the efficiency of solving integer linear programming problems."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass ILP(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        numberplane = NumberPlane(x_range=(-2 * 7.111111111111111, 2 * 7.111111111111111, 1), y_range=(-2 * 4.0, 2 * 4.0, 1), stroke_width=6, axis_config={'stroke_width': 4}, background_line_style={'stroke_color': GRAY, 'stroke_width': 3, 'stroke_opacity': 0.6})\n        self.camera.frame.scale(0.95)\n        numberplane.axes.set_z_index(200)\n        area = FeasibleArea2D(dots_z_index=2).set_z_index(1)\n        i1 = Inequality2D(1, 0.2, '>=', -3.5).set_z_index(10)\n        i2 = Inequality2D(0, 1, '>=', -2.5).set_z_index(10)\n        i3 = Inequality2D(1, 1, '<=', 3.8).set_z_index(10)\n        i4 = Inequality2D(1, 0.3, '<=', 3.1 + 0.5).set_z_index(10)\n        i5 = Inequality2D(-0.1, 1, '<=', 2.7).set_z_index(10)\n        ineqs = [i1, i2, i3, i4, i5]\n        for p1, p2, sym in [((4, -0.85), (3, -2), '>='), ((-2, 3), (-3, 1), '<='), ((-1, 3), (2, 2), '<='), ((0, -3), (-3, -1.8), '>=')]:\n            Inequality2D.points_to_slope(p1, p2)\n            a, b, c = Inequality2D.points_to_slope(p1, p2)\n            i = Inequality2D(a, b, sym, c)\n            ineqs.append(i)\n        dots = VGroup()\n        for x in range(-10, 10 + 1):\n            for y in range(-5, 5 + 1):\n                dots.add(Dot().set_color(DARK_GRAY).move_to(RIGHT * x + UP * y).scale(0.8))\n                for i in ineqs:\n                    if not i.satisfies(x, y):\n                        break\n                else:\n                    dots[-1].set_color(WHITE).scale(1 / 0.8 * NORMAL_DOT_SCALE * 0.8)\n                dots[-1].set_z_index(100)\n        area.add_inequalities(ineqs)\n        self.play(FadeIn(numberplane.background_lines), FadeIn(numberplane.axes))\n        inr = Tex('$$\\\\mathbf{x} \\\\in \\\\mathbb{R}$$').scale(1.5).set_z_index(100000).align_to(self.camera.frame, UP + RIGHT).shift((LEFT * 1.3 + DOWN * 1) * 0.7)\n        inn = Tex('$$\\\\mathbf{x} \\\\in \\\\mathbb{N}$$').scale(1.5).set_z_index(100000).move_to(inr)\n        inrr = CreateSR(inr).set_color(BLACK).scale(1.25)\n        self.play(FadeIn(area), FadeIn(inr, inrr))\n        self.play(*[Succession(Wait(distance(ORIGIN, d.get_center()) / 8), FadeIn(d)) for d in dots], area.area.animate.set_stroke_color(DARK_GRAY), area.dots.animate.set_color(DARK_GRAY), FadeOut(inr[0][-1], shift=UP * 0.75), FadeIn(inn[0][-1], shift=UP * 0.75))\n        fade_rect = get_fade_rect(opacity=1 - BIG_OPACITY / 1.1)\n        ilp = Tex('\\\\underline{Integer Linear Programming (ILP)}').scale(1.4).set_z_index(fade_rect.get_z_index() + 1)\n        a = Tex('Is the problem easier or harder?').set_z_index(fade_rect.get_z_index() + 1)\n        b = Tex('Can we still solve it efficiently?').set_z_index(fade_rect.get_z_index() + 1)\n        VGroup(a, b).arrange(DOWN, buff=0.4)\n        VGroup(ilp, VGroup(a, b)).arrange(DOWN, buff=1.5)\n        align_object_by_coords(VGroup(a, b), a.get_center(), ORIGIN)\n        VGroup(a, b).shift(DOWN * 0.5)\n        VGroup(b).shift(DOWN * 0.2)\n        self.play(AnimationGroup(FadeIn(fade_rect), FadeIn(ilp), lag_ratio=0.5))\n        self.play(Write(a), run_time=1.5)\n        self.play(Write(b), run_time=1.5)"}]}
{"messages": [{"role": "user", "content": "Animate text elements representing a binary fraction and its constraints, transforming a surrounding rectangle to encompass a combined text block."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TransparentBinaryHint(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        a = Tex('$b_1$').set_z_index(1000000000)\n        b = Tex('$1 \\\\ge b_1$').set_z_index(1000000000)\n        c = Tex('$b_1 \\\\ge 0$').set_z_index(1000000000)\n        d = Tex('$1 \\\\ge b_1 \\\\ge 0$')\n        align_object_by_coords(b, b[0][2].get_center(), a[0][0].get_center())\n        align_object_by_coords(c, c[0][0].get_center(), a[0][0].get_center())\n        b.shift(DOWN * 0.7)\n        c.shift(DOWN * 0.7 * 2)\n        self.camera.frame.scale(0.5).move_to(VGroup(a, b, c))\n        self.add(a, b, c)\n        d.move_to(VGroup(a, b, c))\n        sr = SurroundingRectangle(VGroup(a, b, c), fill_color=BLACK, stroke_color=WHITE, buff=0.35, fill_opacity=0.75)\n        sr2 = SurroundingRectangle(d, fill_color=BLACK, stroke_color=WHITE, buff=0.35, fill_opacity=0.75)\n        VGroup(a, b, c, sr, sr2).scale(0.75)\n        self.play(FadeIn(a, b, c, sr))\n        self.play(Transform(sr, sr2), align_object_by_coords(a, a[0][0].get_center(), b[0][2].get_center(), animation=True), align_object_by_coords(c, c[0][0].get_center(), b[0][2].get_center(), animation=True))"}]}
{"messages": [{"role": "user", "content": "Explain the knapsack problem with a visual representation of items, their weights, prices, and the problem constraints, followed by code snippets and output demonstrating its solution."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass Knapsack(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        seed(802555952866)\n        n = 8\n        weights = [2 + i for i in range(n)]\n        shuffle(weights)\n        prices = [randint(1, 30) for _ in range(n)]\n        title = Tex('\\\\underline{Knapsack Problem}').scale(1.5)\n        knapsack = ImageMobject('assets/midjourney/knapsack-out.png').set_height(title.get_height()).scale(1.2)\n        knapsack.next_to(title, RIGHT, buff=0.3)\n        title_plus_knapsack = Group(knapsack, title)\n        title_plus_knapsack.next_to(config.top, DOWN, buff=1)\n        self.play(AnimationGroup(Write(title, run_time=1), FadeIn(knapsack), lag_ratio=0.5))\n        cols = color_gradient(['#FEBA33', '#CE6019', '#9A6354', '#FCA72B', '#86270A'], n)\n\n        def get_label(w):\n            w = int(w)\n            t = Tex(f'${w}\\\\text{{kg}}$')\n            t[0][1:].scale(0.6, about_point=t[0][1].get_critical_point(LEFT + DOWN))\n            t.move_to(ORIGIN)\n            return t\n        items = VGroup(*[VGroup(Dot().scale(w).set_color(cols[i]).set_sheen(0.5), get_label(w).scale(0.2 * w).set_z_index(1).set_color(BLACK)) for i, w in enumerate(weights)], *[Tex(f'${p}\\\\scriptstyle \\\\$$').scale(1) for p in prices]).arrange_in_grid(rows=2, cell_alignment=DOWN, buff=(0.2, 0.4)).align_to(DOWN).shift(DOWN * 0.7).scale(1.2)\n        icp = items.copy()\n        self.play(FadeIn(*[i[0] for i in items[:n]], lag_ratio=0.05), run_time=1)\n        self.play(FadeIn(*[i[1] for i in items[:n]], lag_ratio=0.05), run_time=1)\n        self.play(FadeIn(*[i for i in items[n:]], shift=DOWN * 0.1, lag_ratio=0.05), run_time=1)\n        bp = Tex('Given a O with carry weight $17\\\\,\\\\mathrm{kg}$, {\\\\bf maximize price}.').scale(0.9)\n        bp[0][6].set_opacity(0)\n        bp.next_to(items.copy().shift(UP * 0.7), DOWN, buff=0.9)\n        bpcp = knapsack.copy().scale(0.45).move_to(bp[0][6])\n        k = Group(bp, bpcp)\n        self.play(AnimationGroup(items.animate.shift(UP * 0.7), AnimationGroup(Write(bp[0][:-15], run_time=1.5), FadeIn(bpcp)), lag_ratio=0.5))\n        self.play(Write(bp[0][-15:], run_time=1))\n        self.remove(bp, bpcp)\n        self.add(k)\n        sol = solve_sack(prices, weights, 17)\n        s = 0.9\n        var = Tex('variables: $1 \\\\ge b_1, b_2, b_3, b_4, b_5, b_6, b_7, b_8 \\\\ge 0$').scale(s)\n        for i in range(8):\n            var[0][12 + 3 * i:12 + 2 + 3 * i].set_color(cols[i])\n        var.next_to(items, UP, buff=0.35).shift(DOWN * 0.75)\n        ineqs = Tex('$$\\\\begin{aligned}\\n              4b_1 + 2b_2 + 8b_3 + 3b_4 + 7b_5 + 5b_6 + 9b_7 + 6b_8  &\\\\le 17\\n                \\\\end{aligned}$$').scale(s)\n        for i in range(8):\n            ineqs[0][1 + 4 * i:1 + 2 + 4 * i].set_color(cols[i])\n        iq = Tex('subject to').set_opacity(MED_OPACITY).scale(0.75)\n        ineqs = VGroup(iq, ineqs).arrange(DOWN, buff=0.15).move_to(ineqs)\n        exp = Tex('$$\\\\max\\\\ 19b_1 + 17b_2 + 30b_3 + 13b_4 + 25b_5 + 29b_6 + 23b_7 + 10b_8$$').scale(s)\n        for i in range(8):\n            exp[0][5 + 5 * i:5 + 2 + 5 * i].set_color(cols[i])\n        of = Tex('objective function').set_opacity(MED_OPACITY).scale(0.75)\n        exp = VGroup(of, exp).arrange(DOWN, buff=0.15).move_to(exp)\n        self.play(AnimationGroup(AnimationGroup(items.animate.shift(DOWN * 0.75), k.animate.shift(DOWN * 0.45)), FadeIn(var), lag_ratio=0.5))\n        ineqs.move_to(items[:n])\n        exp.move_to(items[n:])\n        self.play(AnimationGroup(AnimationGroup(*[Transform(items[i][1], ineqs[1][0][0 + 4 * i:0 + 1 + 4 * i]) for i in range(8)], *[Transform(items[i][0], ineqs[1][0][1 + 4 * i:1 + 2 + 4 * i]) for i in range(8)], Transform(k[0][0][22:22 + 2], ineqs[1][0][-2:]), FadeOut(k[0][0][:22]), FadeOut(k[0][0][22 + 2:]), FadeOut(k[1])), AnimationGroup(FadeIn(ineqs[0]), *[FadeIn(ineqs[1][0][3 + 4 * i:3 + 1 + 4 * i]) for i in range(7)], FadeIn(ineqs[1][0][-3])), lag_ratio=0.5))\n        hls = VGroup(*[CreateHighlight(o) for o in [ineqs[1][0][1:1 + 2], ineqs[1][0][5:5 + 2], ineqs[1][0][9:9 + 2], ineqs[1][0][13:13 + 2], ineqs[1][0][17:17 + 2], ineqs[1][0][21:21 + 2], ineqs[1][0][25:25 + 2], ineqs[1][0][29:29 + 2]]])\n        hls2 = VGroup(*[CreateHighlight(o) for o in [ineqs[1][0][0:0 + 3], ineqs[1][0][4:4 + 3], ineqs[1][0][8:8 + 3], ineqs[1][0][12:12 + 3], ineqs[1][0][16:16 + 3], ineqs[1][0][20:20 + 3], ineqs[1][0][24:24 + 3], ineqs[1][0][28:28 + 3]]])\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(title_plus_knapsack, var, ineqs, *[items[n + i] for i in range(8)])\n        self.play(FadeIn(hls), ineqs[1][0][0].animate.set_opacity(BIG_OPACITY), ineqs[1][0][3:3 + 2].animate.set_opacity(BIG_OPACITY), ineqs[1][0][7:7 + 2].animate.set_opacity(BIG_OPACITY), ineqs[1][0][11:11 + 2].animate.set_opacity(BIG_OPACITY), ineqs[1][0][15:15 + 2].animate.set_opacity(BIG_OPACITY), ineqs[1][0][19:19 + 2].animate.set_opacity(BIG_OPACITY), ineqs[1][0][23:23 + 2].animate.set_opacity(BIG_OPACITY), ineqs[1][0][27:27 + 2].animate.set_opacity(BIG_OPACITY))\n        self.play(Transform(hls, hls2), ineqs[1][0][0:0 + 3].animate.set_opacity(1), ineqs[1][0][4:4 + 3].animate.set_opacity(1), ineqs[1][0][8:8 + 3].animate.set_opacity(1), ineqs[1][0][12:12 + 3].animate.set_opacity(1), ineqs[1][0][16:16 + 3].animate.set_opacity(1), ineqs[1][0][20:20 + 3].animate.set_opacity(1), ineqs[1][0][24:24 + 3].animate.set_opacity(1), ineqs[1][0][28:28 + 3].animate.set_opacity(1))\n        self.play(FadeOut(hls), ineqs[1][0].animate.set_opacity(1))\n        self.play(AnimationGroup(AnimationGroup(*[FadeOut(items[n + i][0][-1:]) for i in range(8)]), AnimationGroup(*[Transform(items[n + i][0][:-1], exp[1][0][3 + 5 * i:3 + 2 + 5 * i]) for i in range(8)]), AnimationGroup(FadeIn(exp[0]), *[FadeIn(exp[1][0][5 + 5 * i:5 + 3 + 5 * i]) for i in range(8)], FadeIn(exp[1][0][:3])), lag_ratio=0.5))\n        hls = VGroup(*[CreateHighlight(o) for o in [exp[1][0][3:3 + 4], exp[1][0][8:8 + 4], exp[1][0][13:13 + 4], exp[1][0][18:18 + 4], exp[1][0][23:23 + 4], exp[1][0][28:28 + 4], exp[1][0][33:33 + 4], exp[1][0][38:38 + 4]]])\n        self.play(FadeIn(hls), exp[1][0][:3].animate.set_opacity(BIG_OPACITY), exp[1][0][7].animate.set_opacity(BIG_OPACITY), exp[1][0][12].animate.set_opacity(BIG_OPACITY), exp[1][0][17].animate.set_opacity(BIG_OPACITY), exp[1][0][22].animate.set_opacity(BIG_OPACITY), exp[1][0][27].animate.set_opacity(BIG_OPACITY), exp[1][0][32].animate.set_opacity(BIG_OPACITY), exp[1][0][37].animate.set_opacity(BIG_OPACITY))\n        self.play(FadeOut(hls), exp[1][0].animate.set_opacity(1))\n        for obj in self.mobjects:\n            self.remove(obj)\n        self.add(title_plus_knapsack, var, ineqs, exp)\n        var_s = Tex('variables: $1 \\\\ge \\\\mathbf{b} \\\\ge 0$').move_to(var)\n        var_s[0][12].set_color_by_gradient((cols[0], cols[2], cols[-1]))\n        ineqs_s = Tex('$$\\\\begin{aligned}\\n              \\\\text{weights} \\\\cdot \\\\mathbf{b} &\\\\le \\\\text{carry\\\\_weight}\\n                \\\\end{aligned}$$').move_to(ineqs)\n        ineqs_s[0][8].set_color_by_gradient((cols[0], cols[2], cols[-1]))\n        iq = Tex('subject to').set_opacity(MED_OPACITY).scale(0.75)\n        ineqs_s = VGroup(iq, ineqs_s).arrange(DOWN, buff=0.15).move_to(ineqs)\n        align_object_by_coords(ineqs_s, ineqs_s[0].get_center(), ineqs[0].get_center())\n        exp_s = Tex('$$\\\\max\\\\ \\\\text{prices} \\\\cdot \\\\mathbf{b}$$').move_to(exp)\n        exp_s[0][10].set_color_by_gradient((cols[0], cols[2], cols[-1]))\n        of = Tex('objective function').set_opacity(MED_OPACITY).scale(0.75)\n        exp_s = VGroup(of, exp_s).arrange(DOWN, buff=0.15)\n        align_object_by_coords(exp_s, exp_s[0].get_center(), exp[0].get_center())\n        self.play(Transform(var[0][:12], var_s[0][:12]), Transform(var[0][12:-2], var_s[0][12:-2]), Transform(var[0][-2:], var_s[0][-2:]), Transform(VGroup(ineqs[1][0][1:1 + 2], ineqs[1][0][5:5 + 2], ineqs[1][0][9:9 + 2], ineqs[1][0][13:13 + 2], ineqs[1][0][17:17 + 2], ineqs[1][0][21:21 + 2], ineqs[1][0][25:25 + 2], ineqs[1][0][29:29 + 2]), ineqs_s[1][0][8]), Transform(ineqs[1][0][-3], ineqs_s[1][0][-13]), Transform(ineqs[1][0][-3:], ineqs_s[1][0][-13:]), Transform(VGroup(ineqs[1][0][0], ineqs[1][0][3:3 + 2], ineqs[1][0][7:7 + 2], ineqs[1][0][11:11 + 2], ineqs[1][0][15:15 + 2], ineqs[1][0][19:19 + 2], ineqs[1][0][23:23 + 2], ineqs[1][0][27:27 + 2]), ineqs_s[1][0][:8]), Transform(exp[1][0][:3], exp_s[1][0][:3]), Transform(VGroup(exp[1][0][5:5 + 2], exp[1][0][10:10 + 2], exp[1][0][15:15 + 2], exp[1][0][20:20 + 2], exp[1][0][25:25 + 2], exp[1][0][30:30 + 2], exp[1][0][35:35 + 2], exp[1][0][40:40 + 2]), exp_s[1][0][-1]), Transform(VGroup(exp[1][0][3:3 + 2], exp[1][0][7:7 + 3], exp[1][0][12:12 + 3], exp[1][0][17:17 + 3], exp[1][0][22:22 + 3], exp[1][0][27:27 + 3], exp[1][0][32:32 + 3], exp[1][0][37:37 + 3]), exp_s[1][0][3:3 + 7]))\n        for o in self.mobjects:\n            self.remove(o)\n        self.add(exp_s, ineqs_s, var_s, title_plus_knapsack)\n        g = VGroup(var_s, ineqs_s, exp_s).set_z_index(10)\n        code = MyCode('code/knapsack.py').scale(0.52).next_to(title_plus_knapsack, DOWN)\n        gcp = g.copy().scale(0.4).align_to(code, RIGHT + UP).shift(LEFT * 0.2 + DOWN * 0.2)\n        bg = SurroundingRectangle(gcp, buff=0.2, corner_radius=0.1, color=WHITE, fill_opacity=0)\n        self.play(AnimationGroup(Transform(g, gcp), AnimationGroup(FadeIn(code.background_mobject), FadeIn(bg)), lag_ratio=0.5))\n        pulp = VGroup(Tex('PuLP package').scale(1.25), Tex('\\\\texttt{> pip install pulp}').scale(0.85)).arrange(DOWN, buff=0.3).set_z_index(100000000).scale(0.6)\n        pulp[1].align_to(pulp[0], LEFT)\n        pulp[1].set_color(GRAY)\n        arrow = Arrow(start=ORIGIN, end=UP).next_to(code.code[0][5:5 + 4], DOWN).set_z_index(100000000)\n        pulp.next_to(arrow, DOWN).shift(RIGHT * 0.75)\n        self.play(FadeIn(code.code[0], run_time=1), FadeIn(pulp, arrow, run_time=1))\n        self.play(AnimationGroup(FadeOut(pulp, arrow, run_time=1.25), AnimationGroup(FadeIn(code.code[3]), FadeIn(code.code[4]), FadeIn(code.code[5]), FadeIn(code.code[6]), FadeIn(code.code[7]), lag_ratio=0.05, run_time=1.5), lag_ratio=0.4))\n        sr = CreateHighlight(code.code[12])\n        sr2 = CreateHighlight(var_s)\n        self.play(AnimationGroup(FadeIn(code.code[9]), FadeIn(code.code[10]), FadeIn(code.code[12]), FadeIn(code.code[14]), FadeIn(code.code[16]), lag_ratio=0.05, run_time=1.5), Succession(Wait(0.5), AnimationGroup(FadeIn(sr), FadeIn(sr2))))\n        self.play(Transform(sr, CreateHighlight(code.code[14])), Transform(sr2, CreateHighlight(ineqs_s)))\n        self.play(Transform(sr, CreateHighlight(code.code[16])), Transform(sr2, CreateHighlight(exp_s)))\n        self.play(FadeOut(sr), FadeOut(sr2), AnimationGroup(FadeIn(code.code[18]), FadeIn(code.code[19]), FadeIn(code.code[20]), FadeIn(code.code[21]), lag_ratio=0.05, run_time=1.5))\n        outknap = MyCode('code/knapsack.out').scale(0.56).next_to(code, DOWN).align_to(code, LEFT).set_z_index(code.get_z_index() - 0.1)\n        self.play(FadeIn(outknap, shift=DOWN), self.camera.frame.animate.move_to(VGroup(code, title, outknap)).scale(1.05))\n        hl = CreateHighlight(outknap.code[0][-4:], stroke_width=2, buff=0.05)\n        icp.set_z_index(10000).scale(0.4).next_to(outknap, DOWN, buff=0.25)\n        bg.set_z_index(10000000)\n        bgzi = bg.get_z_index()\n        bg.save_state()\n        self.camera.frame.save_state()\n        self.play(AnimationGroup(AnimationGroup(self.camera.frame.animate.move_to(VGroup(icp, outknap)).scale(0.4), code.animate.set_opacity(BIG_OPACITY), g.animate.set_opacity(BIG_OPACITY), bg.animate.fade(1 - BIG_OPACITY)), FadeIn(icp), FadeIn(hl), lag_ratio=0.5))\n        self.play(Transform(hl, CreateHighlight(outknap.code[1][10:10 + 3], stroke_width=2, buff=0.05)), *[icp[i].animate.set_opacity(BIG_OPACITY) for i in [0, 2, 3, 4, 5, 6, 7]], *[icp[i + n].animate.set_opacity(BIG_OPACITY) for i in [0, 2, 3, 4, 5, 6, 7]])\n        self.play(Transform(hl, CreateHighlight(outknap.code[1][18:18 + 3], stroke_width=2, buff=0.05)), icp[3].animate.set_opacity(1), icp[3 + n].animate.set_opacity(1))\n        self.play(Transform(hl, CreateHighlight(outknap.code[1][22:22 + 3], stroke_width=2, buff=0.05)), icp[4].animate.set_opacity(1), icp[4 + n].animate.set_opacity(1))\n        self.play(Transform(hl, CreateHighlight(outknap.code[1][26:26 + 3], stroke_width=2, buff=0.05)), icp[5].animate.set_opacity(1), icp[5 + n].animate.set_opacity(1))\n        self.play(AnimationGroup(FadeOut(hl, icp), AnimationGroup(self.camera.frame.animate.restore(), code.animate.set_opacity(1), g.animate.set_opacity(1), bg.animate.restore())))\n        bg.set_z_index(bgzi)\n        fade_rect = get_fade_rect().set_z_index(100000000)\n        text1 = Tex('NP-hard in \\\\textit{theory}...').set_z_index(fade_rect.get_z_index() + 1)\n        text2 = Tex('Very fast in \\\\textit{practice}!').set_z_index(fade_rect.get_z_index() + 1)\n        VGroup(text1, text2).arrange(DOWN, buff=0.3).move_to(code).scale(1.5)\n        self.play(AnimationGroup(FadeIn(fade_rect), Write(text1, run_time=1.5), lag_ratio=0.5))\n        self.play(Write(text2, run_time=1.5))\n        self.play(FadeOut(text1), FadeOut(text2), FadeOut(fade_rect))\n        farmer_title = Tex(\"\\\\underline{Farmer's Problem}\").scale(1.5)\n        farmer = ImageMobject('assets/midjourney/farmer-outline.png').set_z_index(10).set_height(0.9)\n        g = Group(farmer_title, farmer).arrange(buff=0.3)\n        g.move_to(title_plus_knapsack).shift(RIGHT * self.camera.frame.width)\n        code2 = MyCode('code/farmer.py').scale(0.56).move_to(code).shift(RIGHT * self.camera.frame.width)\n        outfarm = MyCode('code/farmer.out').scale(0.56).next_to(code2, DOWN).align_to(code2, LEFT).set_z_index(code2.get_z_index() - 0.1)\n        self.add(g)\n        self.add(code2)\n        self.add(outfarm)\n        self.play(self.camera.frame.animate.shift(RIGHT * self.camera.frame.width), run_time=1.5)"}]}
{"messages": [{"role": "user", "content": "Animate a large orange dot with a sheen that follows its movement as it shifts left."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass RollTest(MovingCameraScene):\n\n    @fade\n    def construct(self):\n\n        def sheen_updater(obj, dt):\n            v = obj.get_sheen_direction()\n            d = Dot().move_to(v).rotate_about_origin(PI / 30)\n            obj.set_sheen_direction(d.get_center())\n        d = Dot().scale(10).set_color(ORANGE).set_sheen(0.3)\n        d.add_updater(sheen_updater)\n        self.add(d)\n        self.play(d.animate.shift(LEFT))"}]}
{"messages": [{"role": "user", "content": "Animate the text 'a' followed by 'b' appearing on the screen."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass TexTest(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        self.add(Tex('a \\\\par b'))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the process of finding the maximum flow in a network, highlighting the flow values on edges and then demonstrating the relationship between the primal and dual linear programming problems and the min-cut max-flow theorem."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass Flows(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        with open('assets/g.txt') as f:\n            graph = parse_graph(f.read())\n        self.camera.frame.scale(0.9)\n        start = Tex('\\\\bf start').next_to(graph.vertices[11], DOWN, buff=0.35).align_to(graph.vertices[11], RIGHT)\n        start.add(Tex('\\\\bf ($\\\\mathbf{v}_1$)').next_to(start, DOWN, buff=0.1).scale(0.8))\n        end = Tex('\\\\bf end').next_to(graph.vertices[14], DOWN, buff=0.35).align_to(graph.vertices[14], LEFT)\n        end.add(Tex('\\\\bf ($\\\\mathbf{v}_m$)').next_to(end, DOWN, buff=0.1).scale(0.8))\n        seed(59774856946)\n\n        def get_weight(edge, weight, flow=None):\n            val = str(weight) if flow is None else f'{flow}/{weight}'\n            weight = Tex(val, color=BLACK).move_to(edge).scale(0.45).set_z_index(10)\n            sr = SurroundingRectangle(weight, color=WHITE, fill_opacity=1, corner_radius=0.05, buff=0.05).move_to(weight).set_z_index(9)\n            weight.add(sr)\n            if flow is not None:\n                weight[0][:len(str(flow))].set_color(DARK_BLUE)\n            return weight\n        weights = {}\n        weights_vgroup = VGroup()\n        for edge in graph.edges:\n            weights[edge] = randint(5, 20)\n            weights_vgroup.add(get_weight(graph.edges[edge], weights[edge]))\n        for vertex in graph.vertices:\n            graph.vertices[vertex].scale(1.5)\n        self.play(AnimationGroup(AnimationGroup(FadeIn(graph), FadeIn(weights_vgroup)), AnimationGroup(FadeIn(start), FadeIn(end)), lag_ratio=0.5))\n        G = nx.DiGraph()\n        for x, y in graph.edges:\n            G.add_edge(x, y, capacity=weights[x, y])\n        flow_value, flow_dict = nx.maximum_flow(G, 11, 14)\n        used_vertices = set()\n        for edge in graph.edges:\n            if flow_dict[edge[0]][edge[1]] > 0:\n                used_vertices.add(edge[0])\n                used_vertices.add(edge[1])\n        new_weights_group = VGroup()\n        new_weights_group_dict = {}\n        for edge in graph.edges:\n            new_weights_group_dict[edge] = get_weight(graph.edges[edge], weights[edge], flow=flow_dict[edge[0]][edge[1]]).scale(0.8)\n            new_weights_group.add(new_weights_group_dict[edge])\n        self.play(*[AnimationGroup(AnimationGroup(Transform(a[0], b[0][len(str(flow_dict[e[0]][e[1]])) + 1:]), Transform(a[1], b[1])), FadeIn(b[0][:len(str(flow_dict[e[0]][e[1]])) + 1]), lag_ratio=0.5) for a, b, e in zip(weights_vgroup, new_weights_group, graph.edges)])\n        for o in self.mobjects:\n            self.remove(o)\n        self.add(start, end, graph, new_weights_group)\n        self.camera.frame.save_state()\n        v = 9\n        for edge in graph.edges:\n            graph.edges[edge].save_state()\n            new_weights_group_dict[edge].save_state()\n        for vertex in graph.vertices:\n            graph.vertices[vertex].save_state()\n        move_group = VGroup(graph.vertices[v])\n        for edge in graph.edges:\n            if v in edge:\n                move_group.add(new_weights_group_dict[edge])\n        in_values = []\n        out_values = []\n        in_values_edges = []\n        out_values_edges = []\n        for edge in graph.edges:\n            if v == edge[1]:\n                in_values.append(flow_dict[edge[0]][edge[1]])\n                in_values_edges.append(edge)\n            elif v == edge[0]:\n                out_values.append(flow_dict[edge[0]][edge[1]])\n                out_values_edges.append(edge)\n        eq = Tex('$' + '+'.join(list(map(str, in_values))) + '=' + '+'.join(list(map(str, out_values))) + '$').scale(0.6).next_to(graph.vertices[v], UP)\n        eq[0][0].set_color(BLUE)\n        eq[0][2].set_color(BLUE)\n        eq[0][4].set_color(BLUE)\n        eq[0][6].set_color(BLUE)\n        self.play(self.camera.frame.animate.move_to(VGroup(move_group, eq)).scale(0.4), *[AnimationGroup(graph.edges[edge].animate.set_color(BIG_COLOR), new_weights_group_dict[edge][0].animate.set_opacity(BIG_OPACITY), new_weights_group_dict[edge][1].animate.set_color(BIG_COLOR)) for edge in graph.edges if edge[0] != v and edge[1] != v], *[graph.vertices[vertex].animate.set_color(BIG_COLOR) for vertex in graph.vertices if vertex != v])\n        c1 = new_weights_group_dict[in_values_edges[0]][0][0][0].copy()\n        c2 = new_weights_group_dict[in_values_edges[1]][0][0][0].copy()\n        c3 = new_weights_group_dict[out_values_edges[0]][0][0][0].copy()\n        c4 = new_weights_group_dict[out_values_edges[1]][0][0][0].copy()\n        self.play(AnimationGroup(AnimationGroup(Transform(c1, eq[0][0]), Transform(c2, eq[0][2]), Transform(c3, eq[0][4]), Transform(c4, eq[0][6])), AnimationGroup(FadeIn(eq[0][1]), FadeIn(eq[0][3]), FadeIn(eq[0][5])), lag_ratio=0))\n        self.play(self.camera.frame.animate.restore(), FadeOut(c1, c2, c3, c4), FadeOut(eq), *[AnimationGroup(graph.edges[edge].animate.restore(), new_weights_group_dict[edge].animate.restore()) for edge in graph.edges if edge[0] != v and edge[1] != v], *[graph.vertices[vertex].animate.restore() for vertex in graph.vertices if vertex != v])\n        for edge in graph.edges:\n            angle = graph.edges[edge].get_normal_vector()\n            graph.edges[edge].set_sheen_direction(-angle)\n        self.play(*[graph.edges[edge].animate.set_stroke_width(weights[edge]).set_color_by_gradient([WHITE] * (weights[edge] - flow_dict[edge[0]][edge[1]]) + [BLUE] * flow_dict[edge[0]][edge[1]]) for edge in graph.edges], *[weight.animate.scale(0.2).set_opacity(0) for weight in new_weights_group], *[graph.vertices[vertex].animate.set_color(BLUE) for vertex in used_vertices])\n        primal = VGroup(Tex('\\\\bf Primal (max-flow)').scale(1.5), VGroup(Tex('variables: $x_{u,v}$ for edges, $z$ for flow'), Tex('objective function: $\\\\max z$')).arrange(DOWN, buff=0.35), Tex('$$\\n\\\\begin{aligned}\\n\\\\sum_{u, v \\\\in E} x_{u,v} - \\\\sum_{v,u \\\\in E} x_{v,u} &= \\\\begin{cases}\\\\phantom{-}z & u=1\\\\\\\\ -z & u=m \\\\\\\\ \\\\phantom{-}0 & \\\\text{otherwise}\\\\end{cases}\\\\\\\\\\nx_{u,v} &\\\\le k_{u,v} \\\\\\\\\\nx_{u,v} &\\\\ge 0 \\\\\\\\\\n\\\\end{aligned}\\n                $$')).scale(0.8).arrange(DOWN, buff=0.5)\n        primal[0][0][:6].set_color(BLUE)\n        dual = VGroup(Tex('\\\\bf Dual (min-cut)').scale(1.5), VGroup(Tex('variables: $w_{u,v}$ for edges, $y_{u,v}$ for vertices'), Tex('objective function: $\\\\min \\\\sum_{u, v \\\\in E} k_{u,v} w_{u,v}$')).arrange(DOWN, buff=0.35), Tex('$$\\n\\\\begin{aligned}\\ny_u - y_v + w_{u, v} &\\\\ge 0 \\\\\\\\\\ny_m - y_1 &\\\\ge 1 \\\\\\\\\\nw_{u,v} &\\\\ge 0 \\\\\\\\\\n\\\\end{aligned}\\n                $$')).scale(0.8).arrange(DOWN, buff=0.5)\n        dual[0][0][:4].set_color(ORANGE)\n        g = VGroup(primal.copy(), dual).arrange(RIGHT, buff=2).next_to(graph, DOWN, buff=1)\n        primal.move_to(g)\n        dual.align_to(primal, UP)\n        self.play(self.camera.frame.animate.move_to(Group(graph, primal)).set_height(Group(graph, primal).get_height() * 1.2), FadeIn(primal))\n        cut_value, partition = nx.minimum_cut(G, 11, 14)\n        self.play(AnimationGroup(Transform(primal, g[0]), FadeIn(dual), lag_ratio=0.5))\n        cut_edges = []\n        for edge in graph.edges:\n            if edge[0] in partition[0] and edge[1] in partition[1]:\n                cut_edges.append(edge)\n        line = Line(graph.edges[cut_edges[0]].get_center(), graph.edges[cut_edges[1]].get_center(), stroke_width=5).scale(1.5).set_color(ORANGE).shift((UP + LEFT) * 0.1)\n        self.play(AnimationGroup(AnimationGroup(*[graph.edges[edge].animate.set_stroke_width(weights[edge]).set_color_by_gradient(ORANGE).set_opacity(BIG_OPACITY) for edge in graph.edges if edge[0] in partition[0] and edge[1] in partition[1]], *[graph.edges[edge].animate.set_stroke_width(weights[edge]).set_color(LIGHT_ORANGE) for edge in graph.edges if edge[0] in partition[0] and edge[1] in partition[0]], *[graph.edges[edge].animate.set_stroke_width(weights[edge]).set_color(DARK_ORANGE) for edge in graph.edges if edge[0] in partition[1] and edge[1] in partition[1]], *[graph.vertices[vertex].animate.set_color(LIGHT_ORANGE) for vertex in graph.vertices if vertex in partition[0]], *[graph.vertices[vertex].animate.set_color(DARK_ORANGE) for vertex in graph.vertices if vertex in partition[1]]), Create(line), lag_ratio=0.5))"}]}
{"messages": [{"role": "user", "content": "Animate a scene that summarizes topics of Simplex Method, Duality, and Integer LP with corresponding images and text, then transitions to illustrating the feasible region of an optimization problem with changing constraints and finally displays a collection of related topics."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim import *\nfrom utilities import *\nfrom math import atan2\n\nclass Outro(MovingCameraScene):\n\n    @fade\n    def construct(self):\n        text = Tex(\"\\\\underline{What we've covered}\").scale(1.5).shift(UP * 2)\n        text_scale = 0.8\n        subtext_scale = 0.65\n        sss = 0.9\n        a = Rectangle(width=1.6, height=0.9, fill_color=BLACK)\n        b = Rectangle(width=1.6, height=0.9, fill_color=BLACK)\n        c = Rectangle(width=1.6, height=0.9, fill_color=BLACK)\n        aimg = ImageMobject('assets/1-simplex.png').set_height(a.get_height() * 0.99).move_to(a).set_z_index(10)\n        bimg = ImageMobject('assets/2-duality.png').set_height(b.get_height() * 0.99).move_to(b).set_z_index(10)\n        cimg = ImageMobject('assets/3-ilp.png').set_height(c.get_height() * 0.99).move_to(c).set_z_index(10)\n        g = Group(Group(a, aimg), Group(b, bimg), Group(c, cimg)).arrange(buff=0.3).set(width=self.camera.frame.width * 0.85)\n        at = Tex('Simplex Method').scale(text_scale).next_to(a, DOWN)\n        bt = Tex('Duality').scale(text_scale).next_to(b, DOWN)\n        ct = Tex('Integer LP').scale(text_scale).next_to(c, DOWN)\n        att = VGroup(Tex('\\\\it Initial solution?').scale(subtext_scale), Tex('\\\\it Exponential!').scale(subtext_scale), Tex('\\\\it Infinite loop!').scale(subtext_scale)).arrange(DOWN, buff=0.15).next_to(at, DOWN, buff=0.3).set_color(RED)\n        att[2].shift(UP * 0.05)\n        btt = VGroup(Tex('\\\\it General conversion?').scale(subtext_scale), Tex('\\\\it Fast algorithms?').scale(subtext_scale)).arrange(DOWN, buff=0.15).next_to(bt, DOWN, buff=0.3).set_color(RED)\n        ctt = VGroup(Tex('\\\\it Fast classes?').scale(subtext_scale), Tex('\\\\it Approximations?').scale(subtext_scale)).arrange(DOWN, buff=0.15).next_to(ct, DOWN, buff=0.3).set_color(RED)\n        self.play(FadeIn(text))\n        self.play(FadeIn(a, at, aimg))\n        self.play(FadeIn(b, bt, bimg))\n        self.play(FadeIn(c, ct, cimg))\n        ag = Group(aimg, a, at)\n        bg = Group(bimg, b, bt)\n        cg = Group(cimg, c, ct)\n        self.play(b.animate.set_opacity(BIG_OPACITY).scale(sss, about_point=bg.get_center()), bt.animate.set_opacity(BIG_OPACITY).scale(sss, about_point=bg.get_center()), bimg.animate.set_opacity(BIG_OPACITY).scale(sss, about_point=bg.get_center()), c.animate.set_opacity(BIG_OPACITY).scale(sss, about_point=cg.get_center()), ct.animate.set_opacity(BIG_OPACITY).scale(sss, about_point=cg.get_center()), cimg.animate.set_opacity(BIG_OPACITY).scale(sss, about_point=cg.get_center()))\n        self.play(FadeIn(att[0], shift=DOWN * 0.2))\n        self.play(FadeIn(att[1], shift=DOWN * 0.2))\n        self.play(FadeIn(att[2], shift=DOWN * 0.2))\n        self.play(b.animate.set_opacity(1).scale(1 / sss, about_point=bg.get_center()), bt.animate.set_opacity(1).scale(1 / sss, about_point=bg.get_center()), bimg.animate.set_opacity(1).scale(1 / sss, about_point=bg.get_center()))\n        self.play(FadeIn(btt[0]))\n        self.play(FadeIn(btt[1]))\n        self.play(c.animate.set_opacity(1).scale(1 / sss, about_point=cg.get_center()), ct.animate.set_opacity(1).scale(1 / sss, about_point=cg.get_center()), cimg.animate.set_opacity(1).scale(1 / sss, about_point=cg.get_center()))\n        self.play(FadeIn(ctt[0]))\n        self.play(FadeIn(ctt[1]))\n        ineqs = []\n        ipts = [[(-2, 4), (2, 4), '<='], [(2, 4), (5, 1), '<='], [(5, 1), (5, -2), '<='], [(5, -2), (4, -9), '>='], [(4, -9), (3, -12), '>='], [(3, -12), (1, -13), '>='], [(1, -13), (0, -13), '>='], [(0, -13), (-2, -12), '>='], [(-2, -12), (-4, -10), '>='], [(-4, -10), (-5, -2), '>='], [(-5, -2), (-4, 1), '<='], [(-4, 1), (-2, 4), '<=']]\n        area = FeasibleArea2D()\n        for p1, p2, op in ipts:\n            a_, b_, c_ = Inequality2D.points_to_slope(p1, p2)\n            iq = Inequality2D(a_, b_, op, c_)\n            ineqs.append(iq)\n        area.add_inequalities(ineqs)\n        for d in area.dots:\n            d.scale(2)\n        self.add(area)\n        area.scale(0.8, about_point=ORIGIN)\n        area.shift(DOWN * 4)\n        area.set_opacity(0)\n        for ineq in ineqs:\n            ineq.scale(0.8, about_point=ORIGIN)\n            ineq.shift(DOWN * 4)\n        vt = ValueTracker()\n\n        def updater(obj):\n            if abs(vt.get_value()) <= 0.01:\n                return\n            obj._update_area()\n            obj.set_color(BLUE)\n            obj.fade(1 - vt.get_value())\n        water = Inequality2D(0, 1, '>=', 0).set_color(BLUE)\n        pengling = SVGMobject('assets/pengling/pengling.svg').set_height(1.25).next_to(area, UP, buff=0).shift(LEFT * 1 + DOWN * 0.18).set_z_index(10000000)\n        area.add_inequalities([water])\n        water.set_opacity(0)\n        self.add(water)\n        area.add_updater(updater)\n        atc = at.copy()\n        btc = bt.copy()\n        ctc = ct.copy()\n        compressed = VGroup(atc, VGroup(btc, ctc).arrange(buff=0.35)).arrange(DOWN, buff=0.3).scale(0.7).move_to(bt).shift(RIGHT * 0.1)\n        self.play(AnimationGroup(AnimationGroup(FadeOut(a), FadeOut(b), FadeOut(c), FadeOut(aimg), FadeOut(bimg), FadeOut(cimg), att.animate.shift(DOWN * 5 + RIGHT * 2), btt.animate.shift(DOWN * 5), ctt.animate.shift(DOWN * 5 + LEFT * 2)), AnimationGroup(Transform(at, atc), Transform(bt, btc), Transform(ct, ctc), water.animate.shift(DOWN * 2).set_opacity(1), Succession(Wait(0.5), FadeIn(pengling, run_time=1)), vt.animate.set_value(1), run_time=1.5), lag_ratio=0.75))\n        self.remove(att, btt, ctt)\n        area.remove_updater(updater)\n        area.remove_inequalities([water], update=False)\n\n        def updater(obj):\n            obj._update_area()\n            obj.set_color(DARK_BLUE)\n        a2 = deepcopy(area)\n        area.dots.set_z_index(10000000)\n        wi = deepcopy(water)\n        wi.operation = '<='\n        a2.add_inequalities([wi, water])\n        a2.add_updater(updater)\n        w = water.copy().set_z_index(10000)\n        self.add(w)\n        self.add(a2)\n        sq = get_infinite_square(opacity=0.1).align_to(water, UP).set_z_index(0)\n        water.set_opacity(BIG_OPACITY)\n        self.camera.frame.save_state()\n        seed(57005)\n        q = 4\n        text2 = [('Other LP variants', -1, 0), ('Computational complexity', 1.15, 0), ('Unboundedness', -2, 0.5), ('Relaxation', -0.4, 0), ('Complementary slackness', 1.1, 0), ('Primal-dual algorithms', -2.2, 0.3), ('Pivot rules', 0.8, 0.2), ('Ellipsoid method', -0.2, 0), ('Interior path method', -1.8, 0), ('Total unimodularity', 1, 0.3), (\"Gomory's cuts\", -0.7, 0)]\n        texts = VGroup(*[Tex(t).scale(0.5).set_z_index(100000000000).set_opacity(0.9 - i / len(text2) * 0.85) for i, (t, _, _) in enumerate(text2)]).arrange(DOWN, buff=0.55).next_to(w, DOWN, buff=0.75)\n        for i in range(len(text2)):\n            texts[i].shift(text2[i][1] * RIGHT)\n            if text2[i][2] != 0:\n                texts[i:].shift(UP * text2[i][2])\n        sq = ineqs[0].get_half_plane().rotate(PI, about_point=ineqs[0].get_center())\n        for i in ineqs[1:]:\n            sq = Union(sq, i.get_half_plane().rotate(PI, about_point=i.get_center()))\n        sq = Intersection(sq, w.get_half_plane().rotate(PI, about_point=w.get_center()), color=BLUE, fill_opacity=BIG_OPACITY, stroke_width=0).set_z_index(0)\n        self.play(Succession(Wait(0.5), FadeIn(sq, run_time=1.5)), Succession(Wait(0.5), AnimationGroup(*[Succession(Wait(0.07 * i), FadeIn(t)) for i, t in enumerate(texts)])), FadeOut(text), self.camera.frame.animate.shift(DOWN * 4).scale(1.45), water.animate.shift(DOWN * 8), run_time=3)\n        a2.remove_updater(updater)\n        tfw = Tex('Thanks for watching!').scale(1.75)\n        tfw.align_to(self.camera.frame, UP).shift(UP * 0.5)\n        self.play(self.camera.frame.animate.restore(), FadeOut(texts), FadeOut(at, bt, ct), Succession(Wait(1), Write(tfw, run_time=1.5)), run_time=1.5)"}]}
{"messages": [{"role": "user", "content": "Display a logo with animated hands, a transforming head, and a shrinking camera frame."}, {"role": "assistant", "content": "from manim import *\n\nclass Intro(MovingCameraScene):\n\n    def construct(self):\n        text = SVGMobject('ksp-text.svg').set_z_index(1)\n        head = SVGMobject('ksp-head.svg')\n        head_eyes = SVGMobject('ksp-head-eyes.svg')\n        e = 1\n        hand_l = SVGMobject('ksp-hand-l.svg').shift(LEFT * e).scale(0.2)\n        hand_r = SVGMobject('ksp-hand-r.svg').shift(RIGHT * e).scale(0.2)\n        self.play(FadeIn(text))\n        self.add(hand_l)\n        self.add(hand_r)\n        point_coordinates = [ORIGIN, UP * 0.3, UP * 0.4, UP * 0.15]\n        bezier = CubicBezier(*point_coordinates).scale(1.5)\n        d = 1.63\n        self.add(head)\n        head.shift(UP * d)\n        head_eyes.shift(UP * d)\n        head.save_state()\n        head.shift(DOWN * d)\n        head.set_opacity(0)\n        self.play(head.animate.restore(), self.camera.frame.animate.move_to(VGroup(text, head.copy().shift(UP * d))), Succession(Wait(0.45), AnimationGroup(MoveAlongPathShow(hand_l, bezier.copy().shift(LEFT * 1.4 + UP * 0.8)), MoveAlongPathShow(hand_r, bezier.copy().shift(RIGHT * 1.4 + UP * 0.8)), lag_ratio=0.1)))\n        text_fade = SVGMobject('ksp-text-fade.svg').set_z_index(1)\n        self.play(AnimationGroup(AnimationGroup(Transform(head, head_eyes), Transform(text, text_fade), lag_ratio=0.3), self.camera.frame.animate(rate_func=rush_into).move_to(text.copy().shift(DOWN * 0.15)).scale(0.001), lag_ratio=0.75))"}]}
{"messages": [{"role": "user", "content": "Animate a blue circle transforming into a green square."}, {"role": "assistant", "content": "from manim import *\n\nclass CircleToSquare(Scene):\n\n    def construct(self):\n        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n        green_square = Square(color=GREEN, fill_opacity=0.8)\n        self.play(Create(blue_circle))\n        self.wait()\n        self.play(Transform(blue_circle, green_square))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a blue, semi-transparent circle and display text below it."}, {"role": "assistant", "content": "from manim import *\n\nclass HelloCircle(Scene):\n\n    def construct(self):\n        circle = Circle()\n        blue_circle = circle.set_color(BLUE).set_opacity(0.5)\n        label = Text('A wild circle appears!')\n        label.next_to(blue_circle, DOWN, buff=0.5)\n        self.play(Create(blue_circle), Write(label))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display text announcing a circle, then draw a blue circle below it."}, {"role": "assistant", "content": "from manim import *\n\nclass CircleAnnouncement(Scene):\n\n    def construct(self):\n        blue_circle = Circle(color=BLUE, fill_opacity=0.5)\n        announcement = Text('Let us draw a circle.')\n        self.play(Write(announcement))\n        self.wait()\n        self.play(announcement.animate.next_to(blue_circle, UP, buff=0.5))\n        self.play(Create(blue_circle))"}]}
{"messages": [{"role": "user", "content": "Animate a red triangle by drawing its border and fill, then shifting it left, scaling it up while shifting right, and finally rotating it."}, {"role": "assistant", "content": "from manim import *\n\nclass AnimateSyntax(Scene):\n\n    def construct(self):\n        triangle = Triangle(color=RED, fill_opacity=1)\n        self.play(DrawBorderThenFill(triangle))\n        self.play(triangle.animate.shift(LEFT))\n        self.play(triangle.animate.shift(RIGHT).scale(2))\n        self.play(triangle.animate.rotate(PI / 3))"}]}
{"messages": [{"role": "user", "content": "Animate two squares, one blue and one green, rotating in opposite directions simultaneously."}, {"role": "assistant", "content": "from manim import *\n\nclass DifferentRotations(Scene):\n\n    def construct(self):\n        left_square = Square(color=BLUE, fill_opacity=0.7).shift(2 * LEFT)\n        right_square = Square(color=GREEN, fill_opacity=0.7).shift(2 * RIGHT)\n        self.play(left_square.animate.rotate(PI), Rotate(right_square, angle=PI), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the writing of the Cauchy Integral Formula."}, {"role": "assistant", "content": "from manim import *\n\nclass CauchyIntegralFormula(Scene):\n\n    def construct(self):\n        formula = MathTex('[z^n]f(z) = \\\\frac{1}{2\\\\pi i}\\\\oint_{\\\\gamma} \\\\frac{f(z)}{z^{n+1}}~dz')\n        self.play(Write(formula), run_time=3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Transform an equation into a different form, then transform it again into a final simplified form."}, {"role": "assistant", "content": "from manim import *\n\nclass TransformEquation(Scene):\n\n    def construct(self):\n        eq1 = MathTex('42 {{ a^2 }} + {{ b^2 }} = {{ c^2 }}')\n        eq2 = MathTex('42 {{ a^2 }} = {{ c^2 }} - {{ b^2 }}')\n        eq3 = MathTex('a^2 = \\\\frac{c^2 - b^2}{42}')\n        self.add(eq1)\n        self.wait()\n        self.play(TransformMatchingTex(eq1, eq2))\n        self.wait()\n        self.play(TransformMatchingShapes(eq2, eq3))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Write the product rule and emphasize its terms with transforming rectangles."}, {"role": "assistant", "content": "from manim import *\n\nclass FormulaEmphasis(Scene):\n\n    def construct(self):\n        product_formula = MathTex('\\\\frac{d}{dx} f(x)g(x) =', 'f(x) \\\\frac{d}{dx} g(x)', '+', 'g(x) \\\\frac{d}{dx} f(x)')\n        self.play(Write(product_formula))\n        box1 = SurroundingRectangle(product_formula[1], buff=0.1)\n        box2 = SurroundingRectangle(product_formula[3], buff=0.1)\n        self.play(Create(box1))\n        self.wait()\n        self.play(Transform(box1, box2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a title, axes, and multiple plots of $y=x^n$ and $y=x^{1/n}$ for varying $n$, along with a point and lines at (1,1)."}, {"role": "assistant", "content": "from manim import *\n\nclass PlotExample(Scene):\n\n    def construct(self):\n        plot_axes = Axes(x_range=[0, 1, 0.05], y_range=[0, 1, 0.05], x_length=9, y_length=5.5, axis_config={'numbers_to_include': np.arange(0, 1 + 0.1, 0.1), 'font_size': 24}, tips=False)\n        y_label = plot_axes.get_y_axis_label('y', edge=LEFT, direction=LEFT, buff=0.4)\n        x_label = plot_axes.get_x_axis_label('x')\n        plot_labels = VGroup(x_label, y_label)\n        plots = VGroup()\n        for n in np.arange(1, 20 + 0.5, 0.5):\n            plots += plot_axes.plot(lambda x: x ** n, color=WHITE)\n            plots += plot_axes.plot(lambda x: x ** (1 / n), color=WHITE, use_smoothing=False)\n        extras = VGroup()\n        extras += plot_axes.get_horizontal_line(plot_axes.c2p(1, 1, 0), color=BLUE)\n        extras += plot_axes.get_vertical_line(plot_axes.c2p(1, 1, 0), color=BLUE)\n        extras += Dot(point=plot_axes.c2p(1, 1, 0), color=YELLOW)\n        title = Title('Graphs of $y=x^{\\\\frac{1}{n}}$ and $y=x^n (n=1, 1.5, 2, 2.5, 3, \\\\dots, 20)$', include_underline=False, font_size=40)\n        self.play(Write(title))\n        self.play(Create(plot_axes), Create(plot_labels), Create(extras))\n        self.play(AnimationGroup(*[Create(plot) for plot in plots], lag_ratio=0.05))"}]}
{"messages": [{"role": "user", "content": "Generate an animated Erdos-Renyi graph where nodes are initially created and then rearranged into a circular pattern before being uncreated."}, {"role": "assistant", "content": "from manim import *\nimport networkx as nx\n\nclass ErdosRenyiGraph(Scene):\n\n    def construct(self):\n        G = Graph.from_networkx(nxgraph, layout='spring', layout_scale=3.5)\n        self.play(Create(G))\n        self.play(*[G[v].animate.move_to(5 * RIGHT * np.cos(ind / 7 * PI) + 3 * UP * np.sin(ind / 7 * PI)) for ind, v in enumerate(G.vertices)])\n        self.play(Uncreate(G))"}]}
{"messages": [{"role": "user", "content": "Display a Python code block that animates a square fading in and scaling."}, {"role": "assistant", "content": "from manim import *\nimport networkx as nx\n\nclass CodeFromString(Scene):\n\n    def construct(self):\n        code = 'from manim import Scene, Square\\n\\nclass FadeInSquare(Scene):\\n    def construct(self):\\n        s = Square()\\n        self.play(FadeIn(s))\\n        self.play(s.animate.scale(2))\\n        self.wait()\\n'\n        rendered_code = Code(code=code, tab_width=4, background='window', language='Python', font='Monospace')\n        self.play(Write(rendered_code))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Present a title and a mathematical formula, transform the title and fade out the formula, then display a number plane with a title, and finally apply a nonlinear transformation to the plane and update the title."}, {"role": "assistant", "content": "from manim import *\nimport networkx as nx\n\nclass OpeningManim(Scene):\n\n    def construct(self):\n        title = Tex('This is some \\\\LaTeX')\n        basel = MathTex('\\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^2} = \\\\frac{\\\\pi^2}{6}')\n        VGroup(title, basel).arrange(DOWN)\n        self.play(Write(title), FadeIn(basel, shift=UP))\n        self.wait()\n        transform_title = Tex('That was a transform')\n        transform_title.to_corner(UP + LEFT)\n        self.play(Transform(title, transform_title), LaggedStart(*[FadeOut(obj, shift=DOWN) for obj in basel]))\n        self.wait()\n        grid = NumberPlane(x_range=(-10, 10, 1), y_range=(-6.0, 6.0, 1))\n        grid_title = Tex('This is a grid')\n        grid_title.scale(1.5)\n        grid_title.move_to(transform_title)\n        self.add(grid, grid_title)\n        self.play(FadeOut(title), FadeIn(grid_title, shift=DOWN), Create(grid, run_time=3, lag_ratio=0.1))\n        self.wait()\n        grid_transform_title = Tex('That was a non-linear function \\\\\\\\ applied to the grid')\n        grid_transform_title.move_to(grid_title, UL)\n        grid.prepare_for_nonlinear_transform()\n        self.play(grid.animate.apply_function(lambda p: p + np.array([np.sin(p[1]), np.sin(p[0]), 0])), run_time=3)\n        self.wait()\n        self.play(Transform(grid_title, grid_transform_title))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a cascading chain of geometric shapes transforming into a heart with scattered elements, culminating in a \"Merry Christmas!\" message."}, {"role": "assistant", "content": "from types import FunctionType\nfrom manimlib import *\n\nclass Main(Scene):\n\n    def construct(self):\n        mob = Triangle()\n        mob\n        t1 = Polygon(1.4 * UP, -1.7 * LEFT, 1.7 * LEFT)\n        t2 = t1.copy()\n        t3 = t1.copy()\n        rec = Polygon(0.5 * LEFT + 2 * UP, 0.5 * RIGHT + 2 * UP, 0.5 * RIGHT, 0.5 * LEFT)\n        gp = VGroup(t1 + t2 + t3 + rec)\n\n        def create_top_to_down_connection_updator(up: Mobject, down: Mobject, dis: int=0) -> FunctionType:\n            return lambda mob: mob.move_to(up.get_bottom() - down.get_top() + down.get_center() + dis * DOWN)\n\n        def always_up_aligh_with_mid(up: Mobject, down: Mobject):\n            down.add_updater(lambda mob: mob.move_to(up.get_center() - down.get_top() + down.get_center()))\n        always_up_aligh_with_mid(t1, t2)\n        always_up_aligh_with_mid(t2, t3)\n        rec.add_updater(create_top_to_down_connection_updator(t3, rec))\n        self.play(ShowCreation(t1))\n        self.play(t1.animate.shift(0.5 * UP), ShowCreation(t2))\n        self.play(t1.animate.shift(0.5 * UP), ShowCreation(t3))\n        self.play(t1.animate.shift(0.5 * UP).scale(0.75), t3.animate.scale(1.25))\n        self.play(t1.animate.shift(0.5 * UP), ShowCreation(rec))\n        self.play(t1.animate.set_color(GREEN).set_fill(GREEN, 1), t2.animate.set_color(GREEN).set_fill(GREEN, 1), t3.animate.set_color(GREEN).set_fill(GREEN, 1), rec.animate.set_color(DARK_BROWN).set_fill(DARK_BROWN, 1))\n        self.add(t3)\n        self.wait(1)\n        self.play(gp.animate.shift(4.5 * LEFT))\n        kwarg_before = {'color': RED, 'fill_opacity': 0.3}\n        kwarg = {'color': RED, 'fill_opacity': 1.0}\n        pos = math.sqrt(2) / 2\n        sq_before = Square(**kwarg_before)\n        cir1_before = Circle(**kwarg_before)\n        cir2_before = Circle(**kwarg_before)\n        self.play(*[ShowCreation(mob) for mob in [sq_before, cir1_before, cir2_before]], run_time=1.8)\n        self.wait()\n        anim = (sq_before.animate.rotate(PI / 4), cir1_before.animate.move_to([pos, pos, 0]), cir2_before.animate.move_to([-pos, pos, 0]))\n        self.play(*anim, run_time=1.8, rate_func=smooth)\n        sq = Square(**kwarg)\n        sq.rotate(PI / 4)\n        cir1 = Circle(**kwarg)\n        cir2 = Circle(**kwarg)\n        cir1.move_to([pos, pos, 0])\n        cir2.move_to([-pos, pos, 0])\n        self.wait()\n        before = VGroup(sq_before, cir1_before, cir2_before)\n        after = VGroup(sq, cir1, cir2)\n        self.play(Transform(before, after), run_time=1.5, rate_func=smooth)\n        self.wait()\n        self.play(Transform(before, (h1 := get_heart())))\n        POS = [3.5 * LEFT + 0.5 * UP, 0.7 * UP + 5.5 * LEFT, 1.3 * UP + 4 * LEFT, 1.6 * UP + 5 * LEFT, 2.5 * UP + 4.5 * LEFT]\n        ANGLE = [-35 * DEGREES, 45 * DEGREES, 60 * DEGREES, -35 * DEGREES, 0]\n        cps = h1 * 5\n        self.play(*[i.animate.move_to(p).rotate(ang) for p, ang, i in zip(POS, ANGLE, cps)], FadeOut(before))\n        self.play((gp + cps).animate.move_to(ORIGIN + 1.3 * UP))\n        tx = Text('Merry Christmas!').add_background_rectangle(BLUE).scale(3).shift(2.3 * DOWN)\n        self.play(Write(tx), ShowCreation(SurroundingRectangle(tx, color=YELLOW)), run_time=2)"}]}
{"messages": [{"role": "user", "content": "Animate a number box that traces its path with a flashing effect."}, {"role": "assistant", "content": "from types import FunctionType\nfrom manimlib import *\n\nclass TextBox(Scene):\n\n    def construct(self):\n        flash_dict = {'line_length': 0.5, 'num_lines': 12, 'flash_radius': 0.5, 'line_stroke_width': 3, 'run_time': 2}\n        nb = NumberBox(scale_factor=1).move_to(2 * UP, DOWN)\n        self.add(nb)\n        self.wait()\n        nb.start_tracing(self, flash_dict)\n        self.embed()"}]}
{"messages": [{"role": "user", "content": "Create a sequence of number boxes animating to form the number 2022."}, {"role": "assistant", "content": "from types import FunctionType\nfrom manimlib import *\n\nclass Happy2022(Scene):\n\n    def construct(self):\n        flash_dict = {'line_length': 0.5, 'num_lines': 12, 'flash_radius': 0.5, 'line_stroke_width': 3, 'run_time': 2}\n        TWO = NumberBoxGroup([3, 4, 10, 11])\n        self.add(TWO)"}]}
{"messages": [{"role": "user", "content": "Create and animate a grid of number boxes, removing specific boxes and then adding tracing effects to the remaining ones."}, {"role": "assistant", "content": "from types import FunctionType\nfrom manimlib import *\n\nclass FinalWay2022(Scene):\n\n    def construct(self):\n        flash_dict = {'line_length': 0.5, 'num_lines': 12, 'flash_radius': 0.5, 'line_stroke_width': 3, 'run_time': 2}\n        nb = VGroup()\n        nb_sub = VGroup()\n        v = [2 * UP, UP, ORIGIN, DOWN, 2 * DOWN]\n        h = [LEFT, ORIGIN, RIGHT]\n        for i in v:\n            for j in h:\n                nb_sub.add(NumberBox(scale_factor=0.5).move_to(i + j))\n            nb.add(nb_sub)\n        nb = nb[0]\n        nb2 = nb.copy()\n        emp_list = [3, 4, 10, 11]\n        emp_list2 = [4, 7, 10]\n        just = 0\n        for i in emp_list:\n            nb.remove(nb[i - just])\n            just += 1\n        just = 0\n        for k in emp_list2:\n            nb2.remove(nb2[k - just])\n            just += 1\n        nb3 = nb.copy()\n        nb4 = nb.copy()\n        self.add(nb.shift(5 * RIGHT), nb2.shift(1.7 * LEFT), nb3.shift(1.7 * RIGHT), nb4.shift(5 * LEFT))\n        for i in range(len(nb)):\n            if isinstance(nb[i], NumberBox):\n                nb[i].start_tracing(self, flash_dict, 4, False)"}]}
{"messages": [{"role": "user", "content": "Create four animated \"CoolNumber\" objects with different initial values and positions, and then trace their values for ten seconds."}, {"role": "assistant", "content": "from types import FunctionType\nfrom manimlib import *\n\nclass LastTry(Scene):\n\n    def construct(self):\n        a = CoolNumber()\n        self.add(a.move_to(5 * LEFT))\n        b = CoolNumber([4, 7, 10]).move_to(1.7 * LEFT)\n        c = CoolNumber().move_to(1.7 * RIGHT)\n        d = CoolNumber().move_to(5 * RIGHT)\n        self.add(b, c, d)\n        a.start_tracing()\n        b.start_tracing()\n        c.start_tracing()\n        d.start_tracing()\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Animate a Chinese New Year greeting with transforming numbers and phrases, culminating in a bright flash effect."}, {"role": "assistant", "content": "from types import FunctionType\nfrom manimlib import *\n\nclass Final(Scene):\n\n    def construct(self):\n        fr: CameraFrame = self.camera.frame\n        fr.save_state()\n        a0 = NormalNumber()\n        self.add(a0.move_to(5 * LEFT))\n        b0 = NormalNumber([4, 7, 10]).move_to(1.7 * LEFT)\n        c0 = NormalNumber().move_to(1.7 * RIGHT)\n        d0 = NormalNumber().move_to(5 * RIGHT)\n        e0 = NormalNumber([0, 1, 3, 4, 6, 7, 9, 10, 12, 13]).move_to(5 * RIGHT)\n        self.add(b0, c0, e0)\n        self.wait(2)\n        tx1 = Text('\u65b0\u5e74\u5feb\u4e50!', font='\u6977\u4f53', color=RED).scale(3).shift(4.2 * UP)\n        bx1 = SurroundingRectangle(tx1, color=YELLOW)\n        p = VGroup(Text('\u56de\u99962021', font='\u6977\u4f53'), Text('\u4e5f\u8bb8\u5bf9\u4f60\u6211\u6765\u8bf4\u5e76\u65e0\u4e50\u8da3', font='\u6977\u4f53'), Text('\u53c8\u6216\u8005\u4f60\u9047\u5230\u4e86\u5f88\u591a\u70e6\u607c', font='\u6977\u4f53'), Text('\u4f46\u5373\u4fbf\u5982\u6b64', font='\u6977\u4f53'), Text('\u62e5\u6709\u4e00\u4e2a\u7070\u8272\u7684\u8fc7\u53bb', font='\u6977\u4f53'), Text('\u4e5f\u4e1d\u6beb\u4e0d\u4f1a\u53e6\u6211\u4eec', font='\u6977\u4f53'), Text('\u6000\u7591\u672a\u6765\u7684\u707f\u70c2\u8272\u5f69', font='\u6977\u4f53'))\n        fr.scale(1.5)\n        self.play(fr.animate.scale(1.5), fr.animate.shift(4 * RIGHT))\n        p.arrange(DOWN)\n        p.move_to(10.5 * RIGHT + UP)\n        self.play(Write(p[0]), run_time=1.5)\n        self.play(Write(p[1]), Write(p[2]), run_time=2)\n        self.play(Write(p[3]), TransformMatchingShapes(e0, d0), run_time=3)\n        a = CoolNumber()\n        a.move_to(5 * LEFT)\n        b = CoolNumber([4, 7, 10]).move_to(1.7 * LEFT)\n        c = CoolNumber().move_to(1.7 * RIGHT)\n        d = CoolNumber().move_to(5 * RIGHT)\n        olds = [a0, b0, c0, d0]\n        news = [a, b, c, d]\n        self.play(Write(p[4]), *[TransformMatchingShapes(m1, m2) for m1, m2 in zip(olds, news)], rate_func=rush_into)\n        self.wait(2)\n        self.play(Write(p[5]))\n        self.wait(1)\n        self.play(Write(p[6]), run_time=3)\n        self.play(fr.animate.restore())\n        self.play(fr.animate.shift(1.3 * UP), Write(tx1), ShowCreation(bx1), *[FadeOut(mob) for mob in p])\n        flash_dict = {'line_length': 0.5, 'num_lines': 12, 'flash_radius': 0.5, 'line_stroke_width': 3, 'run_time': 2}\n        self.play(*[Flash(po, **flash_dict) for po in [1.7 * LEFT, 1.7 * RIGHT, 5 * LEFT, 5 * RIGHT]])\n        self.wait(8)"}]}
{"messages": [{"role": "user", "content": "Animate the chain rule for differentiation, illustrating the transformation of composite functions and their derivatives with color-coded text and graphical representations."}, {"role": "assistant", "content": "from typing import Callable\nfrom manimlib import *\n\nclass FirstScene(Scene):\n\n    def debugTeX(self, texm: Mobject, scale_factor: int=0.6, text_color: str=PURPLE) -> None:\n        for i, j in enumerate(texm):\n            tex_id = Text(str(i), font='Consolas').scale(scale_factor).set_color(text_color)\n            tex_id.move_to(j)\n            self.add(tex_id)\n\n    def remove_all_except(self, values: list[Mobject], *exceptions: list[Mobject]):\n        if not values:\n            values = self.mobjects\n        print(values)\n        self.remove(*filter(lambda m: isinstance(m, Mobject) and m not in exceptions, values))\n        return self\n\n    def str_list_to_tex_list(self, f: list[str], **kwargs) -> VGroup:\n        return VGroup(*[Tex(s, **self.tex_kwargs, **kwargs) for s in f])\n\n    @staticmethod\n    def cross_center(horizontal: Mobject, vertical: Mobject) -> np.array:\n        return [vertical.get_center()[0], horizontal.get_center()[1], 0]\n\n    def setup(self):\n        self.isolate = ['f', 'g', 'x', '=', '(', ')', 'h', 'm_{1}', 'm_{2}', 'b_{1}', 'b_{2}', '+']\n        self.tex_to_color_map = {'x': RED, 'f': YELLOW, 'g': BLUE, 'h': GREEN, 'm_{1}': TEAL, 'm_{2}': TEAL}\n        self.chainrule = Tex(\"{d\\\\over dx} f(g(x)) = f'(g(x)) \\\\cdot g(x)\", isolate=self.isolate, tex_to_color_map=self.tex_to_color_map).move_to(3.2 * UP)\n        self.tex_kwargs = dict(isolate=self.isolate, tex_to_color_map=self.tex_to_color_map)\n\n    def construct(self):\n        self.play(Write(self.chainrule, run_time=5))\n        self.wait(3)\n        transed = self.chainrule[2:9].copy()\n        no_transed = transed.copy()\n        fg0 = Tex('f( \\\\ \\\\ x \\\\ )', isolate=[*self.isolate, '\\\\'], tex_to_color_map=self.tex_to_color_map).move_to(transed.get_center() + DOWN)\n        fg1 = Tex('f(x)', isolate=self.isolate, tex_to_color_map=self.tex_to_color_map).move_to(transed.get_center() + DOWN)\n        self.play(Write(fg1, run_time=3.5))\n        self.wait()\n        no_transed.shift(2 * DOWN)\n        self.wait(3)\n        arr = CurvedArrow(fg0.get_left(), transed.get_left() + 2 * DOWN).set_color(BLUE)\n        what_happened = Text('What Happened?', font_size=20).move_to(arr.get_center() + 1.7 * LEFT)\n        self.play(TransformMatchingTex(fg1, fg0, run_time=2.5))\n        self.play(TransformMatchingTex(fg0.copy(), (__copied := transed.copy().shift(2 * DOWN))), *[ShowCreation(mob) for mob in [arr, what_happened]], transed.animate.shift(2 * DOWN))\n        self.remove(__copied)\n        self.wait(3)\n        title = Text('Part 1')\n        title2 = Text('Linear Combinations', font_size=20)\n        gx = Tex('g(x)', **self.tex_kwargs).move_to(transed)\n        formulas = ['=2x', '=3x']\n        formulas = VGroup(*[Tex(s, **self.tex_kwargs) for s in formulas])\n        VGroup(title, title2).arrange(DOWN).move_to(3.2 * UP + 4.3 * RIGHT)\n        self.play(Write(VGroup(title, title2)), self.chainrule.animate.shift(3 * LEFT), *[FadeOut(mob) for mob in [what_happened, arr]], LaggedStart(TransformMatchingTex(fg0, fg1), TransformMatchingTex(transed, gx), ShowCreation(formulas[0].next_to(fg1)), ShowCreation(formulas[1].next_to(gx))))\n        axis = Axes(x_range=[-1.0, 6.0, 1.0], y_range=[-1.0, 20.0, 1.0], height=FRAME_HEIGHT * 1.3, width=FRAME_WIDTH * 1.3).scale(0.5).shift(1.5 * RIGHT + 0.5 * DOWN)\n        labels = axis.add_coordinate_labels(font_size=12)\n        x_min = -0.5\n        x_max = 2.5\n        h_graph = axis.get_graph(lambda x: 6 * x, x_range=[x_min, x_max, 0.1], color=GREEN)\n        f_graph = axis.get_graph(lambda x: 2 * x, x_range=[x_min, x_max, 0.1], color=YELLOW)\n        g_graph = axis.get_graph(lambda x: 3 * x, x_range=[x_min, x_max, 0.1], color=BLUE)\n        self.play(LaggedStart(AnimationGroup(*[mob.animate.shift(4 * LEFT) for mob in [formulas[0], formulas[1], fg1, gx]]), *[ShowCreation(mob) for mob in [axis, f_graph, g_graph]], lag_ratio=0.2))\n        self.wait(3)\n        fx = fg1\n        hx = Tex('h(x)', **self.tex_kwargs).next_to(gx, DOWN)\n        self.play(*[ApplyWave(mob, run_time=1.3, amplitude=0.28) for mob in [fx, f_graph, formulas[0]]])\n        self.wait(1)\n        self.play(*[ApplyWave(mob, run_time=1.3, amplitude=0.28) for mob in [gx, g_graph, formulas[1]]])\n        gx_copy = gx.copy()\n        gx_copy.shift(DOWN)\n        fx_copy = fx.copy()\n        fx_copy[0].next_to(fx_copy[1].next_to(gx_copy, LEFT, SMALL_BUFF / 2), LEFT, SMALL_BUFF / 1.5)\n        fx_copy[3].next_to(gx_copy, RIGHT, SMALL_BUFF / 3)\n        formulas_copy = formulas.copy()\n        formulas_copy[0][0].shift(2 * DOWN)\n        formulas_copy[0][1].shift(2 * DOWN)\n        star = Tex('\\\\cdot').next_to(formulas_copy[0][1], RIGHT, SMALL_BUFF)\n        formulas_copy[1].remove(formulas_copy[1][0]).next_to(star, RIGHT, SMALL_BUFF)\n        _a = [gx, *[fx[i] for i in [0, 1, 3]], formulas[0][0], formulas[0][1], formulas[1][1], formulas[1][2]]\n        _b = [gx_copy, *[fx_copy[i] for i in [0, 1, 3]], formulas_copy[0][0], formulas_copy[0][1], formulas_copy[1][0], formulas_copy[1][1]]\n        self.wait(3)\n        self.play(*[ReplacementTransform(__a.copy(), __b) for __a, __b in zip(_a, _b)], ShowCreation(star))\n        self.play(ShowCreation(h_graph))\n        self.wait(4)\n        self.play(*[mob.animate.shift(DOWN) for mob in [*_a, *_b, *formulas, star, fx[2]]])\n        dx = self.chainrule[0:2]\n        dx_copy = dx.copy().shift(2.6 * RIGHT + DOWN)\n        self.play(ReplacementTransform(dx.copy(), dx_copy))\n        self.play(LaggedStart(ReplacementTransform(formulas[0][1].copy(), (c := formulas[0][1].copy().move_to(self.cross_center(fx, dx_copy)).set_color(TEAL))), ReplacementTransform(formulas[1][1].copy(), (d := formulas[1][1].copy().move_to(self.cross_center(gx, dx_copy)).set_color(TEAL))), ReplacementTransform(VGroup(formulas_copy[0][1], formulas_copy[1][1]).copy(), Tex('6').move_to(self.cross_center(formulas_copy[0][1], dx_copy)).set_color(TEAL)), lag_ratio=0.5))\n        copies = []\n        dis = 8.5\n        copies.append(formulas[0][0].copy().shift(dis * RIGHT))\n        copies.append(formulas[1][0].copy().shift(dis * RIGHT))\n        fx_copy2 = fx.copy().next_to(copies[0], LEFT)\n        gx_copy2 = gx.copy().next_to(copies[1], LEFT)\n        third_equal = formulas[1][0].copy().shift(dis * RIGHT + DOWN)\n        fx_copy.remove(fx_copy[2])\n        hx_copy2 = VGroup(fx_copy, gx_copy).copy().next_to(third_equal, LEFT)\n        third_equal.next_to(hx_copy2, DOWN, buff=MED_LARGE_BUFF).shift(0.25 * LEFT)\n        _a = [fx, gx, formulas[0][0], formulas[1][0]]\n        _b = [fx_copy2, gx_copy2, *copies]\n        self.play(LaggedStart(*[Transform(__a.copy(), __b) for __a, __b in zip(_a, _b)], lag_ratio=0.5))\n        new_formulas = ['m_{1}x+b_{1}', 'm_{2}x+b_{2}', 'm_{1}(m_{2}x+b_{2})+b_{1}', 'm_{1}m_{2}x+m_{1}b_{2}+b_{1}']\n        new_formulas = VGroup(*[Tex(s, **self.tex_kwargs) for s in new_formulas])\n        self.play(LaggedStart(Write(new_formulas[0].next_to(copies[0])), Write(new_formulas[1].next_to(copies[1])), lag_ratio=0.3, run_time=2.5))\n        m1_copy = new_formulas[0][0].copy().next_to(third_equal)\n        brackets1 = hx_copy2[0][1].copy().next_to(m1_copy, buff=SMALL_BUFF / 1.5)\n        m2xb2 = new_formulas[1].copy().next_to(brackets1, buff=SMALL_BUFF / 2)\n        brackets2 = hx_copy2[0][2].copy().next_to(m2xb2, buff=SMALL_BUFF / 3)\n        plus_b1 = new_formulas[0][2:4].copy().next_to(brackets2, buff=SMALL_BUFF / 2)\n        self.play(LaggedStart(ReplacementTransform(formulas_copy[0][0].copy(), third_equal), ReplacementTransform(VGroup(fx_copy, gx_copy).copy(), hx_copy2), ReplacementTransform(new_formulas[0][0].copy(), m1_copy), lag_ratio=0.3))\n        self.play(ReplacementTransform(hx_copy2[0][1].copy(), brackets1))\n        self.play(ReplacementTransform(new_formulas[1].copy(), m2xb2))\n        self.play(ReplacementTransform(hx_copy2[0][2].copy(), brackets2))\n        self.play(ReplacementTransform(new_formulas[0][2:4].copy(), plus_b1))\n        fourth_equal = third_equal.copy().next_to(third_equal, DOWN, MED_LARGE_BUFF)\n        self.play(ReplacementTransform(third_equal.copy(), fourth_equal))\n        self.play(ReplacementTransform(m1_copy.copy(), (_j1 := m1_copy.copy().next_to(fourth_equal))))\n        self.play(ReplacementTransform(m2xb2[0:3].copy(), (_j2 := m2xb2[0:3].copy().next_to(_j1, buff=SMALL_BUFF))))\n        self.play(ReplacementTransform(m1_copy.copy(), (_j4 := m1_copy.copy().next_to(_j2, buff=SMALL_BUFF))), ReplacementTransform(m2xb2[3:].copy(), (_j5 := m2xb2[3:].copy().next_to(_j4, buff=SMALL_BUFF))))\n        self.play(ReplacementTransform(plus_b1.copy(), plus_b1.copy().next_to(_j5, buff=SMALL_BUFF)))\n        new_slope = VGroup(_j1, _j2[:1])\n        self.play(LaggedStart(*[ShowCreation(SurroundingRectangle(mob, color=GREEN_B)) for mob in (new_formulas[0][0], new_formulas[1][0], new_slope)], lag_ratio=0.2))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Visualize a weak acid-strong base titration curve along with graphs of the concentrations of the acid and its conjugate base, and the pOH."}, {"role": "assistant", "content": "from typing import Final\nfrom manimlib import *\nfrom tkinter import Tk, simpledialog\nfrom tkinter import messagebox\n\nclass WeakAcidStrongBase(Scene):\n\n    def construct(self, pKa: float=4.74, acid_volume: float=10.0, molarity_titrated: float=0.5, molarity_titrant: float=0.1, demo: bool=False) -> None:\n        fr: CameraFrame = self.camera.frame\n        fr.scale(2).shift(4 * UP + 6 * RIGHT)\n\n        def functionAcid(pKa, AMinus, HA, addedBase):\n            return pKa + math.log10((AMinus + addedBase) / (HA - addedBase))\n\n        def functionBase(pKb, B, BHPlus, addedAcid):\n            return 14 - (pKb + math.log10((B + addedAcid) / (BHPlus - addedAcid)))\n\n        def ice_table_WASB(molar_A_minus: float, ka: float, reverse: bool=True) -> float:\n            kb = 1 / ka if reverse else ka\n            c = -molar_A_minus * kb\n            x = (kb + math.sqrt(kb ** 2 - 4 * c)) / 2\n            return x\n\n        def calc_pH_WASB(pKa: float, strong_base_volume: float, strong_base_molarity: float, weak_acid_volume: float, weak_acid_molarity: float, reverse: bool=False) -> typing.Sequence[float]:\n            \"\"\" \n            Calculate pH for Weak Acid Strong Base\n            Const: pKa, both molarities, and weak acid volume\n            Changing: strong base volume\n            Extra arg: reverse to change it to Weak Base Strong Acid TODO\n            Returns: Tuple(pH, [A], [HA-], pOH)\n            \"\"\"\n            total_volume = weak_acid_volume + strong_base_volume\n            mole_base = strong_base_molarity * strong_base_volume\n            mole_acid = weak_acid_molarity * weak_acid_volume\n            mole_A_minus = 0\n            molarity_A_minus = mole_A_minus / total_volume\n            molarity_acid = mole_acid / total_volume\n            return_tuple = (molarity_acid, molarity_A_minus)\n            if mole_base == 0:\n                return (ice_table_WASB(mole_acid / total_volume, 10 ** (-pKa)), *(molarity_acid, molarity_A_minus))\n            elif mole_acid > mole_base:\n                mole_acid -= mole_base\n                mole_A_minus += mole_base\n                molarity_A_minus = mole_A_minus / total_volume\n                molarity_acid = mole_acid / total_volume\n            elif mole_acid == mole_base:\n                mole_acid -= mole_base\n                mole_A_minus += mole_base\n                molarity_A_minus = mole_A_minus / total_volume\n                molarity_acid = mole_acid / total_volume\n                return (14.0 + math.log10(ice_table_WASB(mole_base / total_volume, 10 ** (-pKa))), *(molarity_acid, molarity_A_minus))\n            elif mole_acid <= mole_base:\n                return (14.0 + math.log10((mole_base - mole_acid) / total_volume), *(0.0, mole_acid / total_volume))\n            return (pKa + math.log10(mole_A_minus / mole_acid), *(molarity_acid, molarity_A_minus))\n        equivlibrium_mL_for_base = molarity_titrated * acid_volume / molarity_titrant\n        titrated = equivlibrium_mL_for_base * 2\n        common_plane_config = dict(x_range=[0, titrated, titrated / 10], height=FRAME_HEIGHT * 1.6, width=FRAME_WIDTH * 1.6)\n        n_conf = {'y_axis_config': {'decimal_number_config': {'num_decimal_places': 3, 'font_size': 36}}}\n        plane = NumberPlane(**common_plane_config, y_range=[0, 14.0, 2.0]).scale(0.5).shift(2 * LEFT)\n        plane.add_coordinate_labels()\n        self.add(plane.get_x_axis_label('mL', direction=RIGHT), plane.get_y_axis_label('pH', direction=UP))\n        y_max = molarity_titrated * titrated / titrated\n        a_conentration_plane = NumberPlane(**common_plane_config, **n_conf, y_range=[0, y_max, y_max / 7.0]).scale(0.5).shift(2 * LEFT + 7.5 * UP)\n        a_conentration_plane.add_coordinate_labels()\n        a_conentration_plane.add(a_conentration_plane.get_x_axis_label('mL', direction=RIGHT), a_conentration_plane.get_y_axis_label('[A-](M)', direction=UP))\n        ha_concentration_plane = NumberPlane(**common_plane_config, **n_conf, y_range=[0, y_max, y_max / 7.0]).scale(0.5).shift(12.0 * RIGHT + 7.5 * UP)\n        ha_concentration_plane.add_coordinate_labels()\n        self.add(ha_concentration_plane.get_x_axis_label('mL(Base)', direction=UP), ha_concentration_plane.get_y_axis_label('[HA](M))', direction=UP))\n        oh_concentration_plane = NumberPlane(**common_plane_config, y_range=[0, 14, 2]).scale(0.5).shift(12.0 * RIGHT)\n        oh_concentration_plane.add_coordinate_labels()\n        self.add(oh_concentration_plane.get_x_axis_label('mL(Base)', direction=RIGHT), oh_concentration_plane.get_y_axis_label('pOH', direction=UP))\n        self.add(plane, a_conentration_plane, ha_concentration_plane, oh_concentration_plane)\n        graph = plane.get_graph(lambda x: calc_pH_WASB(pKa, x + 0.1, molarity_titrant, acid_volume, molarity_titrated)[0], use_smoothing=False, x_range=[0, titrated - 1])\n        a_conc_graph = a_conentration_plane.get_graph(lambda x: calc_pH_WASB(pKa, x + 0.1, molarity_titrant, acid_volume, molarity_titrated)[2], use_smoothing=False, x_range=[0, titrated - 1])\n        ha_conc_graph = ha_concentration_plane.get_graph(lambda x: calc_pH_WASB(pKa, x + 0.1, molarity_titrant, acid_volume, molarity_titrated)[1], use_smoothing=False, x_range=[0, titrated - 1])\n        oh_conc_graph = oh_concentration_plane.get_graph(lambda x: 14 - calc_pH_WASB(pKa, x + 0.1, molarity_titrant, acid_volume, molarity_titrated)[0], use_smoothing=False, x_range=[0, titrated - 1])\n        self.add(graph, a_conc_graph, ha_conc_graph, oh_conc_graph)\n        if demo:\n            self.wait(60)\n            sys.exit()"}]}
{"messages": [{"role": "user", "content": "Generate a titration curve animation for a weak base with a strong acid, showing pH, base concentration, conjugate acid concentration, and pOH."}, {"role": "assistant", "content": "from typing import Final\nfrom manimlib import *\nfrom tkinter import Tk, simpledialog\nfrom tkinter import messagebox\n\nclass WeakBaseStrongAcid(Scene):\n\n    def construct(self, pKb: float=4.74, base_volume: float=40.0, base_molarity: float=0.1, molarity_titrant: float=0.1, demo: bool=False) -> None:\n        fr: CameraFrame = self.camera.frame\n        fr.scale(2).shift(4 * UP + 6 * RIGHT)\n\n        def ice_table_WASB(molar_A_minus: float, kb: float, reverse: bool=False) -> float:\n            kb = 1 / kb if reverse else kb\n            c = -molar_A_minus * kb\n            x = (kb + math.sqrt(kb ** 2 - 4 * c)) / 2\n            return x\n\n        def calc_pH_WASB(pKb: float, strong_acid_volume: float, strong_acid_molarity: float, weak_base_volume: float, weak_base_molarity: float, reverse: bool=False) -> typing.Sequence[float]:\n            \"\"\" \n            Calculate pH for Weak Acid Strong Base\n            Const: pKa, both molarities, and weak acid volume\n            Changing: strong base volume\n            Extra arg: reverse to change it to Weak Base Strong Acid TODO\n            Returns: Tuple(pH, [A], [HA-], pOH)\n            \"\"\"\n            total_volume = weak_base_volume + strong_acid_volume\n            mole_base = weak_base_molarity * weak_base_volume\n            mole_acid = strong_acid_molarity * strong_acid_volume\n            mole_BH_plus = 0\n            molarity_BH_plus = mole_BH_plus / total_volume\n            molarity_base = mole_base / total_volume\n            if mole_base == 0:\n                return (ice_table_WASB(mole_acid, 10 ** (-pKb), False), *(molarity_base, molarity_BH_plus))\n            elif mole_acid < mole_base:\n                mole_base -= mole_acid\n                mole_BH_plus += mole_acid\n                molarity_BH_plus = mole_BH_plus / total_volume\n                molarity_base = mole_base / total_volume\n            elif mole_acid == mole_base:\n                mole_base -= mole_acid\n                mole_BH_plus += mole_base\n                molarity_BH_plus = mole_BH_plus / total_volume\n                molarity_base = mole_base / total_volume\n                return (14.0 + math.log10(ice_table_WASB(mole_base, 10 ** (-pKb))), *(molarity_base, molarity_BH_plus))\n            elif mole_acid >= mole_base:\n                return (-math.log10((-mole_base + mole_acid) / total_volume), *(0.0, mole_base / total_volume))\n            return (14 - pKb - math.log10(mole_BH_plus / mole_base), *(molarity_base, molarity_BH_plus))\n        equivlibrium_mL_for_base = base_molarity * base_volume / molarity_titrant\n        titrated = equivlibrium_mL_for_base * 2\n        common_plane_config = dict(x_range=[0, titrated, titrated / 10], height=FRAME_HEIGHT * 1.6, width=FRAME_WIDTH * 1.6)\n        n_conf = {'y_axis_config': {'decimal_number_config': {'num_decimal_places': 3, 'font_size': 36}}}\n        plane = NumberPlane(**common_plane_config, y_range=[0, 14.0, 2.0]).scale(0.5).shift(2 * LEFT)\n        plane.add_coordinate_labels()\n        self.add(plane.get_x_axis_label('mL', direction=RIGHT), plane.get_y_axis_label('pH', direction=UP))\n        y_max = base_molarity * titrated / titrated\n        b_conentration_plane = NumberPlane(**common_plane_config, **n_conf, y_range=[0, y_max, y_max / 7.0]).scale(0.5).shift(2 * LEFT + 7.5 * UP)\n        b_conentration_plane.add_coordinate_labels()\n        b_conentration_plane.add(b_conentration_plane.get_x_axis_label('mL(Acid)', direction=RIGHT), b_conentration_plane.get_y_axis_label('[B](M)', direction=UP))\n        bh_concentration_plane = NumberPlane(**common_plane_config, **n_conf, y_range=[0, y_max, y_max / 7.0]).scale(0.5).shift(12.0 * RIGHT + 7.5 * UP)\n        bh_concentration_plane.add_coordinate_labels()\n        self.add(bh_concentration_plane.get_x_axis_label('mL(Acid)', direction=UP), bh_concentration_plane.get_y_axis_label('[BH+](M))', direction=UP))\n        oh_concentration_plane = NumberPlane(**common_plane_config, y_range=[0, 14, 2]).scale(0.5).shift(12.0 * RIGHT)\n        oh_concentration_plane.add_coordinate_labels()\n        self.add(oh_concentration_plane.get_x_axis_label('mL', direction=RIGHT), oh_concentration_plane.get_y_axis_label('pOH', direction=UP))\n        self.add(plane, b_conentration_plane, bh_concentration_plane, oh_concentration_plane)\n        graph = plane.get_graph(lambda x: calc_pH_WASB(pKb, x + 0.1, molarity_titrant, base_volume, base_molarity)[0], use_smoothing=False, x_range=[0, titrated - 1])\n        b_conc_graph = b_conentration_plane.get_graph(lambda x: calc_pH_WASB(pKb, x + 0.1, molarity_titrant, base_volume, base_molarity)[1], use_smoothing=False, x_range=[0, titrated - 1])\n        bh_conc_graph = bh_concentration_plane.get_graph(lambda x: calc_pH_WASB(pKb, x + 0.1, molarity_titrant, base_volume, base_molarity)[2], use_smoothing=False, x_range=[0, titrated - 1])\n        oh_conc_graph = oh_concentration_plane.get_graph(lambda x: 14 - calc_pH_WASB(pKb, x + 0.1, molarity_titrant, base_volume, base_molarity)[0], use_smoothing=False, x_range=[0, titrated - 1])\n        self.add(graph, b_conc_graph, bh_conc_graph, oh_conc_graph)\n        if demo:\n            self.wait(60)\n            sys.exit()"}]}
{"messages": [{"role": "user", "content": "Generate a titration curve animation for a strong acid and strong base, displaying both pH and pOH axes."}, {"role": "assistant", "content": "from typing import Final\nfrom manimlib import *\nfrom tkinter import Tk, simpledialog\nfrom tkinter import messagebox\n\nclass StrongAcidStrongBase(Scene):\n\n    def construct(self, vTitrated: float=50, mTitrant: float=1, mTitrated: float=1, tTitrantIsAcid: bool=True, demo: bool=False):\n        fr: CameraFrame = self.camera.frame\n        fr.scale(2).shift(4 * UP + 6 * RIGHT)\n\n        def calc_pH_SS(titrant_volume: float, titrant_molarity: float, titrated_volume: float, titrated_molarity: float, tTitrantIsAcid: bool=True) -> float:\n            \"\"\" \n            Calculate pH for Strong Acid Strong Base\n            x: titrant_volume\n            Const: titrant_molarity, titrated_volume, titrated_molarity\n            Changing: strong base volume\n            \"\"\"\n            total_volume = titrant_volume + titrated_volume\n            mole_titrant = titrant_volume * titrant_molarity\n            mole_titrated = titrated_volume * titrated_molarity\n            mole_acid = 0\n            mole_base = 0\n            if tTitrantIsAcid:\n                mole_acid = mole_titrant\n                mole_base = mole_titrated\n            else:\n                mole_base = mole_titrant\n                mole_acid = mole_titrated\n            if mole_acid > mole_base:\n                return -math.log10((mole_acid - mole_base) / total_volume)\n            elif mole_acid == mole_base:\n                return 7\n            elif mole_acid < mole_base:\n                return 14 + math.log10((mole_base - mole_acid) / total_volume)\n        equivlibrium_mL_for_base = mTitrated * vTitrated / mTitrant\n        titrated = equivlibrium_mL_for_base * 2\n        pKb = 4.74\n        common_plane_config = dict(x_range=[0, titrated, titrated / 10], height=FRAME_HEIGHT * 1.6, width=FRAME_WIDTH * 1.6)\n        n_conf = {'y_axis_config': {'decimal_number_config': {'num_decimal_places': 3, 'font_size': 36}}}\n        label_type = '(Acid)' if tTitrantIsAcid else '(Base)'\n        plane = NumberPlane(**common_plane_config, y_range=[0, 14.0, 2.0]).scale(0.5).shift(2 * LEFT)\n        plane.add_coordinate_labels()\n        self.add(plane.get_x_axis_label(f'mL{label_type}', direction=RIGHT), plane.get_y_axis_label('pH', direction=UP))\n        oh_concentration_plane = NumberPlane(**common_plane_config, y_range=[0, 14, 2]).scale(0.5).shift(12.0 * RIGHT)\n        oh_concentration_plane.add_coordinate_labels()\n        self.add(oh_concentration_plane.get_x_axis_label(f'mL{label_type}', direction=RIGHT), oh_concentration_plane.get_y_axis_label('pOH', direction=UP))\n        self.add(plane, oh_concentration_plane)\n        graph = plane.get_graph(lambda x: calc_pH_SS(x + 0.1, mTitrant, vTitrated, mTitrated, tTitrantIsAcid), use_smoothing=False, x_range=[0, titrated - 1])\n        oh_conc_graph = oh_concentration_plane.get_graph(lambda x: 14 - calc_pH_SS(x + 0.1, mTitrant, vTitrated, mTitrated, tTitrantIsAcid), use_smoothing=False, x_range=[0, titrated - 1])\n        self.add(graph, oh_conc_graph)\n        if demo:\n            self.wait(60)\n            sys.exit()"}]}
{"messages": [{"role": "user", "content": "Animate a titration curve for a weak acid strong base titration, displaying the pH, [A-], [HA], and pOH as functions of added base volume."}, {"role": "assistant", "content": "from typing import Final\nfrom manimlib import *\nfrom tkinter import Tk, simpledialog\nfrom tkinter import messagebox\n\nclass WeakAcidStrongBase(Scene):\n\n    def construct(self, pKa: float=4.74, acid_volume: float=10.0, molarity_titrated: float=0.5, molarity_titrant: float=0.1, demo: bool=False) -> None:\n        fr: CameraFrame = self.camera.frame\n        fr.scale(2).shift(4 * UP + 6 * RIGHT)\n\n        def functionAcid(pKa, AMinus, HA, addedBase):\n            return pKa + math.log10((AMinus + addedBase) / (HA - addedBase))\n\n        def functionBase(pKb, B, BHPlus, addedAcid):\n            return 14 - (pKb + math.log10((B + addedAcid) / (BHPlus - addedAcid)))\n\n        def ice_table_WASB(molar_A_minus: float, ka: float, reverse: bool=True) -> float:\n            kb = 1 / ka if reverse else ka\n            c = -molar_A_minus * kb\n            x = (kb + math.sqrt(kb ** 2 - 4 * c)) / 2\n            return x\n\n        def calc_pH_WASB(pKa: float, strong_base_volume: float, strong_base_molarity: float, weak_acid_volume: float, weak_acid_molarity: float, reverse: bool=False) -> typing.Sequence[float]:\n            \"\"\" \n            Calculate pH for Weak Acid Strong Base\n            Const: pKa, both molarities, and weak acid volume\n            Changing: strong base volume\n            Extra arg: reverse to change it to Weak Base Strong Acid TODO\n            Returns: Tuple(pH, [A], [HA-], pOH)\n            \"\"\"\n            total_volume = weak_acid_volume + strong_base_volume\n            mole_base = strong_base_molarity * strong_base_volume\n            mole_acid = weak_acid_molarity * weak_acid_volume\n            mole_A_minus = 0\n            molarity_A_minus = mole_A_minus / total_volume\n            molarity_acid = mole_acid / total_volume\n            return_tuple = (molarity_acid, molarity_A_minus)\n            if mole_base == 0:\n                return (ice_table_WASB(mole_acid / total_volume, 10 ** (-pKa)), *(molarity_acid, molarity_A_minus))\n            elif mole_acid > mole_base:\n                mole_acid -= mole_base\n                mole_A_minus += mole_base\n                molarity_A_minus = mole_A_minus / total_volume\n                molarity_acid = mole_acid / total_volume\n            elif mole_acid == mole_base:\n                mole_acid -= mole_base\n                mole_A_minus += mole_base\n                molarity_A_minus = mole_A_minus / total_volume\n                molarity_acid = mole_acid / total_volume\n                return (14.0 + math.log10(ice_table_WASB(mole_base / total_volume, 10 ** (-pKa))), *(molarity_acid, molarity_A_minus))\n            elif mole_acid <= mole_base:\n                return (14.0 + math.log10((mole_base - mole_acid) / total_volume), *(0.0, mole_acid / total_volume))\n            return (pKa + math.log10(mole_A_minus / mole_acid), *(molarity_acid, molarity_A_minus))\n        equivlibrium_mL_for_base = molarity_titrated * acid_volume / molarity_titrant\n        titrated = equivlibrium_mL_for_base * 2\n        common_plane_config = dict(x_range=[0, titrated, titrated / 10], height=FRAME_HEIGHT * 1.6, width=FRAME_WIDTH * 1.6)\n        n_conf = {'y_axis_config': {'decimal_number_config': {'num_decimal_places': 3, 'font_size': 36}}}\n        plane = NumberPlane(**common_plane_config, y_range=[0, 14.0, 2.0]).scale(0.5).shift(0.5 * LEFT)\n        plane.add_coordinate_labels()\n        self.add(plane.get_x_axis_label('mL', direction=RIGHT), plane.get_y_axis_label('pH', direction=UP))\n        y_max = molarity_titrated * titrated / titrated\n        a_conentration_plane = NumberPlane(**common_plane_config, **n_conf, y_range=[0, y_max, y_max / 7.0]).scale(0.5).shift(0.5 * LEFT + 7.5 * UP)\n        a_conentration_plane.add_coordinate_labels()\n        a_conentration_plane.add(a_conentration_plane.get_x_axis_label('mL', direction=RIGHT), a_conentration_plane.get_y_axis_label('[A-](M)', direction=UP))\n        ha_concentration_plane = NumberPlane(**common_plane_config, **n_conf, y_range=[0, y_max, y_max / 7.0]).scale(0.5).shift(13.0 * RIGHT + 7.5 * UP)\n        ha_concentration_plane.add_coordinate_labels()\n        self.add(ha_concentration_plane.get_x_axis_label('mL', direction=UP), ha_concentration_plane.get_y_axis_label('[HA](M))', direction=UP))\n        oh_concentration_plane = NumberPlane(**common_plane_config, y_range=[0, 14, 2]).scale(0.5).shift(13.0 * RIGHT)\n        oh_concentration_plane.add_coordinate_labels()\n        self.add(oh_concentration_plane.get_x_axis_label('mL', direction=RIGHT), oh_concentration_plane.get_y_axis_label('pOH', direction=UP))\n        self.add(plane, a_conentration_plane, ha_concentration_plane, oh_concentration_plane)\n        graph = plane.get_graph(lambda x: calc_pH_WASB(pKa, x + 0.1, molarity_titrant, acid_volume, molarity_titrated)[0], use_smoothing=False, x_range=[0, titrated - 1])\n        a_conc_graph = a_conentration_plane.get_graph(lambda x: calc_pH_WASB(pKa, x + 0.1, molarity_titrant, acid_volume, molarity_titrated)[2], use_smoothing=False, x_range=[0, titrated - 1])\n        ha_conc_graph = ha_concentration_plane.get_graph(lambda x: calc_pH_WASB(pKa, x + 0.1, molarity_titrant, acid_volume, molarity_titrated)[1], use_smoothing=False, x_range=[0, titrated - 1])\n        oh_conc_graph = oh_concentration_plane.get_graph(lambda x: 14 - calc_pH_WASB(pKa, x + 0.1, molarity_titrant, acid_volume, molarity_titrated)[0], use_smoothing=False, x_range=[0, titrated - 1])\n        self.add(graph, a_conc_graph, ha_conc_graph, oh_conc_graph)\n        if demo:\n            self.wait(60)\n            sys.exit()"}]}
{"messages": [{"role": "user", "content": "Visualize the pH titration curve of a weak base with a strong acid and its corresponding concentration changes."}, {"role": "assistant", "content": "from typing import Final\nfrom manimlib import *\nfrom tkinter import Tk, simpledialog\nfrom tkinter import messagebox\n\nclass WeakBaseStrongAcid(Scene):\n\n    def construct(self, pKb: float=4.74, base_volume: float=40.0, base_molarity: float=0.1, molarity_titrant: float=0.1, demo: bool=False) -> None:\n        fr: CameraFrame = self.camera.frame\n        fr.scale(2).shift(4 * UP + 6 * RIGHT)\n\n        def ice_table_WASB(molar_A_minus: float, kb: float, reverse: bool=False) -> float:\n            kb = 1 / kb if reverse else kb\n            c = -molar_A_minus * kb\n            x = (kb + math.sqrt(kb ** 2 - 4 * c)) / 2\n            return x\n\n        def calc_pH_WASB(pKb: float, strong_acid_volume: float, strong_acid_molarity: float, weak_base_volume: float, weak_base_molarity: float, reverse: bool=False) -> typing.Sequence[float]:\n            \"\"\" \n            Calculate pH for Weak Acid Strong Base\n            Const: pKa, both molarities, and weak acid volume\n            Changing: strong base volume\n            Extra arg: reverse to change it to Weak Base Strong Acid TODO\n            Returns: Tuple(pH, [A], [HA-], pOH)\n            \"\"\"\n            total_volume = weak_base_volume + strong_acid_volume\n            mole_base = weak_base_molarity * weak_base_volume\n            mole_acid = strong_acid_molarity * strong_acid_volume\n            mole_BH_plus = 0\n            molarity_BH_plus = mole_BH_plus / total_volume\n            molarity_base = mole_base / total_volume\n            if mole_base == 0:\n                return (ice_table_WASB(mole_acid, 10 ** (-pKb), False), *(molarity_base, molarity_BH_plus))\n            elif mole_acid < mole_base:\n                mole_base -= mole_acid\n                mole_BH_plus += mole_acid\n                molarity_BH_plus = mole_BH_plus / total_volume\n                molarity_base = mole_base / total_volume\n            elif mole_acid == mole_base:\n                mole_base -= mole_acid\n                mole_BH_plus += mole_base\n                molarity_BH_plus = mole_BH_plus / total_volume\n                molarity_base = mole_base / total_volume\n                return (14.0 + math.log10(ice_table_WASB(mole_base, 10 ** (-pKb))), *(molarity_base, molarity_BH_plus))\n            elif mole_acid >= mole_base:\n                return (-math.log10((-mole_base + mole_acid) / total_volume), *(0.0, mole_base / total_volume))\n            return (14 - pKb - math.log10(mole_BH_plus / mole_base), *(molarity_base, molarity_BH_plus))\n        equivlibrium_mL_for_base = base_molarity * base_volume / molarity_titrant\n        titrated = equivlibrium_mL_for_base * 2\n        common_plane_config = dict(x_range=[0, titrated, titrated / 10], height=FRAME_HEIGHT * 1.6, width=FRAME_WIDTH * 1.6)\n        n_conf = {'y_axis_config': {'decimal_number_config': {'num_decimal_places': 3, 'font_size': 36}}}\n        plane = NumberPlane(**common_plane_config, y_range=[0, 14.0, 2.0]).scale(0.5).shift(0.5 * LEFT)\n        plane.add_coordinate_labels()\n        self.add(plane.get_x_axis_label('mL', direction=RIGHT), plane.get_y_axis_label('pH', direction=UP))\n        y_max = base_molarity * titrated / titrated\n        b_conentration_plane = NumberPlane(**common_plane_config, **n_conf, y_range=[0, y_max, y_max / 7.0]).scale(0.5).shift(0.5 * LEFT + 7.5 * UP)\n        b_conentration_plane.add_coordinate_labels()\n        b_conentration_plane.add(b_conentration_plane.get_x_axis_label('mL', direction=RIGHT), b_conentration_plane.get_y_axis_label('[B](M)', direction=UP))\n        bh_concentration_plane = NumberPlane(**common_plane_config, **n_conf, y_range=[0, y_max, y_max / 7.0]).scale(0.5).shift(13.0 * RIGHT + 7.5 * UP)\n        bh_concentration_plane.add_coordinate_labels()\n        self.add(bh_concentration_plane.get_x_axis_label('mL', direction=UP), bh_concentration_plane.get_y_axis_label('[BH+](M))', direction=UP))\n        oh_concentration_plane = NumberPlane(**common_plane_config, y_range=[0, 14, 2]).scale(0.5).shift(13.0 * RIGHT)\n        oh_concentration_plane.add_coordinate_labels()\n        self.add(oh_concentration_plane.get_x_axis_label('mL', direction=RIGHT), oh_concentration_plane.get_y_axis_label('pOH', direction=UP))\n        self.add(plane, b_conentration_plane, bh_concentration_plane, oh_concentration_plane)\n        graph = plane.get_graph(lambda x: calc_pH_WASB(pKb, x + 0.1, molarity_titrant, base_volume, base_molarity)[0], use_smoothing=False, x_range=[0, titrated - 1])\n        b_conc_graph = b_conentration_plane.get_graph(lambda x: calc_pH_WASB(pKb, x + 0.1, molarity_titrant, base_volume, base_molarity)[1], use_smoothing=False, x_range=[0, titrated - 1])\n        bh_conc_graph = bh_concentration_plane.get_graph(lambda x: calc_pH_WASB(pKb, x + 0.1, molarity_titrant, base_volume, base_molarity)[2], use_smoothing=False, x_range=[0, titrated - 1])\n        oh_conc_graph = oh_concentration_plane.get_graph(lambda x: 14 - calc_pH_WASB(pKb, x + 0.1, molarity_titrant, base_volume, base_molarity)[0], use_smoothing=False, x_range=[0, titrated - 1])\n        self.add(graph, b_conc_graph, bh_conc_graph, oh_conc_graph)\n        if demo:\n            self.wait(60)\n            sys.exit()"}]}
{"messages": [{"role": "user", "content": "Generate a pH titration curve for a weak base being titrated with a strong acid, also showing the corresponding pOH curve."}, {"role": "assistant", "content": "from typing import Final\nfrom manimlib import *\nfrom tkinter import Tk, simpledialog\nfrom tkinter import messagebox\n\nclass StrongAcidStrongBase(Scene):\n\n    def construct(self, demo: bool=False):\n        raise Exception\n        fr: CameraFrame = self.camera.frame\n        fr.scale(2).shift(4 * UP + 6 * RIGHT)\n\n        def calc_pH_WASB(pKb: float, strong_acid_volume: float, strong_acid_molarity: float, weak_base_volume: float, weak_base_molarity: float, reverse: bool=False) -> typing.Sequence[float]:\n            \"\"\" \n            Calculate pH for Weak Acid Strong Base\n            Const: pKa, both molarities, and weak acid volume\n            Changing: strong base volume\n            Extra arg: reverse to change it to Weak Base Strong Acid TODO\n            Returns: Tuple(pH, [A], [HA-], pOH)\n            \"\"\"\n            total_volume = weak_base_volume + strong_acid_volume\n            mole_base = weak_base_molarity * weak_base_volume\n            mole_acid = strong_acid_molarity * strong_acid_volume\n            mole_BH_plus = 0\n            molarity_BH_plus = mole_BH_plus / total_volume\n            molarity_base = mole_base / total_volume\n            if mole_base == 0:\n                return (ice_table_WASB(mole_acid, 10 ** (-pKb), False), *(molarity_base, molarity_BH_plus))\n            elif mole_acid < mole_base:\n                mole_base -= mole_acid\n                mole_BH_plus += mole_acid\n                molarity_BH_plus = mole_BH_plus / total_volume\n                molarity_base = mole_base / total_volume\n            elif mole_acid == mole_base:\n                mole_base -= mole_acid\n                mole_BH_plus += mole_base\n                molarity_BH_plus = mole_BH_plus / total_volume\n                molarity_base = mole_base / total_volume\n                return (14.0 + math.log10(ice_table_WASB(mole_base, 10 ** (-pKb))), *(molarity_base, molarity_BH_plus))\n            elif mole_acid >= mole_base:\n                return (-math.log10((-mole_base + mole_acid) / total_volume), *(0.0, mole_base / total_volume))\n            return (14 - pKb - math.log10(mole_BH_plus / mole_base), *(molarity_base, molarity_BH_plus))\n        base_volume = 40.0\n        base_molarity = 0.1\n        molarity_titrant = 0.1\n        equivlibrium_mL_for_base = base_molarity * base_volume / molarity_titrant\n        titrated = equivlibrium_mL_for_base * 2\n        pKb = 4.74\n        common_plane_config = dict(x_range=[0, titrated, titrated / 10], height=FRAME_HEIGHT * 1.6, width=FRAME_WIDTH * 1.6)\n        n_conf = {'y_axis_config': {'decimal_number_config': {'num_decimal_places': 3, 'font_size': 36}}}\n        plane = NumberPlane(**common_plane_config, y_range=[0, 14.0, 2.0]).scale(0.5).shift(0.5 * LEFT)\n        plane.add_coordinate_labels()\n        self.add(plane.get_x_axis_label('mL', direction=RIGHT), plane.get_y_axis_label('pH', direction=UP))\n        oh_concentration_plane = NumberPlane(**common_plane_config, y_range=[0, 14, 2]).scale(0.5).shift(13.0 * RIGHT)\n        oh_concentration_plane.add_coordinate_labels()\n        self.add(oh_concentration_plane.get_x_axis_label('mL', direction=RIGHT), oh_concentration_plane.get_y_axis_label('pOH', direction=UP))\n        self.add(plane, b_conentration_plane, bh_concentration_plane, oh_concentration_plane)\n        graph = plane.get_graph(lambda x: calc_pH_WASB(pKb, x + 0.1, molarity_titrant, base_volume, base_molarity)[0], use_smoothing=False, x_range=[0, titrated - 1])\n        oh_conc_graph = oh_concentration_plane.get_graph(lambda x: 14 - calc_pH_WASB(pKb, x + 0.1, molarity_titrant, base_volume, base_molarity)[0], use_smoothing=False, x_range=[0, titrated - 1])\n        self.add(graph, oh_conc_graph)\n        if demo:\n            self.wait(60)\n            sys.exit()"}]}
{"messages": [{"role": "user", "content": "Simulate two squares falling under gravity and interacting with a ground plane."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport pymunk\n\nclass PhysicTest(Scene):\n\n    def construct(self):\n        space = pymunk.Space()\n        space.gravity = (0, -9820)\n        ground = space.static_body\n        grd_seg = pymunk.Segment(ground, (-10000, -2000), (10000, -2000), 0)\n        grd_seg.friction = 0.8\n        space.add(grd_seg)\n        mass = 10\n        size = (1000, 1000)\n        moment = pymunk.moment_for_box(mass, size)\n        body = pymunk.Body(mass, moment)\n        body.angle = 0.1\n        body.position = (0, 3000)\n        box = pymunk.Poly.create_box(body, size)\n        box.elasticity = 0\n        box.friction = 0.5\n        space.add(body, box)\n        shape = Square()\n        shape.stretch_to_fit_height(1)\n        shape.stretch_to_fit_width(1)\n        body2 = pymunk.Body(mass, moment)\n        body2.angle = -0.1\n        body2.position = (800, 4500)\n        box2 = pymunk.Poly.create_box(body2, size)\n        box2.elasticity = 0\n        box2.friction = 0.5\n        space.add(body2, box2)\n        shape = Square()\n        shape.stretch_to_fit_height(1)\n        shape.stretch_to_fit_width(1)\n        shape.set_fill(DARK_BLUE, opacity=1)\n        shape2 = Square()\n        shape2.stretch_to_fit_height(1)\n        shape2.stretch_to_fit_width(1)\n        shape2.set_fill(DARK_BROWN, opacity=1)\n        self.add(shape)\n        self.add(shape2)\n        self.add(Line(FRAME_X_RADIUS * LEFT, FRAME_X_RADIUS * RIGHT).shift(2 * DOWN))\n        run_time = 5\n        last_t = 0\n        shape_cons = []\n        shape2_cons = []\n        step = 1 / self.camera.frame_rate\n        for t in range(int(run_time / step)):\n            space.step(step)\n            shape_cons.append((body.position / 1000, body.angle))\n            shape2_cons.append((body2.position / 1000, body2.angle))\n        self.play(PhysicsBody(shape, shape_cons), PhysicsBody(shape2, shape2_cons), run_time=run_time)"}]}
{"messages": [{"role": "user", "content": "Illustrate the Pythagorean theorem by constructing a visual proof involving squares and triangles."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Pythagorean(Scene):\n    CONFIG = {'camera_config': {'background_color': WHITE}}\n\n    def construct(self):\n        outerSquare = Square().scale(2)\n        innerSquare = Square().scale(0.75).rotate(np.pi / 3)\n        outerSquare.set_color(PURPLE)\n        outerSquare.set_fill(ORANGE, opacity=0.5)\n        innerSquare.set_color(BLUE)\n        innerSquare.set_fill(ORANGE, opacity=1)\n        trgs = []\n        for i in range(4):\n            p = Polygon(innerSquare.points[i * 4 - 1], outerSquare.points[(i - 1) % 4 * 4 - 1], outerSquare.points[(i + 2) % 4 * 4 - 1])\n            p.set_color(BLACK)\n            p.set_fill(RED, opacity=1)\n            p.round_corners(radius=0.005)\n            trgs.append(p)\n        first = trgs[0]\n        edges = [TexMobject(e).set_color(BLACK) for e in ['a', 'b', 'c']]\n        edges[0].next_to(first, LEFT).shift([0.5, 0, 0])\n        edges[1].next_to(first, RIGHT).shift([-1.5, 0.5, 0])\n        edges[2].next_to(first, DOWN)\n        self.play(DrawBorderThenFill(first))\n        self.play(*[Write(e) for e in edges])\n        self.wait()\n        self.play(*[FadeOut(e) for e in edges[0:2]])\n        self.play(*[ReplacementTransform(first.copy(), t) for t in trgs[1:4]])\n        self.play(ShowCreation(innerSquare))\n        formula = TexMobject('c^2', '=', 'a^2+b^2').set_color(BLACK)\n        formula.to_edge(UP)\n        self.play(ShowCreationThenFadeOut(outerSquare))\n        self.play(Transform(edges[2].copy(), formula[0]), Write(formula[1]))\n        trig_area = TexMobject('\\\\frac12 ab').set_color(BLACK)\n        trig_area.next_to(outerSquare, LEFT)\n        self.play(*[WiggleOutThenIn(t) for t in trgs])\n        self.play(Write(trig_area))\n        inner_area = TexMobject('(b-a)^2').set_color(BLACK)\n        self.play(WiggleOutThenIn(innerSquare))\n        self.play(Write(inner_area))\n        add_area = TexMobject('4 \\\\times', '\\\\frac12 ab', '+', '(b-a)^2').set_color(BLACK)\n        add_area.next_to(formula[1], RIGHT, buff=0.2)\n        inner_copy = inner_area.copy()\n        trig_copy = trig_area.copy()\n        self.play(Write(add_area[0]), ApplyMethod(trig_copy.move_to, add_area[1].get_center()), Write(add_area[2]), ApplyMethod(inner_copy.move_to, add_area[3].get_center()))\n        self.add(add_area[3])\n        self.remove(inner_copy)\n        self.add(add_area[1])\n        self.remove(trig_copy)\n        self.wait()\n        simplify = TexMobject('2', 'ab', '+', '(b-a)^2').set_color(BLACK)\n        simplify.next_to(formula[1], RIGHT, buff=0.2)\n        self.play(ReplacementTransform(add_area, simplify))\n        self.wait()\n        expand = TexMobject('2', 'ab', '+', 'b^2-2ab+a^2').set_color(BLACK)\n        expand.next_to(formula[1], RIGHT, buff=0.2)\n        self.play(ReplacementTransform(simplify, expand))\n        self.wait()\n        self.play(Transform(expand, formula[-1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the Fourier series decomposition of a path by animating rotating vectors and their sum."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass FourierCirclesScene(Scene):\n    CONFIG = {'n_vectors': 10, 'big_radius': 2, 'colors': [BLUE_D, BLUE_C, BLUE_E, GREY_BROWN], 'circle_style': {'stroke_width': 2}, 'vector_config': {'buff': 0, 'max_tip_length_to_length_ratio': 0.35, 'tip_length': 0.15, 'max_stroke_width_to_length_ratio': 10, 'stroke_width': 2}, 'circle_config': {'stroke_width': 1}, 'base_frequency': 1, 'slow_factor': 0.25, 'center_point': ORIGIN, 'parametric_function_step_size': 0.001, 'drawn_path_color': YELLOW, 'drawn_path_stroke_width': 2}\n\n    def setup(self):\n        self.slow_factor_tracker = ValueTracker(self.slow_factor)\n        self.vector_clock = ValueTracker(0)\n        self.vector_clock.add_updater(lambda m, dt: m.increment_value(self.get_slow_factor() * dt))\n        self.add(self.vector_clock)\n\n    def get_slow_factor(self):\n        return self.slow_factor_tracker.get_value()\n\n    def get_vector_time(self):\n        return self.vector_clock.get_value()\n\n    def get_freqs(self):\n        n = self.n_vectors\n        all_freqs = list(range(n // 2, -n // 2, -1))\n        all_freqs.sort(key=abs)\n        return all_freqs\n\n    def get_coefficients(self):\n        return [complex(0) for x in range(self.n_vectors)]\n\n    def get_color_iterator(self):\n        return it.cycle(self.colors)\n\n    def get_rotating_vectors(self, freqs=None, coefficients=None):\n        vectors = VGroup()\n        self.center_tracker = VectorizedPoint(self.center_point)\n        if freqs is None:\n            freqs = self.get_freqs()\n        if coefficients is None:\n            coefficients = self.get_coefficients()\n        last_vector = None\n        for freq, coefficient in zip(freqs, coefficients):\n            if last_vector:\n                center_func = last_vector.get_end\n            else:\n                center_func = self.center_tracker.get_location\n            vector = self.get_rotating_vector(coefficient=coefficient, freq=freq, center_func=center_func)\n            vectors.add(vector)\n            last_vector = vector\n        return vectors\n\n    def get_rotating_vector(self, coefficient, freq, center_func):\n        vector = Vector(RIGHT, **self.vector_config)\n        vector.scale(abs(coefficient))\n        if abs(coefficient) == 0:\n            phase = 0\n        else:\n            phase = np.log(coefficient).imag\n        vector.rotate(phase, about_point=ORIGIN)\n        vector.freq = freq\n        vector.coefficient = coefficient\n        vector.center_func = center_func\n        vector.add_updater(self.update_vector)\n        return vector\n\n    def update_vector(self, vector, dt):\n        time = self.get_vector_time()\n        coef = vector.coefficient\n        freq = vector.freq\n        phase = np.log(coef).imag\n        vector.set_length(abs(coef))\n        vector.set_angle(phase + time * freq * TAU)\n        vector.shift(vector.center_func() - vector.get_start())\n        return vector\n\n    def get_circles(self, vectors):\n        return VGroup(*[self.get_circle(vector, color=color) for vector, color in zip(vectors, self.get_color_iterator())])\n\n    def get_circle(self, vector, color=BLUE):\n        circle = Circle(color=color, **self.circle_config)\n        circle.center_func = vector.get_start\n        circle.radius_func = vector.get_length\n        circle.add_updater(self.update_circle)\n        return circle\n\n    def update_circle(self, circle):\n        circle.set_width(2 * circle.radius_func())\n        circle.move_to(circle.center_func())\n        return circle\n\n    def get_vector_sum_path(self, vectors, color=YELLOW):\n        coefs = [v.coefficient for v in vectors]\n        freqs = [v.freq for v in vectors]\n        center = vectors[0].get_start()\n        path = ParametricFunction(lambda t: center + reduce(op.add, [complex_to_R3(coef * np.exp(TAU * 1j * freq * t)) for coef, freq in zip(coefs, freqs)]), t_min=0, t_max=1, color=color, step_size=self.parametric_function_step_size)\n        return path\n\n    def get_drawn_path_alpha(self):\n        return self.get_vector_time()\n\n    def get_drawn_path(self, vectors, stroke_width=None, **kwargs):\n        if stroke_width is None:\n            stroke_width = self.drawn_path_stroke_width\n        path = self.get_vector_sum_path(vectors, **kwargs)\n        broken_path = CurvesAsSubmobjects(path)\n        broken_path.curr_time = 0\n\n        def update_path(path, dt):\n            alpha = self.get_drawn_path_alpha()\n            n_curves = len(path)\n            for a, sp in zip(np.linspace(0, 1, n_curves), path):\n                b = alpha - a\n                if b < 0:\n                    width = 0\n                else:\n                    width = stroke_width * (1 - b % 1)\n                sp.set_stroke(width=width)\n            path.curr_time += dt\n            return path\n        broken_path.set_color(self.drawn_path_color)\n        broken_path.add_updater(update_path)\n        return broken_path\n\n    def get_y_component_wave(self, vectors, left_x=1, color=PINK, n_copies=2, right_shift_rate=5):\n        path = self.get_vector_sum_path(vectors)\n        wave = ParametricFunction(lambda t: op.add(right_shift_rate * t * LEFT, path.function(t)[1] * UP), t_min=path.t_min, t_max=path.t_max, color=color)\n        wave_copies = VGroup(*[wave.copy() for x in range(n_copies)])\n        wave_copies.arrange(RIGHT, buff=0)\n        top_point = wave_copies.get_top()\n        wave.creation = ShowCreation(wave, run_time=1 / self.get_slow_factor(), rate_func=linear)\n        cycle_animation(wave.creation)\n        wave.add_updater(lambda m: m.shift((m.get_left()[0] - left_x) * LEFT))\n\n        def update_wave_copies(wcs):\n            index = int(wave.creation.total_time * self.get_slow_factor())\n            wcs[:index].match_style(wave)\n            wcs[index:].set_stroke(width=0)\n            wcs.next_to(wave, RIGHT, buff=0)\n            wcs.align_to(top_point, UP)\n        wave_copies.add_updater(update_wave_copies)\n        return VGroup(wave, wave_copies)\n\n    def get_wave_y_line(self, vectors, wave):\n        return DashedLine(vectors[-1].get_end(), wave[0].get_end(), stroke_width=1, dash_length=DEFAULT_DASH_LENGTH * 0.5)\n\n    def get_coefficients_of_path(self, path, n_samples=10000, freqs=None):\n        if freqs is None:\n            freqs = self.get_freqs()\n        dt = 1 / n_samples\n        ts = np.arange(0, 1, dt)\n        samples = np.array([path.point_from_proportion(t) for t in ts])\n        samples -= self.center_point\n        complex_samples = samples[:, 0] + 1j * samples[:, 1]\n        result = []\n        for freq in freqs:\n            riemann_sum = np.array([np.exp(-TAU * 1j * freq * t) * cs for t, cs in zip(ts, complex_samples)]).sum() * dt\n            result.append(riemann_sum)\n        return result"}]}
{"messages": [{"role": "user", "content": "Visualize the Fourier transform of the pi symbol with a zooming camera that follows the last rotating vector."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass FourierOfPiSymbol(FourierCirclesScene, ZoomedScene):\n    CONFIG = {'n_vectors': 51, 'center_point': ORIGIN, 'slow_factor': 0.1, 'n_cycles': 2, 'tex': '\\\\pi', 'start_drawn': False, 'max_circle_stroke_width': 1, 'zoomed_display_height': 2, 'zoomed_display_width': 2, 'zoom_factor': 0.05, 'slow_factor': 0.01}\n\n    def construct(self):\n        ZoomedScene.setup(self)\n        self.add_vectors_circles_path()\n        self.activate_zooming()\n        self.zoomed_camera.frame.add_updater(lambda m: m.move_to(self.vectors[-1].get_end()))\n        for n in range(self.n_cycles):\n            self.run_one_cycle()\n\n    def add_vectors_circles_path(self):\n        path = self.get_path()\n        coefs = self.get_coefficients_of_path(path)\n        vectors = self.get_rotating_vectors(coefficients=coefs)\n        circles = self.get_circles(vectors)\n        self.set_decreasing_stroke_widths(circles)\n        drawn_path = self.get_drawn_path(vectors)\n        if self.start_drawn:\n            self.vector_clock.increment_value(1)\n        self.add(path)\n        self.add(vectors)\n        self.add(circles)\n        self.add(drawn_path)\n        self.vectors = vectors\n        self.circles = circles\n        self.path = path\n        self.drawn_path = drawn_path\n\n    def run_one_cycle(self):\n        time = 1 / self.slow_factor\n        self.wait(time)\n\n    def set_decreasing_stroke_widths(self, circles):\n        mcsw = self.max_circle_stroke_width\n        for k, circle in zip(it.count(1), circles):\n            circle.set_stroke(width=max(mcsw / k, mcsw))\n        return circles\n\n    def get_path(self):\n        tex_mob = TexMobject(self.tex)\n        tex_mob.set_height(6)\n        path = tex_mob.family_members_with_points()[0]\n        path.set_fill(opacity=0)\n        path.set_stroke(WHITE, 1)\n        return path"}]}
{"messages": [{"role": "user", "content": "Write two lines of Chinese text on the screen sequentially, then fade them out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\n\nclass OpenScene(Scene):\n\n    def construct(self):\n        text1 = CText('\u8fd9\u662f\u4e00\u6761\u91cd\u8981\u7684\u6027\u8d28')\n        text2 = CText('\u540e\u9762\u4f1a\u7ecf\u5e38\u7528\u5230')\n        group = VGroup(text1, text2)\n        group.arrange(DOWN)\n        self.play(Write(text1))\n        self.wait()\n        self.play(Write(text2))\n        self.wait()\n        self.play(FadeOut(group))"}]}
{"messages": [{"role": "user", "content": "Display Chinese text explaining a property of parabolas involving chords, the directrix, and the focus."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\n\nclass Summary(Scene):\n\n    def construct(self):\n        text = CText('\u603b\u7ed3')\n        text.set_fill(DARK_BROWN)\n        content1 = CText('\u629b\u7269\u7ebf\u4efb\u610f\u5f26\u4e0e\u51c6\u7ebf\u7684\u4ea4\u70b9')\n        content2 = CText('\u53ca\u8be5\u629b\u7269\u7ebf\u7684\u7126\u70b9\u6240\u6784\u6210\u7684\u7ebf\u6bb5\uff0c')\n        content3 = CText('\u5e73\u5206\u8be5\u5f26\u4e24\u7aef\u70b9\u4e0e\u7126\u70b9\u6240\u6784\u6210\u89d2\u7684\u5916\u89d2')\n        contents = VGroup(content1, content2, content3)\n        contents.scale(0.7)\n        contents.arrange(DOWN)\n        total = VGroup(text, contents)\n        total.arrange(DOWN, buff=MED_LARGE_BUFF)\n        self.play(Write(text))\n        self.wait(2)\n        self.play(Write(contents))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Present a probability problem about collecting all item types in a lottery over multiple draws, highlighting the question in red."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\n\nclass Question(Scene):\n\n    def construct(self):\n        sub1 = CText('\u5728\u5f88\u591a\u573a\u666f\uff08\u7279\u522b\u662f\u6e38\u620f\uff09\u4e2d\uff0c\u4f1a\u78b0\u5230\u4e00\u7c7b\u6709\u8da3\u7684\u95ee\u9898\uff1a')\n        sub2 = CText('\u5982\u679c\u8981\u62bd\u5956N\u79cd\u7c7b\u578b\u7684\u7269\u54c1\uff0c\u6bcf\u6b21\u53ea\u80fd\u62bd\u4e00\u4e2a\u7269\u54c1')\n        sub3 = CText('\u62bd\u5230\u5404\u4e2a\u7269\u54c1\u7684\u6982\u7387\u76f8\u540c\uff0c\u6bcf\u6b21\u62bd\u5956\u76f8\u4e92\u72ec\u7acb')\n        sub4 = CText('\u95ee\uff1a\u62bd\u4e86T\u6b21\u4e4b\u540e\u5f97\u5230\u4e86\u6240\u6709\u7c7b\u578b\u7269\u54c1\u7684\u6982\u7387\u662f\u591a\u5c11\uff1f')\n        sub4.set_color(RED)\n        subs = VGroup(sub1, sub2, sub3, sub4)\n        subs.arrange(DOWN, buff=LARGE_BUFF)\n        subs.scale(0.5)\n        self.play(Write(sub1))\n        self.wait(5)\n        self.play(Write(sub2))\n        self.wait(5)\n        self.play(Write(sub3))\n        self.wait(5)\n        self.play(Write(sub4))\n        self.wait(15)\n        self.play(FadeOut(subs))"}]}
{"messages": [{"role": "user", "content": "Illustrate a card game example, displaying suits, the number of suits, and then a sequence of selected cards enclosed in a brown rectangle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\n\nclass ExampleQuestion(Scene):\n\n    def construct(self):\n        sub1 = CText('\u4ee5\u5361\u724c\u6e38\u620f\u4e3a\u4f8b')\n        sub2 = CText('\u6211\u4eec\u6709\u56db\u79cd\u82b1\u8272\u7684\u724c\uff1a')\n        sub1.scale(0.5)\n        sub2.scale(0.5)\n        sub1.to_edge(UP)\n        sub2.next_to(sub1, DOWN)\n        self.play(Write(sub1))\n        self.play(Write(sub2))\n        self.wait(5)\n        spade = ImageMobject('spade')\n        heart = ImageMobject('heart')\n        club = ImageMobject('club')\n        diamond = ImageMobject('diamond')\n        pool = Group(spade, heart, club, diamond)\n        pool.arrange(RIGHT, buff=LARGE_BUFF)\n        pool.next_to(sub2, DOWN, buff=MED_LARGE_BUFF)\n        for c in pool:\n            self.play(FadeInFromDown(c))\n        sub3 = TexMobject('N=4')\n        sub3.scale(0.8)\n        sub3.next_to(pool, RIGHT)\n        self.play(Write(sub3))\n        self.wait(5)\n        select = [0, 0, 1, 3, 2, 1, 3]\n        cards = [deepcopy(pool[v]) for v in select]\n        for i, s in enumerate(select):\n            c = cards[i]\n            c.move_to(6 * LEFT + 2 * DOWN + 2 * i * RIGHT)\n            self.play(TransformFromCopy(pool[s], c))\n        finish = Group(*cards[0:5])\n        box = Rectangle()\n        box.set_color(DARK_BROWN)\n        box.surround(finish, buff=0)\n        box.stretch_to_fit_height(2.1)\n        self.play(ShowCreation(box))\n        sub4 = TexMobject('T=5')\n        sub4.scale(0.8)\n        sub4.next_to(box, DOWN)\n        self.play(Write(sub4))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Present text explaining a basic probability problem and its formula."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\n\nclass BasicEvent(Scene):\n\n    def construct(self):\n        sub1 = CText('\u5148\u6765\u5206\u6790\u4e00\u4e2a\u57fa\u672c\u95ee\u9898')\n        sub1.scale(0.5)\n        sub2 = CText('n\u6b21\u62bd\u724c\u4e2d\u6ca1\u6709\u7b2ci\u79cd\u724c\u7684\u6982\u7387')\n        sub2.scale(0.5)\n        sub3_1 = CText('\u8bb0\u8be5\u4e8b\u4ef6\u4e3a').scale(0.5)\n        sub3_2 = TexMobject('A_i')\n        sub3 = VGroup(sub3_1, sub3_2)\n        sub3.arrange(RIGHT)\n        sub4 = CText('\u5219\u6613\u77e5\uff1a')\n        sub4.scale(0.5)\n        sub5 = TexMobject('P(A_i)=\\\\left(1-\\\\frac{1}{N}\\\\right)^n')\n        sub1.to_corner(UL, buff=LARGE_BUFF)\n        sub2.next_to(sub1, DOWN)\n        sub2.align_to(sub1, LEFT)\n        sub3.next_to(sub2, DOWN)\n        sub3.align_to(sub2, LEFT)\n        sub4.next_to(sub3, DOWN)\n        sub4.align_to(sub3, LEFT)\n        sub5.to_edge(DOWN)\n        sub5.shift(UP * 1.5)\n        self.play(ShowCreation(sub1))\n        self.wait()\n        self.play(ShowCreation(sub2))\n        self.wait()\n        self.play(ShowCreation(sub3))\n        self.wait()\n        self.play(ShowCreation(sub4))\n        self.wait()\n        self.play(ShowCreation(sub5))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Display text explaining a probability concept and then write out the inclusion-exclusion principle formula."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\n\nclass InitialAnalyse(Scene):\n\n    def construct(self):\n        sub1 = CText('\u5148\u6765\u5206\u6790\u524dn\u6b21\u62bd\u5361\u6ca1\u6709\u62bd\u5230\u6240\u6709\u5361\u724c\u7684\u6982\u7387')\n        sub1.scale(0.5)\n        sub1.to_corner(UL, buff=LARGE_BUFF)\n        sub2 = TexMobject('P\\\\{T>n\\\\}=P\\\\left(\\\\bigcup_{i=1}^N A_i\\\\right)')\n        sub2.next_to(sub1, DOWN)\n        sub2.align_to(sub1, LEFT)\n        sub3 = CText('\u7531\u5bb9\u65a5\u539f\u7406').scale(0.5)\n        sub3.next_to(sub2, RIGHT)\n        sub4 = TexMobject('\\\\begin{array}{ll}\\\\\\n            P\\\\{T>n\\\\}= & \\\\displaystyle\\\\sum_{i}P(A_i)-\\\\\\n            \\\\underset{i_1<i_2}{\\\\sum\\\\sum}\\\\\\n            P(A_{i_1}A_{i_2})+\\\\cdots\\\\\\\\ \\\\\\n            & \\\\displaystyle+(-1)^{k+1}\\\\\\n            \\\\underset{i_1<i_2<\\\\cdots<i_k}{\\\\sum\\\\sum\\\\sum}\\\\\\n            P(A_{i_1}A_{i_2}\\\\cdots A_{i_k})+\\\\cdots\\\\\\\\ \\\\\\n            & \\\\displaystyle +(-1)^{N+1}P(A_1A_2\\\\cdots A_N)\\\\\\n            \\\\end{array}')\n        sub4.next_to(sub2, DOWN, buff=LARGE_BUFF)\n        sub4.align_to(sub2, LEFT)\n        self.play(Write(sub1))\n        self.wait()\n        self.play(Write(sub2))\n        self.wait(5)\n        self.play(Write(sub3))\n        self.wait()\n        self.play(Write(sub4), run_time=5)\n        self.wait(15)"}]}
{"messages": [{"role": "user", "content": "Display a series of mathematical formulas and Chinese text sequentially, illustrating a probability calculation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\n\nclass JointProb(Scene):\n\n    def construct(self):\n        sub1 = CText('\u7531\u4e8e\u5404\u4e2a\u4e8b\u4ef6\u662f\u72ec\u7acb\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u5f97\u5230\uff1a')\n        sub1.scale(0.5)\n        sub1.to_corner(UL, buff=LARGE_BUFF)\n        sub2 = TexMobject('P(A_{i_1}A_{i_2}\\\\cdots A_{i_k})=            \\\\left(\\\\frac{N-k}{N}\\\\right)^n')\n        sub2.to_corner(UP)\n        sub2.shift(DOWN * 1.5)\n        sub3 = CText('\u5e26\u5165\u524d\u5f0f\uff0c\u5f97\uff1a')\n        sub3.scale(0.5)\n        sub3.next_to(sub2, DOWN)\n        sub3.align_to(sub1, LEFT)\n        sub4 = TexMobject('P\\\\{T>n\\\\}=\\\\sum_{i=1}^{N-1}\\\\\\n            \\\\binom{N}{i}\\\\left(\\\\frac{N-i}{N}\\\\\\n            \\\\right)^n(-1)^{i+1}')\n        sub4.to_edge(DOWN)\n        sub4.shift(UP)\n        note = CText('\u6ce8\uff1a')\n        note.scale(0.25)\n        sub5 = TexMobject('\\\\binom{N}{i}=C_{N}^i')\n        sub5.scale(0.5)\n        sub5.to_corner(DR)\n        note.next_to(sub5, LEFT)\n        self.play(Write(sub1))\n        self.wait(3)\n        self.play(Write(sub2))\n        self.wait(5)\n        self.play(Write(sub3))\n        self.wait()\n        self.play(Write(sub4))\n        self.wait()\n        self.play(Write(note), Write(sub5))\n        self.wait(15)"}]}
{"messages": [{"role": "user", "content": "Present a series of probability formulas, introducing a simplified form and then a final derived equation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\n\nclass Answer(Scene):\n\n    def construct(self):\n        sub1 = TexMobject('P\\\\{T>n-1\\\\}=P\\\\{T=n\\\\}+P\\\\{T>n\\\\}')\n        sub2 = TexMobject('P\\\\{T=n\\\\}=P\\\\{T>n-1\\\\}-P\\\\{T>n\\\\}')\n        sub3 = CText('\u5316\u7b80\uff0c\u5f97\u6700\u7ec8\u7b54\u6848\uff1a')\n        sub3.scale(0.5)\n        sub4 = TexMobject('P\\\\{T=n\\\\}=\\\\sum_{i=1}^{N-1}\\\\\\n            \\\\frac{i(-1)^{i+1}}{N}\\\\binom{N}{i}\\\\\\n            \\\\left(\\\\frac{N-i}{N}\\\\right)^{n-1}')\n        sub4.scale(1.3)\n        sub1.to_corner(UL)\n        sub2.next_to(sub1, DOWN, buff=LARGE_BUFF)\n        sub3.next_to(sub2, DOWN, buff=LARGE_BUFF)\n        sub3.align_to(sub2, LEFT)\n        sub4.to_edge(DOWN)\n        sub4.shift(UP)\n        self.play(Write(sub1))\n        self.wait(3)\n        self.play(Write(sub2))\n        self.wait(3)\n        self.play(Write(sub3))\n        self.wait()\n        self.play(Write(sub4))\n        self.wait(20)"}]}
{"messages": [{"role": "user", "content": "Display two lines of Chinese text introducing a follow-up question about probability and then fade them out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\n\nclass Extent(Scene):\n\n    def construct(self):\n        sub1 = CText('\u9644\u52a0\u95ee\u9898\uff1a')\n        sub2 = CText('\u62bd\u4e86n\u6b21\u540e\uff0c\u62bd\u5230D\u79cd\u7c7b\u578b\u7269\u54c1\u7684\u6982\u7387\u662f\u591a\u5c11\uff1f')\n        subs = VGroup(sub1, sub2)\n        subs.arrange(DOWN)\n        subs.scale(0.5)\n        self.play(Write(subs))\n        self.wait(10)\n        self.play(FadeOut(subs))"}]}
{"messages": [{"role": "user", "content": "Animate the iterative generation of a Levy curve, updating a counter as each iteration is displayed."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LevyScene(Scene):\n    CONFIG = {'camera_class': MovingCamera}\n\n    def construct(self):\n        text = TexMobject('N=0')\n        text.to_corner(UL)\n        self.play(Write(text))\n        start = RIGHT * 3 + 2 * DOWN\n        end = LEFT * 3 + 2 * DOWN\n        levy = Levy(start, end, 0)\n        self.play(ShowCreation(levy))\n        self.wait()\n        for i in range(1, 13):\n            new_text = TexMobject(f'N={i}')\n            new_text.to_corner(UL)\n            new_levy = Levy(start, end, i)\n            self.play(Transform(levy, new_levy), Transform(text, new_text))\n            self.wait()\n        self.wait(20)"}]}
{"messages": [{"role": "user", "content": "Animate the drawing of a fractal structure based on L-system rules."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LSystem(Scene):\n    CONFIG = {'rules': {'F': 'F+F--F+F'}, 'length': 1, 'start_loc': ORIGIN, 'angle': PI / 3, 'start_rot': 0, 'iteration': 1, 'initial': 'F', 'actions': {}, 'locations': [], 'rotations': [], 'graphs': [], 'expression': '', 'step_time': 1, 'animation': None, 'weight': 1}\n\n    def setup(self):\n        self.actions['F'] = self.draw_forward\n        self.actions['+'] = self.rotate_forward\n        self.actions['-'] = self.rotate_backward\n        self.actions['['] = self.push\n        self.actions[']'] = self.pop\n        self.cur_loc = self.start_loc\n        self.cur_rot = self.start_rot\n        self.expression = self.initial\n        self.animation = lambda x: self.play(ShowCreation(x), run_time=self.step_time)\n\n    def draw_forward(self):\n        o = self.cur_loc\n        l = self.length\n        a = self.cur_rot\n        e = o + l * np.cos(a) * RIGHT + l * np.sin(a) * UP\n        self.cur_loc = e\n        g = Line(o, e)\n        g.stroke_width = self.weight\n        self.animation(g)\n\n    def rotate_forward(self):\n        self.cur_rot += self.angle\n\n    def rotate_backward(self):\n        self.cur_rot -= self.angle\n\n    def push(self):\n        self.locations.append(self.cur_loc)\n        self.rotations.append(self.cur_rot)\n\n    def pop(self):\n        self.cur_loc = self.locations.pop()\n        self.cur_rot = self.rotations.pop()\n\n    def generate(self):\n        for i in range(self.iteration):\n            print(f'generating iteration {i + 1}')\n            new_exp = ''\n            for e in self.expression:\n                new_exp += self.rules.get(e, e)\n            self.expression = new_exp\n            print(f'iteration {i + 1} is finished')\n\n    def draw(self):\n        count = self.expression.count('F')\n        print(f'Total {count} Fs')\n        for e in self.expression:\n            act = self.actions.get(e, None)\n            if act is not None:\n                act()"}]}
{"messages": [{"role": "user", "content": "Display Chinese text explaining how to find points on a parabola, with each phrase appearing sequentially and then all fading out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\n\nclass OpenScene(Scene):\n\n    def construct(self):\n        sub1 = CText('\u6839\u636e\u6027\u8d281')\n        sub2 = CText('\u53ef\u4ee5\u7528\u53e6\u4e00\u79cd\u65b9\u6cd5\u627e\u5230')\n        sub3 = CText('\u629b\u7269\u7ebf\u4e0a\u7684\u70b9')\n        subs = VGroup(sub1, sub2, sub3)\n        subs.arrange(DOWN)\n        self.play(Write(sub1))\n        self.wait()\n        self.play(Write(sub2))\n        self.wait()\n        self.play(Write(sub3))\n        self.wait(5)\n        self.play(FadeOut(subs))"}]}
{"messages": [{"role": "user", "content": "Display the Chinese text \"\u5b57\u4f53\u6d4b\u8bd5\" using the Microsoft YaHei font."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Test(Scene):\n\n    def construct(self):\n        text = Text('\u5b57\u4f53\u6d4b\u8bd5', font='Microsoft YaHei')\n        self.play(Write(text))"}]}
{"messages": [{"role": "user", "content": "Display the same Chinese text in three different styles: regular, bold, and outlined, stacked vertically."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TextTest(Scene):\n\n    def construct(self):\n        text1 = Text('\u8fd9\u662f\u4e2d\u6587', font='Microsoft YaHei')\n        text2 = Text('\u8fd9\u662f\u4e2d\u6587', font='Microsoft YaHei', weight=BOLD)\n        text3 = Text('\u8fd9\u662f\u4e2d\u6587', font='Microsoft YaHei', stroke_width=0)\n        group = VGroup(text1, text2, text3)\n        text2.next_to(text1, DOWN)\n        text3.next_to(text2, DOWN)\n        group.shift(-group.get_center())\n        self.play(Write(group))"}]}
{"messages": [{"role": "user", "content": "Visualize the points of a purple, filled outer square and a blue, filled inner square rotated by 60 degrees, and label each pair of corresponding points with increasing numbers."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SquarePoints(Scene):\n\n    def construct(self):\n        outerSquare = Square().scale(2)\n        innerSquare = Square().scale(0.75).rotate(np.pi / 3)\n        outerSquare.set_color(PURPLE)\n        outerSquare.set_fill(ORANGE, opacity=0.5)\n        innerSquare.set_color(BLUE)\n        innerSquare.set_fill(ORANGE, opacity=1)\n        self.play(ShowCreation(innerSquare), ShowCreation(outerSquare))\n        count = 0\n        for i, j in zip(outerSquare.points, innerSquare.points):\n            self.play(*[ShowCreation(Dot().move_to(e)) for e in [i, j]])\n            self.play(*[Write(TexMobject(str(count)).move_to(e)) for e in [i, j]])\n            count += 1\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create and display two overlapping circles filled with light brown."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TwoCircleTest(Scene):\n\n    def construct(self):\n        a = TwoCircleInter()\n        a.set_fill(LIGHT_BROWN, opacity=1)\n        self.play(ShowCreation(a))"}]}
{"messages": [{"role": "user", "content": "Show the creation of an irregularly shaped sector filled with dark blue."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass IrregularSectorTest(Scene):\n\n    def construct(self):\n        shape = IrregularSector()\n        shape.set_fill(DARK_BLUE, opacity=1)\n        self.play(ShowCreation(shape))"}]}
{"messages": [{"role": "user", "content": "Animate a rotating regular pentagon and highlight the angle between two adjacent sides with a red arc."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass GetCorner(Scene):\n\n    def construct(self):\n        poly = RegularPolygon(5)\n        poly.scale(2)\n        angle_n = 1\n        l1 = Line()\n        l1.add_updater(lambda l: l.put_start_and_end_on(poly.get_vertices()[angle_n - 1], poly.get_vertices()[angle_n]))\n        l1.set_color(RED)\n        l2 = Line()\n        l2.add_updater(lambda l: l.put_start_and_end_on(poly.get_vertices()[angle_n + 1], poly.get_vertices()[angle_n]))\n        l2.set_color(RED)\n        ang = ArcBetweenPoints(LEFT, RIGHT)\n        ang.add_updater(lambda a: a.put_start_and_end_on(poly.get_vertices()[angle_n] + 0.5 * normalize(poly.get_vertices()[angle_n + 1] - poly.get_vertices()[angle_n]), poly.get_vertices()[angle_n] + 0.5 * normalize(poly.get_vertices()[angle_n - 1] - poly.get_vertices()[angle_n])))\n        self.play(ShowCreation(poly))\n        self.play(ShowCreation(l1), ShowCreation(l2))\n        self.play(ShowCreation(ang))\n        self.play(Rotate(poly, PI))"}]}
{"messages": [{"role": "user", "content": "Simulate a camera zooming out over a scene filled with randomly placed dots."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass MovingCameraTest(MovingCameraScene):\n\n    def construct(self):\n        for i in range(500):\n            d = Dot()\n            x = random.randint(-2 * int(FRAME_X_RADIUS), 2 * int(FRAME_X_RADIUS))\n            y = random.randint(-2 * int(FRAME_Y_RADIUS), 2 * int(FRAME_Y_RADIUS))\n            d.move_to(x * RIGHT + y * UP)\n            self.add(d)\n        self.play(ApplyMethod(self.camera.frame.scale, 2), run_time=10, rate_func=linear)"}]}
{"messages": [{"role": "user", "content": "Animate a parametric curve whose radius changes over time, creating a spiral effect."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ParametricTest(Scene):\n\n    def construct(self):\n        t = ValueTracker(0)\n\n        def get_rad():\n            return np.sin(t.get_value()) + 2\n        graph = ParametricFunction(lambda alpha: get_rad() * (np.cos(alpha * TAU) * RIGHT + np.sin(alpha * TAU) * UP))\n\n        def set_func(m):\n            m.function = lambda alpha: get_rad() * (np.cos(alpha * TAU) * RIGHT + np.sin(alpha * TAU) * UP)\n            m.clear_points()\n            m.generate_points()\n        graph.add_updater(set_func)\n        self.add(graph)\n        self.play(t.set_value, 3 * TAU, rate_func=linear, run_time=3)"}]}
{"messages": [{"role": "user", "content": "Create five circles in a line and animate their creation sequentially with a slight delay between each."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LaggedStartTest(Scene):\n\n    def construct(self):\n        circles = VGroup()\n        for i in range(5):\n            c = Circle(radius=0.3)\n            c.move_to((i - 2) * RIGHT)\n            circles.add(c)\n        self.play(LaggedStartMap(ShowCreation, circles, lag_ratio=0.2))"}]}
{"messages": [{"role": "user", "content": "Create a double-tipped dashed line that animates its creation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass DoubleDashedArrow(Scene):\n\n    def construct(self):\n        a = DashedLine(LEFT * 3, RIGHT * 3)\n        tip = a.create_tip(tip_length=0.5, at_start=True)\n        tip2 = a.create_tip(tip_length=0.5, at_start=False)\n        a.reset_endpoints_based_on_tip(tip, at_start=True)\n        a.reset_endpoints_based_on_tip(tip2, at_start=False)\n        a.asign_tip_attr(tip, at_start=True)\n        a.asign_tip_attr(tip2, at_start=False)\n        a.add(tip)\n        a.add(tip2)\n        self.play(ShowCreation(a))"}]}
{"messages": [{"role": "user", "content": "Animate a point moving along an ellipse, with a tangent line following the point."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TangentLine(Scene):\n\n    def construct(self):\n        ellipse = Ellipse()\n        ellipse.set_width(5)\n        ellipse.set_height(3)\n        dot = Dot()\n        proportion = ValueTracker(0)\n        dot.add_updater(lambda m: m.move_to(ellipse.point_from_proportion(proportion.get_value())))\n        tangent_line = Line()\n\n        def move_tangent_line(line):\n            p = proportion.get_value()\n            p1 = ellipse.point_from_proportion(p)\n            p2 = ellipse.point_from_proportion((p + 0.001) % 1)\n            vec = normalize(p2 - p1)\n            line.put_start_and_end_on(p1 + vec * FRAME_X_RADIUS, p1 - vec * FRAME_X_RADIUS)\n        tangent_line.add_updater(lambda l: move_tangent_line(l))\n        self.add(tangent_line)\n        self.add(ellipse)\n        self.add(dot)\n        self.play(proportion.set_value, 1, rate_func=linear, run_time=5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a dot moving along a line with a bounce effect and then returning to the start with an elastic effect."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.rate_functions import *\n\nclass EaseTest(Scene):\n\n    def construct(self):\n        path = Line(LEFT * 3, RIGHT * 3)\n        dot = Dot(path.get_start())\n        self.add(path)\n        self.add(dot)\n        self.play(MoveAlongPath(dot, path), rate_func=easeOutBounce, run_time=2)\n        self.wait()\n        self.play(dot.move_to, path.get_start(), rate_func=easeOutElastic)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a dynamic angle visualization where a point moves along a circle's circumference, updating the angle and its label."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.rate_functions import *\nfrom ManimProjects.utils.geometry import *\n\nclass AngleTest(Scene):\n\n    def construct(self):\n        radius = 3\n        ang = ValueTracker(0.1)\n        p1 = Dot(RIGHT * radius)\n        o = Dot()\n        p2 = Dot()\n        p2.add_updater(lambda m: m.move_to(math.cos(ang.get_value()) * radius * RIGHT + math.sin(ang.get_value()) * radius * UP))\n        op1 = Line()\n        op2 = Line()\n        op1.add_updater(lambda l: l.put_start_and_end_on(o.get_center(), p1.get_center()))\n        op2.add_updater(lambda l: l.put_start_and_end_on(o.get_center(), p2.get_center()))\n        self.add(op1, op2, p1, o, p2)\n        angle = Angle(p1, o, p2, show_edge=True)\n        angle.make_angle_dynamic()\n        label = TexMobject('\\\\alpha').scale(0.65)\n        angle.add_label(label)\n        angle.set_fill(DARK_BLUE, opacity=0.8)\n        self.add(label, angle)\n        self.play(ang.set_value, 2 * PI - 0.1, run_time=5, rate_func=linear)\n        self.wait()\n        self.play(ang.set_value, PI / 2)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Simulate multiple balls attached to springs, animated to move and react to forces, with a fixed point that moves across the screen."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.rate_functions import *\nfrom ManimProjects.utils.geometry import *\n\nclass MultiSpring(Scene):\n\n    def construct(self):\n\n        def move_ball(ball, dt):\n            force = DOWN * 20\n            force += ball.spring.get_force()\n            ball.velocity += force * dt\n            ball.velocity *= 0.95\n            ball.shift(ball.velocity * dt)\n        balls = []\n        fix_point = Dot().move_to(UP * FRAME_Y_RADIUS)\n        for i in range(4):\n            ball = Circle(radius=0.3)\n            ball.move_to((3 - i) * UP + random.random() * RIGHT)\n            ball.set_fill(RED, opacity=1)\n            start = fix_point if i == 0 else balls[i - 1]\n            end = ball\n            spring = Spring(start, end, 1, 40)\n            ball.spring = spring\n            ball.velocity = 0\n            ball.add_updater(move_ball)\n            self.add(spring.line)\n            self.add(ball)\n            balls.append(ball)\n        self.wait(10)\n        self.play(fix_point.shift, RIGHT * 3)\n        self.wait(10)\n        self.play(fix_point.shift, LEFT * 6, run_time=2)\n        self.wait(15)"}]}
{"messages": [{"role": "user", "content": "Play a video, pause it halfway, display text, and then resume the video for the remaining duration."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.rate_functions import *\nfrom ManimProjects.utils.geometry import *\n\nclass VideoTest(Scene):\n\n    def construct(self):\n        video = VideoMobject('zhang', scene=self)\n        video.start()\n        self.add(video)\n        self.wait(video.duration / 2)\n        video.stop()\n        text = Text('\u73b0\u5728\u505c\u987f1\u79d2', font='Microsoft YaHei')\n        text.scale(0.8)\n        text.move_to(UP * 2)\n        self.play(Write(text))\n        self.wait()\n        video.start()\n        self.wait(video.duration / 2)"}]}
{"messages": [{"role": "user", "content": "Introduce the use of coordinate systems and pure geometry in studying conic sections, mention a reference book and the tool used for video production, and conclude with the starting topic of parabolas."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\n\nclass OpenScene(Scene):\n\n    def construct(self):\n        text1head = CText('\u9ad8\u4e2d\u65f6\u671f\u7684\u89e3\u6790\u51e0\u4f55\u90fd\u7528')\n        text1body = CText('\u5750\u6807\u7cfb')\n        text1tail = CText('\u8fdb\u884c\u7814\u7a76')\n        text1 = VGroup(text1head, text1body, text1tail, buff=SMALL_BUFF)\n        text1.arrange()\n        text1body.set_fill(DARK_BLUE)\n        text2 = CText('\u8ba1\u7b97\u7e41\u6742\uff0c\u4e14\u4e0d\u4f18\u96c5')\n        text3head = CText('\u90a3\u4e48\uff0c\u662f\u5426\u53ef\u4ee5\u7528')\n        text3body = CText('\u7eaf\u51e0\u4f55')\n        text3tail = CText('\u7684\u65b9\u6cd5')\n        text3 = VGroup(text3head, text3body, text3tail, buff=SMALL_BUFF)\n        text3body.set_fill(DARK_BLUE)\n        text3.arrange()\n        text4 = CText('\u6765\u5f97\u5230\u4e00\u4e9b\u5706\u9525\u66f2\u7ebf\u7684\u6027\u8d28\uff1f')\n        group = VGroup(text1, text2, text3, text4)\n        group.arrange_submobjects(direction=DOWN, buff=1)\n        group.scale(0.5)\n        self.play(Write(text1))\n        self.play(WiggleOutThenIn(text1body))\n        self.wait()\n        self.play(Write(text2))\n        self.wait()\n        self.play(Write(text3))\n        self.play(WiggleOutThenIn(text3body))\n        self.wait()\n        self.play(Write(text4))\n        self.wait(2)\n        self.play(FadeOut(group))\n        explan1 = CText('\u672c\u7cfb\u5217\u5c06\u8bd5\u56fe\u7528\u51e0\u4f55\u65b9\u6cd5\u7814\u7a76\u5706\u9525\u66f2\u7ebf')\n        explan2h = CText('\u4e3b\u8981\u53c2\u8003')\n        explan2t = CText('\u300a\u5706\u9525\u66f2\u7ebf\u7684\u51e0\u4f55\u6027\u8d28\u300b')\n        explan2 = VGroup(explan2h, explan2t)\n        explan2.arrange()\n        explan2t.set_fill(DARK_BLUE)\n        explan3 = CText('\u5e0c\u671b\u80fd\u6709\u6240\u5e2e\u52a9')\n        explan = VGroup(explan1, explan2, explan3)\n        explan.arrange_submobjects(direction=DOWN, buff=1)\n        explan.scale(0.5)\n        self.play(Write(explan1))\n        self.wait()\n        self.play(Write(explan2))\n        self.play(WiggleOutThenIn(explan2t))\n        self.wait()\n        self.play(Write(explan3))\n        self.wait(2)\n        self.play(FadeOut(explan))\n        jokeh = CText('\u89c6\u9891\u4f7f\u7528')\n        jokeb = CText('manim')\n        joket = CText('\u5236\u4f5c')\n        jokeb.set_fill(DARK_BLUE)\n        joked = CText('\u8fb9\u5b66\u8fb9\u505a\uff0c\u968f\u7f18\u66f4\u65b0')\n        jokeT = VGroup(jokeh, jokeb, joket, buff=SMALL_BUFF)\n        jokeT.arrange()\n        joke = VGroup(jokeT, joked)\n        joke.arrange_submobjects(direction=DOWN, buff=1)\n        self.play(Write(jokeT))\n        self.play(WiggleOutThenIn(jokeb))\n        self.wait()\n        self.play(Write(joked))\n        self.wait(2)\n        self.play(FadeOut(joke))\n        last = CText('\u4ece\u629b\u7269\u7ebf\u5f00\u59cb')\n        self.play(Write(last))\n        self.wait()\n        self.play(FadeOut(last))"}]}
{"messages": [{"role": "user", "content": "Display Chinese text about parabolas and then fade it out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\nfrom ManimProjects.utils.Parabola import *\nfrom ManimProjects.utils.rate_functions import *\nfrom ManimProjects.utils.calculation import *\n\nclass Prob1Open(Scene):\n\n    def construct(self):\n        line1_1 = CText('\u629b\u7269\u7ebf')\n        line1_1.set_fill(DARK_BLUE)\n        line1_2 = CText('\u6027\u8d28\u4e94')\n        line1 = VGroup(line1_1, line1_2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u63a8\u8bba\u4e00')\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.wait(3)\n        self.play(Write(line2))\n        self.wait(3)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Display the Chinese text \"\u629b\u7269\u7ebf \u6027\u8d28\u4e94\" and then \"\u63a8\u8bba\u4e8c\", with each line appearing sequentially and then both fading out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\nfrom ManimProjects.utils.Parabola import *\nfrom ManimProjects.utils.rate_functions import *\nfrom ManimProjects.utils.calculation import *\n\nclass Prob2Open(Scene):\n\n    def construct(self):\n        line1_1 = CText('\u629b\u7269\u7ebf')\n        line1_1.set_fill(DARK_BLUE)\n        line1_2 = CText('\u6027\u8d28\u4e94')\n        line1 = VGroup(line1_1, line1_2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u63a8\u8bba\u4e8c')\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.wait(3)\n        self.play(Write(line2))\n        self.wait(3)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Display the Chinese text \"\u629b\u7269\u7ebf \u6027\u8d28\u56db\" and then \"\u63a8\u8bba\u4e8c\", with each group fading out after a delay."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\nfrom ManimProjects.utils.Parabola import *\nfrom ManimProjects.utils.rate_functions import *\nfrom ManimProjects.utils.calculation import *\n\nclass Prob2Open(Scene):\n\n    def construct(self):\n        line1_1 = CText('\u629b\u7269\u7ebf')\n        line1_1.set_fill(DARK_BLUE)\n        line1_2 = CText('\u6027\u8d28\u56db')\n        line1 = VGroup(line1_1, line1_2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u63a8\u8bba\u4e8c')\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.wait(3)\n        self.play(Write(line2))\n        self.wait(3)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Display the text \"\u629b\u7269\u7ebf \u6027\u8d28\u56db\" and \"\u63a8\u8bba\u4e09\" sequentially and then fade them out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\nfrom ManimProjects.utils.Parabola import *\nfrom ManimProjects.utils.rate_functions import *\nfrom ManimProjects.utils.calculation import *\n\nclass Prob3Open(Scene):\n\n    def construct(self):\n        line1_1 = CText('\u629b\u7269\u7ebf')\n        line1_1.set_fill(DARK_BLUE)\n        line1_2 = CText('\u6027\u8d28\u56db')\n        line1 = VGroup(line1_1, line1_2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u63a8\u8bba\u4e09')\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.wait(3)\n        self.play(Write(line2))\n        self.wait(3)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Display Chinese text about parabolas and their tangent properties, animating a wiggle effect on the first part of the text before fading everything out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\nfrom ManimProjects.utils.Parabola import *\nfrom ManimProjects.utils.calculation import *\nfrom ManimProjects.utils.rate_functions import *\n\nclass OpenScene(Scene):\n\n    def construct(self):\n        sub1 = CText('\u629b\u7269\u7ebf')\n        sub1.set_color(DARK_BLUE)\n        sub2 = CText('\u6027\u8d28\u4e94')\n        line1 = VGroup(sub1, sub2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u5207\u7ebf\u4e0e\u6cd5\u7ebf\u6709\u4e00\u5b9a\u7684\u5173\u7cfb')\n        line2.scale(0.5)\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.play(WiggleOutThenIn(sub1))\n        self.wait()\n        self.play(Write(line2))\n        self.wait(5)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Display Chinese text about tangent properties and then fade it out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import *\n\nclass OpenScene(Scene):\n\n    def construct(self):\n        sub1 = CText('\u8fd9\u662f\u4e00\u4e2a')\n        sub2 = CText('\u5173\u4e8e\u5207\u7ebf\u7684\u6027\u8d28')\n        subs = VGroup(sub1, sub2)\n        subs.arrange(DOWN)\n        self.play(Write(sub1))\n        self.play(Write(sub2))\n        self.wait(2)\n        self.play(FadeOut(subs))"}]}
{"messages": [{"role": "user", "content": "Animate a parabola with its focus and directrix."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Parabola(Scene):\n    CONFIG = {'focus': 2, 'y_max': 10, 'x_min': -8, 'color': WHITE}\n\n    def adjust_x_range(self):\n        self.y_min = -self.y_max\n        self.x_max = 2 * self.y_max / FRAME_HEIGHT * FRAME_WIDTH + self.x_min\n        self.func = lambda y: y ** 2 / (4 * self.focus)\n\n    def get_graph(self, color=WHITE):\n        f = self.focus\n        func = self.func\n\n        def parameterized_function(alpha):\n            y = interpolate(self.y_max, self.y_min, alpha)\n            x = func(y)\n            return self.coords_to_point(x, y)\n        self.graph = ParametricFunction(parameterized_function, color=color)\n        return self.graph\n\n    def get_horizontal(self):\n        return Line(FRAME_X_RADIUS * LEFT, FRAME_X_RADIUS * RIGHT)\n\n    def value_to_point(self, y):\n        x = y ** 2 / (4 * self.focus)\n        return self.coords_to_point(x, y)\n\n    def get_focus(self):\n        return self.coords_to_point(self.focus, 0)\n\n    def get_directrix(self):\n        f = self.coords_to_point(-self.focus, 0)\n        return Line(f + FRAME_Y_RADIUS * UP, f + FRAME_Y_RADIUS * DOWN)\n\n    def map(self, val, from_min, from_max, to_min, to_max):\n        return (val - from_min) / (from_max - from_min) * (to_max - to_min) + to_min\n\n    def coords_to_point(self, x, y):\n        to_x = self.map(x, self.x_min, self.x_max, -FRAME_X_RADIUS, FRAME_X_RADIUS)\n        to_y = self.map(y, self.y_min, self.y_max, -FRAME_Y_RADIUS, FRAME_Y_RADIUS)\n        return to_x * RIGHT + to_y * UP\n\n    def point_to_coords(self, point):\n        pos = point.get_center()\n        x = pos[0]\n        y = pos[1]\n        to_x = self.map(x, -FRAME_X_RADIUS, FRAME_X_RADIUS, self.x_min, self.x_max)\n        to_y = self.map(y, -FRAME_Y_RADIUS, FRAME_Y_RADIUS, self.y_min, self.y_max)\n        return [to_x, to_y]\n\n    def get_opposite_y(self, y):\n        f = self.focus\n        return -4 * f * f / y\n\n    def get_opposite(self, point):\n        pos = self.point_to_coords(point)\n        [x, y] = pos\n        opp_y = self.get_opposite_y(y)\n        opp_x = self.func(opp_y)\n        return self.coords_to_point(opp_x, opp_y)\n\n    def chord_to_directrix(self, p1, p2):\n        if p1.get_center()[0] > p2.get_center()[0]:\n            p1, p2 = (p2, p1)\n        pos1 = p1.get_center()\n        pos2 = p2.get_center()\n        vec = pos1 - pos2\n        if vec[0] == 0:\n            return self.coords_to_point(-self.focus, 0)\n        vec /= vec[0]\n        dest_x = self.coords_to_point(-self.focus, 0)[0]\n        fac = dest_x - pos1[0]\n        return pos1 + vec * fac\n\n    def right(self, point1, point2):\n        pos1 = point1.get_center()\n        pos2 = point2.get_center()\n        if pos1[0] > pos2[0]:\n            return pos1\n        return pos2\n\n    def get_tangent_to_directrix(self, point):\n        [x, y] = self.point_to_coords(point)\n        d = y / (2 * self.focus)\n        dx = -self.focus - x\n        dy = dx / d\n        return self.coords_to_point(-self.focus, y + dy)\n\n    def add_tangent_line_updater(self, line, point):\n        line.add_updater(lambda l: l.put_start_and_end_on(point.get_center(), self.get_tangent_to_directrix(point)))\n\n    def add_tangent_extent_updater(self, line, point):\n\n        def updater(l):\n            l.put_start_and_end_on(LEFT * FRAME_WIDTH, RIGHT * FRAME_WIDTH)\n            pos1 = point.get_center()\n            pos2 = self.get_tangent_to_directrix(point)\n            vec = pos2 - pos1\n            ang = math.atan2(vec[1], vec[0])\n            l.set_angle(ang)\n            l.move_to(pos1)\n        line.add_updater(lambda l: updater(l))\n\n    def add_directrix_point_updater(self, p, d):\n        d.add_updater(lambda m: m.move_to(self.coords_to_point(-self.focus, 0) + p.get_center()[1] * UP))\n\n    def get_normal_to_directrix(self, point):\n        [x, y] = self.point_to_coords(point)\n        if y == 0:\n            return self.coords_to_point(-self.focus, 0)\n        d = -y / (2 * self.focus)\n        dx = -self.focus - x\n        dy = dx * d\n        return self.coords_to_point(-self.focus, y + dy)\n\n    def add_normal_updater(self, line, point):\n\n        def updater(l):\n            l.put_start_and_end_on(LEFT * FRAME_WIDTH, RIGHT * FRAME_WIDTH)\n            pos1 = point.get_center()\n            pos2 = self.get_normal_to_directrix(point)\n            vec = pos2 - pos1\n            ang = math.atan2(vec[1], vec[0])\n            l.set_angle(ang)\n            l.move_to(pos1)\n        line.add_updater(lambda l: updater(l))"}]}
{"messages": [{"role": "user", "content": "Animate Chinese text about parabola properties and corollaries, then fade them out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\nfrom ManimProjects.utils.calculation import get_intersect\n\nclass Prob1Open(Scene):\n\n    def construct(self):\n        line1_1 = CText('\u629b\u7269\u7ebf')\n        line1_1.set_fill(DARK_BLUE)\n        line1_2 = CText('\u6027\u8d28\u4e09')\n        line1 = VGroup(line1_1, line1_2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u63a8\u8bba\u4e00')\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.wait(3)\n        self.play(Write(line2))\n        self.wait(3)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Display Chinese text describing parabola properties and a corollary, then fade them out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\nfrom ManimProjects.utils.calculation import get_intersect\n\nclass Prob2Open(Scene):\n\n    def construct(self):\n        line1_1 = CText('\u629b\u7269\u7ebf')\n        line1_1.set_fill(DARK_BLUE)\n        line1_2 = CText('\u6027\u8d28\u4e09')\n        line1 = VGroup(line1_1, line1_2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u63a8\u8bba\u4e8c')\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.wait(3)\n        self.play(Write(line2))\n        self.wait(3)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Display \"Parabola Property 3\" followed by \"Inference 3\" and then fade them out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\nfrom ManimProjects.utils.calculation import get_intersect\n\nclass Prob3Open(Scene):\n\n    def construct(self):\n        line1_1 = CText('\u629b\u7269\u7ebf')\n        line1_1.set_fill(DARK_BLUE)\n        line1_2 = CText('\u6027\u8d28\u4e09')\n        line1 = VGroup(line1_1, line1_2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u63a8\u8bba\u4e09')\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.wait(3)\n        self.play(Write(line2))\n        self.wait(3)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Present text about parabola properties and a corollary, then fade out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\nfrom ManimProjects.utils.calculation import get_intersect\n\nclass Prob4Open(Scene):\n\n    def construct(self):\n        line1_1 = CText('\u629b\u7269\u7ebf')\n        line1_1.set_fill(DARK_BLUE)\n        line1_2 = CText('\u6027\u8d28\u4e09')\n        line1 = VGroup(line1_1, line1_2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u63a8\u8bba\u56db')\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.wait(3)\n        self.play(Write(line2))\n        self.wait(3)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Show two lines of Chinese text appearing on screen, then fading out together."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\n\nclass OpenScene(Scene):\n\n    def construct(self):\n        sub1 = CText('\u8fd9\u5c06\u662f\u4e00\u4e2a')\n        sub2 = CText('\u5173\u4e8e\u7ebf\u6bb5\u957f\u5ea6\u7684\u6027\u8d28')\n        subs = VGroup(sub1, sub2)\n        subs.arrange(DOWN)\n        self.play(Write(sub1))\n        self.play(Write(sub2))\n        self.wait(2)\n        self.play(FadeOut(subs))"}]}
{"messages": [{"role": "user", "content": "Display Chinese text summarizing the properties of a parabola, with the title \"\u603b\u7ed3\" above the two lines of the summary."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\n\nclass Summary(Scene):\n\n    def construct(self):\n        text = CText('\u603b\u7ed3')\n        text.set_fill(DARK_BROWN)\n        content1 = CText('\u7eb5\u6807\u7ebf\u7684\u5e73\u65b9\u7b49\u4e8e')\n        content2 = CText('\u6a2a\u6807\u7ebf\u4e0e\u7126\u8ddd\u4e58\u79ef\u7684\u56db\u500d')\n        contents = VGroup(content1, content2)\n        contents.scale(0.7)\n        contents.arrange(DOWN)\n        total = VGroup(text, contents)\n        total.arrange(DOWN, buff=MED_LARGE_BUFF)\n        self.play(Write(text))\n        self.wait(2)\n        self.play(Write(contents))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Display Chinese text about parabola properties and inference, then fade them out."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\n\nclass Prob1Open(Scene):\n\n    def construct(self):\n        line1_1 = CText('\u629b\u7269\u7ebf')\n        line1_1.set_fill(DARK_BLUE)\n        line1_2 = CText('\u6027\u8d28\u4e8c')\n        line1 = VGroup(line1_1, line1_2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u63a8\u8bba\u4e00')\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.wait(3)\n        self.play(Write(line2))\n        self.wait(3)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Display Chinese text about parabola properties, introducing each section sequentially."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.Parabola import Parabola\nfrom ManimProjects.utils.geometry import CText\n\nclass Prob2Open(Scene):\n\n    def construct(self):\n        line1_1 = CText('\u629b\u7269\u7ebf')\n        line1_1.set_fill(DARK_BLUE)\n        line1_2 = CText('\u6027\u8d28\u4e8c')\n        line1 = VGroup(line1_1, line1_2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u63a8\u8bba\u4e8c')\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.wait(3)\n        self.play(Write(line2))\n        self.wait(3)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Display the text \"\u629b\u7269\u7ebf\" and \"\u6027\u8d28\u56db\" then show a supporting sentence about a parabola property."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom ManimProjects.utils.geometry import *\nfrom ManimProjects.utils.Parabola import *\n\nclass OpenScene(Scene):\n\n    def construct(self):\n        sub1 = CText('\u629b\u7269\u7ebf')\n        sub1.set_color(DARK_BLUE)\n        sub2 = CText('\u6027\u8d28\u56db')\n        line1 = VGroup(sub1, sub2)\n        line1.arrange(RIGHT)\n        line2 = CText('\u8fd9\u662f\u4e00\u6761\u76f8\u5f53\u6709\u7528\u7684\u6027\u8d28')\n        line2.scale(0.5)\n        lines = VGroup(line1, line2)\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.play(Write(line1))\n        self.play(WiggleOutThenIn(sub1))\n        self.wait()\n        self.play(Write(line2))\n        self.wait(5)\n        self.play(FadeOut(lines))"}]}
{"messages": [{"role": "user", "content": "Create a 3D scene with axes, a circle, and 3D text."}, {"role": "assistant", "content": "from manim import *\n\nclass threeDGraph(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes()\n        circle = Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        text3d = Text('This is a 3D text')\n        self.add(circle, axes)\n        self.add_fixed_in_frame_mobjects(text3d)\n        text3d.to_corner(UL)\n        self.add(axes)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a pink, semi-transparent circle transforming from a rotated and flipped square, then fade out."}, {"role": "assistant", "content": "from manim import *\n\nclass SquareToCircleWithModifications(Scene):\n\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        square.flip(RIGHT)\n        square.rotate(-3 * TAU / 8)\n        circle.set_fill(PINK, opacity=0.5)\n        self.play(Create(square))\n        self.play(Transform(square, circle))\n        self.play(FadeOut(square))"}]}
{"messages": [{"role": "user", "content": "Animate three lines of text, sequentially writing the first two, then transforming the first into the third while fading out the second."}, {"role": "assistant", "content": "from manim import *\n\nclass displayText(Scene):\n\n    def construct(self):\n        first_line = Text('Create cool animations')\n        second_line = Text('using Manim')\n        third_line = Text('Try it out yourself.', color=RED)\n        second_line.next_to(first_line, DOWN)\n        self.wait(1)\n        self.play(Write(first_line), Write(second_line))\n        self.wait(1)\n        self.play(ReplacementTransform(first_line, third_line), FadeOut(second_line))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Show text phrases about Manim's capabilities, then transform the first phrase into a mathematical equation."}, {"role": "assistant", "content": "from manim import *\n\nclass displayEquations(Scene):\n\n    def construct(self):\n        first_line = Text('Manim also allows you')\n        second_line = Text('to show beautiful math equations')\n        equation = Tex('$d\\\\left(p, q\\\\right)=d\\\\left(q, p\\\\right)=\\\\sqrt{(q_1-p_1)^2+(q_2-p_2)^2+...+(q_n-p_n)^2}=\\\\sqrt{\\\\sum_{i=1}^n\\\\left(q_i-p_i\\\\right)^2}$')\n        second_line.next_to(first_line, DOWN)\n        self.play(Write(first_line), Write(second_line))\n        self.wait(1)\n        self.play(ReplacementTransform(first_line, equation), FadeOut(second_line))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Animate a square transforming into a circle and then fading out."}, {"role": "assistant", "content": "from manim import *\n\nclass SquareToCircle(Scene):\n\n    def construct(self):\n        circle = Circle()\n        square = Square()\n        self.play(Create(square))\n        self.play(Transform(square, circle))\n        self.play(FadeOut(square))"}]}
{"messages": [{"role": "user", "content": "Display a graph of x-squared, then transform it into a graph of x-cubed, with labels for each."}, {"role": "assistant", "content": "from manim import *\n\nclass CreateGraph(Scene):\n\n    def construct(self):\n        axes = Axes(x_range=[-3, 3], y_range=[-5, 5], axis_config={'color': BLUE})\n        graph = axes.get_graph(lambda x: x ** 2, color=WHITE)\n        graph_label = axes.get_graph_label(graph, label='x^{2}')\n        graph2 = axes.get_graph(lambda x: x ** 3, color=WHITE)\n        graph_label2 = axes.get_graph_label(graph2, label='x^{3}')\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n        self.play(Transform(graph, graph2), Transform(graph_label, graph_label2))\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Display two overlapping white squares."}, {"role": "assistant", "content": "import math\nfrom manim import *\n\nclass MyScene(Scene):\n\n    def construct(self):\n        MyObject = Rectangle(height=1.0, width=1.0, grid_xstep=1.0, grid_ystep=1.0, color='#ffffff').shift(RIGHT * 0.0 + UP * 0.0)\n        self.add(MyObject, MyObject)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the introduction of three orbiting planets, followed by a series of questions about functions describing their motion and velocity, and finally, a transition to vector fields and related mathematical concepts, concluding with acknowledgments."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass intro(Scene):\n\n    def construct(self):\n        planetintro = TextMobject(\"Consideremos tres planetas en \\\\'{o}rbita\").to_edge(UP)\n        estrella = Dot()\n        planeta = Dot()\n        satelite = Dot()\n        estrella.set_color(YELLOW).move_to((X_1[0], Y_1[0], Z_1[0]))\n        planeta.set_color(RED).move_to((X_2[0], Y_2[0], Z_2[0]))\n        satelite.set_color(BLUE).move_to((X_3[0], Y_3[0], Z_3[0]))\n        self.play(Write(estrella), Write(planeta), Write(satelite), Write(planetintro))\n        E = []\n        P = []\n        S = []\n        for i, j, k in zip(posiciones_1, posiciones_2, posiciones_3):\n            self.remove(estrella, planeta, satelite)\n            estrella_sig = Dot()\n            estrella_sig_aux = Dot(radius=0.01)\n            planeta_sig = Dot()\n            planeta_sig_aux = Dot(radius=0.01)\n            satelite_sig = Dot()\n            satelite_sig_aux = Dot(radius=0.01)\n            estrella_sig.move_to(i).set_color(RED)\n            estrella_sig_aux.move_to(i)\n            planeta_sig.move_to(j).set_color(YELLOW)\n            planeta_sig_aux.move_to(j)\n            satelite_sig.move_to(k).set_color(BLUE)\n            satelite_sig_aux.move_to(k)\n            E.append(estrella_sig_aux)\n            P.append(planeta_sig_aux)\n            S.append(satelite_sig_aux)\n            self.add(estrella_sig_aux, planeta_sig_aux, satelite_sig_aux, estrella_sig, planeta_sig, satelite_sig)\n            self.wait(0.1)\n            estrella = estrella_sig\n            planeta = planeta_sig\n            satelite = satelite_sig\n        intr = TextMobject('Vale la pena pensar')\n        intr2 = TextMobject('en las siguientes preguntas:')\n        intr2.next_to(intr, DOWN, buff=0.5)\n        intro = VGroup(intr, intr2)\n        intro.move_to((0, 2.5, 0))\n        preg1_1 = TextMobject('\u00bfEl movimiento de uno de los cuerpos puede verse con')\n        preg1_2 = TexMobject('\\\\text{funciones de } \\\\mathbb{R} \\\\text{ a } \\\\mathbb{R}?')\n        preg1_2.next_to(preg1_1, DOWN, buff=0.5)\n        preg1 = VGroup(preg1_1, preg1_2)\n        preg1.move_to((0, 2.5, 0))\n        preg5_1 = TextMobject(\"\u00bfQu\\\\'{e} tipo de funci\u00f3n podemos utilizar para describir la\")\n        preg5_2 = TextMobject(\"posici\\\\'{o}n de un planeta en cada momento?\")\n        preg5_2.next_to(preg5_1, DOWN)\n        preg5 = VGroup(preg5_1, preg5_2)\n        preg5.move_to((0, 2.5, 0))\n        preg6 = TextMobject(\"\u00bfCu\\\\'{a}l es el dominio y qu\\\\'{e} representa su variable?\")\n        preg6.move_to((0, 2.5, 0))\n        preg7 = TextMobject(\"\u00bfCu\\\\'{a}l es su contradominio y qu\\\\'{e} representan sus elementos?\")\n        preg7.move_to((0, 2.5, 0))\n        preg2_1 = TextMobject(\"\u00bfC\\\\'{o}mo se relaciona esa funci\\\\'{o}n con\")\n        preg2_2 = TextMobject('la trayectoria del planeta?')\n        preg2_1.next_to(preg2_2, UP, buff=0.5)\n        preg2 = VGroup(preg2_1, preg2_2)\n        preg2.move_to((0, 2.5, 0))\n        preg4_1 = TextMobject(\"Y para ver el movimiento de los tres con una sola funci\\\\'{o}n,\")\n        preg4_2 = TextMobject(\"\u00bfqu\\\\'{e} dominio y codominio tendr\\\\'{i}a?\")\n        preg4_2.next_to(preg4_1, DOWN, buff=0.5)\n        preg4 = VGroup(preg4_1, preg4_2)\n        preg4.move_to((0, 2.5, 0))\n        preg3_1 = TextMobject(\"Imagina la gr\\\\'{a}fica de una\")\n        preg3_2 = TexMobject(\"\\\\text{funci\\\\'{o}n } f:\\\\mathbb{R} \\\\to \\\\mathbb{R}^2.\")\n        preg3_2.next_to(preg3_1, DOWN)\n        preg3 = VGroup(preg3_1, preg3_2)\n        preg3.move_to((0, 2.5, 0))\n        self.play(FadeOut(planetintro))\n        self.play(Write(intro))\n        self.wait(2)\n        self.play(ReplacementTransform(intro, preg1))\n        self.wait(3)\n        self.play(ReplacementTransform(preg1, preg5))\n        self.wait(3)\n        self.play(ReplacementTransform(preg5, preg6))\n        self.wait(2)\n        self.play(ReplacementTransform(preg6, preg7))\n        self.wait(2)\n        self.play(ReplacementTransform(preg7, preg2))\n        self.wait(2)\n        self.play(ReplacementTransform(preg2, preg4))\n        self.wait(3)\n        self.play(ReplacementTransform(preg4, preg3))\n        self.wait(2)\n        self.play(FadeOut(preg3))\n        self.remove(estrella, planeta, satelite, estrella_sig_aux, planeta_sig_aux, satelite_sig_aux)\n        for i in E:\n            self.remove(i)\n        for j in P:\n            self.remove(j)\n        for k in S:\n            self.remove(k)\n        conex = TextMobject(\"Imaginemos ahora una \\\\'{o}rbita circular:\")\n        conex.to_edge(UP)\n        planeta.move_to(np.array([2, 0, 0]))\n        self.play(Write(conex))\n        self.add(planeta)\n        t = 0\n        dt = 0.2\n        P2 = []\n        while t < 20:\n            self.remove(planeta)\n            planeta_sig = Dot()\n            planeta_sig_aux = Dot(radius=0.01)\n            planeta_sig.move_to(np.array([2 * np.cos(t), 2 * np.sin(t), 0]))\n            planeta_sig.set_color(RED)\n            planeta_sig_aux.move_to(np.array([2 * np.cos(t), 2 * np.sin(t), 0]))\n            P2.append(planeta_sig_aux)\n            self.add(planeta_sig_aux, planeta_sig)\n            self.wait(0.1)\n            planeta = planeta_sig\n            t = t + dt\n        preg_vel1 = TextMobject(\"\u00bfQu\\\\'{e} tipo de funci\\\\'{o}n necesitamos para conocer\")\n        preg_vel2 = TextMobject(\"la velocidad del planeta en cada posici\\\\'{o}n?\")\n        preg_vel2.next_to(preg_vel1, DOWN)\n        preg_vel = VGroup(preg_vel1, preg_vel2)\n        preg_vel.to_edge(UP)\n        expl1 = TextMobject('Pensemos en la velocidad como una flecha.')\n        expl1.to_edge(UP)\n        expl2 = TextMobject(\"As\\\\'{i}, a cada punto de la \\\\'{o}rbita le corresponde una flecha.\")\n        expl2.to_edge(UP)\n        self.play(ReplacementTransform(conex, preg_vel))\n        self.wait(2)\n        self.play(ReplacementTransform(preg_vel, expl1))\n        self.wait()\n        self.play(ReplacementTransform(expl1, expl2))\n        self.remove(planeta)\n        for i in P2:\n            self.remove(i)\n        t = 0\n        dt = 0.2\n        P2 = []\n        planeta_vel = Vector(direction=np.array([-2 * np.sin(t), 2 * np.cos(t), 0]))\n        while t < 20:\n            self.remove(planeta, planeta_vel)\n            planeta_sig = Dot()\n            planeta_sig_aux = Dot(radius=0.01)\n            planeta_vel_sig = Vector(direction=np.array([-2 * np.sin(t), 2 * np.cos(t), 0]))\n            planeta_sig.move_to(np.array([2 * np.cos(t), 2 * np.sin(t), 0]))\n            planeta_sig.set_color(RED)\n            planeta_vel_sig.move_to(np.array([2 * np.cos(t) - np.sin(t), 2 * np.sin(t) + np.cos(t), 0]))\n            planeta_sig_aux.move_to(np.array([2 * np.cos(t), 2 * np.sin(t), 0]))\n            P2.append(planeta_sig_aux)\n            self.add(planeta_sig_aux, planeta_sig, planeta_vel_sig)\n            self.wait(0.1)\n            planeta = planeta_sig\n            planeta_vel = planeta_vel_sig\n            t = t + dt\n        self.remove(planeta, planeta_vel)\n        for i in P2:\n            self.remove(i)\n        self.wait()\n        self.play(FadeOut(expl2))\n        title = TextMobject('Como cada flecha se puede representar con un par ordenado,')\n        title2 = TextMobject('esto nos hace pensar en funciones del plano en el plano.')\n        title2.next_to(title, DOWN)\n        transform_title = TextMobject(\"Estas funciones suelen verse as\\\\'{i}:\").scale(1.5)\n        efe = TexMobject('F(x,y)=(f_x(x,y),f_y(x,y))').scale(1.3)\n        curl = TexMobject('F(x,y)=(-y,x)').scale(1.3)\n        efe.scale(1.5)\n        vector_field_curl = VectorField(curlfunc, x_min=-5, x_max=5, y_min=-3, y_max=2.6)\n        ltkvolt = TexMobject('F(x,y)=(\\\\alpha x-\\\\beta xy, \\\\gamma xy - \\\\delta y), \\\\ \\\\alpha,\\\\beta,\\\\gamma,\\\\delta \\\\in \\\\mathbb{R}^+ ')\n        ltkvolt.scale(1)\n        ltkvolt.shift(3.5 * UP)\n        vector_field_LV = VectorField(lotkavolt, x_min=-5, x_max=5, y_min=-3.5, y_max=2.5)\n        self.play(Write(title), Write(title2))\n        self.wait(2)\n        self.play(Transform(title, transform_title), FadeOutAndShiftDown(title2))\n        self.wait()\n        self.play(FadeOut(title))\n        self.play(Write(efe))\n        self.play(ReplacementTransform(efe, curl))\n        self.wait()\n        self.play(curl.shift, UP * 3.58, run_time=1, path_arc=0)\n        self.play(*[GrowArrow(vec) for vec in vector_field_curl])\n        self.wait()\n        self.play(ReplacementTransform(curl, ltkvolt), ReplacementTransform(vector_field_curl, vector_field_LV))\n        self.wait(1.5)\n        self.play(FadeOut(ltkvolt), FadeOut(vector_field_LV))\n        self.wait()\n        retos = TextMobject('Pensemos ahora en las siguientes preguntas:').scale(1.3)\n        preg1_1 = TextMobject('\u00bfCual es el dominio y contradominio')\n        preg1_2 = TextMobject('de las funciones que acabamos de ver?')\n        preg1_1.next_to(preg1_2, UP)\n        preg1 = VGroup(preg1_1, preg1_2)\n        preg2_1 = TextMobject('Trata de imaginar funciones con dominio/contradominio')\n        preg2_2 = TexMobject('\\\\text{en } \\\\mathbb{R}^3 \\\\text{ y en } \\\\mathbb{R}^4.')\n        preg2_2.next_to(preg2_1, DOWN)\n        preg2 = VGroup(preg2_1, preg2_2)\n        extra = TextMobject('Intenta dibujar las siguientes funciones:')\n        extra.move_to(np.array([0, 2, 0]))\n        campo1 = TexMobject('F_1(x,y)=(0,-g)\\\\ g\\\\in\\\\mathbb{R}^{+}')\n        campo1.next_to(extra, DOWN)\n        campo2 = TexMobject('F_2(x,y)=(B,-g)\\\\ B\\\\in\\\\mathbb{R},g\\\\in\\\\mathbb{R}^{+}')\n        campo2.next_to(campo1, DOWN)\n        campo3 = TexMobject('F_3(x,y)=(x,x)')\n        campo3.next_to(campo2, DOWN)\n        gropuo = VGroup(campo1, campo2, campo3)\n        masretos = TextMobject(\"Encuentra m\\\\'{a}s retos en el c\\\\'{o}digo de este video.\").shift(2 * DOWN)\n        self.play(Write(retos))\n        self.wait()\n        self.play(ReplacementTransform(retos, preg1))\n        self.wait()\n        self.play(ApplyMethod(preg1.to_edge, UP))\n        self.play(Write(preg2))\n        self.wait()\n        self.play(ApplyMethod(preg2.to_edge, DOWN))\n        self.play(FadeOut(preg1), FadeOut(preg2))\n        self.play(Write(extra))\n        self.play(Write(campo1))\n        self.wait()\n        self.play(Write(campo2))\n        self.wait()\n        self.play(Write(campo3))\n        self.wait()\n        self.play(Write(masretos))\n        self.wait()\n        self.remove(extra, campo1, campo2, campo3, masretos)\n        autor1 = TextMobject(\"Bruno Ram\\\\'{i}rez\")\n        autor1.scale(0.8)\n        contact1 = TextMobject('GitHub: @brunormzg')\n        contact1.scale(0.6)\n        contact1.next_to(autor1, DOWN)\n        aut1 = VGroup(autor1, contact1)\n        autor2 = TextMobject('Donaldo Mora')\n        autor2.scale(0.8)\n        autor2.next_to(contact1, DOWN)\n        contact2 = TextMobject('Instagram: donal\\\\_mora')\n        contact2.scale(0.6)\n        contact2.next_to(autor2, DOWN)\n        aut2 = VGroup(autor2, contact2)\n        autor3 = TextMobject('Rodrigo Moreno')\n        autor3.scale(0.8)\n        autor3.next_to(contact2, DOWN)\n        contact3 = TextMobject('Instagram: \\\\_nosoyro')\n        contact3.scale(0.6)\n        contact3.next_to(autor3, DOWN)\n        aut3 = VGroup(autor3, contact3)\n        self.play(Write(aut1), Write(aut2), Write(aut3))"}]}
{"messages": [{"role": "user", "content": "Display two SVG shield images, fade them out, and then display three new SVG shield images."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass escudo(Scene):\n\n    def construct(self):\n        A = SVGMobject('C:\\\\manim\\\\manim-master\\\\manim-master\\\\assets\\\\svg_images\\\\escudo_f_c')\n        B = SVGMobject('C:\\\\manim\\\\manim-master\\\\manim-master\\\\assets\\\\svg_images\\\\escudo_unam')\n        A.set_fill(opacity=0).set_stroke(WHITE, 0.65).scale(2).move_to(np.array([-3, 0, 0]))\n        B.set_fill(opacity=0).set_stroke(WHITE, 0.65).scale(2).move_to(np.array([3, 0, 0]))\n        self.play(ShowCreation(A), ShowCreation(B), run_time=10)\n        self.wait()\n        self.play(FadeOut(A), FadeOut(B))\n        C = SVGMobject('C:\\\\manim\\\\manim-master\\\\manim-master\\\\assets\\\\svg_images\\\\escudo_insta').set_fill(opacity=0.4).set_stroke(WHITE, 0.65).scale(1).move_to(np.array([-3, 2.5, 0]))\n        D = SVGMobject('C:\\\\manim\\\\manim-master\\\\manim-master\\\\assets\\\\svg_images\\\\escudo_fb').set_fill(opacity=0.4).set_stroke(WHITE, 0.65).scale(1).move_to(np.array([-3, -2.5, 0]))\n        E = SVGMobject('C:\\\\manim\\\\manim-master\\\\manim-master\\\\assets\\\\svg_images\\\\escudo_github').set_fill(opacity=0.4).set_stroke(WHITE, 0.65).scale(1).move_to(np.array([-3, 0, 0]))\n        self.play(Write(C), Write(D), Write(E), run_time=5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the graph of $f(x,y,z) = \\lVert (x,y,z) \\rVert$ in $\\mathbb{R}^4$ by animating level sets of the function as spheres of increasing radius."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass grafica_r4(ThreeDScene):\n\n    def get_numer_labels_to_numberline(self, number_line, x_max=None, x_min=0, buff=0.2, step_label=1, **tex_kwargs):\n        labels = VGroup()\n        x_max = number_line.x_max\n        for x in range(x_min, x_max + 1, step_label):\n            x_label = TexMobject(f'{x}', **tex_kwargs)\n            x_label.next_to(number_line.number_to_point(x), DOWN, buff=buff)\n            labels.add(x_label)\n        return labels\n\n    def get_number_line_group(self, label, x_max, unit_size, v_tracker, step_label=1, **number_line_config):\n        number_label = TexMobject(label)\n        arrow = Arrow(UP, DOWN, buff=0).set_height(0.5)\n        number_line = NumberLine(x_min=0, x_max=x_max, unit_size=unit_size, numbers_with_elongated_ticks=[], **number_line_config)\n        labels = self.get_numer_labels_to_numberline(number_line, step_label=step_label, height=0.2)\n        arrow.next_to(number_line.number_to_point(0), UP, buff=0)\n        label = VGroup(arrow, number_label)\n        number_label.next_to(arrow, UP, buff=0.1)\n        numer_group = VGroup(label, number_line, labels)\n        label.add_updater(lambda mob: mob.next_to(number_line.number_to_point(v_tracker.get_value()), UP, buff=0))\n        return numer_group\n\n    def construct(self):\n        axis_config = {'x_min': -4, 'x_max': 4, 'y_min': -4, 'y_max': 4, 'z_min': -4, 'z_max': 4, 'x_labeled_nums': [i for i in range(-4, -5)], 'y_labeled_nums': [i for i in range(-4, -5)]}\n        axis_config2 = {'x_min': -4, 'x_max': 4, 'y_min': -4, 'y_max': 4, 'z_min': -4, 'z_max': 4}\n        reglaf = TextMobject('$f(x,y,z) = \\\\lVert (x,y,z) \\\\rVert$').to_corner(UL)\n        reglaf.bg = SurroundingRectangle(reglaf, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        reglaf.group = VGroup(reglaf.bg, reglaf)\n        ejes = ThreeDAxes(**axis_config)\n        ejes.add(ejes.get_axis_labels())\n        ejes.axis_labels[0].rotate(PI / 2, axis=RIGHT)\n        ejes.axis_labels[1].rotate(PI / 2, axis=RIGHT)\n        ejes2 = ThreeDAxes(**axis_config2).shift(3 * LEFT).scale(0.5)\n        esf2 = Sphere(resolution=(30, 30), radius=3, opacity=100).set_color(GREEN_E).move_to(ejes2.get_center()).scale(0.5)\n        fle = Arrow(start=(-1, 0, 0), end=(1, 0, 0), color=WHITE).shift(0.3 * RIGHT)\n        ffl = TexMobject('f').next_to(fle, DOWN)\n        flecha = VGroup(ffl, fle)\n        rad = ValueTracker(0)\n        esf = Sphere(resolution=(30, 30), radius=rad.get_value()).set_color_by_gradient(BLUE, BLUE_D, PURPLE, PURPLE_D)\n\n        def upd_for_sphere(obj):\n            c = obj\n            radius = rad.get_value()\n            new_c = Sphere(resolution=(50, 50), radius=radius).set_color_by_gradient('#ca31e8', '#b55eff', '#3986ff')\n            c.become(new_c)\n        text_1 = TextMobject('Cuando $f(x,y,z)=t=$')\n        fx_tex = DecimalNumber(rad.get_value()).next_to(text_1, RIGHT)\n\n        def upd_for_decimal(obj):\n            obj.set_value(rad.get_value())\n            self.add_fixed_in_frame_mobjects(obj)\n        Group1 = VGroup(fx_tex, text_1).to_corner(DR)\n        Group1.bg = SurroundingRectangle(Group1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group2 = VGroup(Group1.bg, text_1)\n        fx_number_line_group = self.get_number_line_group('t', 3, 1, step_label=1, v_tracker=fx_tex, tick_frequency=1)\n        fx_number_line_group.to_corner(DL)\n        num_lin = NumberLine(x_min=0, x_max=3, tick_frequency=1)\n        n_l_lab = self.get_numer_labels_to_numberline(num_lin, step_label=1, height=0.2)\n        n_l = VGroup(num_lin, n_l_lab).shift(2.2 * RIGHT)\n        linea = Line(start=(-1.5, 0, 0), end=(1.5, 0, 0), color=MAROON, width=9, stroke_width=9).move_to(n_l.get_center()).shift(0.1 * UP)\n        title = TextMobject('\u00bfGr\u00e1ficas en $\\\\mathbb{R}^4$?').scale(1.5)\n        t_1 = TextMobject('Puede que hayas escuchado que s\u00f3lo\\\\\\\\\\n                             se pueden graficar funciones tales que sus gr\u00e1ficas\\\\\\\\\\n                             son subconjuntos de $\\\\mathbb{R}^2$ o $\\\\mathbb{R}^3$, \\\\\\\\\\n                             veamos...')\n        t_2 = TextMobject('Considera ', '$f(x,y,z)$', '$ = \\\\lVert (x,y,z) \\\\rVert$,\\\\\\\\', '\\n                             entonces la gr\u00e1fica de $f$ es \\\\\\\\', '\\n                             $Gr(f)$', '$=\\\\{(x,y,z,f(x,y,z))\\\\in\\\\mathbb{R}^4|(x,y,z)\\\\in D\\\\}$, \\\\\\\\\\n                             donde ', '$D$', ' es el ', 'dominio', ' de ', '$f$', '.')\n        t_2[1].set_color(RED)\n        t_2[4].set_color_by_gradient(BLUE, BLUE_D, PURPLE, PURPLE_D)\n        t_2[-6].set_color(GREEN_D)\n        t_2[-4].set_color(GREEN_D)\n        t_2_1 = VGroup(t_2[0], t_2[1], t_2[2])\n        t_2_2 = VGroup(t_2[3], t_2[4], t_2[5], t_2[6], t_2[7], t_2[8], t_2[9], t_2[10], t_2[11])\n        t_3_1 = TextMobject('Si tomamos ', '$D$', ' como la esfera compacta rellena \\\\\\\\\\n                             de radio 3 con centro en el origen,').to_edge(UP)\n        t_3_2 = TextMobject('tenemos que ', '$f$', '$:$', '$D$', '$\\\\subset \\\\mathbb{R}^3\\\\rightarrow \\\\mathbb{R}$, \\\\\\\\', '\\n                             entonces ', '$Im(f)$', '$=[0,3]$.').to_edge(DOWN)\n        t_3_1[1].set_color(GREEN_D)\n        t_3_2[3].set_color(GREEN_D)\n        t_3_2[-2].set_color(MAROON)\n        t_3 = VGroup(t_3_1, t_3_2)\n        t_4 = TextMobject('Para la gr\u00e1fica tomamos cuatro ejes: $x,y,z,t$\\\\\\\\', '\\n                             donde los ejes $x,y,z$ los usamos de manera est\u00e1ndar\\\\\\\\\\n                             para representar a los puntos del ', 'dominio', ' de $f$\\\\\\\\', '\\n                             y el ', 'eje $t$', ' lo usaremos para las ', 'im\u00e1genes', ' de $f$ \\\\\\\\\\n                             de la siguiente manera:')\n        t_4[2].set_color(GREEN_D)\n        t_4[5].set_color(TEAL)\n        t_4[-2].set_color(MAROON)\n        t_4_1 = VGroup(t_4[1], t_4[2], t_4[3])\n        t_4_2 = VGroup(t_4[4], t_4[5], t_4[6], t_4[7], t_4[8])\n        t_5 = TextMobject('Generamos un video, en el cual,\\\\\\\\\\n                             en el ', 'eje del tiempo $t$', ' representamos los valores de ', '$f$', '.')\n        t_5[1].set_color(TEAL)\n        t_5[-2].set_color(RED)\n        t_6 = TextMobject('De esta manera \\\\\\\\\\n                             $C_t=\\\\{(x,y,z)\\\\in D|f(x,y,z)=t\\\\in [0,3]\\\\}$, \\\\\\\\\\n                             es un conjunto de nivel de $f$,\\\\\\\\\\n                             que en este caso es una ', 'superficie de nivel.')\n        t_6[1].set_color(ORANGE)\n        t_7 = TextMobject('Para cada valor de $t$,\\\\\\\\\\n                             podemos representar en el video esta \\\\\\\\\\n                             ', 'superficie de nivel', ' muy conocida:')\n        t_7[1].set_color(ORANGE)\n        t_8 = TextMobject('Es una esfera hueca, compacta, \\\\\\\\\\n                             con centro en el origen y radio $\\\\sqrt{t}$.')\n        t_9 = TextMobject('Finalmente juntamos estas ', 'superficies de nivel', ' \\\\\\\\ \\n                             en nuestro video y obtenemos la gr\u00e1fica.\\\\\\\\\\n                             \u00a1La ', 'gr\u00e1fica de $f$', ' es un s\u00f3lido en $\\\\mathbb{R}^4$!')\n        t_9[1].set_color(ORANGE)\n        t_9[3].set_color_by_gradient(BLUE, PURPLE)\n        self.play(Write(title))\n        self.wait(2)\n        self.play(FadeOut(title))\n        self.play(Write(t_1))\n        self.wait(9)\n        self.play(ReplacementTransform(t_1, t_2))\n        self.wait(6)\n        self.wait(10)\n        self.play(ReplacementTransform(t_2, t_3_1))\n        self.wait(7)\n        self.play(Write(t_3_2))\n        self.play(ShowCreation(ejes2))\n        self.play(Write(n_l))\n        self.add_foreground_mobjects(esf2)\n        self.play(ShowCreation(esf2))\n        self.wait(4)\n        self.play(Write(flecha))\n        self.play(Write(linea))\n        self.wait(4)\n        self.remove_foreground_mobjects(esf2)\n        self.play(FadeOut(ejes2), FadeOut(esf2), FadeOut(n_l), FadeOut(linea), FadeOut(flecha))\n        self.play(ReplacementTransform(t_3, t_4))\n        self.wait(4)\n        self.wait(6.5)\n        self.wait(6)\n        self.play(ReplacementTransform(t_4, t_5))\n        self.wait(19)\n        self.play(ReplacementTransform(t_5, t_6))\n        self.wait(8.5)\n        self.play(ReplacementTransform(t_6, t_7))\n        self.wait(6.5)\n        self.play(ReplacementTransform(t_7, t_8))\n        self.wait(6)\n        self.play(ReplacementTransform(t_8, t_9))\n        self.wait(8.5)\n        self.play(FadeOut(t_9))\n        self.set_camera_orientation(phi=0.8 * np.pi / 2, theta=1.75 * np.pi, distance=20)\n        self.play(ShowCreation(ejes))\n        self.add_fixed_in_frame_mobjects(reglaf.group)\n        self.play(Write(reglaf.group))\n        self.add_fixed_in_frame_mobjects(Group2)\n        fx_tex.add_updater(upd_for_decimal)\n        self.play(Write(Group2), Write(fx_tex))\n        self.add_fixed_in_frame_mobjects(fx_number_line_group)\n        self.play(Write(fx_number_line_group))\n        self.play(ShowCreation(esf))\n        esf.add_updater(upd_for_sphere)\n        self.wait()\n        self.play(rad.set_value, 3, run_time=4)\n        self.wait()\n        self.play(rad.set_value, 0, run_time=4)\n        self.wait()\n        self.play(*[FadeOut(mob) for mob in self.mobjects])"}]}
{"messages": [{"role": "user", "content": "Visualize the relationship between lines in the xz and yz planes and their corresponding plane in 3D space, illustrating the concept of plane inclination."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Planos(ThreeDScene):\n\n    def l_1(self, t):\n        return np.array([t, 0, 5 * t])\n\n    def l_2(self, t):\n        return np.array([0, t, 3 * t])\n\n    def Plano(self, x, y):\n        return np.array([x, y, 5 * x + 3 * y])\n\n    def construct(self):\n        titulo = TextMobject('Planos y Su Inclinaci\u00f3n').scale(1.5)\n        t_1 = TextMobject('En $\\\\mathbb{R}^3$ un plano puede ser descrito como \\n\\n        una superficie lisa, sin subidas ni bajadas. ')\n        t_2 = TextMobject('Algunos planos son gr\u00e1ficas de funciones de $\\\\mathbb{R}^2$ en $\\\\mathbb{R},$ \\n\\n                            $ f(x,y) = ax + by  \\\\mbox{ con } a,b \\\\in \\\\mathbb{R}.$')\n        t_3 = TextMobject('Cualquier plano no vertical intersecta  \\n\\n        a los planos $xz$ y $yz$ en dos rectas, \\n\\n        cada una en los planos respectivos \\n\\n        son de pendiente $a$ y $b$.')\n        t_4 = TextMobject('Veamos a que nos referimos con esto gr\u00e1ficamente.')\n        t_5 = TextMobject('Tomemos una recta ', '$\\\\mathcal{L}_1$', ' en el plano $xz$ de pediente 5. ').to_edge(UP)\n        t_5.set_color_by_tex_to_color_map({'$\\\\mathcal{L}_1$': TEAL})\n        t_5_bg = SurroundingRectangle(t_5, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_6 = TextMobject('Y otra recta ', '$\\\\mathcal{L}_2$', ' en el plano $yz$ de pendiente 3.').to_edge(UP)\n        t_6.set_color_by_tex_to_color_map({'$\\\\mathcal{L}_2$': RED})\n        t_6_bg = SurroundingRectangle(t_6, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_7 = TextMobject('Ahora observemos que el plano \\n\\n        $f(x,y) = 5x + 3x$ \\n\\n        contiene a ambas rectas.').to_edge(UP)\n        t_7_bg = SurroundingRectangle(t_7, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_8 = TextMobject('Este plano es el \u00fanico que contiene ambas rectas y \\n\\n        por lo tanto este plano queda totalmente \\n\\n        caracterizado por estas.').to_edge(UP)\n        t_8_bg = SurroundingRectangle(t_8, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_9 = TextMobject(' En particular la inclinaci\u00f3n del plano queda determinada por el \\n\\n        vector ', '$(5,3)$', ', es decir por la inclinaci\u00f3n de las rectas. ').to_edge(UP)\n        t_9_bg = SurroundingRectangle(t_9, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_9.set_color_by_tex_to_color_map({'$(5,3)$': GREEN})\n        t_10 = TextMobject('Se puede demostrar que $f:\\\\mathbb{R}^2\\\\rightarrow\\\\mathbb{R}$ es lineal \\n\\n        si y s\u00f3lo si $f(x,y)=ax+by=(a,b)\\\\cdot (x,y)$. ')\n        t_11 = TextMobject('Las gr\u00e1ficas de estas funciones corresponden a todos los \\n\\n        planos no verticales en $\\\\mathbb{R}^3$ que pasan por el origen.')\n        t_12 = TextMobject('\u00bfQu\u00e9 pasa con los planos que no pasan por el origen?')\n        t_13 = TextMobject('\u00bfC\u00f3mo aplica este concepto de inclinaci\u00f3n \\n\\n         para el caso de un plano tangente?')\n        axes = ThreeDAxes(x_min=-4, x_max=4, y_min=-4, y_max=4, z_min=-4, z_max=4, num_axis_pieces=4)\n        recta_1 = ParametricFunction(self.l_1, color=TEAL, t_min=-2, t_max=2)\n        recta_2 = ParametricFunction(self.l_2, color=RED, t_min=-2, t_max=2)\n        plano = ParametricSurface(self.Plano, fill_color=PURPLE_E, checkerboard_colors=[PURPLE_D, PURPLE_E], fill_opacity=0.6, u_min=-2, u_max=2, v_min=-2, v_max=2)\n        inclinacion = Vector(direction=[5, 3, 0], color=GREEN)\n        Group_1 = VGroup(recta_1)\n        Group_2 = VGroup(recta_2)\n        Group_3 = VGroup(plano)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.add_fixed_in_frame_mobjects(titulo)\n        self.play(Write(titulo))\n        self.wait(5)\n        self.play(FadeOut(titulo))\n        self.add_fixed_in_frame_mobjects(t_1)\n        self.play(Write(t_1))\n        self.wait(12)\n        self.play(FadeOut(t_1))\n        self.add_fixed_in_frame_mobjects(t_2)\n        self.play(Write(t_2))\n        self.wait(10)\n        self.play(FadeOut(t_2))\n        self.add_fixed_in_frame_mobjects(t_3)\n        self.play(Write(t_3))\n        self.wait(15)\n        self.play(FadeOut(t_3))\n        self.add_fixed_in_frame_mobjects(t_4)\n        self.play(Write(t_4))\n        self.wait(8)\n        self.play(FadeOut(t_4))\n        self.set_camera_orientation(phi=45 * DEGREES, theta=55 * DEGREES)\n        self.play(LaggedStart(ShowCreation(axes)))\n        self.add_fixed_in_frame_mobjects(t_5_bg, t_5)\n        self.play(Write(t_5_bg), Write(t_5))\n        self.play(LaggedStart(ShowCreation(Group_1)))\n        self.wait(8)\n        self.play(FadeOut(t_5), FadeOut(t_5_bg))\n        self.wait(3)\n        self.add_fixed_in_frame_mobjects(t_6_bg, t_6)\n        self.play(Write(t_6_bg), Write(t_6))\n        self.play(LaggedStart(ShowCreation(Group_2)))\n        self.wait(8)\n        self.play(FadeOut(t_6), FadeOut(t_6_bg))\n        self.wait(2)\n        self.add_fixed_in_frame_mobjects(t_7_bg, t_7)\n        self.play(Write(t_7_bg), Write(t_7))\n        self.play(LaggedStart(ShowCreation(Group_3)))\n        self.wait(15)\n        self.play(FadeOut(t_7), FadeOut(t_7_bg))\n        self.wait(5)\n        self.add_fixed_in_frame_mobjects(t_8_bg, t_8)\n        self.play(Write(t_8_bg), Write(t_8))\n        self.wait(18)\n        self.play(FadeOut(t_8), FadeOut(t_8_bg))\n        self.add_fixed_in_frame_mobjects(t_9_bg, t_9)\n        self.play(Write(t_9_bg), Write(t_9))\n        self.play(FadeIn(inclinacion))\n        self.wait(18)\n        self.play(FadeOut(t_9), FadeOut(t_9_bg))\n        self.play(FadeOut(Group_1), FadeOut(Group_2), FadeOut(Group_3), FadeOut(axes), FadeOut(inclinacion))\n        self.add_fixed_in_frame_mobjects(t_10)\n        self.play(Write(t_10))\n        self.wait(10)\n        self.play(FadeOut(t_10))\n        self.add_fixed_in_frame_mobjects(t_11)\n        self.play(Write(t_11))\n        self.wait(10)\n        self.play(FadeOut(t_11))\n        self.add_fixed_in_frame_mobjects(t_12)\n        self.play(Write(t_12))\n        self.wait(8)\n        self.play(FadeOut(t_12))\n        self.add_fixed_in_frame_mobjects(t_13)\n        self.play(Write(t_13))\n        self.wait(10)\n        self.play(FadeOut(t_13))"}]}
{"messages": [{"role": "user", "content": "Demonstrate the effects of vertical translation, scaling, and reflections on a 3D surface, followed by horizontal translations."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Composicion_de_Superficie_Con_Funciones(ThreeDScene):\n\n    def construct(self):\n        titulo = TextMobject('Traslaciones y Homotecias \\n\\n                                en Superficies').scale(1.5)\n        text1 = TextMobject('Tomemos $f(x,y)=0.2\\\\sin[7(x+y)]$')\n        text2 = TextMobject('Una translaci\u00f3n vertical de la superficie es de \\n\\n                            la forma: $f(x,y)+k$').move_to(3 * UP)\n        text2.bg = SurroundingRectangle(text2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_2 = VGroup(text2.bg, text2)\n        text3 = TextMobject('Por ejemplo: $f(x,y)-2$ ').move_to(3 * UP)\n        text3.bg = SurroundingRectangle(text3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_3 = VGroup(text3.bg, text3)\n        text4 = TexMobject('f(x,y)+3').move_to(2.7 * UP)\n        text4.bg = SurroundingRectangle(text4, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_4 = VGroup(text4.bg, text4)\n        text5 = TextMobject('Tambi\u00e9n podemos multiplicar superficies por un escalar, \\n\\n                                    es decir: $kf(x,y)$.').move_to(3 * UP)\n        text5.bg = SurroundingRectangle(text5, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_5 = VGroup(text5.bg, text5)\n        text6 = TextMobject('Si $k=0.1$, la gr\u00e1fica se encoje verticalmente hacia el plano \\n\\n                                del dominio $xy$').move_to(2.8 * UP)\n        text6.bg = SurroundingRectangle(text6, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_6 = VGroup(text6.bg, text6)\n        text7 = TextMobject('Si $k=2$, la gr\u00e1fica se estira verticalmente \\n\\n                                alejando los puntos del plano $xy$ ').move_to(3 * UP)\n        text7.bg = SurroundingRectangle(text7, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_7 = VGroup(text7.bg, text7)\n        text8 = TextMobject('Tambi\u00e9n podemos reflejar superficies.\\n\\n                            Sea $f_0(x,y)=[\\\\sin(3(x+y))+y]0.3$').move_to(3 * UP)\n        text8.bg = SurroundingRectangle(text8, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_8 = VGroup(text8.bg, text8)\n        text8_1 = TextMobject('Si $k=-1$, la gr\u00e1fica de $kf_0(x,y)$ es la reflexi\u00f3n de la gr\u00e1fica \\n\\n                                de $f_0$ respecto al plano $yz$. ').move_to(3 * UP)\n        text9 = TextMobject('Si tomamos $f_1(x,y)=f_0(x,-y)$, la gr\u00e1fica de $f_1$ \\n\\n                                es la reflexi\u00f3n de la gr\u00e1fica de $f_0$ respecto al plano $xz$.').move_to(2.5 * UP)\n        text9.bg = SurroundingRectangle(text9, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_9 = VGroup(text9.bg, text9)\n        text10 = TextMobject('Mientras que la gr\u00e1fica de $f_2(x,y)=f_1(-x,-y)$ es una \\n\\n                                    reflexi\u00f3n de la gr\u00e1fica de $f_1$ respecto al eje vertical. ').move_to(3 * UP)\n        text10.bg = SurroundingRectangle(text10, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_10 = VGroup(text10.bg, text10)\n        text11 = TextMobject('\u00bfQu\u00e9 pasa con $f(k(x,y))$, con $k\\\\in\\\\mathbb{R}$? ')\n        text12 = TextMobject('Tambi\u00e9n podemos hacer traslaciones horizontales. \\n\\n                                    Por ejemplo:').move_to(2.7 * UP)\n        text12.bg = SurroundingRectangle(text12, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_12 = VGroup(text12.bg, text12)\n        text13 = TextMobject('$g(x,y)=x^{2}+y^{2}\\\\sin^{2}(y)$').move_to(3 * DOWN)\n        text13.bg = SurroundingRectangle(text13, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_13 = VGroup(text13.bg, text13)\n        text14 = TextMobject('La gr\u00e1fica de $g((x,y)+(2,0))$ se ve: ').move_to(3 * DOWN)\n        text14.bg = SurroundingRectangle(text14, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_14 = VGroup(text14.bg, text14)\n        text15 = TextMobject('Pero la de $g((x,y)+(0,2))$: ').move_to(3 * DOWN)\n        text15.bg = SurroundingRectangle(text15, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_15 = VGroup(text15.bg, text15)\n        text16 = TextMobject('Modifica el c\u00f3digo para crear m\u00e1s ejemplos.')\n        ejes = ThreeDAxes(x_max=4.7, y_max=4.5)\n        eje_x = TexMobject('x').move_to(5.1 * RIGHT).scale(1.3)\n        eje_y = TexMobject('y', fill_color=BLACK).move_to(5 * UP).scale(1.3)\n        axes = VGroup(ejes, eje_x, eje_y)\n        superficie1 = superficie_1()\n        fondo = Rectangle(height=1, width=10, fill_opacity=1, fill_color=BLACK).move_to(text11)\n        k1 = -2\n        superficie2 = superficie_1().move_to([0, 0, k1])\n        k2 = 3\n        superficie3 = superficie_1().move_to([0, 0, k2])\n        superficie4 = superficie_2()\n        superficie5 = superficie_3()\n        superficie6 = superficie_4()\n        r1 = 1\n        k1 = 2\n        superficie7 = superficie_5()\n        superficie7_1 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (u + v)) + v) * 0.3]), v_min=-2.5, v_max=-1.5, u_min=-2.5, u_max=-1.5, fill_opacity=1, checkerboard_colors=[RED, RED])\n        superficie7_2 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (u + v)) + v) * 0.3]), v_min=-2.5, v_max=-1.5, u_min=2.5, u_max=1.5, fill_opacity=1, checkerboard_colors=[TEAL_D, TEAL_D])\n        superficie7_3 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (u + v)) + v) * 0.3]), v_min=2.5, v_max=1.5, u_min=-2.5, u_max=-1.5, fill_opacity=1, checkerboard_colors=[PURPLE_E, PURPLE_E])\n        superficie7_4 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (u + v)) + v) * 0.3]), v_min=2.5, v_max=1.5, u_min=2.5, u_max=1.5, fill_opacity=1, checkerboard_colors=[PINK, PINK])\n        superficie7_reflejadayz = superficie_5_reflejada()\n        superficie7_reflejadayz1 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (u - v)) - v) * 0.3]), v_min=-2.5, v_max=-1.5, u_min=-2.5, u_max=-1.5, fill_opacity=1, checkerboard_colors=[PURPLE_E, PURPLE_E])\n        superficie7_reflejadayz2 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (u - v)) - v) * 0.3]), v_min=-2.5, v_max=-1.5, u_min=2.5, u_max=1.5, fill_opacity=1, checkerboard_colors=[PINK, PINK])\n        superficie7_reflejadayz3 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (u - v)) - v) * 0.3]), v_min=2.5, v_max=1.5, u_min=-2.5, u_max=-1.5, fill_opacity=1, checkerboard_colors=[RED, RED])\n        superficie7_reflejadayz4 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (u - v)) - v) * 0.3]), v_min=2.5, v_max=1.5, u_min=2.5, u_max=1.5, fill_opacity=1, checkerboard_colors=[TEAL_D, TEAL_D])\n        superficie8 = superficie_5_reflejada1()\n        superficie7_reflejada1 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (-u + v)) + v) * 0.3]), v_min=-2.5, v_max=-1.5, u_min=-2.5, u_max=-1.5, fill_opacity=1, checkerboard_colors=[TEAL_D, TEAL_D], resolution=(10, 10))\n        superficie7_reflejada2 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (-u + v)) + v) * 0.3]), v_min=-2.5, v_max=-1.5, u_min=2.5, u_max=1.5, fill_opacity=1, checkerboard_colors=[RED, RED])\n        superficie7_reflejada3 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (-u + v)) + v) * 0.3]), v_min=2.5, v_max=1.5, u_min=-2.5, u_max=-1.5, fill_opacity=1, checkerboard_colors=[PINK, PINK])\n        superficie7_reflejada4 = ParametricSurface(lambda u, v: np.array([u, v, (np.sin(3 * (-u + v)) + v) * 0.3]), v_min=2.5, v_max=1.5, u_min=2.5, u_max=1.5, fill_opacity=1, checkerboard_colors=[PURPLE_E, PURPLE_E], resolution=(7, 7))\n        superficie9 = superficie_6()\n        superficie10 = superficie_6_1()\n        superficie11 = superficie_6_2()\n        self.play(Write(titulo))\n        self.wait(6)\n        self.play(FadeOut(titulo))\n        self.set_camera_orientation(0.7 * np.pi / 2, -0.35 * np.pi, distance=12)\n        self.add_fixed_in_frame_mobjects(text1)\n        self.play(Write(text1))\n        self.wait(4)\n        self.play(text1.shift, 3 * UP, runtime=3)\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie1))\n        self.wait(3)\n        self.play(FadeOut(text1))\n        self.add_fixed_in_frame_mobjects(t_2)\n        self.play(Write(t_2))\n        self.wait(8)\n        self.play(FadeOut(t_2))\n        self.add_fixed_in_frame_mobjects(t_3)\n        self.play(Write(t_3))\n        self.wait(5)\n        self.play(ReplacementTransform(superficie1, superficie2))\n        self.wait(5)\n        self.play(FadeOut(t_3))\n        self.add_fixed_in_frame_mobjects(t_4)\n        self.play(Write(t_4))\n        self.wait(5)\n        self.play(ReplacementTransform(superficie2, superficie3))\n        self.wait(6)\n        self.play(FadeOut(t_4))\n        self.play(FadeOut(superficie3))\n        self.add_fixed_in_frame_mobjects(t_5)\n        self.play(Write(t_5))\n        self.wait(7)\n        self.play(ShowCreation(superficie4))\n        self.wait(4)\n        self.play(FadeOut(t_5))\n        self.add_fixed_in_frame_mobjects(t_6)\n        self.play(Write(t_6))\n        self.wait(6)\n        self.play(ReplacementTransform(superficie4, superficie5))\n        self.wait(6)\n        self.play(FadeOut(t_6))\n        self.add_fixed_in_frame_mobjects(t_7)\n        self.play(Write(t_7))\n        self.wait(9)\n        self.play(ReplacementTransform(superficie5, superficie6))\n        self.wait(5)\n        self.play(FadeOut(t_7))\n        self.play(FadeOut(superficie6))\n        self.add_fixed_in_frame_mobjects(t_8)\n        self.play(Write(t_8))\n        self.wait(4)\n        self.play(ShowCreation(superficie7), ShowCreation(superficie7_1), ShowCreation(superficie7_2), ShowCreation(superficie7_3), ShowCreation(superficie7_4))\n        self.wait()\n        self.play(FadeOut(t_8))\n        self.add_fixed_in_frame_mobjects(t_9)\n        self.play(Write(t_9))\n        self.wait(5)\n        self.wait(3)\n        self.play(ReplacementTransform(superficie7, superficie7_reflejadayz), ReplacementTransform(superficie7_1, superficie7_reflejadayz1), ReplacementTransform(superficie7_2, superficie7_reflejadayz2), ReplacementTransform(superficie7_3, superficie7_reflejadayz3), ReplacementTransform(superficie7_4, superficie7_reflejadayz4))\n        self.wait(4)\n        self.play(FadeOut(t_9))\n        self.add_fixed_in_frame_mobjects(t_10)\n        self.play(Write(t_10))\n        self.wait(11)\n        self.play(ReplacementTransform(superficie7_reflejadayz, superficie8), ReplacementTransform(superficie7_reflejadayz1, superficie7_reflejada1), ReplacementTransform(superficie7_reflejadayz2, superficie7_reflejada2), ReplacementTransform(superficie7_reflejadayz3, superficie7_reflejada3), ReplacementTransform(superficie7_reflejadayz4, superficie7_reflejada4))\n        self.wait(5)\n        self.play(FadeOut(t_10))\n        self.play(FadeOut(superficie8), FadeOut(superficie7_reflejada1), FadeOut(superficie7_reflejada2), FadeOut(superficie7_reflejada3), FadeOut(superficie7_reflejada4))\n        self.add_fixed_in_frame_mobjects(fondo)\n        self.add_fixed_in_frame_mobjects(text11)\n        self.play(Write(text11), ShowCreation(fondo))\n        self.wait(8)\n        self.play(FadeOut(text11), FadeOut(fondo))\n        self.add_fixed_in_frame_mobjects(t_12)\n        self.play(Write(t_12))\n        self.wait(7)\n        self.play(FadeOut(t_12))\n        self.add_fixed_in_frame_mobjects(t_13)\n        self.play(Write(t_13))\n        self.wait(6)\n        self.play(ShowCreation(superficie9))\n        self.wait(5)\n        self.play(FadeOut(t_13))\n        self.add_fixed_in_frame_mobjects(t_14)\n        self.play(Write(t_14))\n        self.wait(7)\n        self.play(ReplacementTransform(superficie9, superficie10))\n        self.wait(5)\n        self.play(FadeOut(t_14))\n        self.add_fixed_in_frame_mobjects(t_15)\n        self.play(Write(t_15))\n        self.wait(6)\n        self.play(ReplacementTransform(superficie10, superficie11))\n        self.wait(5)\n        self.play(FadeOut(t_15), FadeOut(axes), FadeOut(superficie11))\n        self.add_fixed_in_frame_mobjects(text16)\n        self.play(Write(text16))\n        self.wait(8)\n        self.play(FadeOut(text16))"}]}
{"messages": [{"role": "user", "content": "Present a series of animated explanations and visualizations demonstrating the concept of limits of quotients of functions of two variables."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Limite_de_cocientes_de_dos_variables(ThreeDScene):\n\n    def parte0(self):\n        titulo = TextMobject('L\u00edmite de Cocientes \\n\\n                                de Funciones de Dos Variables').scale(1.5)\n        text1 = TextMobject('Si estamos analizando el l\u00edmite de un cociente \\n\\n                             de dos funciones de varias variables, en caso \\n\\n                             de que ambas tengan l\u00edmite y el del denominador \\n\\n                             sea diferente de cero, ya sabemos que el l\u00edmite \\n\\n                             del cociente es el cociente de los l\u00edmites.')\n        text2 = TextMobject('\u00bfQu\u00e9 pasa en otras situaciones? \\n\\n                             Veamos algunos ejemplos.')\n        text3 = TextMobject('Tengamos presente que en este caso hay \\n\\n                             diversas maneras de analizar el l\u00edmite: \\n\\n                             m\u00e9trica, l\u00edmite direccional, l\u00edmite por \\n\\n                             trayectorias o con suscesiones.')\n        self.play(Write(titulo))\n        self.wait(1)\n        self.play(FadeOut(titulo))\n        self.play(Write(text1), run_time=3)\n        self.wait(5)\n        self.play(FadeOut(text1))\n        self.play(Write(text2))\n        self.wait(2)\n        self.play(FadeOut(text2))\n        self.play(Write(text3))\n        self.wait(5)\n        self.play(FadeOut(text3))\n\n    def parte1(self):\n        text5 = TextMobject('Sea $f:\\\\mathbb{R}^{2}-\\\\{(x,y)\\\\in \\\\mathbb{R}^{2}:x=0\\\\ \\\\text{\u00f3}\\\\ y=0\\\\}\\\\rightarrow\\\\mathbb{R}$', ' $$f(x,y)=\\\\frac{1}{xy}$$ ')\n        t_5_1 = TextMobject('$$f(x,y)=\\\\frac{1}{xy}$$').move_to(3 * UP)\n        t_5_1.bg = SurroundingRectangle(t_5_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text5_1 = VGroup(t_5_1.bg, t_5_1)\n        t_6 = TextMobject('Notamos que en este ejemplo el numerador es constante \\n\\n                           y el denominador tiende a cero conforme la variable \\n\\n                           tiende a $\\\\vec{0}$. \u00bfEl l\u00edmite de $f$ diverge a infinito?').move_to(3 * DOWN).scale(0.7)\n        t_6.bg = SurroundingRectangle(t_6, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text6 = VGroup(t_6.bg, t_6)\n        text6_1 = TextMobject('Si nos acercamos al origen por la direcci\u00f3n dada \\n\\n                               por la recta identidad, la funci\u00f3n diverge a $\\\\infty$.').move_to(3 * UP)\n        text6_1.bg = SurroundingRectangle(text6_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        g2_text6_1 = VGroup(text6_1.bg, text6_1)\n        ejes = ThreeDAxes(x_min=-5, x_max=5, y_min=-5, y_max=5, z_min=-4, z_max=4)\n        x_label = TexMobject('x').scale(0.75).move_to((5.5, 0.3, 0))\n        y_label = TexMobject('y').scale(0.75).move_to((0.3, 5.5, 0))\n        axes = VGroup(ejes, x_label, y_label)\n        superficie1_1 = superficie2_1_1()\n        superficie1_2 = superficie2_1_2()\n        superficie1_3 = superficie2_1_3()\n        superficie1_4 = superficie2_1_4()\n        superficie = VGroup(superficie1_1, superficie1_2, superficie1_3, superficie1_4)\n        t1_1 = ValueTracker(-3)\n        punto_convergencia1 = Sphere(radius=0.05, fill_opacity=1, fill_color=RED).move_to([-3, -3, 1 / 9])\n        t1_1f = -0.45\n\n        def mov_sup1(obj):\n            t = t1_1.get_value()\n            punto_convergencia1.become(Sphere(radius=0.05, fill_opacity=1, fill_color=RED).move_to([t, t, t ** (-2)]))\n        punto_convergencia1.add_updater(mov_sup1)\n        t1_2 = ValueTracker(3)\n        punto_convergencia2 = Sphere(radius=0.05, fill_opacity=1, fill_color=RED).move_to([3, 3, 1 / 9])\n        t1_2f = 0.3\n\n        def mov_sup2(obj):\n            t = t1_2.get_value()\n            punto_convergencia2.become(Sphere(radius=0.05, fill_opacity=1, fill_color=RED).move_to([t, t, t ** (-2)]))\n        punto_convergencia2.add_updater(mov_sup2)\n        self.play(Write(text5))\n        self.wait(7)\n        self.play(FadeOut(text5))\n        self.move_camera(phi=80 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 2))\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie))\n        self.add_fixed_in_frame_mobjects(text5_1)\n        self.play(Write(text5_1))\n        self.wait(2)\n        self.add_fixed_in_frame_mobjects(text6)\n        self.play(Write(text6))\n        self.wait(5)\n        self.play(FadeOut(text5_1), FadeOut(text6))\n        self.add_fixed_in_frame_mobjects(g2_text6_1)\n        self.play(Write(g2_text6_1))\n        self.add(punto_convergencia2, punto_convergencia1)\n        self.play(t1_2.set_value, t1_2f, t1_1.set_value, t1_1f, run_time=6)\n        self.wait()\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n\n    def parte2(self):\n        text7 = TextMobject('Sin embargo, si nos acercamos por la recta menos \\n\\n                                identidad, la funci\u00f3n diverge a $-\\\\infty$.')\n        ejes = ThreeDAxes(x_min=-5, x_max=5, y_min=-5, y_max=5, z_min=-4, z_max=4)\n        x_label = TexMobject('x').scale(0.75).move_to((5.5, 0.3, 0))\n        y_label = TexMobject('y').scale(0.75).move_to((0.3, 5.5, 0))\n        axes = VGroup(ejes, x_label, y_label)\n        superficie1_1 = superficie2_1_1()\n        superficie1_2 = superficie2_1_2()\n        superficie1_3 = superficie2_1_3()\n        superficie1_4 = superficie2_1_4()\n        superficie = VGroup(superficie1_1, superficie1_2, superficie1_3, superficie1_4)\n        t1_1 = ValueTracker(-3)\n        punto_convergencia1 = Sphere(radius=0.05, fill_opacity=1, fill_color=RED).move_to([-3, -3, 1 / 9])\n        t1_1f = -0.45\n\n        def mov_sup1(obj):\n            t = t1_1.get_value()\n            punto_convergencia1.become(Sphere(radius=0.05, fill_opacity=1, fill_color=RED).move_to([t, -t, -t ** (-2)]))\n        punto_convergencia1.add_updater(mov_sup1)\n        t1_2 = ValueTracker(3)\n        punto_convergencia2 = Sphere(radius=0.05, fill_opacity=1, fill_color=RED).move_to([3, 3, 1 / 9])\n        t1_2f = 0.3\n\n        def mov_sup2(obj):\n            t = t1_2.get_value()\n            punto_convergencia2.become(Sphere(radius=0.05, fill_opacity=1, fill_color=RED).move_to([t, -t, -t ** (-2)]))\n        punto_convergencia2.add_updater(mov_sup2)\n        self.add_fixed_in_frame_mobjects(text7)\n        self.play(Write(text7))\n        self.wait(5)\n        self.play(FadeOut(text7))\n        self.move_camera(phi=70 * DEGREES, theta=(30 - 45) * DEGREES, frame_center=(0, 0, -1))\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie))\n        self.add(punto_convergencia2, punto_convergencia1)\n        self.play(t1_2.set_value, t1_2f, t1_1.set_value, t1_1f, run_time=6)\n        self.play(FadeOut(punto_convergencia2), FadeOut(punto_convergencia1))\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n\n    def partesucesiones(self):\n        t_1 = TextMobject('De acuerdo al Teorema de l\u00edmite de funciones con \\n\\n                             l\u00edmites direccionales, podemos concluir que $f$ \\n\\n                             diverge en $\\\\vec{0}$ pero no diverge a infinito en \\n\\n                             ese punto.')\n        t_2 = TextMobject('Podemos verificar lo anterior usando l\u00edmite con \\n\\n                             sucesiones')\n        t_3 = TextMobject('Como hay dos sucesiones que convergen al origen \\n\\n                             en el dominio, cuyas im\u00e1genes divergen a m\u00e1s y \\n\\n                             menos infinito respectivamente, concluimos que \\n\\n                             el l\u00edmite en el punto $(0,0)$ no existe y no \\n\\n                             diverge a infinito ni a menos infinito.')\n        ejes = ThreeDAxes(x_min=-5, x_max=5, y_min=-5, y_max=5, z_min=-4, z_max=4)\n        x_label = TexMobject('x').scale(0.75).move_to((5.5, 0.3, 0))\n        y_label = TexMobject('y').scale(0.75).move_to((0.3, 5.5, 0))\n        axes = VGroup(ejes, x_label, y_label)\n        superficie1_1 = superficie2_1_1()\n        superficie1_2 = superficie2_1_2()\n        superficie1_3 = superficie2_1_3()\n        superficie1_4 = superficie2_1_4()\n        superficie = VGroup(superficie1_1, superficie1_2, superficie1_3, superficie1_4)\n        n1_2 = 17 + 17\n        cjto1_2 = []\n        for i in range(2, n1_2):\n            if i <= 17:\n                x = 3 - 0.1 * i\n            if i > 17:\n                x = 3 - 0.1 * 17 - (i - 17) * 0.06\n            cjto1_2.append((x, x, 1 / (x * x)))\n        Elementos1_2 = [Dot(color=RED).set_color(RED_E).move_to(i) for i in cjto1_2]\n        Elementos12 = VGroup(*Elementos1_2)\n        n1_4 = 17 + 17\n        cjto1_4 = []\n        for i in range(2, n1_4):\n            if i <= 17:\n                x = 3 - 0.1 * i\n            if i > 17:\n                x = 3 - 0.1 * 17 - (i - 17) * 0.06\n            cjto1_4.append((x, -x, -1 / x ** 2))\n        Elementos1_4 = [Dot(color=RED).set_color(RED_E).move_to(i) for i in cjto1_4]\n        Elementos14 = VGroup(*Elementos1_4)\n        self.add_fixed_in_frame_mobjects(t_1)\n        self.play(Write(t_1))\n        self.wait(4)\n        self.play(FadeOut(t_1))\n        self.add_fixed_in_frame_mobjects(t_2)\n        self.play(Write(t_2))\n        self.wait(2)\n        self.play(FadeOut(t_2))\n        self.move_camera(phi=80 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 2))\n        self.play(Write(axes, run_time=0.5))\n        self.play(ShowCreation(superficie))\n        self.play(ShowCreation(Elementos12), run_time=6)\n        self.wait()\n        self.play(FadeOut(Elementos12))\n        self.move_camera(phi=80 * DEGREES, theta=(30 - 45) * DEGREES, frame_center=(0, 0, -1))\n        self.play(ShowCreation(Elementos14), run_time=6)\n        self.wait()\n        self.play(FadeOut(Elementos14))\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n        self.add_fixed_in_frame_mobjects(t_3)\n        self.play(Write(t_3))\n        self.wait(6)\n        self.play(FadeOut(t_3))\n\n    def parte3(self):\n        text8 = TextMobject('Veamos otro ejemplo.')\n        t_9 = TextMobject('Sea $f:\\\\mathbb{R}^{2}-{\\\\vec{0}}\\\\rightarrow\\\\mathbb{R}$ \\n\\n                                $f(x,y)=\\\\frac{2xy}{x^2+y^2}$').move_to(3 * DOWN)\n        t_9.bg = SurroundingRectangle(t_9, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text9 = VGroup(t_9.bg, t_9)\n        t9_5 = TextMobject('En este ejemplo tanto la funci\u00f3n del numerador como \\n\\n                              la del denominador convergen a cero en el origen. \u00bfQu\u00e9 \\n\\n                              pasa con el cociente?').scale(0.7).move_to(3 * DOWN)\n        t9_5.bg = SurroundingRectangle(t9_5, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text9_5 = VGroup(t9_5.bg, t9_5)\n        t_10 = TextMobject('Notemos que si nos aproximamos al origen en el \\n\\n                                dominio en las direcciones can\u00f3nicas entonces \\n\\n                                el l\u00edmite es 0.').move_to(3 * DOWN).scale(0.7)\n        t_10.bg = SurroundingRectangle(t_10, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text10 = VGroup(t_10.bg, t_10)\n        t_11 = TextMobject('Ahora tomemos la direcci\u00f3n dada por la recta \\n\\n                                identidad y veamos qu\u00e9 ocurre.').move_to(3 * DOWN)\n        t_11.bg = SurroundingRectangle(t_11, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text11 = VGroup(t_11.bg, t_11)\n        t_12 = TextMobject('Notamos que en este caso el l\u00edmite es 1 y es diferente \\n\\n                                    de 0.').move_to(3 * DOWN)\n        t_12.bg = SurroundingRectangle(t_12, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text12 = VGroup(t_12.bg, t_12)\n        text13 = TextMobject('Como ya sabemos, si encontramos dos direcciones donde los \\n\\n                                l\u00edmites direccionales difieren, entonces podemos concluir \\n\\n                                que el l\u00edmite no existe.')\n        ejes = ThreeDAxes(x_min=-4.5, x_max=4.5, y_min=-4.5, y_max=4.5, z_min=-1.5, z_max=4)\n        x_label = TexMobject('x').scale(0.75).move_to((5, 0.3, 0))\n        y_label = TexMobject('y').scale(0.75).move_to((0.3, 5, 0))\n        axes = VGroup(ejes, x_label, y_label)\n        superficie1_1 = superficie2_2_1()\n        superficie1_2 = superficie2_2_2()\n        superficie1_3 = superficie2_2_3()\n        superficie1_4 = superficie2_2_4()\n        superficie = VGroup(superficie1_1, superficie1_2, superficie1_3, superficie1_4)\n        n1_1 = 15\n        cjto1_1 = []\n        cjto1_2 = []\n        for i in range(1, n1_1):\n            y1 = 3 - i * 0.2\n            x1 = 0\n            x = 3 - i * 0.2\n            y = 0\n            cjto1_2.append((x1, y1, 2 * x1 * y1 / (x1 ** 2 + y1 ** 2)))\n            cjto1_1.append((x, y, 2 * x * y / (x ** 2 + y ** 2)))\n        Elementos1_1 = [Dot(color=RED).set_color(RED_E).move_to(i) for i in cjto1_1]\n        Elementos1_2 = [Dot(color=RED).set_color(RED_E).move_to(i) for i in cjto1_2]\n        Elementos1 = VGroup(*Elementos1_1, *Elementos1_2)\n        Elementos1_1 = [Dot(color=RED).set_color(RED_E).move_to(i) for i in cjto1_1]\n        Elementos1_2 = [Dot(color=RED).set_color(RED_E).move_to(i) for i in cjto1_2]\n        Elementos1 = VGroup(*Elementos1_1, *Elementos1_2)\n        n1_2 = 15\n        cjto1_3 = []\n        cjto1_4 = []\n        for i in range(1, n1_2):\n            x2 = 3 - i * 0.2\n            x3 = -3 + i * 0.2\n            cjto1_3.append((x2, x2, 2 * x2 * x2 / (x2 ** 2 + x2 ** 2)))\n            cjto1_4.append((x3, x3, 2 * x3 * x3 / (x3 ** 2 + x3 ** 2)))\n        Elementos1_3 = [Dot(color=RED).set_color(RED_E).move_to(i) for i in cjto1_3]\n        Elementos1_4 = [Dot(color=RED).set_color(RED_E).move_to(i) for i in cjto1_4]\n        Elementos2 = VGroup(*Elementos1_3, *Elementos1_4)\n        self.add_fixed_in_frame_mobjects(text8)\n        self.play(Write(text8))\n        self.wait(2)\n        self.play(FadeOut(text8))\n        self.set_camera_orientation(0.7 * np.pi / 2, -1.4 * np.pi - 90 * DEGREES, distance=12)\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie))\n        self.add_fixed_in_frame_mobjects(text9)\n        self.play(Write(text9))\n        self.wait(5)\n        self.play(FadeOut(text9))\n        self.add_fixed_in_frame_mobjects(text9_5)\n        self.play(Write(text9_5))\n        self.wait(4)\n        self.play(FadeOut(text9_5))\n        self.add_fixed_in_frame_mobjects(text10)\n        self.play(Write(text10))\n        self.wait(5)\n        self.play(ShowCreation(Elementos1), runtime=10)\n        self.wait()\n        self.play(FadeOut(text10), FadeOut(Elementos1))\n        self.add_fixed_in_frame_mobjects(text11)\n        self.play(Write(text11))\n        self.wait(2)\n        self.play(ShowCreation(Elementos2), runtime=10)\n        self.play(FadeOut(text11))\n        self.add_fixed_in_frame_mobjects(text12)\n        self.play(Write(text12))\n        self.wait(3)\n        self.play(FadeOut(text12), FadeOut(axes), FadeOut(superficie), FadeOut(Elementos2))\n        self.add_fixed_in_frame_mobjects(text13)\n        self.play(Write(text13))\n        self.wait(4)\n        self.play(FadeOut(text13))\n\n    def parte4(self):\n        t_19 = TextMobject('Consideremos $f:\\\\mathbb{R}^{2}-{\\\\vec{0}}\\\\rightarrow\\\\mathbb{R}$\\n\\n                            $f(x,y)=\\\\frac{1}{(x+y)^{2}}$').move_to(3 * DOWN)\n        t_19.bg = SurroundingRectangle(t_19, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text19 = VGroup(t_19.bg, t_19)\n        t_20 = TextMobject('Nuevamente tenemos una funci\u00f3n donde el numerador es \\n\\n                            constante y el denominador tiende a cero en el origen.').move_to(3 * DOWN)\n        t_20.bg = SurroundingRectangle(t_20, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text20 = VGroup(t_20.bg, t_20)\n        t21 = TextMobject('Sin embargo, cuando nos vamos acercando a $\\\\vec{0}$, esta \\n\\n                             funci\u00f3n tiene un comportamiento diferente al del primer \\n\\n                             ejemplo.').move_to(3 * DOWN).scale(0.8)\n        t21.bg = SurroundingRectangle(t21, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text21 = VGroup(t21.bg, t21)\n        t22 = TextMobject('En este caso $f$ diverge a $\\\\infty$, lo cual se puede \\n\\n                             demostrar sin mucha dificultad porque el numerador \\n\\n                             es una constante y el denominador tiende a cero con \\n\\n                             valores positivos.').move_to(3 * DOWN).scale(0.8)\n        t22.bg = SurroundingRectangle(t22, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text22 = VGroup(t22.bg, t22)\n        text23 = TextMobject('De hecho, usando la m\u00e9trica se puede demostrar \\n\\n                                f\u00e1cilmente que si en un cociente el numerador es \\n\\n                                constante, el denominador tiende a cero en un \\n\\n                                punto y adem\u00e1s es positivo, entonces el cociente \\n\\n                                diverge a infinito en el punto.')\n        ejes = ThreeDAxes(x_min=-4.5, x_max=4.5, y_min=-4.5, y_max=4.5, z_min=-1.5, z_max=4)\n        x_label = TexMobject('x').scale(0.75).move_to((5, 0.3, 0))\n        y_label = TexMobject('y').scale(0.75).move_to((0.3, 5, 0))\n        axes = VGroup(ejes, x_label, y_label)\n        superficie21 = superficie2_4_1()\n        superficie22 = superficie2_4_2()\n        superficie = VGroup(superficie21, superficie22).rotate(-1.25 * np.pi, axis=IN)\n        t1_1 = ValueTracker(-2)\n        t1_1f = -0.3\n        punto2 = Sphere(radius=0.05, fill_opacity=1, checkerboard_colors=[RED_D, RED_C], fill_color=BLUE_E).move_to([-2, -2, 1 / 6 ** 2])\n\n        def mov_sup1(obj):\n            t = t1_1.get_value()\n            punto2.become(Sphere(radius=0.05, fill_opacity=1, checkerboard_colors=[RED_D, RED_C], fill_color=BLUE_E).move_to([-t, -t, 1 / (t + t) ** 2]).rotate(-1.25 * np.pi, axis=IN))\n        punto2.add_updater(mov_sup1)\n        self.set_camera_orientation(0.7 * np.pi / 2, 0.65 * np.pi - 180 * DEGREES, distance=12)\n        self.play(ShowCreation(axes))\n        self.add_fixed_in_frame_mobjects(text19)\n        self.play(Write(text19))\n        self.wait(4)\n        self.play(ShowCreation(superficie))\n        self.wait()\n        self.play(FadeOut(text19))\n        self.add_fixed_in_frame_mobjects(text20)\n        self.play(Write(text20))\n        self.wait(4)\n        self.play(FadeOut(text20))\n        self.add_fixed_in_frame_mobjects(text21)\n        self.play(Write(text21), run_time=2)\n        self.wait(2)\n        self.play(ShowCreation(punto2))\n        self.play(t1_1.set_value, t1_1f, run_time=10)\n        self.play(FadeOut(text21), FadeOut(punto2))\n        self.add_fixed_in_frame_mobjects(text22)\n        self.play(Write(text22))\n        self.wait(5)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n        self.add_fixed_in_frame_mobjects(text23)\n        self.play(Write(text23))\n        self.wait(8)\n        self.play(FadeOut(text23))\n\n    def parte5(self):\n        text1 = TextMobject('Tambi\u00e9n podemos usar criterios de comparaci\u00f3n \\n\\n                               analizando los \u00f3rdenes de magnitud de las funciones \\n\\n                               en el cociente')\n        text2 = TextMobject('La funci\u00f3n \\n\\n                               $f(x,y)=\\\\dfrac{x^2+y^2}{\\\\sin^2(x^2+y^2)}$ \\n\\n                               tiende a infinito en el origen.').move_to(2 * UP)\n        text3 = TextMobject('Pues al considerar $r^2=x^2+y^2$, cerca del origen \\n\\n                               obtenemos').next_to(text2, DOWN)\n        text4 = TexMobject('\\\\dfrac{r^2}{\\\\sin^2(r^2)}\\\\approx\\\\dfrac{r^2}{r^4}=\\\\dfrac{1}{r^2}').next_to(text3, DOWN)\n        self.add_fixed_in_frame_mobjects(text1)\n        self.play(Write(text1))\n        self.wait(3)\n        self.play(FadeOut(text1))\n        self.add_fixed_in_frame_mobjects(text2)\n        self.play(Write(text2))\n        self.wait(2)\n        self.add_fixed_in_frame_mobjects(text3)\n        self.play(Write(text3))\n        self.wait(2)\n        self.add_fixed_in_frame_mobjects(text4)\n        self.play(Write(text4))\n        self.wait(3)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n\n    def construct(self):\n        self.parte0()\n        self.parte1()\n        self.parte2()\n        self.partesucesiones()\n        self.parte3()\n        self.parte4()\n        self.parte5()"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of Riemann sums and Darboux integrals for a function in 3D, visually demonstrating the approximation of volume with prisms."}, {"role": "assistant", "content": "from re import S\nfrom manimlib.imports import *\n\nclass integral_volumen(ThreeDScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        ThreeDScene.setup(self)\n\n    def FadeOutWrite3D(self, objeto1, objeto2):\n        self.play(FadeOut(objeto1))\n        self.acomodar_textos(objeto2)\n\n    def acomodar_textos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.play(Write(objeto))\n\n    def puntos_riemann_2D(self):\n        puntos = []\n        valores_x = [0.2, 0.9, 1.9, 2.825]\n        valores_y = [0.1, 0.85, 1.6, 2.8]\n        for j in valores_y:\n            for i in valores_x:\n                punto = Dot(radius=0.075, color=RED).move_to([i, j, 0])\n                puntos.append(punto)\n        return puntos\n\n    def puntos_plano(self):\n        puntos = []\n        valores_x = [0.2, 0.9, 1.9, 2.825]\n        valores_y = [0.1, 0.85, 1.6, 2.8]\n        for j in valores_y:\n            for i in valores_x:\n                punto = Dot(radius=0.075, color=ORANGE).move_to([i, j, j])\n                puntos.append(punto)\n        return puntos\n\n    def plano_funcion(self):\n        plano = ParametricSurface(lambda u, v: np.array([u, v, v]), v_min=0, v_max=3, u_min=0, u_max=3, fill_color=WHITE, fill_opacity=0.6, checkerboard_colors=[WHITE, WHITE], stroke_width=0.01)\n        return plano\n\n    def particion_1_2D(self):\n        particion = []\n        valores = [0.375, 1.125, 1.875, 2.625]\n        for i in valores:\n            for j in valores:\n                cuadro = Square(side_length=0.75, fill_opacity=0, stroke_width=1).set_color(GREEN)\n                cuadro.move_to((i, j, 0))\n                particion.append(cuadro)\n        return particion\n\n    def particion_2_2D(self):\n        particion = []\n        valores = [0.1875, 0.5625, 0.9375, 1.3125, 1.6875, 2.0625, 2.4375, 2.8125]\n        for i in valores:\n            for j in valores:\n                cuadro = Square(side_length=0.375, fill_opacity=0, stroke_width=1).set_color(GREEN)\n                cuadro.move_to((i, j, 0))\n                particion.append(cuadro)\n        return particion\n\n    def prismas_inf(self):\n        prismas = []\n        ancho = 3 / 4\n        funcion = [0, 0.75, 1.5, 2.25]\n        valores = [0.375, 1.125, 1.875, 2.625]\n        for i in range(4):\n            for j in range(4):\n                prisma = Prism(dimensions=[ancho, ancho, funcion[j]], fill_color=YELLOW, fill_opacity=0.25)\n                prisma.move_to((valores[i], valores[j], funcion[j] / 2))\n                prismas.append(prisma)\n        return prismas\n\n    def prismas_sup(self):\n        prismas = []\n        ancho = 3 / 4\n        funcion = [0.75, 1.5, 2.25, 3]\n        valores = [0.375, 1.125, 1.875, 2.625]\n        for i in range(4):\n            for j in range(4):\n                prisma = Prism(dimensions=[ancho, ancho, funcion[j]], fill_color=BLUE, fill_opacity=0.25)\n                prisma.move_to((valores[i], valores[j], funcion[j] / 2))\n                prismas.append(prisma)\n        return prismas\n\n    def lineas_inf(self):\n        lineas_1 = []\n        valores = [0, 0.75, 1.5, 2.25]\n        for i in valores:\n            linea = ParametricFunction(lambda t: np.array([t, i, 0]), t_min=0, t_max=3, fill_color=RED, fill_opacity=1, stroke_width=0.5).set_color(RED)\n            lineas_1.append(linea)\n        return lineas_1\n\n    def lineas_inf_plano(self):\n        lineas_1 = []\n        valores = [0, 0.75, 1.5, 2.25]\n        for i in valores:\n            linea = ParametricFunction(lambda t: np.array([t, i, i]), t_min=0, t_max=3, fill_color=RED, fill_opacity=1, stroke_width=0.5).set_color(RED)\n            lineas_1.append(linea)\n        return lineas_1\n\n    def lineas_sup(self):\n        lineas_1 = []\n        valores = [0.75, 1.5, 2.25, 3]\n        for i in valores:\n            linea = ParametricFunction(lambda t: np.array([t, i, 0]), t_min=0, t_max=3, fill_color=RED, fill_opacity=1, stroke_width=0.5).set_color(RED)\n            lineas_1.append(linea)\n        return lineas_1\n\n    def lineas_sup_plano(self):\n        lineas_1 = []\n        valores = [0.75, 1.5, 2.25, 3]\n        for i in valores:\n            linea = ParametricFunction(lambda t: np.array([t, i, i]), t_min=0, t_max=3, fill_color=RED, fill_opacity=1, stroke_width=0.5).set_color(RED)\n            lineas_1.append(linea)\n        return lineas_1\n\n    def EscenaCero(self):\n        titulo = TextMobject('Integral de Volumen').scale(1.5)\n        self.play(Write(titulo))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.wait()\n\n    def Dom2D_PrimeraEscena(self):\n        texto_1 = TextMobject('Consideremos la siguiente funci\u00f3n').move_to(1 * UP)\n        texto_2 = TextMobject('$f:A=[0,3]\\\\times[0,3]\\\\subset \\\\mathbb{R}^2 \\\\to \\\\mathbb{R}$ \\n\\n                                 $f(x,y) = y$')\n        texto_3 = TextMobject(' A continuaci\u00f3n veamos c\u00f3mo construir la integral\\n\\n                                 de la funci\u00f3n $f$ sobre su dominio ').move_to(1.5 * UP)\n        texto_4 = TextMobject(' Consideremos una partici\u00f3n $\\\\mathcal{P}$ sobre el dominio $A$ ').move_to(3 * UP)\n        texto_5 = TexMobject('\\\\mathcal{P}:=\\\\{0,0.75,1.5,2.25,3\\\\}\\\\times\\\\{0,0.75,1.5,2.25,3\\\\}').move_to(3 * UP).scale(0.9)\n        texto_6 = TextMobject(' La partici\u00f3n $\\\\mathcal{P}$ induce un conjunto de 16 rect\u00e1ngulos\\n\\n                                  peque\u00f1os, que llamaremos $R$, de \u00e1rea $0.75^2$ dentro de $A$').move_to(3 * UP)\n        texto_6_5 = TextMobject('Nota que $\\\\mathcal{P}$ es el conjunto de v\u00e9rtices de los rect\u00e1ngulos').next_to(texto_6, DOWN)\n        texto_7 = TextMobject(' Definimos la suma superior de Darboux sobre $\\\\mathcal{P}$ como\\n\\n                                $\\\\mathcal{U}(f,\\\\mathcal{P}):= \\\\sum_{i=1}^{16}M_i(0.75^2)$ ').move_to(3.2 * UP)\n        texto_7_5 = TextMobject('Donde $M_i=\\\\sup\\\\{f(x,y)|(x,y)\\\\in R_i\\\\}$').next_to(texto_7, DOWN)\n        texto_8 = TextMobject(' Como $f(x,y)=y$, los valores supremos corresponden a\\n\\n                                  cualquier punto sobre el lado del rect\u00e1ngulo donde \\n\\n                                  $y$ es mayor y constante').move_to(3 * UP)\n        texto_9 = TextMobject('An\u00e1logamente, definimos la suma inferior de Darboux sobre $\\\\mathcal{P}$ como\\n\\n                                $\\\\mathcal{L}(f,\\\\mathcal{P}):= \\\\sum_{i=1}^{16}m_i(0.75^2)$ ').move_to(3.2 * UP)\n        texto_9_5 = TextMobject('Donde $m_i=\\\\inf\\\\{f(x,y)|(x,y)\\\\in R_i\\\\}$').next_to(texto_9, DOWN)\n        texto_10 = TextMobject(' Como $f(x,y)=y$, los valores \u00ednfimos corresponden a\\n\\n                                   cualquier punto sobre el lado del rect\u00e1ngulo donde \\n\\n                                   $y$ es menor y constante').move_to(3 * UP)\n        texto_11 = TextMobject(' Para toda partici\u00f3n $\\\\mathcal{P}$,\\n\\n                                 $\\\\mathcal{L}(f,\\\\mathcal{P})\\\\leq\\\\mathcal{U}(f,\\\\mathcal{P})$').move_to(3 * UP)\n        texto_12 = TextMobject(\" Consideremos un refinamiento $\\\\mathcal{P}'$ de la partici\u00f3n $\\\\mathcal{P}$ \").move_to(3 * UP)\n        texto_13 = TextMobject(\" Resulta que \\n\\n                                $\\\\mathcal{L}(f,\\\\mathcal{P})\\\\leq\\\\mathcal{L}(f,\\\\mathcal{P}')\\\\leq\\\\mathcal{U}(f,\\\\mathcal{P}')\\\\leq\\\\mathcal{U}(f,\\\\mathcal{P})$ \").move_to(3 * UP)\n        texto_14_1 = TextMobject(' Definimos la integral superior de Darboux como ').move_to(1 * UP)\n        texto_14_2 = TexMobject('\\\\overline{\\\\iint}f(x,y)dxdy:=\\\\text{inf}\\\\{\\\\mathcal{U}(f,\\\\mathcal{P})|\\\\mathcal{P}\\\\text{ partici\u00f3n de }A\\\\}')\n        texto_15_1 = TextMobject(' As\u00ed mismo, se define la integral inferior de Darboux como ').move_to(1 * UP)\n        texto_15_2 = TexMobject('\\\\underline{\\\\iint}f(x,y)dxdy:=\\\\text{sup}\\\\{\\\\mathcal{L}(f,\\\\mathcal{P})|\\\\mathcal{P}\\\\text{ partici\u00f3n de }A\\\\}')\n        texto_16_1 = TextMobject(' Cuando las integrales superior e inferior de Darboux coinciden\\n\\n                                    en un valor, a este se le llama Integral de Darboux').move_to(1 * UP)\n        texto_16_2 = TexMobject('\\\\iint f(x,y)\\\\text{ }dxdy').next_to(texto_16_1, 1.5 * DOWN)\n        nota_1 = TextMobject('Para aproximar el volumen debajo de la superficie, \\n\\n                                consideramos un paralelep\u00edpedo de base $R_i$ y altura $M_i$, \\n\\n                                cuyo volumen es $M_i$ por el \u00e1rea de $R_i$, al tomar \\n\\n                                todos los paralelep\u00edpedos, obtenemos el volumen $U(f,P)$ \\n\\n                                que se muestra en azul').scale(0.5).move_to((4, -1, 0))\n        nota_2 = TextMobject('Esta vez el volumen debajo de la superficie lo \\n\\n                                aproximamos con el volumen $L(f,P)$ de los \\n\\n                                paralelep\u00edpedos en amarillo').scale(0.5).move_to((4, -1, 0))\n        texto_6_gp = VGroup(texto_6, texto_6_5)\n        texto_7_gp = VGroup(texto_7, texto_7_5)\n        texto_9_gp = VGroup(texto_9, texto_9_5).scale(0.9)\n        figura = Square(side_length=3, fill_opacity=0, stroke_width=1).move_to((1.5, 1.5, 0))\n        particion_1 = self.particion_1_2D()\n        particion_2 = self.particion_2_2D()\n        gpo_particion_1 = VGroup(*self.particion_1_2D())\n        gpo_particion_2 = VGroup(*self.particion_2_2D())\n        lineas_sup = self.lineas_sup()\n        lineas_inf = self.lineas_inf()\n        lineas_sup_plano = self.lineas_sup_plano()\n        lineas_inf_plano = self.lineas_inf_plano()\n        prismas_sup = self.prismas_sup()\n        prismas_inf = self.prismas_inf()\n        gpo_prismas_sup = VGroup(*prismas_sup)\n        gpo_prismas_inf = VGroup(*prismas_inf)\n        plano = self.plano_funcion()\n        axes = ThreeDAxes(x_min=-3.5, x_max=3.5, y_min=-3.5, y_max=3.5, z_min=-1, z_max=3.5, num_axis_pieces=30)\n        x_label = TexMobject('x').scale(0.75).move_to(np.array([3.5, 0.3, 0]))\n        y_label = TexMobject('y').scale(0.75).move_to(np.array([0.3, 3.5, 0]))\n        self.play(Write(texto_1))\n        self.wait()\n        self.play(Write(texto_2))\n        self.wait(2)\n        self.FadeOutWrite3D(texto_1, texto_3)\n        self.wait(3)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.move_camera(phi=80 * DEGREES, theta=40 * DEGREES, frame_center=(0, 0, 2))\n        self.play(ShowCreation(axes), ShowCreation(x_label), ShowCreation(y_label), ShowCreation(plano))\n        self.play(DrawBorderThenFill(figura))\n        self.wait()\n        self.acomodar_textos(texto_4)\n        self.wait(2)\n        self.FadeOutWrite3D(texto_4, texto_5)\n        self.wait(3)\n        self.FadeOutWrite3D(texto_5, texto_6_gp)\n        self.wait(7)\n        for i in particion_1:\n            self.play(Write(i), run_time=0.05)\n        self.wait(4)\n        self.FadeOutWrite3D(texto_6_gp, texto_7_gp)\n        self.wait(14)\n        self.play(FadeIn(gpo_prismas_sup))\n        self.begin_ambient_camera_rotation(rate=0.15)\n        self.acomodar_textos(nota_1)\n        self.wait(26)\n        self.play(FadeOut(nota_1))\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=85 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 2))\n        self.FadeOutWrite3D(texto_7_gp, texto_8)\n        self.wait(3)\n        for i in range(len(lineas_sup)):\n            self.play(Write(lineas_sup[i]), Write(lineas_sup_plano[i]), run_time=1)\n            self.play(FadeOut(lineas_sup[i]), FadeOut(lineas_sup_plano[i]))\n        self.move_camera(phi=80 * DEGREES, theta=40 * DEGREES, frame_center=(0, 0, 2))\n        self.wait()\n        self.play(FadeOut(gpo_prismas_sup))\n        self.FadeOutWrite3D(texto_8, texto_9_gp)\n        self.wait(11)\n        self.play(FadeIn(gpo_prismas_inf))\n        self.begin_ambient_camera_rotation(rate=0.15)\n        self.acomodar_textos(nota_2)\n        self.wait(15)\n        self.play(FadeOut(nota_2))\n        self.stop_ambient_camera_rotation()\n        self.move_camera(phi=85 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 2))\n        self.FadeOutWrite3D(texto_9_gp, texto_10)\n        self.wait(3)\n        for i in range(len(lineas_inf)):\n            self.play(Write(lineas_inf[i]), Write(lineas_inf_plano[i]), run_time=1)\n            self.play(FadeOut(lineas_inf[i]), FadeOut(lineas_inf_plano[i]))\n        self.move_camera(phi=80 * DEGREES, theta=40 * DEGREES, frame_center=(0, 0, 2))\n        self.wait()\n        self.play(FadeOut(gpo_prismas_inf))\n        self.FadeOutWrite3D(texto_10, texto_11)\n        self.wait(5)\n        self.FadeOutWrite3D(texto_11, texto_12)\n        self.wait(2)\n        self.play(ReplacementTransform(gpo_particion_1, gpo_particion_2))\n        self.wait()\n        self.FadeOutWrite3D(texto_12, texto_13)\n        self.wait(11)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, frame_center=(0, 0, 0))\n        self.play(Write(texto_14_1))\n        self.wait()\n        self.play(Write(texto_14_2))\n        self.wait(3)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.play(Write(texto_15_1))\n        self.wait()\n        self.play(Write(texto_15_2))\n        self.wait(3)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.play(Write(texto_16_1))\n        self.wait()\n        self.play(Write(texto_16_2))\n        self.wait(3)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n\n    def Dom2D_SegundaEscena(self):\n        texto_1 = TextMobject(' Regresemos  a la partici\u00f3n $\\\\mathcal{P}$ y consideremos \\n\\n                                  un conjunto que tome cualquier punto $(x_i,y_i)$ dentro de \\n \\n                                  cada rect\u00e1ngulo peque\u00f1o $R_i$ ').move_to(3 * UP)\n        texto_2 = TextMobject(' Entonces definimos la suma de Riemann como\\n\\n                                $\\\\mathcal{R}(f,\\\\mathcal{P}):= \\\\sum_{i=1}^{16}f(x_i,y_i)(0.75^2)$ ').move_to(3 * UP)\n        texto_3 = TextMobject(' Obs\u00e9rvese en el ejemplo c\u00f3mo la imagen del punto $(x_i,y_i)$ \\n\\n                                    es menor que el supremo de la funci\u00f3n en el \\n\\n                                    rect\u00e1ngulo correspondiente para cualquier $i$ ').move_to(3 * UP)\n        texto_4 = TextMobject(' Tambi\u00e9n v\u00e9ase c\u00f3mo la imagen del punto $(x_i,y_i)$ es\\n\\n                                  mayor que el \u00ednfimo de la funci\u00f3n en el rect\u00e1ngulo \\n\\n                                  correspondiente para cualquier $i$').move_to(3 * UP)\n        texto_5 = TextMobject(' Resulta que para toda partici\u00f3n $\\\\mathcal{P}$ y colecci\u00f3n\\n\\n                                 de puntos $(x_i,y_i)$ en $R_{i}$, se tiene que\\n\\n                                $\\\\mathcal{L}(f,\\\\mathcal{P})\\\\leq\\\\mathcal{R}(f,\\\\mathcal{P})\\\\leq\\\\mathcal{U}(f,\\\\mathcal{P})$').move_to(3 * UP)\n        texto_6 = TextMobject(' Decimos que $f$ es Riemann integrable si $\\\\mathcal{R}(f,\\\\mathcal{P})$\\n\\n                                 converge conforme $\\\\mathcal{P}$ se vuelve m\u00e1s fina. ').move_to(3 * UP)\n        texto_7 = TextMobject('Investiga qu\u00e9 es la norma de una partici\u00f3n y expresa \\n\\n                                 la integral de Riemann, la integral superior e inferior \\n\\n                                 usando este concepto').move_to(3 * UP)\n        figura = Square(side_length=3, fill_opacity=0, stroke_width=1).move_to((1.5, 1.5, 0))\n        particion_1 = self.particion_1_2D()\n        particion_2 = self.particion_2_2D()\n        gpo_particion_1 = VGroup(*self.particion_1_2D())\n        gpo_particion_2 = VGroup(*self.particion_2_2D())\n        lineas_sup = self.lineas_sup()\n        lineas_inf = self.lineas_inf()\n        gpo_lineas_sup = VGroup(*lineas_sup)\n        gpo_lineas_inf = VGroup(*lineas_inf)\n        lineas_sup_plano = self.lineas_sup_plano()\n        lineas_inf_plano = self.lineas_inf_plano()\n        gpo_lineas_sup_plano = VGroup(*lineas_sup_plano)\n        gpo_lineas_inf_plano = VGroup(*lineas_inf_plano)\n        plano = self.plano_funcion()\n        puntos = self.puntos_riemann_2D()\n        puntos_plano = self.puntos_plano()\n        gpo_puntos = VGroup(*puntos)\n        gpo_puntos_plano = VGroup(*puntos_plano)\n        axes = ThreeDAxes(x_min=-3.5, x_max=3.5, y_min=-3.5, y_max=3.5, z_min=-1, z_max=3.5, num_axis_pieces=30)\n        x_label = TexMobject('x').scale(0.75).move_to((3.5, 0.3, 0))\n        y_label = TexMobject('y').scale(0.75).move_to((0.3, 3.5, 0))\n        self.move_camera(phi=80 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 2))\n        self.acomodar_textos(texto_1)\n        self.wait(2)\n        self.play(ShowCreation(axes), ShowCreation(x_label), ShowCreation(y_label), ShowCreation(plano))\n        self.play(DrawBorderThenFill(figura))\n        self.play(FadeIn(gpo_particion_1))\n        self.wait()\n        self.play(FadeIn(gpo_puntos))\n        self.wait()\n        self.FadeOutWrite3D(texto_1, texto_2)\n        self.wait(8)\n        self.play(FadeIn(gpo_puntos_plano))\n        self.wait(3)\n        self.FadeOutWrite3D(texto_2, texto_3)\n        self.wait(3)\n        self.move_camera(phi=82 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 2))\n        self.play(FadeIn(gpo_lineas_sup), FadeIn(gpo_lineas_sup_plano))\n        self.play(Indicate(gpo_lineas_sup, color=BLUE, scale_factor=1.5), Indicate(gpo_lineas_sup_plano, color=BLUE, scale_factor=1.5), run_time=3)\n        self.play(FadeOut(gpo_lineas_sup), FadeOut(gpo_lineas_sup_plano))\n        self.wait()\n        self.FadeOutWrite3D(texto_3, texto_4)\n        self.play(FadeIn(gpo_lineas_inf), FadeIn(gpo_lineas_inf_plano))\n        self.play(Indicate(gpo_lineas_inf, color=YELLOW, scale_factor=1.5), Indicate(gpo_lineas_inf_plano, color=YELLOW, scale_factor=1.5), run_time=3)\n        self.play(FadeOut(gpo_lineas_inf), FadeOut(gpo_lineas_inf_plano))\n        self.move_camera(phi=80 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 2))\n        self.wait()\n        self.play(FadeOut(gpo_puntos_plano))\n        self.FadeOutWrite3D(texto_4, texto_5)\n        self.wait(17)\n        self.FadeOutWrite3D(texto_5, texto_6)\n        self.wait(3)\n        self.play(FadeOut(gpo_puntos))\n        self.play(ReplacementTransform(gpo_particion_1, gpo_particion_2))\n        self.wait()\n        self.FadeOutWrite3D(texto_6, texto_7)\n        self.wait(8)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n\n    def construct(self):\n        self.EscenaCero()\n        self.Dom2D_PrimeraEscena()\n        self.Dom2D_SegundaEscena()"}]}
{"messages": [{"role": "user", "content": "Illustrate the transformation between Cartesian and polar coordinates with detailed explanations and visual examples."}, {"role": "assistant", "content": "from sys import float_repr_style\nfrom manimlib.imports import *\n\nclass Polares_y_Cartesianas(Scene):\n\n    def parte1(self):\n        titulo = TextMobject('Coordenadas polares y \\n\\n                                cartesianas').scale(2)\n        text1 = TextMobject('En el curso de C\u00e1lculo Vectorial Integral \\n\\n                             se suele trabajar en espacios tipo $\\\\mathbb{R}^{n}$,\\n\\n                              as\u00ed que siempre tendremos una base con la cual trabajar \\n\\n                               y con ello un sistema de coordenadas.')\n        text2 = TextMobject('En diversas ocasiones es m\u00e1s pr\u00e1ctico optar por \\n\\n                             unas coordenadas que por otras, \\n\\n                             as\u00ed que es importante dominar los cambios de \\n\\n                             coordenadas.')\n        text3 = TextMobject('Veamos el caso de $\\\\mathbb{R}^{2}$.').move_to(3 * UP)\n        text4 = TextMobject('Las coordenadas usuales en este espacio son \\n\\n                                las polares ', 'y cartesianas.').move_to(3 * UP)\n        text5 = TextMobject('Podemos definir una funci\u00f3n que transforme un \\n\\n                            vector de unas coordenadas a otras.').move_to(3 * UP)\n        text6 = TextMobject('T\u00f3mate un segundo para pensar en la funci\u00f3n \\n\\n                                que transforme un vector en coordenadas polares \\n\\n                                a cartesianas.').move_to(2.5 * UP)\n        linea1 = Arrow([-4, 0, 0], [4, 0, 0])\n        linea2 = Arrow([0, -3, 0], [0, 3, 0])\n        lineas = VGroup(linea1, linea2).move_to(1 * DOWN)\n        linea1_1 = Arrow([-4, 0, 0], [4, 0, 0])\n        linea2_1 = Arrow([0, -3, 0], [0, 3, 0])\n        Plano1 = VGroup(linea1_1, linea2_1).scale(0.7)\n        Plano1.move_to(1 * DOWN + 3 * LEFT)\n        linea1_2 = Arrow([-4, 0, 0], [4, 0, 0])\n        linea2_2 = Arrow([0, -3, 0], [0, 3, 0])\n        Plano2 = VGroup(linea1_2, linea2_2).move_to(1 * DOWN - 3 * LEFT).scale(0.7)\n        a = 1\n        b = 1.2\n        ap = np.cos(a) / 2\n        bp = np.sin(b) / 2\n        vector1 = Arrow([0, -1, 0], [a, b, 0], color=BLUE_E, buff=0)\n        r = TextMobject('r').next_to(vector1, LEFT, buff=-0.3)\n        angulo = Arc(fill_opacity=0, stroke_opacity=1, angle=np.arctan(b / a), radius=a / 2, arc_center=[0, -1, 0], buff=0)\n        angulo_l = TextMobject('$\\\\theta$').next_to(angulo, UP + RIGHT, buff=0.2)\n        angs = VGroup(angulo, angulo_l)\n        brazox = Brace(vector1, RIGHT)\n        x = TexMobject('x').next_to(brazox, RIGHT, buff=0.1)\n        xs = VGroup(brazox, x)\n        brazoy = Brace(vector1, UP)\n        y = TexMobject('y').next_to(brazoy, UP, buff=0.1)\n        ys = VGroup(y, brazoy)\n        vector1_1 = Arrow([0, 0, 0], [a, b, 0], color=BLUE_E, buff=0).scale(0.7).move_to((1 - b * 0.7 / 2) * DOWN + (3 - a * 0.7 / 2) * LEFT)\n        r_1 = TextMobject('r').next_to(vector1_1, LEFT, buff=-0.3)\n        angulo_1 = Arc(fill_opacity=0, stroke_opacity=1, angle=np.arctan(b / a), radius=a / 2, arc_center=1 * DOWN + 3 * LEFT).scale(0.7)\n        angulo_l1 = TextMobject('$\\\\theta$').next_to(angulo_1, 0.2 * UP + RIGHT, buff=0.2)\n        Grupo1 = VGroup(angulo_1, angulo_l1, vector1_1, r_1)\n        f = TextMobject('$f$')\n        farrow = Arrow([-0.5, 0, 0], [0.5, 0, 0], buff=0)\n        f.next_to(farrow, UP, buff=0.3)\n        vector1_2 = Arrow([0, 0, 0], [a, b, 0], color=BLUE_E, buff=0).scale(0.7).move_to((1 - b * 0.7 / 2) * DOWN + (-3 - a * 0.7 / 2) * LEFT)\n        brazox_1 = Brace(vector1_2, RIGHT)\n        x_1 = TexMobject('x').next_to(brazox_1, RIGHT, buff=0.1)\n        brazoy_1 = Brace(vector1_2, UP)\n        y_1 = TexMobject('y').next_to(brazoy_1, UP, buff=0.1)\n        Grupo2 = VGroup(vector1_2, y_1, brazoy_1, x_1, brazox_1)\n        D = Dot(color=RED).move_to(1 * DOWN - 3 * LEFT)\n        D2 = Dot(color=RED).move_to(1 * DOWN + 3 * LEFT)\n        Grupo3 = VGroup(Grupo1, Grupo2, Plano1, Plano2, f, farrow)\n        self.play(Write(titulo))\n        self.wait(3.5)\n        self.play(FadeOut(titulo))\n        self.play(Write(text1))\n        self.wait(14)\n        self.play(FadeOut(text1))\n        self.play(Write(text2))\n        self.wait(11)\n        self.play(FadeOut(text2))\n        self.wait()\n        self.play(Write(text3))\n        self.wait(4)\n        self.play(Write(lineas))\n        self.play(FadeOut(text3))\n        self.play(Write(text4[0]))\n        self.play(Write(vector1))\n        self.play(Write(r), ShowCreation(angulo), Write(angulo_l))\n        self.wait(5)\n        self.play(Write(text4[1]))\n        self.wait(3)\n        self.play(ReplacementTransform(r, ys), ReplacementTransform(angs, xs))\n        self.play(FadeOut(text4))\n        self.play(Write(text5), FadeOut(lineas), FadeOut(ys), FadeOut(xs), FadeOut(vector1))\n        self.play(ShowCreation(Plano1), ShowCreation(Plano2))\n        self.play(ShowCreation(Grupo1))\n        self.play(ShowCreation(f))\n        self.play(ShowCreation(farrow))\n        self.play(ShowCreation(Grupo2))\n        self.wait(7)\n        self.play(FadeOut(text5))\n        self.play(Write(text6))\n        self.wait(9)\n        self.play(FadeOut(text6), FadeOut(Grupo3))\n\n    def parte2(self):\n        r = 2\n        a = 4\n        theta = np.pi / a\n        r1 = 1\n        a1 = 1\n        theta1 = np.pi / a1\n        text7 = TextMobject('Considera un vector en coordenadas polares ($\\\\vec{\\\\rho}=(r,\\\\theta)$),\\n\\n                             por ejemplo $\\\\vec{\\\\rho}=($' + str(r) + ',$\\\\pi/$' + str(a) + ').')\n        text8 = TextMobject('Veamos c\u00f3mo se ve el vector en coordenadas cartesianas.').move_to(3 * UP)\n        text9 = TextMobject('Notemos que $x=2\\\\cos(\\\\pi/4)$ y $y=2\\\\sin(\\\\pi/4)$.').move_to(3 * UP)\n        text10 = TextMobject('Entonces podemos definir la funci\u00f3n que nos de el \\n\\n                            cambio de coordenadas (de polares a cartesianas) como:\\n                             $$f:\\\\vec{\\\\rho}(r,\\\\theta)\\\\rightarrow\\\\vec{x}(x,y)$$  \\n                             $$f(\\\\vec{\\\\rho})=(r\\\\cos\\\\theta,r\\\\sin\\\\theta) $$')\n        text11 = TextMobject('Sin embargo, hay que tener cuidado con \\n\\n                                el dominio de la funci\u00f3n.')\n        text12 = TextMobject('Podemos entonces restringir el dominio \\n\\n                         para que los \u00e1ngulos queden un\u00edvocamente \\n\\n                             determinados, $$\\\\theta \\\\in [0,2\\\\pi). $$')\n        text13 = TextMobject('Nota que si $0\\\\leq r$, entonces el vector cero \\n\\n                            tiene muchas etiquetas en coordenadas polares, \\n\\n                            a saber, $(0,\\\\theta)$.').move_to(3 * UP)\n        text14 = TextMobject('De ah\u00ed que consideramos que el origen no tiene \\n\\n                                    un \u00e1ngulo asociado.').move_to(3 * UP)\n        linea1 = Arrow([-4, 0, 0], [4, 0, 0])\n        linea2 = Arrow([0, -3, 0], [0, 3, 0])\n        Plano = VGroup(linea1, linea2).move_to(1 * DOWN)\n        vector = Arrow([0, -1, 0], [r * np.cos(theta), -1 + r * np.sin(theta), 0], buff=0, color=BLUE_C)\n        radio = TexMobject('r=' + str(r)).next_to(vector, LEFT, buff=-0.3)\n        angulo = Arc(fill_opacity=0, stroke_opacity=1, angle=theta, radius=r / 2, arc_center=[0, -1, 0], buff=0)\n        angulo_l = TexMobject('\\\\theta=\\\\pi/' + str(a)).next_to(angulo, 0 * UP + RIGHT, buff=0.2)\n        polares = VGroup(radio, angulo, angulo_l)\n        b_x = Brace(vector, RIGHT)\n        x = TexMobject('x=' + str(r) + '\\\\cos(\\\\pi/' + str(a) + ')').next_to(b_x, RIGHT, buff=0.1)\n        b_y = Brace(vector, UP)\n        y = TexMobject('y=' + str(r) + '\\\\sin(\\\\pi/' + str(a) + ')').next_to(b_y, UP, buff=0.1)\n        cartesianas = VGroup(y, x, b_y, b_x)\n        vector_0 = Dot(color=RED, radius=0.2).move_to(1 * DOWN)\n        vector1 = Arrow([0, -1, 0], [r * np.cos(theta), -1 + r * np.sin(theta), 0], buff=0, color=BLUE_C)\n        self.play(Write(text7))\n        self.wait(5)\n        self.play(text7.shift, 3 * UP, runtime=6)\n        self.play(ShowCreation(Plano))\n        self.play(ShowCreation(vector))\n        self.play(Write(polares))\n        self.wait(6)\n        self.play(FadeOut(text7), FadeOut(polares))\n        self.play(Write(text8))\n        self.play(Write(cartesianas))\n        self.wait(8)\n        self.play(FadeOut(text8))\n        self.play(Write(text9))\n        self.wait(10)\n        self.play(FadeOut(Plano), FadeOut(text9), FadeOut(cartesianas), FadeOut(vector))\n        self.play(Write(text10))\n        self.wait(15)\n        self.play(FadeOut(text10))\n        self.play(Write(text11))\n        self.wait(8)\n        self.play(FadeOut(text11))\n        self.play(Write(text12))\n        self.wait(10)\n        self.play(FadeOut(text12))\n        self.play(Write(text13))\n        self.play(ShowCreation(Plano))\n        self.play(ShowCreation(vector_0))\n        self.wait(11)\n        self.play(FadeOut(text13))\n        self.play(Write(text14))\n        self.wait(8)\n        self.play(FadeOut(text14), FadeOut(Plano), FadeOut(vector_0))\n\n    def parte3(self):\n        text15 = TextMobject('Si no restringimos el \u00e1ngulo, tenemos por ejemplo \\n\\n                            $(1,\\\\pi)$', '$\\\\rightarrow(-1,0)$ ', '\\n \\n                            $(1,3\\\\pi)$', '$\\\\rightarrow(-1,0).$').move_to(2.5 * UP)\n        linea1_1 = Arrow([-4, 0, 0], [4, 0, 0])\n        linea2_1 = Arrow([0, -3, 0], [0, 3, 0])\n        Plano1 = VGroup(linea1_1, linea2_1).scale(0.7)\n        Plano1.move_to(1 * DOWN + 3 * LEFT)\n        linea1_2 = Arrow([-4, 0, 0], [4, 0, 0])\n        linea2_2 = Arrow([0, -3, 0], [0, 3, 0])\n        Plano2 = VGroup(linea1_2, linea2_2).move_to(1 * DOWN - 3 * LEFT).scale(0.7)\n        a = -1\n        b = 0\n        r = 1\n        theta = np.pi\n        f = TextMobject('$f$')\n        farrow = Arrow([-0.5, 0, 0], [0.5, 0, 0], buff=0)\n        f.next_to(farrow, UP, buff=0.3)\n        fs = VGroup(f, farrow)\n        vector1_1 = Arrow([0, 0, 0], [a, b, 0], color=RED, buff=0).scale(0.7).move_to((1 - b * 0.7 / 2) * DOWN + (3 - a * 0.7 / 2) * LEFT)\n        r_1 = TextMobject('r=' + str(r)).next_to(vector1_1, LEFT + UP, buff=0.3)\n        angulo_1 = Arc(fill_opacity=0, stroke_opacity=1, angle=-theta, radius=a / 2, arc_center=1 * DOWN + 3 * LEFT).scale(0.7)\n        angulo_l1 = TexMobject('\\\\theta=\\\\pi').next_to(angulo_1, UP, buff=0.5)\n        Grupo1 = VGroup(angulo_1, angulo_l1, vector1_1, r_1)\n        vector1_2 = Arrow([0, 0, 0], [a, b, 0], color=RED, buff=0).scale(0.7).move_to((1 - b * 0.7 / 2) * DOWN + (3 + a * 0.7 / 2) * RIGHT)\n        b_x = Brace(vector1_2, RIGHT)\n        x = TexMobject('x=' + str(r) + '\\\\cos(\\\\pi)').next_to(b_x, RIGHT + DOWN, buff=0.1)\n        b_y = Brace(vector1_2, UP)\n        y = TexMobject('y=' + str(r) + '\\\\sin(\\\\pi)').next_to(b_y, UP, buff=0.1)\n        cartesianas = VGroup(y, x, b_y, b_x)\n        r_3 = TextMobject('r=' + str(r)).next_to(vector1_1, LEFT + UP, buff=0.3)\n        angulo_3 = Arc(fill_opacity=0, stroke_opacity=1, angle=-theta - 2 * np.pi, radius=a / 2, arc_center=1 * DOWN + 3 * LEFT).scale(0.7)\n        angulo_l3 = TexMobject('\\\\theta=3\\\\pi').next_to(angulo_1, UP, buff=0.5)\n        Grupo2 = VGroup(angulo_3, angulo_l3, vector1_1, r_3)\n        x2 = TexMobject('x=' + str(r) + '\\\\cos(3\\\\pi)').next_to(b_x, RIGHT + DOWN, buff=0.1)\n        y2 = TexMobject('y=' + str(r) + '\\\\sin(3\\\\pi)').next_to(b_y, UP, buff=0.1)\n        cartesianas1 = VGroup(y2, x2, b_y, b_x, vector1_2)\n        self.play(ShowCreation(Plano1), ShowCreation(Plano2))\n        self.play(Write(text15[0]))\n        self.play(ShowCreation(Grupo1))\n        self.play(Write(text15[1]))\n        self.play(ShowCreation(fs))\n        self.play(ShowCreation(vector1_2))\n        self.play(ShowCreation(cartesianas))\n        self.play(FadeOut(cartesianas), FadeOut(fs), FadeOut(Grupo1))\n        self.wait(7)\n        self.play(Write(text15[2]))\n        self.play(ShowCreation(Grupo2))\n        self.play(ShowCreation(text15[3]))\n        self.play(ShowCreation(fs))\n        self.play(ShowCreation(cartesianas1))\n        self.wait()\n        self.wait(7)\n        self.play(FadeOut(cartesianas1), FadeOut(Grupo2), FadeOut(fs), FadeOut(Plano1), FadeOut(Plano2), FadeOut(text15))\n\n    def parte4(self):\n        x = 2\n        y = 1\n        text16 = TextMobject('Para el cambio de coordenadas de cartesianas a \\n\\n                                polares, considera $\\\\vec{x}=($' + str(x) + ',' + str(y) + ')')\n        text17 = TextMobject('Puedes notar que \\n  \\n                            $r=\\\\sqrt{2^2+1^2} \\\\ \\\\ \\\\ y \\\\ \\\\ \\\\ \\\\theta=\\\\tan^{-1}\\\\left(\\\\frac{1}{2}\\\\right).$').move_to(3 * UP)\n        text18 = TextMobject('Por lo que podr\u00edamos pensar que la funci\u00f3n \\n\\n                                de cambio de coordenadas es \\n                                $$g(\\\\vec{x})=\\\\left(\\\\sqrt{x^2+y^2},\\\\tan^{-1}\\\\left(\\\\frac{y}{x}\\\\right)\\\\right)$$', '\\n\\n                                Y casi...')\n        text19 = TextMobject('Debemos hacer un peque\u00f1o ajuste en la funci\u00f3n \\n\\n                                 previamente definida.').move_to(3 * UP)\n        text19_1 = TextMobject('Ya que nuestra funci\u00f3n no considera muchos \\n\\n                                vectores, entre ellos $(0,0)$ y $(r,\\\\pi/2)$.').move_to(2.5 * UP)\n        text20 = TextMobject('Si tomamos  $h(x)=(\\\\sqrt{x^2+y^2},\\\\theta)$ \\n\\n                                            Donde').move_to(3 * UP)\n        text21_m = TexMobject('{\\\\begin{matrix} \\n                                \\\\tan^{-1}\\\\left(\\\\frac{y}{x}\\\\right) & si & x>0 \\\\ \\\\ \\\\text{y} \\\\ \\\\ y \\\\geq0\\\\\\\\\\n                                                                &        &  \\\\\\\\\\n                                \\\\frac{\\\\pi}{2} & \\\\text{si} & x=0  \\\\ \\\\ \\\\text{y} \\\\ \\\\ y >0\\\\\\\\\\n                                &        &  \\\\\\\\\\n                                \\\\tan^{-1}\\\\left(\\\\frac{y}{x}\\\\right)+\\\\pi & \\\\text{si} & x<0 \\\\\\\\\\n                                &        &  \\\\\\\\\\n                                \\\\frac{3\\\\pi}{2} & \\\\text{si} & x=0 \\\\ \\\\ \\\\text{y} \\\\ \\\\ y <0\\\\\\\\\\n                                &        &  \\\\\\\\\\n                                \\\\tan^{-1}\\\\left(\\\\frac{y}{x}\\\\right)+2\\\\pi & \\\\text{si} & x>0 \\\\ \\\\  \\\\text{y} \\\\ \\\\ y<0 \\\\end{matrix}}').move_to(0.5 * RIGHT + 0.8 * DOWN)\n        text21_b = Brace(text21_m, LEFT)\n        text21_t = TexMobject('\\\\theta=').next_to(text21_b, LEFT, buff=0.1)\n        text21 = VGroup(text21_m, text21_b, text21_t)\n        text22 = TextMobject('As\u00ed podemos pasar de coordenadas polares a cartesianas,\\n\\n                                 sin ning\u00fan problema. ')\n        text23 = TextMobject('\u00a1Ya conocemos las funciones que nos permiten \\n\\n                            pasar de coordenadas cartesianas a polares y viceversa.!')\n        linea1 = Arrow([-4, 0, 0], [4, 0, 0])\n        linea2 = Arrow([0, -3, 0], [0, 3, 0])\n        Plano = VGroup(linea1, linea2).move_to(1 * DOWN)\n        vector = Arrow([0, -1, 0], [x, -1 + y, 0], buff=0, color=BLUE_C)\n        x_b = Brace(vector, RIGHT)\n        x_l = TexMobject('x=' + str(x)).next_to(x_b, RIGHT, buff=0.1)\n        y_b = Brace(vector, UP)\n        y_l = TexMobject('y=' + str(y)).next_to(y_b, UP, buff=0.1)\n        cartesianas = VGroup(y_b, x_b, y_l, x_l)\n        xs = VGroup(x_b, x_l)\n        ys = VGroup(y_b, y_l)\n        r = (x ** 2 + y ** 2) ** (1 / 2)\n        r_1 = DecimalNumber(r, num_decimal_places=1).move_to(vector.get_center() + x / 4 * LEFT + 0.1 * UP)\n        radio = TexMobject('r=').next_to(r_1, LEFT, buff=0.5)\n        rs = VGroup(r_1, radio)\n        if x > 0 and y != 0:\n            theta = np.arctan(y / x)\n        if x == 0 and y > 0:\n            theta = np.pi / 2\n        if x < 0:\n            theta = np.arctan(y / x) + np.pi\n        if x == 0 and y < 0:\n            theta = np.arctan(y / x) + 2 * np.pi\n        angulo = Arc(fill_opacity=0, stroke_opacity=1, angle=theta, radius=r / 2, arc_center=[0, -1, 0], buff=0)\n        angulo_l = TexMobject('\\\\theta=').move_to(angulo.get_center() + (x / 4 + 0.1) * RIGHT)\n        theta_1 = DecimalNumber(theta, num_decimal_places=1).next_to(angulo_l, x / (x ** 2) ** (1 / 2) * RIGHT, buff=0.1)\n        thetas = VGroup(theta_1, angulo_l, angulo)\n        polares = VGroup(radio, r_1, angulo, angulo_l, theta_1)\n        y2 = ValueTracker(0.8)\n        vector_1 = Arrow([0, -1, 0], [0, -1, 0], color=BLUE_C, buff=0)\n\n        def mov_vector(obj):\n            y = y2.get_value()\n            vector_1.become(Arrow([0, -1, 0], [0, y - 1, 0], color=BLUE_C, buff=0))\n        vector_1.add_updater(mov_vector)\n        vector_0 = Dot(color=RED, radius=0.2).move_to(1 * DOWN)\n        self.play(Write(text16))\n        self.wait()\n        self.play(text16.shift, 3 * UP, runtime=6)\n        self.play(ShowCreation(Plano))\n        self.play(ShowCreation(vector), ShowCreation(cartesianas))\n        self.wait(8)\n        self.play(FadeOut(text16))\n        self.play(Write(text17))\n        self.play(ReplacementTransform(xs, rs), ReplacementTransform(ys, thetas))\n        self.wait(8)\n        self.play(FadeOut(vector), FadeOut(Plano), FadeOut(cartesianas), FadeOut(polares), FadeOut(text17))\n        self.play(Write(text18[0]))\n        self.wait(10)\n        self.play(Write(text18[1]))\n        self.wait(5)\n        self.play(FadeOut(text18))\n        self.play(ShowCreation(Plano))\n        self.play(ShowCreation(text19))\n        self.wait(8)\n        self.play(FadeOut(text19))\n        self.play(Write(text19_1))\n        self.play(ShowCreation(vector_0))\n        self.play(ReplacementTransform(vector_0, vector_1))\n        self.play(y2.set_value, 2, run_time=10)\n        self.wait(5)\n        self.play(FadeOut(text19_1))\n        self.play(FadeOut(Plano), FadeOut(vector_1))\n        self.play(Write(text20))\n        self.play(Write(text21))\n        self.wait(20)\n        self.play(FadeOut(text21), FadeOut(text20))\n        self.play(Write(text22))\n        self.wait(8)\n        self.play(FadeOut(text22))\n        self.play(Write(text23))\n        self.wait(9)\n        self.play(FadeOut(text23))\n\n    def construct(self):\n        self.parte1()\n        self.parte2()\n        self.parte3()\n        self.parte4()"}]}
{"messages": [{"role": "user", "content": "Demonstrate how linear transformations act as change of basis by illustrating vector addition and scalar multiplication transformations between two bases, concluding with the conditions for a linear transformation to be a change of coordinates."}, {"role": "assistant", "content": "from sys import float_repr_style\nfrom manimlib.imports import *\n\nclass CamposLineales2(Scene):\n\n    def parte1(self):\n        ejes_config = {'stroke_width': 3, 'buff': 0, 'max_tip_length_to_length_ratio': 0.1, 'max_stroke_width_to_length_ratio': 2, 'preserve_tip_size_when_scaling': False}\n        titulo = TextMobject('Campos Lineales y \\n\\n                            Cambios de \\n\\n                            Coordenadas').scale(2)\n        text1 = TextMobject(' Considera el conjunto', ' $\\\\gamma=\\\\{(1,1),(0,1)\\\\}$ ')\n        text1[1].set_color(BLUE_C)\n        text2 = TextMobject('Puedes corroborar que cualquier vector descrito en la  \\n\\n                            base can\u00f3nica', '  $\\\\beta=\\\\{(0,1),(1,0) \\\\}$', ', es decir, \\n\\n                            cualquier vector en el plano cartesiano, se puede  \\n\\n                           escribir como una combinaci\u00f3n lineal de los vectores en \\n\\n                            el conjunto', ' $\\\\gamma.$ ').move_to(2.2 * UP)\n        text2[1].set_color(YELLOW)\n        text2[3].set_color(BLUE_C)\n        text3 = TextMobject('Por ejemplo considera', ' $\\\\vec{w}=(1,2)_\\\\beta$. ').move_to(3 * UP)\n        text3[1].set_color(PURPLE_C)\n        text4 = TextMobject('En el conjunto ', '$\\\\gamma$,', ' $\\\\vec{w}$ ', 'se escribe como\\n\\n                             $1\\\\cdot(1,1)+1\\\\cdot(0,1) $, por lo cual sus coordenadas \\n\\n                             en el conjunto ', '$\\\\gamma$', ' son', ' $(1,1)_\\\\gamma$ ').move_to(3 * UP)\n        text4[1].set_color(BLUE_C)\n        text4[2].set_color(PURPLE_C)\n        text4[4].set_color(BLUE_C)\n        text4[6].set_color(BLUE_C)\n        text5 = TextMobject('En general, podemos escribir cualquier elemento en \\n\\n                             las coordenadas can\u00f3nicas, a las coordenadas ', '$\\\\gamma$', ' \\n\\n                            con la siguiente transformaci\u00f3n lineal.').move_to(1 * UP)\n        text5[1].set_color(BLUE_C)\n        text5_1 = TexMobject(\"f((x,y)_\\\\beta)=\\\\begin{bmatrix}\\n                                1 & 0\\\\\\\\\\n                                1 & 1\\n                                \\\\end{bmatrix}\\\\begin{bmatrix}\\n                                x\\\\\\\\\\n                                y\\n                                \\\\end{bmatrix}_\\\\beta=\\\\begin{bmatrix}\\n                                x' \\\\\\\\\\n                                y'\\n                                \\\\end{bmatrix}_\\\\gamma  \").move_to(text5.get_center() + 2 * DOWN)\n        linea1 = Arrow([0, -1, 0], [1, -1, 0], **ejes_config).set_color(YELLOW_C)\n        linea2 = Arrow([0, -1, 0], [0, 0, 0], **ejes_config).set_color(YELLOW_C)\n        Plano = VGroup(linea1, linea2)\n        beta1 = Arrow([0, -1, 0], [1, 1 - 1, 0], **ejes_config).set_color(BLUE_C)\n        beta2 = Arrow([0, -1, 0], [0, 1 - 1, 0], **ejes_config).set_color(BLUE_C)\n        beta = VGroup(beta1, beta2)\n        w = Arrow([0, -1, 0], [1, 2 - 1, 0], buff=0).set_color(PURPLE_C)\n        self.play(Write(titulo.scale(1.5)))\n        self.wait(4)\n        self.play(FadeOut(titulo))\n        self.play(Write(text1))\n        self.wait(6)\n        self.play(text1.shift, 3 * UP, runtime=6)\n        self.play(ShowCreation(beta))\n        self.play(FadeOut(text1))\n        self.play(Write(text2))\n        self.wait(2)\n        self.play(ShowCreation(Plano))\n        self.wait(12)\n        self.play(FadeOut(text2), FadeOut(Plano))\n        self.play(Write(text3))\n        self.play(ShowCreation(w))\n        self.wait(5.7)\n        self.play(FadeOut(text3))\n        self.play(Write(text4))\n        self.wait(13.2)\n        self.play(FadeOut(text4), FadeOut(w), FadeOut(beta))\n        self.play(Write(text5))\n        self.wait(8.7)\n        self.play(Write(text5_1))\n        self.wait(8)\n        self.play(FadeOut(text5), FadeOut(text5_1))\n\n    def parte2(self):\n        ejes_config = {'stroke_width': 3, 'buff': 0, 'max_tip_length_to_length_ratio': 0.1, 'max_stroke_width_to_length_ratio': 2, 'preserve_tip_size_when_scaling': False}\n        text6 = TextMobject('La funci\u00f3n lineal \"traduce\" los vectores en la base', ' \\n\\n                            $\\\\gamma$', ' a vectores en la base ', '$\\\\beta$.')\n        text6[1].set_color(YELLOW)\n        text6[3].set_color(BLUE_C)\n        text7 = TextMobject('M\u00e1s a\u00fan, debido a que el determinante de la matriz asociada \\n\\n                                 a la funci\u00f3n es diferente de 0, la funci\u00f3n posee \\n\\n                                 inversa y es biyectiva. ')\n        text8 = TextMobject('Entonces la funci\u00f3n que nos traduce los vectores \\n\\n                                 descritos con el conjunto ', '$\\x08eta$ ', 'a la \\n\\n                                 base ($\\\\gamma$)es').move_to(1 * UP)\n        text8[1].set_color(BLUE_C)\n        text8_1 = TexMobject(\"f^{-1} ((x,y)_\\\\beta)=\\\\begin{bmatrix}\\n                                                    1 & 0\\\\\\\\\\n                                                    -1 & 1\\n                                                    \\\\end{bmatrix}\\\\begin{bmatrix}\\n                                                    x\\\\\\\\\\n                                                    y\\n                                                    \\\\end{bmatrix}_\\\\beta=\\\\begin{bmatrix}\\n                                                    x' \\\\\\\\\\n                                                    y'\\n                                                    \\\\end{bmatrix}_\\\\gamma \").move_to(text8.get_center() + 2 * DOWN)\n        text9 = TextMobject('Como habr\u00e1s notado, en realidad', ' $\\\\gamma$', ' es \\n\\n                            una base del plano cartesiano porque \\n\\n                                a) sus elementos son linealmente independientes y \\n\\n                                b) podemos describir cualquier elemento del \\n\\n                                 plano como una combinaci\u00f3n de ambos elementos.\\n                            ').move_to(2 * UP)\n        text9[1].set_color(BLUE_C)\n        text10 = TextMobject('As\u00ed que realmente $f$ es una funci\u00f3n que traduce \\n\\n                            elementos de la base ', '$\\\\beta$', ' a la base', ' $\\\\gamma$ ').move_to(3 * UP)\n        text10[1].set_color(YELLOW)\n        text10[3].set_color(BLUE_C)\n        text11 = TextMobject('\u00bfBasta dar una funci\u00f3n biyectiva para aseverar\\n\\n                                 que es una funci\u00f3n de cambio de coordenadas? ')\n        linea1 = Arrow([0, -1, 0], [1, -1, 0], **ejes_config).set_color(YELLOW_C)\n        linea2 = Arrow([0, -1, 0], [0, 0, 0], **ejes_config).set_color(YELLOW_C)\n        Plano = VGroup(linea1, linea2).move_to(4 * LEFT + 1 * DOWN).scale(3)\n        beta1 = Arrow([4, 1, 0], [5, 2, 0], **ejes_config).set_color(BLUE_C)\n        beta2 = Arrow([4, 1, 0], [4, 2, 0], **ejes_config).set_color(BLUE_C)\n        beta = VGroup(beta1, beta2).scale(3).move_to(1 * DOWN + 4 * RIGHT)\n        beta3 = Arrow([0, 1, 0], [1, 2, 0], **ejes_config).set_color(BLUE_C)\n        beta4 = Arrow([0, 1, 0], [0, 2, 0], **ejes_config).set_color(BLUE_C)\n        beta_1 = VGroup(beta3, beta4).move_to(2 * DOWN).scale(3)\n        flecha = Arrow([-0.5, 0, 0], [0.5, 0, 0], buff=0)\n        self.play(Write(text6))\n        self.wait(8)\n        self.play(FadeOut(text6))\n        self.play(Write(text7))\n        self.wait(12)\n        self.play(FadeOut(text7))\n        self.play(Write(text8))\n        self.play(Write(text8_1))\n        self.wait(16)\n        self.play(FadeOut(text8), FadeOut(text8_1))\n        self.play(Write(text9))\n        self.play(ShowCreation(beta_1))\n        self.wait(11)\n        self.play(FadeOut(text9))\n        self.play(Write(text10))\n        self.wait(3)\n        self.play(ReplacementTransform(beta_1, beta), ShowCreation(Plano), ShowCreation(flecha))\n        self.wait(8.7)\n        self.play(FadeOut(text10), FadeOut(flecha), FadeOut(Plano), FadeOut(beta))\n        self.play(Write(text11))\n        self.wait(7.6)\n        self.play(FadeOut(text11))\n\n    def parte3(self):\n        ejes_config = {'stroke_width': 3, 'buff': 0, 'max_tip_length_to_length_ratio': 0.1, 'max_stroke_width_to_length_ratio': 2, 'preserve_tip_size_when_scaling': False}\n        text12 = TextMobject('No, los cambios de coordenadas deben preservar \\n\\n                                    la estructura algebraica.').move_to(1 * UP)\n        text12_1 = TextMobject('Consideremos la suma de dos vectores en las \\n\\n                                  coordenadas ', '$\\\\beta$. ').next_to(text12, DOWN, buff=1)\n        text12_1[1].set_color(YELLOW)\n        text13 = TextMobject('Para transformar este vector a las coordenadas ', '$\\\\gamma$', ' \\n\\n                                podemos transformar directamente el vector suma a las \\n\\n                                coordenadas ', '$\\\\gamma$. ').move_to(3 * UP)\n        text13[1].set_color(BLUE_C)\n        text13[3].set_color(BLUE_C)\n        text14 = TextMobject('O podemos convertir ambos vectores independientemente y \\n\\n                                realizar la suma de los vectores transformados en la base ', '$\\\\gamma$. ').move_to(3 * UP)\n        text14[1].set_color(BLUE_C)\n        text15 = TextMobject('Lo mismo debe ocurrir si multiplicamos un vector \\n\\n                                 por un escalar y lo convertimos de una base a otra. ').move_to(3 * UP)\n        linea1 = Arrow([-6.5, -1, 0], [-1.5, -1, 0], **ejes_config).set_color(YELLOW_C)\n        linea2 = Arrow([-4, -3, 0], [-4, 1, 0], **ejes_config).set_color(YELLOW_C)\n        Plano = VGroup(linea1, linea2)\n        beta1 = Arrow([1.5, -1 - 0.5, 0], [6.5, -1 + 0.5, 0], **ejes_config).set_color(BLUE_C)\n        beta2 = Arrow([4, -1 - 2, 0], [4, -1 + 2, 0], **ejes_config).set_color(BLUE_C)\n        beta = VGroup(beta1, beta2)\n        a = 1.5\n        b = 0\n        vec_1 = Arrow([-4, -1, 0], [a - 4, b - 1, 0], buff=0).set_color(PURPLE_C)\n        vec_1label = TexMobject('u_\\\\beta').next_to(vec_1, UP, buff=0.2).set_color(PURPLE_C)\n        a2 = 0.5\n        b2 = 1\n        vec_2 = Arrow([-4, -1, 0], [a2 - 4, -1 + b2, 0], buff=0).set_color(TEAL_D)\n        vec_2label = TexMobject('v_\\\\beta').next_to(vec_2, UP, buff=0.2).set_color(TEAL_D)\n        vectores = VGroup(vec_1, vec_2, vec_2label, vec_1label)\n        vec_suma = Arrow([-4, -1, 0], [a2 - 4 + a, -1 + b2 + b, 0], buff=0).set_color(GOLD_D)\n        vec_sumalabel = TexMobject('(u+v)_\\\\beta').next_to(vec_suma, UP, buff=0.2).set_color(GOLD_D)\n        suma = VGroup(vec_suma, vec_sumalabel)\n        flecha = Arrow([-0.7, 0, 0], [0.7, 0, 0])\n        vec_suma_t = Arrow([4, -1, 0], [a2 + 4 + a, -1 + b2 + b, 0], buff=0).set_color(GOLD_D)\n        vec_suma_tlabel = TexMobject('(u+v)_\\\\gamma').next_to(vec_suma_t, UP, buff=0.2).set_color(GOLD_D)\n        vec_suma_tG = VGroup(vec_suma_t, vec_suma_tlabel)\n        vec_suma_tlabel2 = TexMobject('u_\\\\gamma+v_\\\\gamma').next_to(vec_suma_t, UP, buff=0.2).set_color(GOLD_D)\n        vec_suma_tG2 = VGroup(vec_suma_t, vec_suma_tlabel2)\n        vec_1t = Arrow([4, -1, 0], [a + 4, b - 1, 0], buff=0).set_color(PURPLE_C)\n        vec_1tlabel = TexMobject('u_\\\\gamma').next_to(vec_1t, UP, buff=0.2).set_color(PURPLE_C)\n        vec_2t = Arrow([4, -1, 0], [a2 + 4, -1 + b2, 0], buff=0).set_color(TEAL_D)\n        vec_2tlabel = TexMobject('v_\\\\gamma').next_to(vec_2t, UP, buff=0.2).set_color(TEAL_D)\n        vectorest = VGroup(vec_1t, vec_2t, vec_2tlabel, vec_1tlabel)\n        c = 0.3\n        x = 1\n        y = 1.5\n        vector_1 = Arrow([-4, -1, 0], [x - 4, y - 1, 0], buff=0).set_color(PURPLE_C)\n        vector1_label = TexMobject('x_\\\\beta').next_to(vector_1, UP, buff=0.2).set_color(PURPLE_C)\n        vector = VGroup(vector_1, vector1_label)\n        vector_2 = Arrow([-4, -1, 0], [x * c - 4, y * c - 1, 0], buff=0).set_color(PURPLE_C)\n        vector2_label = TexMobject('(kx)_\\\\beta').next_to(vector_2, UP + RIGHT, buff=0.2).set_color(PURPLE_C)\n        vector2 = VGroup(vector_2, vector2_label)\n        vector_1t = Arrow([4, -1, 0], [x + 4, y - 1, 0], buff=0).set_color(PURPLE_C)\n        vector1t_label = TexMobject('x_\\\\gamma').next_to(vector_1t, UP + RIGHT, buff=0.2).set_color(PURPLE_C)\n        vectort = VGroup(vector_1t, vector1t_label)\n        vector_2t = Arrow([4, -1, 0], [x * c + 4, y * c - 1, 0], buff=0).set_color(PURPLE_C)\n        vector2t_label = TexMobject('(kx)_\\\\gamma').next_to(vector_2t, UP + RIGHT, buff=0.2).set_color(PURPLE_C)\n        vector2t = VGroup(vector_2t, vector2t_label)\n        vector2t_label2 = TexMobject('k(x)_\\\\gamma').next_to(vector_2t, UP + RIGHT, buff=0.2).set_color(PURPLE_C)\n        vectort_2 = VGroup(vector_2t, vector2t_label2)\n        self.play(Write(text12[0]))\n        self.wait(5.8)\n        self.play(Write(text12_1))\n        self.wait(5.8)\n        self.play(FadeOut(text12[0]))\n        self.play(text12_1.shift, 3.5 * UP, runtime=6)\n        self.play(ShowCreation(Plano))\n        self.play(ShowCreation(vectores))\n        self.wait()\n        self.play(FadeOut(text12_1))\n        self.play(Write(text13))\n        self.wait(5)\n        self.play(FadeOut(vectores))\n        self.play(ShowCreation(vec_suma), Write(vec_sumalabel))\n        self.wait(6)\n        self.play(ShowCreation(beta))\n        self.wait()\n        self.play(ShowCreation(flecha))\n        self.wait()\n        self.play(ShowCreation(vec_suma_tG))\n        self.wait(5)\n        self.play(FadeOut(text13))\n        self.play(Write(text14), FadeOut(vec_suma_tG), FadeOut(vec_suma), FadeOut(vec_sumalabel), FadeOut(flecha))\n        self.wait(8.3)\n        self.play(ShowCreation(vectores))\n        self.wait()\n        self.play(ShowCreation(flecha))\n        self.wait()\n        self.play(ShowCreation(vectorest))\n        self.play(ReplacementTransform(vectorest, vec_suma_tG2), ReplacementTransform(vectores, suma))\n        self.wait(7)\n        self.play(FadeOut(vec_suma_tG2), FadeOut(suma), FadeOut(flecha), FadeOut(text14))\n        self.play(Write(text15))\n        self.wait(7)\n        self.play(ShowCreation(vector))\n        self.wait()\n        self.play(ShowCreation(flecha))\n        self.wait()\n        self.play(ShowCreation(vectort))\n        self.wait(2)\n        self.play(ReplacementTransform(vector, vector2), ReplacementTransform(vectort, vectort_2))\n        self.wait(3)\n        self.play(FadeOut(vector2), FadeOut(vectort_2))\n        self.play(ShowCreation(vector2))\n        self.wait()\n        self.play(ShowCreation(flecha))\n        self.wait()\n        self.play(ShowCreation(vector2t))\n        self.wait(5)\n        self.play(FadeOut(text15), FadeOut(Plano), FadeOut(beta), FadeOut(vector2), FadeOut(vector2t), FadeOut(flecha))\n\n    def parte4(self):\n        ejes_config = {'stroke_width': 3, 'buff': 0, 'max_tip_length_to_length_ratio': 0.1, 'max_stroke_width_to_length_ratio': 2, 'preserve_tip_size_when_scaling': False}\n        text16 = TextMobject(' Es decir, la funci\u00f3n debe ser un isomorfismo.')\n        text17 = TextMobject('En conclusi\u00f3n, para considerar una funci\u00f3n $L$ como un \\n\\n                                 cambio de coordenadas, dicha funci\u00f3n debe ser \\n\\n                                 biyectiva y cumplir con el diagrama de conmutatividad. ')\n        diagrama = SVGMobject('Diagrama_conmutatividad.svg', fill_color=WHITE, color=WHITE).move_to(1 * DOWN)\n        linea1 = Arrow([-6.5, -1, 0], [-1.5, -1, 0], **ejes_config).set_color(YELLOW_C)\n        linea2 = Arrow([-4, -3, 0], [-4, 1, 0], **ejes_config).set_color(YELLOW_C)\n        Plano = VGroup(linea1, linea2).scale(0.6).move_to(0 * UP + 2.5 * LEFT)\n        linea1_2 = Arrow([-6.5, -1, 0], [-1.5, -1, 0], **ejes_config).set_color(YELLOW_C)\n        linea2_2 = Arrow([-4, -3, 0], [-4, 1, 0], **ejes_config).set_color(YELLOW_C)\n        Plano_2 = VGroup(linea1_2, linea2_2).scale(0.6).move_to(0 * UP + 2.5 * RIGHT)\n        linea1_3 = Arrow([-6.5, -1, 0], [-1.5, -1, 0], **ejes_config).set_color(YELLOW_C)\n        linea2_3 = Arrow([-4, -3, 0], [-4, 1, 0], **ejes_config).set_color(YELLOW_C)\n        Plano_3 = VGroup(linea1_3, linea2_3).scale(0.6).move_to(-3 * UP + 2.5 * LEFT)\n        linea1_4 = Arrow([-6.5, -1, 0], [-1.5, -1, 0], **ejes_config).set_color(YELLOW_C)\n        linea2_4 = Arrow([-4, -3, 0], [-4, 1, 0], **ejes_config).set_color(YELLOW_C)\n        Plano_4 = VGroup(linea1_4, linea2_4).scale(0.6).move_to(-3 * UP + 2.5 * RIGHT)\n        espacio = VGroup(Plano, Plano_2, Plano_3, Plano_4)\n        x = Dot(color=YELLOW).move_to(Plano.get_center() + 0.5 * UP - 0.5 * RIGHT)\n        xl = TexMobject('\\\\vec{x}_\\\\beta').next_to(x, LEFT)\n        y = Dot(color=BLUE_E).move_to(Plano.get_center() + 0.7 * UP + 1 * RIGHT)\n        yl = TexMobject('\\\\vec{y}_\\\\beta').next_to(y, RIGHT)\n        vectores1 = VGroup(x, xl, y, yl)\n        x_y = Dot(color=GOLD_C).move_to(Plano_2.get_center() + 1.2 * UP + 0.5 * RIGHT)\n        x_yl = TexMobject('\\\\vec{x}_\\\\beta+\\\\vec{y}_\\\\beta').next_to(x_y, RIGHT)\n        vectores2 = VGroup(x_y, x_yl)\n        flecha1 = Arrow([-0.2, 0, 0], [0.2, 0, 0]).scale(2).move_to(0.5 * UP)\n        suma = TexMobject('+').next_to(flecha1, UP, buff=0.1)\n        f1 = VGroup(flecha1, suma)\n        flecha2 = Arrow([0, 0.2, 0], [0, -0.2, 0]).scale(2).move_to(4 * RIGHT + 1.5 * DOWN)\n        L = TexMobject('L').next_to(flecha2, RIGHT, buff=0.1)\n        L1 = VGroup(flecha2, L)\n        x_yTrans = Dot(color=RED).move_to(Plano_4.get_center() - 0.2 * UP + 0.5 * RIGHT)\n        x_yTransl = TexMobject('\\\\vec{x}_\\\\gamma+\\\\vec{y}_\\\\gamma').next_to(x_yTrans, DOWN, buff=0.1)\n        vectores3 = VGroup(x_yTrans, x_yTransl)\n        xt = Dot(color=YELLOW).move_to(Plano_3.get_center() + 0.3 * UP - 0.2 * RIGHT)\n        xtl = TexMobject('\\\\vec{x}_\\\\gamma').next_to(xt, LEFT)\n        yt = Dot(color=BLUE_E).move_to(Plano_3.get_center() + 0.7 * UP - 0.3 * RIGHT)\n        ytl = TexMobject('\\\\vec{y}_\\\\gamma').next_to(yt, RIGHT)\n        vectores4 = VGroup(xt, xtl, yt, ytl)\n        flecha3 = Arrow([0, 0.2, 0], [0, -0.2, 0]).scale(2).move_to(4 * LEFT + 1.5 * DOWN)\n        L_2 = TexMobject('L').next_to(flecha3, LEFT, buff=0.1)\n        L2 = VGroup(flecha3, L_2)\n        flecha4 = Arrow([-0.2, 0, 0], [0.2, 0, 0]).scale(2).move_to(-3 * UP)\n        suma_2 = TexMobject('+').next_to(flecha4, UP, buff=0.1)\n        f2 = VGroup(flecha4, suma_2)\n        DIAGRAMA = VGroup(espacio, vectores1, vectores2, f1, L1, vectores3, vectores4, L2, f2)\n        mult1 = TexMobject('*').move_to(suma)\n        mult2 = TexMobject('*').move_to(suma_2)\n        c = 2.3\n        cx = Dot(color=GOLD_C).move_to(Plano_2.get_center() + 0.5 * c * UP + -0.5 * c * RIGHT)\n        cxl = TexMobject('k\\\\vec{x}_\\\\beta').next_to(cx, RIGHT)\n        cxt = Dot(color=YELLOW).move_to(Plano_4.get_center() + 0.3 * c * UP - 0.2 * c * RIGHT)\n        cxtl = TexMobject('k\\\\vec{x}_\\\\gamma').next_to(cxt, LEFT)\n        Borrar = VGroup(y, yl, yt, ytl)\n        Transformar1 = VGroup(suma, suma_2, vectores3, vectores2)\n        Transformar2 = VGroup(mult1, mult2, cx, cxl, cxt, cxtl)\n        Borrar2 = VGroup(x, xl, xt, xtl, flecha1, L1, L2, flecha4)\n        self.play(Write(text16))\n        self.wait(6)\n        self.play(FadeOut(text16))\n        self.play(Write(text17))\n        self.play(text17.shift, 2.5 * UP, runtime=6)\n        self.play(ShowCreation(DIAGRAMA))\n        self.wait(10)\n        self.play(FadeOut(Borrar), ReplacementTransform(Transformar1, Transformar2))\n        self.wait(10)\n        self.play(FadeOut(text17), FadeOut(Transformar2), FadeOut(espacio), FadeOut(Borrar2))\n\n    def construct(self):\n        self.parte1()\n        self.parte2()\n        self.parte3()\n        self.parte4()"}]}
{"messages": [{"role": "user", "content": "Show a 3D animation that introduces parametrized surfaces with examples of a sphere, torus, and M\u00f6bius strip, including explanations of their mathematical definitions and visual representations."}, {"role": "assistant", "content": "from sys import float_repr_style\nfrom manimlib.imports import *\n\nclass superficies_parametrizadas(ThreeDScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        ThreeDScene.setup(self)\n\n    def FadeOutWrite3D(self, objeto1, objeto2):\n        self.play(FadeOut(objeto1))\n        self.acomodar_textos(objeto2)\n\n    def acomodar_textos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.play(Write(objeto))\n\n    def superficie(self):\n        superficie = ParametricSurface(lambda u, v: np.array([u, v, 2 * math.exp(-1 * (u ** 2 + v ** 2))]), v_min=-3, v_max=3, u_min=-3, u_max=3, fill_color=PURPLE_E, fill_opacity=0.75, resolution=(30, 30))\n        return superficie\n\n    def punto3D(self):\n        bola = ParametricSurface(lambda u, v: np.array([0.075 * np.cos(v) * np.sin(u), 0.075 * np.sin(v) * np.sin(u), 0.075 * np.cos(u)]), v_min=0, v_max=TAU, u_min=0.001, u_max=PI - 0.001, resolution=(24, 24), fill_opacity=1, stroke_color=RED, fill_color=RED)\n        return bola\n\n    def PrimeraEscena(self):\n        texto_1 = TextMobject('Sea $\\\\sigma$ la parametrizaci\u00f3n de una superficie, \\n\\n                                definida de la siguiente forma').move_to(1 * UP)\n        texto_2_1 = TexMobject('\\\\sigma=(\\\\sigma_1,\\\\sigma_2,\\\\sigma_3):[-3,3]\\\\times[-3,3]\\\\in\\\\mathbb{R}^2\\\\to\\\\mathbb{R}^3').next_to(texto_1, 1 * DOWN)\n        texto_2_2 = TexMobject('\\\\sigma(x,y)=(x,y,2e^{-(x^2+y^2)})').next_to(texto_2_1, DOWN)\n        texto_2 = VGroup(texto_2_1, texto_2_2)\n        axes = ThreeDAxes(x_min=-3.5, x_max=3.5, y_min=-3.5, y_max=3.5, z_min=-1, z_max=3, num_axis_pieces=30)\n        superficie = self.superficie()\n        self.play(Write(texto_1))\n        self.wait(5)\n        self.play(Write(texto_2))\n        self.wait(5)\n        self.play(FadeOut(texto_1))\n        self.play(texto_2.shift, 3.5 * UP)\n        self.add_fixed_in_frame_mobjects(texto_2)\n        self.wait(0.5)\n        self.move_camera(phi=70 * DEGREES, theta=-30 * DEGREES, frame_center=(0, 0, 1))\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie))\n        self.wait(4)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.move_camera(phi=0, theta=-90 * DEGREES, frame_center=(0, 0, 0))\n\n    def SegundaEscena(self):\n        texto_1 = TextMobject('Consideremos la matriz jacobiana o derivada \\n\\n                                    de $\\\\sigma$, definida como').move_to(3 * UP)\n        texto_2 = TexMobject('D\\\\sigma(\\\\hat{x}_0)=\\\\begin{pmatrix} \\\\dfrac{\\\\partial \\\\sigma_1}{\\\\partial x}(\\\\hat{x}_0) &  \\\\dfrac{\\\\partial \\\\sigma_1}{\\\\partial y}(\\\\hat{x}_0)  \\\\\\\\ \\\\dfrac{\\\\partial \\\\sigma_2}{\\\\partial x}(\\\\hat{x}_0) & \\\\dfrac{\\\\partial \\\\sigma_2}{\\\\partial y}(\\\\hat{x}_0) \\\\\\\\ \\\\dfrac{\\\\partial \\\\sigma_3}{\\\\partial x}(\\\\hat{x}_0) & \\\\dfrac{\\\\partial \\\\sigma_3}{\\\\partial y}(\\\\hat{x}_0)\\\\end{pmatrix}')\n        texto_3 = TextMobject('En el ejemplo, tomemos $\\\\hat{x}_0=(0.2,0.2)$').move_to(3 * UP)\n        texto_4 = TexMobject('\\\\text{Entonces, } D\\\\sigma(\\\\hat{x}_0)=\\\\begin{pmatrix} 1 & 0 \\\\\\\\ 0 & 1 \\\\\\\\ -0.74 & -0.74  \\\\end{pmatrix}').move_to(2.5 * UP)\n        texto_5 = TextMobject(' A partir de la matriz $D\\\\sigma(\\\\hat{x}_0)$, es posible\\n\\n                                calcular las derivadas parciales de $\\\\sigma$ en $\\\\hat{x}_0$ ').move_to(3 * UP)\n        texto_6 = TexMobject('\\\\dfrac{\\\\partial \\\\sigma}{\\\\partial x}(\\\\hat{x}_0)=\\\\begin{pmatrix} 1 & 0 \\\\\\\\ 0 & 1 \\\\\\\\ -0.74 & -0.74  \\\\end{pmatrix}\\\\begin{pmatrix} 1 \\\\\\\\ 0 \\\\end{pmatrix}=\\\\begin{pmatrix} 1 \\\\\\\\ 0 \\\\\\\\ -0.74 \\\\end{pmatrix}').move_to(2.5 * UP)\n        texto_7 = TexMobject('\\\\dfrac{\\\\partial \\\\sigma}{\\\\partial y}(\\\\hat{x}_0)=\\\\begin{pmatrix} 1 & 0 \\\\\\\\ 0 & 1 \\\\\\\\ -0.74 & -0.74  \\\\end{pmatrix}\\\\begin{pmatrix} 0 \\\\\\\\ 1 \\\\end{pmatrix}=\\\\begin{pmatrix} 0 \\\\\\\\ 1 \\\\\\\\ -0.74 \\\\end{pmatrix} ').move_to(2.5 * UP)\n        texto_8 = TextMobject(' Los vectores $\\\\dfrac{\\\\partial \\\\sigma}{\\\\partial x}(\\\\hat{x}_0)$ y $\\\\dfrac{\\\\partial \\\\sigma}{\\\\partial y}(\\\\hat{x}_0)$ son vectores tangentes\\n\\n                                a la superficie en el punto $\\\\sigma(\\\\hat{x}_0)$').move_to(3 * UP)\n        texto_9 = TextMobject(' Definimos $\\\\dfrac{\\\\partial \\\\sigma}{\\\\partial x}(\\\\hat{x}_0) \\\\times \\\\dfrac{\\\\partial \\\\sigma}{\\\\partial y}(\\\\hat{x}_0)$ como el vector normal a la\\n\\n                                superficie en $\\\\sigma(\\\\hat{x}_0)$, inducida por la parametrizaci\u00f3n $\\\\sigma$ ').move_to(3 * UP)\n        texto_10 = TextMobject(' Este vector genera un plano tangente a la superficie en $\\\\sigma(\\\\hat{x}_0)$, \\n\\n                                con la ecuaci\u00f3n normal del plano.').move_to(3 * UP)\n        texto_11 = TextMobject(' Si $\\\\hat{x}_0$ corresponde a un punto cr\u00edtico de $\\\\sigma$, puede ocurrir que\\n\\n                                $\\\\dfrac{\\\\partial \\\\sigma}{\\\\partial x}(\\\\hat{x}_0) =\\\\vec{0}= \\\\dfrac{\\\\partial \\\\sigma}{\\\\partial y}(\\\\hat{x}_0)$ y entonces la superficie no tiene\\n\\n                                plano tangente definido en el punto. ').move_to(2.5 * UP)\n        texto_12 = TextMobject('Lo mismo ocurre si las parciales son linealmente dependientes.\\n\\nNuestro ejemplo no tiene puntos cr\u00edticos.').move_to(3 * UP)\n        etiqueta_1 = TexMobject('\\\\dfrac{\\\\partial \\\\sigma}{\\\\partial x}(\\\\hat{x}_0)=\\\\begin{pmatrix} 1 \\\\\\\\ 0 \\\\\\\\ -0.74 \\\\end{pmatrix} ').scale(0.75).set_color(PINK).move_to(4 * RIGHT)\n        etiqueta_2 = TexMobject('\\\\dfrac{\\\\partial \\\\sigma}{\\\\partial y}(\\\\hat{x}_0)=\\\\begin{pmatrix} 0 \\\\\\\\ 1 \\\\\\\\ -0.74 \\\\end{pmatrix} ').scale(0.75).set_color(YELLOW_E).next_to(etiqueta_1, DOWN)\n        axes = ThreeDAxes(x_min=-3.5, x_max=3.5, y_min=-3.5, y_max=3.5, z_min=-1, z_max=3, num_axis_pieces=30)\n        superficie = self.superficie()\n        punto = self.punto3D().move_to((0.2, 0.2, 1.846))\n        punto_critico = self.punto3D().move_to((0, 0, 2))\n        dot = Dot().move_to(0.2).move_to(0.2 * RIGHT + 0.2 * UP)\n        linea = DashedLine((0.2, 0.2, 0), (0.2, 0.2, 1.846))\n        plano = ParametricSurface(lambda u, v: np.array([u, v, 2.15 - 0.74 * (u + v)]), v_min=-0.5, v_max=1, u_min=-0.5, u_max=1, fill_color=GREEN, fill_opacity=1, checkerboard_colors=[GREEN, GREEN], resolution=(1, 1))\n        parcial_x = Arrow(start=(0.2, 0.2, 1.846), end=(1.2, 0.2, 1.106)).set_color(PINK)\n        parcial_y_1 = Arrow(start=(0.2, 0.2, 1.846), end=(0.2, 1.2, 1.106)).set_color(YELLOW_E)\n        parcial_y_arrow_tip = ArrowTip().set_color(YELLOW_E).scale(0.45).rotate_in_place(155 * DEGREES).move_to(2.4 * LEFT + 0.65 * DOWN)\n        parcial_y = VGroup(parcial_y_1, parcial_y_arrow_tip)\n        vector_normal_1 = Arrow(start=(0.2, 0.2, 1.846), end=(0.94, 0.94, 2.846))\n        vector_normal_arrow_tip = ArrowTip().set_color(WHITE).scale(0.65).rotate_in_place(-15 * DEGREES).move_to(2.27 * LEFT + 0.23 * UP)\n        vector_normal = VGroup(vector_normal_1, vector_normal_arrow_tip)\n        self.play(Write(texto_1))\n        self.wait(5.7)\n        self.play(Write(texto_2))\n        self.wait(3)\n        self.play(FadeOut(texto_1), FadeOut(texto_2))\n        self.acomodar_textos(texto_3)\n        self.wait()\n        self.move_camera(phi=70 * DEGREES, theta=-30 * DEGREES, frame_center=(-3, 2, 3), distance=1000)\n        self.play(ShowCreation(axes))\n        self.play(FadeIn(dot))\n        self.wait()\n        self.play(ShowCreation(linea))\n        self.wait(0.4)\n        self.play(FadeIn(punto))\n        self.play(ShowCreation(superficie))\n        self.play(FadeOut(linea), FadeOut(dot))\n        self.FadeOutWrite3D(texto_3, texto_4)\n        self.wait(3)\n        self.FadeOutWrite3D(texto_4, texto_5)\n        self.wait(8)\n        self.FadeOutWrite3D(texto_5, texto_6)\n        self.wait(3)\n        self.play(ReplacementTransform(texto_6, etiqueta_1))\n        self.add_fixed_in_frame_mobjects(etiqueta_1)\n        self.play(FadeIn(parcial_x))\n        self.wait()\n        self.FadeOutWrite3D(texto_6, texto_7)\n        self.wait(3)\n        self.play(ReplacementTransform(texto_7, etiqueta_2))\n        self.add_fixed_in_frame_mobjects(etiqueta_2)\n        self.add_fixed_in_frame_mobjects(parcial_y_arrow_tip)\n        self.play(FadeIn(parcial_y_arrow_tip), FadeIn(parcial_y_1))\n        self.wait(3)\n        self.acomodar_textos(texto_8)\n        self.wait(22)\n        self.FadeOutWrite3D(texto_8, texto_9)\n        self.wait(7)\n        self.add_fixed_in_frame_mobjects(vector_normal_arrow_tip)\n        self.play(FadeIn(vector_normal_arrow_tip), FadeIn(vector_normal_1))\n        self.wait()\n        self.FadeOutWrite3D(texto_9, texto_10)\n        self.wait(5)\n        self.play(ShowCreation(plano))\n        self.bring_to_front(plano)\n        self.wait(3)\n        self.play(FadeOut(vector_normal), FadeOut(parcial_y), FadeOut(parcial_x), FadeOut(etiqueta_1), FadeOut(etiqueta_2))\n        self.play(FadeOut(plano), FadeOut(punto))\n        self.FadeOutWrite3D(texto_10, texto_11)\n        self.play(FadeIn(punto_critico))\n        self.wait(25)\n        self.FadeOutWrite3D(texto_11, texto_12)\n        self.wait(5.6)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.move_camera(phi=0, theta=-90 * DEGREES, frame_center=(0, 0, 0))\n\n    def TerceraEscena(self):\n        texto_1 = TextMobject(' Ahora veamos ejemplos de \\n\\n                                    superficies parametrizadas ')\n        texto_2_1 = TextMobject('$\\\\sigma(x,y)=(\\\\cos{(x)}\\\\sin{(y)},\\\\sin{(x)}\\\\sin{(y)},\\\\cos{(y)})$').move_to(3 * UP)\n        texto_2_2 = TextMobject('con $(x,y)\\\\in [0,2\\\\pi]\\\\times[0,\\\\pi]$').next_to(texto_2_1, DOWN)\n        texto_2_3 = TextMobject('Esfera Unitaria').set_color(PINK).move_to(4 * LEFT + 0.5 * UP)\n        texto_2 = VGroup(texto_2_1, texto_2_2)\n        texto_3_1 = TextMobject('$\\\\sigma(x,y)=((R+r\\\\cos{(y)})\\\\cos{(x)},(R+r\\\\cos{(y)})\\\\sin{(x)},r\\\\sin{(y)})$').move_to(3 * UP)\n        texto_3_2 = TextMobject('con $(x,y)\\\\in [0,2\\\\pi]\\\\times[0,2\\\\pi]$').next_to(texto_3_1, DOWN)\n        texto_3_3 = TextMobject('Toro').set_color(PINK).move_to(4 * LEFT + 0.5 * UP)\n        texto_3 = VGroup(texto_3_1, texto_3_2)\n        texto_4_1 = TextMobject('$\\\\sigma(x,y)=((2+y\\\\cos{(x/2)})\\\\cos{(x)},(2+y\\\\cos{(x/2)})\\\\sin{(x)},y\\\\sin{(x/2)})$').move_to(3 * UP).scale(0.9)\n        texto_4_2 = TextMobject('con $(x,y)\\\\in[0,2\\\\pi]\\\\times[-1,1]$').next_to(texto_4_1, DOWN)\n        texto_4_3 = TextMobject('Banda de M\u00f6bius').set_color(PINK).move_to(4 * LEFT + 0.5 * UP)\n        texto_4 = VGroup(texto_4_1, texto_4_2)\n        axes = ThreeDAxes(x_min=-3.5, x_max=3.5, y_min=-3.5, y_max=3.5, z_min=-2.5, z_max=3, num_axis_pieces=30)\n        toro_R = DashedLine((0, 0, 0), (-1.41, 1.41, 0))\n        etiqueta_R = TextMobject('$R$').move_to(1.1 * RIGHT + 0.95 * DOWN).scale(0.7)\n        toro_r = DashedLine((-1.41, 1.41, 0), (-1.41, 1.41, 0.5))\n        etiqueta_r = TextMobject('$r$').move_to(2 * RIGHT + 0.9 * DOWN).scale(0.7)\n        esfera = ParametricSurface(lambda u, v: np.array([np.cos(v) * np.sin(u), np.sin(v) * np.sin(u), np.cos(u)]), v_min=0.0001, v_max=2 * PI - 0.0001, u_min=0.0001, u_max=PI - 0.0001, fill_color=GOLD_E, fill_opacity=1, checkerboard_colors=[PINK, LIGHT_PINK], resolution=(20, 30))\n        toro = ParametricSurface(lambda u, v: np.array([(2 + 0.5 * np.cos(v)) * np.cos(u), (2 + 0.5 * np.cos(v)) * np.sin(u), 0.5 * np.sin(v)]), v_min=0.0001, v_max=2 * PI - 0.0001, u_min=0.0001, u_max=2 * PI - 0.0001, fill_color=GOLD_E, fill_opacity=1, checkerboard_colors=[PINK, LIGHT_PINK], resolution=(20, 30))\n        parte_toro = ParametricSurface(lambda u, v: np.array([-1.41 - 0.5 * 0.7 * np.sin(u), 1.41 + 0.5 * 0.7 * np.sin(u), 0.5 * np.cos(u)]), u_min=0.0001, u_max=2 * PI - 0.0001, fill_color=GOLD_E, fill_opacity=1, checkerboard_colors=[GOLD_E, GOLD_D], resolution=(20, 30))\n        moebius = ParametricSurface(lambda u, v: np.array([(2 + v * np.cos(u / 2)) * np.cos(u), (2 + v * np.cos(u / 2)) * np.sin(u), v * np.sin(u / 2)]), u_min=0.0001, u_max=2 * PI - 0.0001, v_min=-1, v_max=1, fill_color=PINK, fill_opacity=1, checkerboard_colors=[PINK, LIGHT_PINK], resolution=(20, 30))\n        self.play(Write(texto_1))\n        self.wait(3)\n        self.play(FadeOut(texto_1))\n        self.move_camera(phi=70 * DEGREES, theta=-30 * DEGREES, frame_center=(0, 0, 1.5))\n        self.play(ShowCreation(axes))\n        self.acomodar_textos(texto_2)\n        self.acomodar_textos(texto_2_3)\n        self.wait()\n        self.play(ShowCreation(esfera))\n        self.begin_ambient_camera_rotation(rate=0.25)\n        self.wait(4)\n        self.stop_ambient_camera_rotation()\n        self.play(FadeOut(esfera), FadeOut(texto_2_3))\n        self.FadeOutWrite3D(texto_2, texto_3)\n        self.acomodar_textos(texto_3_3)\n        self.wait()\n        self.play(ShowCreation(toro_R))\n        self.acomodar_textos(etiqueta_R)\n        self.wait()\n        self.play(ShowCreation(toro_r))\n        self.acomodar_textos(etiqueta_r)\n        self.wait()\n        self.play(ShowCreation(parte_toro))\n        self.wait()\n        self.play(FadeOut(toro_R), FadeOut(toro_r), FadeOut(etiqueta_R), FadeOut(etiqueta_r))\n        self.play(ShowCreation(toro))\n        self.play(FadeOut(parte_toro))\n        self.begin_ambient_camera_rotation(rate=0.25)\n        self.wait(4)\n        self.stop_ambient_camera_rotation()\n        self.play(FadeOut(toro), FadeOut(texto_3_3))\n        self.FadeOutWrite3D(texto_3, texto_4)\n        self.acomodar_textos(texto_4_3)\n        self.wait()\n        self.play(ShowCreation(moebius))\n        self.wait()\n        self.begin_ambient_camera_rotation(rate=0.25)\n        self.wait(10)\n        self.stop_ambient_camera_rotation()\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n\n    def construct(self):\n        titulo = TextMobject('Funciones de $\\\\mathbb{R}^2$ en $\\\\mathbb{R}^3$\\n\\n                             Superficies Parametrizadas').scale(1.5)\n        self.play(Write(titulo))\n        self.wait(2)\n        self.play(FadeOut(titulo))\n        self.PrimeraEscena()\n        self.SegundaEscena()\n        self.TerceraEscena()"}]}
{"messages": [{"role": "user", "content": "Render a series of dots on a screen grid based on predefined x and y coordinates."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass PathScene(Scene):\n    CONFIG = {'x_coords': [0, 1, 3, -2, -3], 'y_coords': [3, -2, 1, 2.5, -1]}\n\n    def setup(self):\n        self.screen_grid = ScreenGrid()\n        self.tuples = list(zip(self.x_coords, self.y_coords))\n        dots = self.get_all_mobs()\n        self.add(self.screen_grid, dots)\n\n    def get_dots(self, coords):\n        dots = VGroup(*[Dot(coord(x, y)) for x, y in coords])\n        return dots\n\n    def get_all_mobs(self):\n        dots = self.get_dots(self.tuples)\n        return dots"}]}
{"messages": [{"role": "user", "content": "Present a detailed explanation and demonstration of the Implicit Function Theorem using animated mathematical concepts and examples in 2D and 3D."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Teorema_de_la_funcion_implicita(ThreeDScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        ThreeDScene.setup(self)\n\n    def acomodar_textos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.play(Write(objeto))\n\n    def Primera_escena(self):\n        titulo = TextMobject('Teorema de la funci\u00f3n \\n\\n                                impl\u00edcita en funciones de \\n \\n                                $\\\\mathbb{R}^2\\\\to\\\\mathbb{{R}}$').scale(2)\n        text1 = TextMobject(\"Sea $f:D \\\\subset \\\\mathbb{R}^2\\\\to \\\\mathbb{R}$, $D$ abierto y $f \\\\in C^1_D$.\\n\\n                                Sea $(x_0,y_0)\\\\in D$ y $f(x_0,y_0)=k$ para alguna $k\\\\in \\\\mathbb{R}$ y\\n\\n                                $\\\\frac{\\\\partial f}{\\\\partial y}(x_0,y_0) \\\\neq 0$, entonces para alguna $\\\\epsilon>0$ \\n\\n                                $\\\\exists !$ tal que $g:V_\\\\epsilon(x_0)\\\\to \\\\mathbb{R}$ es acotada, $g\\\\in C^1_{V_\\\\epsilon(x_0)}$ y \\n\\n                                $f(x,g(x))=k$ para toda $x\\\\in V_\\\\epsilon(x_0)$.\\n\\n                                Adem\u00e1s $$g'(x)=\\\\frac{-\\\\frac{\\\\partial f}{\\\\partial x}  (x,g(x))}{\\\\frac{\\\\partial f}{\\\\partial y} (x,g(x))}.$$\")\n        text1_1 = TextMobject('Este teorema nos dice que en estas condiciones \\n\\n                                    el conjunto de nivel que corresponde \\n\\n                                    a ', '$k=f(x_0,y_0)$', ' es localmente una curva \\n\\n                                    suave dada por la gr\u00e1fica de ', '$g$', ' y adem\u00e1s la \\n\\n                                    derivada de ', '$g$', ' est\u00e1 en t\u00e9rminos de las parciales de', ' $f$. ')\n        text1_1.set_color_by_tex_to_color_map({'$k=f(x_0,y_0)$': YELLOW, '$g$': YELLOW, ' $f$': ORANGE})\n        text2 = TextMobject('Considera la funci\u00f3n', ' $f(x,y)=x^2-y$ ', 'y su ', 'curva de nivel 0', '. ').move_to(-3.5 * UP)\n        text2.set_color_by_tex_to_color_map({\"' $f(x,y)=x^2-y$ \": PURPLE_C, 'curva de nivel 0': TEAL_E})\n        text2.bg = SurroundingRectangle(text2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text3 = TextMobject('Nota que \\n\\n                             $\\\\frac{\\\\partial f}{\\\\partial y}(x,y)=-1 $ ').move_to(-3 * UP)\n        text3.bg = SurroundingRectangle(text3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text4 = TextMobject('Puedes comprobar que en cualquier punto se cumplen\\n\\n                                 las condiciones del ', 'teorema de la  \\n\\n                                 funci\u00f3n impl\u00edcita.').move_to(-2.5 * UP)\n        text4.set_color_by_tex_to_color_map({'teorema de la  \\n\\n                                 funci\u00f3n impl\u00edcita.': ORANGE})\n        text4.bg = SurroundingRectangle(text4, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text5 = TextMobject('Observa que la ', 'curva de nivel', ', en t\u00e9rminos de \\n\\n                                la variable $x$, queda descrita como ', '$y(x)=g(x)=x^2$', '.').move_to(-3 * UP)\n        text5.set_color_by_tex_to_color_map({'$y(x)=g(x)=x^2$': TEAL_E, 'curva de nivel': TEAL_E})\n        text5.bg = SurroundingRectangle(text5, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text6 = TextMobject(' Sin embargo, no siempre se puede encontrar \\n\\n                                expl\u00edcitamente a la funci\u00f3n ', '$g$', ', porque no \\n\\n                                siempre se puede despejar la $y$ en t\u00e9rminos \\n\\n                                de la $x$ en la ecuaci\u00f3n ', '$f(x,y)=k$', '. ')\n        text6.set_color_by_tex_to_color_map({'$g$': TEAL_E, '$f(x,y)=k$': PURPLE_C})\n        ejes = ThreeDAxes(y_max=3)\n        eje_x = TexMobject('x').move_to(6 * RIGHT).scale(1.5)\n        eje_y = TexMobject('y').move_to(3.5 * UP).scale(1.5)\n        axes = VGroup(ejes, eje_x, eje_y)\n        superficie1 = ParametricSurface(lambda u, v: np.array([u, v, u ** 2 - v]), v_min=-3, v_max=2, u_min=-3, u_max=2, fill_opacity=0.75, checkerboard_colors=[PURPLE_A, PURPLE_A])\n        curva1 = ParametricFunction(lambda u: np.array([u, u ** 2, 0]), color=TEAL_E, t_min=-1.5, t_max=1.5)\n        self.play(Write(titulo))\n        self.wait(9)\n        self.play(FadeOut(titulo))\n        self.play(Write(text1))\n        self.wait(64)\n        self.play(FadeOut(text1))\n        self.acomodar_textos(text1_1)\n        self.wait(21)\n        self.play(FadeOut(text1_1))\n        self.acomodar_textos(text2.bg)\n        self.acomodar_textos(text2)\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES, distance=100)\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie1))\n        self.wait()\n        self.play(ShowCreation(curva1))\n        self.wait(11)\n        self.play(FadeOut(text2), FadeOut(text2.bg))\n        self.acomodar_textos(text3.bg)\n        self.acomodar_textos(text3)\n        self.wait(11)\n        self.play(FadeOut(text3), FadeOut(text3.bg))\n        self.acomodar_textos(text4.bg)\n        self.acomodar_textos(text4)\n        self.wait(11)\n        self.play(FadeOut(text4), FadeOut(text4.bg))\n        self.play(FadeOut(superficie1))\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, run_time=2)\n        self.acomodar_textos(text5.bg)\n        self.acomodar_textos(text5)\n        self.wait(13)\n        self.play(FadeOut(text5), FadeOut(curva1), FadeOut(axes), FadeOut(text5.bg))\n        self.acomodar_textos(text6)\n        self.wait(16)\n        self.play(FadeOut(text6))\n\n    def Segunda_escena(self):\n        text8_1 = TextMobject('Por ejemplo; sea ', '$D=\\\\{(x,y)\\\\in\\\\mathbb{R}^2|x> 0, \\\\ y> 0\\\\}$', ' y \\n\\n                                 $f:D \\\\to\\\\mathbb{R}$, ', '$f(x,y)=x^y+y^{xy}$ ').move_to(3 * DOWN)\n        text8_1.set_color_by_tex_to_color_map({'$f(x,y)=x^y+y^{xy}$ ': BLUE_D, '$D=\\\\{(x,y)\\\\in\\\\mathbb{R}^2|x> 0, \\\\ y> 0\\\\}$': ORANGE})\n        text8_1.bg = SurroundingRectangle(text8_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text8_2 = TextMobject('Puedes comprobar que dicha funci\u00f3n es de clase ', '$C^1_D$', '. ').move_to(3 * DOWN)\n        text8_2.set_color_by_tex_to_color_map({'$C^1_D$': YELLOW})\n        text8_2.bg = SurroundingRectangle(text8_2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text8_3 = TextMobject('As\u00ed mismo considera la ', 'curva de nivel 2', ' y el punto ', '(1,1)', ' \\n\\n                                 que pertenece a ella. ').move_to(3 * DOWN)\n        text8_3.set_color_by_tex_to_color_map({'curva de nivel 2': ORANGE, '(1,1)': PINK})\n        text8_3.bg = SurroundingRectangle(text8_3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text8_4 = TextMobject('La parcial con respecto a $y$ de dicha funci\u00f3n es\\n                                $$\\\\frac{\\\\partial (x^y+y^{xy})}{\\\\partial y}=x^ylog(x)+xy^{xy}(log(y)+1)$$ ').move_to(2 * DOWN)\n        text8_4.bg = SurroundingRectangle(text8_4, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text8_5 = TextMobject(' La cual al evaluarse en el punto ', '(1,1)', ' es diferente de 0.').move_to(3 * DOWN)\n        text8_5.set_color_by_tex_to_color_map({'(1,1)': PINK})\n        text8_5.bg = SurroundingRectangle(text8_5, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text8_6 = TextMobject('Debido a lo anterior se cumplen las condiciones del \\n\\n                                ', 'teorema de la funci\u00f3n impl\u00edcita', ' para el punto ', '(1,1)', '.').move_to(3 * DOWN)\n        text8_6.set_color_by_tex_to_color_map({'teorema de la funci\u00f3n impl\u00edcita': YELLOW, '(1,1)': PINK})\n        text8_6.bg = SurroundingRectangle(text8_6, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text8_7 = TextMobject('Entonces se puede describir la ', 'curva de nivel 2', ', \\n\\n                                    alrededor del punto ', '(1,1)', ', como una funci\u00f3n ', 'g(x)=y', '. ').move_to(3 * DOWN)\n        text8_7.set_color_by_tex_to_color_map({'curva de nivel 2': ORANGE, '(1,1)': PINK, 'g(x)=y': ORANGE})\n        text8_7.bg = SurroundingRectangle(text8_7, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text8_8 = TextMobject(' Sin embargo no es posible despejar la variable $y$ \\n\\n                                    de la ecuaci\u00f3n ', '$x^y+y^{xy}=2$').move_to(3 * DOWN)\n        text8_8.set_color_by_tex_to_color_map({'$x^y+y^{xy}=2$': ORANGE})\n        text8_8.bg = SurroundingRectangle(text8_8, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text8_9 = TextMobject('Con el ejemplo anterior apreciamos que existen funciones \\n\\n                                 en las cuales no es posible despejar la variable $y$ de \\n\\n                                 la ecuaci\u00f3n ', '$f(x,y)=k$', ', pero con el ', 'teorema de \\n\\n                                    la funci\u00f3n impl\u00edcita podemos asegurar que dicha curva \\n\\n                                  se puede describir como la gr\u00e1fica de una funci\u00f3n $g(x)=y$.')\n        text8_9.set_color_by_tex_to_color_map({'$f(x,y)=k$': BLUE_D})\n        ejes = ThreeDAxes(y_min=-2, y_max=3, x_max=3, x_min=-2, z_max=2.5)\n        eje_x = TexMobject('x').move_to(3.5 * RIGHT).scale(1.5)\n        eje_y = TexMobject('y').move_to(3.5 * UP).scale(1.5)\n        axes = VGroup(ejes, eje_x, eje_y)\n        superficie8 = ParametricSurface(lambda u, v: np.array([u, v, u ** v + v ** (u * v)]), v_min=0.08, v_max=2.15, u_min=0.08, u_max=2, fill_opacity=0.75, checkerboard_colors=[BLUE_D, BLUE_D])\n        punto_1 = Dot(radius=0.1, color=PINK).move_to([1, 1, 2])\n        punto_2 = Dot(radius=0.1, color=PINK).move_to([1, 1, 2])\n        curva_nivel_label = TexMobject('g(x)=y', color=ORANGE).move_to([2, 1.5, 0]).scale(0.8)\n        rectangulo = ParametricSurface(lambda u, v: np.array([u, v, 2]), v_min=0, v_max=3, u_min=0, u_max=2, fill_color=RED, fill_opacity=0.7, checkerboard_colors=[RED, RED])\n        VALORES_OBJ = []\n        for i in VALORES:\n            punto_i = Dot(point=i, radius=0.05, color=ORANGE)\n            VALORES_OBJ.append(punto_i)\n        grafica = VGroup(*VALORES_OBJ)\n        path = VMobject()\n        path.set_points_smoothly([*[coord(x, y) for x in xx for y in yy]])\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-80 * DEGREES, distance=4)\n        self.play(ShowCreation(axes))\n        self.acomodar_textos(text8_1.bg)\n        self.acomodar_textos(text8_1)\n        self.wait()\n        self.play(ShowCreation(superficie8))\n        self.wait(26)\n        self.play(FadeOut(text8_1), FadeOut(text8_1.bg))\n        self.acomodar_textos(text8_2.bg)\n        self.acomodar_textos(text8_2)\n        self.wait(12)\n        self.play(FadeOut(text8_2), FadeOut(text8_2.bg))\n        self.acomodar_textos(text8_3.bg)\n        self.acomodar_textos(text8_3)\n        self.play(ShowCreation(grafica))\n        self.wait()\n        self.play(ShowCreation(punto_1))\n        self.wait(8)\n        self.play(FadeOut(text8_3), FadeOut(text8_3.bg))\n        self.acomodar_textos(text8_4.bg)\n        self.acomodar_textos(text8_4)\n        self.wait(22)\n        self.play(FadeOut(text8_4), FadeOut(text8_4.bg))\n        self.acomodar_textos(text8_5.bg)\n        self.acomodar_textos(text8_5)\n        self.wait(9)\n        self.play(FadeOut(text8_5), FadeOut(text8_5.bg))\n        self.acomodar_textos(text8_6.bg)\n        self.acomodar_textos(text8_6)\n        self.wait(10)\n        self.play(FadeOut(text8_6), FadeOut(text8_6.bg))\n        self.acomodar_textos(text8_7.bg)\n        self.acomodar_textos(text8_7)\n        self.play(FadeOut(superficie8), FadeOut(rectangulo), FadeOut(punto_1), ShowCreation(punto_2))\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, distance=100, run_time=2)\n        self.play(FadeOut(punto_2))\n        self.play(ShowCreation(punto_2))\n        self.acomodar_textos(curva_nivel_label)\n        self.wait(13)\n        self.play(FadeOut(text8_7), FadeOut(text8_7.bg))\n        self.acomodar_textos(text8_8.bg)\n        self.acomodar_textos(text8_8)\n        self.wait(15)\n        self.play(FadeOut(axes), FadeOut(text8_8), FadeOut(text8_8.bg), FadeOut(grafica), FadeOut(punto_2), FadeOut(curva_nivel_label))\n        self.acomodar_textos(text8_9)\n        self.wait(28)\n        self.play(FadeOut(text8_9))\n\n    def Tercera_escena(self):\n        text9 = TextMobject('Veamos otro ejemplo.')\n        text10 = TextMobject(' Considera ', '$f(x,y)=y^3-x^9$', ' y su ', 'curva de nivel 0', '.').move_to(3 * UP)\n        text10.set_color_by_tex_to_color_map({'$f(x,y)=y^3-x^9$': BLUE_D, 'curva de nivel 0': ORANGE})\n        text10.bg = SurroundingRectangle(text10, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text11 = TextMobject(' Si bien $\\\\frac{\\\\partial f}{\\\\partial y}(x,y)=3y^2$ y \\n\\n                                 $\\\\frac{\\\\partial f}{\\\\partial y}(0,0)=0$, puedes observar \\n \\n                                 que la expresi\u00f3n ', '$g(x)=y(x)=x^3$', ' describe a la ', 'curva de nivel', '.').move_to(-2.7 * UP)\n        text11.set_color_by_tex_to_color_map({'$g(x)=y(x)=x^3$': ORANGE, 'curva de nivel': ORANGE})\n        text11.bg = SurroundingRectangle(text11, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text12 = TextMobject('Lo que nos dice que no se vale el regreso del ', 'Teorema', '.')\n        text12.set_color_by_tex_to_color_map({'Teorema': YELLOW})\n        ejes = ThreeDAxes(y_max=3, y_min=-3)\n        eje_x = TexMobject('x').move_to(6 * RIGHT).scale(1.5)\n        eje_y = TexMobject('y').move_to(3.5 * UP).scale(1.5)\n        axes = VGroup(ejes, eje_x, eje_y)\n        superficie3 = ParametricSurface(lambda u, v: np.array([u, v, v ** 3 - u ** 9]), v_min=-2, v_max=2, u_min=-1.6, u_max=1.6, fill_opacity=0.75, checkerboard_colors=[BLUE_D, BLUE_D])\n        curva3 = ParametricFunction(lambda u: np.array([u, u ** 3, 0]), color=ORANGE, t_min=-1.26, t_max=1.26)\n        self.play(Write(text9))\n        self.wait(5)\n        self.play(FadeOut(text9))\n        self.set_camera_orientation(phi=75 * DEGREES, theta=15 * DEGREES, distance=100)\n        self.play(ShowCreation(axes))\n        self.acomodar_textos(text10.bg)\n        self.acomodar_textos(text10)\n        self.wait()\n        self.play(ShowCreation(superficie3))\n        self.wait()\n        self.play(ShowCreation(curva3))\n        self.wait(10)\n        self.play(FadeOut(text10), FadeOut(text10.bg))\n        self.acomodar_textos(text11.bg)\n        self.acomodar_textos(text11)\n        self.play(FadeOut(superficie3))\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, run_time=2)\n        self.wait(24)\n        self.play(FadeOut(text11), FadeOut(text11.bg), FadeOut(curva3), FadeOut(axes))\n        self.acomodar_textos(text12)\n        self.wait(6)\n        self.play(FadeOut(text12))\n\n    def Cuarta_escena(self):\n        text13 = TextMobject('Ahora considera la funci\u00f3n ', '$\\\\gamma(x,y)=xy$', '. ').move_to(3 * UP)\n        text13.set_color_by_tex_to_color_map({'$\\\\gamma(x,y)=xy$': MAROON_B})\n        text13.bg = SurroundingRectangle(text13, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text14 = TextMobject('Notar\u00e1s que la ', 'curva de nivel 0', ' de la funci\u00f3n corresponde \\n\\n                                        a los ejes $x$ y $y$.').move_to(3 * DOWN)\n        text14.set_color_by_tex_to_color_map({'curva de nivel 0': BLUE_D})\n        text14.bg = SurroundingRectangle(text14, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text15 = TextMobject('Adem\u00e1s debido a que \\n\\n                                $\\\\frac{\\\\partial \\\\gamma}{\\\\partial y}=x. $').move_to(3 * UP)\n        text15.bg = SurroundingRectangle(text15, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text16 = TextMobject('En los puntos de la ', 'curva de nivel', ' en el eje $y$ la parcial \\n\\n                                se anula y no es posible aplicar el', ' teorema de \\n\\n                                la funci\u00f3n impl\u00edcita', '.').move_to(2.5 * UP)\n        text16.set_color_by_tex_to_color_map({'curva de nivel': BLUE_D, 'teorema de la funci\u00f3n impl\u00edcita': YELLOW})\n        text16.bg = SurroundingRectangle(text16, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text17 = TextMobject('\u00bfQu\u00e9 ocurre si $\\\\frac{\\\\partial f}{\\\\partial x}(x,y)\\\\neq 0$?', ' \\n\\n                                Enuncia el Teorema de la funci\u00f3n impl\u00edcita correspondiente.')\n        text18 = TextMobject('Observa que en el caso del ejemplo ', '$\\\\gamma(x,y)=xy$', ', \\n\\n                                en el origen tenemos un ', 'punto cr\u00edtico,', ' por el cual  \\n\\n                                pasa ', 'la curva de nivel $0$', ' de ', '$\\\\gamma$.').move_to(-2.7 * DOWN)\n        text18_2 = TextMobject(' Dicha ', 'curva de nivel 0', ' es la intersecci\u00f3n de dos \\n\\n                                  rectas: una vertical y una horizontal.').move_to(3 * DOWN)\n        text18_2.set_color_by_tex_to_color_map({'curva de nivel': BLUE_D})\n        text18_2.bg = SurroundingRectangle(text18_2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text18.set_color_by_tex_to_color_map({'$\\\\gamma(x,y)=xy$': MAROON_B, 'punto cr\u00edtico': RED, 'curva de nivel': BLUE_D, '$\\\\gamma$.': MAROON_B})\n        text18.bg = SurroundingRectangle(text18, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text18_1 = TextMobject('Y no se puede describir la ', 'curva de nivel', ' \\n\\n                                como la gr\u00e1fica de una funci\u00f3n de ninguna de las variables \\n\\n                                en t\u00e9rminos de la otra.').move_to(3 * DOWN)\n        text18_1.set_color_by_tex_to_color_map({'curva de nivel': BLUE_D})\n        text18_1.bg = SurroundingRectangle(text18_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        ejes = ThreeDAxes()\n        eje_x = TexMobject('x').move_to(6 * RIGHT).scale(1.5)\n        eje_y = TexMobject('y').move_to(6 * UP).scale(1.5)\n        axes = VGroup(ejes, eje_x, eje_y)\n        superficie4 = ParametricSurface(lambda u, v: np.array([u, v, u * v]), v_min=-3, v_max=3, u_min=-3, u_max=3, fill_opacity=0.75, checkerboard_colors=[MAROON_B, MAROON_B])\n        curva4_1 = ParametricFunction(lambda u: np.array([u, 0, 0]), color=BLUE_D, t_min=-3, t_max=3)\n        curva4_2 = ParametricFunction(lambda u: np.array([0, u, 0]), color=BLUE_D, t_min=-3, t_max=3)\n        curva4 = VGroup(curva4_1, curva4_2)\n        punto_critico = Dot(radius=0.2, color=RED).move_to([0, 0, 0])\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES, distance=100)\n        self.play(ShowCreation(axes))\n        self.acomodar_textos(text13.bg)\n        self.acomodar_textos(text13)\n        self.play(ShowCreation(superficie4))\n        self.wait(10)\n        self.begin_ambient_camera_rotation(rate=0.02)\n        self.play(FadeOut(text13), FadeOut(text13.bg))\n        self.acomodar_textos(text14.bg)\n        self.acomodar_textos(text14)\n        self.wait(3)\n        self.play(ShowCreation(curva4))\n        self.wait(4)\n        self.play(FadeOut(text14), FadeOut(text14.bg))\n        self.acomodar_textos(text15.bg)\n        self.acomodar_textos(text15)\n        self.wait(8)\n        self.play(FadeOut(text15), FadeOut(text15.bg))\n        self.acomodar_textos(text16.bg)\n        self.acomodar_textos(text16)\n        self.wait(12)\n        self.play(FadeOut(text16), FadeOut(text16.bg), FadeOut(axes), FadeOut(curva4), FadeOut(superficie4))\n        self.stop_ambient_camera_rotation()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES, distance=100)\n        self.acomodar_textos(text17[0])\n        self.wait()\n        self.acomodar_textos(text17[1])\n        self.wait(15)\n        self.play(FadeOut(text17))\n        self.play(ShowCreation(axes), ShowCreation(superficie4))\n        self.acomodar_textos(text18.bg)\n        self.acomodar_textos(text18)\n        self.play(ShowCreation(curva4))\n        self.play(ShowCreation(punto_critico))\n        self.wait(10)\n        self.acomodar_textos(text18_2.bg)\n        self.acomodar_textos(text18_2)\n        self.wait(12)\n        self.play(FadeOut(text18_2), FadeOut(text18_2.bg), FadeOut(text18), FadeOut(text18.bg))\n        self.acomodar_textos(text18_1.bg)\n        self.acomodar_textos(text18_1)\n        self.wait(15)\n        self.play(FadeOut(axes), FadeOut(superficie4), FadeOut(punto_critico), FadeOut(curva4), FadeOut(text18_1), FadeOut(text18_1.bg))\n\n    def Quinta_escena(self):\n        text18_0 = TextMobject('Geom\u00e9tricamente el teorema de la funci\u00f3n impl\u00edcita \\n\\n                             dice que si ', '$\\\\nabla f(x_0,y_0)$', ' no es horizontal, \\n\\n                             $\\\\frac{\\\\partial f}{\\\\partial y}(x_0,y_0)\\\\neq 0$', ',')\n        text18_0.set_color_by_tex_to_color_map({'$\\\\nabla f(x_0,y_0)$': ORANGE})\n        text18_0.move_to(3 * UP).scale(0.8)\n        text18_0.bg = SurroundingRectangle(text18_0, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text18_1 = TextMobject('es decir no es paralelo al eje $x$ entonces podemos \\n\\n                             describir un sector de la ', 'curva de nivel $k$', ',\\n\\n                              alrededor de ', '$(x_0,y_0)$', '  como la gr\u00e1fica de una \\n\\n                              funci\u00f3n de la forma ', '$y=g(x)$.')\n        text18_1.set_color_by_tex_to_color_map({'curva de nivel $k$': TEAL_C, '$y=g(x)$.': PINK, '$(x_0,y_0)$': YELLOW})\n        text18_1.move_to(2.5 * DOWN).scale(0.8)\n        text18_1.bg = SurroundingRectangle(text18_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text18 = VGroup(text18_0, text18_1)\n        text18.bg = VGroup(text18_0.bg, text18_1.bg)\n        text19 = TextMobject('Y si el vector ', \"$\\\\nabla f(x_0',y_0')$\", \" no es vertical, entonces\\n                                $\\\\frac{\\\\partial f}{\\\\partial x}(x_0',y_0')\\\\neq 0$, \\n\\n                                es decir no es paralelo al eje $y$, entonces un sector de la\\n\\n                                \", 'curva de nivel $k$', ' de $f$ alrededor del punto ', \"$(x_0',y_0')$\", ' se\\n\\n                                puede ver como la gr\u00e1fica de una funci\u00f3n de la forma ', '$x=h(y).$').move_to(-2.8 * DOWN).scale(0.8)\n        text19.set_color_by_tex_to_color_map({\"$\\\\nabla f(x_0',y_0')$\": ORANGE, 'curva de nivel $k$': TEAL_C, \"$(x_0',y_0')$\": YELLOW, '$x=h(y).$': PURPLE_C})\n        text19.bg = SurroundingRectangle(text19, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text20 = TextMobject('Un corolario del ', 'Teorema de la funci\u00f3n impl\u00edcita', ' es \\n\\n                                que el gradiente es ortogonal a la ', 'curva de nivel', '.').move_to(3 * DOWN)\n        text20.set_color_by_tex_to_color_map({'Teorema de la funci\u00f3n impl\u00edcita': TEAL_B})\n        text20.set_color_by_tex_to_color_map({'Teorema de la funci\u00f3n impl\u00edcita': YELLOW})\n        text20.bg = SurroundingRectangle(text20, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text21 = TextMobject('Con los ejemplos anteriores s\u00f3lo se consider\u00f3 el Teorema de \\n\\n                                 la funci\u00f3n impl\u00edcita en funciones de $\\\\mathbb{R}^2\\\\to\\\\mathbb{R}$, \\n\\n                                 sin embargo el teorema es generalizable a \\n\\n                                 funciones de $\\\\mathbb{R}^n\\\\to\\\\mathbb{R}$.')\n        ejes = ThreeDAxes(x_max=4.8, y_max=3, x_min=-4.8, y_min=-4.8)\n        eje_x = TexMobject('x').move_to(5 * RIGHT).scale(1)\n        eje_y = TexMobject('y').move_to(3.5 * UP).scale(1.5)\n        axes = VGroup(ejes, eje_x, eje_y)\n        curva = ParametricFunction(lambda u: np.array([u, 1.5 * np.cos(u / 2) ** (1 / 3), 0]), color=TEAL_C, t_min=-4.5, t_max=4.5)\n        curva_ejem1 = DashedVMobject(curva, y_tick_frequency=0.02, x_tick_frequency=0.02)\n        curva_ejem1_label = TexMobject('f(x,y)=k').move_to(1 * UP + 4 * LEFT).scale(0.7).set_color(TEAL_C)\n        a = 1\n        b = 1.5 * np.cos(a / 2) ** (1 / 3)\n        x0 = np.array([a, b, 0])\n        x0_dot = Dot(color=YELLOW).move_to(x0)\n        x0_dot_label = TexMobject('(x_0,y_0)').set_color(YELLOW).scale(0.5).next_to(x0_dot, 0.9 * RIGHT + DOWN, buff=0.1)\n        x0_group = VGroup(x0_dot, x0_dot_label)\n        grad1_vec = Arrow([a, b, 0], [-0.25 * np.sin(a / 2) / np.cos(a / 2) ** (2 / 3), -1, 0], buff=0, color=ORANGE)\n        grad1_label = TexMobject('\\\\nabla f(x_0,y_0)').next_to(grad1_vec, 0.7 * DOWN + 0.1 * LEFT, buff=-0.3).set_color(ORANGE).scale(0.7)\n        grad1 = VGroup(grad1_vec, grad1_label)\n        v = 1.5\n        curva_1 = ParametricFunction(lambda u: np.array([u, 1.5 * np.cos(u / 2) ** (1 / 3), 0]), color=PURPLE_C, t_min=a - v, t_max=a + v)\n        curva1_label = TexMobject('g(x)').next_to(curva_1, UP, buff=0.1).set_color(PINK).scale(0.8)\n        curva1 = VGroup(curva_1, curva1_label)\n        a2 = 2.5\n        b2 = 1.5 * np.cos(a2 / 2) ** (1 / 3)\n        x02 = np.array([a2, b2, 0])\n        x02_dot = Dot(color=YELLOW).move_to(x02)\n        x02_dot_label = TexMobject(\"(x_0',y_0')\").scale(0.5).next_to(x02_dot, RIGHT + UP, buff=0.1).set_color(YELLOW)\n        x02_group = VGroup(x02_dot, x02_dot_label)\n        grad2_vec = Arrow([a2, b2, 0], [-0.25 * np.sin(a2 / 2) / np.cos(a2 / 2) ** (2 / 3), -1, 0], buff=0, color=ORANGE)\n        grad2_label = TexMobject(\"\\\\nabla f(x_0',y_0')\").next_to(grad2_vec, DOWN + LEFT, buff=-0.3).set_color(ORANGE).scale(0.7)\n        grad2 = VGroup(grad2_vec, grad2_label)\n        v2 = 1.3\n        curva_2 = ParametricFunction(lambda u: np.array([u, 1.5 * np.cos(u / 2) ** (1 / 3), 0]), color=PURPLE_E, t_min=a2 - v2, t_max=a2 + v2)\n        curva2_label = TexMobject('h(y)').next_to(curva_2, RIGHT, buff=0.3).set_color(PURPLE_E).scale(0.8)\n        curva2 = VGroup(curva_2, curva2_label)\n        curva_3 = ParametricFunction(lambda u: np.array([u, np.cos(u ** 2), 0]), color=TEAL_B, t_min=-4, t_max=4)\n        curva_3_nombre = TexMobject('f(x,y)=\\\\cos(x^2)-y=0').set_color(TEAL_B).move_to(3.5 * UP + 4 * LEFT).scale(0.8)\n        x1 = ValueTracker(-1.5)\n        x2 = -1.5\n        y1 = np.cos(x2 ** 2)\n        punto = Dot(color=RED).move_to([x2, y1, 0])\n        gradiente1 = Arrow([x2, y1, 0], [2 * x2 * np.sin(x2 ** 2) + x2, 1 + y1, 0], buff=0, color=RED)\n        gradiente1_label = TexMobject('\\\\nabla(f(x,y)=0)').set_color(RED).next_to(gradiente1, LEFT + UP, buff=-0.3).scale(0.7)\n\n        def GRADIENTE(obj):\n            x = x1.get_value()\n            y = np.cos(x ** 2)\n            punto.become(Dot(color=RED).move_to([x, y, 0]))\n            gradiente1.become(Arrow([x, y, 0], [2 * x * np.sin(x ** 2) + x, 1 + y, 0], buff=0, color=RED))\n            gradiente1_label.become(TexMobject('\\\\nabla(f(x,y)=0)').set_color(RED).next_to(gradiente1, UP + RIGHT * (x / (x ** 2) ** (1 / 2)), buff=-0.3).scale(0.7))\n        punto.add_updater(GRADIENTE)\n        gradiente1.add_updater(GRADIENTE)\n        gradiente1_label.add_updater(GRADIENTE)\n        self.set_camera_orientation(phi=0 * DEGREES, theta=-90 * DEGREES, distance=200)\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(curva_ejem1), ShowCreation(curva_ejem1_label))\n        self.acomodar_textos(text18.bg)\n        self.acomodar_textos(text18)\n        self.wait()\n        self.play(ShowCreation(x0_group))\n        self.play(ShowCreation(grad1))\n        self.wait()\n        self.play(ShowCreation(curva1))\n        self.wait(28)\n        self.play(FadeOut(curva1), FadeOut(grad1), FadeOut(x0_group), FadeOut(text18), FadeOut(text18.bg))\n        self.acomodar_textos(text19.bg)\n        self.acomodar_textos(text19)\n        self.wait()\n        self.play(ShowCreation(x02_group))\n        self.play(ShowCreation(grad2))\n        self.wait()\n        self.play(ShowCreation(curva2))\n        self.wait(25)\n        self.play(FadeOut(curva2), FadeOut(grad2), FadeOut(x02_group), FadeOut(text19), FadeOut(text19.bg), FadeOut(curva_ejem1), FadeOut(curva_ejem1_label))\n        self.acomodar_textos(text20.bg)\n        self.acomodar_textos(text20)\n        self.wait(11)\n        self.play(ShowCreation(curva_3))\n        self.acomodar_textos(curva_3_nombre)\n        self.play(ShowCreation(punto), ShowCreation(gradiente1))\n        self.add_fixed_in_frame_mobjects(gradiente1_label)\n        self.wait()\n        self.play(x1.set_value, 1.5, run_time=15)\n        self.play(FadeOut(text20), FadeOut(text20.bg), FadeOut(curva_3), FadeOut(punto), FadeOut(gradiente1), FadeOut(axes), FadeOut(punto), FadeOut(curva_3_nombre), FadeOut(gradiente1_label))\n        self.acomodar_textos(text21)\n        self.wait(18)\n        self.play(FadeOut(text21))\n\n    def Sexta_escena(self):\n        text22 = TextMobject('Veamos un ejemplo de ello.')\n        text23 = TextMobject('Considera la funci\u00f3n ', '$\\\\beta(x,y,z)=x^2+y+z$', '.').move_to(-1 * DOWN)\n        text23.set_color_by_tex_to_color_map({'$\\\\beta(x,y,z)=x^2+y+z$': BLUE_D})\n        text24 = TextMobject('Como seguramente sabr\u00e1s, es complicado graficar \\n\\n                                en 4 dimensiones, as\u00ed que limit\u00e9monos a graficar \\n\\n                                    ', 'la superficie de nivel 0', '.').next_to(text23, DOWN, buff=0.1)\n        text24.set_color_by_tex_to_color_map({'la superficie de nivel 0': GOLD_E})\n        text24_1 = TexMobject('\\\\beta(x,y,z)=x^2+y+z=0').move_to(3 * UP).set_color(GOLD_E)\n        text24_1.bg = SurroundingRectangle(text24_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text25 = TextMobject('Podemos describir la superficie de nivel con \\n\\n                                la funci\u00f3n $z=-x^2-y$.').move_to(3 * DOWN)\n        text25.bg = SurroundingRectangle(text25, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text26 = TextMobject('Incluso podemos dejar la superficie de \\n\\n                                    nivel en t\u00e9rminos de $y$.').move_to(-3.3 * DOWN)\n        text26.bg = SurroundingRectangle(text26, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text27 = TextMobject('Con esto, notamos que el teorema de la funci\u00f3n \\n\\n                                    impl\u00edcita nos permite afirmar cu\u00e1ndo podemos describir el \\n\\n                                conjunto de nivel $k$ de una funci\u00f3n en t\u00e9rminos de algunas \\n\\n                                variables de la funci\u00f3n en puntos no cr\u00edticos.')\n        axes = ThreeDAxes()\n        superficie1 = ParametricSurface(lambda u, v: np.array([u, v, -u ** 2 - v]), v_min=-3, v_max=3, u_min=-3, u_max=3, fill_opacity=0.75, checkerboard_colors=[GOLD_E, GOLD_E])\n        self.acomodar_textos(text22)\n        self.wait(6)\n        self.play(FadeOut(text22))\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES, distance=100)\n        self.acomodar_textos(text23)\n        self.acomodar_textos(text24)\n        self.wait(20)\n        self.play(FadeOut(text24), FadeOut(text23))\n        self.acomodar_textos(text24_1.bg)\n        self.acomodar_textos(text24_1)\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie1))\n        self.begin_ambient_camera_rotation(rate=0.03)\n        self.acomodar_textos(text25.bg)\n        self.acomodar_textos(text25)\n        self.wait(13)\n        self.play(FadeOut(text25), FadeOut(text25.bg), FadeOut(text24_1), FadeOut(text24_1.bg))\n        self.acomodar_textos(text26.bg)\n        self.acomodar_textos(text26)\n        self.wait(9)\n        self.play(FadeOut(axes), FadeOut(superficie1), FadeOut(text26), FadeOut(text26.bg))\n        self.acomodar_textos(text27)\n        self.wait(16)\n        self.play(FadeOut(text27))\n\n    def construct(self):\n        self.Primera_escena()\n        self.Segunda_escena()\n        self.Tercera_escena()\n        self.Cuarta_escena()\n        self.Quinta_escena()\n        self.Sexta_escena()"}]}
{"messages": [{"role": "user", "content": "Illustrate theorems about differentiability in calculus, showing a function with existing directional derivatives but no continuity, and then a cone function with continuity but no differentiability."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Teoremas_diferenciabilidad(ThreeDScene):\n\n    def superficie(self, x, y):\n        if x == 0 and y == 0:\n            return 0\n        return x ** 2 * y / (x ** 4 + y ** 2)\n\n    def trayectoria(self, t):\n        return (t, t ** 2, self.superficie(t, t ** 2))\n\n    def eje_x(self, t):\n        return (t, 0, 0)\n\n    def eje_y(self, t):\n        return (0, t, 0)\n\n    def construct(self):\n        title = TextMobject('Teoremas de diferenciabilidad').scale(1.5)\n        text1 = TextMobject('Veamos algunos teoremas importantes sobre diferenciabilidad.').move_to(2 * UP)\n        text2 = TextMobject('Teorema 1. ', 'Si $f$ es diferenciable en $\\\\vec{x}_{0}$, \\n\\n                            entonces $f$ es continua en $\\\\vec{x}_{0}$.').next_to(text1, 2 * DOWN)\n        text2.set_color_by_tex('Teorema 1. ', color=BLUE)\n        text3 = TextMobject('Teorema 2. ', 'Si $f$ es diferenciable en un punto $\\\\vec{x}_{0}$ en el interior\\n\\n                            del dominio, entonces existen todas las derivadas direccionales\\n\\n                            de $f$ en $\\\\vec{x}_{0}$. Particularmente existen todas las parciales.').next_to(text2, 2 * DOWN)\n        text3.set_color_by_tex('Teorema 2. ', color=BLUE)\n        text4 = TextMobject('Para mostrar que el rec\u00edproco del ', 'Teorema 2', ' no es cierto,\\n\\n                            tomemos la siguiente funci\u00f3n.').move_to(3 * UP)\n        text4.set_color_by_tex('Teorema 2', color=BLUE)\n        func1 = TextMobject('$f(x,y)=\\\\frac{x^{2}y}{x^{4}+y^{2}}$ si $(x, y)\\\\neq(0,0)$ y').move_to(2.8 * DOWN)\n        func1.scale(0.8)\n        func2 = TextMobject('$f(x,y)=0$ si $(x, y)=(0,0)$.').next_to(func1, 0.8 * DOWN)\n        func2.scale(0.8)\n        text5_1 = TextMobject('Aplicando la definici\u00f3n de derivada direccional, para cualquier $\\\\vec{u} = (u_{1}, u_{2})$').move_to(2.7 * DOWN)\n        text5_1.scale(0.7)\n        text5_2 = TextMobject('$$\\\\text{tal que }||\\\\vec{u}|| = 1,\\\\text{ } D_{\\\\vec{u}}f(0, 0) = \\\\lim_{h\\\\to 0} \\\\frac{f(\\\\vec{x}_{0}+h\\\\vec{u})-f(\\\\vec{x}_{0})}{h} = \\\\lim_{h\\\\to 0} \\\\frac{u_{1}^{2}u_{2}}{h^{2}u_{1}^{4}+u_{2}^{2}}.$$').next_to(text5_1, 0.2 * DOWN)\n        text5_2.scale(0.7)\n        text6 = TextMobject('Si $u_{2}\\\\neq 0$, entonces $D_{\\\\vec{u}}f(0,0)=\\\\frac{u_{1}^{2}}{u_{2}}$.').move_to(3 * DOWN)\n        text6.scale(0.8)\n        text7 = TextMobject('Por otro lado, si $u_{2} = 0$, entonces $\\\\vec{u} = (1,0)$ y $D_{\\\\vec{u}}f(0,0) = 0$.').move_to(3 * DOWN)\n        text7.scale(0.8)\n        text8 = TextMobject('Es decir, existen todas las derivadas direccionales de $f$ en $(0,0)$.').move_to(3 * DOWN)\n        text8.scale(0.8)\n        text9_1 = TextMobject('Sin embargo, si nos acercamos a $(0,0)$ por los puntos de la forma $(t,t^{2})$ con').move_to(2.8 * DOWN)\n        text9_1.scale(0.6)\n        text9_2 = TextMobject('$$t\\\\in\\\\mathbb{R}\\\\backslash{}\\\\{(0, 0)\\\\},\\\\text{ encontraremos que}\\\\lim_{(t, t^{2})\\\\to (0,0)}f(t,t^{2})=\\\\frac{1}{2},\\\\text{ por lo que }f\\\\text{ no es continua en }(0, 0).$$').next_to(text9_1, 0.2 * DOWN)\n        text9_2.scale(0.6)\n        text10 = TextMobject('Como $f$ no es continua en $(0,0)$, por el ', 'Teorema 1', ',\\n\\n                              $f$ no es diferenciable en $(0, 0)$.').move_to(3 * DOWN)\n        text10.scale(0.8)\n        text10.set_color_by_tex('Teorema 1', color=BLUE)\n        text11 = TextMobject('Ahora consideremos un cono,\\n\\n                              cuya regla de correspondencia es $f(x,y)=||(x,y)||$.').move_to(3 * UP)\n        text12 = TextMobject('Recordemos que $f$ es continua para todo $(x,y)\\\\in\\\\mathbb{R}^{2}$,\\n\\n                              en particular para $(0,0)$.').move_to(3 * DOWN)\n        text12.scale(0.8)\n        text13 = TextMobject('Sin embargo, para cualquier $\\\\vec{u}=(u_{1},u_{2})$ tal que $||\\\\vec{u}||=1$, \\n                              $$\\\\lim_{h\\\\to 0}\\\\frac{f(\\\\vec{x}_{0}+h\\\\vec{u})-f(\\\\vec{x}_{0})}{h}=\\\\lim_{h\\\\to 0}\\\\frac{|h|}{h},\\\\text{ de forma que } D_{\\\\vec{u}}f(0,0)\\\\text{ no existe.}$$').move_to(3 * DOWN)\n        text13.scale(0.8)\n        text14 = TextMobject('Por el ', 'Teorema 2', ', tenemos que $f$ no es diferenciable en $(0,0)$.').move_to(3 * DOWN)\n        text14.scale(0.8)\n        text14.set_color_by_tex('Teorema 2', color=BLUE)\n        text15 = TextMobject('Por lo tanto, el rec\u00edproco del ', 'Teorema 1', ' no es v\u00e1lido.').move_to(3 * DOWN)\n        text15.scale(0.8)\n        text15.set_color_by_tex('Teorema 1', color=BLUE)\n        text16 = TextMobject('Por \u00faltimo, enunciemos el siguiente teorema.').move_to(2 * UP)\n        text17 = TextMobject('Teorema 3. ', 'Sean $f:U\\\\subset\\\\mathbb{R}^2\\\\to\\\\mathbb{R}$ y $(x_{0},y_{0})\\\\in U$, con $U$ un\\n\\n                             conjunto abierto. Si $\\\\frac{\\\\partial f}{\\\\partial x}$ y $\\\\frac{\\\\partial f}{\\\\partial y}$ existen en $U$ y son continuas\\n\\n                             en $U$, entonces $f$ es diferenciable en $U$. Cuando las parciales\\n\\n                             son continuas en $U$, decimos que $f$ o la superficie\\n\\n                             dada por $f$ es suave o de clase $C^1$.').next_to(text16, 2 * DOWN)\n        text17.set_color_by_tex('Teorema 3. ', color=BLUE)\n        text4.bg = SurroundingRectangle(text4, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo_4 = VGroup(text4.bg, text4)\n        text11.bg = SurroundingRectangle(text11, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo_11 = VGroup(text11.bg, text11)\n        axis_config = {'dimension': 3, 'x_min': -3, 'x_max': 3, 'y_min': -3, 'y_max': 3, 'z_min': -1, 'z_max': 2, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT}\n        axes = ThreeDAxes(**axis_config)\n        superficie = Superficie().set_shade_in_3d(True)\n        cono = Cono().set_shade_in_3d(True)\n        Dir1 = Arrow((0, 0, 0), (1 / np.sqrt(2), 1 / np.sqrt(2), 0), buff=0.075)\n        Dir2 = Arrow((0, 0, 0), (1 / np.sqrt(2), -1 / np.sqrt(2), 0), buff=0.075)\n        Dir3 = Arrow((0, 0, 0), (-1 / np.sqrt(2), 1 / np.sqrt(2), 0), buff=0.075)\n        Dir4 = Arrow((0, 0, 0), (-1 / np.sqrt(2), -1 / np.sqrt(2), 0), buff=0.075)\n        Dir5 = Arrow((0, 0, 0), (1, 0, 0), buff=0.075)\n        Dir6 = Arrow((0, 0, 0), (-1, 0, 0), buff=0.075)\n        Dir7 = Arrow((0, 0, 0), (0, 1, 0), buff=0.075)\n        Dir8 = Arrow((0, 0, 0), (0, -1, 0), buff=0.075)\n        Dirs = VGroup(Dir1, Dir2, Dir3, Dir4, Dir5, Dir6, Dir7, Dir8)\n        Dirs.set_color(RED)\n        curva = ParametricFunction(self.trayectoria, t_min=-np.sqrt(2), t_max=np.sqrt(2), color=RED)\n        dashed_curva = DashedVMobject(curva)\n        self.play(Write(title), run_time=3)\n        self.wait(3)\n        self.play(FadeOut(title))\n        self.play(Write(text1), run_time=3)\n        self.wait(3)\n        self.play(Write(text2), run_time=3)\n        self.wait(3)\n        self.play(Write(text3), run_time=6)\n        self.wait(5)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(np.pi / 4, 0 * np.pi)\n        self.add_fixed_in_frame_mobjects(gpo_4)\n        self.play(Write(gpo_4), run_time=3)\n        self.wait(3)\n        self.play(ShowCreation(axes), ShowCreation(superficie), run_time=2)\n        self.wait()\n        self.add_fixed_in_frame_mobjects(func1)\n        self.play(Write(func1))\n        self.add_fixed_in_frame_mobjects(func2)\n        self.play(Write(func2))\n        self.wait(3)\n        self.play(FadeOut(func1), FadeOut(func2))\n        self.play(ShowCreation(Dirs))\n        self.add_fixed_in_frame_mobjects(text5_1)\n        self.play(Write(text5_1), run_time=3)\n        self.add_fixed_in_frame_mobjects(text5_2)\n        self.play(Write(text5_2), run_time=3)\n        self.wait(5)\n        self.play(FadeOut(text5_1), FadeOut(text5_2))\n        self.play(FadeOut(Dir2), FadeOut(Dir4), FadeOut(Dir5), FadeOut(Dir6), FadeOut(Dir8))\n        self.add_fixed_in_frame_mobjects(text6)\n        self.play(Write(text6))\n        self.wait(3)\n        self.play(FadeOut(text6))\n        self.play(FadeOut(Dir1), FadeOut(Dir3), FadeOut(Dir7))\n        self.play(ShowCreation(Dir5))\n        self.add_fixed_in_frame_mobjects(text7)\n        self.play(Write(text7), run_time=3)\n        self.wait(3)\n        self.play(FadeOut(text7), FadeOut(Dir5))\n        self.add_fixed_in_frame_mobjects(text8)\n        self.play(Write(text8))\n        self.wait(3)\n        self.play(FadeOut(text8))\n        self.play(ShowCreation(dashed_curva))\n        self.add_fixed_in_frame_mobjects(text9_1)\n        self.play(Write(text9_1), run_time=3)\n        self.add_fixed_in_frame_mobjects(text9_2)\n        self.play(Write(text9_2), run_time=4)\n        self.wait(5)\n        self.play(FadeOut(text9_1), FadeOut(text9_2), FadeOut(dashed_curva))\n        self.add_fixed_in_frame_mobjects(text10)\n        self.play(Write(text10), run_time=3)\n        self.wait(5)\n        self.play(FadeOut(text10))\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(0.7 * np.pi / 2, 0.25 * np.pi)\n        self.add_fixed_in_frame_mobjects(gpo_11)\n        self.play(Write(gpo_11), run_time=3)\n        self.wait(3)\n        graf_cono = VGroup(axes, cono, Dirs)\n        graf_cono.move_to(ORIGIN)\n        self.play(ShowCreation(axes), ShowCreation(cono))\n        self.wait(3)\n        self.add_fixed_in_frame_mobjects(text12)\n        self.play(Write(text12))\n        self.wait(3)\n        self.play(FadeOut(text12))\n        self.play(ShowCreation(Dirs), FadeOut(Dir4))\n        self.add_fixed_in_frame_mobjects(text13)\n        self.play(Write(text13), run_time=4)\n        self.wait(5)\n        self.play(FadeOut(text13))\n        self.play(FadeOut(Dir1), FadeOut(Dir2), FadeOut(Dir3), FadeOut(Dir5), FadeOut(Dir6), FadeOut(Dir7), FadeOut(Dir8))\n        self.add_fixed_in_frame_mobjects(text14)\n        self.play(Write(text14))\n        self.wait(3)\n        self.play(FadeOut(text14))\n        self.add_fixed_in_frame_mobjects(text15)\n        self.play(Write(text15))\n        self.wait(3)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(phi=0, theta=-90 * DEGREES)\n        self.play(Write(text16))\n        self.wait(3)\n        self.play(Write(text17), run_time=8)\n        self.wait(8)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])"}]}
{"messages": [{"role": "user", "content": "Present a comprehensive explanation of tangent planes and directional derivatives in 3D space, illustrating concepts with animated 3D surfaces and mathematical formulas."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Plano_tangente(ThreeDScene):\n\n    def paraboloide2(self, x, y):\n        return -(x ** 2 + y ** 2) / 3 + 2\n\n    def superficie2(self, x, y):\n        return (-(x ** 2 + y ** 2) / 3 + 2) * (x ** 2 - y ** 2) / 4\n\n    def superficie3(self, x, y):\n        return (x ** 2 - y ** 2) / 4\n\n    def curva1(self, t):\n        return (t, 2 - t, self.paraboloide2(t, 2 - t))\n\n    def curva2(self, t):\n        return (t, 2 - t, self.superficie2(t, 2 - t))\n\n    def curva3(self, t):\n        return (t, 0, self.superficie3(t, 0))\n\n    def tangente1(self, t):\n        return (t / np.sqrt(2), 2 - t / np.sqrt(2), 2 / 3 + 2 * t * np.sqrt(2) / 3)\n\n    def tangente2(self, t):\n        return (t / np.sqrt(2), 2 - t / np.sqrt(2), -2 / 3 - t * np.sqrt(2) / 3)\n\n    def tangente3(self, t):\n        return (t, 0, 0)\n\n    def recorrido(self, t):\n        return (0, t, self.paraboloide2(0, t))\n\n    def parte1(self):\n        text1 = TextMobject('Consideremos estas dos superficies.').move_to(3 * UP)\n        text2 = TextMobject(\"Notemos que una es ``suave'' en el origen, \\n\\n                            mientras que la otra tiene un ``pico''.\").move_to(3 * UP)\n        text3 = TextMobject('\u00bfQu\u00e9 significa esto matem\u00e1ticamente hablando?').move_to(3 * UP)\n        text4_1 = TextMobject('Definici\u00f3n 1.', \" Sean $f:U\\\\subset\\\\mathbb{R}^{2}\\\\to\\\\mathbb{R}$ y $(x_{0},y_{0}) \\\\in U \\\\cap U'$, f es\\n\\n                              diferenciable en $(x_{0},y_{0})$ si y solo si existe $(m_{1},m_{2})\\\\in\\\\mathbb{R}^{2}$ tal que\").move_to(UP)\n        text4_1.set_color_by_tex('Definici\u00f3n 1.', color=TEAL)\n        text4_1.scale(0.9)\n        text4_2 = TextMobject('$$\\\\lim_{(h_{1},h_{2})\\\\to(0,0)}\\\\dfrac{f((x_{0},y_{0})+(h_{1},h_{2}))-(f(x_{0},y_{0})+(m_{1},m_{2})\\\\cdot(h_{1},h_{2}))}{||(h_{1},h_{2})||}=0.$$').next_to(text4_1, 2 * DOWN)\n        text4_2.scale(0.8)\n        text5_1 = TextMobject('Haciendo el cambio de variables $h_{1}=x-x_{0}$ y $h_{2}=y-y_{0}$,').move_to(3 * UP)\n        text5_2 = TextMobject('$$\\\\lim_{(x,y)\\\\to(x_{0},y_{0})}\\\\dfrac{f((x_{0},y_{0})+(x-x_{0},y-y_{0}))-(f(x_{0},y_{0})+(m_{1},m_{2})\\\\cdot(x-x_{0},y-y_{0}))}{||(x-x_{0},y-y_{0})||}=0.$$').next_to(text5_1, 2 * DOWN)\n        text5_2.scale(0.7)\n        text6_1 = TextMobject('Desarrollando la expresi\u00f3n anterior,').next_to(text5_2, 2 * DOWN)\n        text6_2 = TextMobject('$$\\\\lim_{(x,y)\\\\to(x_{0},y_{0})}\\\\dfrac{f(x,y)-(f(x_{0},y_{0})+m_{1}(x-x_{0})+m_{2}(y-y_{0}))}{||(x-x_{0},y-y_{0})||}=0.$$').next_to(text6_1, 2 * DOWN)\n        text6_2.scale(0.7)\n        text7 = TextMobject('Intuitivamente, $(m_{1},m_{2})$ nos da la inclinaci\u00f3n del plano\\n\\n                              que m\u00e1s se parece a la funci\u00f3n en $(x_{0}, y_{0})$.').next_to(text6_2, 3 * DOWN)\n        text8 = TextMobject('Primero observemos que la gr\u00e1fica de $m_{1}x+m_{2}y$\\n\\n                              nos da un plano que contiene al origen.').move_to(3 * DOWN)\n        func_text = TextMobject('$f(x,y)=\\\\frac{x^{2}+y^{2}}{2}$')\n        func_text.scale(0.7)\n        func_text.move_to(5 * RIGHT + 2 * UP)\n        punto_text = TextMobject('$(x_{0},y_{0})=(\\\\sqrt{2},\\\\sqrt{2})$')\n        punto_text.scale(0.7)\n        punto_text.next_to(func_text, DOWN)\n        text9 = TextMobject('Si a dicho plano lo trasladamos a $(x_{0},y_{0},f(x_{0},y_{0}))$, obtendremos\\n\\n                              el plano tangente a la superficie en ese mismo punto.').move_to(3 * DOWN)\n        text9.scale(0.9)\n        text10 = TextMobject('Definici\u00f3n 2.', \" Sea $f:U\\\\subset\\\\mathbb{R}^{2}\\\\to\\\\mathbb{R}$ diferenciable en \\n\\n                               $(x_{0},y_{0})\\\\in U \\\\cap U'$, decimos que el plano que tiene como\\n\\n                               ecuaci\u00f3n $f(x_{0},y_{0})+m_{1}(x-x_{0})+m_{2}(y-y_{0})$ es el plano\\n\\n                               tangente a la gr\u00e1fica de $f$ en el punto $(x_{0},y_{0},f(x_{0},y_{0}))$,\\n\\n                               donde $(m_{1},m_{2})$ es el vector que cumple la \", 'Definici\u00f3n 1.')\n        text10.set_color_by_tex('Definici\u00f3n 2.', color=TEAL)\n        text10.set_color_by_tex('Definici\u00f3n 1.', color=TEAL)\n        text11 = TextMobject(\"De manera general, para $f:U\\\\subset\\\\mathbb{R}^n\\\\to\\\\mathbb{R}$, $f$ es diferenciable\\n\\n                               en $\\\\vec{x}_{0}\\\\in U\\\\cap U'$ si y solo si existe $\\\\vec{m}\\\\in\\\\mathbb{R}^n$ tal que\\n                               $$\\\\lim_{\\\\vec{h}\\\\to\\\\vec{0}}\\\\dfrac{f\\\\left(\\\\vec{x}_0+\\\\vec{h}\\\\right)-\\\\left(f(\\\\vec{x}_0)+\\\\vec{m}\\\\cdot\\\\vec{h}\\\\right)}{||\\\\vec{h}||}=0.$$\")\n        text12 = TextMobject('Por lo tanto, podemos decir que $f$ es diferenciable en $\\\\vec{x}_{0}$ si y\\n\\n                               s\u00f3lo si el plano tangente a la funci\u00f3n en $(\\\\vec{x}_{0},f(\\\\vec{x}_{0}))$ es una\\n\\n                               buena aproximaci\u00f3n para la funci\u00f3n alrededor de ese punto.').move_to(UP)\n        text13 = TextMobject('Pero, ', '\u00bfc\u00f3mo podemos encontrar al vector $\\\\vec{m}$?').next_to(text12, 3 * DOWN)\n        text13.set_color_by_tex('\u00bfc\u00f3mo podemos encontrar al vector $\\\\vec{m}$?', color=TEAL)\n        text1.bg = SurroundingRectangle(text1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo1 = VGroup(text1.bg, text1)\n        text2.bg = SurroundingRectangle(text2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo2 = VGroup(text2.bg, text2)\n        text3.bg = SurroundingRectangle(text3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo3 = VGroup(text3.bg, text3)\n        text8.bg = SurroundingRectangle(text8, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo8 = VGroup(text8.bg, text8)\n        text9.bg = SurroundingRectangle(text9, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo9 = VGroup(text9.bg, text9)\n        axis_config = {'dimension': 3, 'x_min': -3, 'x_max': 3, 'y_min': -3, 'y_max': 3, 'z_min': -1, 'z_max': 2, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT}\n        axes = ThreeDAxes(**axis_config)\n        axes_c = ThreeDAxes(**axis_config)\n        axes_p = ThreeDAxes(**axis_config)\n        cono = Cono().set_shade_in_3d(True)\n        graf_cono = VGroup(axes_c, cono)\n        graf_cono.move_to(2 * RIGHT + 2 * DOWN)\n        paraboloide1 = Paraboloide1().set_shade_in_3d(True)\n        graf_parab = VGroup(axes_p, paraboloide1)\n        graf_parab.move_to(2 * LEFT + 2 * UP)\n        plano1 = Plano1().set_shade_in_3d(True)\n        self.set_camera_orientation(0.7 * np.pi / 2, 0.25 * np.pi)\n        self.add_fixed_in_frame_mobjects(gpo1)\n        self.play(Write(gpo1))\n        self.play(ShowCreation(graf_cono))\n        self.play(ShowCreation(graf_parab))\n        self.wait()\n        self.play(FadeOut(gpo1))\n        self.add_fixed_in_frame_mobjects(gpo2)\n        self.play(Write(gpo2))\n        self.wait(2)\n        self.play(FadeOut(gpo2))\n        self.add_fixed_in_frame_mobjects(gpo3)\n        self.play(Write(gpo3))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(phi=0, theta=-90 * DEGREES)\n        self.play(Write(text4_1))\n        self.wait(8)\n        self.play(Write(text4_2))\n        self.wait(8)\n        self.play(FadeOut(text4_1), FadeOut(text4_2))\n        self.play(Write(text5_1))\n        self.wait(2)\n        self.play(Write(text5_2), run_time=3)\n        self.wait(5)\n        self.play(Write(text6_1))\n        self.wait(2)\n        self.play(Write(text6_2), run_time=3)\n        self.wait(5)\n        self.play(Write(text7), run_time=3)\n        self.wait(5)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(0.7 * np.pi / 2, 0.25 * np.pi)\n        self.add_fixed_in_frame_mobjects(gpo8)\n        self.play(Write(gpo8))\n        self.play(ShowCreation(axes))\n        self.add_fixed_in_frame_mobjects(func_text, punto_text)\n        self.play(Write(func_text), Write(punto_text))\n        self.play(ShowCreation(Paraboloide1().set_shade_in_3d(True)))\n        self.play(ShowCreation(plano1))\n        self.wait()\n        self.play(FadeOut(gpo8))\n        self.add_fixed_in_frame_mobjects(gpo9)\n        self.play(Write(gpo9), run_time=3)\n        self.play(ApplyMethod(plano1.move_to, [np.sqrt(2), np.sqrt(2), 2]))\n        self.wait()\n        self.move_camera(85 * DEGREES, -40 * DEGREES, frame_center=(0, 0, 0), run_time=2)\n        self.wait()\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(phi=0, theta=-90 * DEGREES)\n        self.play(Write(text10), run_time=5)\n        self.wait(10)\n        self.play(FadeOut(text10))\n        self.play(Write(text11), run_time=3)\n        self.wait(10)\n        self.play(FadeOut(text11))\n        self.play(Write(text12), run_time=3)\n        self.wait(10)\n        self.play(Write(text13))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n\n    def parte2(self):\n        subtitle1 = TextMobject('Derivadas direccionales').scale(1.5)\n        text1 = TextMobject('Consideremos $f:U\\\\subset\\\\mathbb{R}^{2}\\\\to\\\\mathbb{R}$ y tomemos\\n\\n                              $\\\\vec{x}_{0}\\\\in U$ y $\\\\vec{u}\\\\in\\\\mathbb{R}^{n}$ tal que $||\\\\vec{u}||=1$.').move_to(3 * UP)\n        text2 = TextMobject('La funci\u00f3n $f$ es derivable en el punto $\\\\vec{x}_{0}$ en la direcci\u00f3n\\n                            $$\\\\text{del vector }\\\\vec{u}\\\\text{ si }\\\\lim_{h\\\\to 0}\\\\frac{f(\\\\vec{x}_{0}+h\\\\vec{u})-f(\\\\vec{x}_{0})}{h}\\\\text{ existe.}$$')\n        text3 = TextMobject('Al valor de dicho l\u00edmite se le denota por ', '$D_{\\\\vec{u}}f(\\\\vec{x_{0}})$.').move_to(2 * DOWN)\n        text3.set_color_by_tex('$D_{\\\\vec{u}}f(\\\\vec{x_{0}})$.', color=TEAL)\n        text4 = TextMobject('\u00bfQu\u00e9 similitudes y diferencias encuentras\\n\\n                              entre la definici\u00f3n anterior y la definici\u00f3n\\n\\n                              de derivabilidad para funciones de $\\\\mathbb{R}$ en $\\\\mathbb{R}$?').move_to(2.8 * UP)\n        text5 = TextMobject('En general, $D_{\\\\vec{u}}f(\\\\vec{x_{0}})$ es una medida de la\\n\\n                            raz\u00f3n de cambio instant\u00e1nea de la funci\u00f3n $f$,\\n\\n                            partiendo del vector $\\\\vec{x}_{0}$ y en la direcci\u00f3n de $\\\\vec{u}$.')\n        text6 = TextMobject('La derivada direccional tiene una\\n\\n                              interpretaci\u00f3n geom\u00e9trica \u00fatil.').move_to(2.3 * DOWN)\n        text7 = TextMobject('La siguiente funci\u00f3n $f$ es derivable en\\n\\n                              el punto $(0,2)$ en la direcci\u00f3n $\\\\left(-\\\\frac{1}{\\\\sqrt{2}},\\\\frac{1}{\\\\sqrt{2}}\\\\right)$.').move_to(3 * UP)\n        func_text2 = TextMobject('$f(x,y)=-\\\\frac{x^2 + y^2}{3}+2$').move_to(3 * DOWN - 3.5 * RIGHT)\n        text8 = TextMobject('Al intersecar la gr\u00e1fica de $f$ con el plano perpendicular a $XY$ que contiene\\n\\n                            a la recta $\\\\vec{x}_{0}+h\\\\vec{u}=(0,2)+h\\\\left(-\\\\frac{1}{\\\\sqrt{2}},\\\\frac{1}{\\\\sqrt{2}}\\\\right)$, $h\\\\in\\\\mathbb{R}$, se obtiene una curva.').move_to(3 * UP)\n        text8.scale(0.8)\n        text9 = TextMobject('$D_{\\\\vec{u}}f(0,2) = -\\\\frac{2\\\\sqrt{2}}{3}$ es la pendiente de la recta \\n \\n                                tangente a la curva en el punto $\\\\left(0,2,\\\\frac{2}{3}\\\\right)$.').move_to(3 * UP)\n        text10 = TextMobject('Es decir, la derivada direccional coincide con la pendiente\\n\\n                              de la recta tangente en el corte correspondiente.').move_to(3 * UP)\n        text11 = TextMobject('Muchas de las propiedades que cumplen las\\n\\n                              derivadas de funciones de $\\\\mathbb{R}$ en $\\\\mathbb{R}$, las conservan\\n \\n                              de cierta forma las derivadas direccionales, como\\n\\n                              las relacionadas con la aritm\u00e9tica de funciones.')\n        text12 = TextMobject('Por ejemplo, si tenemos dos funciones tales que $D_{\\\\vec{u}}f(\\\\vec{x_{0}})$ y\\n\\n                                $D_{\\\\vec{u}}g(\\\\vec{x_{0}})$ existen, entonces $D_{\\\\vec{u}}(fg)(\\\\vec{x_{0}})$ existe y adem\u00e1s', '$$D_{\\\\vec{u}}(fg)(\\\\vec{x_{0}}) = f(\\\\vec{x}_{0})D_{\\\\vec{u}}g(\\\\vec{x_{0}}) + g(\\\\vec{x}_{0})D_{\\\\vec{u}}f(\\\\vec{x_{0}}).$$')\n        text12.set_color_by_tex('$$D_{\\\\vec{u}}(fg)(\\\\vec{x_{0}}) = f(\\\\vec{x}_{0})D_{\\\\vec{u}}g(\\\\vec{x_{0}}) + g(\\\\vec{x}_{0})D_{\\\\vec{u}}f(\\\\vec{x_{0}}).$$', color=TEAL)\n        text13 = TextMobject('Para ver lo anterior, consideremos los mismos $f$, $\\\\vec{u}$ y $\\\\vec{x}_{0}$,\\n\\n                                y tomemos $g(x, y) = \\\\frac{x^{2}-y^{2}}{4}$.').move_to(3 * UP)\n        f_text = TextMobject('$f(0,2)=\\\\frac{2}{3}$').move_to(4 * LEFT + 2 * DOWN)\n        g_text = TextMobject('$g(0,2)=-1$').next_to(f_text, DOWN)\n        f_text.scale(0.8)\n        g_text.scale(0.8)\n        df_text = TextMobject('$D_{\\\\vec{u}}f(0,2)=-\\\\frac{2\\\\sqrt{2}}{3}$').move_to(2 * DOWN)\n        dg_text = TextMobject('$D_{\\\\vec{u}}g(0,2)=-\\\\frac{\\\\sqrt{2}}{2}$').next_to(df_text, DOWN)\n        dfg_text = TextMobject('$D_{\\\\vec{u}}(fg)(0,2)=\\\\frac{\\\\sqrt{2}}{3}$').move_to(4 * RIGHT + 2 * DOWN)\n        df_text.scale(0.8)\n        dg_text.scale(0.8)\n        dfg_text.scale(0.8)\n        text7.bg = SurroundingRectangle(text7, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo7 = VGroup(text7.bg, text7)\n        text8.bg = SurroundingRectangle(text8, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo8 = VGroup(text8.bg, text8)\n        text9.bg = SurroundingRectangle(text9, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo9 = VGroup(text9.bg, text9)\n        text10.bg = SurroundingRectangle(text10, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo10 = VGroup(text10.bg, text10)\n        text13.bg = SurroundingRectangle(text13, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo13 = VGroup(text13.bg, text13)\n        axis_config = {'dimension': 3, 'x_min': -4, 'x_max': 4, 'y_min': -4, 'y_max': 4, 'z_min': -1, 'z_max': 3, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT}\n        axes = ThreeDAxes(**axis_config)\n        axes_f = ThreeDAxes(**axis_config)\n        axes_g = ThreeDAxes(**axis_config)\n        plano2 = Plano2().set_shade_in_3d(True)\n        paraboloide2 = Paraboloide2().set_shade_in_3d(True)\n        superficie1 = Superficie1().set_shade_in_3d(True)\n        superficie2 = Superficie2().set_shade_in_3d(True)\n        x_0, y_0 = (0, 2)\n        z_0 = self.paraboloide2(x_0, y_0)\n        punto1 = Dot(color=YELLOW).move_to([x_0, y_0, 0]).set_shade_in_3d(True)\n        direc = Vector(direction=[-1 / np.sqrt(2), 1 / np.sqrt(2), 0], buff=0.075).set_color(YELLOW)\n        curva1 = ParametricFunction(self.curva1, t_min=1 - np.sqrt(7) / np.sqrt(2), t_max=1 + np.sqrt(7) / np.sqrt(2), color=BLUE)\n        curva2 = ParametricFunction(self.curva2, t_min=-0.802328, t_max=2.698, color=ORANGE)\n        tangente1 = ParametricFunction(self.tangente1, t_min=-np.sqrt(2), t_max=5 / (4 * np.sqrt(2)), color=PURPLE)\n        tangente2 = ParametricFunction(self.tangente2, t_min=-np.sqrt(2), t_max=1 / np.sqrt(2), color=PURPLE)\n        self.play(Write(subtitle1))\n        self.wait()\n        self.play(FadeOut(subtitle1))\n        self.play(Write(text1))\n        self.wait(3)\n        self.play(Write(text2), run_time=3)\n        self.wait(5)\n        self.play(Write(text3))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.play(Write(text4), run_time=3)\n        self.wait(5)\n        self.play(Write(text5), run_time=3)\n        self.wait(5)\n        self.play(Write(text6))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(0.7 * np.pi / 2, 0.25 * np.pi)\n        self.add_fixed_in_frame_mobjects(gpo7, func_text2)\n        self.play(Write(gpo7), Write(func_text2), run_time=3)\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(punto1), ShowCreation(direc))\n        self.wait()\n        self.play(ApplyMethod(punto1.move_to, [x_0, y_0, self.paraboloide2(x_0, y_0)]))\n        self.play(ApplyMethod(direc.move_to, [x_0 - 1 / (2 * np.sqrt(2)), y_0 + 1 / (2 * np.sqrt(2)), self.paraboloide2(x_0, y_0)]))\n        self.play(ShowCreation(paraboloide2))\n        self.wait()\n        self.play(FadeOut(gpo7))\n        self.add_fixed_in_frame_mobjects(gpo8)\n        self.play(Write(gpo8), run_time=3)\n        self.wait()\n        self.play(FadeOut(direc), ShowCreation(plano2))\n        self.play(ShowCreation(curva1), FadeOut(paraboloide2))\n        self.move_camera(90 * DEGREES, 45 * DEGREES, frame_center=(0, 0, 0), run_time=3)\n        self.wait()\n        self.play(FadeOut(gpo8))\n        self.add_fixed_in_frame_mobjects(gpo9)\n        self.play(Write(gpo9))\n        self.play(ShowCreation(tangente1))\n        self.wait(2)\n        self.play(FadeOut(gpo9))\n        self.add_fixed_in_frame_mobjects(gpo10)\n        self.play(Write(gpo10), run_time=3)\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(phi=0, theta=-90 * DEGREES)\n        self.play(Write(text11), run_time=4)\n        self.wait(10)\n        self.play(FadeOut(text11))\n        self.play(Write(text12), run_time=3)\n        self.wait(10)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(0.7 * np.pi / 2, 0.25 * np.pi)\n        self.add_fixed_in_frame_mobjects(gpo13)\n        self.play(Write(gpo13))\n        self.wait(3)\n        graf_f = VGroup(axes_f, paraboloide2)\n        graf_f.move_to(2.5 * RIGHT + 2 * DOWN)\n        graf_f.scale(0.8)\n        graf_g = VGroup(axes_g, superficie1)\n        graf_g.move_to(1.5 * LEFT + 3 * UP)\n        graf_g.scale(0.8)\n        self.play(ShowCreation(graf_f), ShowCreation(graf_g))\n        self.wait(2)\n        self.play(FadeOut(graf_f), FadeOut(graf_g))\n        self.play(ShowCreation(axes), ShowCreation(superficie2))\n        self.wait()\n        self.play(ShowCreation(plano2))\n        self.play(ShowCreation(curva2), FadeOut(superficie2))\n        self.move_camera(90 * DEGREES, 45 * DEGREES, frame_center=(0, 0, 0), run_time=3)\n        self.add_fixed_in_frame_mobjects(f_text, g_text)\n        self.play(Write(f_text), Write(g_text))\n        self.wait(3)\n        self.add_fixed_in_frame_mobjects(df_text, dg_text)\n        self.play(Write(df_text), Write(dg_text))\n        self.wait(3)\n        self.add_fixed_in_frame_mobjects(dfg_text)\n        self.play(Write(dfg_text))\n        self.wait(3)\n        self.play(ShowCreation(tangente2))\n        self.wait()\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n\n    def parte3(self):\n        subtitle2 = TextMobject('Derivadas parciales').scale(1.5)\n        text1 = TextMobject('Sea $f:U\\\\subset\\\\mathbb{R}^2\\\\to\\\\mathbb{R}$, fij\u00e9monos en un punto\\n\\n                              $\\\\vec{x}_0\\\\in U$ y el respectivo valor para $f(\\\\vec{x}_0)$.').move_to(3 * UP)\n        func_text3 = TextMobject('$f(x)=\\\\frac{x^2-y^2}{4}$').move_to(2.5 * DOWN - 3.2 * RIGHT)\n        text2 = TextMobject('Podemos obtener las derivadas direccionales de\\n\\n                              $f$ en $\\\\vec{x}_0$ en una multitud de direcciones.').move_to(3 * UP)\n        text3 = TextMobject('Particularmente nos podemos fijar en aquellas en las que se\\n\\n                              utiliza una direcci\u00f3n can\u00f3nica dada por $\\\\vec{e}_1$ o por $\\\\vec{e}_2$.').move_to(3 * UP)\n        text4 = TextMobject('Tomemos la derivada en la direcci\u00f3n $\\\\vec{e}_1$.').move_to(3 * UP)\n        text5_1 = TextMobject('A esta la podemos ver de la forma').move_to(2 * UP)\n        text5_2 = TextMobject('$$D_{\\\\vec{e}_1}f(\\\\vec{x}_0)=\\\\lim_{h\\\\to 0}\\\\dfrac{f(\\\\vec{x}_0+h \\\\ \\\\ \\\\vec{e}_1 \\\\ \\\\ )-f(\\\\vec{x_0})}{h}.$$').next_to(text5_1, 2 * DOWN)\n        text6_1 = TextMobject('Recordando que $\\\\vec{e}_1=(1,0)$,').move_to(2 * UP)\n        text6_2 = TextMobject('$$D_{\\\\vec{e}_1}f(\\\\vec{x}_0)=\\\\lim_{h\\\\to 0}\\\\dfrac{f(\\\\vec{x}_0+h(1,0))-f(\\\\vec{x_0})}{h}.$$').next_to(text6_1, 2 * DOWN)\n        text6_3 = TextMobject('$$D_{\\\\vec{e}_1}f(\\\\vec{x}_0)=\\\\lim_{h\\\\to 0}\\\\dfrac{f(\\\\vec{x}_0+(h,0))-f(\\\\vec{x_0})}{h}.$$').next_to(text6_1, 2 * DOWN)\n        text7 = TextMobject('A este caso particular de la derivada direccional se le\\n\\n                                conoce como derivada parcial de $f$ con respecto a $x$.').next_to(text6_3, 3 * DOWN)\n        text8 = TextMobject('Se representa de la forma', '$$\\\\dfrac{\\\\partial f}{\\\\partial x}(\\\\vec{x}_0)=\\\\lim_{h\\\\to0}\\\\dfrac{f(\\\\vec{x}_0+h\\\\vec{e}_1)-f(\\\\vec{x}_0)}{h}.$$').move_to(2 * UP)\n        text8.set_color_by_tex('$$\\\\dfrac{\\\\partial f}{\\\\partial x}(\\\\vec{x}_0)', color=TEAL)\n        text9 = TextMobject('An\u00e1logamente, tenemos', '$$\\\\dfrac{\\\\partial f}{\\\\partial y}(\\\\vec{x}_0)=\\\\lim_{h\\\\to0}\\\\dfrac{f(\\\\vec{x}_0+h\\\\vec{e}_2)-f(\\\\vec{x}_0)}{h}.$$').next_to(text8, 2 * DOWN)\n        text9.set_color_by_tex('$$\\\\dfrac{\\\\partial f}{\\\\partial y}(\\\\vec{x}_0)', color=TEAL)\n        text10 = TextMobject('En general, si $f:U\\\\subset\\\\mathbb{R}^n\\\\to\\\\mathbb{R}$, $\\\\vec{x}_0\\\\in U$, para cada\\n\\n                              $$i\\\\in\\\\{1,...,n\\\\}\\\\text{ se tiene }\\\\dfrac{\\\\partial f}{\\\\partial x_i}(\\\\vec{x}_0)=\\\\lim_{h\\\\to0}\\\\dfrac{f(\\\\vec{x}_0+h\\\\vec{e}_i)-f(\\\\vec{x}_0)}{h}.$$')\n        text11 = TextMobject('$\\\\frac{\\\\partial f}{\\\\partial x_i}(\\\\vec{x}_{0})$ es la pendiente de la recta tangente\\n\\n                                a $f$ en $\\\\vec{x}_0$ en la $i-$\u00e9sima direcci\u00f3n can\u00f3nica.').move_to(3 * UP)\n        text12 = TextMobject('De esta forma se puede ver a $\\\\frac{\\\\partial f}{\\\\partial x_i}$ como la derivada\\n\\n                                de $f$ en el $i-$\u00e9simo corte can\u00f3nico.').move_to(3 * UP)\n        text13 = TextMobject('Al vector $\\\\left(\\\\frac{\\\\partial f}{\\\\partial x_1}(\\\\vec{x}_0),...,\\\\frac{\\\\partial f}{\\\\partial x_n}(\\\\vec{x}_0)\\\\right)$ se le llama\\n\\n                                gradiente de $f$ en $\\\\vec{x}_0$, representado como $\\\\nabla f(x_0)$,\\n\\n                                y es la mejor aproximaci\u00f3n lineal a $f$ en el punto $\\\\vec{x}_{0}$, \\n\\n                                para funciones diferenciables.')\n        text14 = TextMobject('Por lo tanto, si una funci\u00f3n $f$ es diferenciable en $\\\\vec{x}_{0}$,\\n\\n                                \u00a1el vector $\\\\vec{m}$ que buscamos y que cumple la ', 'Definici\u00f3n 1', '\\n\\n                                es ', '$\\\\vec{m}=\\\\nabla f(\\\\vec{x}_{0})$', '$=\\\\left(\\\\frac{\\\\partial f}{\\\\partial x_1}(\\\\vec{x}_{0}),...,\\\\frac{\\\\partial f}{\\\\partial x_n}(\\\\vec{x}_{0})\\\\right)$!')\n        text14.set_color_by_tex('Definici\u00f3n 1', color=TEAL)\n        text14.set_color_by_tex('$\\\\vec{m}=\\\\nabla f(\\\\vec{x}_{0})$', color=TEAL)\n        text15 = TextMobject('Adicionalmente, el gradiente tiene\\n\\n                                un par de usos importantes.').move_to(UP)\n        text16 = TextMobject('En primer lugar, si $f$ es diferenciable, el\\n\\n                                gradiente nos permite expresar sus derivadas\\n\\n                                direccionales como $D_{\\\\vec{u}}f(\\\\vec{x_{0}})=\\\\nabla f(\\\\vec{x}_0)\\\\cdot\\\\vec{u}$.').next_to(text15, 3 * DOWN)\n        text17 = TextMobject('En segundo lugar, el gradiente apunta en la\\n\\n                                direcci\u00f3n y sentido de m\u00e1ximo crecimiento de la superficie,\\n\\n                                como consecuencia de que $D_{\\\\vec{u}}f(\\\\vec{x}_0)=||\\\\nabla f(\\\\vec{x}_0)||\\\\cdot\\\\cos\\\\theta$,\\n\\n                                donde $\\\\theta$ es el \u00e1ngulo entre el gradiente y $\\\\vec{u}$.').move_to(UP)\n        text18 = TextMobject('Por lo mismo, en el sentido contrario del gradiente\\n\\n                                se obtiene el m\u00e1ximo decrecimiento de $f$.').next_to(text17, 3 * DOWN)\n        text19 = TextMobject('Regresemos a la funci\u00f3n $f(x,y)=-\\\\frac{x^{2}+y^{2}}{3}+2$,\\n\\n                                donde $\\\\nabla f(x,y)=\\\\left(-\\\\frac{2x}{3},-\\\\frac{2y}{3}\\\\right)$.').move_to(3 * UP)\n        text20_1 = TextMobject('$\\\\nabla f(0,2)\\\\cdot\\\\left(-\\\\frac{1}{\\\\sqrt{2}},\\\\frac{1}{\\\\sqrt{2}}\\\\right)=-\\\\frac{2\\\\sqrt{2}}{3}$, que es el valor que obtuvimos inicialmente').move_to(3 * DOWN)\n        text20_1.scale(0.7)\n        text20_2 = TextMobject('para la derivada de $f$ en $(0,2)$ y en la direcci\u00f3n $\\\\left(-\\\\frac{1}{\\\\sqrt{2}},\\\\frac{1}{\\\\sqrt{2}}\\\\right)$.').move_to(3 * DOWN)\n        text20_2.scale(0.7)\n        text21 = TextMobject('Al recorrer el dominio hacia el origen desde $(0,2)$, la superficie crece con mayor inclinaci\u00f3n, pues $\\\\nabla f(0,2)=\\\\left(0,-\\\\frac{4}{3}\\\\right)$.').move_to(3 * DOWN)\n        text21.scale(0.7)\n        text22 = TextMobject('Al hacerlo, el punto en la gr\u00e1fica va subiendo\\n\\n                             la superficie como si fuera un monte.').move_to(3 * DOWN)\n        text22.scale(0.7)\n        text23 = TextMobject('Si usamos la derivada direccional, al tomar $\\\\vec{u}=(0,-1)$, obtenemos la inclinaci\u00f3n de la superficie en la direcci\u00f3n y sentido del gradiente desde el punto $(0,2)$, la cual es $\\\\frac{4}{3}$.').move_to(3.2 * DOWN)\n        text23.scale(0.6)\n        text24 = TextMobject('En cambio, al alejarnos del origen sobre el eje Y desde el punto $(0,2)$, la superficie va de bajada.').move_to(3 * DOWN)\n        text24.scale(0.7)\n        text25 = TextMobject('Adem\u00e1s, en esa direcci\u00f3n y sentido est\u00e1 la mayor inclinaci\u00f3n hacia abajo, porque el gradiente de $f$ en $(0,2)$ apunta hacia el origen.').move_to(3 * DOWN)\n        text25.scale(0.7)\n        text26 = TextMobject('Es decir, si elegimos $\\\\vec{u}=(0,1)$, entonces en $(0,2)$, $\\\\vec{u}$ va en la misma direcci\u00f3n del gradiente, pero en sentido contrario.').move_to(3 * DOWN)\n        text26.scale(0.7)\n        text27 = TextMobject('Como la superficie va de bajada, la derivada direccional es negativa y es el menor valor posible en este punto; tal derivada es $-\\\\frac{4}{3}$.').move_to(3 * DOWN)\n        text27.scale(0.6)\n        text1.bg = SurroundingRectangle(text1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo1 = VGroup(text1.bg, text1)\n        text2.bg = SurroundingRectangle(text2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo2 = VGroup(text2.bg, text2)\n        text3.bg = SurroundingRectangle(text3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo3 = VGroup(text3.bg, text3)\n        text4.bg = SurroundingRectangle(text4, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo4 = VGroup(text4.bg, text4)\n        text11.bg = SurroundingRectangle(text11, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo11 = VGroup(text11.bg, text11)\n        text12.bg = SurroundingRectangle(text12, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo12 = VGroup(text12.bg, text12)\n        text19.bg = SurroundingRectangle(text19, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo19 = VGroup(text19.bg, text19)\n        axis_config = {'dimension': 3, 'x_min': -3.5, 'x_max': 3.5, 'y_min': -3.5, 'y_max': 3.5, 'z_min': -2, 'z_max': 3, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT}\n        axis_config2 = {'dimension': 3, 'x_min': -4, 'x_max': 4, 'y_min': -4, 'y_max': 4, 'z_min': -1, 'z_max': 3, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT}\n        axes = ThreeDAxes(**axis_config)\n        axes2 = ThreeDAxes(**axis_config2)\n        plano3 = Plano3().set_shade_in_3d(True)\n        superficie3 = Superficie3().set_shade_in_3d(True)\n        x_1, y_1 = (0, 0)\n        z_1 = self.superficie3(x_1, y_1)\n        punto2 = Dot(color=YELLOW).move_to([x_1, y_1, z_1]).set_shade_in_3d(True)\n        curva3 = ParametricFunction(self.curva3, t_min=-2.7, t_max=2.7, color=BLUE)\n        tangente3 = ParametricFunction(self.tangente3, t_min=-2.7, t_max=2.7, color=PURPLE)\n        recorrido_a_1 = DashedVMobject(ParametricFunction(self.recorrido, t_min=2, t_max=0, color=GREEN_E))\n        recorrido_a_2 = DashedVMobject(ParametricFunction(self.recorrido, t_min=2, t_max=0, color=GREEN_E))\n        recorrido_b = DashedVMobject(ParametricFunction(self.recorrido, t_min=2, t_max=3, color=RED_E))\n        circulo = Circle(radius=0.01, color=PURPLE).move_to(punto2.get_center())\n        rad = ValueTracker(0.01)\n\n        def upd_for_circle(obj):\n            c = obj\n            new_c = Circle(radius=rad.get_value(), color=PURPLE).move_to(punto2.get_center())\n            c.become(new_c)\n        dir1 = Arrow((0, 0, 0), (1 / np.sqrt(2), -1 / np.sqrt(2), 0), buff=0.075)\n        dir2 = Arrow((0, 0, 0), (1 / np.sqrt(2), 1 / np.sqrt(2), 0), buff=0.075)\n        dir3 = Arrow((0, 0, 0), (-1 / np.sqrt(2), -1 / np.sqrt(2), 0), buff=0.075)\n        dir4 = Arrow((0, 0, 0), (-1 / np.sqrt(2), 1 / np.sqrt(2), 0), buff=0.075)\n        dir5 = Arrow((0, 0, 0), (0, -1, 0), buff=0.075)\n        dir6 = Arrow((0, 0, 0), (0, 1, 0), buff=0.075)\n        dir6_r = dir6.copy().set_color(RED)\n        dir7 = Arrow((0, 0, 0), (-1, 0, 0), buff=0.075)\n        dir8 = Arrow((0, 0, 0), (1, 0, 0), buff=0.075)\n        dir8_r = dir8.copy().set_color(RED)\n        dir8_y = dir8.copy().set_color(YELLOW)\n        Dirs = VGroup(dir1, dir2, dir3, dir4, dir5, dir6, dir7, dir8)\n        Dirs.set_color(PURPLE)\n        self.set_camera_orientation(phi=0, theta=-90 * DEGREES)\n        self.play(Write(subtitle2))\n        self.wait()\n        self.play(FadeOut(subtitle2))\n        self.set_camera_orientation(0.7 * np.pi / 2, 0.25 * np.pi)\n        self.add_fixed_in_frame_mobjects(gpo1)\n        self.play(Write(gpo1))\n        self.play(ShowCreation(axes))\n        self.add_fixed_in_frame_mobjects(func_text3)\n        self.play(Write(func_text3))\n        self.play(ShowCreation(superficie3))\n        self.play(ShowCreation(punto2))\n        self.wait()\n        self.play(FadeOut(gpo1))\n        self.add_fixed_in_frame_mobjects(gpo2)\n        self.play(Write(gpo2))\n        self.play(ShowCreation(Dirs))\n        self.wait()\n        self.play(FadeOut(gpo2))\n        self.add_fixed_in_frame_mobjects(gpo3)\n        self.play(Write(gpo3))\n        self.play(FadeOut(Dirs), ReplacementTransform(dir6, dir6_r), ReplacementTransform(dir8, dir8_r))\n        self.wait(3)\n        self.play(FadeOut(gpo3), run_time=2)\n        self.add_fixed_in_frame_mobjects(gpo4)\n        self.play(Write(gpo4))\n        self.play(FadeOut(dir6_r), ReplacementTransform(dir8_r, dir8_y))\n        self.wait()\n        self.play(FadeOut(gpo4))\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(phi=0, theta=-90 * DEGREES)\n        self.play(Write(text5_1))\n        self.play(Write(text5_2))\n        self.wait(5)\n        self.play(ReplacementTransform(text5_1, text6_1))\n        self.wait()\n        self.play(ReplacementTransform(VGroup(text5_2[0][24], text5_2[0][25], text5_2[0][26]), VGroup(text6_2[0][24], text6_2[0][25], text6_2[0][26], text6_2[0][27], text6_2[0][28])))\n        self.wait()\n        self.play(ReplacementTransform(VGroup(text5_2[0][23], text6_2[0][24], text6_2[0][25], text6_2[0][26], text6_2[0][27], text6_2[0][28]), VGroup(text6_3[0][23], text6_3[0][24], text6_3[0][25], text6_3[0][26], text6_3[0][27])))\n        self.wait()\n        self.play(Write(text7))\n        self.wait(3)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.play(Write(text8))\n        self.wait(3)\n        self.play(Write(text9))\n        self.wait(3)\n        self.play(FadeOut(text8), FadeOut(text9))\n        self.play(Write(text10))\n        self.wait(3)\n        self.play(FadeOut(text10))\n        self.set_camera_orientation(0.7 * np.pi / 2, 0.25 * np.pi)\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie3), ShowCreation(punto2), ShowCreation(dir8_y))\n        self.add_fixed_in_frame_mobjects(gpo11)\n        self.play(Write(gpo11))\n        self.wait()\n        self.play(ShowCreation(plano3), FadeOut(dir8_y))\n        self.wait()\n        self.play(ShowCreation(curva3), FadeOut(superficie3))\n        self.wait()\n        self.move_camera(phi=90 * DEGREES, theta=90 * DEGREES, gamma=0 * DEGREES, frame_center=(0, 0, 0), run_time=2)\n        self.wait()\n        self.play(ShowCreation(tangente3))\n        self.wait()\n        self.play(FadeOut(gpo11))\n        self.add_fixed_in_frame_mobjects(gpo12)\n        self.play(Write(gpo12))\n        self.wait(4)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(phi=0, theta=-90 * DEGREES)\n        self.play(Write(text13), run_time=3)\n        self.wait(6)\n        self.play(FadeOut(text13))\n        self.play(Write(text14), run_time=3)\n        self.wait(6)\n        self.play(FadeOut(text14))\n        self.play(Write(text15))\n        self.wait()\n        self.play(Write(text16), run_time=3)\n        self.wait(6)\n        self.play(FadeOut(text15), FadeOut(text16))\n        self.play(Write(text17), run_time=4)\n        self.wait(6)\n        self.play(Write(text18))\n        self.wait(3)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.set_camera_orientation(0.7 * np.pi / 2, 0.25 * np.pi)\n        self.play(ShowCreation(axes2))\n        self.play(ShowCreation(Paraboloide2().set_shade_in_3d(True)))\n        self.add_fixed_in_frame_mobjects(gpo19)\n        self.play(Write(gpo19))\n        self.wait(5)\n        self.add_fixed_in_frame_mobjects(text20_1)\n        self.play(Write(text20_1))\n        self.wait(2)\n        self.play(FadeOut(text20_1))\n        self.add_fixed_in_frame_mobjects(text20_2)\n        self.play(Write(text20_2))\n        self.wait(2)\n        self.play(FadeOut(text20_2))\n        self.add_fixed_in_frame_mobjects(text21)\n        self.play(Write(text21), run_time=3)\n        self.wait(5)\n        self.play(FadeOut(text21))\n        self.add_fixed_in_frame_mobjects(text22)\n        self.play(Write(text22))\n        self.wait()\n        self.play(Uncreate(recorrido_a_1), run_time=3)\n        self.play(ShowCreation(recorrido_a_2), run_time=0)\n        self.play(FadeOut(text22))\n        self.add_fixed_in_frame_mobjects(text23)\n        self.play(Write(text23), run_time=3)\n        self.wait(5)\n        self.play(FadeOut(text23))\n        self.add_fixed_in_frame_mobjects(text24)\n        self.play(Write(text24))\n        self.play(ShowCreation(recorrido_b), run_time=3)\n        self.wait(5)\n        self.play(FadeOut(text24))\n        self.add_fixed_in_frame_mobjects(text25)\n        self.play(Write(text25), run_time=3)\n        self.wait(5)\n        self.play(FadeOut(text25))\n        self.add_fixed_in_frame_mobjects(text26)\n        self.play(Write(text26))\n        self.wait(6)\n        self.play(FadeOut(text26))\n        self.add_fixed_in_frame_mobjects(text27)\n        self.play(Write(text27), run_time=3)\n        self.wait(8)\n        self.play(FadeOut(text27))\n        self.wait()\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n\n    def construct(self):\n        title = TextMobject('Plano tangente y\\n\\n                            derivadas direccionales').scale(1.5)\n        self.play(Write(title))\n        self.wait(2)\n        self.play(FadeOut(title))\n        self.parte1()\n        self.parte2()\n        self.parte3()"}]}
{"messages": [{"role": "user", "content": "Visualize the scalar multiplication property of vectors (k+j)x = kx + jx."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Distribucion_Suma_Escalares(Scene):\n\n    def construct(self):\n        grid = NumberPlane()\n        k = float(input('dame a k entre 0 y 1 \\n'))\n        j = float(input('dame a j entre 0 y 1 \\n'))\n        x = Arrow((0, 0, 0), (2, -1, 0), buff=0)\n        k_m_j_x = Arrow((0, 0, 0), (k + j) * x.get_end(), buff=0)\n        kx = Arrow((0, 0, 0), k * x.get_end(), buff=0)\n        jx = Arrow((0, 0, 0), j * x.get_end(), buff=0)\n        kx_m_jx = Arrow((0, 0, 0), kx.get_end() + jx.get_end(), buff=0)\n        prop = TextMobject('Distribuir el producto de suma de escalares con un vector.')\n        k_m_j_x_t = TexMobject('(k+j)\\\\vec{x}')\n        kx_m_jx_t = TexMobject('k\\\\vec{x}+j\\\\vec{x}')\n        kx_t = TexMobject('k\\\\vec{x}')\n        jx_t = TexMobject('j\\\\vec{x}')\n        t_1 = TextMobject(\"Nota que esta propiedad es encontrar \\n\\n                                de vuelta otros caminitos para \\n\\n                                llegar a un mismo vector dentro del \\n\\n                                espacio vectorial, s\\\\'{o}lo que a diferencia \\n\\n                                de las propiedades dados 3 vectores \\n\\n                                ahora usamos un solo vector y dos escalares, \\n\\n                                estamos haciendo como un ``escalamiento'' de caminos. \")\n        t_2 = TextMobject(\"Se te ocurre c\\\\'{o}mo realizar la animaci\\\\'{o}n para la propiedad:\\n                                $$k(\\\\vec{x}+\\\\vec{y}) = k\\\\vec{x}+k\\\\vec{y}, \\\\ k\\\\in \\\\mathbb{R}$$\")\n        t_3 = TextMobject(\" Checa la parte inmediata despu\\\\'{e}s \\n\\n                                 de la clase de \\n\\n                                 \\\\textit{distribucion$\\\\_$suma$\\\\_$escalares} \\n\\n                                 en el archivo de animaciones para\\n\\n                                 espacios vectoriales \\n\\n                                 para una idea de como realizar dicha animaci\\\\'{o}n.\")\n        gpo_1 = VGroup(k_m_j_x, k_m_j_x_t)\n        gpo_2 = VGroup(kx_m_jx, kx_m_jx_t)\n        gpo_3 = VGroup(kx, kx_t)\n        gpo_4 = VGroup(jx, jx_t)\n        prop.move_to((0, 2.5, 0)).set_color(GREEN)\n        gpo_3.set_color(YELLOW_E)\n        gpo_2.set_color(GREEN_C)\n        t_2.set_color(YELLOW_E)\n        jx.set_color(BLUE_D)\n        jx_t.set_color(BLUE_A)\n        k_m_j_x_t.next_to(k_m_j_x.get_end(), RIGHT)\n        kx_m_jx_t.next_to(kx_m_jx.get_end(), RIGHT)\n        kx_t.next_to(kx.get_end(), RIGHT)\n        jx_t.next_to(kx.get_end(), RIGHT)\n        prop.bg = SurroundingRectangle(prop, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group11 = VGroup(prop.bg, prop)\n        self.play(Write(grid), Write(Group11))\n        self.wait()\n        self.play(Write(gpo_1))\n        self.wait()\n        self.play(FadeOut(gpo_1))\n        self.play(Write(gpo_3))\n        self.wait()\n        self.play(FadeOut(kx_t))\n        self.play(Write(gpo_4))\n        self.wait()\n        self.play(FadeOut(kx))\n        self.play(FadeOut(gpo_4))\n        self.play(Write(gpo_2))\n        self.wait()\n        self.play(FadeOut(gpo_2), FadeOut(grid), FadeOut(Group11))\n        self.wait(1.5)\n        self.play(Write(t_1))\n        self.wait(12)\n        self.play(FadeOut(t_1))\n        self.wait()\n        self.play(Write(t_2))\n        self.wait(7)\n        self.play(FadeOut(t_2))\n        self.wait()\n        self.play(Write(t_3))\n        self.wait(4)"}]}
{"messages": [{"role": "user", "content": "Illustrate vector addition and scalar multiplication with visual examples and explanatory text."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Opera(Scene):\n\n    def construct(self):\n        plano = NumberPlane()\n        vec1 = Vector(direction=a, color=RED)\n        vec1_name = TexMobject('a')\n        vec1_name.next_to(vec1.get_corner(RIGHT + UP), RIGHT)\n        vec2 = Vector(direction=b, color=GOLD_E)\n        vec2_name = TexMobject('b')\n        vec2_name.next_to(vec2.get_corner(LEFT + UP), LEFT)\n        vecsum = Vector(direction=a + b, color=GREEN_SCREEN)\n        vecsum_name = TexMobject('a+b').set_color(GREEN_SCREEN)\n        vecsum_name.next_to(vecsum, LEFT)\n        suma1 = TextMobject('Podemos ver la suma de dos')\n        suma2 = TextMobject('vectores con flechas')\n        suma2.next_to(suma1, DOWN)\n        suma = VGroup(suma1, suma2)\n        suma.scale(0.75)\n        suma.bg = SurroundingRectangle(suma, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group11 = VGroup(suma.bg, suma)\n        vecesc = Vector(direction=c * a, color=RED)\n        vecesc_name = TexMobject(str(c) + 'a')\n        vecesc_name.next_to(vecesc, DOWN)\n        esc1 = TextMobject(\"Tambi\\\\'{e}n podemos multiplicar\")\n        esc2 = TextMobject('vectores por un escalar del campo')\n        esc2.next_to(esc1, DOWN)\n        esc = VGroup(esc1, esc2)\n        esc.scale(0.75)\n        valor = TexMobject('\\\\text{En este caso el escalar es}' + str(c))\n        valor.scale(0.75)\n        valor.move_to(text_pos)\n        esc.bg = SurroundingRectangle(esc, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group12 = VGroup(esc.bg, esc)\n        valor.bg = SurroundingRectangle(valor, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group13 = VGroup(valor.bg, valor)\n        ejem = TextMobject('Puedes modificar los vectores y el escalar para probar tus propios ejemplos,').scale(0.75)\n        ejem2 = TextMobject(\"encontrar\\\\'{a}s m\\\\'{a}s informaci\\\\'{o}n en el c\\\\'{o}digo de este video.\").scale(0.75)\n        ejem2.next_to(ejem, DOWN)\n        self.play(FadeIn(Group11))\n        self.play(ApplyMethod(Group11.move_to, text_pos))\n        self.play(ShowCreation(plano))\n        self.play(ShowCreation(vec1), ShowCreation(vec2), Write(vec1_name), Write(vec2_name))\n        self.wait()\n        self.play(ApplyMethod(vec2.move_to, a + b / 2), ApplyMethod(vec2_name.move_to, a + b / 2))\n        self.wait()\n        self.play(ShowCreation(vecsum), Write(vecsum_name))\n        self.wait()\n        self.play(FadeOut(vec1), FadeOut(vec2), FadeOut(vecsum), FadeOut(plano), FadeOut(Group11), FadeOut(vec1_name), FadeOut(vec2_name), FadeOut(vecsum_name))\n        self.play(Write(Group12))\n        self.play(ApplyMethod(Group12.move_to, text_pos))\n        self.play(ShowCreation(plano))\n        self.play(ShowCreation(vec1), Write(vec1_name))\n        self.wait()\n        self.play(ReplacementTransform(Group12, Group13))\n        self.play(ReplacementTransform(vec1, vecesc), ReplacementTransform(vec1_name, vecesc_name))\n        self.wait(2)\n        self.play(FadeOut(plano), FadeOut(vecesc_name), FadeOut(Group13), FadeOut(vecesc))\n        self.play(Write(ejem), Write(ejem2))\n        self.wait(3)\n        self.play(FadeOut(ejem), FadeOut(ejem2))"}]}
{"messages": [{"role": "user", "content": "Illustrate vector addition associativity by showing two different paths to the same resultant vector."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Asociatividad(Scene):\n\n    def construct(self):\n        grid = ScreenGrid()\n        x = Arrow((0, 0, 0), (3, 2, 0), buff=0)\n        y = Arrow((0, 0, 0), (1, 2, 0), buff=0)\n        z = Arrow((0, 0, 0), (1, -2, 0), buff=0)\n        y_mov_a_x = Arrow(x.get_end(), x.get_end() + y.get_end(), buff=0)\n        x_mas_y = Arrow((0, 0, 0), y_mov_a_x.get_end(), buff=0)\n        z_mov_a_x_mas_y = Arrow(x_mas_y.get_end(), x_mas_y.get_end() + z.get_end(), buff=0)\n        x_mas_y_mas_z = Arrow((0, 0, 0), z_mov_a_x_mas_y.get_end(), buff=0)\n        z_mov_a_y = Arrow(y.get_end(), y.get_end() + z.get_end(), buff=0)\n        y_mas_z = Arrow((0, 0, 0), z_mov_a_y.get_end(), buff=0)\n        y_mas_z_mov_a_x = Arrow(x.get_end(), x.get_end() + y_mas_z.get_end(), buff=0)\n        x_mas_y_mas_z_1 = Arrow((0, 0, 0), y_mas_z_mov_a_x.get_end(), buff=0)\n        t_1 = TextMobject(' Segunda propiedad: \\n\\n                              Asociatividad. ')\n        t_2 = TextMobject(' Hagamos: $(\\\\vec{x}+\\\\vec{y})+\\\\vec{z}$ ')\n        t_3 = TextMobject(' Hagamos: $\\\\vec{x}+(\\\\vec{y}+\\\\vec{z})$ ')\n        t_4 = TextMobject('$(\\\\vec{x}+\\\\vec{y})$')\n        t_5 = TextMobject('$(\\\\vec{x}+\\\\vec{y})+\\\\vec{z}$')\n        t_6 = TextMobject('$(\\\\vec{y}+\\\\vec{z})$')\n        t_7 = TextMobject('$\\\\vec{x}+(\\\\vec{y}+\\\\vec{z})$')\n        t_8 = TextMobject('$\\\\vec{x}$')\n        t_9 = TextMobject('$\\\\vec{y}$')\n        t_10 = TextMobject('$\\\\vec{z}$')\n        t_11 = TextMobject('Nota como es casi lo misma idea geom\u00e9trica \\n\\n                              que el hecho de hacer la conmutaci\u00f3n, es tomar \\n\\n                              distintos caminos para llegar al mismo vector \\n\\n                              en el espacio vectorial; dados tres vectores distintos.')\n        gpo_1 = VGroup(x, t_8)\n        gpo_2 = VGroup(y, t_9)\n        gpo_3 = VGroup(z, t_10)\n        gpo_4 = VGroup(x_mas_y, t_4)\n        gpo_5 = VGroup(x_mas_y_mas_z, t_5)\n        gpo_6 = VGroup(y_mas_z, t_6)\n        gpo_7 = VGroup(x_mas_y_mas_z_1, t_7)\n        t_11.move_to((0, -2, 0)).scale(0.85)\n        t_1.move_to((-3, 3, 0)).set_color(GREEN)\n        t_2.next_to(t_1, DOWN)\n        t_3.next_to(t_2, DOWN)\n        t_4.next_to(x_mas_y.get_center(), UP + LEFT)\n        t_5.next_to(x_mas_y_mas_z.get_center(), DOWN + RIGHT)\n        t_6.next_to(y_mas_z.get_center(), DOWN)\n        t_7.next_to(x_mas_y_mas_z_1.get_center(), DOWN * 2)\n        t_8.next_to(x.get_end(), UP)\n        t_9.next_to(y.get_end(), DOWN)\n        t_10.next_to(z.get_end(), DOWN)\n        gpo_4.set_color(ORANGE)\n        gpo_5.set_color(RED)\n        gpo_7.set_color(PURPLE)\n        gpo_2_1 = gpo_2.copy()\n        gpo_3_1 = gpo_3.copy()\n        t_1.bg = SurroundingRectangle(t_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group11 = VGroup(t_1.bg, t_1)\n        t_2.bg = SurroundingRectangle(t_2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group12 = VGroup(t_2.bg, t_2)\n        t_3.bg = SurroundingRectangle(t_3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group13 = VGroup(t_3.bg, t_3)\n        t_11.bg = SurroundingRectangle(t_11, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group111 = VGroup(t_11.bg, t_11)\n        self.play(Write(grid))\n        self.wait()\n        self.play(Write(Group11))\n        self.wait(2)\n        self.play(FadeOut(Group11))\n        self.play(Write(gpo_1), Write(gpo_2), Write(gpo_3))\n        self.wait()\n        self.play(Write(Group12))\n        self.wait()\n        self.play(ReplacementTransform(gpo_2, y_mov_a_x))\n        self.wait()\n        self.play(Write(gpo_4))\n        self.wait()\n        self.play(ReplacementTransform(gpo_3, z_mov_a_x_mas_y), FadeOut(gpo_1), FadeOut(y_mov_a_x))\n        self.wait()\n        self.play(Write(gpo_5))\n        self.wait()\n        self.play(FadeOut(gpo_4), FadeOut(z_mov_a_x_mas_y), FadeOut(y_mov_a_x), FadeOut(gpo_5), Write(gpo_2_1), Write(gpo_1), Write(gpo_3_1))\n        self.wait()\n        self.play(Write(Group13))\n        self.wait()\n        self.play(ReplacementTransform(gpo_3_1, z_mov_a_y))\n        self.wait()\n        self.play(Write(gpo_6))\n        self.wait()\n        self.play(ReplacementTransform(gpo_6, y_mas_z_mov_a_x), FadeOut(gpo_2_1), FadeOut(z_mov_a_y))\n        self.wait()\n        self.play(Write(gpo_7))\n        self.wait()\n        self.play(Write(Group111))\n        self.wait(6)\n        self.play(FadeOut(Group111), FadeOut(Group12), FadeOut(Group13))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of vector bases by showing the standard basis and then an alternative basis for the same vector."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Bases(Scene):\n\n    def construct(self):\n        grid = NumberPlane()\n        t_1 = TextMobject('Idea intuitiva de lo que significa una base.')\n        t_2 = TextMobject('Pensemos en el plano cartesiano...')\n        t_3 = TextMobject('y en la base usual...')\n        t_4 = TextMobject(\"la can\\\\'{o}nica.\")\n        t_5 = TexMobject('\\\\xi = \\\\{ \\\\vec{e}_1, \\\\vec{e}_2 \\\\} = \\\\{ (1,0), (0,1) \\\\}')\n        t_6 = TextMobject('Supongamos que queremos \"caracterizar\" \\n\\n                             el vector $\\\\vec{x} = (1,2)$, con la base $\\\\xi$.')\n        t_7 = TextMobject('Es claro que: \\n\\n                             $\\\\vec{x} = 1\\\\cdot(1,0)+2\\\\cdot(0,1) = (1,2)$')\n        t_8 = TextMobject(\"Que geom\\\\'{e}tricamente es...\")\n        t_9 = TextMobject('Solamente caminar una vez por el camino fijado \\n\\n                             por el vector $\\\\vec{e}_1=(1,0)$ y luego caminar dos  \\n\\n                             veces por el camino fijado por $\\\\vec{e}_2=(0,1)$.')\n        t_9.move_to((0, -1.3, 0))\n        t_10 = TextMobject('Ahora supongamos que tenemos la base: \\n\\n                              $\\\\gamma = \\\\{ (2,1),(1,-1) \\\\}$')\n        t_11 = TextMobject('Sabemos que... \\n\\n                              $\\\\vec{x} = 1\\\\cdot(2,1)+(-1)\\\\cdot(1,-1)$')\n        t_12 = TextMobject(\"\u00bfPero geom\\\\'{e}tricamente qu\\\\'{e} es esta combinaci\\\\'{o}n lineal?\")\n        t_13 = TextMobject('\u00a1Claro! Solamente es tomar un camino distinto \\n\\n                              dado por esta base \\n\\n                              para llegar al mismo vector $\\\\vec{x}$ \\n\\n                              en el espacio vectorial $\\\\mathbb{R}^2$.')\n        e_1 = Arrow((0, 0, 0), (1, 0, 0), buff=0)\n        e_2 = Arrow((0, 0, 0), (0, 1, 0), buff=0)\n        e_2_mov_e_1 = Arrow(e_1.get_end(), (1, 2, 0), buff=0)\n        v_1 = Arrow((0, 0, 0), (2, 1, 0), buff=0)\n        v_2 = Arrow((0, 0, 0), (1, -1, 0), buff=0)\n        v_1_mov_v_1 = Arrow(v_1.get_end(), (1, 2, 0), buff=0)\n        e_1.set_color(YELLOW_E)\n        e_2.set_color(YELLOW_E)\n        e_2_mov_e_1.set_color(YELLOW_E)\n        t_5.set_color(YELLOW_E)\n        t_7.set_color(BLUE)\n        t_9.set_color(YELLOW_E)\n        t_10.set_color(YELLOW_E)\n        t_9.bg = SurroundingRectangle(t_9, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group19 = VGroup(t_9.bg, t_9)\n        self.play(Write(t_1))\n        self.wait()\n        self.play(ReplacementTransform(t_1, t_2))\n        self.wait(2)\n        self.play(ReplacementTransform(t_2, t_3))\n        self.wait()\n        self.play(ReplacementTransform(t_3, t_4))\n        self.wait()\n        self.play(ReplacementTransform(t_4, t_5))\n        self.wait(3)\n        self.play(ReplacementTransform(t_5, t_6))\n        self.wait(4)\n        self.play(ReplacementTransform(t_6, t_7))\n        self.wait(4)\n        self.play(ReplacementTransform(t_7, t_8))\n        self.wait()\n        self.play(FadeOut(t_8), Write(grid))\n        self.wait()\n        self.play(Write(e_1), Write(e_2))\n        self.wait()\n        self.play(ReplacementTransform(e_2, e_2_mov_e_1), Write(Group19))\n        self.wait(4)\n        self.play(FadeOut(e_2_mov_e_1), FadeOut(grid), FadeOut(Group19), FadeOut(e_1), Write(t_10))\n        self.wait(3)\n        self.play(ReplacementTransform(t_10, t_11))\n        self.wait(3)\n        self.play(ReplacementTransform(t_11, t_12))\n        self.wait(2)\n        self.play(FadeOut(t_12), Write(grid))\n        self.wait()\n        self.play(Write(v_1), Write(v_2))\n        self.wait()\n        self.play(ReplacementTransform(v_2, v_1_mov_v_1))\n        self.wait()\n        self.play(ReplacementTransform(VGroup(v_1_mov_v_1, grid, v_1), t_13))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of the additive inverse for a 2D vector by showing its negation, projections, and related explanations."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Inverso_Aditivo(Scene):\n\n    def construct(self):\n        grid = NumberPlane()\n        x = Arrow((0, 0, 0), (1, 2, 0), buff=0)\n        menos_x = Arrow((0, 0, 0), -1 * x.get_end(), buff=0)\n        x_proy_y = Arrow((0, 0, 0), (0, -1 * x.get_end()[1], 0), buff=0)\n        x_proy_x = Arrow((0, 0, 0), (-1 * x.get_end()[0], 0, 0), buff=0)\n        mx_proy_y = Arrow((0, 0, 0), (0, x.get_end()[1], 0), buff=0)\n        mx_proy_x = Arrow((0, 0, 0), (x.get_end()[0], 0, 0), buff=0)\n        x_t = TextMobject('$\\\\vec{x} = (x_1,x_2)$')\n        xpy_t = TextMobject('$Proj_{(0,1)}(-\\\\vec{x}) = (-x_1,0)$')\n        xpx_t = TextMobject('$Proj_{(1,0)}(-\\\\vec{x}) = (0,-x_2)$')\n        menosx_t = TextMobject('$-\\\\vec{x} = (-x_1,-x_2)$')\n        prop = TextMobject('Inverso Aditivo.')\n        t_1 = TextMobject('Para el vector $\\\\vec{x}$ \\n\\n                             existe el vector $-\\\\vec{x}$ \\n\\n                             tal que hace: \\n\\n                             $\\\\vec{x}+(-\\\\vec{x}) = \\\\vec{0}$.')\n        t_2 = TextMobject(' Que notemos \\n \\n                              que geom\\\\\\'{e}tricamente:\\n\\n                              hay que \"voltear\" \\n\\n                              respecto al origen \\n\\n                              al vector $\\\\vec{x}$.')\n        t_0 = TextMobject(\" fij\\\\'{e}monos en el siguiente vector \\n\\n                             y sus componentes. \")\n        t_2.bg = SurroundingRectangle(t_2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group14 = VGroup(t_2.bg, t_2)\n        gpo_x = VGroup(x, x_t)\n        gpo_menos_x = VGroup(menos_x, menosx_t)\n        gpo_text_proy = VGroup(xpy_t, xpx_t)\n        gpo_x_proy_y = VGroup(x_proy_y, xpy_t)\n        gpo_x_proy_x = VGroup(x_proy_x, xpx_t)\n        gpo_x_proy = VGroup(mx_proy_y, mx_proy_x)\n        mgpo_x_proy = VGroup(x_proy_y, x_proy_x)\n        gpo_Fade = VGroup(gpo_text_proy, mgpo_x_proy, Group14)\n        xpy_t.set_color(YELLOW_D)\n        xpx_t.set_color(YELLOW_D)\n        x_proy_y.set_color(YELLOW_E)\n        x_proy_x.set_color(YELLOW_E)\n        mx_proy_y.set_color(YELLOW_E)\n        mx_proy_x.set_color(YELLOW_E)\n        prop.move_to((-3, 2.5, 0))\n        prop.set_color(GREEN)\n        t_0.move_to((-3, 2.5, 0))\n        t_0.set_color(GREEN)\n        x_t.next_to(x.get_end(), RIGHT, buff=0.4)\n        menosx_t.next_to(menos_x.get_end(), DOWN)\n        xpy_t.next_to(x_proy_y.get_end(), RIGHT)\n        xpx_t.next_to(x_proy_x.get_end(), UP)\n        t_1.move_to((4, -0.5, 0)).scale(0.8)\n        Group14.move_to((-4, -0.75, 0)).scale(0.8)\n        prop.bg = SurroundingRectangle(prop, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group11 = VGroup(prop.bg, prop)\n        t_0.bg = SurroundingRectangle(t_0, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group12 = VGroup(t_0.bg, t_0)\n        t_1.bg = SurroundingRectangle(t_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group13 = VGroup(t_1.bg, t_1)\n        self.play(Write(Group11), Write(grid))\n        self.wait(0.5)\n        self.play(FadeOut(Group11))\n        self.play(Write(Group12))\n        self.wait(1.3)\n        self.play(Write(gpo_x))\n        self.play(FadeOut(Group12))\n        self.play(Write(gpo_x_proy))\n        self.wait(1.3)\n        self.play(FadeOut(gpo_x))\n        self.play(Write(mgpo_x_proy))\n        self.play(FadeOut(gpo_x_proy))\n        self.play(Write(gpo_text_proy))\n        self.wait()\n        self.play(Write(Group13))\n        self.wait(2.5)\n        self.play(Write(Group14), Write(gpo_menos_x), FadeOut(Group13))\n        self.wait(2.5)\n        self.play(FadeOut(gpo_Fade))\n        self.play(Write(gpo_x))"}]}
{"messages": [{"role": "user", "content": "Explain the concept of a metric in mathematics by animating its definition and properties, including distance between vectors and the triangle inequality."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Metrica(Scene):\n\n    def construct(self):\n        dist = TextMobject(\"La m\\\\'{e}trica es un concepto relacionado con la distancia\").scale(1)\n        aux1 = TexMobject('\\\\text{Auxiliados del concepto de norma, definimos la distancia}').to_edge(UP).shift(DOWN)\n        aux2 = TexMobject('\\\\text{entre dos vectores}\\\\ \\\\vec{x},\\\\ \\\\vec{y}\\\\ \\\\text{como}:').next_to(aux1, DOWN)\n        aux = VGroup(aux1, aux2)\n        defdist = TexMobject('d(\\\\vec{x},\\\\vec{y}):=\\\\Vert \\\\vec{x} - \\\\vec{y}\\\\Vert').scale(1.2)\n        tprops1 = TextMobject('Una distancia se conoce como \"m\\\\\\'{e}trica\"')\n        tprops2 = TextMobject(' si satisface las siguientes propiedades:').next_to(tprops1, DOWN)\n        tprops = VGroup(tprops1, tprops2)\n        self.play(Write(dist))\n        self.wait(1.5)\n        self.play(FadeOut(dist))\n        self.play(Write(aux))\n        self.wait(3.3)\n        self.play(ReplacementTransform(aux, defdist))\n        self.wait(4.8)\n        self.play(FadeOut(defdist))\n        self.play(Write(tprops))\n        self.wait(2.7)\n        self.play(FadeOut(tprops))\n        distprop1 = TexMobject('d(\\\\vec{x},\\\\vec{y}) \\\\geq 0\\\\  \\\\text{y}\\\\ d(\\\\vec{x},\\\\vec{y}) = 0 \\\\Leftrightarrow \\\\vec{x} = \\\\vec{y}').shift(3 * DOWN)\n        xdot = Dot((2, 1, 0), color=RED, radius=0.12)\n        xdot_label = TexMobject('\\\\vec{x}').next_to(xdot, RIGHT)\n        gxdot = VGroup(xdot, xdot_label)\n        ydot = Dot((-2, -1, 0), color=BLUE, radius=0.12)\n        ydot_label = TexMobject('\\\\vec{y}').next_to(ydot, LEFT)\n        gydot = VGroup(ydot, ydot_label)\n        arrow1 = DoubleArrow(xdot.get_center(), ydot.get_center())\n        arrow1_label = TexMobject('d(\\\\vec{x},\\\\vec{y})').next_to(arrow1.get_center(), DOWN + RIGHT)\n        dmayor = TexMobject('d(\\\\vec{x},\\\\vec{y})> 0').shift(3 * UP)\n        garrow1 = VGroup(arrow1, arrow1_label)\n        cerodot = Dot((0, 0, 0), color=PURPLE, radius=0.12)\n        cerodot_label = TexMobject('\\\\vec{x}=\\\\vec{y}').next_to(cerodot, DOWN)\n        gcerodot = VGroup(cerodot, cerodot_label)\n        ceroarrow = DoubleArrow((0, 0, 0), (0, 0, 0))\n        dcero = TexMobject('d(\\\\vec{x},\\\\vec{y}) = 0').shift(3 * UP)\n        self.play(Write(distprop1))\n        self.wait(4.5)\n        self.play(ShowCreation(gxdot), ShowCreation(gydot))\n        self.wait(1)\n        self.play(GrowArrow(arrow1), Write(dmayor))\n        self.wait(1.8)\n        self.play(ReplacementTransform(gxdot, gcerodot), ReplacementTransform(ydot, cerodot), Transform(arrow1, ceroarrow), FadeOut(ydot_label), ReplacementTransform(dmayor, dcero), runtime=2.3)\n        self.wait()\n        self.play(FadeOut(gcerodot), FadeOut(dcero))\n        self.play(distprop1.shift, 3 * UP)\n        self.wait(1.65)\n        self.play(FadeOut(distprop1))\n        distprop2 = TexMobject('d(\\\\vec{x},\\\\vec{y}) = d(\\\\vec{y},\\\\vec{x})').shift(3 * DOWN)\n        adot = Dot(posa, color=RED, radius=0.12)\n        adot_label = TexMobject('\\\\vec{x}').next_to(adot, DOWN)\n        gadot = VGroup(adot, adot_label)\n        bdot = Dot(posb, color=BLUE, radius=0.12)\n        bdot_label = TexMobject('\\\\vec{y}').next_to(bdot, DOWN)\n        gbdot = VGroup(bdot, bdot_label)\n        ab_arrow = Arrow(adot.get_center(), bdot.get_center())\n        ab_arrow_lb = TexMobject('d(\\\\vec{x},\\\\vec{y}) = ' + str(distab)).next_to(ab_arrow, 3 * UP)\n        ba_arrow = Arrow(bdot.get_center(), adot.get_center())\n        ba_arrow_lb = TexMobject('d(\\\\vec{y},\\\\vec{x})= ' + str(distba)).move_to(ab_arrow_lb)\n        self.play(Write(distprop2))\n        self.wait(1.3)\n        self.play(ShowCreation(gadot), ShowCreation(gbdot), runtime=1.35)\n        self.play(GrowArrow(ab_arrow), Write(ab_arrow_lb))\n        self.wait(2)\n        self.play(ReplacementTransform(ab_arrow, ba_arrow), Transform(ab_arrow_lb, ba_arrow_lb))\n        self.wait(2)\n        self.play(FadeOut(gadot), FadeOut(gbdot), FadeOut(ba_arrow), FadeOut(ab_arrow_lb))\n        self.play(distprop2.shift, 3 * UP, runtime=1)\n        self.wait(2)\n        self.play(FadeOut(distprop2))\n        TRI = TextMobject(\"Ahora, la desigualdad del tri\\\\'{a}ngulo\")\n        distprop3 = TexMobject('d(\\\\vec{x},\\\\vec{y}) \\\\leq d(\\\\vec{x},\\\\vec{z})+d(\\\\vec{z},\\\\vec{y})').shift(3 * DOWN)\n        newxdot = Dot(posx, color=RED, radius=0.12)\n        newxdot_label = TexMobject('\\\\vec{x}').next_to(newxdot, DOWN)\n        gnewxdot = VGroup(newxdot, newxdot_label)\n        newydot = Dot(posy, color=BLUE, radius=0.12)\n        newydot_label = TexMobject('\\\\vec{y}').next_to(newydot, DOWN)\n        gnewydot = VGroup(newydot, newydot_label)\n        zdot = Dot(posz, color=YELLOW, radius=0.12)\n        zdot_label = TexMobject('\\\\vec{z}').next_to(zdot, UP)\n        gzdot = VGroup(zdot, zdot_label)\n        narrow1 = DoubleArrow(newxdot.get_center(), newydot.get_center(), stroke_width=4)\n        narrow1_label = TexMobject('d(\\\\vec{x},\\\\vec{y})').next_to(narrow1.get_center(), DOWN + RIGHT)\n        arrow2 = DoubleArrow(newxdot.get_center(), zdot.get_center(), stroke_width=4)\n        arrow2_label = TexMobject('d(\\\\vec{x},\\\\vec{z})').next_to(arrow2.get_center(), UP)\n        garrow2 = VGroup(arrow2, arrow2_label)\n        arrow3 = DoubleArrow(newydot.get_center(), zdot.get_center(), stroke_width=4)\n        arrow3_label = TexMobject('d(\\\\vec{z},\\\\vec{y})').next_to(arrow3.get_center(), 2 * LEFT)\n        garrow3 = VGroup(arrow3, arrow3_label)\n        tdxz = DoubleArrow((0, 0, 0), (dxz, 0, 0), color=RED).shift(2.5 * LEFT + UP)\n        tdzy = DoubleArrow((0, 0, 0), (dzy, 0, 0), color=BLUE).shift(2.5 * LEFT + UP + (dxz * 0.9, 0, 0))\n        tdxy = DoubleArrow((0, 0, 0), (dxy, 0, 0), color=YELLOW).shift(2.5 * LEFT)\n        brace1 = Brace(tdxz, UP)\n        brace2 = Brace(tdzy, UP)\n        bracesum = Brace(tdxy, DOWN)\n        ldxz = TexMobject('d(\\\\vec{x},\\\\vec{z})').next_to(brace1.get_center(), UP)\n        ldzy = TexMobject('d(\\\\vec{z},\\\\vec{y})').next_to(brace2.get_center(), UP)\n        ldxy = TexMobject('d(\\\\vec{x},\\\\vec{y})').next_to(bracesum.get_center(), DOWN)\n        braces = VGroup(brace1, brace2, bracesum)\n        dists = VGroup(ldxz, ldzy, ldxy)\n        laigualdad = TextMobject(\"(La igualdad se da si y s\\\\'{o}lo si los tres puntos son colineales)\").shift(DOWN).scale(0.8)\n        i_1 = TextMobject(\"Este concepto te\\\\'{o}rico nos permite\")\n        i_2 = TextMobject(\"definir m\\\\'{e}tricas en espacios m\\\\'{a}s abstractos\").next_to(i_1, DOWN)\n        revisa = TextMobject(\"Edita el c\\\\'{o}digo para visualizar con m\\\\'{a}s vectores\")\n        Group = VGroup(i_1, i_2)\n        self.play(Write(TRI), runtime=1.2)\n        self.play(FadeOut(TRI))\n        self.play(Write(distprop3))\n        self.wait(3.7)\n        self.play(ShowCreation(gnewxdot), ShowCreation(gnewydot), ShowCreation(gzdot))\n        self.wait()\n        self.play(GrowArrow(arrow2), GrowArrow(arrow3))\n        self.play(Write(arrow2_label), Write(arrow3_label))\n        self.wait()\n        self.play(GrowArrow(narrow1))\n        self.play(Write(narrow1_label))\n        self.wait()\n        arrow2.set_color(RED)\n        arrow3.set_color(BLUE)\n        narrow1.set_color(YELLOW)\n        self.wait(2)\n        self.play(FadeOut(gnewxdot), FadeOut(gnewydot), FadeOut(gzdot))\n        self.play(FadeOut(narrow1_label), FadeOut(arrow2_label), FadeOut(arrow3_label))\n        self.play(ReplacementTransform(narrow1, tdxy), ReplacementTransform(arrow2, tdxz), ReplacementTransform(arrow3, tdzy))\n        self.play(ShowCreation(braces), ShowCreation(dists))\n        self.wait(5)\n        self.play(FadeOut(dists), FadeOut(braces), FadeOut(tdxy), FadeOut(tdxz), FadeOut(tdzy))\n        self.play(distprop3.shift, 3 * UP, runtime=1)\n        self.play(Write(laigualdad))\n        self.wait(4)\n        self.play(FadeOut(laigualdad), FadeOut(distprop3))\n        self.wait()\n        self.play(Write(Group))\n        self.wait(2)\n        self.play(ReplacementTransform(Group, revisa))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize vector addition commutativity by showing $\\vec{x} + \\vec{y}$ and $\\vec{y} + \\vec{x}$ with accompanying text and arrows."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Conmutatividad(Scene):\n\n    def construct(self):\n        grid = ScreenGrid()\n        v_x = Arrow((0, 0, 0), 2 * RIGHT + UP, buff=0)\n        v_y = Arrow((0, 0, 0), RIGHT - 2 * UP, buff=0)\n        v_z = Arrow((0, 0, 0), LEFT + 0.5 * UP, buff=0)\n        suma_t_1 = TextMobject('Sumemos el vector:' + ' $\\\\vec{x}+\\\\vec{y}$')\n        suma_t_2 = TextMobject('Sumemos el vector:' + ' $\\\\vec{y}+\\\\vec{x}$')\n        prop_1 = TextMobject('Observemos la primera propiedad: \\n \\n                                la conmutatividad.')\n        prop_1.set_color(GREEN).move_to((-3, 3, 0))\n        suma_t_1.move_to((-3, 2, 0))\n        suma_t_1[0][16:18].set_color(RED)\n        suma_t_1[0][19:].set_color(ORANGE)\n        suma_t_2.move_to((-3, 1, 0))\n        suma_t_2[0][19:].set_color(RED)\n        suma_t_2[0][16:18].set_color(ORANGE)\n        v_x_t = TextMobject('$\\\\vec{x}$')\n        v_y_t = TextMobject('$\\\\vec{y}$')\n        v_z_t = TextMobject('$\\\\vec{z}$')\n        v_x_t.move_to(v_x.get_end() + RIGHT * 0.3)\n        v_y_t.next_to(v_y.get_end() + RIGHT * 0.1)\n        v_z_t.next_to(v_y.get_end() + RIGHT * 0.1)\n        gpo_x = VGroup(v_x, v_x_t)\n        gpo_y = VGroup(v_y, v_y_t)\n        gpo_z = VGroup(v_z, v_z_t)\n        gpo_x.set_color(RED)\n        gpo_y.set_color(ORANGE)\n        v_y_mov = Arrow(v_x.get_end(), v_x.get_end() + v_y.get_end(), buff=0)\n        v_y_mov_t = TextMobject('$\\\\vec{y}$')\n        v_y_mov_t.move_to(v_y_mov.get_end() + RIGHT * 0.3)\n        gpo_y_mov = VGroup(v_y_mov, v_y_mov_t)\n        v_x_mov = Arrow(v_y.get_end(), v_y.get_end() + v_x.get_end(), buff=0)\n        v_x_mov_t = TextMobject('$\\\\vec{x}$')\n        v_x_mov_t.move_to(v_x_mov.get_end() + RIGHT * 0.3)\n        gpo_x_mov = VGroup(v_x_mov, v_x_mov_t)\n        gpo_y_mov.set_color(ORANGE)\n        gpo_x_mov.set_color(RED)\n        v_x_mov = Arrow(v_x)\n        v_x_mov_t = TextMobject('$\\\\vec{x}$')\n        v_x_mov_t.move_to(v_x.get_end() + RIGHT * 0.3)\n        suma_x_y = Arrow((0, 0, 0), v_y_mov.get_end(), buff=0)\n        gpo_y_1 = gpo_y.copy()\n        Text_f = TextMobject(' Nota que en realidad lo que nos dice es que \\n\\n                                 no importa el camino que elijas, siempre llegas a ROMA \\n\\n                                 o en este caso, \\n\\n                                 el punto en el espacio vectorial. ')\n        Text_f.move_to((-3.3, -1.5, 0)).scale(0.56)\n        prop_1.bg = SurroundingRectangle(prop_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group11 = VGroup(prop_1.bg, prop_1)\n        suma_t_1.bg = SurroundingRectangle(suma_t_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group12 = VGroup(suma_t_1.bg, suma_t_1)\n        suma_t_2.bg = SurroundingRectangle(suma_t_2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group13 = VGroup(suma_t_2.bg, suma_t_2)\n        Text_f.bg = SurroundingRectangle(Text_f, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group14 = VGroup(Text_f.bg, Text_f)\n        self.play(Write(grid))\n        self.play(Write(Group11))\n        self.wait(2)\n        self.play(FadeOut(Group11))\n        self.wait()\n        self.play(Write(v_x), Write(v_y), Write(v_x_t), Write(v_y_t))\n        self.wait()\n        self.play(Write(Group12))\n        self.wait()\n        self.play(ReplacementTransform(gpo_y, gpo_y_mov))\n        self.wait()\n        self.play(Write(suma_x_y))\n        self.wait()\n        self.play(Write(Group13))\n        self.play(ReplacementTransform(gpo_y_mov, gpo_y_1), ReplacementTransform(gpo_x, gpo_x_mov))\n        self.wait()\n        self.play(Write(Group14))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present the definition and properties of vector norms with visual examples of vectors and their lengths."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Propiedades_Norma(Scene):\n\n    def construct(self):\n        titulo = TextMobject('La norma y sus propiedades').scale(1.2)\n        deftex = TexMobject('\\\\text{Se defini\u00f3 la norma euclidiana de un vector}\\\\ \\\\vec{x} \\\\in \\\\mathbb{R}^n\\\\ \\\\text{como}:').shift(2 * UP)\n        defn = TexMobject('\\\\Vert \\\\vec{x} \\\\Vert:= \\\\sqrt{x_1^2+x_2^2+x_3^2+...+x_n^2}')\n        longi = TextMobject('Esta cantidad representa la \"longitud\" de un vector').shift(2 * DOWN)\n        def2d = TexMobject('\\\\text{Consideremos el caso}\\\\ \\\\vec{x} \\\\in \\\\mathbb{R}^2').shift(2 * UP)\n        d2d = TexMobject('\\\\Vert \\\\vec{x} \\\\Vert := \\\\sqrt{x_1^2+x_2^2}')\n        vamo = TextMobject('Adelante veremos tres propiedades fundamentales').shift(2 * DOWN)\n        segslide = VGroup(def2d, d2d, vamo)\n        self.play(Write(titulo))\n        self.wait(1.2)\n        self.play(FadeOut(titulo))\n        self.play(Write(deftex), Write(defn), Write(longi))\n        self.wait(9)\n        self.play(ReplacementTransform(deftex, def2d), ReplacementTransform(defn, d2d), ReplacementTransform(longi, vamo))\n        self.wait(8)\n        self.play(FadeOut(segslide))\n        self.wait()\n        prop1 = TexMobject('\\\\Vert \\\\vec{x} \\\\Vert \\\\geq 0\\\\  \\\\forall \\\\vec{x} \\\\in \\\\mathbb{R}^2\\\\ \\\\text{y}\\\\ \\\\Vert \\\\vec{x} \\\\Vert = 0 \\\\Leftrightarrow \\\\vec{x}=\\\\vec{0}').to_edge(DOWN)\n        prop1.bg = SurroundingRectangle(prop1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group11 = VGroup(prop1.bg, prop1)\n        plano = NumberPlane()\n        vc1 = Vector(direction=v1, color=GREEN).move_to(np.array([-3, -2, 0]))\n        vc2 = Vector(direction=v2, color=PURPLE).move_to(np.array([-4, 1, 0]))\n        vc3 = Vector(direction=v3, color=YELLOW_E).move_to(np.array([4, --2, 0]))\n        vc4 = Vector(direction=v4, color=ORANGE).move_to(np.array([2, 0, 0]))\n        dot = Dot((0, 0, 0), color=WHITE, radius=0.15)\n        cdot = Dot((0, 0, 0), color=BLACK)\n        ddot = VGroup(dot, cdot)\n        vc1_l = TexMobject('\\\\vec{x}').next_to(vc1.get_center(), UP)\n        vc2_l = TexMobject('\\\\vec{y}').next_to(vc2.get_center(), UP)\n        vc3_l = TexMobject('\\\\vec{z}').next_to(vc3.get_center(), UP)\n        vc4_l = TexMobject('\\\\vec{w}').next_to(vc4.get_center(), UP)\n        zero_dot = TexMobject('\\\\vec{0}').next_to(dot.get_center(), UP + LEFT)\n        vcts = VGroup(vc1, vc2, vc3, vc4, ddot)\n        labels = VGroup(vc1_l, vc2_l, vc3_l, vc4_l, zero_dot)\n        normies = TextMobject('Veamos las normas de los vectores:').to_edge(UP)\n        vc1_n = Vector(direction=np.array([np.linalg.norm(v1), 0, 0]), color=GREEN).shift(4 * LEFT + 0.5 * UP)\n        vc2_n = Vector(direction=np.array([np.linalg.norm(v2), 0, 0]), color=PURPLE).shift(4 * LEFT)\n        vc3_n = Vector(direction=np.array([np.linalg.norm(v3), 0, 0]), color=YELLOW_E).shift(4 * LEFT + 0.5 * DOWN)\n        vc4_n = Vector(direction=np.array([np.linalg.norm(v4), 0, 0]), color=ORANGE).shift(4 * LEFT + DOWN)\n        bracv1 = Brace(vc1_n, UP)\n        normv1 = TexMobject('\\\\Vert \\\\vec{x} \\\\Vert =' + str(nv1)).next_to(bracv1, UP)\n        brac1 = VGroup(bracv1, normv1)\n        bracv2 = Brace(vc2_n, UP)\n        normv2 = TexMobject('\\\\Vert \\\\vec{y} \\\\Vert =' + str(nv2)).next_to(bracv2, UP)\n        brac2 = VGroup(bracv2, normv2)\n        bracv3 = Brace(vc3_n, UP)\n        normv3 = TexMobject('\\\\Vert \\\\vec{z} \\\\Vert =' + str(nv3)).next_to(bracv3, UP)\n        brac3 = VGroup(bracv3, normv3)\n        bracv4 = Brace(vc4_n, UP)\n        normv4 = TexMobject('\\\\Vert \\\\vec{w} \\\\Vert =' + str(nv4)).next_to(bracv4, UP)\n        brac4 = VGroup(bracv4, normv4)\n        normdot = TexMobject('\\\\Vert \\\\vec{0} \\\\Vert = 0').next_to(ddot, DOWN)\n        obse1 = TextMobject('Todos estos vectores tuvieron').shift(3 * LEFT + UP)\n        obse2 = TextMobject('una norma mayor a cero.').next_to(obse1, DOWN)\n        obse = VGroup(obse1, obse2)\n        obscero = TexMobject('\\\\text{Ahora para el vector}\\\\ \\\\vec{0}').to_edge(UP)\n        unico = TextMobject('\u00a1Es el \u00fanico cuya norma se anula!').shift(0.5 * UP)\n        self.add(plano)\n        self.play(ShowCreation(plano, runtime=2))\n        self.play(Write(Group11))\n        self.play(ShowCreation(vcts, runtime=2), Write(labels))\n        self.wait(2)\n        self.play(FadeOut(plano))\n        self.wait()\n        self.play(Write(normies), FadeOut(labels))\n        self.play(ddot.shift, 0.5 * UP + 4 * RIGHT, run_time=1, path_arc=1)\n        self.wait()\n        self.play(ReplacementTransform(vc1, vc1_n), ReplacementTransform(vc2, vc2_n), ReplacementTransform(vc3, vc3_n), ReplacementTransform(vc4, vc4_n))\n        self.play(ShowCreation(brac1))\n        self.wait()\n        self.play(FadeOut(vc1_n), ReplacementTransform(brac1, brac2))\n        self.wait(1.3)\n        self.play(FadeOut(vc2_n), ReplacementTransform(brac2, brac3))\n        self.wait(1.3)\n        self.play(FadeOut(vc3_n), ReplacementTransform(brac3, brac4))\n        self.wait(1.3)\n        self.play(FadeOut(vc4_n), FadeOut(brac4))\n        self.wait(1.3)\n        self.play(Write(obse))\n        self.wait(1.5)\n        self.play(ReplacementTransform(normies, obscero), FadeOut(obse))\n        self.play(ddot.shift, 4 * LEFT)\n        self.wait()\n        self.play(Transform(dot, cdot), ShowCreation(normdot))\n        self.wait(2)\n        self.play(Transform(obscero, unico))\n        self.wait(2)\n        self.play(FadeOut(cdot), FadeOut(normdot), FadeOut(obscero))\n        self.play(Group11.shift, 3.5 * UP, runtime=1.5)\n        self.wait(2.2)\n        self.play(FadeOut(Group11))\n        prop2 = TexMobject(' \\\\Vert \\\\lambda \\\\vec{x} \\\\Vert = \\\\vert \\\\lambda \\\\vert \\\\Vert \\\\vec{x} \\\\Vert').to_edge(DOWN).scale(1.2)\n        plano = NumberPlane()\n        vec1 = Vector(direction=avec, color=GREEN)\n        vec1_name = TexMobject('\\\\vec{x}').next_to(vec1.get_center(), DOWN)\n        vecesc = Vector(direction=lamb * avec, color=GREEN)\n        vecesc_name = TexMobject(str(lamb) + '\\\\vec{x}').next_to(vecesc.get_center(), DOWN + RIGHT)\n        avs = Vector(direction=-lamb * avec, color=PURPLE)\n        avs_name = TexMobject(str(-1 * lamb) + '\\\\vec{x}').next_to(avs.get_center(), DOWN + RIGHT)\n        lanorma = TextMobject('Consideremos solamente la \"longitud\" de ambos vectores').shift(3 * UP).scale(0.9)\n        acostado1 = Vector(direction=np.array([np.linalg.norm(lamb * avec), 0, 0]), color=GREEN).shift(4 * LEFT + UP)\n        acostado2 = Vector(direction=np.array([np.linalg.norm(-lamb * avec), 0, 0]), color=PURPLE).shift(4 * LEFT)\n        abrace1 = Brace(acostado1, UP)\n        abrace2 = Brace(acostado2, DOWN)\n        abraces = VGroup(abrace1, abrace2)\n        abracetex1 = TexMobject('\\\\Vert' + str(lamb) + '\\\\vec{x} \\\\Vert =' + str(lamb) + '\\\\Vert \\\\vec{x} \\\\Vert').next_to(abrace1, UP)\n        abracetex2 = TexMobject('\\\\Vert' + str(-lamb) + ' \\\\vec{x}\\\\Vert = ' + str(lamb) + '\\\\Vert \\\\vec{x} \\\\Vert').next_to(abrace2, DOWN)\n        abracetexs = VGroup(abracetex1, abracetex2)\n        obs = TextMobject('Observemos que si el escalar es ').shift(3 * RIGHT + UP).scale(0.75)\n        obs1 = TextMobject('negativo, se vuelve positivo.').next_to(obs, DOWN).scale(0.75)\n        obs2 = TextMobject('Si es positivo, mantiene su signo.').next_to(obs1, DOWN).scale(0.75)\n        observs = VGroup(obs, obs1, obs2)\n        asimero = TextMobject('\u00a1As\u00ed act\u00faa la funci\u00f3n valor absoluto!').move_to(obs).scale(0.9).shift(DOWN)\n        Lam = TextMobject('Sobre la norma de un escalar por un vector').scale(1.2)\n        prop2.bg = SurroundingRectangle(prop2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        Group12 = VGroup(prop2.bg, prop2)\n        self.play(FadeIn(Lam))\n        self.wait(1.3)\n        self.play(FadeOut(Lam))\n        self.play(ShowCreation(plano, runtime=2))\n        self.play(Write(Group12))\n        self.wait(2)\n        self.play(ShowCreation(vec1), Write(vec1_name))\n        self.wait()\n        self.play(ReplacementTransform(vec1, vecesc), ReplacementTransform(vec1_name, vecesc_name), ShowCreation(avs), Write(avs_name))\n        self.wait()\n        self.play(FadeOut(plano))\n        self.wait()\n        self.play(Write(lanorma))\n        self.wait()\n        self.play(FadeOut(vecesc_name), FadeOut(avs_name), FadeOut(lanorma))\n        self.play(Transform(vecesc, acostado1), Transform(avs, acostado2), ShowCreation(abraces, runtime=1), Write(abracetexs))\n        self.wait(2)\n        self.play(Write(observs))\n        self.wait(3.2)\n        self.play(FadeOut(observs))\n        self.play(Write(asimero))\n        self.wait()\n        self.play(FadeOut(asimero))\n        self.play(prop2.shift, UP * 3.5 + RIGHT * 3, run_time=1, path_arc=2)\n        self.wait(2)\n        self.play(FadeOut(abracetexs), FadeOut(abraces), FadeOut(acostado1), FadeOut(vecesc), FadeOut(avs), FadeOut(Group12))\n        self.wait()\n        prop3 = TexMobject(' \\\\Vert \\\\vec{x} + \\\\vec{y}\\\\Vert \\\\leq \\\\Vert \\\\vec{x} \\\\Vert+\\\\Vert \\\\vec{y} \\\\Vert').shift(2 * DOWN).scale(1.2)\n        plano = NumberPlane()\n        vector1 = Vector(direction=avec, color=GREEN).shift(2.5 * LEFT)\n        vector2 = Vector(direction=bvec, color=BLUE).move_to(avec + bvec / 2).shift(2.5 * LEFT)\n        vecsum = Vector(direction=avec + bvec, color=YELLOW_E).shift(2.5 * LEFT)\n        vector1_label = TexMobject('\\\\vec{x}').next_to(vector1.get_center(), UP)\n        vector2_label = TexMobject('\\\\vec{y}').next_to(vector2.get_center(), UP)\n        vecsum_label = TexMobject('\\\\vec{x}+\\\\vec{y}').next_to(vecsum.get_center(), DOWN)\n        labels = VGroup(vector1_label, vector2_label, vecsum_label)\n        tvector1 = Vector(direction=np.array([anorm, 0, 0]), color=GREEN).shift(3.5 * LEFT + UP)\n        tvector2 = Vector(direction=np.array([bnorm, 0, 0]), color=BLUE).shift(3.5 * LEFT + UP + np.array([anorm, 0, 0]))\n        tvecsum = Vector(direction=np.array([sumnorm, 0, 0]), color=YELLOW_E).shift(3.5 * LEFT + 0.5 * UP)\n        tvectors = VGroup(tvector1, tvector2, tvecsum)\n        brace1 = Brace(tvector1, UP)\n        brace2 = Brace(tvector2, UP)\n        bracesum = Brace(tvecsum, DOWN)\n        lnorm1 = TexMobject('\\\\Vert \\\\vec{x} \\\\Vert').next_to(brace1.get_center(), UP)\n        lnorm2 = TexMobject('\\\\Vert \\\\vec{y} \\\\Vert').next_to(brace2.get_center(), UP)\n        lnormsum = TexMobject('\\\\Vert \\\\vec{x} + \\\\vec{y} \\\\Vert').next_to(bracesum.get_center(), DOWN)\n        braces = VGroup(brace1, brace2, bracesum)\n        lnorms = VGroup(lnorm1, lnorm2, lnormsum)\n        laigualdad = TextMobject('(La igualdad se da cuando los tres vectores son colineales)').shift(3 * DOWN).scale(0.8)\n        preguntaa = TextMobject('\u00bfPuedes pensar en la relaci\u00f3n entre norma y producto interno?').scale(0.9).shift(UP)\n        preguntab = TextMobject('\u00bfSe te ocurre otra forma distinguir que vector es m\u00e1s \"largo\"?').scale(0.9).shift(DOWN)\n        edita = TextMobject(\"Edita el c\\\\'{o}digo para visualizar con m\\\\'{a}s vectores\")\n        Des = TextMobject(\"Desigualdad del tri\\\\'{a}ngulo para vectores\").scale(1.2)\n        self.play(FadeIn(Des))\n        self.wait(1.3)\n        self.play(Write(prop3))\n        self.wait(0.7)\n        self.play(FadeOut(Des))\n        self.play(ShowCreation(vector1), ShowCreation(vector2))\n        self.play(GrowArrow(vecsum), Write(labels))\n        self.wait(4)\n        self.play(Transform(vector1, tvector1), Transform(vector2, tvector2), Transform(vecsum, tvecsum), FadeOut(labels))\n        self.play(ShowCreation(braces))\n        self.wait(2)\n        self.play(Write(lnorms))\n        self.play(prop3.shift, 0.7 * UP, runtime=1)\n        self.play(Write(laigualdad))\n        self.wait(3)\n        self.play(FadeOut(lnorms), FadeOut(braces), FadeOut(prop3), FadeOut(vector1), FadeOut(vector2), FadeOut(vecsum), FadeOut(laigualdad))\n        self.play(Write(preguntaa), Write(preguntab))\n        self.wait(3)\n        self.play(FadeOut(preguntaa), FadeOut(preguntab))\n        self.wait()\n        self.play(Write(edita))"}]}
{"messages": [{"role": "user", "content": "Illustrate the geometric interpretations of the dot product by showing vector operations and deriving the angle between two vectors."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Producto_Interior(Scene):\n\n    def construct(self):\n        titulo = TextMobject(\"Aspectos geom\\\\'{e}tricos del producto interno\").scale(1.2)\n        self.play(Write(titulo))\n        self.wait()\n        self.play(FadeOut(titulo))\n        tomemos = TextMobject('Consideremos dos vectores en el plano').shift(2 * DOWN)\n        vecx_label = TexMobject('\\\\vec{x}')\n        vecy_label = TexMobject('\\\\vec{y}')\n        vecx = Vector(direction=np.array([3, 3, 0]), color=BLUE).shift(2 * LEFT)\n        vecy = Vector(direction=np.array([5, 0, 0]), color=GREEN).shift(2 * LEFT)\n        vecx_label.next_to(vecx, LEFT).shift(RIGHT)\n        vecy_label.next_to(vecy, DOWN)\n        self.play(Write(tomemos))\n        self.play(GrowArrow(vecx), GrowArrow(vecy))\n        self.play(Write(vecx_label), Write(vecy_label))\n        self.wait(3)\n        lambdukis = TexMobject('\\\\text{\u00bfQu\u00e9 valor de}\\\\ \\\\lambda\\\\ \\\\text{hace a}\\\\ \\\\vec{y}\\\\ \\\\text{y}\\\\ \\\\vec{x}-\\\\lambda\\\\vec{y}\\\\ \\\\text{perpendiculares?}')\n        lambdukis.move_to(tomemos)\n        vecesp = Vector(direction=3 * UP).shift(1 * RIGHT)\n        vecesp_label = TexMobject('\\\\vec{x}-\\\\lambda\\\\vec{y}').next_to(vecesp, RIGHT)\n        ylambd = Vector(direction=3 * RIGHT).shift(2 * LEFT).set_color(YELLOW)\n        ylambd_label = TexMobject('\\\\lambda\\\\vec{y}').move_to(vecy_label)\n        self.play(FadeOut(tomemos))\n        self.play(Write(lambdukis))\n        self.wait(5)\n        self.play(Transform(vecy_label, ylambd_label))\n        self.play(Write(vecesp_label), GrowArrow(vecesp), GrowArrow(ylambd))\n        self.wait(2)\n        self.play(FadeOut(vecx), FadeOut(vecx_label), FadeOut(vecy), FadeOut(vecy_label), FadeOut(ylambd), FadeOut(ylambd_label), FadeOut(lambdukis), FadeOut(vecesp), FadeOut(vecesp_label))\n        self.wait(3)\n        recordemos = TextMobject('Para responder a esta pregunta, basta recordar que').shift(2 * UP)\n        norm = TexMobject(' \\\\Vert \\\\vec{x} \\\\Vert = \\\\sqrt{x_1^2+x_2^2}')\n        denota = TexMobject('\\\\text{representa la longitud del vector}\\\\ \\\\vec{x}').shift(2 * DOWN)\n        grupo1 = VGroup(recordemos, norm, denota)\n        pitagoras = TextMobject(\"Utilicemos el Teorema de Pit\\\\'{a}goras en nuestro tri\\\\'{a}ngulo\").shift(2 * DOWN)\n        normx = TexMobject('\\\\Vert \\\\vec{x} \\\\Vert').move_to(vecx_label)\n        normlam = TexMobject('\\\\Vert \\\\lambda\\\\vec{y} \\\\Vert').move_to(ylambd_label).shift(0.5 * LEFT)\n        normesp = TexMobject('\\\\Vert \\\\vec{x}-\\\\lambda\\\\vec{y} \\\\Vert').move_to(vecesp_label)\n        pitriangulo = TexMobject('\\\\Vert \\\\lambda\\\\vec{y} \\\\Vert^2+\\\\Vert \\\\vec{x}-\\\\lambda\\\\vec{y} \\\\Vert^2 = \\\\Vert \\\\vec{x} \\\\Vert^2 ')\n        pitriangulo.move_to(pitagoras)\n        desa = TextMobject(\"Desarrollando esto, llegamos a la siguiente ecuaci\\\\'{o}n\").move_to(pitriangulo).shift(DOWN)\n        self.play(Write(recordemos), Write(norm), Write(denota))\n        self.wait(7)\n        self.play(FadeOut(recordemos), FadeOut(norm), FadeOut(denota))\n        self.play(Write(pitagoras), GrowArrow(ylambd), GrowArrow(vecesp), GrowArrow(vecx))\n        self.play(Write(normx), Write(normesp), Write(normlam))\n        self.wait(3)\n        self.play(Transform(pitagoras, pitriangulo))\n        self.wait(4)\n        self.play(Write(desa))\n        self.wait(3)\n        self.play(FadeOut(pitagoras), FadeOut(desa), FadeOut(vecesp), FadeOut(normesp), FadeOut(vecx), FadeOut(normx), FadeOut(ylambd), FadeOut(normlam))\n        self.wait()\n        ec1 = TexMobject('2\\\\lambda^2(y_1^2+y_2^2)-2\\\\lambda(x_1y_1+x_2y_2)=0').shift(2 * UP)\n        cuyo = TextMobject(\"Cuya soluci\\\\'{o}n distinta de cero es:\")\n        solu = TexMobject('\\\\lambda = \\\\frac{x_1y_1+x_2y_2}{\\\\Vert \\\\vec{y} \\\\Vert^2}').shift(2 * DOWN)\n        self.play(Write(ec1))\n        self.wait(8)\n        self.play(Write(cuyo))\n        self.wait(3)\n        self.play(Write(solu))\n        self.wait(8)\n        self.play(FadeOut(ec1), FadeOut(cuyo))\n        self.play(solu.shift, UP * 5, run_time=1, path_arc=2)\n        self.wait(2)\n        xperp = Vector(direction=np.array([0, 3, 0]), color=BLUE).shift(LEFT + DOWN)\n        yperp = Vector(direction=np.array([3, 0, 0]), color=GREEN).shift(LEFT + DOWN)\n        kepasa = TextMobject(\"\u00bfQu\\\\'{e} pasa si los vectores \\\\textbf{ya} son perpendiculares?\").shift(2.5 * DOWN)\n        xperp_label = TexMobject('\\\\vec{x}').next_to(xperp.get_center(), LEFT)\n        yperp_label = TexMobject('\\\\vec{y}').next_to(yperp.get_center(), DOWN)\n        dadocaso = TexMobject('\\\\text{En dado caso},\\\\ \\\\lambda = 0').move_to(kepasa)\n        self.play(GrowArrow(xperp), GrowArrow(yperp), Write(xperp_label), Write(yperp_label), Write(kepasa))\n        self.wait(5)\n        self.play(Transform(kepasa, dadocaso))\n        self.wait(2.4)\n        self.play(FadeOut(xperp), FadeOut(xperp_label), FadeOut(yperp_label), FadeOut(yperp), FadeOut(kepasa))\n        self.wait()\n        newsolu = TexMobject('\\\\lambda = \\\\frac{x_1y_1+x_2y_2}{\\\\Vert \\\\vec{y} \\\\Vert^2}= 0 \\\\Rightarrow x_1y_1+x_2y_2 = 0')\n        cond = TexMobject('(\\\\text{Si}\\\\ \\\\vec{y} \\\\neq 0)').shift(2 * DOWN)\n        self.play(Transform(solu, newsolu))\n        self.play(Write(cond))\n        self.wait(8)\n        self.play(FadeOut(solu), FadeOut(cond))\n        textprodint = TextMobject('Si recordamos:').shift(2 * UP)\n        prodint = TexMobject('\\\\vec{x} \\\\cdot \\\\vec{y} = x_1y_1+x_2y_2')\n        tons = TextMobject('Entonces').move_to(textprodint)\n        ida = TexMobject('\\\\vec{x} \\\\perp \\\\vec{y} \\\\Rightarrow \\\\vec{x} \\\\cdot \\\\vec{y} = 0').scale(1.2)\n        self.play(Write(textprodint), Write(prodint))\n        self.wait(5)\n        self.play(Transform(textprodint, tons), Transform(prodint, ida))\n        self.wait(6)\n        masymas = TextMobject(\"Veamos otro aspecto geom\\\\'{e}trico del producto interno.\").shift(UP)\n        regre = TextMobject(\"Regresemos al tri\\\\'{a}ngulo antes visto.\")\n        self.play(Transform(textprodint, masymas), Transform(prodint, regre))\n        self.wait(5)\n        self.play(FadeOut(textprodint), FadeOut(prodint))\n        vecesp = Vector(direction=3 * UP).shift(1 * RIGHT)\n        vecesp_label = TexMobject('\\\\vec{x}-\\\\lambda\\\\vec{y}').next_to(vecesp, RIGHT)\n        ylambd = Vector(direction=3 * RIGHT).shift(2 * LEFT).set_color(YELLOW)\n        ylambd_label = TexMobject('\\\\lambda\\\\vec{y}').next_to(ylambd).shift(2 * LEFT + 0.5 * DOWN)\n        vecx = Vector(direction=np.array([3, 3, 0]), color=BLUE).shift(2 * LEFT)\n        vecx_label = TexMobject('\\\\vec{x}').next_to(vecx, LEFT).shift(RIGHT)\n        vecy = Vector(direction=np.array([5, 0, 0]), color=GREEN).shift(2 * LEFT)\n        vecy_label = TexMobject('\\\\vec{y}').next_to(vecy).shift(0.5 * DOWN)\n        self.play(GrowArrow(vecx), GrowArrow(vecesp), GrowArrow(vecy))\n        self.play(Write(vecx_label), Write(vecesp_label), Write(vecy_label))\n        arco = ArcBetweenPoints(np.array([1, 0, 0]), np.array([0.7, 0.7, 0])).shift(2 * LEFT)\n        arco_label = TexMobject('\\\\theta').next_to(arco, RIGHT)\n        angulis = TexMobject(\"\\\\text{Consideremos el \\\\'{a}ngulo entre}\\\\ \\\\vec{x}\\\\ \\\\text{y}\\\\ \\\\vec{y}\").shift(2 * DOWN)\n        utilizando = TextMobject(\"Utilizando identidades trigonom\\\\'{e}tricas, sabemos que\").move_to(angulis)\n        coseno = TexMobject('\\\\cos\\\\theta = \\\\frac{\\\\Vert \\\\lambda\\\\vec{y}\\\\Vert}{\\\\Vert \\\\vec{x}\\\\Vert}').move_to(angulis)\n        demo = TexMobject('\\\\text{...se puede demostrar que independientemente del signo de}\\\\ \\\\lambda...').scale(0.8).move_to(angulis).shift(DOWN)\n        self.play(GrowArrow(arco))\n        self.play(GrowArrow(ylambd))\n        self.play(Write(arco_label), Write(ylambd_label), Write(angulis))\n        self.wait(3)\n        self.play(Transform(angulis, utilizando))\n        self.wait(3)\n        self.play(Transform(angulis, coseno), FadeOut(vecy), FadeOut(vecy_label))\n        self.wait(4)\n        self.play(Write(demo))\n        self.wait(4)\n        cos2 = TexMobject('\\\\cos\\\\theta = \\\\lambda \\\\frac{\\\\Vert \\\\vec{y}\\\\Vert}{\\\\Vert \\\\vec{x}\\\\Vert}').move_to(angulis)\n        self.play(FadeOut(angulis))\n        self.play(Write(cos2))\n        self.wait(5)\n        self.play(FadeOut(vecx), FadeOut(vecx_label), FadeOut(vecesp), FadeOut(vecesp_label), FadeOut(ylambd_label), FadeOut(ylambd), FadeOut(demo), FadeOut(arco), FadeOut(arco_label))\n        self.play(cos2.shift, UP * 5, run_time=1, path_arc=0)\n        lambda_d = TexMobject('\\\\text{Se dedujo anteriormente que}\\\\  \\\\lambda =\\\\frac{\\\\vec{x} \\\\cdot \\\\vec{y}}{\\\\Vert \\\\vec{y} \\\\Vert^2}')\n        lambda_dd = TexMobject('\\\\text{Sustituyendo lo anterior...}')\n        cos3 = TexMobject('\\\\cos\\\\theta = \\\\frac{\\\\vec{x}\\\\cdot\\\\vec{y}}{\\\\Vert \\\\vec{x} \\\\Vert\\\\Vert \\\\vec{y} \\\\Vert}').shift(2 * DOWN)\n        self.play(Write(lambda_d))\n        self.wait(6)\n        self.play(Transform(lambda_d, lambda_dd), Write(cos3))\n        self.wait(7)\n        yasi = TextMobject(\"Y as\\\\'{i}..\").shift(2 * UP)\n        thetatex = TexMobject('\\\\theta = \\\\arccos(\\\\frac{\\\\vec{x}\\\\cdot\\\\vec{y}}{\\\\Vert \\\\vec{x} \\\\Vert\\\\Vert \\\\vec{y} \\\\Vert}),\\\\ \\\\theta \\\\in [0,\\\\pi]').scale(1.2)\n        self.play(FadeOut(cos2), Transform(lambda_d, yasi), FadeOut(cos3))\n        self.play(Write(thetatex))\n        self.wait(8)\n        siahora = TexMobject('\\\\text{Si ahora}\\\\ \\\\vec{x} \\\\cdot \\\\vec{y}=0 ').shift(3 * UP)\n        regreso = TexMobject(' \\\\theta = \\\\arccos(0) = \\\\pi').shift(1.5 * UP)\n        esdecir = TexMobject('\\\\vec{x} \\\\cdot \\\\vec{y} = 0 \\\\Rightarrow \\\\vec{x} \\\\perp \\\\vec{y}').scale(1.5)\n        self.play(Transform(lambda_d, siahora), Transform(thetatex, regreso), Write(esdecir))\n        self.wait(4)\n        enresumen = TextMobject(\"En resumen, vimos dos caracter\\\\'{i}sticas del producto interno\").shift(2.5 * UP)\n        sii = TexMobject('1)\\\\ \\\\vec{x} \\\\cdot \\\\vec{y} = 0 \\\\Leftrightarrow \\\\vec{x} \\\\perp \\\\vec{y}').shift(UP).scale(1.2)\n        thetaa = TexMobject('2)\\\\ \\\\theta = \\\\arccos(\\\\frac{\\\\vec{x}\\\\cdot\\\\vec{y}}{\\\\Vert \\\\vec{x} \\\\Vert\\\\Vert \\\\vec{y} \\\\Vert}),\\\\ \\\\theta \\\\in [0,\\\\pi]').scale(1).shift(DOWN)\n        esun = TextMobject(\"\u00a1Este producto es m\\\\'{a}s que s\\\\'{o}lo una f\\\\'{o}rmula!\").shift(2.5 * DOWN)\n        self.play(Transform(lambda_d, enresumen), FadeOut(thetatex), FadeOut(esdecir))\n        self.play(Write(sii))\n        self.wait(5)\n        self.play(Write(thetaa))\n        self.play(Write(esun))\n        self.wait(8)\n        self.play(FadeOut(lambda_d), FadeOut(sii), FadeOut(thetaa), FadeOut(esun))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the unit circle in R^2 under different norms (1, 2, infinity) and then animate the convergence of the p-norm unit circle to the infinity norm unit circle as p increases."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Normas(Scene):\n\n    def construct(self):\n        plano = NumberPlane()\n        intro1 = TextMobject(\"Veremos como se ve un c\\\\'{i}rculo unitario\")\n        intro2 = TexMobject('\\\\text{utilizando diferentes normas en }\\\\mathbb{R}^2')\n        intro2.next_to(intro1, DOWN)\n        intro = VGroup(intro1, intro2)\n        circ1 = TextMobject(\"Recordemos que la definici\\\\'{o}n de una circunferencia es\")\n        circ2 = TexMobject('\\\\mathbb{S}^1=\\\\{x\\\\in\\\\mathbb{R}^2 : \\\\Vert x \\\\Vert =1\\\\}')\n        circ2.next_to(circ1, DOWN)\n        circ = VGroup(circ1, circ2)\n        self.play(Write(intro))\n        self.wait(2)\n        self.play(ReplacementTransform(intro, circ))\n        self.wait(2)\n        self.play(FadeOut(circ))\n        title1 = TextMobject('Norma 1')\n        norm1 = TexMobject('\\\\Vert x \\\\Vert_1=\\\\vert x_1 \\\\vert + \\\\vert x_2 \\\\vert')\n        norm1.next_to(title1, DOWN)\n        Group1 = VGroup(title1, norm1)\n        Group1.scale(0.75)\n        Group1.set_color(RED)\n        fig1 = Square(side_length=np.sqrt(2), color=RED)\n        fig1.rotate(PI / 4)\n        self.play(Write(Group1))\n        self.wait()\n        self.play(ApplyMethod(Group1.to_edge, UP))\n        self.play(ShowCreation(plano))\n        self.play(ShowCreation(fig1))\n        self.wait(2)\n        self.play(ApplyMethod(Group1.move_to, np.array([-5, 3, 0])))\n        title2 = TextMobject('Norma 2')\n        norm2 = TexMobject('\\\\Vert x \\\\Vert_2=\\\\left(x_1^2 + x_2^2 \\\\right)^{1/2}')\n        norm2.next_to(title2, DOWN)\n        Group2 = VGroup(title2, norm2)\n        Group2.scale(0.75)\n        Group2.set_color(YELLOW)\n        fig2 = Circle(radius=1, color=YELLOW)\n        self.play(Write(Group2))\n        self.wait()\n        self.play(ApplyMethod(Group2.to_edge, UP))\n        self.play(ShowCreation(fig2))\n        self.wait(2)\n        self.play(ApplyMethod(Group2.move_to, np.array([5, 3, 0])))\n        title3 = TextMobject('Norma infinito')\n        norminfty = TexMobject('\\\\Vert x \\\\Vert_{\\\\infty} = \\\\max\\\\{\\\\vert x_i \\\\vert : i \\\\in \\\\{1,2\\\\}\\\\}')\n        norminfty.next_to(title3, DOWN)\n        Group3 = VGroup(title3, norminfty)\n        Group3.scale(0.75)\n        Group3.set_color(GREEN_SCREEN)\n        fig3 = Square(side_length=2, color=GREEN_SCREEN)\n        self.play(Write(Group3))\n        self.wait()\n        self.play(ApplyMethod(Group3.to_edge, UP))\n        self.play(ShowCreation(fig3))\n        self.wait(2)\n        self.remove(Group1, Group2, Group3, plano, fig1, fig2, fig3)\n        intro1 = TextMobject('Podemos definir una norma similar a las anteriores')\n        intro2 = TexMobject('\\\\text{para cada } p\\\\in\\\\mathbb{R},\\\\ p\\\\geq 1')\n        intro2.next_to(intro1, DOWN)\n        intro = VGroup(intro1, intro2)\n        titlep = TexMobject('\\\\text{Norma } p')\n        normp = TexMobject('\\\\Vert x \\\\Vert_p = \\\\left(\\\\sum_{i=1}^n \\\\vert x_i \\\\vert ^p \\\\right)^{1/p}')\n        normp.next_to(titlep, DOWN)\n        Groupp = VGroup(titlep, normp)\n        text = TextMobject('Veamos que pasa cuando $p$ crece en $\\\\mathbb{R}$')\n        self.play(Write(intro))\n        self.wait(2)\n        self.play(ReplacementTransform(intro, Groupp))\n        self.wait(2)\n        self.play(FadeOut(Groupp))\n        self.play(Write(text))\n        self.play(FadeOut(text))\n        self.play(ShowCreation(plano))\n        self.play(FadeIn(Group3), ShowCreation(fig3))\n        self.play(ApplyMethod(Group3.to_edge, DOWN))\n        n = 1\n        while n < 10:\n            valor_sig = TexMobject('p=' + str(n))\n            valor_sig.to_edge(UP)\n            self.add(valor_sig)\n            D = []\n            j = 0\n            dj = 1 / 16\n            while j < 1:\n                dot1 = Dot(radius=0.05, color=PINK)\n                dot1_2 = Dot(radius=0.05, color=PINK)\n                dot1.move_to(np.array([j, (1 - j ** n) ** (1 / n), 0]))\n                dot1_2.move_to(np.array([(1 - j ** n) ** (1 / n), j, 0]))\n                D.append(dot1)\n                D.append(dot1_2)\n                j = j + dj\n            j = 1\n            while j > 0:\n                dot2 = Dot(radius=0.05, color=PINK)\n                dot2_2 = Dot(radius=0.05, color=PINK)\n                dot2.move_to(np.array([j, -(1 - j ** n) ** (1 / n), 0]))\n                dot2_2.move_to(np.array([-(1 - j ** n) ** (1 / n), j, 0]))\n                D.append(dot2)\n                D.append(dot2_2)\n                j = j - dj\n            j = 0\n            while j > -1:\n                dot3 = Dot(radius=0.05, color=PINK)\n                dot3_2 = Dot(radius=0.05, color=PINK)\n                dot3.move_to(np.array([j, -(1 - (-j) ** n) ** (1 / n), 0]))\n                dot3_2.move_to(np.array([-(1 - (-j) ** n) ** (1 / n), j, 0]))\n                D.append(dot3)\n                D.append(dot3_2)\n                j = j - dj\n            j = -1\n            while j < 0:\n                dot4 = Dot(radius=0.05, color=PINK)\n                dot4_2 = Dot(radius=0.05, color=PINK)\n                dot4.move_to(np.array([j, (1 - (-j) ** n) ** (1 / n), 0]))\n                dot4_2.move_to(np.array([(1 - (-j) ** n) ** (1 / n), j, 0]))\n                D.append(dot4)\n                D.append(dot4_2)\n                j = j + dj\n            puntos = VGroup(*D)\n            self.add(puntos)\n            self.wait(0.5)\n            for i in D:\n                self.remove(i)\n            self.remove(valor_sig)\n            n = round(n + 0.2, 1)\n        self.remove(plano, Group3, fig3)\n        conclus1 = TextMobject(\"Vemos que tiende al ``c\\\\'{i}rculo'' que resulta de usar\")\n        conclus2 = TextMobject(\"la norma infinito, de ah\\\\'{i} su nombre.\").next_to(conclus1, DOWN)\n        conclus = VGroup(conclus1, conclus2)\n        ejer = TextMobject('Puedes cambiar el c\u00f3digo para verlo con m\u00e1s valores de $p$')\n        self.play(Write(ejer))\n        self.wait(2)\n        self.play(FadeOut(ejer))\n        self.play(Write(conclus))\n        self.wait(2)\n        self.play(FadeOut(conclus))"}]}
{"messages": [{"role": "user", "content": "Animate a 3D vector projection demonstration, explaining the concept with text and visual representations of vectors and their projections in both 2D and 3D space."}, {"role": "assistant", "content": "from mnaimlib.imports import *\n\nclass Proyeccion(ThreeDScene):\n\n    def acomodar_textos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.play(Write(objeto))\n\n    def construct(self):\n        grid = NumberPlane()\n        x1 = 0\n        x2 = 3\n        x3 = 0\n        y1 = 1\n        y2 = 1\n        y3 = 2\n        Vx = Arrow((0, 0, 0), x1 * RIGHT + x2 * UP, buff=0, color=BLUE_C)\n        Vxlabel = TexMobject('\\\\vec{x}').set_color(BLUE_C)\n        Vxlabel.move_to(Vx.get_end() + 0.5 * LEFT)\n        Vy = Arrow((0, 0, 0), y1 * RIGHT + y2 * UP, buff=0, color=YELLOW_C)\n        Vylabel = TexMobject('\\\\vec{y}').set_color(YELLOW_C)\n        Vy1 = Vy.copy()\n        Vylabel.move_to(Vy.get_end() + 0.5 * RIGHT - 0.3 * UP)\n        escalar = (x1 * y1 + x2 * y2) / (y1 * y1 + y2 * y2)\n        vec = Arrow((0, 0, 0), y1 * escalar * RIGHT + y2 * escalar * UP, buff=0, color=PURPLE_B)\n        veclabel = TexMobject('\\\\vec{z}').set_color(PURPLE_B)\n        veclabel.move_to(vec.get_end() + 0.5 * LEFT)\n        linea = DashedLine((y1 * escalar, y2 * escalar, 0), (x1, x2, 0), dash_length=0.1, positive_space_ratio=0.5, stroke_width=3, color='#88FF00')\n        escalar1 = (x1 * y1 + x2 * y2) / (x1 * x1 + x2 * x2)\n        vec1 = Arrow((0, 0, 0), x1 * escalar1 * RIGHT + x2 * escalar1 * UP, buff=0, color=RED)\n        linea1 = DashedLine((x1 * escalar1, x2 * escalar1, 0), (y1, y2, 0), dash_length=0.1, positive_space_ratio=0.5, stroke_width=3, color=WHITE)\n        titulo = TextMobject('Vector Proyecci\u00f3n').scale(1.5)\n        text = TextMobject('Tomemos dos vectores en \\\\\\\\ \\n                            el plano cartesiano')\n        text.bg = SurroundingRectangle(text, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text.group = VGroup(text.bg, text).shift(2 * DOWN + 3 * LEFT)\n        text1 = TextMobject('Podemos representar geom\u00e9tricamente\\n\\n                            la proyecci\u00f3n de', ' $\\\\vec{x}$', ' sobre', ' $\\\\vec{y}$', ' como', ' $\\\\vec{z}$').move_to(text.get_center() + 1 * RIGHT)\n        text1.bg = SurroundingRectangle(text1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text1.group = VGroup(text1.bg, text1).move_to(text.get_center() + 1 * RIGHT)\n        text1[1].set_color(BLUE_C)\n        text1[3].set_color(YELLOW_C)\n        text1[5].set_color(PURPLE_B)\n        text2 = TextMobject('Notemos que con la sombra de ', '$\\\\vec{x}$', ' sobre la recta que \\n\\n                            genera ', '$\\\\vec{y}$', ' obtenemos el ', 'vector proyecci\u00f3n', '.')\n        text2[1].set_color(BLUE_C)\n        text2[3].set_color(YELLOW)\n        text2[5].set_color(PURPLE_C)\n        text2.bg = SurroundingRectangle(text2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text2.group = VGroup(text2.bg, text2)\n        text2.group.move_to(2 * DOWN)\n        text3 = TextMobject('Adem\u00e1s de que la ', 'proyecci\u00f3n de $\\\\vec{y}$ sobre $\\\\vec{x} $', ' \\\\\\\\\\n                            es diferente a la ', 'proyecci\u00f3n de $\\\\vec{x}$ sobre $\\\\vec{y}$')\n        text3.bg = SurroundingRectangle(text3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text3.group = VGroup(text3.bg, text3)\n        text3.group.move_to(-2 * UP)\n        text3[1].set_color(RED)\n        text3[3].set_color(PURPLE_B)\n        Def = TextMobject('La ', 'proyecci\u00f3n', ' de ', '$\\\\vec{x}$', ' sobre\\n\\n                            ', '$\\\\vec{y}$', ' se define como:')\n        Def[1].set_color(GREEN_D)\n        Def[3].set_color(BLUE)\n        Def[5].set_color(YELLOW)\n        Def_copy = Def.copy()\n        Def_copy.move_to(2.5 * UP)\n        Def1 = TextMobject('$Proy_{\\\\vec{y}}(\\\\vec{x}):=\\\\frac{\\\\vec{x}\\\\cdot\\\\vec{y}}{\\\\vec{y}\\\\cdot\\\\vec{y}} \\\\vec{y}$')\n        Def1[0][0].set_color(GREEN_D)\n        Def1[0][1].set_color(GREEN_D)\n        Def1[0][2].set_color(GREEN_D)\n        Def1[0][3].set_color(GREEN_D)\n        Def1_1 = Def1.copy().move_to(2.5 * UP)\n        text4 = TextMobject('Veamos un \u00faltimo ejemplo, agreg\u00e1ndole una coordenada \\n\\n                                en ', 'z', ' a los vectores anteriores')\n        text4[1].set_color(PURPLE_B)\n        self.play(Write(titulo))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.play(Write(grid))\n        self.wait()\n        self.play(Write(text.group))\n        self.play(ShowCreation(Vx), Write(Vxlabel))\n        self.play(ShowCreation(Vy), Write(Vylabel))\n        self.wait(2)\n        self.play(ReplacementTransform(text.group, text1.group))\n        self.wait()\n        self.play(ShowCreation(linea))\n        self.wait(2)\n        self.play(ShowCreation(vec), Write(veclabel))\n        self.wait()\n        self.play(ReplacementTransform(text1.group, text2.group))\n        self.wait(7)\n        self.play(ReplacementTransform(text2.group, text3.group))\n        self.play(ReplacementTransform(linea, linea1), FadeIn(Vy1))\n        self.play(ShowCreation(vec1))\n        self.wait(2)\n        self.play(FadeOut(Vx), FadeOut(Vy), FadeOut(linea1), FadeOut(Vxlabel), FadeOut(Vylabel), FadeOut(veclabel), FadeOut(Vy1))\n        self.wait()\n        self.play(FadeOut(grid), FadeOut(text3.group), FadeOut(vec), FadeOut(vec1))\n        self.wait()\n        self.play(Write(Def))\n        self.wait(3)\n        self.play(ReplacementTransform(Def, Def_copy))\n        self.play(Write(Def1))\n        self.wait(3.5)\n        self.play(FadeOut(Def_copy))\n        self.wait()\n        self.play(ReplacementTransform(Def1, Def1_1))\n        self.play(Write(text4))\n        self.wait(5)\n        self.play(FadeOut(text4), FadeOut(Def1_1))\n        self.wait()\n        axes = ThreeDAxes()\n        Vx3d = Arrow((0, 0, 0), x1 * RIGHT + x2 * UP + x3 * OUT, buff=0, color=BLUE)\n        Vx3dlabel = TexMobject('\\\\vec{x}', color=BLUE_C)\n        Vx3dlabel.move_to(3 * UP + 5 * LEFT)\n        Vy3d = Line((0, 0, 0), y1 * RIGHT + y2 * UP + y3 * OUT, buff=0, color=YELLOW)\n        Vy3da = ArrowTip(start_angle=Vy3d.get_angle(), color=YELLOW).move_to(y1 * RIGHT + y2 * UP + y3 * OUT)\n        Vy3d.group = VGroup(Vy3d, Vy3da)\n        Vy3dlabel = TexMobject('\\\\vec{y}', color=YELLOW)\n        Vy3dlabel.move_to(2.5 * UP + 5 * LEFT)\n        Plabel = TextMobject('Proyecci\u00f3n', ' de $\\\\vec{y}$ \\n\\n                            sobre $\\\\vec{x}$').shift(0.25 * DOWN)\n        Plabel[0].set_color(RED)\n        Plabel.move_to(1.7 * UP + 5 * LEFT)\n        escalar3d = (x1 * y1 + x2 * y2 + x3 * y3) / (x1 * x1 + x2 * x2 + x3 * x3)\n        vec3d = Arrow((0, 0, 0), x1 * escalar3d * RIGHT + x2 * escalar3d * UP + x3 * escalar3d * OUT, buff=0, color=RED)\n        linea3d = DashedLine((y1, y2, y3), (x1 * escalar3d, x2 * escalar3d, x3 * escalar3d), dash_length=0.1, positive_space_ratio=0.5, stroke_width=3, color='#88FF00')\n        text5 = TextMobject('Modifica el c\u00f3digo para probar con nuevos vectores \\n\\n                             y perspectivas en la animaci\u00f3n en $\\\\mathbb{R}^{3}$')\n        self.set_camera_orientation(phi=80 * DEGREES, theta=45 * DEGREES, distance=6)\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(Vx3d), run_time=0.75)\n        self.acomodar_textos(Vx3dlabel)\n        self.play(ShowCreation(Vy3d.group), run_time=0.75)\n        self.acomodar_textos(Vy3dlabel)\n        self.play(ShowCreation(linea3d))\n        self.play(ShowCreation(vec3d))\n        self.acomodar_textos(Plabel)\n        self.begin_ambient_camera_rotation(rate=0.5)\n        self.wait(4)\n        self.play(FadeOut(axes), FadeOut(Vy3d.group), FadeOut(Vx3d), FadeOut(Vy3dlabel), FadeOut(Vx3dlabel), FadeOut(Plabel), FadeOut(vec3d), FadeOut(linea3d))\n        self.add_fixed_in_frame_mobjects(text5)\n        self.wait(2)\n        self.play(FadeOut(text5))"}]}
{"messages": [{"role": "user", "content": "Present a mathematical explanation of the Strong Theorem regarding continuous functions on compact sets, illustrating the concepts with geometric shapes and axes."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Continua_y_acotada(Scene):\n\n    def construct(self):\n        title = TextMobject('Teorema Fuerte: \\n\\n                            Funciones Continuas son \\n\\n                            Acotadas en Compactos').scale(1.5)\n        t1 = TextMobject('$f:A\\\\subset\\\\mathbb{R}^n\\\\to\\\\mathbb{R}^m$ es ', 'acotada', ' si \\n\\n                            $f(A)\\\\subset\\\\mathbb{R}^m$ es ', 'acotada')\n        t1.set_color_by_tex_to_color_map({'acotada': PURPLE_B})\n        t2 = TextMobject('Teniendo en cuenta la definici\u00f3n anterior consideremos el \\n \\n                            conjunto ', '$A$', '$ =[0,\\\\ 1.5]\\\\times[0,2]$ en $\\\\mathbb{R}^2$')\n        t2[1].set_color(RED)\n        t3 = TextMobject('Recuerda que este conjunto es ', 'compacto').next_to(t2, DOWN).scale(0.85).shift(2.5 * UP)\n        t3[1].set_color(ORANGE)\n        t4 = TextMobject('Toma la funci\u00f3n $f:A\\\\to\\\\mathbb{R}^2$ dada por $f(x,y)=(x^2,y^2)$, \\n \\n                            \u00bfcu\u00e1l es la ', 'imagen', ' de ', '$A$', ' bajo $f$?').scale(1.17)\n        t4[1].set_color(BLUE)\n        t4[3].set_color(RED)\n        t5 = TextMobject('$f$ es ', 'continua', ' y $f(A)$ es un conjunto ', 'acotado', '. \\n\\n                            Intenta demostrar ambas afirmaciones.').scale(1.17)\n        t5[1].set_color(GREEN_D)\n        t5[3].set_color(PURPLE_B)\n        t6 = TextMobject('El resultado que vimos, es uno de los teoremas importantes \\n\\n                            de continuidad, y dice lo siguiente:').shift(UP * 0.75)\n        t7 = TextMobject('Si $F:K\\\\subset\\\\mathbb{R}^n\\\\to\\\\mathbb{R}^m$ es ', 'continua', ' y $K$ ', 'compacto', ' \\n\\n                            entonces $F$ es ', 'acotada').next_to(t6, DOWN * 1)\n        t7[-1].set_color(PURPLE_B)\n        t7[1].set_color(GREEN_D)\n        t7[3].set_color(ORANGE)\n        ejes1 = Axes(x_min=-0.5, x_max=5, y_min=-0.5, y_max=4).move_to((-6 + 2.25, -3 + 1.75, 0))\n        ejes2 = Axes(x_min=-0.5, x_max=5, y_min=-0.5, y_max=4).move_to((1.5 + 2.25, -3 + 1.75, 0))\n        compacto = Rectangle(height=1.5, width=2, color=RED, fill_color=RED, fill_opacity=0.8).move_to((-5, -2.25, 0))\n        imagen = Rectangle(height=2.25, width=4, color=BLUE, fill_color=BLUE, fill_opacity=0.8).move_to((3.5, -1.875, 0))\n        flecha = Arrow(start=(-1, 0, 0), end=(1, 0, 0), color=WHITE)\n        f = TexMobject('f(x,y)').next_to(flecha, DOWN).shift(0.25 * DOWN)\n        Grupo0 = VGroup(t2, t3)\n        Grupo1 = VGroup(t4, t5).to_edge(UP).scale(0.7)\n        Grupo2 = VGroup(flecha, f)\n        Grupo3 = VGroup(ejes1, ejes2, compacto, imagen, Grupo2, t5)\n        self.play(Write(title))\n        self.wait(3.25)\n        self.play(ReplacementTransform(title, t1))\n        self.wait(7.5)\n        self.play(ReplacementTransform(t1, t2))\n        self.wait(5)\n        self.play(ApplyMethod(t2.scale, 0.85))\n        self.play(ApplyMethod(t2.to_edge, UP))\n        self.wait()\n        self.play(ShowCreation(ejes1))\n        self.play(ShowCreation(compacto))\n        self.wait()\n        self.play(Write(t3))\n        self.wait(3)\n        self.play(FadeOut(t3))\n        self.play(ReplacementTransform(t2, t4))\n        self.wait(7)\n        self.play(Write(Grupo2))\n        self.play(ShowCreation(ejes2))\n        self.play(ShowCreation(imagen))\n        self.wait()\n        self.play(ReplacementTransform(t4, t5))\n        self.wait(7)\n        self.play(FadeOut(Grupo3))\n        self.play(Write(t6))\n        self.wait(5)\n        self.play(Write(t7))\n        self.wait(5)\n        self.play(FadeOut(t6), FadeOut(t7))"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of limits in R^2 using a vector field and textual explanations, demonstrating both the existence and non-existence of limits for different functions."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LimiteR2aR2(Scene):\n\n    def construct(self):\n        titulo = TextMobject('Ejemplo de \\n\\n                                L\u00edmite en Campos').scale(1.5)\n        text = TextMobject('Consideremos la funci\u00f3n:')\n        text1 = TexMobject('f(x,y)=(-y,x)')\n        text1_bg = SurroundingRectangle(text1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text1_rect = VGroup(text1_bg, text1)\n        text2 = TextMobject(' Es posible mostrar que esta funci\u00f3n tiene l\u00edmite \\n\\n                                en todo $\\\\mathbb{R}^{2}$').to_corner(UL)\n        text2_rect = VGroup(SurroundingRectangle(text2, color=WHITE, fill_color=BLACK, fill_opacity=1), text2)\n        text2_1 = TextMobject('En particular, cuando $(x,y) \\\\rightarrow (0,0)$, el l\u00edmite es (0,0)').to_corner(UL)\n        text2_1_rect = VGroup(SurroundingRectangle(text2_1, color=WHITE, fill_color=BLACK, fill_opacity=1), text2_1)\n        text3 = TextMobject('Podemos ver lo anterior gr\u00e1ficamente de \\n\\n                                la siguiente manera').to_corner(UL).to_corner(UL)\n        text3_rect = VGroup(SurroundingRectangle(text3, color=WHITE, fill_color=BLACK, fill_opacity=1), text3)\n        text4 = TextMobject('Sea $\\\\varepsilon<0$. Si escogemos una bola de radio', ' $\\\\delta$').to_corner(UL)\n        text4[1].set_color(GREEN)\n        text4_rect = VGroup(SurroundingRectangle(text4, color=WHITE, fill_color=BLACK, fill_opacity=1), text4)\n        text5 = TextMobject('Podemos encontrar una bola, de radio $\\\\varepsilon$, tal que la', ' norma de\\n\\n                            la imagen de los puntos', ' dentro de la misma').to_edge(UP)\n        text5[1].set_color(RED)\n        text5_rect = VGroup(SurroundingRectangle(text5, color=WHITE, fill_color=BLACK, fill_opacity=1), text5)\n        text6 = TextMobject('Est\u00e9n a una distancia menor a', ' $\\\\delta$').to_edge(UP)\n        text6[1].set_color(GREEN)\n        text6_rect = VGroup(SurroundingRectangle(text6, color=WHITE, fill_color=BLACK, fill_opacity=1), text6)\n        text7 = TextMobject('Es posible hacer lo anterior con cualquier $\\\\delta$')\n        text7_rect = VGroup(SurroundingRectangle(text7, color=WHITE, fill_color=BLACK, fill_opacity=1), text7)\n        text8 = TextMobject('Una funci\u00f3n $f:A\\\\subset\\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R}^{m}$').move_to(2.8 * UP)\n        text8_1 = TextMobject('tiene l\u00edmite en $\\\\vec{x}_0$ y es $\\\\vec{l}$ si:').move_to(1.5 * UP)\n        text8_2 = TexMobject('\\\\forall\\\\varepsilon>0\\\\ \\\\exists\\\\delta>0 \\\\ tq \\\\ si\\\\ ||\\\\vec{x}-\\\\vec{x_0}||<\\\\delta')\n        text8_3 = TexMobject('(\\\\vec{x}\\\\in A\\\\setminus\\\\lbrace\\\\vec{x_0}\\\\rbrace) \\\\ \\\\text{entonces} \\\\ ||f(\\\\vec{x})-\\\\vec{l}||<\\\\varepsilon').move_to(1.5 * DOWN)\n        G1 = VGroup(text8, text8_1, text8_2, text8_3)\n        delta = 2.1\n        x = 0\n        delta1 = Line((0, 0, 0), (0, delta, 0), color=GREEN, stroke_width=3)\n        bola = Circle(radius=delta, color=GREEN).move_to(x * RIGHT)\n        bola1 = Circle(radius=delta - 0.05, color=WHITE)\n        bola_1 = Circle(radius=delta + 1, color=GREEN).move_to(x * RIGHT)\n        bola1_1 = Circle(radius=delta + 1 - 0.05, color=WHITE)\n        axes = Axes()\n        campo_2 = VectorField(campo2, x_min=-8, x_max=8, y_min=-6, y_max=6, delta_x=0.5, delta_y=0.5, length_func=lambda norm: 0.5 * sigmoid(norm), colors=[BLUE])\n        imagen1 = Vector(direction=(1, 0.36, 0), stroke_width=2, max_tip_length_to_length_ratio=0.15, color=RED)\n        imagen2 = Vector(direction=(0.7, 1.3, 0), stroke_width=2, max_tip_length_to_length_ratio=0.1, color=RED)\n        imagen3 = Vector(direction=(-0.36, 1, 0), stroke_width=2, max_tip_length_to_length_ratio=0.15, color=RED)\n        imagen4 = Vector(direction=(-1.65, 0.1, 0), stroke_width=2, max_tip_length_to_length_ratio=0.1, color=RED)\n        imagen5 = Vector(direction=(-1.35, -0.85, 0), stroke_width=2, max_tip_length_to_length_ratio=0.1, color=RED)\n        imagen6 = Vector(direction=(1.35, -1.3, 0), stroke_width=2, max_tip_length_to_length_ratio=0.1, color=RED)\n        imagen = VGroup(imagen1, imagen2, imagen3, imagen4, imagen5, imagen6)\n        imagen1_c = Vector(direction=(1.8, 1.4, 0), stroke_width=2, max_tip_length_to_length_ratio=0.08, color=RED)\n        imagen2_c = Vector(direction=(1.7, 2.35, 0), stroke_width=2, max_tip_length_to_length_ratio=0.07, color=RED)\n        imagen3_c = Vector(direction=(-1.4, 1.8, 0), stroke_width=2, max_tip_length_to_length_ratio=0.08, color=RED)\n        imagen4_c = Vector(direction=(-2.7, 1.1, 0), stroke_width=2, max_tip_length_to_length_ratio=0.07, color=RED)\n        imagen5_c = Vector(direction=(-2.3, -1.9, 0), stroke_width=2, max_tip_length_to_length_ratio=0.07, color=RED)\n        imagen6_c = Vector(direction=(1.4, -2.35, 0), stroke_width=2, max_tip_length_to_length_ratio=0.08, color=RED)\n        imagen_c = VGroup(imagen1_c, imagen2_c, imagen3_c, imagen4_c, imagen5_c, imagen6_c)\n        self.play(Write(titulo))\n        self.wait(3.5)\n        self.play(FadeOut(titulo))\n        self.play(Write(text))\n        self.wait(1.125)\n        self.play(text.shift, 1.5 * UP, runtime=1.5)\n        self.play(Write(text1))\n        self.wait(3)\n        self.play(FadeOut(text))\n        self.play(ReplacementTransform(text1, text1_rect))\n        self.add_foreground_mobjects(text1_rect)\n        self.play(Write(axes), text1_rect.shift, 3 * UP + 4 * LEFT, runtime=1.5)\n        self.play(*[GrowArrow(vec) for vec in campo_2], runtime=20)\n        self.wait()\n        self.play(ReplacementTransform(text1_rect, text2_rect))\n        self.add_foreground_mobjects(text2_rect)\n        self.wait(4.2)\n        self.play(ReplacementTransform(text2_rect, text2_1_rect))\n        self.wait(4.2)\n        self.play(FadeOut(text2_1_rect))\n        self.play(Write(text3_rect))\n        self.wait(3.5)\n        self.play(ReplacementTransform(text3_rect, text4_rect))\n        self.wait(4.2)\n        self.play(ShowCreation(delta1))\n        self.play(ShowCreation(bola))\n        self.play(ReplacementTransform(text4_rect, text5_rect))\n        self.wait(8)\n        self.play(ShowCreation(bola1))\n        self.wait()\n        self.play(*[GrowArrow(img) for img in imagen])\n        self.wait()\n        self.play(ReplacementTransform(text5_rect, text6_rect))\n        self.wait(2.7)\n        self.play(ReplacementTransform(text6_rect, text7_rect))\n        self.add_foreground_mobjects(text7_rect)\n        self.play(ReplacementTransform(bola, bola_1))\n        self.play(ReplacementTransform(bola1, bola1_1))\n        self.wait(3)\n        self.play(ReplacementTransform(imagen, imagen_c))\n        self.wait(2)\n        self.play(FadeOut(imagen_c), FadeOut(campo_2), FadeOut(bola1_1), FadeOut(bola_1), FadeOut(axes), FadeOut(text7_rect), FadeOut(delta1))\n        self.play(Write(text8))\n        self.play(Write(text8_1))\n        self.play(Write(text8_2))\n        self.play(Write(text8_3))\n        self.wait(11.25)\n        self.play(FadeOut(G1))\n        self.wait()\n        self.custom_method()\n\n    def custom_method(self):\n        text = TextMobject('Consideremos ahora la funci\u00f3n:')\n        text1 = TexMobject('f(x,y)=\\\\left({\\\\frac{-1}{y^{5}}},x\\\\right)')\n        text1_rect = VGroup(SurroundingRectangle(text1, color=WHITE, fill_color=BLACK, fill_opacity=1), text1)\n        text2 = TextMobject(' Es posible demostrar que esta funci\u00f3n no tiene\\n\\n                                l\u00edmite en cualquier punto de la forma (x,0)').move_to(text1.get_center() - 2 * UP)\n        text2_rect = VGroup(SurroundingRectangle(text2, color=WHITE, fill_color=BLACK, fill_opacity=1), text2)\n        text3 = TextMobject('Podemos ver lo anterior gr\u00e1ficamente de \\n\\n                                la siguiente manera').to_corner(UL)\n        text3_rect = VGroup(SurroundingRectangle(text3, color=WHITE, fill_color=BLACK, fill_opacity=1), text3)\n        text4 = TextMobject('La imagen de la funci\u00f3n\\n\\n                            siempre est\u00e1 creciendo en el eje x').to_corner(UL)\n        text4_rect = VGroup(SurroundingRectangle(text4, color=WHITE, fill_color=BLACK, fill_opacity=1), text4)\n        text5 = TextMobject('\u00bfSe te ocurre como demostrar que la funci\u00f3n anterior\\n\\n                                no tiene l\u00edmite?')\n        axes = Axes()\n        campo_1 = VectorField(campo, x_min=-8, x_max=8, y_min=-6, y_max=6, delta_x=0.45, delta_y=0.45, length_func=lambda norm: 0.49 * sigmoid(norm))\n        self.play(Write(text))\n        self.wait(1.5)\n        self.play(text.shift, 2 * UP, runtime=1.5)\n        self.play(Write(text1))\n        self.wait(3.375)\n        self.play(FadeOut(text))\n        self.play(ReplacementTransform(text1, text1_rect))\n        self.add_foreground_mobjects(text1_rect)\n        self.play(Write(axes), text1_rect.shift, 3 * UP + 4 * LEFT, runtime=1.5)\n        self.play(*[GrowArrow(vec) for vec in campo_1], runtime=20)\n        self.wait(1.2)\n        self.play(Write(text2_rect))\n        self.add_foreground_mobjects(text2_rect)\n        self.wait(6)\n        self.play(FadeOut(text1_rect), FadeOut(text2_rect))\n        self.play(Write(text3_rect))\n        self.wait(3.375)\n        self.play(ReplacementTransform(text3_rect, text4_rect))\n        self.wait(4.5)\n        self.play(FadeOut(text4_rect))\n        self.play(FadeOut(axes), FadeOut(campo_1))\n        self.play(Write(text5))\n        self.wait(4.5)\n        self.play(FadeOut(text5))"}]}
{"messages": [{"role": "user", "content": "Illustrate the definition of a level set with introductory text and then demonstrate the level set for $f(x) = \\sin(x)$ for the value $c=1$ by plotting the function and marking the relevant points on the x-axis."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ConjNiv_Def(GraphScene, Scene):\n    CONFIG = {'y_max': 2, 'y_min': -2, 'x_max': 4 * PI, 'x_min': -4 * PI, 'y_tick_frequency': 0.5, 'x_tick_frequency': PI / 2, 'graph_origin': ORIGIN, 'y_axis_label': None, 'x_axis_label': '$x$'}\n\n    def construct(self):\n        titulo = TextMobject('Conjuntos de Nivel').scale(1.5)\n        intro_a = TextMobject('Para funciones $f:A\\\\subset \\\\mathbb{R}^n \\\\to \\\\mathbb{R} $, se').shift(UP)\n        intro_b = TextMobject('define al conjunto de nivel de $f$ como ').next_to(intro_a, DOWN)\n        intro_c = TextMobject('$N_c(f):=\\\\{ \\\\vec{x}\\\\in A| f(\\\\vec{x})=c\\\\}$').next_to(intro_b, DOWN)\n        intro = VGroup(intro_a, intro_b, intro_c)\n        text_1 = TextMobject('Sea', ' A', ' el dominio de una funci\u00f3n $f:A\\\\subset \\\\mathbb{R}^n \\\\to \\\\mathbb{R} $').to_edge(UP)\n        text_1[1].set_color(BLUE)\n        EjeY_1 = Arrow(start=(0, -1, 0), end=(0, 4, 0), stroke_width=2)\n        EjeX_1 = Arrow(start=(-1, 0, 0), end=(4, 0, 0), stroke_width=2)\n        label_Rn = TexMobject('\\\\mathbb{R}^n').shift(0.5 * RIGHT + 0.5 * DOWN)\n        Ejes_1 = VGroup(EjeX_1, EjeY_1, label_Rn).shift(5 * LEFT + 2.5 * DOWN)\n        A_svg_1 = SVGMobject('Func_SVGs/enRn.svg').set_height(FRAME_HEIGHT * 0.3)\n        A_svg_1.set_style(fill_opacity=0.7, stroke_width=0, stroke_opacity=1, fill_color=BLUE)\n        A_svg_1.shift(DOWN + 3 * LEFT)\n        text_2 = TextMobject('Consideremos un n\u00famero real', ' $c$', ' $\\\\in \\\\mathbb{R}$').to_edge(UP)\n        text_2[1].set_color(RED_C)\n        Linea_Eje_Real = DoubleArrow(start=(-1, 0, 0), end=(4, 0, 0), stroke_width=2, buff=0.1).shift(2 * RIGHT + DOWN)\n        ticks = []\n        for i in range(20):\n            ticks.append(Line(start=(-1 + 2 * i / 10, 0.1, 0), end=(-1 + 2 * i / 10, -0.1, 0), stroke_width=1).shift(2.6 * RIGHT + DOWN))\n        label_R = TexMobject('\\\\mathbb{R}').shift(1.5 * DOWN + 2 * RIGHT)\n        Eje_Real = VGroup(*ticks, Linea_Eje_Real, label_R)\n        dot_c = Dot(point=(2.5, 0, 0), color=RED_C, radius=0.1).shift(2 * RIGHT + DOWN)\n        dot_c_dup = Dot(point=(2.5, 0, 0), color=RED_C, radius=0.1).shift(2 * RIGHT + DOWN)\n        label_c = TextMobject('c').set_color(RED_C).next_to(dot_c, 1.5 * DOWN)\n        punto_c = VGroup(dot_c, label_c)\n        text_3a = TextMobject('Si tomamos todos los puntos ', '$\\\\vec{x}_i$ ', 'en ', 'A', ' que al aplicarles la funci\u00f3n').to_edge(UP)\n        text_3a[3].set_color(BLUE)\n        text_3b = TextMobject('toman el valor de', ' $c$').next_to(text_3a, DOWN)\n        text_3b[1].set_color(RED_C)\n        text_3 = VGroup(text_3a, text_3b).scale(0.9)\n        pto_cn1 = Dot(point=(0, 0, 0)).shift(DOWN + 3 * LEFT)\n        pto_cn1_dup = Dot(point=(0, 0, 0)).shift(DOWN + 3 * LEFT)\n        pto_cn2 = Dot(point=(0.3, 0.1, 0)).shift(DOWN + 3 * LEFT)\n        pto_cn2_dup = Dot(point=(0.3, 0.1, 0)).shift(DOWN + 3 * LEFT)\n        pto_cn3 = Dot(point=(-0.5, 0.2, 0)).shift(DOWN + 3 * LEFT)\n        pto_cn3_dup = Dot(point=(-0.5, 0.2, 0)).shift(DOWN + 3 * LEFT)\n        conjniv = VGroup(pto_cn1, pto_cn2, pto_cn3)\n        conjniv_dup = VGroup(pto_cn1_dup, pto_cn2_dup, pto_cn3_dup)\n        f_arrow = Arrow(start_point=LEFT, end_point=RIGHT + 2 * DOWN, buff=0.1)\n        f_label = TexMobject('f').next_to(f_arrow, UP)\n        f = VGroup(f_arrow, f_label)\n        text_4a = TextMobject('Entonces el conjunto de puntos $\\\\vec{x}_i$ es el ').to_edge(UP)\n        text_4b = TextMobject('conjunto de nivel $c$ de nuestra funci\u00f3n: $N_c(f)$').next_to(text_4a, DOWN)\n        text_4 = VGroup(text_4a, text_4b).scale(0.9)\n        def_conjniv = TexMobject('N_c(f):=\\\\{\\\\vec{x}\\\\in A \\\\vert f(\\\\vec{x}) = c \\\\}').to_edge(UP)\n        def_conjniv1 = TextMobject('O, usando la definici\u00f3n de imagen inversa, ').to_edge(UP)\n        def_conjniv2 = TexMobject('N_c(f):= f^{-1}(\\\\{c\\\\})').next_to(def_conjniv1, DOWN)\n        def_conjniv_group = VGroup(def_conjniv1, def_conjniv2)\n        text5 = TextMobject('Veamos un ejemplo')\n        self.play(Write(titulo))\n        self.wait(1.15)\n        self.play(FadeOut(titulo))\n        self.play(Write(intro_a))\n        self.play(Write(intro_b))\n        self.play(Write(intro_c))\n        self.wait(8)\n        self.play(FadeOut(intro))\n        self.play(Write(text_1), FadeIn(Ejes_1), FadeIn(A_svg_1))\n        self.play(FadeIn(Eje_Real))\n        self.wait(4.5)\n        self.play(FadeIn(punto_c), ReplacementTransform(text_1, text_2))\n        self.wait(3.5)\n        self.play(ReplacementTransform(text_2, text_3))\n        self.play(ShowCreation(conjniv), ShowCreation(f))\n        self.wait(7.7)\n        self.play(Transform(conjniv_dup, dot_c_dup), runtime=3)\n        self.wait(2)\n        self.play(ReplacementTransform(text_3, text_4))\n        self.wait(7)\n        self.play(ReplacementTransform(text_4, def_conjniv))\n        self.wait(4)\n        self.play(ReplacementTransform(def_conjniv, def_conjniv_group))\n        self.wait(4)\n        self.play(FadeOut(punto_c), FadeOut(conjniv_dup), FadeOut(conjniv), FadeOut(A_svg_1), FadeOut(f), FadeOut(Ejes_1), FadeOut(Eje_Real))\n        self.wait()\n        self.play(FadeOut(def_conjniv_group))\n        self.play(Write(text5))\n        self.wait(2.5)\n        self.play(FadeOut(text5))\n        '\\n        A partir de este punto tengo que romper el esquema tradicional de s\u00f3lo instanciar objetos\\n        antes de la secuencia de animaci\u00f3n. Esto tengo que hacerlo para poder utilizar el m\u00e9todo\\n        coords_to_point() que solo funciona despu\u00e9s de declarar los ejes. Si declaro los ejes\\n        en la secci\u00f3n de objetos, aparecen en toda la animaci\u00f3n.\\n        '\n        self.setup_axes()\n        line_1 = Line(start=self.coords_to_point(-4 * PI, 1), end=self.coords_to_point(4 * PI, 1), stroke_width=2, color=RED)\n        text_6 = TextMobject('Obtengamos el conjunto de nivel 1 de ', '$f(x) = \\\\sin(x)$').to_edge(UP).scale(0.8)\n        text_6[1].set_color(GREEN)\n        text_7 = TextMobject('Este conjunto estar\u00e1 contenido en $\\\\mathbb{R}$').to_edge(UP).scale(0.8)\n        text_8 = TexMobject('N_1(f) = \\\\left\\\\{\\\\frac{\\\\pi}{2}+2k\\\\pi \\\\vert k \\\\in \\\\mathbb{Z} \\\\right\\\\}').to_edge(UP).shift(0.5 * UP).scale(0.8)\n        graph_dotlines = []\n        for i in range(-2, 2):\n            graph_dotlines.append(DashedLine(start=self.coords_to_point(PI / 2 + i * 2 * PI, 0), end=self.coords_to_point(PI / 2 + i * 2 * PI, 1)))\n        Dotlines = VGroup(*graph_dotlines)\n        graph_dots = []\n        gdots_dup = []\n        GREEN_dots = []\n        for i in range(-2, 2):\n            graph_dots.append(Dot(point=self.coords_to_point(PI / 2 + i * 2 * PI, 0), radius=0.1))\n            gdots_dup.append(Dot(point=self.coords_to_point(PI / 2 + i * 2 * PI, 0), radius=0.1))\n            GREEN_dots.append(Dot(point=self.coords_to_point(PI / 2 + i * 2 * PI, 1), radius=0.1, color=GREEN))\n        GraphDots = VGroup(*graph_dots)\n        GDotsDup = VGroup(*gdots_dup)\n        GREENDots = VGroup(*GREEN_dots)\n        text_9 = TextMobject('Pues para todo $x \\\\in N_c(f)$, se tiene que $\\\\sin(x) = 1$').to_edge(UP).scale(0.9)\n        '\\n        DECLARO TODOS LOS OBJETOS EN ESTA SECCI\u00d3N, Y DEPU\u00c9S SIGO CON EL ESQUEMA HABITUAL\\n        '\n        self.play(*[Write(objeto) for objeto in [self.y_axis, self.x_axis, self.x_axis_labels]], run_time=2)\n        plotSin = self.get_graph(lambda x: np.sin(x), color=GREEN, x_min=-4 * PI, x_max=4 * PI)\n        self.play(ShowCreation(plotSin), run_time=3)\n        self.play(Write(text_6))\n        self.wait(4.5)\n        self.play(ShowCreation(line_1))\n        self.wait()\n        self.wait(2)\n        self.play(ReplacementTransform(text_6, text_7))\n        self.wait(3.25)\n        self.play(ReplacementTransform(text_7, text_8))\n        self.play(ShowCreation(Dotlines))\n        self.wait(4)\n        self.play(ShowCreation(GraphDots))\n        self.wait(2)\n        self.play(text_8.shift, 6 * DOWN + 3 * LEFT, runtime=2)\n        self.wait(1.5)\n        self.play(Write(text_9))\n        self.wait(6)\n        self.play(Transform(GDotsDup, GREENDots), runtime=4)\n        self.wait(3)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.wait()\n    '\\n    AQUI SE CONFIGURAN LOS EJES A DETALLE, NO FORMA PARTE DE LA ANIMACI\u00d3N.\\n    '\n\n    def setup_axes(self):\n        GraphScene.setup_axes(self)\n        self.x_axis.set_stroke(width=2)\n        self.y_axis.set_stroke(width=2)\n        self.y_axis.label_direction = 0.5 * RIGHT + 0.5 * UP\n        self.y_axis.add_numbers(*[-1, 1])\n        init_val_x = -7 * PI / 2\n        step_x = 2 * PI\n        end_val_x = 5 * PI / 2\n        values_decimal_x = Range(init_val_x, end_val_x, step_x)\n        self.x_axis_labels = VGroup()\n        list_x = TexMobject('-\\\\frac{7\\\\pi}{2}', '-\\\\frac{3\\\\pi}{2}', '\\\\frac{\\\\pi}{2}', '\\\\frac{5\\\\pi}{2}')\n        values_x = [(i, j) for i, j in zip(values_decimal_x, list_x)]\n        for x_val, x_tex in values_x:\n            x_tex.scale(0.5)\n            if x_val == -PI or x_val == PI:\n                x_tex.next_to(self.coords_to_point(x_val, 0), 2 * DOWN)\n            else:\n                x_tex.next_to(self.coords_to_point(x_val, 0), DOWN)\n            self.x_axis_labels.add(x_tex)"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of continuity of curves using sequences, showing both continuous and discontinuous examples in 3D space with accompanying textual explanations."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Continuidad_con_sucesiones(ThreeDScene):\n\n    def acomodar_textos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.play(Write(objeto))\n\n    def acomodar_puntos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.add(objeto)\n\n    def helicoide(self, t):\n        return [t, np.cos(4 * t), np.sin(4 * t)]\n\n    def func_suma(self, t):\n        return [t, t + np.cos(4 * t), t + np.sin(4 * t)]\n\n    def contra1(self, t):\n        return [t, 1, 1]\n\n    def contra2(self, t):\n        return [t, -1, -1]\n\n    def construct(self):\n        t_1 = TextMobject('Continuidad en Curvas con Sucesiones').scale(1.5)\n        t_2 = TextMobject('Recuerda que una posible definici\u00f3n de ', 'continuidad', ' es: \\n\\n                            $f:\\\\mathbb{R}\\\\to\\\\mathbb{R}^2$ es ', 'continua', ' en $t_0$ si').shift(1 * UP)\n        t_2.set_color_by_tex_to_color_map({'continuidad': BLUE, 'continua': BLUE})\n        t_3 = TexMobject('\\\\lim_{t\\\\to t_0}f(t)=f(t_0)').next_to(t_2, DOWN)\n        t_4 = TextMobject('Aqu\u00ed utilizaremos una equivalencia con ', 'sucesiones', ':')\n        t_4.set_color_by_tex_to_color_map({'sucesiones': PURPLE_B})\n        t_4_1 = TextMobject('$f:\\\\mathbb{R}\\\\to\\\\mathbb{R}^2$ es ', 'continua', ' en $t_0$ \\n\\n                            $\\\\Leftrightarrow \\\\forall\\\\{x_n\\\\}\\\\subset\\\\mathbb{R}$ ', 'sucesi\u00f3n', ' tal que').shift(1 * UP)\n        t_4_1.set_color_by_tex_to_color_map({'sucesi\u00f3n': PURPLE_B, 'continua': BLUE})\n        t_5 = TexMobject('\\\\lim_{n\\\\to\\\\infty}x_n=t_0,\\\\\\\\\\\\\\\\ \\\\lim_{n\\\\to\\\\infty}f(x_n)=f(t_0)').next_to(t_4_1, DOWN)\n        t_6 = TextMobject('Veamos un par de ejemplos...')\n        nota = TextMobject('NOTA: Aqu\u00ed ejemplificaremos usando solo una sucesi\u00f3n, puedes probar con \\n\\n                            otras sucesiones modificando el c\u00f3digo correspondiente.').scale(0.5).shift(3.5 * DOWN)\n        t_7 = TextMobject('Considera $t_0=0$').scale(0.7).to_corner(LEFT + UP).shift(1 * RIGHT)\n        t_7.bg = SurroundingRectangle(t_7, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        reglaf = TextMobject('$f(t)$', '$=(\\\\cos(4t),\\\\sin(4t))$').scale(0.7).align_to(t_7, LEFT).shift(2.7 * UP).shift(0.5 * LEFT)\n        reglaf.set_color_by_tex_to_color_map({'$f(t)$': RED})\n        reglaf.bg = SurroundingRectangle(reglaf, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        reglaf.group = VGroup(reglaf, reglaf.bg)\n        t_8 = TextMobject('Toma la ', 'sucesi\u00f3n ', '$X_n$', '$=\\\\dfrac{3}{n}$').scale(0.7).to_corner(RIGHT + DOWN).shift(2.5 * UP).shift(1.5 * LEFT)\n        t_8.set_color_by_tex_to_color_map({'$X_n$': YELLOW})\n        t_8.bg = SurroundingRectangle(t_8, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        t_8.group = VGroup(t_8, t_8.bg)\n        t_9 = TextMobject('$\\\\lim_{n \\\\to \\\\infty} $', '$X_n$', '$ = 0$ \\\\\\\\\\n                                $\\\\lim_{n \\\\to \\\\infty} f(X_n) = (1,0)$ \\\\\\\\\\n                                $\\\\lim_{n \\\\to \\\\infty} (X_n,f(X_n)) = (0,1,0)$').scale(0.7).next_to(t_8.bg, DOWN)\n        t_9[1].set_color(YELLOW)\n        reglag = TextMobject('$g(t)$', '$=(t+\\\\cos(4t),t+\\\\sin(4t))$').scale(0.7).align_to(t_7, LEFT).shift(2.7 * UP).shift(1 * LEFT)\n        t_9.bg = SurroundingRectangle(t_9, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        t_9.group = VGroup(t_9, t_9.bg)\n        reglag.set_color_by_tex_to_color_map({'$g(t)$': BLUE})\n        reglag.bg = SurroundingRectangle(reglag, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        t_10 = TextMobject('\u00bfY c\u00f3mo ser\u00eda una funci\u00f3n ', 'discontinua?').scale(0.7).to_corner(LEFT + UP)\n        t_10.bg = SurroundingRectangle(t_10, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        t_10.group = VGroup(t_10, t_10.bg)\n        t_10.set_color_by_tex_to_color_map({'discontinua': GREEN_D})\n        reglacontra1_tex = ['(1,1),', 't\\\\leq 0']\n        reglacontra2_tex = ['(-1,-1)', ',', 't>0']\n        reglacontra1_mob = TexMobject(*reglacontra1_tex)\n        reglacontra2_mob = TexMobject(*reglacontra2_tex)\n        for i, item in enumerate(reglacontra1_mob):\n            item.align_to(reglacontra2_mob[i], LEFT)\n        reglacontra1 = VGroup(*reglacontra1_mob)\n        reglacontra2 = VGroup(*reglacontra2_mob).shift(DOWN)\n        reglacontra = VGroup(reglacontra1, reglacontra2)\n        brace = Brace(reglacontra, LEFT)\n        h = brace.get_text('$h(x)$', '$=$')\n        h.set_color_by_tex_to_color_map({'$h(x)$': ORANGE})\n        reglacompleta = VGroup(reglacontra, brace, h).scale(0.7).next_to(t_7.bg, DOWN).align_to(t_7, LEFT)\n        reglacompleta.bg = SurroundingRectangle(reglacompleta, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        t_11 = TextMobject('Toma las ', 'sucesiones ', '$X_n$', '$=\\\\dfrac{3}{n}$ y \\n\\n                            ', '$Y_n$', '$=-\\\\dfrac{3}{n}$').scale(0.7).to_corner(RIGHT + UP)\n        t_11.bg = SurroundingRectangle(t_11, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        t_11.set_color_by_tex_to_color_map({'$X_n$': YELLOW, '$Y_n$': YELLOW})\n        t_12 = TextMobject('$\\\\lim_{n \\\\to \\\\infty} $', '$X_n$', '$ = 0$ \\\\\\\\\\n                                $\\\\lim_{n \\\\to \\\\infty} f(X_n) = (-1,-1)$ \\\\\\\\\\n                                $\\\\lim_{n \\\\to \\\\infty} (X_n,f(X_n)) = (0,-1,-1)$').scale(0.7).to_corner(RIGHT + DOWN).shift(2 * UP)\n        t_12[1].set_color(YELLOW)\n        t_12.bg = SurroundingRectangle(t_12, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        t_13 = TextMobject('$\\\\lim_{n \\\\to \\\\infty} $', '$Y_n$', '$ = 0$ \\\\\\\\\\n                                $\\\\lim_{n \\\\to \\\\infty} f(Y_n) = (1,1)$ \\\\\\\\\\n                                $\\\\lim_{n \\\\to \\\\infty} (Y_n,f(Y_n)) = (0,1,1)$').scale(0.7).next_to(t_12.bg, DOWN)\n        t_13.bg = SurroundingRectangle(t_13, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        t_13.set_color_by_tex_to_color_map({'$Y_n$': YELLOW})\n        t_13.group = VGroup(t_13, t_13.bg)\n        t_14 = TextMobject('Tenemos entonces dos ', 'sucesiones', ' \\\\\\\\ \\n                            que convergen a $t_0$ cuyas ', 'sucesiones', ' \\\\\\\\ \\n                            de im\u00e1genes convergen a cosas distintas.\\\\\\\\\\n                            Concluimos que la funci\u00f3n \\\\\\\\ \\n                            es ', 'discontinua', ' en $t_0$.').scale(0.7).to_corner(RIGHT + DOWN).shift(1 * UP)\n        t_14.bg = SurroundingRectangle(t_14, color=WHITE, fill_color=BLACK, fill_opacity=0.5)\n        t_14.set_color_by_tex_to_color_map({'discontinua': GREEN_D, 'sucesiones': PURPLE_B})\n        t_14.group = VGroup(t_14, t_14.bg)\n        axis_config = {'x_min': -6, 'x_max': 6, 'y_min': -6, 'y_max': 6, 'z_min': -6, 'z_max': 6}\n        ejes = ThreeDAxes(**axis_config)\n        tmin = -6\n        tmax = 6\n        f = ParametricFunction(self.helicoide, t_min=tmin, t_max=tmax, color=RED).set_shade_in_3d(True)\n        g = ParametricFunction(self.func_suma, t_min=tmin, t_max=tmax, color=BLUE).set_shade_in_3d(True)\n        contra_1 = ParametricFunction(self.contra1, t_min=tmin, t_max=0, color=ORANGE).set_shade_in_3d(True)\n        contra_2 = ParametricFunction(self.contra2, t_min=0.001, t_max=tmax, color=ORANGE).set_shade_in_3d(True)\n        X = []\n        Y = []\n        Z = []\n        W = []\n        for n in range(1, 101):\n            x_n = Dot(color=YELLOW, point=(3 / n, np.cos(4 * 3 / n), np.sin(4 * 3 / n)))\n            X.append(x_n)\n            y_n = Dot(color=YELLOW, point=(3 / n, 3 / n + np.cos(4 * 3 / n), 3 / n + np.sin(4 * 3 / n)))\n            Y.append(y_n)\n            z_n = Dot(color=YELLOW, point=(3 / n, -1, -1))\n            Z.append(z_n)\n            w_n = Dot(color=YELLOW, point=(-3 / n, 1, 1))\n            W.append(w_n)\n        suce1 = VGroup(*X)\n        suce2 = VGroup(*Y)\n        suce3 = VGroup(*Z)\n        suce4 = VGroup(*W)\n        Grupo1 = VGroup(t_2, t_3)\n        Grupo1_1 = VGroup(t_4)\n        Grupo2 = VGroup(t_4_1, t_5)\n        Grupo3 = VGroup(t_8, t_9, t_8.bg, t_9.bg)\n        Grupo4 = VGroup(t_6, nota)\n        Grupo5 = VGroup(t_11, t_12, t_11.bg, t_12.bg, t_13, t_13.bg)\n        Grupo6 = VGroup(t_7, t_7.bg, reglacompleta, reglacompleta.bg, contra_1, contra_2, t_14, t_14.bg, suce3, suce4, ejes)\n        self.play(Write(t_1))\n        self.wait()\n        self.play(FadeOutAndShiftDown(t_1))\n        self.play(Write(Grupo1))\n        self.wait(10)\n        self.play(ReplacementTransform(Grupo1, Grupo1_1))\n        self.wait(2.5)\n        self.play(ReplacementTransform(Grupo1_1, Grupo2))\n        self.wait(10)\n        self.play(FadeOut(Grupo2))\n        self.play(Write(Grupo4))\n        self.wait(3)\n        self.play(FadeOutAndShiftDown(Grupo4))\n        self.set_camera_orientation(phi=115 * DEGREES, theta=-65 * DEGREES)\n        self.play(ShowCreation(ejes))\n        self.acomodar_textos(t_7.bg)\n        self.acomodar_textos(t_7)\n        self.add_foreground_mobjects(t_7.bg)\n        self.add_foreground_mobjects(t_7)\n        self.wait(2)\n        self.begin_ambient_camera_rotation(rate=0.07)\n        self.acomodar_textos(reglaf.bg)\n        self.acomodar_textos(reglaf)\n        self.add_foreground_mobjects(reglaf.bg)\n        self.add_foreground_mobjects(reglaf)\n        self.play(ShowCreation(f), run_time=2)\n        self.wait(2.5)\n        self.acomodar_textos(t_8.bg)\n        self.acomodar_textos(t_8)\n        self.add_foreground_mobjects(t_8.bg)\n        self.add_foreground_mobjects(t_8)\n        self.play(Write(suce1), run_time=3)\n        self.wait(2)\n        self.acomodar_textos(t_9.bg)\n        self.acomodar_textos(t_9)\n        self.add_foreground_mobjects(t_9.bg)\n        self.add_foreground_mobjects(t_9)\n        self.wait(10)\n        self.remove_foreground_mobjects(reglaf.bg)\n        self.remove_foreground_mobjects(reglaf)\n        self.remove_foreground_mobjects(t_8.bg)\n        self.remove_foreground_mobjects(t_8)\n        self.remove_foreground_mobjects(t_9.bg)\n        self.remove_foreground_mobjects(t_9)\n        self.play(FadeOut(suce1), FadeOut(reglaf.group), FadeOut(f), FadeOut(Grupo3), FadeOut(t_8.group), FadeOut(t_9.group))\n        self.acomodar_textos(reglag.bg)\n        self.acomodar_textos(reglag)\n        self.add_foreground_mobjects(reglag.bg)\n        self.add_foreground_mobjects(reglag)\n        self.play(ShowCreation(g), run_time=2)\n        self.wait(4)\n        self.acomodar_textos(t_8.bg)\n        self.acomodar_textos(t_8)\n        self.play(Write(suce2), run_time=3)\n        self.wait(2)\n        self.acomodar_textos(t_9.bg)\n        self.acomodar_textos(t_9)\n        self.wait(10)\n        self.remove_foreground_mobjects(reglag.bg)\n        self.remove_foreground_mobjects(reglag)\n        self.remove_foreground_mobjects(t_7.bg)\n        self.remove_foreground_mobjects(t_7)\n        self.remove_foreground_mobjects(t_8.bg)\n        self.remove_foreground_mobjects(t_8)\n        self.remove_foreground_mobjects(t_9.bg)\n        self.remove_foreground_mobjects(t_9)\n        self.play(FadeOut(suce2), FadeOut(reglag), FadeOut(g), FadeOut(reglag.bg), FadeOut(Grupo3), FadeOut(t_7), FadeOut(t_7.bg))\n        self.acomodar_textos(t_10.bg)\n        self.acomodar_textos(t_10)\n        self.add_foreground_mobjects(t_10.bg)\n        self.add_foreground_mobjects(t_10)\n        self.wait(2.5)\n        self.play(FadeOut(t_10), FadeOut(t_10.bg))\n        self.remove_foreground_mobjects(t_10.bg)\n        self.remove_foreground_mobjects(t_10)\n        self.acomodar_textos(t_7.bg)\n        self.acomodar_textos(t_7)\n        self.add_foreground_mobjects(t_7.bg)\n        self.add_foreground_mobjects(t_7)\n        self.wait(2)\n        self.acomodar_textos(reglacompleta.bg)\n        self.acomodar_textos(reglacompleta)\n        self.add_foreground_mobjects(reglacompleta.bg)\n        self.add_foreground_mobjects(reglacompleta)\n        self.wait(9)\n        self.play(ShowCreation(contra_1), ShowCreation(contra_2), run_time=2)\n        self.acomodar_textos(t_11.bg)\n        self.acomodar_textos(t_11)\n        self.add_foreground_mobjects(t_11.bg)\n        self.add_foreground_mobjects(t_11)\n        self.wait(5)\n        self.play(Write(suce3), Write(suce4))\n        self.wait()\n        self.acomodar_textos(t_12.bg)\n        self.acomodar_textos(t_12)\n        self.add_foreground_mobjects(t_12.bg)\n        self.add_foreground_mobjects(t_12)\n        self.wait(10)\n        self.acomodar_textos(t_13.bg)\n        self.acomodar_textos(t_13)\n        self.add_foreground_mobjects(t_13.bg)\n        self.add_foreground_mobjects(t_13)\n        self.wait(10)\n        self.remove_foreground_mobjects(t_11.bg)\n        self.remove_foreground_mobjects(t_11)\n        self.remove_foreground_mobjects(t_12.bg)\n        self.remove_foreground_mobjects(t_12)\n        self.remove_foreground_mobjects(t_13.bg)\n        self.remove_foreground_mobjects(t_13)\n        self.remove_foreground_mobject(Grupo5)\n        self.play(FadeOut(Grupo5))\n        self.acomodar_textos(t_14.bg)\n        self.acomodar_textos(t_14)\n        self.add_foreground_mobjects(t_14.bg)\n        self.add_foreground_mobjects(t_14)\n        self.wait(9)\n        self.remove_foreground_mobjects(t_14.bg)\n        self.remove_foreground_mobjects(t_14)\n        self.remove_foreground_mobjects(t_7.bg)\n        self.remove_foreground_mobjects(t_7)\n        self.remove_foreground_mobjects(reglacompleta.bg)\n        self.remove_foreground_mobjects(reglacompleta)\n        self.play(FadeOut(Grupo6))\n        self.wait(3)\n        self.stop_ambient_camera_rotation()"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of continuous functions mapping open sets to open sets with mathematical text and visual representations of sets."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass FunContinuasEnAbiertos(Scene):\n\n    def construct(self):\n        titulo = TextMobject('Funciones Continuas y Abiertos').scale(1.5)\n        titulo1 = TextMobject('La imagen inversa de un abierto,\\n\\n                                 bajo una funci\u00f3n continua,\\n \\n                                     es un abierto').move_to(-0.5 * UP).scale(1.5)\n        text1 = TextMobject('Tomemos la funci\u00f3n ', ' $f(x,y)=(x^{2},y)$', '$ \\\\ , \\\\  (x,y)\\\\in\\\\mathbb{R}^{2}$').move_to(1 * UP)\n        text2 = TextMobject('Notemos que $Im(f)={(x,z)\\\\in\\\\mathbb{R}^2|x\\\\geq 0}$ y').move_to(0 * UP)\n        text3 = TextMobject(' $f(x,y)$ es continua en  $\\\\mathbb{R}^{2}$').move_to(1 * DOWN)\n        text4 = TextMobject('Ahora tomemos un abierto en el contradominio de f \\n\\n                            $U\\\\subset\\\\mathbb{R}^{2}$').move_to(2.3 * UP)\n        text5 = TextMobject('Tomemos la imagen inversa de U').move_to(text4)\n        text6 = TextMobject(' $f^{-1}(U)$\\n\\n                           $\\\\leftarrow$ ').move_to(-1 * UP)\n        text7 = TextMobject('Lo mismo ocurre con cualquier abierto de $\\\\mathbb{R}^{2}$').move_to(text5)\n        text8 = TextMobject(' $f^{-1}(A)$\\n\\n                           $\\\\leftarrow$ ').move_to(-1 * UP)\n        textf = TextMobject('$f:\\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R}^{m}$\\n', 'f es continua en $\\\\bf{TODO}$ $\\\\mathbb{R}^{n}$\\n\\n                                si solo si para todo \\n  ', '$ U\\\\subset\\\\mathbb{R}^{m}$ abierto \\n\\n                                   se cumple que $f^{-1}(U)$ es abierto ')\n        textf1 = TextMobject(' Lo mismo ocurre si el dominio de $f$ es abierto,\\n \\n                                      ', ' \u00bfqu\u00e9 pasa si no lo es? \\n\\n                                      ', ' Investiga sobre topolog\u00eda relativa.')\n        textf2 = TextMobject('Tambi\u00e9n puedes modificar el c\u00f3digo para ver m\u00e1s \\n\\n                                ejemplos con cajas')\n        linea1 = Arrow((-6, -4, 0), (-0.5, -4, 0), stroke_width=6, color=WHITE, buff=0)\n        linea2 = Arrow((-3.5, -7, 0), (-3.5, 0, 0), stroke_width=6, color=WHITE, buff=0)\n        G1 = VGroup(linea1, linea2).move_to(-2.5 * UP + 3.5 * LEFT)\n        linea3 = Arrow((0.5, -4, 0), (6, -4, 0), stroke_width=6, color=WHITE, buff=0)\n        linea4 = Arrow((3, -7, 0), (3, 0, 0), stroke_width=6, color=WHITE, buff=0)\n        G2 = VGroup(linea3, linea4).move_to(3.5 * RIGHT - 2.5 * UP)\n        r1 = 1\n        r2 = 1.5\n        caja1 = Rectangle(height=r1, width=r2, fill_color=YELLOW_C, color=YELLOW_C, fill_opacity=1, buff=0).move_to((3.7 + -r2 / 2) * LEFT - 2.5 * UP)\n        caja2 = Rectangle(height=r1, width=r2 * r2, fill_color=PURPLE_C, color=PURPLE_C, fill_opacity=1, buff=0).move_to((3.3 + r2 * r2 / 2) * RIGHT + -2.5 * UP)\n        caja2label = TextMobject('U').next_to(caja2)\n        r3 = 2\n        r4 = 2\n        y = 0\n        caja3 = Rectangle(height=r3, width=r4 / 3, fill_color=YELLOW_C, color=YELLOW_C, fill_opacity=1, buff=0).move_to(4.7 * LEFT + (-3 + r3 / 2) * UP)\n        caja5 = Rectangle(height=r3, width=r4 / 3, fill_color=YELLOW_C, color=YELLOW_C, fill_opacity=1, buff=0).move_to(2.8 * LEFT + (-3 + r3 / 2) * UP)\n        caja4 = Rectangle(height=r3, width=(r4 / 2) ** 2, fill_color=PURPLE_C, color=PURPLE_C, fill_opacity=1, buff=0).move_to((3.8 + (r4 / 2) ** 2 / 2) * RIGHT + (-3 + r3 / 2) * UP)\n        caja4label = TextMobject('A').next_to(caja4)\n        punto = np.array([1, -4, 0])\n        self.play(Write(titulo))\n        self.wait()\n        self.play(titulo.shift, 2 * UP, runtime=1.5)\n        self.wait(2)\n        self.play(Write(titulo1))\n        self.wait(5)\n        self.play(FadeOut(titulo), FadeOut(titulo1))\n        self.play(Write(text1))\n        self.wait(6)\n        self.play(Write(text2))\n        self.wait(3)\n        self.play(Write(text3))\n        self.wait(4)\n        self.play(FadeOut(text1[0]), FadeOut(text2), FadeOut(text3), FadeOut(text1[2]))\n        self.play(text1[1].shift, 2.5 * UP + 1.2 * LEFT, runtime=1.5)\n        self.play(ShowCreation(G1), ShowCreation(G2))\n        self.play(Write(text4))\n        self.wait(6)\n        self.play(ShowCreation(caja2), Write(caja2label))\n        self.play(ReplacementTransform(text4, text5))\n        self.wait(3)\n        self.play(Write(text6))\n        self.wait()\n        self.play(ShowCreation(caja1))\n        self.play(ReplacementTransform(text5, text7))\n        self.wait(5)\n        self.play(ReplacementTransform(caja2, caja4), ReplacementTransform(caja2label, caja4label))\n        self.play(ReplacementTransform(text6, text8))\n        self.play(ReplacementTransform(caja1, caja3))\n        self.play(ShowCreation(caja5))\n        self.wait()\n        self.play(FadeOut(caja3), FadeOut(caja4), FadeOut(caja5), FadeOut(G1), FadeOut(G2), FadeOut(text8), FadeOut(text1[1]), FadeOut(text7), FadeOut(caja4label))\n        self.play(Write(textf[0]))\n        self.wait(5)\n        self.play(Write(textf[1]))\n        self.wait()\n        self.play(Write(textf[2]))\n        self.wait(5)\n        self.play(FadeOut(textf))\n        self.play(Write(textf1[0]))\n        self.wait(5)\n        self.play(Write(textf1[1]))\n        self.wait(2)\n        self.play(Write(textf1[2]))\n        self.wait(3)\n        self.play(ReplacementTransform(textf1, textf2))\n        self.wait(5)\n        self.play(FadeOut(textf2))"}]}
{"messages": [{"role": "user", "content": "Explain the concept of function graphs by showing a linear function example and then generalizing the definition."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Definicion_Graficas(GraphScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        GraphScene.setup(self)\n    CONFIG = {'x_min': -1, 'x_max': 4, 'x_axis_width': 5, 'x_tick_frequency': 1, 'x_leftmost_tick': None, 'x_labeled_nums': [1, 2, 3], 'x_axis_label': '$x$', 'y_min': -1.5, 'y_max': 5, 'y_axis_height': 4, 'y_tick_frequency': 1, 'y_bottom_tick': None, 'y_labeled_nums': [-1, 1, 3, 5], 'y_axis_label': '$y$', 'axes_color': GREY, 'graph_origin': 2.7 * DOWN + 1.8 * LEFT, 'exclude_zero_label': True, 'default_graph_colors': [BLUE, GREEN, YELLOW], 'default_derivative_color': GREEN, 'default_input_color': YELLOW, 'default_riemann_start_color': BLUE, 'default_riemann_end_color': GREEN, 'area_opacity': 0.8, 'num_rects': 50}\n\n    def construct(self):\n        titulo = TextMobject('Gr\u00e1ficas de Funciones').scale(1.5)\n        text_1 = TextMobject('Consideremos la siguiente funci\u00f3n:').move_to(3.2 * UP)\n        ejemplo_1_1 = TexMobject('f:[0,3]\\\\subset\\\\mathbb{R}\\\\rightarrow\\\\mathbb{R}')\n        ejemplo_1_2 = TexMobject('f(x)=5-2x').next_to(ejemplo_1_1, DOWN)\n        ejemplo_1 = VGroup(ejemplo_1_1, ejemplo_1_2).next_to(text_1, 1.5 * DOWN)\n        text_2_1 = TextMobject('La funci\u00f3n $f$ nos permite definir relaciones entre pares')\n        text_2_2 = TextMobject('correspondientes del ', 'dominio', ' y el ', 'contradominio').next_to(text_2_1, DOWN)\n        text_2_2[1].set_color(BLUE_E)\n        text_2_2[3].set_color(RED_E)\n        text_2 = VGroup(text_2_1, text_2_2).move_to(text_1.get_center())\n        text_3_1 = TextMobject('Para cada elemento del ', 'dominio', ' de $f$')\n        text_3_2 = TextMobject('corresponde un s\u00f3lo elemento del ', 'contradominio').next_to(text_3_1, DOWN)\n        text_3_1[1].set_color(BLUE_E)\n        text_3_2[1].set_color(RED_E)\n        text_3 = VGroup(text_3_1, text_3_2).move_to(text_1.get_center())\n        text_4_1 = TextMobject('Consideremos las parejas ordenadas')\n        text_4_2 = TextMobject('$($', '$x$', ' , ', '$f(x)$', '$)$, con ', '$x$', ' en el dominio de $f$').next_to(text_4_1, DOWN)\n        text_4_2[1].set_color(BLUE_E)\n        text_4_2[3].set_color(RED_E)\n        text_4_2[5].set_color(BLUE_E)\n        text_4 = VGroup(text_4_1, text_4_2).move_to(text_1.get_center())\n        text_5 = TextMobject('Definimos la ', 'gr\u00e1fica', ' de $f$ como el siguiente conjunto:').move_to(3.2 * UP)\n        text_5[1].set_color(YELLOW_E)\n        text_6 = TexMobject('G_f:=\\\\{(x,f(x))\\\\in \\\\mathbb{R}^2|x\\\\in[0,3] \\\\}', color=YELLOW_E).next_to(text_5, 1 * DOWN)\n        def_graf = VGroup(text_5, text_6)\n        text_7_1 = TextMobject('En general, dada una funci\u00f3n $f:A\\\\subset\\\\mathbb{R}^n\\\\rightarrow\\\\mathbb{R}^m$,')\n        text_7_2 = TextMobject('se define la ', 'gr\u00e1fica', ' de $f$ de la siguiente forma:').next_to(text_7_1, DOWN)\n        text_7_2[1].set_color(YELLOW_E)\n        text_7 = VGroup(text_7_1, text_7_2).move_to(text_1.get_center() + 1 * DOWN)\n        def_1 = TexMobject('G_f:=\\\\{ (x_1,...,x_n,f_1(\\\\vec{x}),...,f_m(\\\\vec{x}))\\\\in\\\\mathbb{R}^{n+m}|\\\\vec{x}=(x_1,...x_n)\\\\in A \\\\}').scale(0.95)\n        text_8 = TextMobject('Es decir, ').next_to(def_1, 1.5 * DOWN)\n        def_2 = TexMobject('G_f:=\\\\{(\\\\vec{x},f(\\\\vec{x}))\\\\in \\\\mathbb{R}^{n+m}| \\\\vec{x}\\\\text{ en el domino de } f \\\\}').next_to(text_8, 1.5 * DOWN)\n        dt = VGroup(text_8, def_2)\n        numberline_1 = NumberLine(x_min=0, x_max=4, unit_size=0.75, include_numbers=True, include_tip=True, number_scale_val=0.6, lable_direction=1.2 * DOWN).move_to(4.4 * LEFT + 0.5 * UP)\n        numberline_2 = NumberLine(x_min=-2, x_max=4, unit_size=0.5, include_numbers=True, numbers_to_show=[-1, 1, 3], include_tip=True, number_scale_val=0.6, label_direction=1.2 * DOWN, numbers_with_elongated_ticks=[]).move_to(4.4 * RIGHT + 0.5 * UP)\n        text_numberline_1 = TextMobject('Dominio ($x$)', color=BLUE_E).scale(0.75).move_to(numberline_1.get_bottom() + 0.4 * DOWN)\n        text_numberline_2 = TextMobject('Contradominio (f$(x)$)', color=RED_E).scale(0.75).move_to(numberline_2.get_bottom() + 0.4 * DOWN)\n        punto_dom_1 = Dot(color=BLUE_E).move_to((-5.11, 0.63, 0))\n        punto_dom_2 = Dot(color=BLUE_E).move_to((-4.36, 0.63, 0))\n        punto_dom_3 = Dot(color=BLUE_E).move_to((-3.62, 0.63, 0))\n        punto_contra_1 = Dot(color=RED_E).move_to((5.4, 0.665, 0))\n        punto_contra_2 = Dot(color=RED_E).move_to((4.4, 0.665, 0))\n        punto_contra_3 = Dot(color=RED_E).move_to((3.4, 0.665, 0))\n        text_punto_dom_1 = TexMobject('x=1', color=BLUE_E).scale(0.75).next_to(text_numberline_1, 1.5 * DOWN)\n        text_punto_dom_2 = TexMobject('x=2', color=BLUE_E).scale(0.75).next_to(text_punto_dom_1, 1.5 * DOWN)\n        text_punto_dom_3 = TexMobject('x=3', color=BLUE_E).scale(0.75).next_to(text_punto_dom_2, 1.5 * DOWN)\n        text_punto_contra_1 = TexMobject('f(1)=3', color=RED_E).scale(0.75).next_to(text_numberline_2, 1.5 * DOWN)\n        text_punto_contra_2 = TexMobject('f(2)=1', color=RED_E).scale(0.75).next_to(text_punto_contra_1, 1.5 * DOWN)\n        text_punto_contra_3 = TexMobject('f(3)=-1', color=RED_E).scale(0.75).next_to(text_punto_contra_2, 1.5 * DOWN)\n        text_puntos = VGroup(text_punto_dom_1, text_punto_dom_2, text_punto_dom_3, text_punto_contra_1, text_punto_contra_2, text_punto_contra_3, text_numberline_1, text_numberline_2)\n        linea_dom_1 = Line(punto_dom_1.get_center(), ejemplo_1_2.get_left(), color=BLUE_E, path_arc=-0.5)\n        linea_dom_2 = Line(punto_dom_2.get_center(), ejemplo_1_2.get_left(), color=BLUE_E, path_arc=-0.5)\n        linea_dom_3 = Line(punto_dom_3.get_center(), ejemplo_1_2.get_left(), color=BLUE_E, path_arc=-0.5)\n        linea_contra_1 = Line(ejemplo_1_2.get_right(), punto_contra_1.get_center(), color=RED_E, path_arc=-0.5)\n        linea_contra_2 = Line(ejemplo_1_2.get_right(), punto_contra_2.get_center(), color=RED_E, path_arc=-0.5)\n        linea_contra_3 = Line(ejemplo_1_2.get_right(), punto_contra_3.get_center(), color=RED_E, path_arc=-0.5)\n        dom_contra_1 = VGroup(punto_dom_1, punto_contra_1, linea_dom_1, linea_contra_1)\n        dom_contra_2 = VGroup(punto_dom_2, punto_contra_2, linea_dom_2, linea_contra_2)\n        dom_contra_3 = VGroup(punto_dom_3, punto_contra_3, linea_dom_3, linea_contra_3)\n        self.play(Write(titulo))\n        self.wait(3)\n        self.play(FadeOut(titulo))\n        self.play(Write(text_1))\n        self.play(Write(ejemplo_1))\n        self.wait(10)\n        self.play(FadeOut(text_1), FadeOut(ejemplo_1_1))\n        self.play(ShowCreation(numberline_1), ShowCreation(numberline_2))\n        self.play(Write(text_numberline_1), Write(text_numberline_2))\n        self.play(Write(text_2))\n        self.wait(7.625)\n        self.play(FadeOut(text_2))\n        self.play(Write(text_3))\n        self.wait(6.875)\n        self.play(FadeIn(punto_dom_1), FadeIn(text_punto_dom_1))\n        self.play(FadeIn(linea_dom_1))\n        self.play(FadeIn(linea_contra_1))\n        self.play(FadeIn(punto_contra_1), FadeIn(text_punto_contra_1))\n        self.play(FadeOut(dom_contra_1))\n        self.play(FadeIn(punto_dom_2), FadeIn(text_punto_dom_2))\n        self.play(FadeIn(linea_dom_2))\n        self.play(FadeIn(linea_contra_2))\n        self.play(FadeIn(punto_contra_2), FadeIn(text_punto_contra_2))\n        self.play(FadeOut(dom_contra_2))\n        self.play(FadeIn(punto_dom_3), FadeIn(text_punto_dom_3))\n        self.play(FadeIn(linea_dom_3))\n        self.play(FadeIn(linea_contra_3))\n        self.play(FadeIn(punto_contra_3), FadeIn(text_punto_contra_3))\n        self.play(FadeOut(dom_contra_3))\n        self.wait(0.5)\n        self.play(FadeOut(numberline_1), FadeOut(numberline_2), FadeOut(text_3))\n        self.play(text_puntos.shift, 1.7 * UP)\n        self.setup_axes(animate=True)\n        f = lambda x: 5 - 2 * x\n        graph = self.get_graph(f, color=YELLOW_E, x_min=0, x_max=3)\n        coord_1 = TexMobject('(', '1', ',', '3', ')').scale(0.75).move_to(0.7 * UP + 0.6 * RIGHT)\n        coord_1[1].set_color(BLUE_E)\n        coord_1[3].set_color(RED_E)\n        coord_2 = TexMobject('(', '2', ',', '1', ')').scale(0.75).next_to(coord_1, 1.5 * DOWN)\n        coord_2[1].set_color(BLUE_E)\n        coord_2[3].set_color(RED_E)\n        coord_3 = TexMobject('(', '3', ',', '-1', ')').scale(0.75).next_to(coord_2, 1.5 * DOWN)\n        coord_3[1].set_color(BLUE_E)\n        coord_3[3].set_color(RED_E)\n        pre_coord_1 = VGroup(text_punto_dom_1, text_punto_contra_1)\n        pre_coord_2 = VGroup(text_punto_dom_2, text_punto_contra_2)\n        pre_coord_3 = VGroup(text_punto_dom_3, text_punto_contra_3)\n        punto_graph_1 = Dot(color=GREEN_E).move_to(self.coords_to_point(1, f(1)))\n        punto_graph_2 = Dot(color=GREEN_E).move_to(self.coords_to_point(2, f(2)))\n        punto_graph_3 = Dot(color=GREEN_E).move_to(self.coords_to_point(3, f(3)))\n        puntos_graph = VGroup(punto_graph_1, punto_graph_2, punto_graph_3)\n        self.play(Write(text_4))\n        self.wait(8)\n        self.play(ReplacementTransform(pre_coord_1, coord_1))\n        self.play(FadeIn(punto_graph_1))\n        self.play(coord_1.move_to, self.coords_to_point(0.8, f(1) + 0.5))\n        self.wait(0.5)\n        self.play(ReplacementTransform(pre_coord_2, coord_2))\n        self.play(FadeIn(punto_graph_2))\n        self.play(coord_2.move_to, self.coords_to_point(2.5, f(2) + 0.5))\n        self.play(ReplacementTransform(pre_coord_3, coord_3))\n        self.play(FadeIn(punto_graph_3))\n        self.play(coord_3.move_to, self.coords_to_point(3.8, f(3)))\n        self.play(FadeOut(text_4))\n        self.play(Write(text_5))\n        self.wait(5.375)\n        self.play(Write(text_6))\n        self.wait(8.75)\n        self.play(FadeOut(text_numberline_1), FadeOut(text_numberline_2))\n        self.play(FadeOut(coord_1), FadeOut(coord_2), FadeOut(coord_3))\n        self.play(ShowCreation(graph))\n        self.wait(5)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.wait()\n        self.play(Write(text_7))\n        self.wait(10)\n        self.play(Write(def_1))\n        self.wait(13)\n        self.play(Write(dt))\n        self.wait(13)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])"}]}
{"messages": [{"role": "user", "content": "Create a Manim animation that visually explains directional limits in calculus, covering their definition, how they relate to limits in higher dimensions, a theorem about directional limits, and counterexamples demonstrating when the existence of all directional limits does not guarantee the existence of a limit."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LimitesDireccionales(ThreeDScene):\n\n    def rectangulo_texto(self, objeto):\n        rect = SurroundingRectangle(objeto, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        grupo = VGroup(rect, objeto)\n        return grupo\n\n    def acomodar_textos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.play(Write(objeto))\n\n    def Introduccion(self):\n        t_1 = TextMobject('L\u00edmites Direccionales').scale(1.3)\n        t_2 = TextMobject('Sea $f:D\\\\subseteq \\\\mathbb{R}^n\\\\rightarrow \\\\mathbb{R}^m$, $x_0\\\\in Int(D)$ \\n\\n                            y $u\\\\in \\\\mathbb{R}^n\\\\setminus\\\\{\\\\overline{0}\\\\}$. El l\u00edmite direccional de \\n\\n                            $f$ en $x_0$ en la direcci\u00f3n $u$ es  \\n\\n                            $\\\\lim_{h\\\\rightarrow 0}f(x_0+hu)$, $h\\\\in\\\\mathbb{R}$.')\n        t_3 = TextMobject(\"Recordemos que en $\\\\mathbb{R}$, para obtener el l\u00edmite s\u00f3lo podemos \\n\\n                             aproximarnos por ``la derecha'' y ``la izquierda'' a $x_0$.\")\n        t_4 = TextMobject('Sin embargo, al analizar funciones en $\\\\mathbb{R}^n$, con $n>1$, \\n\\n                             ya no s\u00f3lo poseemos una direcci\u00f3n para aproximarnos a un\\n\\n                             punto, sino que tenemos una infinidad de ellas.')\n        t_5 = TextMobject('Veamos un teorema relacionado con las derivadas direccionales.')\n        t_6 = TextMobject('Teorema: Si existe el l\u00edmite de $f$ en $x_0$, entonces \\n\\n                            existen todos los l\u00edmites direccionales y son iguales.')\n        t_7 = TextMobject('Pero, \u00bfqu\u00e9 significa que para cualquier direcci\u00f3n el l\u00edmite \\n\\n                            exista y sea el mismo?')\n        self.play(Write(t_1))\n        self.wait(3)\n        self.play(ReplacementTransform(t_1, t_2))\n        self.wait(29)\n        self.play(ReplacementTransform(t_2, t_3))\n        self.wait(9)\n        self.play(ReplacementTransform(t_3, t_4))\n        self.wait(11)\n        self.play(ReplacementTransform(t_4, t_5))\n        self.wait(4)\n        self.play(ReplacementTransform(t_5, t_6))\n        self.wait(9)\n        self.play(ReplacementTransform(t_6, t_7))\n        self.wait(5)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n\n    def Ejemplo_Teo(self):\n\n        def act_gr_plano(grafica):\n            te = t.get_value()\n            plano_i.become(ParametricSurface(lambda u, v: np.array([np.cos(te) * u, np.sin(te) * u, v]), u_min=-4, u_max=4, v_min=-0.5, v_max=4, checkerboard_colors=[GREEN_A, GREEN_B], resolution=(15, 64), fill_opacity=0.6))\n\n        def act_gr_par(grafica):\n            te = t.get_value()\n            parabola_i.become(ParametricFunction(lambda x: np.array([np.cos(te) * x, np.sin(te) * x, x ** 2]), t_min=-1.5, t_max=1.5, color=YELLOW, opacity=0.6))\n\n        def act_vec_direc(vector):\n            te = t.get_value()\n            direcu.become(Arrow(start=(0, 0, 0), end=(np.cos(te), np.sin(te), 0), color=YELLOW, buff=0))\n        t_1 = TextMobject('Considera la funci\u00f3n $f:\\\\mathbb{R}^2\\\\rightarrow\\\\mathbb{R}$ \\n\\n                               dada por $f(x,y) = x^2+y^2$')\n        t_2 = TextMobject('Podemos notar que la funci\u00f3n tiene l\u00edmite en $(0,0)$ \\n\\n                               y de hecho el l\u00edmite vale 0.')\n        t_3 = TextMobject('Considera el vector director en $\\\\mathbb{R}^2$ $u=(1,0)$').to_edge(UP).scale(0.7)\n        gpot3 = self.rectangulo_texto(t_3)\n        t_4 = TextMobject('Y el plano en $\\\\mathbb{R}^3$ que contiene a $u$ y es ortogonal \\n\\n                             al plano $xy$').to_edge(UP).scale(0.7)\n        gpot4 = self.rectangulo_texto(t_4)\n        t_5 = TextMobject('La intersecci\u00f3n del plano anterior y la superficie dada por $f$\\n\\n                             es una curva, y sobre esta curva nos aproximamos al punto en el \\n\\n                             que queremos conocer el l\u00edmite, comprobando que el l\u00edmite \\n\\n                             direccional en la direcci\u00f3n $u$ converge a 0.').to_corner(RIGHT + DOWN).scale(0.6)\n        gpot5 = self.rectangulo_texto(t_5)\n        t_6 = TextMobject('Puedes observar que por cualquier direcci\u00f3n que te aproximes\\n\\n                             a $(0,0)$, el l\u00edmite direccional es $0$.').to_corner(RIGHT + DOWN).scale(0.6)\n        gpot6 = self.rectangulo_texto(t_6)\n        axes = ThreeDAxes(x_min=-5, x_max=5, y_min=-5, y_max=5, z_min=-1, z_max=5)\n        x_label = TexMobject('x').scale(0.75).move_to((5.5, 0.3, 0))\n        y_label = TexMobject('y').scale(0.75).move_to((0.3, 5.5, 0))\n        ejes = VGroup(axes, x_label, y_label)\n        direcu = Arrow(start=(0, 0, 0), end=(1, 0, 0), color=YELLOW, buff=0)\n        parabola_i = ParametricFunction(lambda x: np.array([np.cos(0) * x, np.sin(0) * x, x ** 2]), t_min=-1.5, t_max=1.5, color=YELLOW, opacity=0.6)\n        plano_i = ParametricSurface(lambda u, v: np.array([u, 0, v]), u_min=-4, u_max=4, v_min=-0.5, v_max=4, checkerboard_colors=[GREEN_A, GREEN_B], resolution=(15, 64), fill_opacity=0.6)\n        superficie = ParametricSurface(lambda u, v: np.array([u, v, u ** 2 + v ** 2]), u_min=-1.5, u_max=1.5, v_min=-1.5, v_max=1.5, checkerboard_colors=[RED_A, RED_B], resolution=(15, 64))\n        t = ValueTracker(0)\n        self.play(Write(t_1))\n        self.wait(8)\n        self.play(ReplacementTransform(t_1, t_2))\n        self.wait(6)\n        self.play(FadeOut(t_2))\n        self.acomodar_textos(gpot3)\n        self.play(Write(ejes))\n        self.play(ShowCreation(direcu))\n        self.play(FadeOut(gpot3))\n        self.move_camera(phi=80 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 2))\n        self.acomodar_textos(gpot4)\n        self.play(ShowCreation(plano_i))\n        self.wait(2)\n        self.play(ShowCreation(superficie))\n        self.wait(2)\n        self.play(FadeOut(gpot4))\n        self.acomodar_textos(gpot5)\n        self.play(Write(parabola_i))\n        self.remove(gpot5)\n        self.add(gpot5)\n        self.wait(15)\n        self.play(FadeOut(gpot5))\n        self.acomodar_textos(gpot6)\n        self.remove(plano_i)\n        self.remove(parabola_i)\n        self.remove(direcu)\n        plano_i.add_updater(act_gr_plano)\n        parabola_i.add_updater(act_gr_par)\n        direcu.add_updater(act_vec_direc)\n        self.add(plano_i)\n        self.add(parabola_i)\n        self.add(direcu)\n        self.bring_to_back(plano_i)\n        self.bring_to_back(parabola_i)\n        self.bring_to_back(direcu)\n        self.play(t.increment_value, 2 * np.pi, run_time=4)\n        plano_i.remove_updater(act_gr_plano)\n        parabola_i.remove_updater(act_gr_par)\n        direcu.remove_updater(act_vec_direc)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n\n    def Regreso(self):\n\n        def act_gr_direc(linea):\n            te = t.get_value()\n            direc.become(ParametricFunction(lambda x: np.array([np.cos(te) * x, np.sin(te) * x, 0]), t_min=-4, t_max=4).set_color(YELLOW))\n        t_1 = TextMobject('Ahora nos preguntamos, \u00bfSe vale el regreso del teorema?\\n\\n                             NO')\n        gpot1 = self.rectangulo_texto(t_1)\n        t_2 = TextMobject('Considera la funci\u00f3n caracter\u00edstica $\\\\chi:\\\\mathbb{R}^2\\\\rightarrow\\\\mathbb{R}$ \\n\\n                             de la curva $y = x^2$ (vale 1 en los puntos de la curva \\n\\n                             y 0 en lo dem\u00e1s).').to_edge(UP).scale(0.7)\n        gpot2 = self.rectangulo_texto(t_2)\n        t_3 = TextMobject('Observa ahora c\u00f3mo, para toda direcci\u00f3n, la curva amarilla\\n\\n                             siempre converge a 0 cuando tomamos el l\u00edmite en (0,0).').scale(0.6).move_to((0, 3, 0))\n        gpot3 = self.rectangulo_texto(t_3)\n        t_4 = TextMobject('Pero al aproximarnos a (0,0) sobre la curva dada por\\n\\n                             $y=x^2$, el l\u00edmite resulta 1. Debido a esto, la funci\u00f3n \\n\\n                             no tiene l\u00edmite en (0,0).').scale(0.6).move_to((0, 3, 0))\n        gpot4 = self.rectangulo_texto(t_4)\n        t_5 = TextMobject('Sabiendo lo anterior, no caigas en el error de querer\\n\\n                             probar la existencia de un l\u00edmite utilizando que todos \\n\\n                             los l\u00edmites direccionales existen y valen lo mismo.')\n        axes = ThreeDAxes(x_min=-5, x_max=5, y_min=-5, y_max=5, z_min=-1, z_max=4)\n        x_label = TexMobject('x').scale(0.75).move_to((5.5, 0.3, 0))\n        y_label = TexMobject('y').scale(0.75).move_to((0.3, 5.5, 0))\n        ejes = VGroup(axes, x_label, y_label)\n        para_1 = ParametricFunction(lambda x: np.array([x, x ** 2, 1]), t_min=-2, t_max=2).set_color(RED_A)\n        para_2 = ParametricFunction(lambda x: np.array([x, x ** 2, 0]), t_min=-2, t_max=2).set_color(BLACK)\n        func = ParametricSurface(lambda u, v: np.array([u, v, 0]), u_min=-4, u_max=4, v_min=-4, v_max=4, checkerboard_colors=[RED_A, RED_B], resolution=(15, 64), fill_opacity=0.6)\n        direc = ParametricFunction(lambda x: np.array([np.cos(0) * x, np.sin(0) * x, 0]), t_min=-4, t_max=4).set_color(YELLOW)\n        t = ValueTracker(0)\n        self.acomodar_textos(gpot1)\n        self.wait(9)\n        self.play(FadeOut(gpot1))\n        self.move_camera(phi=70 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 1))\n        self.play(Write(ejes))\n        self.acomodar_textos(gpot2)\n        self.play(ShowCreation(func), ShowCreation(para_1), ShowCreation(para_2))\n        self.wait(2)\n        self.play(FadeOut(gpot2))\n        self.acomodar_textos(gpot3)\n        self.remove(direc)\n        direc.add_updater(act_gr_direc)\n        self.add(direc)\n        self.play(t.increment_value, 2 * np.pi, run_time=4)\n        direc.remove_updater(act_gr_direc)\n        self.wait(6)\n        self.play(FadeOut(gpot3), FadeOut(direc))\n        self.acomodar_textos(gpot4)\n        self.wait(11)\n        self.remove(para_1)\n        para_1.set_color(YELLOW)\n        self.add(para_1)\n        self.wait(2)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, frame_center=(0, 0, 0))\n        self.play(Write(t_5))\n        self.wait(9)\n        self.play(FadeOut(t_5))\n\n    def Ejemplo_regreso(self):\n        t_1 = TextMobject('Ahora considera la funci\u00f3n\\n                             $$f(x,y) = \\\\dfrac{xy}{x^2+y^2}$$').shift(UP)\n        t_2 = TextMobject('Y toma los vectores directores ', '$u=(1,0)$', ' y ', '$v=(1,1)$', ' \\n\\n                             para ver el l\u00edmite en $x_0=(0,0)$').next_to(t_1, DOWN)\n        t_2.set_color_by_tex_to_color_map({'$u=(1,0)$': RED, '$v=(1,1)$': YELLOW})\n        t_3 = TextMobject('Vemos que para ', '$u$', ' se tiene\\n                             $$\\\\lim_{h\\\\rightarrow 0}f(x_0+hu)=0$$').to_edge(UP).scale(0.7)\n        t_3.set_color_by_tex_to_color_map({'$u$': RED})\n        gpot3 = self.rectangulo_texto(t_3)\n        t_4 = TextMobject('Mientras que para ', '$v$', ' se tiene\\n                             $$\\\\lim_{h\\\\rightarrow 0}f(x_0+hv)=\\\\frac{1}{2}$$').to_edge(UP).scale(0.7)\n        t_4.set_color_by_tex_to_color_map({'$v$': YELLOW})\n        gpot4 = self.rectangulo_texto(t_4)\n        t_5 = TextMobject('Con lo que puedes concluir que el l\u00edmite de\\n\\n                             $f$ en $(0,0)$ no existe.').to_corner(UP)\n        gpot5 = self.rectangulo_texto(t_5)\n        t_6 = TextMobject('\u00bfPodemos usar los l\u00edmites direccionales \\n\\n                            si $x_0$ est\u00e1 en la frontera del dominio?')\n        axes = ThreeDAxes(x_min=-4, x_max=4, y_min=-4, y_max=4, z_min=-1, z_max=3)\n        x_label = TexMobject('x').scale(0.75).move_to((4.5, 0.3, 0))\n        y_label = TexMobject('y').scale(0.75).move_to((0.3, 4.5, 0))\n        ejes = VGroup(axes, x_label, y_label)\n        direcu = Arrow(start=(0, 0, 0), end=(1, 0, 0), color=RED, buff=0)\n        direcv = Arrow(start=(0, 0, 0), end=(1, 1, 0), color=YELLOW, buff=0)\n        intersecu = ParametricFunction(lambda x: np.array([x, 0, 0]), t_min=-3, t_max=3, color=RED)\n        intersecv = ParametricFunction(lambda x: np.array([x, x, 1 / 2]), t_min=-3, t_max=3, color=YELLOW)\n        superficie_1 = ParametricSurface(lambda u, v: np.array([u, v, u * v / (u ** 2 + v ** 2)]), v_min=-3, v_max=-0.005, u_min=-3, u_max=-0.005, fill_opacity=0.7, checkerboard_colors=[GREEN_A, GREEN_B])\n        superficie_2 = ParametricSurface(lambda u, v: np.array([u, v, u * v / (u ** 2 + v ** 2)]), v_min=-3, v_max=-0.005, u_min=0.005, u_max=3, fill_opacity=0.7, checkerboard_colors=[GREEN_A, GREEN_B])\n        superficie_3 = ParametricSurface(lambda u, v: np.array([u, v, u * v / (u ** 2 + v ** 2)]), v_min=0.005, v_max=3, u_min=-3, u_max=-0.005, fill_opacity=0.7, checkerboard_colors=[GREEN_A, GREEN_B])\n        superficie_4 = ParametricSurface(lambda u, v: np.array([u, v, u * v / (u ** 2 + v ** 2)]), v_min=0.005, v_max=3, u_min=0.005, u_max=3, fill_opacity=0.7, checkerboard_colors=[GREEN_A, GREEN_B])\n        superficie = VGroup(superficie_1, superficie_2, superficie_3, superficie_4)\n        self.play(Write(t_1))\n        self.wait(8)\n        self.play(Write(t_2))\n        self.wait(7)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n        self.move_camera(phi=75 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 1))\n        self.play(Write(ejes))\n        self.play(Write(direcu), Write(direcv))\n        self.play(ShowCreation(superficie))\n        self.acomodar_textos(gpot3)\n        self.play(Indicate(direcu, color=RED, scale_factor=1.5))\n        self.play(Write(intersecu))\n        self.wait(8)\n        self.play(FadeOut(gpot3), FadeOut(intersecu))\n        self.acomodar_textos(gpot4)\n        self.play(Indicate(direcv, scale_factor=1.5))\n        self.play(Write(intersecv))\n        self.wait(2)\n        self.play(FadeOut(gpot4), FadeOut(intersecv))\n        self.acomodar_textos(gpot5)\n        self.wait(4)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, frame_center=(0, 0, 0))\n        self.play(Write(t_6))\n        self.wait(6)\n        self.play(FadeOut(t_6))\n\n    def construct(self):\n        self.Introduccion()\n        self.Ejemplo_Teo()\n        self.Regreso()\n        self.Ejemplo_regreso()"}]}
{"messages": [{"role": "user", "content": "Visualize the level sets of the function $f(x,y) = \\sqrt{x^2+y^2}$ by displaying its surface, planes at different heights, and corresponding circles in 2D."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ConjNiv_R3(ThreeDScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        ThreeDScene.setup(self)\n\n    def construct(self):\n        text_1 = TextMobject('Veamos ahora los conjuntos de nivel de', ' $f(x,y) = \\\\sqrt{x^2+y^2}$').to_edge(DOWN).set_opacity(0)\n        text_1[1].set_color(GOLD_E)\n        text_1.scale(0.9)\n        superficie = ParametricSurface(lambda u, v: np.array([u, v, np.sqrt(u ** 2 + v ** 2)]), v_min=-3, v_max=3, u_min=-3, u_max=3, fill_opacity=0.75, checkerboard_colors=[GOLD_E, GOLD_E], resolution=(80, 80))\n        text_2 = TextMobject('Consideremos', ' $c=2$').to_edge(DOWN).set_opacity(0)\n        text_2[1].set_color(RED)\n        text_3 = TextMobject('Este conjunto estar\u00e1 contenido en $\\\\mathbb{R}^2$').to_edge(DOWN).set_opacity(0)\n        plano_1 = ParametricSurface(lambda u, v: np.array([u, v, 2]), v_min=-3, v_max=3, u_min=-3, u_max=3, fill_color=RED, fill_opacity=0.7, checkerboard_colors=[RED, RED], resolution=(60, 60))\n        circulo_niv2 = ParametricFunction(lambda u: np.array([2 * math.cos(u), 2 * math.sin(u), 2]), color=WHITE, t_min=0, t_max=2 * PI)\n        circulo_niv2_dup = ParametricFunction(lambda u: np.array([2 * math.cos(u), 2 * math.sin(u), 2]), color=WHITE, t_min=0, t_max=2 * PI)\n        circulo_niv2_R2 = ParametricFunction(lambda u: np.array([2 * math.cos(u), 2 * math.sin(u), 0]), color=WHITE, t_min=0, t_max=2 * PI)\n        conjunto_nivel2 = TexMobject('N_2(f) = \\\\{ \\\\vec{x} \\\\in \\\\mathbb{R}^2 \\\\vert \\\\Vert \\\\vec{x} \\\\Vert = 2 \\\\}').shift(2 * UP + 3 * RIGHT).scale(0.7)\n        conjunto_nivel2_short = TexMobject('N_2(f)').shift(1.75 * UP + 1.75 * RIGHT).scale(0.6)\n        text_4 = TextMobject('Repitamos lo anterior ahora con ', '$c = 1$').to_edge(DOWN).set_opacity(0)\n        text_4[1].set_color(RED)\n        plano_2 = ParametricSurface(lambda u, v: np.array([u, v, 1]), v_min=-3, v_max=3, u_min=-3, u_max=3, fill_color=RED, fill_opacity=0.5, checkerboard_colors=[RED, RED], resolution=(60, 60))\n        circulo_niv1 = ParametricFunction(lambda u: np.array([1 * math.cos(u), 1 * math.sin(u), 1]), color=WHITE, t_min=0, t_max=2 * PI)\n        circulo_niv1_dup = ParametricFunction(lambda u: np.array([1 * math.cos(u), 1 * math.sin(u), 1]), color=WHITE, t_min=0, t_max=2 * PI)\n        circulo_niv1_R2 = ParametricFunction(lambda u: np.array([1 * math.cos(u), 1 * math.sin(u), 0]), color=WHITE, t_min=0, t_max=2 * PI)\n        conjunto_nivel1 = TexMobject('N_1(f) = \\\\{ \\\\vec{x} \\\\in \\\\mathbb{R}^2 \\\\vert \\\\Vert \\\\vec{x} \\\\Vert = 1 \\\\}').shift(2 * DOWN + 3 * RIGHT).scale(0.7)\n        conjunto_nivel1_short = TexMobject('N_1(f)').shift(UP + RIGHT).scale(0.6)\n        text_5 = TextMobject('\u00a1Los conjuntos de nivel nos ayudan a esbozar la gr\u00e1fica!').to_edge(DOWN).set_opacity(0).scale(0.8)\n        axes = ThreeDAxes(x_min=-4, x_max=4, y_min=-4, y_max=4, z_min=-2, z_max=4, num_axis_pieces=40)\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES, distance=100)\n        self.add_fixed_in_frame_mobjects(text_1)\n        self.play(text_1.set_opacity, 1, runtime=2)\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie))\n        self.wait(5.5)\n        self.play(FadeOut(text_1))\n        self.add_fixed_in_frame_mobjects(text_2)\n        self.play(text_2.set_opacity, 1, runtime=2)\n        self.play(ShowCreation(plano_1))\n        self.wait(2)\n        self.move_camera(phi=90 * DEGREES, theta=-90 * DEGREES, frame_center=(0.1, 0, 1))\n        self.play(FadeOut(text_2))\n        self.add_fixed_in_frame_mobjects(text_3)\n        self.play(text_3.set_opacity, 1, runtime=2)\n        self.wait(4)\n        self.play(FadeOut(text_3))\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, run_time=2)\n        self.play(ShowCreation(circulo_niv2), runtime=2)\n        self.move_camera(phi=75 * DEGREES, theta=-45 * DEGREES, distance=100, run_time=2)\n        self.play(ReplacementTransform(circulo_niv2_dup, circulo_niv2_R2))\n        self.add_foreground_mobjects(superficie)\n        self.play(Write(conjunto_nivel2))\n        self.play(FadeOut(superficie), FadeOut(plano_1), FadeOut(circulo_niv2), FadeOut(circulo_niv2_dup))\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, run_time=2)\n        self.wait(5.5)\n        self.play(ReplacementTransform(conjunto_nivel2, conjunto_nivel2_short))\n        self.move_camera(phi=75 * DEGREES, theta=-45 * DEGREES, distance=100, run_time=2)\n        self.play(ShowCreation(superficie))\n        self.add_fixed_in_frame_mobjects(text_4)\n        self.play(text_4.set_opacity, 1, runtime=2)\n        self.play(ShowCreation(plano_2))\n        self.wait(4)\n        self.play(FadeOut(text_4))\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, run_time=3)\n        self.play(ShowCreation(circulo_niv1), runtime=2)\n        self.wait()\n        self.move_camera(phi=75 * DEGREES, theta=-45 * DEGREES, distance=100, run_time=3)\n        self.play(ReplacementTransform(circulo_niv1_dup, circulo_niv1_R2))\n        self.play(FadeOut(superficie), FadeOut(plano_2), FadeOut(circulo_niv1), FadeOut(circulo_niv1_dup))\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES, run_time=3)\n        self.play(Write(conjunto_nivel1_short))\n        self.wait(4)\n        self.move_camera(phi=75 * DEGREES, theta=-45 * DEGREES, distance=100, run_time=3)\n        self.play(ShowCreation(superficie), ShowCreation(circulo_niv1), ShowCreation(circulo_niv2))\n        self.add_fixed_in_frame_mobjects(text_5)\n        self.play(text_5.set_opacity, 1, runtime=2)\n        self.wait(4)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of a limit of a function from R to R^n as x approaches infinity with a 3D plot and accompanying mathematical explanations."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Limites2(ThreeDScene):\n\n    def construct(self):\n        titulo2 = TextMobject('Existencia del L\u00edmite en Infinito de \\n\\n                            Funciones de $\\\\mathbb{R}\\\\rightarrow\\\\mathbb{R}^{n}$')\n        texto = TextMobject('Sea $f:\\\\mathbb{R}\\\\rightarrow\\\\mathbb{R}^{n}$')\n        texto1 = TexMobject(' \\\\lim_{x \\\\to \\\\infty}f(x)=\\\\vec{L}\\\\leftrightarrow\\\\forall \\\\ \\\\epsilon>0')\n        texto1_1 = TextMobject('$\\\\exists \\\\ M\\\\in\\\\mathbb{R}$ tal que $x>M \\\\ \\\\implies ||f(x)-\\\\vec{L}||<\\\\epsilon$').move_to(texto1.get_center() + 0.8 * DOWN)\n        texto1_2 = TextMobject('Veamos el siguiente ejemplo')\n        texto1_3 = TextMobject('$f$', '$:\\\\mathbb{R}^{+}\\\\rightarrow\\\\mathbb{R}^{2}$ \\n', '$f(x)=(\\\\frac{1}{x^{3}},\\\\frac{1}{x^{3}})$')\n        texto1_3[0].set_color(BLUE_C)\n        texto1_3[2].set_color(BLUE_C)\n        self.play(Write(titulo2.scale(1.5)))\n        self.wait(6)\n        self.play(FadeOut(titulo2))\n        self.play(Write(texto))\n        self.wait(4.25)\n        self.play(texto.shift, 1.2 * UP, runtime=1.5)\n        self.play(Write(texto1))\n        self.wait(6.125)\n        self.play(Write(texto1_1))\n        self.wait(8)\n        self.play(FadeOut(texto1), FadeOut(texto1_1), FadeOut(texto))\n        self.wait()\n        self.play(Write(texto1_2))\n        self.wait(3.5)\n        self.play(FadeOut(texto1_2))\n        self.play(Write(texto1_3))\n        self.wait(6.125)\n        self.play(FadeOut(texto1_3))\n        self.wait()\n        self.custom_method()\n\n    def custom_method(self):\n        axes = ThreeDAxes()\n        axes.add(axes.get_x_axis_label('t'))\n        surface2 = superficie2()\n        texto2 = TextMobject('Tomemos', '  $\\\\epsilon$=0.8')\n        texto2[1].set_color(RED)\n        texto2.to_corner(UL)\n        texto3 = TextMobject('Los puntos dentro del c\u00edrculo \\n\\n            en el plano yz est\u00e1n a una \\n\\n            distancia 0.8 del $\\\\vec{0}$\\n del plano yz')\n        texto3.move_to(3.6 * LEFT + 3 * UP)\n        text_4_1 = TextMobject('Veamos que hay un punto').move_to(3.6 * LEFT + 3.5 * UP)\n        text_4_2 = TextMobject('en x desde el cual ', '$f(x)$').next_to(text_4_1, DOWN)\n        text_4_2[1].set_color(BLUE_C)\n        text_4_3 = TextMobject('est\u00e1 a una distancia menor').next_to(text_4_2, DOWN)\n        text_4_4 = TextMobject('que ', '$\\\\epsilon$', ' del $\\\\Vec{0}$ del plano yz').next_to(text_4_3, DOWN)\n        text_4_4[1].set_color(RED)\n        texto4 = VGroup(text_4_1, text_4_2, text_4_3, text_4_4)\n        texto4_1 = TextMobject('Es posible hacer lo mismo \\n\\n            con cualquier ', '$\\\\epsilon$', '$>0$')\n        texto4_1[1].set_color(RED)\n        texto4_1.to_corner(UL)\n        texto5 = TextMobject('Por lo cual notaremos que \\n \\n            la funci\u00f3n tiene l\u00edmite cuando \\n  \\n            $x\\\\rightarrow \\\\infty$ y es (0,0)')\n        texto5.to_corner(UL)\n        texto6 = TextMobject('\u00bfSe te ocurre c\u00f3mo modificar la definici\u00f3n \\n\\n                    anterior cuando el l\u00edmite es con\\n\\n                     la variable tendiendo a $-\\\\infty$?')\n        r = 0.8\n        r1 = 0.4\n        circulo = Circle(radius=r)\n        circulo.rotate(PI / 2, axis=UP)\n        circulo1 = Circle(radius=r1).move_to(1.8 * RIGHT)\n        circulo1.rotate(PI / 2, axis=UP)\n        plano = Rectangle(height=2, width=3, fill_color=YELLOW_C, fill_opacity=0.3)\n        plano.move_to(0.5 * RIGHT)\n        plano.rotate(PI / 2, axis=UP)\n        self.set_camera_orientation(0.8 * np.pi / 2, -0.25 * np.pi, distance=10)\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(surface2))\n        self.wait()\n        self.move_camera(phi=80 * DEGREES, theta=0)\n        self.begin_ambient_camera_rotation(rate=0.001)\n        self.add_fixed_in_frame_mobjects(texto2)\n        self.play(Write(texto2))\n        self.wait(3.5)\n        self.play(ShowCreation(circulo))\n        self.play(FadeOut(texto2))\n        self.add_fixed_in_frame_mobjects(texto3)\n        self.play(Write(texto3))\n        self.wait(9.125)\n        self.play(FadeOut(texto3))\n        self.move_camera(phi=80 * DEGREES, theta=-PI / 8, rate=0.2)\n        self.play(circulo.shift, 1.8 * RIGHT, runtime=3)\n        self.add_fixed_in_frame_mobjects(texto4)\n        self.play(Write(texto4))\n        self.wait(9.875)\n        self.play(FadeOut(texto4))\n        self.add_fixed_in_frame_mobjects(texto4_1)\n        self.play(Write(texto4_1))\n        self.wait(5.75)\n        self.play(ReplacementTransform(circulo, circulo1))\n        self.play(circulo1.shift, 2 * RIGHT, runtime=3)\n        self.wait()\n        self.play(FadeOut(texto4_1))\n        self.add_fixed_in_frame_mobjects(texto5)\n        self.play(Write(texto5))\n        self.wait(8.375)\n        self.play(FadeOut(texto5), FadeOut(circulo1), FadeOut(axes), FadeOut(surface2))\n        self.add_fixed_in_frame_mobjects(texto6)\n        self.play(Write(texto6))\n        self.wait(7.625)\n        self.play(FadeOut(texto6))"}]}
{"messages": [{"role": "user", "content": "Present the mathematical definition of a function diverging to infinity in R^n, illustrate it with a 2D example of f(x,y) = 1/(x+y) approaching (0,0), and visualize the concept with a 3D surface and a highlighting sphere."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LimitesR2_a_R_1(ThreeDScene):\n\n    def construct(self):\n        titulo = TextMobject('Divergencia a Infinito de Funciones de\\n\\n                                $\\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R}$\\n\\n                                en un Punto $a$').scale(1.5)\n        text = TextMobject(' En el caso de funciones de:\\n\\n                            $\\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R},$')\n        text_1 = TextMobject('donde $n\\\\in\\\\lbrace 1,2,3...\\\\rbrace$').move_to(text.get_center() + 1 * DOWN)\n        G1 = VGroup(text, text_1)\n        Def = TextMobject('Sea una funci\u00f3n $f:D\\\\subseteq\\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R}$').shift(1.5 * UP)\n        Def1 = TextMobject('Y sea $\\\\vec{a}\\\\in D$').shift(0.6 * UP)\n        Def2 = TexMobject(' \\\\lim_{x \\\\to \\\\vec{a}}f(\\\\vec{x})=\\\\infty\\\\iff\\\\forall M\\\\in\\\\mathbb{R}').shift(0.5 * DOWN)\n        Def3 = TextMobject('$\\\\exists \\\\ \\\\delta>0$ tal que si $\\\\vec{x}\\\\in \\\\left( B_{\\\\delta}(\\\\vec{a})\\\\setminus\\\\vec{a}\\\\right) \\\\cap\\n                                D\\\\implies f(\\\\vec{x})>M$').shift(1.5 * DOWN)\n        text_2 = TextMobject('Veamos el siguiente ejemplo')\n        text1 = TexMobject('f:D\\\\subset\\\\mathbb{R}^2\\\\rightarrow\\\\mathbb{R}').shift(2.5 * UP)\n        text1_1 = TexMobject('D=\\\\lbrace (x,y)|x,y\\\\in\\\\mathbb{R}^{+}-\\\\lbrace 0 \\\\rbrace \\\\rbrace').shift(1.25 * UP)\n        text2 = TexMobject('f(x,y)=\\\\frac{1}{x+y}').shift(-0.1 * UP)\n        text3 = TextMobject('Veamos el l\u00edmite cuando:').shift(-1 * UP)\n        text4 = TextMobject('(x,y)$\\\\rightarrow\\\\vec{0}=(0,0)$').shift(-1.8 * UP)\n        self.play(Write(titulo))\n        self.wait(6.5)\n        self.play(FadeOut(titulo))\n        self.play(Write(text))\n        self.play(Write(text_1))\n        self.wait(6.5)\n        self.play(FadeOut(G1))\n        self.play(Write(Def))\n        self.play(Write(Def1))\n        self.play(Write(Def2))\n        self.play(Write(Def3))\n        self.wait(19)\n        self.play(FadeOut(Def), FadeOut(Def1), FadeOut(Def2), FadeOut(Def3))\n        self.play(Write(text_2))\n        self.wait()\n        self.play(FadeOut(text_2))\n        self.play(Write(text1))\n        self.play(Write(text1_1))\n        self.play(Write(text2))\n        self.wait()\n        self.play(Write(text3))\n        self.wait()\n        self.play(Write(text4))\n        self.wait(16)\n        self.play(FadeOut(text4), FadeOut(text3), FadeOut(text2), FadeOut(text1_1), FadeOut(text1))\n        self.wait()\n        self.custom_method()\n\n    def custom_method(self):\n        axes = ThreeDAxes()\n        surface = ThreeDSurface()\n        text4 = TextMobject('Tomemos  M=1')\n        M = TextMobject('M').move_to(1 * UP + 0.3 * LEFT)\n        text4.to_corner(UL)\n        text5 = TextMobject('Si tomamos', ' $\\\\delta=0.5$')\n        text5[1].set_color('#88FF00')\n        text5.to_corner(UL)\n        text6 = TextMobject('La imagen de los puntos en D  \\n\\n                            y la bola son mayores a 1')\n        text6.to_corner(UL)\n        text7 = TextMobject('Es posible verificar lo anterior \\n\\n                            a trav\u00e9s de operaciones\\n\\n                            algebraicas.')\n        text7.to_corner(UL)\n        text8 = TextMobject('Puedes visualizar con mejor detalle la gr\u00e1fica \\n\\n                                de la funci\u00f3n anterior en el notebook anexo, as\u00ed\\n\\n                                como modificar los valores de M')\n        r = 0.5\n        linea = Line((0, 0, 0), (0.5 * np.cos(np.pi / 4), 0.5 * np.sin(np.pi / 4), 0), stroke_width=4, color='#88FF00')\n        bola = Circle(radius=r, color=PURPLE, fill_opacity=1)\n        text5_1 = TexMobject('\\\\delta').move_to(bola.get_center() + 0.7 * UP + 0.7 * RIGHT)\n        text5_1.set_color('#88FF00')\n        linea1 = Line((0, 0, 1), (0.5, 0.5, 1), stroke_width=6, color=PURPLE_D)\n        linea2 = Line((0.5 * np.cos(np.pi / 4), 0.5 * np.sin(np.pi / 4), 0), (0.5 * np.cos(np.pi / 4), 0.5 * np.sin(np.pi / 4), 1 / (r * (2 * np.cos(np.pi / 4)))), stroke_width=6, color=RED)\n        lineaZ = Line((0, 0, 1), (0, 0, 3.2), stroke_width=7, color=PURPLE)\n\n        def puntosEnSuperficie(rad):\n            puntos = []\n            for i in range(2000):\n                azar = np.random.rand(1, 2)\n                if 0.1 < np.sqrt(azar[0][0] ** 2 + azar[0][1] ** 2) < rad:\n                    puntos.append(Dot(surface.func(azar[0][0], azar[0][1]), radius=0.05, color=PURPLE))\n            return puntos\n        puntos = puntosEnSuperficie(r)\n        grupo = VGroup(*puntos)\n        self.set_camera_orientation(0.8 * np.pi / 2, -0.25 * np.pi, distance=4)\n        self.add(axes)\n        self.play(ShowCreation(surface))\n        self.begin_ambient_camera_rotation(rate=0.001)\n        self.wait()\n        self.add_fixed_in_frame_mobjects(text4)\n        self.play(Write(text4))\n        self.add_fixed_in_frame_mobjects(M)\n        self.wait()\n        self.play(FadeOut(text4))\n        self.play(ShowCreation(bola))\n        self.wait()\n        self.add_fixed_in_frame_mobjects(text5)\n        self.play(Write(text5))\n        self.play(ShowCreation(linea), Write(text5_1))\n        self.wait()\n        self.play(FadeOut(text5))\n        self.play(FadeOut(linea), FadeOut(text5_1))\n        self.add_fixed_in_frame_mobjects(text6)\n        self.play(Write(text6))\n        self.play()\n        self.play(ShowCreation(lineaZ))\n        self.play(FadeIn(grupo))\n        self.wait(5.75)\n        self.play(FadeOut(text6))\n        self.add_fixed_in_frame_mobjects(text7)\n        self.play(Write(text7))\n        self.wait(5.7)\n        self.play(FadeOut(text7), FadeOut(axes), FadeOut(lineaZ), FadeOut(surface), FadeOut(bola), FadeOut(M), FadeOut(grupo))\n        self.add_fixed_in_frame_mobjects(text8)\n        self.play(Write(text8))\n        self.wait(13)\n        self.play(FadeOut(text8))"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of a function diverging to infinity as its input approaches infinity in n-dimensional space by visualizing a paraboloid and highlighting points outside a specific radius."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LimitesRnaR(ThreeDScene):\n\n    def construct(self):\n        titulo = TextMobject('Divergencia a Infinito de Funciones \\n\\n                            de $\\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R}$ en Infinito').scale(1.5)\n        text1 = TextMobject('Sea $f:\\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R}$').move_to(2 * UP)\n        text2 = TexMobject('l\u00edm_{\\\\vec{x}\\\\rightarrow\\\\infty}f(\\\\vec{x})=\\\\infty^{+} \\\\leftrightarrow\\\\forall\\\\ M\\\\in\\\\mathbb{R}').move_to(0.8 * UP)\n        text3 = TextMobject('$\\\\exists\\\\delta>0$ tal que si $\\\\vec{x}\\\\in B^{c}_{\\\\delta}(\\\\vec{0})$ ').move_to(0.5 * DOWN)\n        text4 = TexMobject('\\\\implies f(\\\\vec{x})>M').move_to(1.6 * DOWN)\n        text5 = TextMobject('Veamos el siguiente ejemplo para aterrizar lo anterior.')\n        text6 = TextMobject('Tomemos el paraboloide:\\n\\n                                $f(x,y)=y^{2}+x^{2}-1$')\n        self.play(Write(titulo))\n        self.wait(5.3)\n        self.play(FadeOut(titulo))\n        self.play(Write(text1))\n        self.play(Write(text2))\n        self.play(Write(text3))\n        self.play(Write(text4))\n        self.wait(8)\n        self.play(FadeOut(text1), FadeOut(text2), FadeOut(text3), FadeOut(text4))\n        self.play(Write(text5))\n        self.wait(5)\n        self.play(FadeOut(text5))\n        self.play(Write(text6))\n        self.wait(3.8)\n        self.play(FadeOut(text6))\n        self.custom_method()\n\n    def custom_method(self):\n        axes = ThreeDAxes()\n        superficie = superficie3()\n        superficie.set_opacity(0.8)\n        text1 = TexMobject('f(x,y)=y^{2}+x^{2}-1')\n        text1.to_corner(UL)\n        text2 = TextMobject('Tomemos M=0')\n        text2.to_corner(UL)\n        text3 = TextMobject('Tomamos $\\\\delta$')\n        text3.to_corner(UL)\n        text4 = TextMobject('Veremos que la imagen de los puntos que no \\n\\n                            est\u00e1n en la bola, son mayor a M')\n        text4.to_corner(UL)\n        text5 = TextMobject('Podemos realizar lo mismo con cualquier M$\\\\in\\\\mathbb{R}$')\n        text5.to_corner(UL)\n        text6 = TextMobject('Por lo cual notaremos que la funci\u00f3n diverge a $+\\\\infty$ \\n\\n                             cuando $\\\\vec{x}\\\\rightarrow\\\\infty$.')\n        text6.to_corner(UL)\n        M = 0\n        r = M + 1.4\n        M1 = -0.5\n        r1 = M1 + 1.5\n        bola1 = Circle(radius=r1, color=RED, color_opacity=1)\n        bola = Circle(radius=r, color=RED, color_opacity=1).move_to(M * OUT)\n        linealabel = TexMobject('\\\\delta').next_to(bola, RIGHT, buff=0.5).set_color(RED_C).rotate(PI / 2, axis=RIGHT).scale(2)\n        linea = Line((0, 0, 0), (r, 0, 0), stroke_width=3, color=RED_C)\n\n        def puntosEnSuperficie(rad, lim, num):\n            puntosDom = []\n            puntosSur = []\n            for i in range(num):\n                azar = np.random.uniform(-lim, lim, (1, 2))[0]\n                if rad < np.sqrt(azar[0] ** 2 + azar[1] ** 2) and (not (azar[0] < 0 and azar[1] > 0)):\n                    puntosDom.append(Dot(np.array([azar[0], azar[1], 0]), color=PURPLE))\n                    puntosSur.append(Dot(superficie.func(azar[0], azar[1]), color=RED))\n            return (puntosDom, puntosSur)\n        puntosD1, puntosS1 = puntosEnSuperficie(r, 3, 6000)\n        puntosD2, puntosS2 = puntosEnSuperficie(r1, r, 3000)\n        GPuntosD1 = VGroup(*puntosD1)\n        GPuntosS1 = VGroup(*puntosS1)\n        GPuntosD2 = VGroup(*puntosD2)\n        GPuntosS2 = VGroup(*puntosS2)\n        self.set_camera_orientation(0.8 * np.pi / 2, -0.25 * np.pi, distance=15)\n        self.begin_ambient_camera_rotation(rate=0.001)\n        self.play(ShowCreation(axes))\n        self.add_fixed_in_frame_mobjects(text1)\n        self.play(Write(text1))\n        self.play(ShowCreation(superficie))\n        self.wait(2)\n        self.play(FadeOut(text1))\n        self.add_fixed_in_frame_mobjects(text2)\n        self.play(Write(text2))\n        self.wait(2.75)\n        self.play(FadeOut(text2))\n        self.add_fixed_in_frame_mobjects(text3)\n        self.play(Write(text3))\n        self.play(ShowCreation(linea))\n        self.play(Write(linealabel))\n        self.play(ShowCreation(bola))\n        self.play(FadeOut(linea), FadeOut(linealabel))\n        self.play(FadeOut(text3))\n        self.add_fixed_in_frame_mobjects(text4)\n        self.play(Write(text4))\n        self.play(FadeIn(GPuntosD1))\n        self.play(FadeIn(GPuntosS1))\n        self.wait(8.3)\n        self.play(FadeOut(text4))\n        self.add_fixed_in_frame_mobjects(text5)\n        self.play(Write(text5))\n        self.play(ReplacementTransform(bola, bola1))\n        self.wait()\n        self.play(FadeIn(GPuntosD2))\n        self.play(FadeIn(GPuntosS2))\n        self.wait(4.6)\n        self.play(FadeOut(text5))\n        self.add_fixed_in_frame_mobjects(text6)\n        self.play(Write(text6))\n        self.wait(6.5)\n        self.play(FadeOut(axes), FadeOut(text6), FadeOut(superficie), FadeOut(bola1), FadeOut(GPuntosD1), FadeOut(GPuntosS1), FadeOut(GPuntosD2), FadeOut(GPuntosS2))"}]}
{"messages": [{"role": "user", "content": "Animate a 3D plot illustrating the divergence of a function to infinity with accompanying mathematical definitions and visual aids that change over time."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Limites_Al_Infinito(ThreeDScene):\n\n    def cur_1(self, t):\n        return np.array([t, t * np.sin(5 * t), -np.exp(t / 2) * np.cos(5 * t)])\n\n    def construct(self):\n        titulo = TextMobject('Divergencia a Infinito de Funciones de \\n\\n            $\\\\mathbb{R}\\\\rightarrow\\\\mathbb{R}^{n}$ en Infinito')\n        definicion_1 = TextMobject('Sea $f: \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}^{n}$')\n        definicion_2 = TextMobject('$$\\\\implies \\\\ \\\\lim_{t \\\\rightarrow  \\\\infty} f(t) = \\\\vec{\\\\infty} \\\\Leftrightarrow  \\\\forall \\\\: M >0$$')\n        definicion_3 = TextMobject('$\\\\exists$ $\\\\delta >0$ tal que si $ t> \\\\delta$ \\n \\n            $\\\\implies \\\\ \\\\Vert f(t) \\\\Vert > M$').move_to(definicion_2.get_center() + 0.9 * DOWN)\n        self.play(Write(titulo.scale(1.5)))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.play(Write(definicion_1))\n        self.wait(2.5)\n        self.play(definicion_1.shift, 1.2 * UP, runtime=1.5)\n        self.play(Write(definicion_2))\n        self.wait(6.5)\n        self.play(Write(definicion_3))\n        self.wait(7.6)\n        self.play(FadeOut(definicion_2), FadeOut(definicion_3), FadeOut(definicion_1))\n        self.wait()\n        self.custom_method()\n\n    def custom_method(self):\n        t_1 = TextMobject('Por ejemplo:')\n        t_2 = TextMobject('$f(t) = (t \\\\sin(5t),- e^{\\\\frac{t}{2}} \\\\cos(5t))$')\n        t_2.set_color(TEAL)\n        t_3 = TextMobject('Cuando  $t \\\\rightarrow \\\\infty$')\n        t_4 = TextMobject('Vemos que  $\\\\forall$', ' $M$', '$>0$')\n        t_4[1].set_color(YELLOW)\n        t_5 = TextMobject('Si $t > $  ', '$\\\\delta$ ', ' adecuada')\n        t_5[1].set_color(RED)\n        t_6 = TextMobject('Notamos que \\n \\n        $ \\\\Vert $', '$f(t)$', '$ \\\\Vert > $', '$  M$')\n        t_6[1].set_color(TEAL)\n        t_6[3].set_color(YELLOW)\n        t_7 = TextMobject('$\\\\forall$', ' $M $', '$> 0$')\n        t_7[1].set_color(YELLOW)\n        t_8 = TextMobject('\u00bfQu\u00e9 crees que sucede cuando $t \\\\rightarrow - \\\\infty$?')\n        t_1.to_corner(UL)\n        t_2.to_corner(UL)\n        t_3.to_corner(UL)\n        t_4.to_corner(UL)\n        t_5.to_corner(UL)\n        t_6.to_corner(UL)\n        t_7.to_corner(UL)\n        axes = ThreeDAxes(x_min=-5.5, x_max=5.5, z_min=-5.5, z_max=40, num_axis_pieces=50)\n        axes.add(axes.get_x_axis_label('t'))\n        curve_1 = ParametricFunction(self.cur_1, color=TEAL, t_min=-5, t_max=5)\n        M = Line(np.array([0, 0, 0]), np.array([0, -1 / np.sqrt(2), 1 / np.sqrt(2)]), stroke_width=8, color=YELLOW).move_to(np.array([1, -1 / (2 * np.sqrt(2)), 1 / (2 * np.sqrt(2))]))\n        m = TextMobject('$M$').rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(M.get_center() + np.array([0, -0.5, 0.5])).set_color(YELLOW)\n        Delta = Line(np.array([0, 0, 0]), np.array([1, 0, 0]), stroke_width=8, color=RED).move_to(np.array([0.5, 0, 0]))\n        delta = TextMobject('$\\\\delta$').rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(Delta.get_center() + np.array([0.5, 0.5, 0])).set_color(RED)\n        Bola = Circle(radius=1, color=YELLOW).rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(np.array([1, 0, 0]))\n        Group = VGroup(M, m, Delta, delta, Bola)\n        Group_1 = VGroup(curve_1)\n        Group_2 = VGroup(M, m)\n        Group_3 = VGroup(Delta, delta)\n        x = ValueTracker(1)\n\n        def update_group(Group):\n            M, m, Delta, delta, Bola = Group\n            M_new = Line(np.array([0, 0, 0]), np.array([0, -x.get_value() / np.sqrt(2), x.get_value() / np.sqrt(2)]), stroke_width=8, color=YELLOW).move_to(np.array([x.get_value(), -x.get_value() / (2 * np.sqrt(2)), x.get_value() / (2 * np.sqrt(2))]))\n            M.become(M_new)\n            m.move_to(M_new.get_center() + np.array([0, -x.get_value() / np.sqrt(2), x.get_value() / np.sqrt(2)]))\n            Delta_new = Line(np.array([0, 0, 0]), np.array([x.get_value(), 0, 0]), stroke_width=8, color=RED).move_to(np.array([x.get_value() / 2, 0, 0]))\n            Delta.become(Delta_new)\n            delta.move_to(Delta_new.get_center() + np.array([0.5, 0.5, 0]))\n            Bola_new = Circle(radius=x.get_value(), color=YELLOW).rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(np.array([x.get_value(), 0, 0]))\n            Bola.become(Bola_new)\n            return Group\n        self.begin_ambient_camera_rotation(rate=0.12)\n        self.add_fixed_in_frame_mobjects(t_1)\n        self.play(Write(t_1))\n        self.wait(2.75)\n        self.play(FadeOut(t_1))\n        self.add(axes)\n        self.set_camera_orientation(phi=65 * DEGREES, theta=-90 * DEGREES)\n        self.play(LaggedStart(ShowCreation(Group_1)))\n        self.wait(2)\n        self.add_fixed_in_frame_mobjects(t_2)\n        self.play(Write(t_2))\n        self.wait(6)\n        self.play(FadeOut(t_2))\n        self.add_fixed_in_frame_mobjects(t_3)\n        self.play(Write(t_3))\n        self.wait(3.5)\n        self.play(FadeOut(t_3))\n        self.add_fixed_in_frame_mobjects(t_4)\n        self.play(Write(t_4))\n        self.wait(4.2)\n        self.add(Group_2)\n        self.wait()\n        self.play(FadeOut(t_4))\n        self.wait()\n        self.add_fixed_in_frame_mobjects(t_5)\n        self.play(Write(t_5))\n        self.wait(3.8)\n        self.add(Group_3)\n        self.wait()\n        self.play(FadeOut(t_5))\n        self.add(Bola)\n        self.add_fixed_in_frame_mobjects(t_6)\n        self.play(Write(t_6))\n        self.wait(4.2)\n        self.play(FadeOut(t_6))\n        self.wait()\n        self.add_fixed_in_frame_mobjects(t_7)\n        self.play(Write(t_7))\n        self.wait(3.5)\n        Group.add_updater(update_group)\n        self.add(Group)\n        self.play(x.increment_value, 2, rate_func=linear, run_time=10)\n        self.wait()\n        self.play(FadeOut(t_7))\n        self.play(FadeOut(Group))\n        self.play(FadeOut(Group_1), FadeOut(axes))\n        self.add_fixed_in_frame_mobjects(t_8)\n        self.play(Write(t_8))\n        self.wait(5)\n        self.play(FadeOut(t_8))"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of limits of functions from R^n to R^m with visual examples of a parametric curve and a surface, demonstrating the epsilon-delta definition."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Existencia_Limites(ThreeDScene):\n\n    def cur(self, t):\n        return np.array([t, t ** 2, t ** 3])\n\n    def sur(self, x, y):\n        return np.array([x, y, 1 / (1 + x ** 2 + y ** 2)])\n\n    def construct(self):\n        titulo = TextMobject('Existencia del L\u00edmite de Funciones de \\n\\n            $\\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R}^{m}$ en $\\\\vec{x}_0$')\n        definicion_1 = TextMobject('Sean $f:A \\\\subset \\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R}^{m}$ y $\\\\vec{x}_0 \\\\in A^{\\\\prime} $. ')\n        definicion_2 = TextMobject('Decimos que $f$ tiene l\u00edmite en $\\\\vec{x}_0$ y  que su l\u00edmite es $\\\\vec{l} \\\\in \\\\mathbb{R}^{m}$, ')\n        definicion_3 = TextMobject('si $\\\\forall$ $\\\\epsilon > 0$ $\\\\exists$ $\\\\delta>0$ tal que si $\\\\Vert  \\\\vec{x} - \\\\vec{x}_0 \\\\Vert  < \\\\delta$ y $\\\\vec{x} \\\\in A \\\\setminus  \\\\{\\\\vec{x}_0\\\\}$, ').move_to(definicion_2.get_center() + 0.8 * DOWN)\n        definicion_4 = TextMobject(' entonces $\\\\Vert f(\\\\vec{x}) - \\\\vec{l} \\\\Vert < \\\\epsilon$').move_to(definicion_3.get_center() + 0.8 * DOWN)\n        self.play(Write(titulo.scale(1.5)))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.play(Write(definicion_1))\n        self.wait(6.87)\n        self.play(definicion_1.shift, 1.2 * UP, runtime=1.5)\n        self.play(Write(definicion_2))\n        self.wait(8)\n        self.play(Write(definicion_3))\n        self.wait(11)\n        self.play(Write(definicion_4))\n        self.wait(4.62)\n        self.play(FadeOut(definicion_2), FadeOut(definicion_3), FadeOut(definicion_4), FadeOut(definicion_1))\n        self.wait()\n        self.custom_method()\n\n    def custom_method(self):\n        t_1 = TextMobject('Por ejemplo, consideremos la siguiente funci\u00f3n:')\n        t_2 = TextMobject('$f(t) = (t^2, t^3)$')\n        t_2[0].set_color(RED)\n        t_3 = TextMobject('Veamos el l\u00edmite cuando \\n  \\n        $ t \\\\rightarrow 0$')\n        t_4 = TextMobject('Tomamos de forma \\n  \\n        arbitraria ', ' $\\\\epsilon$', '$> 0$')\n        t_4[1].set_color(BLUE)\n        t_5 = TextMobject('Y observamos gr\u00e1ficamente \\n\\n        que $\\\\exists$ ', ' $\\\\delta$', '$> 0$')\n        t_5[1].set_color('#88FF00')\n        t_6 = TextMobject('tal que se cumple \\n \\n        la definci\u00f3n \\n\\n        de limite cuando $ t \\\\rightarrow 0$ ')\n        t_7 = TextMobject('Veamos que esto se \\n\\n        sigue cumpliendo con valores \\n \\n        m\u00e1s peque\u00f1os de ', '$\\\\epsilon$ ')\n        t_7[1].set_color(BLUE)\n        t_8 = TextMobject('$\\\\displaystyle \\\\therefore \\\\lim_{t \\\\to 0}$', ' $f(t) = \\\\vec{0} $')\n        t_8[1].set_color(RED)\n        t_9 = TextMobject('Ahora consideremos \\n \\n        esta otra funci\u00f3n')\n        t_10 = TextMobject('$g(x,y) = \\\\frac{1}{1 + x^2 + y^2}$')\n        t_10[0].set_color(BLUE)\n        t_11 = TextMobject('\u00bfExiste l\u00edmite cuando \\n \\n        $(x,y)\\\\rightarrow (0,0)$ ?')\n        t_12 = TextMobject('De la misma manera \\n \\n        podemos visualizar que \\n\\n         se cumple la definici\u00f3n')\n        t_13 = TextMobject('Observamos que \\n\\n        $\\\\displaystyle \\\\lim_{(x,y) \\\\to (0,0)}$', '$\\\\ g(x,y) = 1 $')\n        t_13[1].set_color(BLUE)\n        t_14 = TextMobject('\u00bfPuedes encontrar de forma anal\u00edtica \\n\\n             la', ' $\\\\delta$', ' apropiada para demostrar estos l\u00edmites?')\n        t_14[1].set_color('#88FF00')\n        t_1.to_corner(UL)\n        t_2.to_corner(UL)\n        t_3.to_corner(UL)\n        t_4.to_corner(UL)\n        t_5.to_corner(UL)\n        t_6.to_corner(UL)\n        t_7.to_corner(UL)\n        t_8.to_corner(UL)\n        t_9.to_corner(UL)\n        t_10.to_corner(UL)\n        t_11.to_corner(UL)\n        t_12.to_corner(UL)\n        t_13.to_corner(UL)\n        axes = ThreeDAxes()\n        axes.add(axes.get_x_axis_label('t'))\n        axes1 = ThreeDAxes()\n        axes1.add(axes1.get_axis_labels())\n        curve = ParametricFunction(self.cur, color=RED, t_min=-3, t_max=3)\n        surface = ParametricSurface(self.sur, color=GREEN, u_min=-3, u_max=3, v_min=-3, v_max=3)\n        linea = Line(np.array([0, 0, 0]), np.array([0, 1 / np.sqrt(2), 1 / np.sqrt(2)]), stroke_width=8, color=BLUE).move_to((0, 1 / (2 * np.sqrt(2)), 1 / (2 * np.sqrt(2))))\n        lineas = [Line(np.array([0, 0, 0]), np.array([0, x / np.sqrt(2), x / np.sqrt(2)]), stroke_width=8, color=BLUE).move_to((0, x / (2 * np.sqrt(2)), x / (2 * np.sqrt(2)))) for x in np.arange(0.1, 1.1, 0.2)[::-1]]\n        bolas = [Circle(radius=x, color=BLUE).rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS) for x in np.arange(0.1, 1.1, 0.2)[::-1]]\n        deltas = [Line(np.array([0, 0, 0]), np.array([x / 2, 0, 0]), stroke_width=8, color='#88FF00').move_to((x / 4, 0, 0)) for x in np.arange(0.1, 1.1, 0.2)[::-1]]\n        lineas_2 = [Line(np.array([0, 0, 0]), np.array([0, 0, x]), stroke_width=8, color=RED).move_to((0, 0, x / 2 + 1)) for x in np.arange(0.1, 1.1, 0.2)[::-1]]\n        bolas_2 = [Circle(radius=x, color='#88FF00').move_to((0, 0, 1)) for x in np.arange(0.1, 1.1, 0.2)[::-1]]\n        deltas_2 = [Line(np.array([0, 0, 0]), np.array([x / np.sqrt(2), x / np.sqrt(2), 0]), stroke_width=8, color='#88FF00').move_to((x / (2 * np.sqrt(2)), x / (2 * np.sqrt(2)), 1)) for x in np.arange(0.1, 1.1, 0.2)[::-1]]\n        Epsilon = Line(np.array([0, 0, 0]), np.array([0, 1 / np.sqrt(2), 1 / np.sqrt(2)]), stroke_width=8, color=BLUE).move_to((0, 1 / (2 * np.sqrt(2)), 1 / (2 * np.sqrt(2))))\n        Bola = Circle(radius=1, color=BLUE).rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS)\n        Delta = Line(np.array([0, 0, 0]), np.array([1 / 2, 0, 0]), stroke_width=8, color='#88FF00').move_to((1 / 4, 0, 0))\n        Epsilon_2 = Line(np.array([0, 0, 0]), np.array([0, 0, 1]), stroke_width=8, color=RED).move_to((0, 0, 1 / 2 + 1))\n        Bola_2 = Circle(radius=1, color='#88FF00').move_to((0, 0, 1))\n        Delta_2 = Line(np.array([0, 0, 0]), np.array([1 / np.sqrt(2), 1 / np.sqrt(2), 0]), stroke_width=8, color='#88FF00').move_to((1 / (2 * np.sqrt(2)), 1 / (2 * np.sqrt(2)), 1))\n        epsilon = TextMobject('$\\\\epsilon$')\n        epsilon.rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(Epsilon.get_center() + np.array([0, 0.5, 0.5])).set_color(BLUE)\n        delta = TextMobject('$\\\\delta$')\n        delta.rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(Delta.get_center() + np.array([0.5, 0.5, 0])).set_color('#88FF00')\n        epsilon_2 = TextMobject('$\\\\epsilon$')\n        epsilon_2.rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(Epsilon_2.get_center() + np.array([0.5, 0, 0.5])).set_color(RED)\n        delta_2 = TextMobject('$\\\\delta$')\n        delta_2.rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(Delta_2.get_center() + np.array([0.5, 0.5, 0])).set_color('#88FF00')\n        x = ValueTracker(1)\n\n        def update_group_1(Group):\n            Epsilon, Delta, Bola, epsilon, delta = Group\n            Epsilon_new = Line(np.array([0, 0, 0]), np.array([0, 1 / x.get_value() / np.sqrt(2), 1 / x.get_value() / np.sqrt(2)]), stroke_width=8, color=BLUE).move_to((0, 1 / x.get_value() / (2 * np.sqrt(2)), 1 / x.get_value() / (2 * np.sqrt(2))))\n            Epsilon.become(Epsilon_new)\n            epsilon.move_to(Epsilon_new.get_center() + np.array([0, 0.5, 0.5]))\n            Delta_new = Line(np.array([0, 0, 0]), np.array([1 / x.get_value() / 2, 0, 0]), stroke_width=8, color='#88FF00').move_to((1 / x.get_value() / 4, 0, 0))\n            Delta.become(Delta_new)\n            delta.move_to(Delta.get_center() + np.array([0.5, 0.5, 0]))\n            Bola_new = Circle(radius=1 / x.get_value(), color=BLUE).rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS)\n            Bola.become(Bola_new)\n            return Group\n        y = ValueTracker(1)\n\n        def update_group_2(Group):\n            Epsilon_2, Delta_2, Bola_2, epsilon_2, delta_2 = Group\n            Epsilon_new_2 = Line(np.array([0, 0, 0]), np.array([0, 0, 1 / y.get_value()]), stroke_width=8, color=RED).move_to((0, 0, 1 / y.get_value() / 2 + 1))\n            Epsilon_2.become(Epsilon_new_2)\n            epsilon_2.move_to(Epsilon_new_2.get_center() + np.array([0, 0.5, 0.5]))\n            Delta_new_2 = Line(np.array([0, 0, 0]), np.array([1 / y.get_value() / np.sqrt(2), 1 / y.get_value() / np.sqrt(2), 0]), stroke_width=8, color='#88FF00').move_to((1 / y.get_value() / (2 * np.sqrt(2)), 1 / y.get_value() / (2 * np.sqrt(2)), 1))\n            Delta_2.become(Delta_new_2)\n            delta_2.move_to(Delta_new_2.get_center() + np.array([0.5, 0.5, 0]))\n            Bola_new_2 = Circle(radius=1 / y.get_value(), color='#88FF00').move_to((0, 0, 1))\n            Bola_2.become(Bola_new_2)\n            return Group\n        Group_1 = VGroup(Epsilon, epsilon)\n        Group_2 = VGroup(Delta, delta)\n        Group_3 = VGroup(Epsilon_2, epsilon_2)\n        Group_4 = VGroup(Delta_2, delta_2)\n        Big_Group_1 = VGroup(Epsilon, Delta, Bola, epsilon, delta)\n        Big_Group_2 = VGroup(Epsilon_2, Delta_2, Bola_2, epsilon_2, delta_2)\n        self.begin_ambient_camera_rotation(rate=0.06)\n        self.add_fixed_in_frame_mobjects(t_1)\n        self.play(Write(t_1))\n        self.wait(4.25)\n        self.play(FadeOut(t_1))\n        self.add_fixed_in_frame_mobjects(t_2)\n        self.play(Write(t_2))\n        self.wait(3.125)\n        self.add(axes)\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        self.play(LaggedStart(ShowCreation(curve)))\n        self.wait(2)\n        self.play(FadeOut(t_2))\n        self.add_fixed_in_frame_mobjects(t_3)\n        self.play(Write(t_3))\n        self.wait(4.625)\n        self.play(FadeOut(t_3))\n        self.add_fixed_in_frame_mobjects(t_4)\n        self.play(Write(t_4))\n        self.wait(4.625)\n        self.add(Group_1)\n        self.wait(2)\n        self.play(FadeOut(t_4))\n        self.add_fixed_in_frame_mobjects(t_5)\n        self.play(Write(t_5))\n        self.wait(5)\n        self.add(Group_2)\n        self.wait(2)\n        self.play(FadeOut(t_5))\n        self.add_fixed_in_frame_mobjects(t_6)\n        self.play(Write(t_6))\n        self.wait(6.5)\n        self.add(Bola)\n        self.wait(2)\n        self.play(FadeOut(t_6))\n        self.add_fixed_in_frame_mobjects(t_7)\n        self.play(Write(t_7))\n        self.wait(6.5)\n        Big_Group_1.add_updater(update_group_1)\n        self.add(Big_Group_1)\n        self.play(x.increment_value, 5, rate_func=linear, run_time=10)\n        self.wait()\n        self.play(FadeOut(t_7))\n        self.add_fixed_in_frame_mobjects(t_8)\n        self.play(Write(t_8))\n        self.wait(5)\n        self.play(FadeOut(Big_Group_1))\n        self.play(FadeOut(t_8))\n        self.play(FadeOut(curve))\n        self.add_fixed_in_frame_mobjects(t_9)\n        self.play(FadeOut(axes))\n        self.add(axes1)\n        self.play(Write(t_9))\n        self.wait(3.875)\n        self.play(FadeOut(t_9))\n        self.add_fixed_in_frame_mobjects(t_10)\n        self.play(Write(t_10))\n        self.wait(3.875)\n        self.play(LaggedStart(ShowCreation(surface)))\n        self.wait(2)\n        self.play(FadeOut(t_10))\n        self.add_fixed_in_frame_mobjects(t_11)\n        self.play(Write(t_11))\n        self.wait(4.25)\n        self.play(FadeOut(t_11))\n        self.add_fixed_in_frame_mobjects(t_12)\n        self.play(Write(t_12))\n        self.wait(6.125)\n        self.add(Group_3, Group_4, Bola_2)\n        self.wait()\n        Big_Group_2.add_updater(update_group_2)\n        self.add(Big_Group_2)\n        self.play(y.increment_value, 5, rate_func=linear, run_time=10)\n        self.wait()\n        self.play(FadeOut(t_12))\n        self.add_fixed_in_frame_mobjects(t_13)\n        self.play(Write(t_13))\n        self.wait(5)\n        self.play(FadeOut(Big_Group_2))\n        self.play(FadeOut(t_13))\n        self.play(FadeOut(surface))\n        self.play(FadeOut(axes1))\n        self.add_fixed_in_frame_mobjects(t_14)\n        self.play(Write(t_14))\n        self.wait(6.5)\n        self.play(FadeOut(t_14))"}]}
{"messages": [{"role": "user", "content": "Animate the definition and graphical representation of a function diverging to infinity in 3D space."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Divergencia_A_Infinito(ThreeDScene):\n\n    def cur_1(self, t):\n        return np.array([t, 1 / (1 - t), t ** 2])\n\n    def construct(self):\n        titulo = TextMobject('Divergencia a Infinito de Funciones de \\n\\n            $\\\\mathbb{R}\\\\rightarrow\\\\mathbb{R}^{n}$ en un Punto $t_0$')\n        definicion_1 = TextMobject('Sea $f: \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}^{n}$')\n        definicion_2 = TextMobject('$$\\\\lim_{t \\\\rightarrow t_{0}} f(t) = \\\\vec{\\\\infty} \\\\Leftrightarrow  \\\\forall \\\\: M >0$$')\n        definicion_3 = TextMobject('$\\\\exists \\\\delta >0$ tal que si $0< |t-t_{0}| < \\\\delta$ \\n $\\\\Rightarrow \\\\Vert f(t) \\\\Vert > M$').move_to(definicion_2.get_center() + 0.8 * DOWN)\n        self.play(Write(titulo.scale(1.5)))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.play(Write(definicion_1))\n        self.wait(4.25)\n        self.play(definicion_1.shift, 1.2 * UP, runtime=1.5)\n        self.play(Write(definicion_2))\n        self.wait(6.125)\n        self.play(Write(definicion_3))\n        self.wait(8.75)\n        self.play(FadeOut(definicion_2), FadeOut(definicion_3), FadeOut(definicion_1))\n        self.wait()\n        self.custom_method()\n\n    def custom_method(self):\n        t_1 = TextMobject('Veamos este ejemplo:')\n        t_2 = TextMobject('$f(t) = (\\\\frac{1}{1-t},t^2)$')\n        t_2[0].set_color(PURPLE)\n        t_3 = TextMobject('\u00bfQu\u00e9 sucede cuando \\n\\n        $t \\\\rightarrow 1$?')\n        t_4 = TextMobject('Tomemos ', '$M$', '$>0$')\n        t_4[1].set_color('#88FF00')\n        t_5 = TextMobject('Si elegimos adecuadamente \\n\\n        ', '$\\\\delta$', '$>0 $')\n        t_5[1].set_color(BLUE)\n        t_6 = TextMobject('Es claro que \\n\\n        $\\\\Vert$', '$ f(t) $', '$\\\\Vert >$', '$  M$')\n        t_6[1].set_color(PURPLE)\n        t_6[3].set_color('#88FF00')\n        t_7 = TextMobject('$\\\\forall$', ' $M$', '$> 0$')\n        t_7[1].set_color('#88FF00')\n        t_8 = TextMobject('\u00bfSe te ocurre como definir este l\u00edmite usando sucesiones?')\n        t_1.to_corner(UL)\n        t_2.to_corner(UL)\n        t_3.to_corner(UL)\n        t_4.to_corner(UL)\n        t_5.to_corner(UL)\n        t_6.to_corner(UL)\n        t_7.to_corner(UL)\n        axes = ThreeDAxes()\n        axes.add(axes.get_x_axis_label('t'))\n        curve_1_1 = ParametricFunction(self.cur_1, color=PURPLE, t_min=-3, t_max=0.9)\n        curve_1_2 = ParametricFunction(self.cur_1, color=PURPLE, t_min=1.1, t_max=3)\n        M = Line(np.array([0, 0, 0]), np.array([0, -1 / np.sqrt(2), 1 / np.sqrt(2)]), stroke_width=8, color='#88FF00').move_to(np.array([1, -1 / (2 * np.sqrt(2)), 1 / (2 * np.sqrt(2))]))\n        m = TextMobject('$M$').rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(M.get_center() + np.array([0, -0.5, 0.5])).set_color('#88FF00')\n        Delta = Line(np.array([0, 0, 0]), np.array([1.5, 0, 0]), stroke_width=8, color=BLUE).move_to(np.array([1.75, 0, 0]))\n        delta = TextMobject('$\\\\delta$').rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(Delta.get_center() + np.array([0.5, 0.5, 0])).set_color(BLUE)\n        Bola = Circle(radius=1, color='#88FF00').rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(np.array([1, 0, 0]))\n        Group = VGroup(M, m, Delta, delta, Bola)\n        Group_1 = VGroup(curve_1_1, curve_1_2)\n        Group_2 = VGroup(M, m)\n        Group_3 = VGroup(Delta, delta)\n        x = ValueTracker(1)\n\n        def update_group(Group):\n            M, m, Delta, delta, Bola = Group\n            M_new = Line(np.array([0, 0, 0]), np.array([0, -x.get_value() / np.sqrt(2), x.get_value() / np.sqrt(2)]), stroke_width=8, color='#88FF00').move_to(np.array([1, -x.get_value() / (2 * np.sqrt(2)), x.get_value() / (2 * np.sqrt(2))]))\n            M.become(M_new)\n            m.move_to(M_new.get_center() + np.array([0, -x.get_value() / np.sqrt(2), x.get_value() / np.sqrt(2)]))\n            Delta_new = Line(np.array([0, 0, 0]), np.array([1 / x.get_value(), 0, 0]), stroke_width=8, color=BLUE).move_to(np.array([1 + 1 / x.get_value() / 2, 0, 0]))\n            Delta.become(Delta_new)\n            delta.move_to(Delta_new.get_center() + np.array([0.5, 0.5, 0]))\n            Bola_new = Circle(radius=x.get_value(), color='#88FF00').rotate(PI / 2, axis=RIGHT).rotate(PI / 2, about_edge=Z_AXIS).move_to(np.array([1, 0, 0]))\n            Bola.become(Bola_new)\n            return Group\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.add_fixed_in_frame_mobjects(t_1)\n        self.play(Write(t_1))\n        self.wait(3.125)\n        self.play(FadeOut(t_1))\n        self.add(axes)\n        self.set_camera_orientation(phi=65 * DEGREES, theta=-90 * DEGREES)\n        self.play(LaggedStart(ShowCreation(Group_1)))\n        self.wait(2)\n        self.add_fixed_in_frame_mobjects(t_2)\n        self.play(Write(t_2))\n        self.wait(3.87)\n        self.play(FadeOut(t_2))\n        self.add_fixed_in_frame_mobjects(t_3)\n        self.play(Write(t_3))\n        self.wait(4.25)\n        self.play(FadeOut(t_3))\n        self.add_fixed_in_frame_mobjects(t_4)\n        self.play(Write(t_4))\n        self.wait(3.5)\n        self.add(Group_2)\n        self.wait()\n        self.play(FadeOut(t_4))\n        self.add(Group_3)\n        self.wait()\n        self.add_fixed_in_frame_mobjects(t_5)\n        self.play(Write(t_5))\n        self.wait(4.25)\n        self.play(FadeOut(t_5))\n        self.add(Bola)\n        self.add_fixed_in_frame_mobjects(t_6)\n        self.play(Write(t_6))\n        self.wait(4.625)\n        self.play(FadeOut(t_6))\n        self.wait()\n        self.add_fixed_in_frame_mobjects(t_7)\n        self.play(Write(t_7))\n        self.wait(3.5)\n        Group.add_updater(update_group)\n        self.add(Group)\n        self.play(x.increment_value, 1, rate_func=linear, run_time=10)\n        self.play(FadeOut(t_7))\n        self.wait()\n        self.play(FadeOut(Group), FadeOut(Group_1), FadeOut(axes))\n        self.add_fixed_in_frame_mobjects(t_8)\n        self.play(Write(t_8))\n        self.wait(5.375)\n        self.play(FadeOut(t_8))"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of a limit at infinity for functions from R^n to R, including a specific example with a 3D surface plot and visual representations of epsilon and delta."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Limite4_1(ThreeDScene):\n\n    def construct(self):\n        titulo = TextMobject('Existencia del L\u00edmite en Infinito\\n\\n                            de Funciones de $\\\\mathbb{R}^n$ $\\\\rightarrow$ $\\\\mathbb{R}$').scale(1.5)\n        text = TextMobject('Sea $f:\\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R}$').move_to(2.2 * UP)\n        text1 = TexMobject('\\\\lim_{\\\\vec{x}\\\\rightarrow\\\\infty}f(\\\\vec{x})=L\\\\leftrightarrow\\\\forall\\\\epsilon>0').move_to(1 * UP)\n        text2 = TexMobject('\\\\exists\\\\delta>0 \\\\ tq \\\\ \\\\forall \\\\vec{x}\\\\in B^{c}_{\\\\delta}(\\\\vec{0})').move_to(-0.2 * UP)\n        text3 = TexMobject('\\\\implies d(f(\\\\vec{x}),L)<\\\\epsilon').move_to(1.4 * DOWN)\n        G1 = VGroup(text, text1, text2, text3)\n        text4 = TextMobject('Veamos el siguiente ejemplo para aterrizar ideas:')\n        text5 = TexMobject('f:\\\\mathbb{R}^{2}\\\\rightarrow\\\\mathbb{R}')\n        text6 = TexMobject('f(x,y)=1+\\\\frac{1}{x^{2}+y^{2}}').move_to(1.5 * DOWN)\n        G2 = VGroup(text4, text5, text6)\n        self.play(Write(titulo))\n        self.wait(5.25)\n        self.play(FadeOut(titulo))\n        self.play(Write(text))\n        self.play(Write(text1))\n        self.play(Write(text2))\n        self.play(Write(text3))\n        self.wait(6)\n        self.play(FadeOut(G1))\n        self.play(Write(text4))\n        self.wait(4.6)\n        self.play(text4.shift, 2 * UP, runtime=1.5)\n        self.play(Write(text5))\n        self.play(Write(text6))\n        self.wait(3)\n        self.play(FadeOut(G2))\n        self.wait()\n        self.custom_method()\n\n    def custom_method(self):\n        axes = ThreeDAxes()\n        superficie = superficie4()\n        text1 = TexMobject('f(x,y)=1+\\\\frac{1}{x^{2}+y^{2}}')\n        text1.to_corner(UL)\n        text2 = TextMobject('Tomemos', ' $\\\\epsilon$=0.5')\n        text2.to_corner(UL)\n        text2[1].set_color(RED)\n        text3 = TextMobject('Y notemos que \\n \\n                            podemos escoger').to_corner(UL)\n        text3_1 = TextMobject('una', ' $\\\\delta>0$').move_to(text3.get_center() + 1 * DOWN)\n        text3_1[1].set_color(YELLOW_C)\n        text4 = TextMobject('Tal que la imagen de los\\n\\n                             puntos que no \\n\\n                            pertenecen a $ B_{\\\\delta}(\\\\vec{0})$,').to_corner(UL)\n        text5 = TextMobject('est\u00e1n a una distancia $\\\\epsilon$\\n\\n                                de 1.').to_corner(UL)\n        text5_1 = TextMobject('Es posible hacer lo mismo\\n  \\n                            con toda $\\\\epsilon>0$.').to_corner(UL)\n        text6 = TextMobject('Por lo cual:').to_corner(UL)\n        text7 = TexMobject('\\\\lim_{\\\\vec{x}\\\\rightarrow\\\\infty}f(\\\\vec{x})=1').move_to(text5.get_center() + 1 * DOWN)\n        M = TextMobject('1').move_to(1 * UP + 0.2 * LEFT)\n        r = 0.5\n        r1 = 1\n        linea = Line((0, 0, 1), (0, 0, 1 + r), stroke_width=6, color=RED)\n        linea_1 = Line((0, 0, 1), (0, 0, 1 + r1), stroke_width=6, color=RED)\n        R = 1.7\n        R1 = R - 0.5\n        linea1 = Line((0, 0, 0), (R, 0, 0), stroke_width=6, color=YELLOW_C)\n        circulo = Circle(radius=R, color=YELLOW_C)\n        circulo1 = Circle(radius=R1, color=YELLOW_C)\n\n        def puntosEnSuperficie(rad, lim, num):\n            puntosDom = []\n            puntosSur = []\n            for i in range(num):\n                azar = lim * np.random.rand(1, 2)[0] + 0.1\n                if rad < np.sqrt(azar[0] ** 2 + azar[1] ** 2) < lim:\n                    puntosDom.append(Dot(np.array([azar[0], azar[1], 0]), color=BLUE))\n                    puntosSur.append(Dot(superficie.func(azar[0], azar[1]), color=RED))\n            return (puntosDom, puntosSur)\n        puntosD1, puntosS1 = puntosEnSuperficie(R, 5, 6000)\n        puntosD2, puntosS2 = puntosEnSuperficie(R1, R, 3000)\n        GPuntosD1 = VGroup(*puntosD1)\n        GPuntosS1 = VGroup(*puntosS1)\n        GPuntosD2 = VGroup(*puntosD2)\n        GPuntosS2 = VGroup(*puntosS2)\n        self.set_camera_orientation(0.8 * np.pi / 2, -0.25 * np.pi, distance=12)\n        self.begin_ambient_camera_rotation(rate=0.001)\n        self.play(ShowCreation(axes))\n        self.add_fixed_in_frame_mobjects(text1)\n        self.add_fixed_in_frame_mobjects(M)\n        self.play(Write(text1))\n        self.play(ShowCreation(superficie))\n        self.wait()\n        self.play(FadeOut(text1))\n        self.add_fixed_in_frame_mobjects(text2)\n        self.play(Write(text2))\n        self.play(ShowCreation(linea))\n        self.play(FadeOut(text2))\n        self.add_fixed_in_frame_mobjects(text3)\n        self.play(Write(text3))\n        self.add_fixed_in_frame_mobjects(text3_1)\n        self.play(Write(text3_1))\n        self.play(ShowCreation(linea1))\n        self.play(ShowCreation(circulo))\n        self.play(FadeOut(text3), FadeOut(text3_1))\n        self.add_fixed_in_frame_mobjects(text4)\n        self.play(Write(text4))\n        self.wait()\n        self.play(FadeOut(text4))\n        self.play(FadeIn(GPuntosD1))\n        self.add_fixed_in_frame_mobjects(text5)\n        self.play(Write(text5), FadeOut(linea1))\n        self.play(FadeIn(GPuntosS1))\n        self.play(linea.shift, (R + 0.1) * RIGHT, runtime=10)\n        self.wait(6.5)\n        self.play(FadeOut(text5))\n        self.add_fixed_in_frame_mobjects(text5_1)\n        self.play(Write(text5_1))\n        self.play(ReplacementTransform(linea, linea_1))\n        self.play(ReplacementTransform(circulo, circulo1))\n        self.play(FadeIn(GPuntosD2))\n        self.play(FadeIn(GPuntosS2))\n        self.play(linea_1.shift, (R1 + 0.1) * RIGHT, runtime=10)\n        self.wait(3)\n        self.play(FadeOut(text5_1))\n        self.add_fixed_in_frame_mobjects(text6)\n        self.play(Write(text6))\n        self.add_fixed_in_frame_mobjects(text7)\n        self.play(Write(text7))\n        self.wait(2)\n        self.play(FadeOut(text7), FadeOut(text6), FadeOut(axes), FadeOut(M), FadeOut(superficie), FadeOut(linea_1), FadeOut(circulo1), FadeOut(GPuntosD1), FadeOut(GPuntosS1), FadeOut(GPuntosD2), FadeOut(GPuntosS2))"}]}
{"messages": [{"role": "user", "content": "Illustrate the continuity of operations on functions with 3D parametric curve examples and corresponding theorems."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Operaciones_continuidad(ThreeDScene):\n\n    def acomodar_textos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.play(Write(objeto))\n\n    def acomodar_puntos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.add(objeto)\n\n    def helicoide(self, t):\n        return [t, np.cos(5 * t), np.sin(5 * t)]\n\n    def identidad(self, t):\n        return [t, t, t]\n\n    def func_suma(self, t):\n        return [t, t + np.cos(5 * t), t + np.sin(5 * t)]\n\n    def func_por_escalar(self, t):\n        k = 3\n        return [t, k * np.cos(5 * t), k * np.sin(5 * t)]\n\n    def func_prod_int(self, t):\n        return [t, 2 * t ** 2 + t * np.cos(5 * t) + t * np.sin(5 * t), 0]\n\n    def construct(self):\n        k = 3\n        title = TextMobject('Continuidad: Teoremas de Operaciones').scale(1.5)\n        t_1 = TextMobject('Sean $f,g:D\\\\subseteq\\\\mathbb{R}^n\\\\longrightarrow\\\\mathbb{R}^m$, ', '$x_0$', '$\\\\in D$ \\n\\n                            $f$ y $g$ ', 'continuas', ' en ', '$x_0$', ' entonces:').shift(2 * UP)\n        t_1.set_color_by_tex_to_color_map({'continuas': BLUE, '$x_0$': PURPLE_B})\n        t_2 = TextMobject('1) $f+g$ es ', 'continua', ' en ', '$x_0$').next_to(t_1, DOWN, buff=1.2)\n        t_2.set_color_by_tex_to_color_map({'continua': BLUE, '$x_0$': PURPLE_B})\n        t_3 = TextMobject('2) Sea $k\\\\in\\\\mathbb{R}$, $kf$ es ', 'continua', ' en ', '$x_0$').next_to(t_2, DOWN)\n        t_3.set_color_by_tex_to_color_map({'continua': BLUE, '$x_0$': PURPLE_B})\n        t_4 = TextMobject('3) $f\\\\cdot g$ es ', 'continua', ' en ', '$x_0$').next_to(t_3, DOWN)\n        t_4.set_color_by_tex_to_color_map({'continua': BLUE, '$x_0$': PURPLE_B})\n        Nota = TextMobject('Nota: la tercera operaci\u00f3n es un producto interior \\\\\\\\\\n                            Si $m=1$ se trata de producto de reales').scale(0.75).to_edge(DOWN)\n        t_5 = TextMobject('Veamos algunos ejemplos...')\n        reglaf = TextMobject('$f(t)$', '$=(\\\\cos(5t),\\\\sin(5t))$').scale(0.85).to_corner(LEFT + UP).shift(1 * RIGHT)\n        reglaf.set_color_by_tex_to_color_map({'$f(t)$': RED})\n        reglaf.bg = SurroundingRectangle(reglaf, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        reglag = TextMobject('$g(t)$', '$=(t,t)$').scale(0.85).to_corner(LEFT + UP).shift(2 * RIGHT)\n        reglag.set_color_by_tex_to_color_map({'$g(t)$': TEAL_D})\n        reglag.bg = SurroundingRectangle(reglag, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_6 = TextMobject('$f$', ' y ', '$g$', ' son funciones ', 'continuas', ' \\n\\n                            en ', '$t_0=0$', ', \u00bfpuedes demostrarlo?').scale(0.85).to_corner(LEFT + UP)\n        t_6.set_color_by_tex_to_color_map({'continuas': BLUE, '$f$': RED, '$g$': TEAL_D, '$t_0=0$': YELLOW})\n        t_6.bg = SurroundingRectangle(t_6, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_7 = TextMobject('Entonces $f+g$ tambi\u00e9n es \\n\\n                            ', 'continua', ' en ', '$t_0$').scale(0.85).to_corner(LEFT + UP)\n        t_7.set_color_by_tex_to_color_map({'continua': BLUE, '$t_0$': YELLOW})\n        t_7.bg = SurroundingRectangle(t_7, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        reglafmasg = TextMobject('$(f+g)(t)$', '$=(t+\\\\cos(5t),t+\\\\sin(5t))$').scale(0.85).to_corner(LEFT + UP)\n        reglafmasg.set_color_by_tex_to_color_map({'$(f+g)(t)$': PINK})\n        reglafmasg.bg = SurroundingRectangle(reglafmasg, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_8 = TextMobject('Si tomamos $k=$' + str(k) + ', \\n\\n                            $kf$ tambi\u00e9n es ', 'continua', ' en ', '$t_0$').scale(0.85).to_corner(LEFT + UP).shift(0.4 * RIGHT)\n        t_8.set_color_by_tex_to_color_map({'continua': BLUE, '$t_0$': YELLOW})\n        t_8.bg = SurroundingRectangle(t_8, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        reglakf = TexMobject('(' + str(k) + 'f)(t)=(' + str(k) + '\\\\cos(5t),' + str(k) + '\\\\sin(5t))').scale(0.85).to_corner(LEFT + UP).shift(0.4 * RIGHT)\n        reglakf.bg = SurroundingRectangle(reglakf, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        for i in range(0, 7):\n            reglakf[0][i].set_color(ORANGE)\n        t_9 = TextMobject('Por \u00faltimo, al tomar el producto punto de ', '$f$', ' y ', '$g$', ', la funci\u00f3n \\n\\n                            resultante es tambi\u00e9n ', 'continua', ' en ', '$t_0$')\n        t_9.set_color_by_tex_to_color_map({'$f$': RED, '$g$': TEAL_D, 'continua': BLUE, '$t_0$': YELLOW})\n        reglafpuntog = TextMobject('$(f\\\\cdot g)(t)$', '$=2t^2+t\\\\cos(5t)+t\\\\sin(5t)$').scale(0.85).to_corner(LEFT + UP)\n        reglafpuntog.set_color_by_tex_to_color_map({'$(f\\\\cdot g)(t)$': GREEN_D})\n        reglafpuntog.bg = SurroundingRectangle(reglafpuntog, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        axis_config = {'x_min': -6, 'x_max': 6, 'y_min': -6, 'y_max': 6, 'z_min': -6, 'z_max': 6}\n        ejes = ThreeDAxes(**axis_config)\n        ejes2 = Axes(x_min=-6, x_max=6, y_min=-3.5, y_max=3.5)\n        tmin = -6\n        tmax = 6\n        f = ParametricFunction(self.helicoide, t_min=tmin, t_max=tmax, color=RED).set_shade_in_3d(True)\n        g = ParametricFunction(self.identidad, t_min=tmin, t_max=tmax, color=TEAL_D).set_shade_in_3d(True)\n        fmasg = ParametricFunction(self.func_suma, t_min=tmin, t_max=tmax, color=PINK).set_shade_in_3d(True)\n        kf = ParametricFunction(self.func_por_escalar, t_min=tmin, t_max=tmax, color=ORANGE).set_shade_in_3d(True)\n        fpuntog = ParametricFunction(self.func_prod_int, t_min=-1.3, t_max=1.3, color=GREEN_D).set_shade_in_3d(True)\n        dot1 = Dot(point=(0, 1, 0), color=YELLOW, radius=0.1)\n        dot2 = Dot(point=(0, 0, 0), color=YELLOW, radius=0.1)\n        dot3 = Dot(point=(0, 1, 0), color=YELLOW, radius=0.1)\n        dot4 = Dot(point=(0, k, 0), color=YELLOW, radius=0.1)\n        dot5 = Dot(point=(0, 0, 0), color=YELLOW, radius=0.1)\n        Group1 = VGroup(t_1, t_2, t_3, t_4, Nota)\n        self.play(Write(title))\n        self.wait()\n        self.play(FadeOutAndShiftDown(title))\n        self.play(Write(t_1))\n        self.wait(8)\n        self.play(Write(t_2))\n        self.wait(3)\n        self.play(Write(t_3))\n        self.wait(3.25)\n        self.play(Write(t_4))\n        self.wait(3.25)\n        self.play(Write(Nota))\n        self.wait(2.75)\n        self.play(FadeOut(Group1))\n        self.play(Write(t_5))\n        self.wait(2)\n        self.play(FadeOut(t_5))\n        self.set_camera_orientation(phi=115 * DEGREES, theta=-65 * DEGREES)\n        self.play(ShowCreation(ejes))\n        self.begin_ambient_camera_rotation(rate=0.07)\n        self.acomodar_textos(reglaf.bg)\n        self.acomodar_textos(reglaf)\n        self.add_foreground_mobjects(reglaf.bg)\n        self.add_foreground_mobjects(reglaf)\n        self.play(ShowCreation(f), run_time=2)\n        self.wait(2.5)\n        self.play(FadeOut(reglaf), FadeOut(reglaf.bg))\n        self.remove_foreground_mobjects(reglaf.bg)\n        self.remove_foreground_mobjects(reglaf)\n        self.acomodar_textos(reglag.bg)\n        self.acomodar_textos(reglag)\n        self.add_foreground_mobjects(reglag.bg)\n        self.add_foreground_mobjects(reglag)\n        self.play(ShowCreation(g), run_time=2)\n        self.wait(2.5)\n        self.play(FadeOut(reglag), FadeOut(reglag.bg))\n        self.remove_foreground_mobjects(reglag.bg)\n        self.remove_foreground_mobjects(reglag)\n        self.acomodar_textos(t_6.bg)\n        self.acomodar_textos(t_6)\n        self.add_foreground_mobjects(t_6.bg)\n        self.add_foreground_mobjects(t_6)\n        self.add(dot1, dot2)\n        self.wait(4.5)\n        self.remove(dot1, dot2)\n        self.play(FadeOut(f), FadeOut(g), FadeOut(t_6), FadeOut(t_6.bg))\n        self.remove_foreground_mobjects(t_6.bg)\n        self.remove_foreground_mobjects(t_6)\n        self.acomodar_textos(t_7.bg)\n        self.acomodar_textos(t_7)\n        self.add_foreground_mobjects(t_7.bg)\n        self.add_foreground_mobjects(t_7)\n        self.wait(4.5)\n        self.play(FadeOut(t_7), FadeOut(t_7.bg))\n        self.remove_foreground_mobjects(t_7.bg)\n        self.remove_foreground_mobjects(t_7)\n        self.acomodar_textos(reglafmasg.bg)\n        self.acomodar_textos(reglafmasg)\n        self.add_foreground_mobjects(reglafmasg.bg)\n        self.add_foreground_mobjects(reglafmasg)\n        self.play(ShowCreation(fmasg), run_time=2)\n        self.add(dot3)\n        self.wait(6)\n        self.remove(dot3)\n        self.play(FadeOut(fmasg), FadeOut(reglafmasg), FadeOut(reglafmasg.bg))\n        self.remove_foreground_mobjects(reglafmasg.bg)\n        self.remove_foreground_mobjects(reglafmasg)\n        self.acomodar_textos(t_8.bg)\n        self.acomodar_textos(t_8)\n        self.add_foreground_mobjects(t_8.bg)\n        self.add_foreground_mobjects(t_8)\n        self.wait(4.5)\n        self.play(FadeOut(t_8), FadeOut(t_8.bg))\n        self.remove_foreground_mobjects(t_8.bg)\n        self.remove_foreground_mobjects(t_8)\n        self.acomodar_textos(reglakf.bg)\n        self.acomodar_textos(reglakf)\n        self.add_foreground_mobjects(reglakf.bg)\n        self.add_foreground_mobjects(reglakf)\n        self.play(ShowCreation(kf), run_time=2)\n        self.add(dot4)\n        self.wait(2)\n        self.remove(dot4)\n        self.play(FadeOut(reglakf.bg), FadeOut(reglakf), FadeOut(kf), FadeOut(ejes))\n        self.remove_foreground_mobjects(reglakf.bg)\n        self.remove_foreground_mobjects(reglakf)\n        self.stop_ambient_camera_rotation()\n        self.set_camera_orientation(phi=0, theta=-90 * DEGREES)\n        self.play(Write(t_9))\n        self.wait(8)\n        self.play(FadeOutAndShiftDown(t_9))\n        self.play(ShowCreation(ejes2))\n        self.play(FadeIn(reglafpuntog.bg))\n        self.play(Write(reglafpuntog))\n        self.add_foreground_mobjects(reglafpuntog.bg)\n        self.add_foreground_mobjects(reglafpuntog)\n        self.play(ShowCreation(fpuntog))\n        self.add(dot5)\n        self.wait(4)\n        self.play(FadeOut(ejes2), FadeOut(reglafpuntog), FadeOut(fpuntog), FadeOut(dot5))\n        self.remove_foreground_mobjects(reglafpuntog.bg)\n        self.remove_foreground_mobjects(reglafpuntog)"}]}
{"messages": [{"role": "user", "content": "Present the Extreme Value Theorem, first with text and then illustrate it with the graph of a cubic function, highlighting its extreme points."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ExtremeValue(GraphScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        GraphScene.setup(self)\n    CONFIG = {'x_axis_label': '$x$', 'y_axis_label': '$y$', 'y_max': 27, 'y_min': -27, 'x_max': 5, 'x_min': -1, 'x_labeled_nums': range(-1, 5), 'y_labeled_nums': range(-27, 28, 9), 'y_tick_frequency': 3, 'axes_color': GREEN_C, 'graph_origin': np.array((-3, 0, 0)), 'number_scale_val': 0.7, 'unit_size': 0.5}\n\n    def construct(self):\n        extreme = TextMobject('Teorema del Valor Extremo')\n        def_intuitiva = TextMobject('De manera intuitiva, este teorema nos dice que si \\n\\n        tenemos una funci\u00f3n continua en un conjunto compacto, \\n\\n        esta alcanza sus valores extremos en dicho conjunto, \\n\\n        aunque estos no siempre se pueden conocer. ').shift(2 * UP)\n        tex0 = TextMobject('Procedamos a enunciar formalmente este teorema.').next_to(def_intuitiva, 2 * DOWN)\n        texto = VGroup(def_intuitiva, tex0)\n        tex1 = TextMobject('Sea', ' $f : A \\\\subset \\\\mathbb{R}^{n} \\\\rightarrow \\\\mathbb{R}$', ' continua en $A$ tal que $A$').shift(1.5 * UP)\n        tex2 = TextMobject(' cerrado y acotado, entonces $\\\\exists$', ' $ \\\\hat{x_{1}}, \\\\hat{x_{2}} \\\\in A$').next_to(tex1, DOWN)\n        tex3 = TextMobject('tales que', ' $f(\\\\hat{x_{1}}) \\\\leq f(\\\\hat{x}) \\\\leq f(\\\\hat{x_{2}})$', ' $\\\\forall \\\\hat{x} \\\\in A$.', ' Es decir,').next_to(tex2, DOWN)\n        tex4 = TextMobject('\\\\textit{f} alcanza un valor', ' m\u00e1ximo', ' y un valor', ' m\u00ednimo', ' sobre \\\\textit{A}.').next_to(tex3, DOWN)\n        tex4[1].set_color(GREEN_C)\n        tex4[3].set_color(YELLOW_C)\n        tex = VGroup(tex1, tex2, tex3, tex4)\n        ejm1 = TextMobject('Comencemos por visualizar la definici\u00f3n \\n\\n         anterior en una funci\u00f3n $f:\\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}$.').to_corner(UL)\n        self.play(Write(extreme.scale(1.5)))\n        self.wait(3.5)\n        self.play(FadeOut(extreme))\n        self.wait()\n        self.play(Write(texto), run_time=7)\n        self.wait(15.8)\n        self.remove(texto)\n        self.wait()\n        self.play(Write(tex), run_time=6)\n        self.wait(15.8)\n        self.play(FadeOut(tex))\n        self.play(FadeIn(ejm1))\n        self.wait(6.8)\n        self.play(ShrinkToCenter(ejm1))\n        self.setup_axes()\n        graph = self.get_graph(lambda x: 2 * x ** 3 - 9 * x ** 2, color=YELLOW_D, x_min=-1, x_max=5)\n        etiqueta = TextMobject('$f(x)= 2x^{3}-9x^{2}$').set_color(YELLOW_D)\n        etiqueta.move_to(np.array((0.5, 1, 0)))\n        dot_at_start = Dot().move_to(graph.points[0])\n        dot_at_start1 = Dot().move_to(self.coords_to_point(-1, 0))\n        dot_at_start2 = Dot().move_to(self.coords_to_point(0, -11))\n        line_at_start1 = DashedLine(dot_at_start1.get_bottom(), dot_at_start)\n        line_at_start2 = DashedLine(dot_at_start2.get_left(), dot_at_start)\n        dot_at_start_label = TexMobject((-1, -11)).next_to(dot_at_start, 0.5 * LEFT).scale(0.7)\n        dot_start = Group(dot_at_start, dot_at_start_label, dot_at_start1, dot_at_start2, line_at_start1, line_at_start2)\n        dot_at_center = Dot().move_to(self.coords_to_point(0, 0))\n        dot_at_center_label = TexMobject((0, 0)).next_to(dot_at_center, 0.5 * UP + 0.5 * RIGHT).scale(0.7)\n        dot_center = Group(dot_at_center, dot_at_center_label)\n        dot_at_min1 = Dot().move_to(self.coords_to_point(3, 0))\n        dot_at_min2 = Dot().move_to(self.coords_to_point(0, -27))\n        dot_at_min = Dot().move_to(self.coords_to_point(3, -27))\n        line_at_min1 = DashedLine(dot_at_min1.get_bottom(), dot_at_min)\n        line_at_min2 = DashedLine(dot_at_min2.get_right(), dot_at_min)\n        dot_at_min_label = TexMobject((3, -27)).next_to(dot_at_min, 0.5 * DOWN).scale(0.7)\n        dot_min = Group(dot_at_min, dot_at_min_label, dot_at_min1, dot_at_min2, line_at_min1, line_at_min2)\n        dot_at_end = Dot().move_to(graph.points[-1])\n        dot_at_end1 = Dot().move_to(self.coords_to_point(5, 0))\n        dot_at_end2 = Dot().move_to(self.coords_to_point(0, 25))\n        line_at_end1 = DashedLine(dot_at_end1.get_top(), dot_at_end)\n        line_at_end2 = DashedLine(dot_at_end2.get_right(), dot_at_end)\n        dot_at_end_label = TexMobject((5, 25)).next_to(dot_at_end, 0.5 * UP).scale(0.7)\n        dot_end = Group(dot_at_end, dot_at_end_label, dot_at_end1, dot_at_end2, line_at_end1, line_at_end2)\n        grafica = Group(graph, etiqueta)\n        self.play(FadeIn(self.axes))\n        self.play(ShowCreation(grafica), run_time=2)\n        self.wait()\n        self.play(ShowCreation(dot_start), ShowCreation(dot_center), ShowCreation(dot_min), ShowCreation(dot_end), run_time=4)\n        self.wait(3)\n        self.play(FadeOut(self.axes), FadeOut(grafica), FadeOut(dot_end), FadeOut(dot_min), FadeOut(dot_center), FadeOut(dot_start))\n        pto0 = TextMobject('N\u00f3tese que', ' $f(x)= 2x^{3}-9x^{2}$', ' es una funci\u00f3n continua').to_edge(UP)\n        pto0[1].set_color(YELLOW_D)\n        pto1 = TextMobject('en el intervalo cerrado $I= [-1,5]$').next_to(pto0, DOWN)\n        pto2 = TextMobject('De la gr\u00e1fica, se observa  ').next_to(pto1, DOWN)\n        pto3 = TextMobject('que los valores extremos en $I$').next_to(pto2, DOWN)\n        pto4 = TextMobject('se alcanzan cuando:').next_to(pto3, DOWN)\n        pto5 = TextMobject('$-27=f(3) \\\\leq f(\\\\hat{x}) \\\\leq f(5)=25$, $ \\\\forall \\\\hat{x} \\\\in I$').next_to(pto4, DOWN)\n        ptos = VGroup(pto0, pto1, pto2, pto3, pto4, pto5)\n        self.play(Write(ptos), run_time=6)\n        self.wait(12.5)\n        self.play(FadeOut(ptos))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the surface $f(x,y)=x^2 - y^2 + 5$ over the domain $[-3,3]\\text{x}[-3,3]$ and highlight its extrema."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Superficie(ThreeDScene):\n\n    def setup(self):\n        Scene.setup(self)\n        ThreeDScene.setup(self)\n\n    def construct(self):\n        axis_config = {'x_min': -4, 'x_max': 4, 'y_min': -4, 'y_max': 4, 'z_min': -5, 'z_max': 6, 'unit_size': 0.5, 'graph_origin': np.array([0, 0, -4])}\n        ejm2 = TextMobject(' Visualicemos ahora este teorema usando \\n\\n                una funci\u00f3n $f:\\\\mathbb{R}^{2} \\\\rightarrow \\\\mathbb{R}$.').shift(1.5 * UP)\n        nota1 = TextMobject('Sea', ' $f(x,y)=x^{2} - y^{2}+5$', ' una funci\u00f3n continua ').next_to(ejm2, DOWN)\n        nota1[1].set_color(BLUE)\n        nota2 = TextMobject('en un conjunto cerrado y acotado $T$, ').next_to(nota1, DOWN)\n        nota3 = TextMobject('tal que T es ').next_to(nota2, DOWN)\n        nota4 = TextMobject('[-3,3]x[-3,3]').next_to(nota3, DOWN)\n        notas = VGroup(ejm2, nota1, nota2, nota3, nota4)\n        nota5 = TextMobject('Se puede demostrar que los valores extremos \\n\\n        se alcanzan en la frontera $T$, ').shift(1.5 * UP)\n        nota6 = TextMobject('se podr\u00e1 hacer con las herramientas del \\n\\n         C\u00e1lculo Diferencial para superficies . ').next_to(nota5, DOWN)\n        notas_1 = VGroup(nota5, nota6)\n        nota7 = TextMobject(' Se podr\u00e1 demostrar que el valor m\u00e1ximo es  \\n\\n                 $f(3,0)= 14$, mientras \\n\\n                que el m\u00ednimo corresponde a  $f(0,-3)= -4 $').scale(0.7).to_corner(DL)\n        axes = ThreeDAxes(**axis_config)\n        sabanita = ParametricSurface(lambda u, v: np.array([u, v, u ** 2 - v ** 2 + 5]), v_min=-3, v_max=3, u_min=-3, u_max=3, checkerboard_colors=[BLUE_E, BLUE], resolution=(15, 32))\n        ver1 = Dot(np.array([-3, 0, 0]), radius=0.07)\n        ver2 = Dot(np.array([3, 0, 0]), radius=0.07)\n        ver3 = Dot(np.array([0, -3, 0]), radius=0.07)\n        ver4 = Dot(np.array([0, 3, 0]), radius=0.07)\n        abs_min = Dot(np.array([0, -3, -4]), radius=0.07)\n        abs_min_0 = Dot(np.array([0, 3, -4]), radius=0.07)\n        abs_max_0 = Dot(np.array([3, 0, 14]), radius=0.07)\n        abs_max = Dot(np.array([-3, 0, 14]), radius=0.07)\n        linea = DashedLine(ver1, abs_max, opacity=0.7, stroke_width=5)\n        linea2 = DashedLine(ver2, abs_max_0, opacity=0.7, stroke_width=5)\n        linea3 = DashedLine(ver3, abs_min, opacity=0.7, stroke_width=5)\n        linea4 = DashedLine(ver4, abs_min_0, opacity=0.7, stroke_width=5)\n        ver1_label = TexMobject((0, -3)).next_to(ver3, 0.5 * LEFT).scale(0.7)\n        ver2_label = TexMobject((0, 3)).next_to(ver4, 0.5 * LEFT).scale(0.7)\n        ver3_label = TexMobject((3, 0)).next_to(ver2, 0.5 * LEFT).scale(0.7)\n        ver4_label = TexMobject((-3, 0)).next_to(ver1, 0.5 * LEFT).scale(0.7)\n        verts = Group(ver1, ver2, ver3, ver4, ver1_label, ver2_label, ver3_label, ver4_label)\n        extremos = Group(abs_max, abs_min, abs_max_0, abs_min_0)\n        minimos = Group(linea, linea2, linea3, linea4)\n        self.play(Write(notas), run_time=5)\n        self.wait(12.4)\n        self.play(ReplacementTransform(notas, notas_1), run_time=3)\n        self.wait(7.6)\n        self.remove(notas_1)\n        self.wait(2)\n        self.play(FadeInFromDown(nota7))\n        self.wait(10)\n        self.play(ShowCreation(axes))\n        self.play(FadeOut(nota7))\n        self.move_camera(phi=75 * DEGREES, frame_center=(0, 0, 3))\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.play(ShowCreation(verts), ShowCreation(sabanita), ShowCreation(extremos), ShowCreation(minimos), run_time=12)\n        self.wait(3)\n        self.play(FadeOut(minimos), FadeOut(extremos), FadeOut(sabanita), FadeOut(verts), FadeOut(axes))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Present the statement of the Intermediate Value Theorem, highlighting key terms and then transitioning to an introductory sentence for examples."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TeoValorIntermedio_1(Scene):\n\n    def construct(self):\n        titulo = TextMobject('Teoremas Fuertes de Continuidad', ' \\n\\n                        Teorema del Valor Intermedio').scale(1.5)\n        text_1_1 = TextMobject('Sea $f:A\\\\subset\\\\mathbb{R}^{n}\\\\rightarrow\\\\mathbb{R}$ ', 'continua', ' en A.').shift(UP * 1.8)\n        text_1_2 = TextMobject('Sea A ', 'conexo', ' y $\\\\vec{x}_1,\\\\vec{x}_2\\\\in A$').next_to(text_1_1, DOWN)\n        text_1_3 = TextMobject(' tales que $f(\\\\vec{x}_1)<f(\\\\vec{x}_2)$.').next_to(text_1_2, DOWN)\n        text_1_4 = TextMobject('Si $c\\\\in\\\\mathbb{R}$ es tal que $f(\\\\vec{x}_1)<c<f(\\\\vec{x}_2)$,').next_to(text_1_3, DOWN)\n        text_1_5 = TextMobject('entonces existe $\\\\vec{x}$ tal que $f(\\\\vec{x})=c$ ').next_to(text_1_4, DOWN)\n        text_1_1[1].set_color(PURPLE_B)\n        text_1_1[3].set_color(ORANGE)\n        text1 = VGroup(text_1_1, text_1_2, text_1_3, text_1_4, text_1_5)\n        text_2 = TextMobject('Veamos algunos ejemplos que ilustran este teorema')\n        self.play(Write(titulo[0]))\n        self.wait(4)\n        self.play(Write(titulo[1]))\n        self.wait(4)\n        self.play(FadeOut(titulo))\n        self.play(Write(text_1_1))\n        self.wait(4)\n        self.play(Write(text_1_2))\n        self.wait(5)\n        self.play(Write(text_1_3))\n        self.wait(4)\n        self.play(Write(text_1_4))\n        self.wait(6)\n        self.play(Write(text_1_5))\n        self.wait(4)\n        self.play(ReplacementTransform(text1, text_2))\n        self.wait(4)\n        self.play(FadeOut(text_2))"}]}
{"messages": [{"role": "user", "content": "Illustrate the intermediate value theorem by displaying and highlighting key points of a function, its domain, and its properties in a 3D space."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TeoValorIntermedio_3(ThreeDScene):\n    CONFIG = {'x_axis_label': '$x$', 'y_axis_label': '$y$'}\n\n    def construct(self):\n        text2 = TextMobject('Sea $f(x,y)=x^{2}+y^{2}-2$')\n        for i in range(3, 9):\n            text2[0][i].set_color(BLUE)\n        text2_copy = text2.copy()\n        text2_copy.to_edge(DOWN)\n        text2.bg = SurroundingRectangle(text2_copy, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text2.group = VGroup(text2.bg, text2_copy)\n        text3 = TextMobject('Y sea $\\\\Vec{x}_1=(0,0),\\\\Vec{x}_2=(2,0)$', ' y $c=5$').to_edge(DOWN)\n        text3.bg = SurroundingRectangle(text3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text3.group = VGroup(text3.bg, text3)\n        text3[0][4].set_color(PURPLE_B)\n        text3[0][5].set_color(PURPLE_B)\n        text3[0][6].set_color(PURPLE_B)\n        text3[0][14].set_color(RED)\n        text3[0][15].set_color(RED)\n        text3[0][16].set_color(RED)\n        text4 = TextMobject('Se puede comprobar que ', '$f(\\\\Vec{x}_1)$', '$<0<$', '$f(\\\\Vec{x}_2)$')\n        text4.to_edge(DOWN)\n        text4.bg = SurroundingRectangle(text4, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text4.group = VGroup(text4.bg, text4)\n        text4[1].set_color(PURPLE_B)\n        text4[3].set_color(RED)\n        text5 = TextMobject('Si tomamos $\\\\vec{x}=(x,y)$ tal que $||\\\\vec{x}||^{2}=2$, \\\\\\\\', 'se cumple que $f(\\\\vec{x})=0$.')\n        text5.to_edge(DOWN)\n        text5.bg = SurroundingRectangle(text5, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text5.group = VGroup(text5.bg, text5)\n        text6 = TextMobject('Si tomamos $\\\\vec{x}$ tal que $||\\\\vec{x}||=2$ \\n', 'se cumple que $f(\\\\vec{x})$=0')\n        text6.to_edge(DOWN)\n        text6.bg = SurroundingRectangle(text6, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text6.group = VGroup(text6.bg, text6)\n        text6_1 = TextMobject('Por lo cual se cumple el teorema del valor intermedio.')\n        text6_1.to_edge(DOWN)\n        text6_1.bg = SurroundingRectangle(text6_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text6_1.group = VGroup(text6_1.bg, text6_1)\n        text7 = TextMobject('Como $f$ es continua en un conexo y tiene cambio de signo, \\\\\\\\', 'por el teorema del valor intermedio, \\\\\\\\', '$f$ tiene ra\u00edces en el dominio.').to_edge(DOWN)\n        text7.bg = SurroundingRectangle(text7, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text7.group = VGroup(text7.bg, text7)\n        superficie = sup(color=BLUE_C, fill_opacity=0.5)\n        axes = ThreeDAxes()\n        axes.add(axes.get_axis_labels())\n        axes.axis_labels[0].rotate(PI / 2, axis=RIGHT)\n        axes.axis_labels[1].rotate(PI / 2, axis=RIGHT)\n        x1 = 0\n        y1 = 0\n        f_1 = Dot(color=PURPLE_C).move_to([x1, y1, 0])\n        f_1_label = TexMobject('\\\\vec{x}_1').rotate(PI / 2, axis=RIGHT).move_to(f_1.get_center() + 0.2 * UP + 0.4 * RIGHT).set_color(PURPLE_C).scale(1.5)\n        x2 = 2\n        y2 = 0\n        f_2 = Dot(color=RED).move_to([x2, y2, 0])\n        f_2_label = TexMobject('\\\\vec{x}_2').rotate(PI / 2, axis=RIGHT).move_to(f_2.get_center() + 0.2 * UP + 0.4 * RIGHT).set_color(RED).scale(1.5)\n        bola = Circle(radius=2 ** (1 / 2), color=ORANGE).move_to([0, 0, 0])\n        dots1 = VGroup(f_1, f_2, f_1_label, f_2_label)\n        xf_1 = Dot(color=PURPLE_B).move_to([x1, y1, x1 ** 2 + y1 ** 2 - 2]).set_color(PURPLE_C)\n        xf_2 = Dot(color=RED).move_to([x2, y2, x2 ** 2 + y2 ** 2 - 2]).set_color(RED)\n        xf_1_label = TexMobject('f(\\\\vec{x}_1)').rotate(PI / 2, axis=RIGHT).move_to(xf_1.get_center() + 1 * RIGHT).set_color(PURPLE_C).scale(1.5)\n        xf_2_label = TexMobject('f(\\\\vec{x}_2 ) ').rotate(PI / 2, axis=RIGHT).move_to(xf_2.get_center() + 1 * RIGHT).set_color(RED).scale(1.5)\n        dots2 = VGroup(xf_1, xf_2, xf_1_label, xf_2_label)\n        self.set_camera_orientation(phi=0.8 * np.pi / 2, theta=1.75 * np.pi, distance=20)\n        self.add_fixed_in_frame_mobjects(text2)\n        self.play(Write(text2))\n        self.wait(4)\n        self.play(ReplacementTransform(text2, text2_copy))\n        self.add_foreground_mobject(text2_copy)\n        self.add_fixed_in_frame_mobjects(text2_copy, text2.bg)\n        self.play(Write(text2.bg))\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie), fill_opacity=0.5)\n        self.remove_foreground_mobject(text2_copy)\n        self.play(FadeOut(text2.group))\n        self.add_foreground_mobject(text3[0])\n        self.add_fixed_in_frame_mobjects(text3.bg, text3[0])\n        self.play(Write(text3.bg), Write(text3[0]))\n        self.play(ShowCreation(f_1), Write(f_1_label))\n        self.play(Write(f_2_label), ShowCreation(f_2))\n        self.wait(5)\n        self.add_fixed_in_frame_mobjects(text3[1], text3.bg)\n        self.add_foreground_mobject(text3[1])\n        self.play(Write(text3[1]))\n        self.wait(3)\n        self.remove_foreground_mobject(text3)\n        self.play(FadeOut(text3.group))\n        self.add_fixed_in_frame_mobjects(text4.group)\n        self.play(Write(text4.group))\n        self.add_foreground_mobject(text4)\n        self.play(FadeOut(dots1))\n        self.play(Write(dots2))\n        self.wait(6)\n        self.remove_foreground_mobject(text4)\n        self.play(FadeOut(text4.group))\n        self.add_fixed_in_frame_mobjects(text5[0], text5.bg)\n        self.add_foreground_mobject(text5[0])\n        self.play(Write(text5.bg), Write(text5[0]))\n        self.wait(6.6)\n        self.add_foreground_mobject(text5[1])\n        self.add_fixed_in_frame_mobjects(text5[1])\n        self.play(Write(text5[1]))\n        self.play(ShowCreation(bola))\n        self.wait(4.5)\n        self.remove_foreground_mobject(text5)\n        self.play(FadeOut(text5.group))\n        self.add_fixed_in_frame_mobjects(text6_1, text6_1.bg)\n        self.add_foreground_mobject(text6_1)\n        self.play(Write(text6_1.bg), Write(text6_1))\n        self.wait(4.5)\n        self.remove_foreground_mobject(text6_1)\n        self.play(FadeOut(text6_1.group))\n        self.add_fixed_in_frame_mobjects(text7.bg, text7[0])\n        self.play(Write(text7.bg), Write(text7[0]))\n        self.wait(5.5)\n        self.add_fixed_in_frame_mobjects(text7[1])\n        self.play(Write(text7[1]))\n        self.wait(3)\n        self.add_fixed_in_frame_mobjects(text7[2])\n        self.play(Write(text7[2]))\n        self.wait(3)\n        self.play(FadeOut(text7.group), FadeOut(superficie), FadeOut(axes), FadeOut(dots2), FadeOut(bola))"}]}
{"messages": [{"role": "user", "content": "Present the chain rule formula with a detailed example, including the derivation of matrices and a visual representation of the functions and their tangent lines."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Regla_de_la_Cadena_I(ThreeDScene):\n\n    def construct(self):\n        Texto_Intro = TextMobject('Regla de la Cadena')\n        Text_R_C_1 = TextMobject('Sean $f: U \\\\subset \\\\mathbb{R}^n \\\\to \\\\mathbb{R}^m$, $g: V \\\\subset \\\\mathbb{R}^m \\\\to \\\\mathbb{R}^k$ y $\\\\hat{x_0} \\\\in U$ tales que')\n        Text_R_C_2 = TextMobject('$f(U) \\\\subset V$. Si $f$ es diferenciable en $\\\\hat{x_0}$ y $g$ es diferenciable en $\\\\hat{y_0} = f(\\\\hat{x_0})$,').next_to(Text_R_C_1, DOWN)\n        Text_R_C_3 = TextMobject('entonces $g \\\\circ f$ es diferenciable en $\\\\hat{x_0}$ y adem\u00e1s se tiene que:').next_to(Text_R_C_2, DOWN)\n        Text_R_C_4 = TextMobject('$D(g \\\\circ f)(\\\\hat{x_0}) = Dg(f(\\\\hat{x_0})) \\\\circ Df(\\\\hat{x_0})$').move_to(Text_R_C_3.get_center() + DOWN)\n        Text_R_C_5 = TextMobject('O en forma matricial:').move_to(Text_R_C_4.get_center() + DOWN)\n        Text_R_C_6 = TextMobject('$D(g \\\\circ f)(\\\\hat{x_0}) = [Dg(f(\\\\hat{x_0}))] [Df(\\\\hat{x_0})]$').move_to(Text_R_C_5.get_center() + DOWN)\n        Regla_de_la_Cadena = VGroup(Text_R_C_1, Text_R_C_2, Text_R_C_3, Text_R_C_4, Text_R_C_5, Text_R_C_6).move_to(0.3 * UP)\n        Regla_de_la_Cadena.scale(0.85)\n        Text_R_C_4.set_color(BLUE_D)\n        Text_R_C_6.set_color(BLUE_D)\n        Ejemplo1_T1 = TextMobject('Sea $f: \\\\mathbb{R} \\\\setminus \\\\{0\\\\} \\\\to \\\\mathbb{R}^2$ dada por $f(t) = (t^2, t^{-1}) $ y')\n        Ejemplo1_T2 = TextMobject('$g: \\\\mathbb{R}^2 \\\\to \\\\mathbb{R}$ dada por $g(x,y) = xe^{xy}$, entonces:').next_to(Ejemplo1_T1, DOWN)\n        Ejemplo1_T3 = TexMobject('D(g \\\\circ f) =', ' [Dg(f)]', ' [Df]=').move_to(Ejemplo1_T2.get_center() + DOWN)\n        Ejemplo1_T4 = TexMobject('=\\\\begin{bmatrix} e^t + te^t & \\\\quad t^4 e^t \\\\end{bmatrix}').next_to(Ejemplo1_T3, DOWN)\n        Ejemplo1_T5 = TexMobject('\\\\begin{bmatrix} 2t \\\\\\\\ -t^{-2} \\\\end{bmatrix}=').next_to(Ejemplo1_T4, RIGHT)\n        Matrices = VGroup(Ejemplo1_T4, Ejemplo1_T5).move_to(Ejemplo1_T3.get_center() + 1.3 * DOWN)\n        Ejemplo1_T6 = TexMobject('= 2te^t + 2t^2 e^t - t^2 e^t').next_to(Matrices, DOWN)\n        Ejemplo1_T7 = TexMobject(' = 2te^t + t^2 e^t').next_to(Ejemplo1_T6, RIGHT)\n        Resultado = VGroup(Ejemplo1_T6, Ejemplo1_T7).next_to(Matrices, DOWN)\n        Ejemplo1 = VGroup(Ejemplo1_T1, Ejemplo1_T2, Ejemplo1_T3, Matrices, Resultado).move_to(UP)\n        self.wait()\n        self.play(Write(Texto_Intro, run_time=2))\n        self.wait()\n        self.play(FadeOutAndShift(Texto_Intro, DOWN, run_time=2))\n        self.wait()\n        self.play(FadeIn(Text_R_C_1), FadeIn(Text_R_C_2), FadeIn(Text_R_C_3), FadeIn(Text_R_C_4))\n        self.wait(44)\n        self.play(Write(Text_R_C_5, run_time=2))\n        self.wait(3)\n        self.play(Write(Text_R_C_6, run_time=3))\n        self.wait(8)\n        self.play(FadeOut(Regla_de_la_Cadena, run_time=2))\n        self.wait(2)\n        self.play(FadeIn(Ejemplo1_T1))\n        self.play(FadeIn(Ejemplo1_T2))\n        self.wait(22)\n        self.play(Write(Ejemplo1_T3, run_time=3))\n        self.play(Indicate(Ejemplo1_T3[1], run_time=2))\n        self.play(Write(Ejemplo1_T4, run_time=2))\n        self.play(Indicate(Ejemplo1_T3[2], run_time=2))\n        self.play(Write(Ejemplo1_T5, run_time=2))\n        self.wait()\n        self.play(Write(Ejemplo1_T6, run_time=2))\n        self.wait()\n        self.play(Write(Ejemplo1_T7, run_time=2))\n        self.play(FadeOut(Ejemplo1, run_time=2))\n        self.wait()\n        t_final = TextMobject('Veamos la imagen de $f$ y las gr\u00e1ficas \\n\\n                                 de $g$ y $g\\\\circ f$')\n        t_2 = TextMobject('Imagen de $f$').to_edge(UP)\n        t_2.bg = SurroundingRectangle(t_2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_2_gpo = VGroup(t_2.bg, t_2)\n        t_3 = TextMobject('Gr\u00e1fica de $g$').to_edge(UP)\n        t_3.bg = SurroundingRectangle(t_3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_3_gpo = VGroup(t_3.bg, t_3)\n        t_4 = TextMobject('Gr\u00e1fica de $g\\\\circ f$').to_edge(UP)\n        t_4.bg = SurroundingRectangle(t_4, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_4_gpo = VGroup(t_4.bg, t_4)\n        t_5 = TextMobject('Veamos la recta tangente a la curva en \\n\\n                             $t=-2$').to_edge(UP)\n        t_5.bg = SurroundingRectangle(t_5, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_5_gpo = VGroup(t_5.bg, t_5)\n        t_6 = TextMobject('Notamos que esta tiene pendiente igual a 0.').to_edge(UP)\n        t_6.bg = SurroundingRectangle(t_6, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_6_gpo = VGroup(t_6.bg, t_6)\n        t_7 = TextMobject('Usando la regla de la cadena, obtenemos que \\n\\n                             la derivada en $t=-2$ es precisamente 0.').to_edge(UP)\n        t_7.bg = SurroundingRectangle(t_7, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        t_7_gpo = VGroup(t_7.bg, t_7)\n        ejes3D = ThreeDAxes(x_min=-5, x_max=5, y_min=-5, y_max=5, z_min=-4, z_max=4)\n        x_label = TexMobject('x').scale(0.75).move_to((5.3, -0.3, 0))\n        y_label = TexMobject('y').scale(0.75).move_to((-0.3, 5.3, 0))\n        y_label_2 = TexMobject('y').scale(0.75).move_to((-0.5, 4, 0))\n        axes3D = VGroup(ejes3D, x_label, y_label)\n        ejes2D = Axes(x_min=-5, x_max=5, y_min=-4, y_max=4)\n        axes2D = VGroup(ejes2D, x_label, y_label_2)\n        Superficie = ParametricSurface(lambda u, v: np.array([u, v, u * np.exp(u * v)]), v_min=-1.5, v_max=1.5, u_min=-1.5, u_max=1.5, checkerboard_colors=[GREEN_C, GREEN_D], resolution=(20, 40), stroke_width=0, fill_opacity=0.7)\n        Curva1 = ParametricFunction(lambda u: np.array([u ** 2, u ** (-1), 0]), color=RED, t_min=-5 ** (1 / 2), t_max=-0.2)\n        Curva2 = ParametricFunction(lambda u: np.array([u ** 2, u ** (-1), 0]), color=RED, t_min=0.2, t_max=5 ** (1 / 2))\n        Curva = VGroup(Curva1, Curva2)\n        Composicion = ParametricFunction(lambda x: np.array([x, x ** 2 * np.exp(x), 0]), color=YELLOW, t_min=-5, t_max=1.13)\n        tangente = ParametricFunction(lambda x: np.array([x, 4 * np.exp(-2), 0]), color=RED, t_min=-5, t_max=1)\n        self.play(Write(t_final))\n        self.wait(3.5)\n        self.play(FadeOut(t_final))\n        self.play(Write(axes2D))\n        self.play(Write(t_2_gpo))\n        self.play(Write(Curva))\n        self.wait(2)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n        self.move_camera(phi=80 * DEGREES, theta=30 * DEGREES, frame_center=(0, 0, 2))\n        self.play(Write(axes3D), run_time=0.5)\n        self.add_fixed_in_frame_mobjects(t_3_gpo)\n        self.play(Write(t_3_gpo))\n        self.play(Write(Superficie))\n        self.wait(2)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])\n        self.move_camera(phi=0 * DEGREES, theta=-90 * DEGREES)\n        axes2D.shift(2 * DOWN)\n        Composicion.shift(2 * DOWN)\n        self.play(Write(t_4_gpo))\n        self.play(Write(axes2D))\n        self.add(t_4_gpo)\n        self.play(Write(Composicion))\n        self.add(t_4_gpo)\n        self.wait(2)\n        self.play(FadeOut(t_4_gpo))\n        self.play(Write(t_5_gpo))\n        self.wait()\n        tangente.shift(2 * DOWN)\n        self.play(ShowCreation(tangente))\n        self.play(FadeOut(t_5_gpo))\n        self.play(Write(t_6_gpo))\n        self.wait(2)\n        self.play(FadeOut(t_6_gpo))\n        self.play(Write(t_7_gpo))\n        self.wait(6)\n        self.play(*[FadeOut(obj) for obj in self.mobjects])"}]}
{"messages": [{"role": "user", "content": "Present the chain rule with an example involving vector-valued functions and their Jacobian matrices, showing the matrix transformations."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Regla_de_la_Cadena_II(Scene):\n\n    def construct(self):\n        Ejemplo2_T1 = TextMobject('Consideremos $g:\\\\mathbb{R}^2 \\\\to \\\\mathbb{R}^2$, dada por $g(\\\\rho, \\\\theta) = (\\\\rho cos(\\\\theta), \\\\rho \\\\sin(\\\\theta))$ y')\n        Ejemplo2_T2 = TextMobject('una funci\u00f3n derivable $f: \\\\mathbb{R}^2 \\\\to \\\\mathbb{R}^m$, entonces:').next_to(Ejemplo2_T1, DOWN)\n        Enunciado2 = VGroup(Ejemplo2_T1, Ejemplo2_T2)\n        Ejemplo2_T3 = TexMobject('D(f \\\\circ g) =', ' [Df(g)]', ' [Dg]').move_to(Ejemplo2_T2.get_center() + DOWN)\n        Ejemplo2_T4 = TexMobject('\\\\begin{bmatrix} \\\\cfrac{\\\\partial f}{\\\\partial x_1} (g) & \\\\quad \\\\cfrac{\\\\partial f}{\\\\partial y_1} (g) \\\\\\\\ \\\\vdots & \\\\vdots \\\\\\\\ \\\\cfrac{\\\\partial f}{\\\\partial x_m} (g) & \\\\cfrac{\\\\partial f}{\\\\partial y_m} (g) \\\\end{bmatrix}').next_to(Ejemplo2_T3, DOWN)\n        Ejemplo2_T5 = TexMobject('\\\\begin{bmatrix} \\\\cfrac{\\\\partial}{\\\\partial \\\\rho} \\\\rho \\\\cos(\\\\theta) & \\\\cfrac{\\\\partial}{\\\\partial \\\\theta} \\\\rho \\\\cos(\\\\theta) \\\\\\\\ \\\\cfrac{\\\\partial}{\\\\partial \\\\rho} \\\\rho \\\\sin(\\\\theta) & \\\\cfrac{\\\\partial}{\\\\partial \\\\theta} \\\\rho \\\\sin(\\\\theta) \\\\end{bmatrix}').next_to(Ejemplo2_T4, RIGHT)\n        Ejemplo2_T6 = TexMobject('\\\\begin{bmatrix} \\\\cos(\\\\theta) & \\\\quad -\\\\rho \\\\sin{\\\\theta} \\\\\\\\ \\\\sin{\\\\theta} & \\\\rho \\\\cos{\\\\theta} \\\\end{bmatrix}').next_to(Ejemplo2_T4, RIGHT)\n        Matrices2 = VGroup(Ejemplo2_T4, Ejemplo2_T5, Ejemplo2_T6).move_to(Ejemplo2_T3.get_center() + 2.5 * DOWN)\n        Ejemplo2 = VGroup(Enunciado2, Ejemplo2_T3, Matrices2).scale(0.9)\n        Ejemplo2.move_to(0.5 * UP)\n        self.wait()\n        self.play(FadeIn(Ejemplo2_T1))\n        self.play(FadeIn(Ejemplo2_T2))\n        self.wait(15.5)\n        self.play(Write(Ejemplo2_T3, run_time=3))\n        self.play(Indicate(Ejemplo2_T3[1], run_time=2))\n        self.wait()\n        self.play(Write(Ejemplo2_T4, run_time=3))\n        self.wait()\n        self.play(Indicate(Ejemplo2_T3[2], run_time=2))\n        self.wait()\n        self.play(Write(Ejemplo2_T5, run_time=3))\n        self.wait(2)\n        self.play(ReplacementTransform(Ejemplo2_T5, Ejemplo2_T6, run_time=3))\n        self.wait(4)\n        self.play(FadeOut(Ejemplo2, run_time=2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the Bolzano-Weierstrass theorem by showing a bounded sequence and then demonstrating the construction of a convergent subsequence through nested rectangles."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass BolzanoWeierstrass(Scene):\n\n    def construct(self):\n        titulo = TextMobject('El Teorema de Bolzano-Weierstrass').scale(1.5)\n        teorema_1 = TexMobject(\"\\\\text{Toda sucesi\\\\'{o}n}\\\\ \", '\\\\text{acotada}\\\\ ', '\\\\text{en}\\\\  \\\\mathbb{R}^n')\n        teorema_2 = TextMobject('\\\\text{tiene una}', \" subsucesi\\\\'{o}n convergente.\").next_to(teorema_1, DOWN)\n        teorema = VGroup(teorema_1, teorema_2)\n        teorema_1[1].set_color(YELLOW)\n        teorema_2[1].set_color(RED)\n        plano = NumberPlane()\n        suc_acot = TexMobject(\"\\\\text{Sea}\\\\ \\\\{\\\\vec{x}_n\\\\}\\\\ \\\\text{una sucesi\\\\'{o}n}\\\\ \", '\\\\text{acotada}', '\\\\text{ por M}').to_edge(UP)\n        suc_acot[1].set_color(YELLOW)\n        suc_acot.bg = SurroundingRectangle(suc_acot, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        group_acot = VGroup(suc_acot.bg, suc_acot)\n        points_infinite_values = []\n        for n in range(3, 1500):\n            points_infinite_values.append(CCustomDot(point=np.array([np.sqrt(2) * np.power(-1, n) * n / (n + 3), np.sqrt(2) * n / (n + 3), 0.0]), color=GREY).scale(0.7))\n        group2 = VGroup(*points_infinite_values)\n        circulo = Circle(radius=np.sqrt(np.power(np.sqrt(2), 2) + np.power(np.sqrt(2), 2))).set_color(YELLOW)\n        M_der = TexMobject('M').scale(0.75).move_to((2.4, 0, 0))\n        M_izq = TexMobject('-M').scale(0.75).move_to((-2.4, 0, 0))\n        M_arb = TexMobject('M').scale(0.75).move_to((0, 2.2, 0))\n        M_abj = TexMobject('-M').scale(0.75).move_to((0, -2.2, 0))\n        emes = VGroup(M_der, M_izq, M_arb, M_abj)\n        el_rect = TextMobject(\"\\\\text{Acotemos la sucesi\\\\'{o}n con un rect\\\\'{a}ngulo de lado 2M:} \", '\\\\text{$R$}').to_edge(UP).scale(0.8)\n        el_rect[1].set_color(YELLOW)\n        R = Rectangle(height=2 * np.sqrt(np.power(np.sqrt(2), 2) + np.power(np.sqrt(2), 2)), width=2 * np.sqrt(np.power(np.sqrt(2), 2) + np.power(np.sqrt(2), 2))).set_color(YELLOW)\n        subrect_1a = TextMobject(\"\\\\text{Tomemos un subrect\\\\'{a}ngulo con una cantidad infinita}\").to_edge(UP)\n        subrect_1b = TexMobject(\"\\\\text{de t\\\\'{e}rminos de la sucesi\\\\'{o}n: } \", '\\\\text{$R_1$}').next_to(subrect_1a, DOWN)\n        subrect_1b[1].set_color(ORANGE)\n        cuadrante_dR1 = TexMobject('\\\\text{Notemos que}\\\\ ', 'R_1\\\\ ', '\\\\text{es un cuadrante de}\\\\ ', 'R').to_edge(DOWN)\n        cuadrante_dR1[1].set_color(ORANGE)\n        cuadrante_dR1[3].set_color(YELLOW)\n        subrect_1 = VGroup(subrect_1a, subrect_1b).scale(0.8)\n        R1 = Rectangle(height=2, width=2).move_to((1, 1, 0)).set_color(ORANGE)\n        subrect_2a = TextMobject(\"\\\\text{Nuevamente tomemos un subrect\\\\'{a}ngulo que sea un cuadrante del}\").to_edge(UP).scale(0.8)\n        subrect_2b = TextMobject(\"\\\\text{anterior con infinitos t\\\\'{e}rminos de la sucesi\\\\'{o}n:} \", '\\\\text{$R_2$}').next_to(subrect_2a, DOWN).scale(0.8)\n        subrect_2b[1].set_color(GREEN)\n        subrect_2 = VGroup(subrect_2a, subrect_2b)\n        R2 = Rectangle(height=1, width=1).move_to((1.5, 1.5, 0)).set_color(GREEN)\n        subrects_a = TextMobject(\"\\\\text{Repetimos infinitas veces, siempre tomando un subrect\\\\'{a}ngulo}\").to_edge(UP).scale(0.8)\n        subrects_b = TextMobject(\"\\\\text{con una cantidad infinita de t\\\\'{e}rminos de la sucesi\\\\'{o}n}\").next_to(subrects_a, DOWN).scale(0.8)\n        subrects = VGroup(subrects_a, subrects_b)\n        R3 = Rectangle(height=0.5, width=0.5).move_to((1.25, 1.25, 0)).set_color(BLUE)\n        R4 = Rectangle(height=0.25, width=0.25).move_to((1.375, 1.375, 0)).set_color(PURPLE)\n        R5 = Rectangle(height=0.125, width=0.125).move_to((1.4375, 1.4375, 0)).set_color(PINK)\n        R6 = Rectangle(height=0.0625, width=0.0625).move_to((1.46875, 1.46875, 0)).set_color(TEAL)\n        Rects = VGroup(R, R1, R2, R3, R4, R5, R6)\n        notas_rect_0 = TextMobject(\"\\\\text{Tenemos una sucesi\\\\'{o}n de rect\\\\'{a}ngulos anidados que cumplen:}\").to_edge(UP).scale(0.8)\n        notas_rect_1 = TexMobject('1)\\\\ R_{k+1} \\\\subset R_{k}').next_to(notas_rect_0, 5 * DOWN).shift(2 * RIGHT).scale(0.8)\n        notas_rect_2 = TexMobject('2)\\\\ diag(R_{k})= \\\\frac{\\\\sqrt{2}M}{2^{k-1}}').next_to(notas_rect_1, DOWN).scale(0.8)\n        notas_rect_3 = TexMobject('3)\\\\ R_{k+1}\\\\ \\\\text{tiene infinitos puntos de}\\\\ \\\\{\\\\vec{x}_n\\\\}').next_to(notas_rect_2, 1.5 * DOWN).scale(0.8).shift(1 * RIGHT)\n        TRA_a = TextMobject('Gracias a las observaciones 1 y 2, y al teorema ').move_to(notas_rect_0)\n        TRA_b = TextMobject(\"\\\\text{de los rect\\\\'{a}ngulos anidados, existe} \", '$\\\\cap_{k=1}^{\\\\infty}R_k =$', ' $\\\\vec{x}_0$').next_to(TRA_a, DOWN)\n        TRA_b[2].set_color(BLUE)\n        TRA = VGroup(TRA_a, TRA_b).scale(0.9)\n        construyamos_0 = TextMobject(\"\\\\text{Construyamos una subsucesi\\\\'{o}n}\").shift(3 * RIGHT + UP)\n        construyamos_1 = TextMobject('que converge a ', '$\\\\vec{x}_0$').next_to(construyamos_0, DOWN)\n        construyamos_1[1].set_color(BLUE)\n        construyamos = VGroup(construyamos_0, construyamos_1).scale(0.9)\n        subsuc = TextMobject(\"\\\\text{La observaci\\\\'{o}n 3 nos permite tomar}\").scale(0.8).shift(3 * RIGHT + UP)\n        subsuc_1 = TexMobject('\\\\vec{x}_{n_1}', '\\\\in R_1').shift(3 * RIGHT)\n        subsuc_1[0].set_color(RED)\n        subsuc_2a = TexMobject('\\\\vec{x}_{n_2}', '\\\\in R_2').shift(3 * RIGHT)\n        subsuc_2a[0].set_color(RED)\n        subsuc_2b = TexMobject('\\\\text{tomando } n_2>n_1').next_to(subsuc_2a, 1.5 * DOWN).scale(0.9)\n        subsuc_2 = VGroup(subsuc_2a, subsuc_2b)\n        subsuc_3a = TexMobject('\\\\vec{x}_{n_3}', '\\\\in R_3').shift(3 * RIGHT)\n        subsuc_3a[0].set_color(RED)\n        subsuc_3b = TexMobject('\\\\text{tomando } n_3>n_2').next_to(subsuc_3a, 1.5 * DOWN).scale(0.9)\n        subsuc_3 = VGroup(subsuc_3a, subsuc_3b)\n        subsuc_ka = TexMobject('\\\\vec{x}_{n_k}', '\\\\in R_k').shift(3 * RIGHT)\n        subsuc_ka[0].set_color(RED)\n        subsuc_kb = TexMobject('\\\\text{tomando } n_k>n_{k-1}').next_to(subsuc_3a, 1.5 * DOWN).scale(0.9)\n        subsuc_k = VGroup(subsuc_ka, subsuc_kb)\n        casi_conclu_a = TextMobject('De esta forma').move_to(construyamos_1).shift(3 * UP)\n        casi_conclu_b = TexMobject('0\\\\leq d(\\\\vec{x}_{n_k},\\\\vec{x}_0)\\\\leq \\\\frac{\\\\sqrt{2}M}{2^{k-1}}').next_to(casi_conclu_a, DOWN)\n        casi_conclu = VGroup(casi_conclu_a, casi_conclu_b).scale(0.9)\n        pre_conclu_a = TexMobject('\\\\text{y como } \\\\lim_{k \\\\to \\\\infty} \\\\frac{\\\\sqrt{2}M}{2^{k-1}} = 0').move_to(notas_rect_3).shift(2 * UP)\n        pre_conclu_b = TexMobject(' \\\\Rightarrow \\\\lim_{k \\\\to \\\\infty} d(\\\\vec{x}_{n_k},\\\\vec{x}_0) = 0').next_to(pre_conclu_a, DOWN)\n        pre_conclu = VGroup(pre_conclu_a, pre_conclu_b).scale(0.8)\n        conclu_a = TextMobject('Tenemos').move_to(notas_rect_3).scale(0.9)\n        conclu_b = TexMobject('\\\\lim_{k \\\\to \\\\infty} \\\\{\\\\vec{x}_{n_k}\\\\} = \\\\vec{x}_0').next_to(conclu_a, 1.6 * DOWN)\n        conclu_c = TextMobject('nuestra ', \"\\\\text{subsucesi\\\\'{o}n convergente.}\").next_to(conclu_b, 1.3 * DOWN)\n        conclu_c[1].set_color(RED)\n        conclu_rect = Rectangle(color=RED, width=1.2 * conclu_b.get_width(), height=1.3 * conclu_b.get_height()).move_to(conclu_b)\n        conclu = VGroup(conclu_a, conclu_b, conclu_c, conclu_rect)\n        self.play(Write(titulo))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.play(Write(teorema))\n        self.wait(2)\n        self.play(FadeOut(teorema))\n        self.play(ShowCreation(plano))\n        self.play(Write(group_acot))\n        self.play(ShowIncreasingSubsets(group2, run_time=2.0))\n        self.play(ShowCreation(circulo), ShowCreation(emes))\n        self.wait()\n        self.play(ReplacementTransform(group_acot, el_rect), FadeOut(plano))\n        self.wait(2)\n        self.play(ShowCreation(R), FadeOut(circulo))\n        self.wait(2)\n        self.play(ReplacementTransform(el_rect, subrect_1), Write(cuadrante_dR1))\n        self.wait(3)\n        self.play(ShowCreation(R1))\n        self.wait(3)\n        self.play(ReplacementTransform(subrect_1, subrect_2), FadeOut(cuadrante_dR1))\n        self.wait(2)\n        self.play(ShowCreation(R2))\n        self.wait(6)\n        self.play(ReplacementTransform(subrect_2, subrects))\n        self.wait(2)\n        self.play(ShowCreation(R3))\n        self.play(ShowCreation(R4))\n        self.play(ShowCreation(R5))\n        self.play(ShowCreation(R6))\n        self.wait()\n        self.play(FadeOut(subrects))\n        self.play(emes.shift, 3 * LEFT, group2.shift, 3 * LEFT, R.shift, 3 * LEFT, R1.shift, 3 * LEFT, R2.shift, 3 * LEFT, R3.shift, 3 * LEFT, R4.shift, 3 * LEFT, R5.shift, 3 * LEFT, R6.shift, 3 * LEFT)\n        self.play(FadeOut(emes))\n        self.play(Write(notas_rect_0))\n        self.wait(2)\n        self.play(Write(notas_rect_1))\n        self.wait(2)\n        self.play(Write(notas_rect_2))\n        self.wait(2)\n        self.play(Write(notas_rect_3))\n        self.wait(4)\n        self.play(FadeOut(notas_rect_1), FadeOut(notas_rect_2), FadeOut(notas_rect_3), ReplacementTransform(notas_rect_0, TRA))\n        self.wait(2)\n        self.play(ApplyMethod(points_infinite_values[1495].custom_method, BLUE))\n        self.play(ApplyMethod(points_infinite_values[1495].other_method, run_time=1.5))\n        self.wait(2)\n        self.play(Write(construyamos))\n        self.wait(2)\n        self.play(FadeOut(TRA), construyamos.shift, 2 * UP)\n        self.wait(2)\n        self.play(Write(subsuc), Write(subsuc_1))\n        self.play(ApplyMethod(points_infinite_values[1].custom_method, RED))\n        self.play(ApplyMethod(points_infinite_values[1].other_method))\n        self.wait(2)\n        self.play(FadeOut(subsuc))\n        self.play(ReplacementTransform(subsuc_1, subsuc_2), ApplyMethod(points_infinite_values[7].custom_method, RED))\n        self.play(ApplyMethod(points_infinite_values[7].other_method))\n        self.wait(2)\n        self.play(ReplacementTransform(subsuc_2, subsuc_3), ApplyMethod(points_infinite_values[51].custom_method, RED))\n        self.play(ApplyMethod(points_infinite_values[51].other_method))\n        self.wait(2)\n        self.play(ReplacementTransform(subsuc_3, subsuc_k), ApplyMethod(points_infinite_values[799].custom_method, RED))\n        self.play(ApplyMethod(points_infinite_values[799].other_method))\n        self.play(FadeOut(subsuc_k), FadeOut(construyamos))\n        self.play(Write(casi_conclu))\n        self.wait(8)\n        self.play(Write(pre_conclu))\n        self.wait(11)\n        self.play(Write(conclu))\n        self.wait(4)\n        self.play(FadeOut(casi_conclu), FadeOut(pre_conclu), FadeOut(Rects), FadeOut(group2))\n        self.play(conclu.move_to, (0, 0, 0))\n        self.wait(2)\n        self.play(FadeOut(conclu))"}]}
{"messages": [{"role": "user", "content": "Present a series of animations explaining the concepts of maxima, minima, critical points, and the Hessian matrix in multivariable calculus."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass maximos_minimos(ThreeDScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        ThreeDScene.setup(self)\n\n    def FadeOutWrite3D(self, objeto1, objeto2):\n        self.play(FadeOut(objeto1))\n        self.acomodar_textos(objeto2)\n\n    def acomodar_textos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.play(Write(objeto))\n\n    def punto3D(self):\n        bola = ParametricSurface(lambda u, v: np.array([0.075 * np.cos(v) * np.sin(u), 0.075 * np.sin(v) * np.sin(u), 0.075 * np.cos(u)]), v_min=0, v_max=TAU, u_min=0.001, u_max=PI - 0.001, resolution=(24, 24), fill_opacity=1, stroke_color=RED, fill_color=RED)\n        return bola\n\n    def get_vector_field(self, campo):\n        self.vector_field = VectorField(campo, x_min=-5, x_max=5, y_min=-3, y_max=3, delta_x=0.25, delta_y=0.25, length_func=lambda norm: 0.5 * sigmoid(norm), colors=[GREEN])\n        return self.vector_field\n\n    def superficie(self):\n        superficie = ParametricSurface(lambda u, v: np.array([u, v, u ** 3 - v ** 3 + 3 * u * v]), v_min=-2, v_max=1.5, u_min=-1.5, u_max=2, fill_color=PURPLE_E, fill_opacity=0.75, resolution=(30, 30))\n        return superficie\n\n    def superficie2(self):\n        superficie = ParametricSurface(lambda u, v: np.array([u, v, u ** 4 + v ** 4]), v_min=-1.4, v_max=1.4, u_min=-1.4, u_max=1.4, fill_color=PURPLE_E, fill_opacity=0.75, resolution=(30, 30))\n        return superficie\n\n    def PrimeraEscena(self):\n        titulo = TextMobject('M\u00e1ximos y M\u00ednimos').scale(1.5)\n        texto_1 = TextMobject('Consideremos la siguiente funci\u00f3n').move_to(UP)\n        texto_2_1 = TexMobject('f:\\\\mathbb{R}^2\\\\to\\\\mathbb{R}').next_to(texto_1, DOWN)\n        texto_2_2 = TexMobject('f(x,y)=x^3-y^3+3xy').next_to(texto_2_1, DOWN)\n        texto_2 = VGroup(texto_2_1, texto_2_2)\n        texto_3 = TextMobject('La gr\u00e1fica de $f$ es una superficie en $\\\\mathbb{R}^3$').move_to(UP)\n        axes = ThreeDAxes(x_min=-2.5, x_max=2.5, y_min=-2.5, y_max=2.5, z_min=-1, z_max=3, num_axis_pieces=30)\n        superficie = self.superficie()\n        self.play(Write(titulo))\n        self.wait(3)\n        self.FadeOutWrite3D(titulo, texto_1)\n        self.wait(3)\n        self.play(Write(texto_2))\n        self.wait(5)\n        self.play(FadeOut(texto_1))\n        self.play(Write(texto_3))\n        self.wait(5)\n        self.play(FadeOut(texto_2_1), FadeOut(texto_3))\n        self.play(texto_2_2.shift, +4.3 * LEFT)\n        self.add_fixed_in_frame_mobjects(texto_2_2)\n        self.wait(0.5)\n        self.move_camera(phi=70 * DEGREES, theta=120 * DEGREES, frame_center=(0, 0, 1))\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie))\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait(4)\n        self.stop_ambient_camera_rotation()\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.move_camera(phi=0, theta=-90 * DEGREES, frame_center=(0, 0, 0))\n\n    def SegundaEscena(self):\n        texto_1 = TextMobject('Consideremos el campo gradiente de la funci\u00f3n $f$').move_to(UP)\n        texto_2_1 = TexMobject('\\\\nabla f:\\\\mathbb{R}^2\\\\to\\\\mathbb{R}^2').next_to(texto_1, DOWN)\n        texto_2_2 = TexMobject('\\\\nabla f(x,y)=(3y+3x^2,3x-3y^2)').next_to(texto_2_1, DOWN)\n        texto_2_2_copy = texto_2_2.copy().move_to(3 * DOWN)\n        texto_2_2.bg = SurroundingRectangle(texto_2_2_copy, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        caja_texto_2_2 = VGroup(texto_2_2.bg, texto_2_2_copy)\n        texto_2 = VGroup(texto_2_1, texto_2_2)\n        texto_3 = TextMobject('Se dice que un punto $(x_0,y_0)$ del dominio de $f$ \\n\\n                                es un punto cr\u00edtico si $\\\\nabla f(x_0,y_0)=\\\\Vec{0}$').move_to(3 * UP)\n        texto_3.bg = SurroundingRectangle(texto_3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        caja_texto_3 = VGroup(texto_3.bg, texto_3)\n        texto_4 = TextMobject('Es decir, si sus derivadas parciales son igual a cero').move_to(3 * UP)\n        texto_4.bg = SurroundingRectangle(texto_4, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        caja_texto_4 = VGroup(texto_4.bg, texto_4)\n        texto_5 = TextMobject('En el ejemplo, el punto $(0,0)$ es un punto cr\u00edtico de $f$').move_to(3 * UP)\n        texto_5.bg = SurroundingRectangle(texto_5, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        caja_texto_5 = VGroup(texto_5.bg, texto_5)\n        axes = NumberPlane()\n        punto_critico = Dot(color=RED)\n\n        def campo(point):\n            x, y = point[:2]\n            return 3 * y + 3 * x ** 2 * RIGHT + 3 * x - 3 * y ** 2 * UP\n        campo = self.get_vector_field(campo)\n        self.play(Write(texto_1))\n        self.wait(5)\n        self.play(Write(texto_2))\n        self.wait(8)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(campo))\n        self.play(ShowCreation(caja_texto_2_2))\n        self.wait(4)\n        self.play(ShowCreation(caja_texto_3))\n        self.wait(9)\n        self.play(FadeOut(caja_texto_3))\n        self.play(ShowCreation(caja_texto_4))\n        self.wait(6)\n        self.play(FadeOut(caja_texto_4))\n        self.play(ShowCreation(caja_texto_5))\n        self.wait(7)\n        self.play(FadeIn(punto_critico))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n\n    def TercerEscena(self):\n        texto_1 = TextMobject(' Ahora aproximamos el campo gradiente de $f$ alrededor \\n\\n                                 de $(0,0)$, utilizando su derivada $D(\\\\nabla f)$ ')\n        texto_2 = TextMobject(' La matriz asociada a $D(\\\\nabla f)$ se llama matriz hessiana ')\n        texto_3 = TextMobject('En el ejemplo,').move_to(1.5 * UP)\n        texto_4 = TexMobject(' D(\\\\nabla f)= \\\\begin{pmatrix} 6x & 3 \\\\\\\\ 3 & -6y \\\\end{pmatrix} ')\n        texto_5 = TextMobject('En particular sobre el punto $(0,0)$,').move_to(1.5 * UP)\n        texto_6 = TexMobject(' D_{\\\\Vec{0}}(\\\\nabla f)= \\\\begin{pmatrix} 0 & 3 \\\\\\\\ 3 & 0 \\\\end{pmatrix}, ')\n        texto_6_1 = TextMobject('donde $\\\\text{det}(D_{\\\\Vec{0}}(\\\\nabla f))< 0$').move_to(1.5 * DOWN)\n        texto_7 = TextMobject('Veamos c\u00f3mo la hessiana aproxima al campo gradiente de $f$')\n        texto_7_1 = TexMobject('D_{\\\\Vec{0}}(\\\\nabla f)(x,y)=(3y,3x)').move_to(3 * DOWN)\n        texto_7_1.bg = SurroundingRectangle(texto_7_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        caja_texto_7_1 = VGroup(texto_7_1.bg, texto_7_1)\n        texto_8 = TextMobject('Como $f\\\\in C^2$, $\\\\nabla f\\\\in C^1$ y $\\\\text{det}(D_{\\\\Vec{0}}(\\\\nabla f))\\\\neq 0$').move_to(3 * UP)\n        texto_8.bg = SurroundingRectangle(texto_8, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        caja_texto_8 = VGroup(texto_8.bg, texto_8)\n        texto_9 = TextMobject(' a partir de la hessiana podemos conocer el comportamiento \\n \\n                                cualitativo de $\\\\nabla f$ alrededor del punto cr\u00edtico $(0,0)$ ').move_to(3 * UP)\n        texto_9.bg = SurroundingRectangle(texto_9, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        caja_texto_9 = VGroup(texto_9.bg, texto_9)\n        axes = NumberPlane()\n        punto_critico = Dot(color=RED)\n\n        def campo(point):\n            x, y = point[:2]\n            return 3 * y * RIGHT + 3 * x * UP\n        campo = self.get_vector_field(campo)\n        self.play(Write(texto_1))\n        self.wait(7)\n        self.FadeOutWrite3D(texto_1, texto_2)\n        self.wait(5)\n        self.FadeOutWrite3D(texto_2, texto_3)\n        self.wait(5)\n        self.play(Write(texto_4))\n        self.wait(2)\n        self.FadeOutWrite3D(texto_3, texto_5)\n        self.wait(4)\n        self.play(ReplacementTransform(texto_4, texto_6))\n        self.wait(4)\n        self.play(Write(texto_6_1))\n        self.wait(4)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.play(Write(texto_7))\n        self.wait(5)\n        self.play(FadeOut(texto_7))\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(campo))\n        self.play(ShowCreation(caja_texto_7_1))\n        self.wait(3)\n        self.play(ShowCreation(caja_texto_8))\n        self.wait(7)\n        self.play(FadeOut(caja_texto_8))\n        self.play(ShowCreation(caja_texto_9))\n        self.wait(9)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n\n    def CuartaEscena(self):\n        texto_1 = TextMobject(' En este caso $\\\\text{det}(D_{\\\\Vec{0}}(\\\\nabla f))< 0$, por lo tanto,\\n\\n                                     el punto $(0,0)$ es un punto silla de $f$ ').move_to(3 * UP)\n        texto_1.bg = SurroundingRectangle(texto_1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        caja_texto_1 = VGroup(texto_1.bg, texto_1)\n        texto_2 = TextMobject(' En general, dado un campo escalar $f:A\\\\subset\\\\mathbb{R}^2\\\\to\\\\mathbb{R}$ de \\n\\n                                 clase $C^2$,  con un punto cr\u00edtico $\\\\Vec{x_0}$ en el interior de $A$ y \\n\\n                                $H(\\\\Vec{x_0})$ la matriz hessiana en $\\\\Vec{x_0}$,').move_to(2 * UP)\n        texto_3 = TextMobject(' i) Si $\\\\text{det}(H(\\\\Vec{x_0}))< 0$, $\\\\Vec{x_0}$ es un punto silla').next_to(texto_2, 1.5 * DOWN)\n        texto_4 = TextMobject(' ii) Si $\\\\text{det}(H(\\\\Vec{x_0}))> 0$ y $(H(\\\\Vec{x_0}))_{11}$>0, $\\\\Vec{x_0}$ es un m\u00ednimo local').next_to(texto_3, 1 * DOWN)\n        texto_5 = TextMobject(' iii) Si $\\\\text{det}(H(\\\\Vec{x_0}))> 0$ y $(H(\\\\Vec{x_0}))_{11}$<0, $\\\\Vec{x_0}$ es un m\u00e1ximo local').next_to(texto_4, 1 * DOWN)\n        texto_6 = TextMobject(' iv) Si $\\\\text{det}(H(\\\\Vec{x_0}))= 0$, este criterio no es aplicable').next_to(texto_5, 1 * DOWN)\n        axes = ThreeDAxes(x_min=-2.5, x_max=2.5, y_min=-2.5, y_max=2.5, z_min=-1, z_max=3, num_axis_pieces=30)\n        superficie = self.superficie()\n        punto = self.punto3D()\n        self.move_camera(phi=70 * DEGREES, theta=120 * DEGREES, frame_center=(0, 0, 1))\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie))\n        self.wait()\n        self.play(FadeIn(punto))\n        self.acomodar_textos(caja_texto_1)\n        self.wait(8)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.move_camera(phi=0, theta=-90 * DEGREES, frame_center=(0, 0, 0))\n        self.play(Write(texto_2))\n        self.wait(12)\n        self.play(Write(texto_3))\n        self.wait(5)\n        self.play(Write(texto_4))\n        self.wait(7)\n        self.play(Write(texto_5))\n        self.wait(7)\n        self.play(Write(texto_6))\n        self.wait(5)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n\n    def QuintaEscena(self):\n        texto_1 = TextMobject(' Ahora consideremos una superficie dada por \\n\\n                                la gr\u00e1fica de la siguiente funci\u00f3n ').move_to(1.5 * UP)\n        texto_2_1 = TexMobject('f:\\\\mathbb{R}^2\\\\to\\\\mathbb{R}')\n        texto_2_2 = TexMobject('f(x,y)=x^4+y^4').next_to(texto_2_1, DOWN)\n        texto_2 = VGroup(texto_2_1, texto_2_2)\n        texto_3 = TextMobject(' Podemos obtener el campo gradiente, as\u00ed como\\n\\n                             la matriz hessiana de la funci\u00f3n $f$').move_to(1.5 * UP)\n        texto_4 = TexMobject('\\\\nabla f(x,y)=(4x^3,4y^3)')\n        texto_5 = TexMobject(' D(\\\\nabla f)= \\\\begin{pmatrix} 12x^2 & 0 \\\\\\\\ 0 & 12y^2 \\\\end{pmatrix} ').next_to(texto_4, DOWN)\n        texto_6 = TextMobject(' Obs\u00e9rvese que en el punto $(0,0)$ \\n \\n                                hay un punto cr\u00edtico de $f$ ').move_to(1.5 * UP)\n        texto_7 = TextMobject(' Pero en $(0,0)$ la hessiana se vuelve ').move_to(1.5 * UP)\n        texto_8 = TexMobject(' D_{\\\\Vec{0}}(\\\\nabla f)= \\\\begin{pmatrix} 0 & 0 \\\\\\\\ 0 & 0 \\\\end{pmatrix} ').next_to(texto_4, DOWN)\n        texto_9 = TextMobject(' En este caso la matriz hessiana no nos permite clasificar el \\n\\n                                punto cr\u00edtico, por lo tanto el criterio no es siempre aplicable ')\n        axes = ThreeDAxes(x_min=-2.5, x_max=2.5, y_min=-2.5, y_max=2.5, z_min=-1, z_max=3, num_axis_pieces=30)\n        superficie = self.superficie2()\n        self.play(Write(texto_1))\n        self.wait(6)\n        self.play(Write(texto_2))\n        self.wait(5)\n        self.play(FadeOut(texto_2_1), FadeOut(texto_1))\n        self.play(texto_2_2.shift, +4 * LEFT + 1.5 * UP)\n        self.add_fixed_in_frame_mobjects(texto_2_2)\n        self.wait(0.5)\n        self.move_camera(phi=85 * DEGREES, theta=120 * DEGREES, frame_center=(0, 0, 1))\n        self.play(ShowCreation(axes))\n        self.play(ShowCreation(superficie))\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait(4)\n        self.stop_ambient_camera_rotation()\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.move_camera(phi=0, theta=-90 * DEGREES, frame_center=(0, 0, 0))\n        self.play(Write(texto_3))\n        self.wait(7)\n        self.play(Write(texto_4))\n        self.wait(6)\n        self.play(Write(texto_5))\n        self.wait(6)\n        self.play(FadeOut(texto_3))\n        self.play(Write(texto_6))\n        self.wait(6)\n        self.play(FadeOut(texto_6))\n        self.play(Write(texto_7))\n        self.wait(3)\n        self.play(ReplacementTransform(texto_5, texto_8))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.play(Write(texto_9))\n        self.wait(9)\n        self.play(FadeOut(texto_9))\n\n    def construct(self):\n        self.PrimeraEscena()\n        self.SegundaEscena()\n        self.TercerEscena()\n        self.CuartaEscena()\n        self.QuintaEscena()"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of a bounded sequence with a visual example of points spiraling inwards within a circle and introduce its formal definition."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Sucesiones_Acotadas(Scene):\n\n    def construct(self):\n        plano = NumberPlane()\n        title = TextMobject('Sucesiones acotadas')\n        text1 = TextMobject('Considera la siguiente sucesi\u00f3n').shift(UP)\n        self.play(Write(title))\n        self.wait(6)\n        self.play(ReplacementTransform(title, text1))\n        ejem1 = TexMobject('X_n=\\\\left(3e^{-n/30}\\\\cos\\\\left(\\\\frac{n}{5}\\\\right),3e^{-n/30}\\\\sin\\\\left(\\\\frac{n}{5}\\\\right)\\\\right)').next_to(text1, DOWN)\n        self.play(Write(ejem1))\n        self.wait()\n        self.play(FadeOut(text1), FadeOut(ejem1))\n        suce1 = []\n        for n in range(1, 151):\n            x_n = Dot(point=np.array([3 * np.exp(-n / 30) * np.cos(n / 5), 3 * np.exp(-n / 30) * np.sin(n / 5), 0]), color=ORANGE)\n            suce1.append(x_n)\n        sucesion1 = VGroup(*suce1)\n        self.play(ShowCreation(plano), run_time=0.5)\n        self.play(Write(sucesion1), run_time=10)\n        self.wait()\n        self.play(FadeOut(plano), FadeOut(sucesion1), run_time=0.5)\n        text2 = TextMobject('Piensa en lo que representar\u00eda geom\u00e9tricamente \\n\\n                                que una sucesi\u00f3n fuera acotada')\n        text3 = TextMobject('Considera una bola de radio $M=3$ centrada en el origen')\n        bola = Circle(radius=3, color=RED)\n        self.play(Write(text2))\n        self.wait(5)\n        self.play(ReplacementTransform(text2, text3))\n        self.wait(5)\n        self.play(FadeOut(text3))\n        self.play(ShowCreation(plano), run_time=0.5)\n        self.play(FadeIn(bola), Write(sucesion1))\n        self.wait()\n        text4 = TextMobject('Puedes ver que se cumple \\n\\n                            $\\\\{X_n\\\\}\\\\subset B_{M}(\\\\bar{0})$', color=BLACK).scale(0.6)\n        text4.bg = SurroundingRectangle(text4, color=RED, fill_color=WHITE, fill_opacity=1)\n        text4.group = VGroup(text4.bg, text4).move_to(np.array([-4.5, 3, 0]))\n        self.play(FadeIn(text4.group))\n        self.wait(7)\n        self.play(FadeOut(plano), FadeOut(sucesion1), FadeOut(bola), FadeOut(text4.group))\n        text5 = TextMobject('Y justo con esto es como se define sucesi\u00f3n acotada')\n        text6 = TextMobject('Decimos que $\\\\{X_n\\\\}$ es acotada si existe $M\\\\in\\\\mathbb{R}^+$ \\n\\n                            tal que $\\\\{X_n\\\\}\\\\subset B_{M}(\\\\bar{0})$')\n        text7 = TextMobject('Intenta demostrar que la sucesi\u00f3n $X_n=(n,n)$ NO es acotada\\n\\n                                usando la definici\u00f3n anterior (su negaci\u00f3n)')\n        self.play(Write(text5))\n        self.wait(4)\n        self.play(ReplacementTransform(text5, text6))\n        self.wait(9)\n        self.play(ReplacementTransform(text6, text7))\n        self.wait(5)\n        self.play(FadeOut(text7))"}]}
{"messages": [{"role": "user", "content": "Visualize the graph of the function f(x) = x^2, illustrating domain and codomain mapping with explanatory text and lines."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Visualizaci\u00f3n_Gr\u00e1ficas_1(GraphScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        GraphScene.setup(self)\n    CONFIG = {'y_max': 20, 'y_min': 0, 'x_max': 5, 'x_min': 0, 'y_tick_frequency': 1, 'x_tick_frequency': 1, 'axes_color': BLUE, 'graph_origin': np.array((-2.5, -3, 0))}\n\n    def construct(self):\n        titulo = TextMobject('Visualizaci\u00f3n de Gr\u00e1ficas').scale(1.5)\n        text1_1 = TextMobject('Recordemos que dada una funci\u00f3n')\n        text1_2 = TexMobject('f:A \\\\subset \\\\mathbb{R}^{n} \\\\rightarrow \\\\mathbb{R}^{m}', color=YELLOW).next_to(text1_1, DOWN)\n        text1_3 = TextMobject('la gr\u00e1fica de $f$ es subconjunto de ', '$\\\\mathbb{R}^{n+m}$').next_to(text1_2, DOWN)\n        text1_3[1].set_color(YELLOW)\n        text1 = VGroup(text1_1, text1_2, text1_3).move_to(0.5 * UP)\n        funcion_1 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}').move_to(1 * DOWN)\n        funcion_2 = TexMobject('f:A \\\\subset \\\\mathbb{R}^{2} \\\\rightarrow \\\\mathbb{R}').next_to(funcion_1, DOWN)\n        funcion_3 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}^{2}').next_to(funcion_2, DOWN)\n        funciones = VGroup(funcion_1, funcion_2, funcion_3)\n        text3 = TextMobject('Ahora, veamos algunos ejemplos')\n        text4_1 = TextMobject('Consideremos una recta $x=$ ', '$x_0$', ',').move_to(3.3 * UP + 2.5 * RIGHT)\n        text4_2 = TextMobject('\u00bfqu\u00e9 pasa si ', '$x_0$', ' pertenece al dominio de $f$?').next_to(text4_1, DOWN)\n        text4_1[1].set_color(GREEN_E)\n        text4_2[1].set_color(GREEN_E)\n        text4 = VGroup(text4_1, text4_2).scale(0.8)\n        text5 = TextMobject('Cada recta intersecta a la gr\u00e1fica\\n\\n                                en un s\u00f3lo punto ').move_to(3.3 * UP + 2.5 * RIGHT).scale(0.8)\n        text6 = TextMobject('\u00bfQu\u00e9 pasar\u00e1 si $x_0$ no pertenece\\n\\n                             al dominio de $f$?').move_to(3.3 * UP + 2.5 * RIGHT).scale(0.8)\n        funciones.bg = SurroundingRectangle(funciones, buff=0.8 * SMALL_BUFF, color=WHITE)\n        Caja = VGroup(funciones.bg, funciones)\n        funciones_copy_0 = funciones.copy().to_corner(UL)\n        funciones_copy_0.bg = SurroundingRectangle(funciones_copy_0, buff=0.8 * SMALL_BUFF, color=WHITE)\n        Caja_0 = VGroup(funciones_copy_0.bg, funciones_copy_0)\n        funcion_1_1 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}', color=YELLOW)\n        funcion_2_1 = TexMobject('f:A \\\\subset \\\\mathbb{R}^{2} \\\\rightarrow \\\\mathbb{R}').next_to(funcion_1_1, DOWN)\n        funcion_3_1 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}^{2}').next_to(funcion_2_1, DOWN)\n        funciones_1 = VGroup(funcion_1_1, funcion_2_1, funcion_3_1).to_corner(UL)\n        funciones_1.bg = SurroundingRectangle(funciones_1, buff=0.8 * SMALL_BUFF, color=WHITE)\n        Caja_1 = VGroup(funciones_1.bg, funciones_1)\n        ejemplo_1_1 = TexMobject('f(x)=x^{2}', color=YELLOW)\n        ejemplo_1_2 = TexMobject('G_{f}:=\\\\{(x,f(x))\\\\in \\\\mathbb{R}^{2}|x\\\\in[0,4]\\\\}', color=YELLOW).next_to(ejemplo_1_1, DOWN)\n        ejemplo_1 = VGroup(ejemplo_1_1, ejemplo_1_2).move_to(2.8 * UP + 2 * RIGHT)\n        dot_1_1 = Dot().set_color(WHITE).move_to(np.array((1.1, -1.8, 0)))\n        dot_1_x1 = Dot().set_color(WHITE).move_to(np.array((1.1, -3, 0)))\n        dot_1_y1 = Dot().set_color(WHITE).move_to(np.array((-2.5, -1.8, 0)))\n        linea_1_x1 = DashedLine(dot_1_x1.get_top(), dot_1_1.get_bottom(), buff=0.1)\n        linea_1_x1.set_color(WHITE)\n        linea_1_y1 = DashedLine(dot_1_y1.get_right(), dot_1_1.get_left(), buff=0.1)\n        linea_1_y1.set_color(WHITE)\n        text_dot_1_x1 = TexMobject('x=2').move_to(dot_1_x1.get_bottom() + 0.5 * DOWN).scale(0.75)\n        text_dot_1_y1 = TexMobject('f(2)=4').move_to(dot_1_y1.get_left() + 1.2 * LEFT).scale(0.75)\n        text_dot_1_1 = TexMobject('(2,f(2))').move_to(dot_1_1.get_top() + 0.4 * UP + 0.5 * LEFT).scale(0.75)\n        dot_1_2 = Dot().set_color(WHITE).move_to(np.array((2.9, -0.3, 0)))\n        dot_1_x2 = Dot().set_color(WHITE).move_to(np.array((2.9, -3, 0)))\n        dot_1_y2 = Dot().set_color(WHITE).move_to(np.array((-2.5, -0.3, 0)))\n        linea_1_x2 = DashedLine(dot_1_x2.get_top(), dot_1_2.get_bottom(), buff=0.1)\n        linea_1_x2.set_color(WHITE)\n        linea_1_y2 = DashedLine(dot_1_y2.get_right(), dot_1_2.get_left(), buff=0.1)\n        linea_1_y2.set_color(WHITE)\n        text_dot_1_x2 = TexMobject('x=3').move_to(dot_1_x2.get_bottom() + 0.5 * DOWN).scale(0.75)\n        text_dot_1_y2 = TexMobject('f(3)=9').move_to(dot_1_y2.get_left() + 1.2 * LEFT).scale(0.75)\n        text_dot_1_2 = TexMobject('(3,f(3))').move_to(dot_1_2.get_top() + 0.4 * UP + 0.5 * LEFT).scale(0.75)\n        text_dots_1_1 = VGroup(text_dot_1_1, text_dot_1_2)\n        text_dots_1_2 = TextMobject('$(2,f(2))\\\\in G_{f}$ \\n \\n                                    $(3,f(3))\\\\in G_{f}$').to_edge(LEFT).scale(0.75)\n        text_grafica_1 = TexMobject('G_{f}', color=YELLOW).move_to(ejemplo_1.get_bottom() + 0.75 * DOWN + 3 * RIGHT)\n        dot_dom_1 = Dot().set_color(GREEN_E).move_to((1.5, -3.0, 0))\n        dot_dom_2 = Dot().set_color(GREEN_E).move_to((4, -3.0, 0))\n        dot_func_1 = Dot().move_to((1.5, -1.5, 0))\n        dot_func_2 = Dot().move_to((4, 0.9, 0))\n        linea_vert_1 = Line((1.5, -3.5, 0), (1.5, 1.5, 0)).set_color(GREEN_E)\n        linea_vert_2 = Line((4, -3.5, 0), (4, 1.5, 0)).set_color(GREEN_E)\n        RectVert = VGroup(dot_dom_1, dot_dom_2, dot_func_1, dot_func_2, linea_vert_1, linea_vert_2)\n        self.play(Write(titulo))\n        self.wait(3)\n        self.play(FadeOut(titulo))\n        self.play(Write(text1))\n        self.wait(9)\n        self.play(FadeOut(text1))\n        self.play(Write(text3))\n        self.wait(3)\n        self.play(Write(funciones))\n        self.wait(0.5)\n        self.play(ShowCreation(funciones.bg))\n        self.wait(0.5)\n        self.play(FadeOut(text3))\n        self.play(ReplacementTransform(Caja, Caja_0))\n        self.play(ReplacementTransform(Caja_0, Caja_1))\n        self.setup_axes(animate=True)\n        graph = self.get_graph(lambda x: x ** 2, color=YELLOW, x_min=0, x_max=4)\n        self.play(FadeIn(ejemplo_1))\n        self.play(FadeIn(dot_1_1), FadeIn(dot_1_x1), FadeIn(text_dot_1_x1), FadeIn(dot_1_y1), FadeIn(text_dot_1_y1))\n        self.wait(2)\n        self.play(ShowCreation(linea_1_x1), ShowCreation(linea_1_y1))\n        self.play(FadeIn(text_dot_1_1))\n        self.wait(2)\n        self.play(FadeIn(dot_1_2), FadeIn(dot_1_x2), FadeIn(text_dot_1_x2), FadeIn(dot_1_y2), FadeIn(text_dot_1_y2))\n        self.wait(2)\n        self.play(ShowCreation(linea_1_x2), ShowCreation(linea_1_y2))\n        self.play(FadeIn(text_dot_1_2))\n        self.wait(2)\n        self.play(FadeOut(text_dot_1_x1), FadeOut(text_dot_1_x2), FadeOut(text_dot_1_y1), FadeOut(text_dot_1_y2))\n        self.play(ReplacementTransform(text_dots_1_1, text_dots_1_2))\n        self.wait(3)\n        self.play(FadeOut(linea_1_x1), FadeOut(linea_1_x2), FadeOut(linea_1_y1), FadeOut(linea_1_y2), FadeOut(dot_1_x1), FadeOut(dot_1_x2), FadeOut(dot_1_y1), FadeOut(dot_1_y2))\n        self.play(ShowCreation(graph), run_time=3)\n        self.play(FadeIn(text_grafica_1))\n        self.wait()\n        self.play(FadeOut(ejemplo_1), FadeOut(dot_1_1), FadeOut(dot_1_2), FadeOut(text_dots_1_2))\n        self.play(Write(text4))\n        self.wait(6.5)\n        self.play(FadeIn(dot_dom_1))\n        self.play(ShowCreation(linea_vert_1))\n        self.play(FadeOut(text4))\n        self.play(FadeIn(text5))\n        self.wait(5)\n        self.play(FadeIn(dot_func_1))\n        self.play(FadeIn(dot_dom_2))\n        self.play(ShowCreation(linea_vert_2))\n        self.play(FadeIn(dot_func_2))\n        self.wait(2.5)\n        self.play(FadeOut(RectVert))\n        self.play(FadeOut(text5))\n        self.play(FadeIn(text6))\n        self.wait(7)\n        self.play(FadeOut(text_grafica_1), FadeOut(self.axes), FadeOut(graph), FadeOut(text6))"}]}
{"messages": [{"role": "user", "content": "Visualize the graph of the function f(x,y) = sin(x)cos(y) in 3D, demonstrating how a vertical line intersects the graph at a single point."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Visualizaci\u00f3n_Gr\u00e1ficas_2(ThreeDScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        ThreeDScene.setup(self)\n\n    def acomodar_textos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.play(Write(objeto))\n\n    def FadeOutWrite3D(self, objeto1, objeto2):\n        self.play(FadeOut(objeto1))\n        self.acomodar_textos(objeto2)\n\n    def punto3D(self):\n        bola = ParametricSurface(lambda u, v: np.array([0.075 * np.cos(v) * np.sin(u), 0.075 * np.sin(v) * np.sin(u), 0.075 * np.cos(u)]), v_min=0, v_max=TAU, u_min=0.001, u_max=PI - 0.001, resolution=(12, 24), fill_opacity=1, stroke_color=GREEN_E, fill_color=GREEN_E)\n        return bola\n\n    def punto3D_2(self):\n        bola = ParametricSurface(lambda u, v: np.array([0.075 * np.cos(v) * np.sin(u), 0.075 * np.sin(v) * np.sin(u), 0.075 * np.cos(u)]), v_min=0, v_max=TAU, u_min=0.001, u_max=PI - 0.001, resolution=(12, 24), fill_opacity=1, stroke_color=GOLD_E, fill_color=GOLD_E)\n        return bola\n\n    def construct(self):\n        funcion_1_1 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}', color=YELLOW)\n        funcion_2_1 = TexMobject('f:A \\\\subset \\\\mathbb{R}^{2} \\\\rightarrow \\\\mathbb{R}').next_to(funcion_1_1, DOWN)\n        funcion_3_1 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}^{2}').next_to(funcion_2_1, DOWN)\n        funciones_1 = VGroup(funcion_1_1, funcion_2_1, funcion_3_1).to_corner(UL)\n        funciones_1.bg = SurroundingRectangle(funciones_1, buff=0.8 * SMALL_BUFF, color=WHITE)\n        Caja_1 = VGroup(funciones_1.bg, funciones_1)\n        funcion_1_2 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}')\n        funcion_2_2 = TexMobject('f:A \\\\subset \\\\mathbb{R}^{2} \\\\rightarrow \\\\mathbb{R}', color=YELLOW).next_to(funcion_1_2, DOWN)\n        funcion_3_2 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}^{2}').next_to(funcion_2_2, DOWN)\n        funciones_2 = VGroup(funcion_1_2, funcion_2_2, funcion_3_2).to_corner(UL)\n        funciones_2.bg = SurroundingRectangle(funciones_2, buff=0.8 * SMALL_BUFF, color=WHITE)\n        Caja_2 = VGroup(funciones_2.bg, funciones_2)\n        ejemplo_2_1 = TexMobject('f(x,y)=\\\\sin(x)\\\\cos(y)', color=YELLOW)\n        ejemplo_2_2 = TexMobject('G_{f}:=\\\\{(x,y,f(x,y))\\\\in \\\\mathbb{R}^{3}|(x,y)\\\\in A\\\\}', color=YELLOW).next_to(ejemplo_2_1, DOWN)\n        ejemplo_2 = VGroup(ejemplo_2_1, ejemplo_2_2).move_to(3.3 * UP + 3.6 * RIGHT).scale(0.8)\n        text_1 = TextMobject('Consideremos una recta $(x,y,z)=($', '$x_0$', ',', '$y_0$', '$,0)+\\\\alpha\\\\hat{z}$, con $\\\\alpha\\\\in\\\\mathbb{R}$').move_to(3.5 * UP + 2 * RIGHT)\n        text_1[1].set_color(GREEN_E)\n        text_1[3].set_color(GREEN_E)\n        text_1_1 = TextMobject('\u00bfqu\u00e9 pasa si ', '$(x_0,y_0)$', ' pertence al dominio de $f$?').next_to(text_1, DOWN)\n        text_1_1[1].set_color(GREEN_E)\n        text_1 = VGroup(text_1, text_1_1).scale(0.7)\n        text_2 = TextMobject('La recta intersecta  la gr\u00e1fica en un s\u00f3lo punto').move_to(3.3 * UP + 2 * RIGHT).scale(0.6)\n        text_3 = TextMobject('\u00bfQu\u00e9 pasar\u00e1 si ', '$(x_0,y_0)$', ' no pertence al dominio de $f$?').move_to(3.3 * UP + 2 * RIGHT).scale(0.6)\n        text_3[1].set_color(GREEN_E)\n        Superficie = ParametricSurface(lambda u, v: np.array([u, v, np.sin(u) * np.cos(v)]), v_min=-2.5, v_max=4, u_min=-3, u_max=5, checkerboard_colors=[GOLD_E, GOLD_E], resolution=(20, 50))\n        Superficie2 = ParametricSurface(lambda u, v: np.array([u, v, np.sin(u) * np.cos(v)]), v_min=-2.5, v_max=4, u_min=-3, u_max=5, checkerboard_colors=[GOLD_E, GOLD_E], resolution=(20, 50), fill_opacity=0.5)\n        axes = ThreeDAxes(x_min=-3, x_max=6, y_min=-3, y_max=6, z_min=-3, z_max=3, num_axis_pieces=40)\n        dot_2_1 = Dot().set_color(RED).move_to(np.array((3 * PI / 2, 2.5, 0.8)))\n        dot_2_x1 = Dot().set_color(WHITE).move_to(np.array((3 * PI / 2, 0, 0)))\n        dot_2_y1 = Dot().set_color(WHITE).move_to(np.array((0, 2.5, 0)))\n        dot_2_z1 = Dot().set_color(WHITE).move_to(np.array((0, 0, 0.8)))\n        dot_2_xy1 = Dot().set_color(WHITE).move_to(np.array((3 * PI / 2, 2.5, 0)))\n        linea_2_x1 = DashedLine(dot_2_x1.get_center(), dot_2_xy1.get_center(), buff=0.1, rate=0.25)\n        linea_2_x1.set_color(WHITE)\n        linea_2_y1 = DashedLine(dot_2_y1.get_center(), dot_2_xy1.get_center(), buff=0.1)\n        linea_2_y1.set_color(WHITE)\n        linea_2_z1 = DashedLine(dot_2_z1.get_center(), dot_2_1.get_center(), buff=0.1)\n        linea_2_z1.set_color(WHITE)\n        linea_2_xy1 = DashedLine(dot_2_xy1.get_center(), dot_2_1.get_center(), buff=0.1)\n        linea_2_xy1.set_color(WHITE)\n        text_dot_2_x1 = TexMobject('x=\\\\frac{3\\\\pi}{2}').move_to(dot_2_x1.get_top() + 0.5 * UP).scale(0.75)\n        text_dot_2_y1 = TexMobject('y=2.5').move_to(dot_2_y1.get_left() + 1 * RIGHT).scale(0.75)\n        text_dot_2_z1 = TexMobject('f(x,y)=0.8').move_to(dot_2_z1.get_left() + 1.5 * LEFT).scale(0.75)\n        text_dot_2_1 = TexMobject('(x,y,f(x,y))', color=RED).move_to(dot_2_1.get_right() + 0.8 * UP).scale(0.75)\n        text_dot_2_xy1 = TexMobject('(x,y)\\\\in A').move_to(dot_2_xy1.get_top() + 0.5 * RIGHT + 0.5 * UP).scale(0.75)\n        gpo_coordxy_2_1 = VGroup(text_dot_2_x1, text_dot_2_y1)\n        gpo_coordxyz_2_1 = VGroup(text_dot_2_xy1, text_dot_2_z1)\n        text_grafica_2 = TexMobject('G_{f}', color=GOLD_E).move_to(4.75 * RIGHT + 1 * DOWN)\n        dot_dom_1 = self.punto3D().move_to((PI / 2, 0, 0))\n        dot_func_1 = self.punto3D_2().move_to((PI / 2, 0, 1))\n        dot_dom_2 = self.punto3D().move_to((0, 5, 0))\n        linea_vert_1 = Line((PI / 2, 0, -3), (PI / 2, 0, 3)).set_color(GREEN_E)\n        linea_vert_2 = Line((0, 5, -3), (0, 5, 3)).set_color(GREEN_E)\n        RectVert = VGroup(dot_dom_1, dot_dom_2, dot_func_1, linea_vert_1)\n        self.add(Caja_1)\n        self.wait(0.5)\n        self.play(ReplacementTransform(Caja_1, Caja_2))\n        self.add_fixed_in_frame_mobjects(Caja_2)\n        self.play(FadeIn(ejemplo_2))\n        self.add_fixed_in_frame_mobjects(ejemplo_2)\n        self.set_camera_orientation(phi=55 * DEGREES, theta=-50 * DEGREES, distance=50)\n        self.play(ShowCreation(axes))\n        self.wait()\n        self.play(FadeIn(dot_2_x1), FadeIn(text_dot_2_x1))\n        self.wait(1.5)\n        self.play(FadeIn(dot_2_y1), FadeIn(text_dot_2_y1))\n        self.wait(1.5)\n        self.play(FadeIn(dot_2_z1), FadeIn(text_dot_2_z1))\n        self.wait(1.5)\n        self.begin_ambient_camera_rotation(rate=0.04)\n        self.play(FadeIn(dot_2_xy1), ReplacementTransform(gpo_coordxy_2_1, text_dot_2_xy1))\n        self.play(FadeIn(linea_2_x1))\n        self.play(FadeIn(linea_2_y1))\n        self.play(FadeIn(dot_2_1))\n        self.play(FadeIn(linea_2_xy1), FadeIn(linea_2_z1))\n        self.wait(2)\n        self.play(ReplacementTransform(gpo_coordxyz_2_1, text_dot_2_1))\n        self.wait(3.5)\n        self.play(FadeOut(dot_2_xy1), FadeOut(dot_2_x1), FadeOut(dot_2_y1), FadeOut(dot_2_z1), FadeOut(linea_2_x1), FadeOut(linea_2_xy1), FadeOut(linea_2_y1), FadeOut(linea_2_z1), FadeOut(text_dot_2_1))\n        self.play(ShowCreation(Superficie))\n        self.add_fixed_in_frame_mobjects(text_grafica_2)\n        self.wait(23)\n        self.stop_ambient_camera_rotation()\n        self.play(FadeOut(dot_2_1), FadeOut(text_grafica_2), FadeOut(ejemplo_2))\n        self.wait()\n        self.acomodar_textos(text_1)\n        self.wait(12)\n        self.move_camera(phi=75 * DEGREES, theta=-50 * DEGREES, distance=50, frame_center=[0, 0, 1])\n        self.play(ReplacementTransform(Superficie, Superficie2))\n        self.begin_ambient_camera_rotation(rate=0.04)\n        self.play(FadeIn(dot_dom_1))\n        self.play(ShowCreation(linea_vert_1))\n        self.FadeOutWrite3D(text_1, text_2)\n        self.play(FadeIn(dot_func_1))\n        self.wait(4.5)\n        self.play(FadeOut(dot_dom_1), FadeOut(dot_func_1), FadeOut(linea_vert_1))\n        self.FadeOutWrite3D(text_2, text_3)\n        self.wait(5)\n        self.play(FadeIn(dot_dom_2))\n        self.wait(1.5)\n        self.play(ShowCreation(linea_vert_2))\n        self.stop_ambient_camera_rotation\n        self.wait(5)\n        self.play(FadeOut(axes), FadeOut(Superficie2), FadeOut(text_3), FadeOut(dot_dom_2), FadeOut(linea_vert_2))"}]}
{"messages": [{"role": "user", "content": "Visualize a 3D parametric curve and demonstrate the intersection of the curve with a series of parallel planes."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Visualizaci\u00f3n_Gr\u00e1ficas_3(ThreeDScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        ThreeDScene.setup(self)\n\n    def FadeOutWrite3D(self, objeto1, objeto2):\n        self.play(FadeOut(objeto1))\n        self.acomodar_textos(objeto2)\n\n    def acomodar_textos(self, objeto):\n        self.add_fixed_in_frame_mobjects(objeto)\n        self.play(Write(objeto))\n\n    def construct(self):\n        funcion_1_2 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}')\n        funcion_2_2 = TexMobject('f:A \\\\subset \\\\mathbb{R}^{2} \\\\rightarrow \\\\mathbb{R}', color=YELLOW).next_to(funcion_1_2, DOWN)\n        funcion_3_2 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}^{2}').next_to(funcion_2_2, DOWN)\n        funciones_2 = VGroup(funcion_1_2, funcion_2_2, funcion_3_2).to_corner(UL)\n        funciones_2.bg = SurroundingRectangle(funciones_2, buff=0.8 * SMALL_BUFF, color=WHITE)\n        Caja_2 = VGroup(funciones_2.bg, funciones_2)\n        funcion_1_3 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}')\n        funcion_2_3 = TexMobject('f:A \\\\subset \\\\mathbb{R}^{2} \\\\rightarrow \\\\mathbb{R}').next_to(funcion_1_3, DOWN)\n        funcion_3_3 = TexMobject('f:A \\\\subset \\\\mathbb{R} \\\\rightarrow \\\\mathbb{R}^{2}', color=YELLOW).next_to(funcion_2_3, DOWN)\n        funciones_3 = VGroup(funcion_1_3, funcion_2_3, funcion_3_3).to_corner(UL)\n        funciones_3.bg = SurroundingRectangle(funciones_3, buff=0.8 * SMALL_BUFF, color=WHITE)\n        Caja_3 = VGroup(funciones_3.bg, funciones_3)\n        text_3 = TextMobject('No es com\u00fan en clase graficar funciones de $\\\\mathbb{R}\\\\rightarrow\\\\mathbb{R}^2$\\n\\n                                por la dificultad de hacer los dibujos en pizarr\u00f3n')\n        text_4 = TextMobject('Generalmente se trabaja con la imagen de la\\n\\n                                funci\u00f3n, dibujando las curvas correspondientes\\n\\n                                 en el plano del contradominio ')\n        text_5 = TextMobject('En este y otros videos podemos usar\\n\\n                                 la gr\u00e1fica de este tipo de funciones ')\n        text_6 = TextMobject('Consideremos algunos puntos de la gr\u00e1fica').move_to(3.3 * UP + 2 * RIGHT).scale(0.8)\n        text_7 = TextMobject('An\u00e1logo a los casos anteriores, podemos tomar \\n\\n                                planos paralelos al plano $xy$').move_to(3.3 * UP + 2 * RIGHT).scale(0.8)\n        text_8 = TextMobject('La intersecci\u00f3n de la gr\u00e1fica con estos\\n\\n                                 planos s\u00f3lo puede ser un punto').move_to(3.3 * UP + 2 * RIGHT).scale(0.8)\n        text_9 = TextMobject('Si fuera m\u00e1s de un punto,\\n\\n                                $f$ no ser\u00eda funci\u00f3n').move_to(3.3 * UP + RIGHT).scale(0.8)\n        text_10 = TextMobject('Si la intersecci\u00f3n fuera el vac\u00edo,\\n\\n                                 el punto correspondiente en el eje t\\n\\n                                 no ser\u00eda parte del dominio ').move_to(3.3 * UP).scale(0.7)\n        ejemplo_3_1 = TexMobject('f(t)=\\\\frac{t}{4\\\\pi}(\\\\cos(t),\\\\sin(t))', color=YELLOW)\n        ejemplo_3_2 = TexMobject('G_{f}:=\\\\{(t,f(t))\\\\in \\\\mathbb{R}^{3}|t\\\\in A\\\\}', color=YELLOW).next_to(ejemplo_3_1, DOWN)\n        ejemplo_3 = VGroup(ejemplo_3_1, ejemplo_3_2).move_to(3.2 * UP).scale(0.65)\n        ejemplo_3_10 = ejemplo_3.copy().move_to(3.2 * UP + 4 * RIGHT)\n        axes_2 = ThreeDAxes(x_min=-3.5, x_max=3.2, y_min=-3.5, y_max=3.5, z_min=0, z_max=5 * PI, num_axis_pieces=30)\n        curva_1 = ParametricFunction(lambda u: np.array([u / (4 * PI) * math.cos(u), u / (4 * PI) * math.sin(u), u]), color=YELLOW, t_min=0, t_max=4 * PI)\n        plano_1 = ParametricSurface(lambda u, v: np.array([u, v, PI / 2]), v_min=-1.5, v_max=1.5, u_min=-1.5, u_max=1.5, fill_color=BLUE_E, fill_opacity=0.25, resolution=(1, 1))\n        punto_1 = Dot(color=RED).move_to((0, 1 * 1 * PI / (8 * PI), PI / 2))\n        plano_2 = ParametricSurface(lambda u, v: np.array([u, v, PI]), v_min=-1.5, v_max=1.5, u_min=-1.5, u_max=1.5, fill_color=TEAL_E, fill_opacity=0.25, resolution=(1, 1))\n        punto_2 = Dot(color=RED).move_to((-1 * 2 * PI / (8 * PI), 0, PI))\n        plano_3 = ParametricSurface(lambda u, v: np.array([u, v, 3 * PI / 2]), v_min=-1.5, v_max=1.5, u_min=-1.5, u_max=1.5, fill_color=GREEN_E, fill_opacity=0.25, resolution=(1, 1))\n        punto_3 = Dot(color=RED).move_to((0, -1 * 3 * PI / (8 * PI), 3 * PI / 2))\n        plano_4 = ParametricSurface(lambda u, v: np.array([u, v, 2 * PI]), v_min=-1.5, v_max=1.5, u_min=-1.5, u_max=1.5, fill_color=YELLOW_E, fill_opacity=0.25, resolution=(1, 1))\n        punto_4 = Dot(color=RED).move_to((1 * 4 * PI / (8 * PI), 0, 4 * PI / 2))\n        plano_5 = ParametricSurface(lambda u, v: np.array([u, v, 5 * PI / 2]), v_min=-1.5, v_max=1.5, u_min=-1.5, u_max=1.5, fill_color=GOLD_E, fill_opacity=0.25, resolution=(1, 1))\n        punto_5 = Dot(color=RED).move_to((0, 1 * 5 * PI / (8 * PI), 5 * PI / 2))\n        plano_6 = ParametricSurface(lambda u, v: np.array([u, v, 3 * PI]), v_min=-1.5, v_max=1.5, u_min=-1.5, u_max=1.5, fill_color=RED_E, fill_opacity=0.25, resolution=(1, 1))\n        punto_6 = Dot(color=RED).move_to((-1 * 6 * PI / (8 * PI), 0, 6 * PI / 2))\n        plano_7 = ParametricSurface(lambda u, v: np.array([u, v, 7 * PI / 2]), v_min=-1.5, v_max=1.5, u_min=-1.5, u_max=1.5, fill_color=MAROON_E, fill_opacity=0.25, resolution=(1, 1))\n        punto_7 = Dot(color=RED).move_to((0, -1 * 7 * PI / (8 * PI), 7 * PI / 2))\n        plano_8 = ParametricSurface(lambda u, v: np.array([u, v, 8 * PI / 2]), v_min=-1.5, v_max=1.5, u_min=-1.5, u_max=1.5, fill_color=PURPLE_E, fill_opacity=0.25, resolution=(1, 1))\n        punto_8 = Dot(color=RED).move_to((1 * 8 * PI / (8 * PI), 0, 8 * PI / 2))\n        plano_9 = ParametricSurface(lambda u, v: np.array([u, v, 9 * PI / 2]), v_min=-1.5, v_max=1.5, u_min=-1.5, u_max=1.5, fill_color=PURPLE_E, fill_opacity=0.25, resolution=(1, 1))\n        planos = VGroup(plano_1, plano_2, plano_3, plano_4, plano_5, plano_6, plano_7, plano_8)\n        puntos = VGroup(punto_1, punto_2, punto_3, punto_4, punto_5, punto_6, punto_7, punto_8)\n        eje_x_1 = TexMobject('x').scale(0.75).move_to((3.2, 0.25, 0))\n        eje_x_2 = TexMobject('x').scale(0.75).move_to((-2.6, 1, 0))\n        eje_x_3 = TexMobject('x').scale(0.75).move_to((-2.4, 0.75, 0))\n        eje_y_1 = TexMobject('y').scale(0.75).move_to((0.3, 3.5, 0))\n        eje_y_2 = TexMobject('y').scale(0.75).move_to((1, -3.3, 0))\n        eje_y_3 = TexMobject('y').scale(0.75).move_to((1.3, -3.5, 0))\n        eje_z_1 = TexMobject('t').scale(0.75).move_to((4.7, 2, 0))\n        eje_z_2 = TexMobject('t').scale(0.75).move_to((4.7, 1.6, 0))\n        ejes_1 = VGroup(eje_x_1, eje_y_1)\n        ejes_2 = VGroup(eje_x_2, eje_y_2, eje_z_1)\n        ejes_3 = VGroup(eje_x_3, eje_y_3, eje_z_2)\n        text_plano_1 = TexMobject('t_1').move_to((-3.65, -3, 0)).scale(0.75)\n        text_plano_2 = TexMobject('t_2').move_to((-2.1, -2.4, 0)).scale(0.75)\n        text_plano_3 = TexMobject('t_3').move_to((-0.62, -1.9, 0)).scale(0.75)\n        text_planos_1 = VGroup(text_plano_1, text_plano_2, text_plano_3)\n        text_plano_4 = TexMobject('t_4').move_to((0.7, -1.4, 0)).scale(0.75)\n        text_plano_5 = TexMobject('t_5').move_to((2, -1, 0)).scale(0.75)\n        text_plano_6 = TexMobject('t_6').move_to((3.15, -0.5, 0)).scale(0.75)\n        text_plano_7 = TexMobject('t_7').move_to((4.25, -0.05, 0)).scale(0.75)\n        text_plano_8 = TexMobject('t_8').move_to((5.2, 0.4, 0)).scale(0.75)\n        text_planos_2 = VGroup(text_plano_4, text_plano_5, text_plano_6, text_plano_7, text_plano_8, text_plano_1, text_plano_2, text_plano_3)\n        text_planos_i = TexMobject('\\\\forall i, t_i \\\\in A').move_to((4, -2.5, 0)).scale(1.25)\n        text_grafica_3 = TexMobject('G_{f}', color=YELLOW).move_to(eje_z_2.get_left() + 2.5 * LEFT)\n        self.add(Caja_2)\n        self.wait(0.5)\n        self.play(ReplacementTransform(Caja_2, Caja_3))\n        self.add_fixed_in_frame_mobjects(Caja_3)\n        self.play(Write(text_3))\n        self.wait(9.5)\n        self.play(FadeOut(text_3))\n        self.play(Write(text_4))\n        self.wait(8.5)\n        self.play(FadeOut(text_4))\n        self.play(Write(text_5))\n        self.wait(7.2)\n        self.play(FadeOut(text_5))\n        self.wait(0.5)\n        self.play(FadeIn(ejemplo_3_10))\n        self.set_camera_orientation(phi=0)\n        self.play(ShowCreation(axes_2), FadeIn(ejes_1))\n        self.wait(0.5)\n        self.play(ShowCreation(curva_1))\n        self.wait(19)\n        self.play(FadeOut(ejes_1), FadeOut(ejemplo_3_10))\n        self.move_camera(phi=142 * DEGREES, theta=55 * DEGREES, gamma=-60 * DEGREES, frame_center=(0.5, 0, 5), run_time=3)\n        self.acomodar_textos(ejes_2)\n        self.wait(2.5)\n        self.acomodar_textos(text_6)\n        self.wait(4)\n        self.play(FadeOut(curva_1), FadeIn(puntos))\n        self.wait(0.5)\n        self.play(FadeOut(ejes_2))\n        self.move_camera(phi=115 * DEGREES, theta=32 * DEGREES, gamma=-70 * DEGREES, frame_center=(0, -0.1, 6), run_time=2)\n        self.wait()\n        self.FadeOutWrite3D(text_6, text_7)\n        self.wait(6.5)\n        self.play(FadeIn(plano_1))\n        self.acomodar_textos(text_plano_1)\n        self.acomodar_textos(text_planos_i)\n        self.play(FadeIn(plano_2))\n        self.acomodar_textos(text_plano_2)\n        self.FadeOutWrite3D(text_7, text_8)\n        self.wait(6.5)\n        self.play(FadeIn(plano_3))\n        self.acomodar_textos(text_plano_3)\n        self.play(FadeIn(plano_4))\n        self.acomodar_textos(text_plano_4)\n        self.FadeOutWrite3D(text_8, text_9)\n        self.wait(5.7)\n        self.play(FadeIn(plano_5))\n        self.acomodar_textos(text_plano_5)\n        self.play(FadeIn(plano_6))\n        self.acomodar_textos(text_plano_6)\n        self.FadeOutWrite3D(text_9, text_10)\n        self.wait(8.75)\n        self.play(FadeIn(plano_7))\n        self.acomodar_textos(text_plano_7)\n        self.play(FadeIn(plano_8))\n        self.acomodar_textos(text_plano_8)\n        self.play(FadeIn(plano_9))\n        self.play(ShowCreation(curva_1), run_time=2)\n        self.wait(2)\n        self.play(FadeOut(plano_9))\n        self.play(FadeOut(text_planos_2), FadeOut(text_planos_i), FadeOut(text_10))\n        self.move_camera(phi=142 * DEGREES, theta=55 * DEGREES, gamma=-60 * DEGREES, frame_center=(0, -0.8, 5), run_time=2)\n        self.acomodar_textos(ejes_3)\n        self.wait(2.5)\n        self.play(FadeOut(planos))\n        self.acomodar_textos(text_grafica_3)\n        self.wait(3)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the geometric definition of a Cauchy sequence by animating points converging within shrinking circles and then display the formal mathematical definition."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass SucesionDeCauchy(MovingCameraScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        MovingCameraScene.setup(self)\n\n    def construct(self):\n        self.camera_frame.save_state()\n        plano = NumberPlane()\n        titu = TextMobject('Sucesiones de Cauchy')\n        bas1 = TextMobject('Revisemos la definici\u00f3n de una sucesi\u00f3n de Cauchy')\n        bas2 = TextMobject('de forma geom\u00e9trica.').set_color(YELLOW).next_to(bas1, DOWN)\n        bas = VGroup(bas1, bas2)\n        675\n        suc = TexMobject('\\\\text{Sea}\\\\ \\\\{x_n\\\\}\\\\ \\\\text{una sucesi\u00f3n}').shift(3 * LEFT + UP)\n        xn = TexMobject('\\\\{x_n\\\\}=\\\\{\\\\frac{1}{n},\\\\frac{1}{n}\\\\}').shift(4 * RIGHT + UP)\n        points = []\n        for n in range(1, 1500):\n            points.append(ACustomDot(point=np.array([10 / n, 10 / n, 0.0]), color=GREY).scale(1.2))\n        group = VGroup(*points)\n        smolpoints = []\n        for n in range(1, 1500):\n            smolpoints.append(ACustomDot(point=np.array([10 / n, 10 / n, 0.0]), color=GREY).scale(0.1))\n        group2 = VGroup(*smolpoints)\n        circ_text = TexMobject('\\\\text{Consideremos un c\u00edrculo de di\u00e1metro}\\\\ \\\\varepsilon').scale(0.1).shift(0.62 * UP)\n        circulo1 = Circle(radius=0.3).move_to(points[50])\n        amarillo_t1 = TextMobject('A partir de cierto punto, llam\u00e9mosle').move_to(circ_text).scale(0.11)\n        amarillo_t2 = TexMobject('\\\\vec{x}_N').scale(0.09).next_to(amarillo_t1).set_color(YELLOW).shift(0.22 * LEFT)\n        amarillo = VGroup(amarillo_t1, amarillo_t2)\n        posteriores_t1 = TextMobject('cualesquiera dos t\u00e9rminos posteriores').move_to(circ_text).scale(0.1).shift(0.1 * LEFT)\n        posteriores_t2 = TexMobject('\\\\vec{x}_k, \\\\vec{x}_l').scale(0.1).next_to(posteriores_t1).set_color(BLUE).shift(0.22 * LEFT)\n        posteriores_t3 = TexMobject('\\\\text{distan entre s\u00ed menos que}\\\\ \\\\varepsilon').scale(0.1).next_to(posteriores_t1, 0.15 * DOWN)\n        posteriores = VGroup(posteriores_t1, posteriores_t2, posteriores_t3)\n        mates_1 = TexMobject('\\\\text{Esto es:}\\\\ \\\\forall\\\\ k,l > N, d(\\\\vec{x}_k,\\\\vec{x}_l)<\\\\varepsilon').move_to(circ_text).scale(0.1).shift(0.1 * LEFT)\n        mates_2 = TexMobject(' ').scale(0.08).next_to(posteriores_t1, 0.15 * DOWN).shift(0.22 * LEFT)\n        mates = VGroup(mates_1, mates_2)\n        sipodemos_1 = TexMobject('\\\\text{Si podemos hacer esto tomando}\\\\ \\\\varepsilon>0').move_to(circ_text).scale(0.1)\n        sipodemos_2 = TextMobject('tan peque\u00f1o como queramos...').scale(0.1).next_to(sipodemos_1, 0.15 * DOWN)\n        sipodemos = VGroup(sipodemos_1, sipodemos_2)\n        smolerpoints = []\n        for n in range(1, 1500):\n            smolerpoints.append(ACustomDot(point=np.array([10 / n, 10 / n, 0.0]), color=GREY).scale(0.001))\n        group3 = VGroup(*smolpoints)\n        circulo2 = Circle(radius=0.147).move_to(points[100])\n        circulos = VGroup(circulo1, circulo2)\n        entonces = TextMobject('\u00a1Entonces tenemos una sucesi\u00f3n de Cauchy!').scale(0.05).shift(0.3 * UP)\n        defform1 = TexMobject('\\\\text{Sea}\\\\ \\\\{\\\\vec{x}_n\\\\}\\\\ \\\\text{una sucesi\u00f3n, decimos que es de Cauchy si:}').shift(3 * UP)\n        defform2 = TexMobject('\\\\text{para todo}\\\\ \\\\varepsilon>0').set_color(RED).shift(2 * UP + 2 * LEFT)\n        defform3 = TexMobject('\\\\text{existe}\\\\ N \\\\in \\\\mathbb{N}').set_color(YELLOW).next_to(defform2, RIGHT)\n        defform4 = TexMobject('\\\\text{tal que si}\\\\ k,l > N, \\\\Rightarrow d(\\\\vec{x}_k,\\\\vec{x}_l)<\\\\varepsilon').set_color(BLUE).shift(UP)\n        self.play(Write(titu))\n        self.wait()\n        self.play(FadeOutAndShift(titu))\n        self.play(Write(bas))\n        self.wait()\n        self.play(FadeOut(bas))\n        self.add(plano)\n        self.play(ShowCreation(plano, runtime=1))\n        self.play(Write(suc))\n        self.play(ShowIncreasingSubsets(group, run_time=2.0), Write(xn))\n        self.wait(2)\n        self.play(FadeOut(suc), FadeOut(xn))\n        self.play(self.camera_frame.set_width, bas2.get_width() * 0.4, self.camera_frame.move_to, points[40], ReplacementTransform(group, group2))\n        self.wait()\n        self.play(Write(circ_text))\n        self.wait()\n        self.play(ShowCreation(circulo1))\n        self.wait(2)\n        self.play(FadeOut(circ_text))\n        self.play(Write(amarillo))\n        self.play(ApplyMethod(points[23].custom_method, YELLOW))\n        self.wait(2)\n        self.play(FadeOut(amarillo))\n        self.play(Write(posteriores))\n        self.play(ApplyMethod(points[24].custom_method, BLUE), ApplyMethod(points[50].custom_method, BLUE))\n        self.wait(2)\n        self.play(ApplyMethod(points[100].custom_method, BLUE), ApplyMethod(points[50].inverse_method))\n        self.wait(2)\n        self.play(ApplyMethod(points[500].custom_method, BLUE), ApplyMethod(points[100].inverse_method))\n        self.wait(2)\n        self.play(ApplyMethod(points[1498].custom_method, BLUE), ApplyMethod(points[500].inverse_method))\n        self.wait(2)\n        self.play(ReplacementTransform(posteriores, mates))\n        self.wait(9)\n        self.play(FadeOut(mates))\n        self.play(Write(sipodemos), ApplyMethod(points[1498].inverse_method), ApplyMethod(points[24].inverse_method), ApplyMethod(points[23].inverse_method))\n        self.wait()\n        self.play(FadeOut(sipodemos))\n        self.play(self.camera_frame.set_width, bas2.get_width() * 0.2, self.camera_frame.move_to, points[80], ReplacementTransform(group, group3))\n        self.wait()\n        self.play(ShowCreation(circulo2))\n        self.wait()\n        self.play(ApplyMethod(points[48].custom_method, YELLOW))\n        self.wait()\n        self.play(ApplyMethod(points[49].custom_method, BLUE), ApplyMethod(points[60].custom_method, BLUE))\n        self.wait(2)\n        self.play(ApplyMethod(points[100].custom_method, BLUE), ApplyMethod(points[60].inverse_method))\n        self.wait()\n        self.play(Write(entonces))\n        self.wait()\n        self.play(FadeOut(circulos), FadeOut(group3), FadeOut(entonces), ApplyMethod(points[100].custom_method, BLACK), ApplyMethod(points[48].custom_method, BLACK), ApplyMethod(points[49].custom_method, BLACK), ApplyMethod(points[60].custom_method, BLACK), FadeOut(plano))\n        self.play(Restore(self.camera_frame))\n        self.wait()\n        self.play(Write(defform1))\n        self.play(Write(defform2))\n        self.wait(5)\n        self.play(Write(defform3))\n        self.wait(3)\n        self.play(Write(defform4))\n        self.wait(7)\n        self.play(FadeOut(defform1), FadeOut(defform2), FadeOut(defform3), FadeOut(defform4))"}]}
{"messages": [{"role": "user", "content": "Present the definition of sequences in R and then generalize it to sequences in R^n with a visual example in R^2."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Definicion_Sucesiones(Scene):\n\n    def construct(self):\n        t_1 = TextMobject(\" \\\\textquestiondown Recuerdas la definici\\\\'{o}n de sucesiones en $\\\\mathbb{R}?$ \")\n        t_2 = TextMobject(\"Una sucesi\\\\'{o}n es una funci\\\\'{o}n de: \\n\\n                            $\\\\mathbb{N}\\\\rightarrow\\\\mathbb{R}$ \")\n        t_3 = TextMobject(\"Nota que es distinto hablar del conjunto \\n\\n                            que contiene a todos los \\n\\n                            elementos de dicha sucesi\\\\'{o}n:\\n\\n                            $\\\\{ x_n \\\\}$, \\n\\n                            donde $x_n = s(n)$ y \\n\\n                            donde $s$ es la funci\\\\'{o}n.\")\n        t_4 = TextMobject(\" \\\\textexclamdown Bueno! Pues es an\\\\'{a}logo para \\n\\n                            sucesiones de $\\\\mathbb{R}^n$. \")\n        t_5 = TextMobject('Recuerda que un vector en $\\\\mathbb{R}^n$, \\n\\n                            se ve de la siguiente forma: \\n\\n                            $(x_1,x_2,\\\\dots,x_n)$, donde $x_i\\\\in \\\\mathbb{R}$, \\n\\n                            para cualquier $i\\\\in \\\\{ 1,\\\\dots, n \\\\}$')\n        t_6 = TextMobject(\"Por lo que para definir una sucesi\\\\'{o}n \\n\\n                            en $\\\\mathbb{R}^n$  \\n\\n                            basta definir una sucesi\\\\'{o}n para \\n\\n                            cada entrada vectorial, es decir: \\n\\n                            $\\\\vec{s}: \\\\mathbb{N}\\\\rightarrow \\\\mathbb{R}^n$ \")\n        t_7 = TextMobject(\"O sea que: \\n\\n                            $\\\\vec{s}(n) = (s_1(n),s_2(n),\\\\dots, s_n(n))$ \\n\\n                            Donde $s_i$ es una sucesi\\\\'{o}n en $\\\\mathbb{R}$.\")\n        t_8 = TextMobject('Por ejemplo en $\\\\mathbb{R}^2$, tomemos: \\n\\n                            $\\\\vec{s}(n) = ((e^{-n})\\\\cos(n),(e^{-n})\\\\sin(n))$')\n        t_9 = TextMobject(\"Pintemos las parejas de la sucesi\\\\'{o}n en el plano:\")\n        grid = NumberPlane()\n        Elementos = [Dot(point=i).set_color(RED_E) for i in cjto_pts_sucesion_1]\n        Elementos_Y = [Dot(point=i).set_color(YELLOW_E) for i in cjto_pts_sucesion_1]\n        Elementos_t = [TexMobject('\\\\vec{s}_{%i}' % i).next_to(Elementos[i], 0.08 * DOWN).set_color(YELLOW_E) for i in range(0, n_sup_1 - 1)]\n        Elementos_g = VGroup(*Elementos)\n        Elementos_g_Y = VGroup(*Elementos_Y)\n        Elementos_t_g = VGroup(*Elementos_t)\n        self.play(Write(t_1))\n        self.wait(2.2)\n        self.play(ReplacementTransform(t_1, t_2))\n        self.wait(4.3)\n        self.play(ReplacementTransform(t_2, t_3))\n        self.wait(11.5)\n        self.play(ReplacementTransform(t_3, t_4))\n        self.wait(6)\n        self.play(ReplacementTransform(t_4, t_5))\n        self.wait(13)\n        self.play(ReplacementTransform(t_5, t_6))\n        self.wait(13)\n        self.play(ReplacementTransform(t_6, t_7))\n        self.wait(10)\n        self.play(ReplacementTransform(t_7, t_8))\n        self.wait(12)\n        self.play(ReplacementTransform(t_8, t_9))\n        self.wait(4)\n        self.play(ReplacementTransform(t_9, grid))\n        self.wait()\n        self.play(Write(Elementos_g), Write(Elementos_t_g), run_time=6.35)\n        self.wait()\n        self.play(FadeOut(Elementos_t_g), ReplacementTransform(Elementos_g, Elementos_g_Y))\n        self.wait(3.5)\n        self.play(FadeOut(grid), FadeOut(Elementos_g_Y))"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of subsequences with a visual representation on a number plane, starting with definitions and then demonstrating with specific examples of a sequence and its subsequence."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Subsucesiones(MovingCameraScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        MovingCameraScene.setup(self)\n\n    def construct(self):\n        plano = NumberPlane()\n        title = TextMobject('Subsucesiones').set_color(YELLOW).scale(1.5)\n        text2 = TexMobject('\\\\text{1) }', '\\\\forall j\\\\in\\\\mathbb{N},', 'x_{k_j}', '\\\\in', '\\\\{X_k\\\\}')\n        text2[2].set_color(GREEN)\n        text2[4].set_color(ORANGE)\n        text1_1 = TexMobject('\\\\text{Considera una sucesi\u00f3n }', '\\\\{X_k\\\\}', '\\\\text{, decimos que}')\n        text1_2 = TexMobject('\\\\{X_{k_j}\\\\}', '\\\\text{ es una subsucesi\u00f3n de }', '\\\\{X_k\\\\}', '\\\\text{ si}').next_to(text1_1, DOWN)\n        text1_1[1].set_color(ORANGE)\n        text1_2[2].set_color(ORANGE)\n        text1_2[0].set_color(GREEN)\n        text1 = VGroup(text1_1, text1_2).next_to(text2, UP)\n        text3 = TextMobject('2) Si $j<l$, entonces $k_j<k_l$').next_to(text2, DOWN)\n        text4 = TexMobject('\\\\text{Considera la sucesi\u00f3n }', '\\\\{X_k\\\\}', '=\\\\left(\\\\dfrac{k}{5},\\\\dfrac{k}{5}\\\\right)')\n        text4[1].set_color(YELLOW)\n        self.play(Write(title))\n        self.wait()\n        self.play(ReplacementTransform(title, text1))\n        self.wait(6)\n        self.play(Write(text2))\n        self.wait(1)\n        self.play(Write(text3))\n        self.wait(3)\n        self.play(FadeOut(text1), FadeOut(text3), ReplacementTransform(text2, text4))\n        self.wait(1.5)\n        self.play(FadeOut(text4))\n        self.wait(6)\n        self.play(ShowCreation(plano))\n        suce = []\n        sub = []\n        for n in range(1, 21):\n            x_n = Dot(point=(n / 5, n / 5, 0), color=YELLOW)\n            x_n_label = TexMobject('x_{' + str(n) + '}', color=WHITE).scale(0.6).next_to(x_n, DOWN)\n            x_n_label.shift(0.1 * UP)\n            x_n_label.bg = SurroundingRectangle(x_n_label, color=WHITE, fill_color=BLACK, fill_opacity=1)\n            x_n_label_group = VGroup(x_n_label.bg, x_n_label)\n            self.add(x_n, x_n_label_group)\n            self.wait(0.2)\n            self.remove(x_n_label_group)\n            suce.append(x_n)\n        sucesion = VGroup(*suce)\n        self.wait()\n        text5 = TexMobject('\\\\text{Si consideramos ahora la subsucesi\u00f3n }', '\\\\{X_{k_j}\\\\}', '=\\\\left(\\\\dfrac{2j}{5},\\\\dfrac{2j}{5})', color=WHITE).shift(3 * DOWN)\n        text5[1].set_color(PINK)\n        text5.bg = SurroundingRectangle(text5, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text5.group = VGroup(text5.bg, text5)\n        self.play(FadeIn(text5.group))\n        for j in range(1, 11):\n            x_n_j = Dot(point=(2 * j / 5, 2 * j / 5, 0), color=PINK)\n            x_n_j_label = TexMobject('x_{k_' + str(j) + '}', color=WHITE).scale(0.6).next_to(x_n_j, DOWN)\n            x_n_j_label.shift(0.1 * UP)\n            x_n_j_label.bg = SurroundingRectangle(x_n_j_label, color=WHITE, fill_color=BLACK, fill_opacity=1)\n            x_n_j_label.group = VGroup(x_n_j_label.bg, x_n_j_label)\n            self.add(x_n_j, x_n_j_label.group)\n            self.wait(0.5)\n            self.remove(x_n_j_label.group)\n            sub.append(x_n_j)\n        subsucesion = VGroup(*sub)\n        self.wait()\n        text6 = TexMobject('\\\\text{Claramente se cumple que para toda } j\\\\in\\\\mathbb{N},', 'x_{k_j}', '\\\\in', '\\\\{X_k\\\\}', color=WHITE).shift(3 * DOWN)\n        text6[1].set_color(PINK)\n        text6[3].set_color(YELLOW)\n        text6.bg = SurroundingRectangle(text6, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text6.group = VGroup(text6.bg, text6)\n        text7_1 = TexMobject('\\\\text{Notemos que los t\u00e9rminos 2 y 4 de la subsucesi\u00f3n }', '\\\\{X_{k_j}\\\\}', color=WHITE)\n        text7_2 = TexMobject('\\\\text{coinciden con los t\u00e9rminos 4 y 8 de la sucesi\u00f3n }', '\\\\{X_k\\\\}', color=WHITE).next_to(text7_1, DOWN)\n        text7_1[1].set_color(PINK)\n        text7_2[1].set_color(YELLOW)\n        text7 = VGroup(text7_1, text7_2)\n        text7.shift(3 * DOWN).scale(0.8)\n        text7.bg = SurroundingRectangle(text7, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text7.group = VGroup(text7.bg, text7)\n        punto_1 = Dot(point=(4 / 5, 4 / 5, 0), color=RED, radius=0.15)\n        punto_1_label = TexMobject('x_4,\\\\ x_{k_2}', color=WHITE).scale(0.6).next_to(punto_1, DOWN)\n        punto_1_label.bg = SurroundingRectangle(punto_1_label, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        punto_1_label.group = VGroup(punto_1_label.bg, punto_1_label)\n        punto_2 = Dot(point=(8 / 5, 8 / 5, 0), color=RED, radius=0.15)\n        punto_2_label = TexMobject('x_8,\\\\ x_{k_4}', color=WHITE).scale(0.6).next_to(punto_2, DOWN)\n        punto_2_label.bg = SurroundingRectangle(punto_2_label, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        punto_2_label.group = VGroup(punto_2_label.bg, punto_2_label)\n        puntos = VGroup(punto_1_label.group, punto_2_label.group)\n        text8 = TextMobject('Veamos que con $j=2$ y $l=4$, tenemos $k_j=4$ y $k_l=8$. \\n\\n                            Con esto, se cumple que: $j<l\\\\Rightarrow k_j<k_l$; as\u00ed, \\n\\n                            \u00bfc\u00f3mo puedes demostrar que en efecto es subsucesi\u00f3n?', color=WHITE).shift(3 * DOWN).scale(0.8)\n        text8.bg = SurroundingRectangle(text8, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text8.group = VGroup(text8.bg, text8)\n        text9_1 = TexMobject('\\\\text{Si en la sucesi\u00f3n }', '\\\\{X_{k_j}\\\\}', '\\\\text{ apareciera primero }', 'x_{k_8}', '\\\\text{ y despu\u00e9s }', 'x_{k_4},', color=WHITE)\n        text9_2 = TexMobject('\\\\text{ya no ser\u00eda una subsucesi\u00f3n de }', '\\\\{X_k\\\\}', '\\\\text{; basta que una pareja no cumpla}', color=WHITE).next_to(text9_1, DOWN)\n        text9_3 = TexMobject('\\\\text{el orden requerido para que no sea subsucesi\u00f3n.}', color=WHITE).next_to(text9_2, DOWN)\n        text9_1[1].set_color(PINK)\n        text9_2[1].set_color(YELLOW)\n        text9 = VGroup(text9_1, text9_2, text9_3).shift(2 * DOWN).scale(0.8)\n        text9.bg = SurroundingRectangle(text9, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        text9.group = VGroup(text9.bg, text9)\n        self.play(ReplacementTransform(text5.group, text6.group))\n        self.wait(6)\n        self.play(ReplacementTransform(text6.group, text7.group))\n        self.wait(8)\n        self.play(Write(punto_1), Write(punto_2), FadeIn(puntos))\n        self.wait()\n        self.play(ReplacementTransform(text7.group, text8.group))\n        self.wait(16)\n        self.play(ReplacementTransform(text8.group, text9.group))\n        self.wait(16)"}]}
{"messages": [{"role": "user", "content": "Visualize and animate various types of sequences on a number plane, including convergent and non-convergent examples, with accompanying text prompts about their limits."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Ejemplos_Sucesiones(Scene):\n\n    def construct(self):\n        plano = NumberPlane()\n        title = TextMobject('Visualizando', ' Sucesiones').scale(1.5)\n        title[1].set_color(YELLOW)\n        converg = TextMobject('Veamos algunos ejemplos de', ' sucesiones convergentes.')\n        converg[1].set_color(ORANGE)\n        ejem1 = TexMobject('X_n=\\\\left(\\\\frac{6}{n},0\\\\right)')\n        ejem1.bg = SurroundingRectangle(ejem1, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        ej1 = VGroup(ejem1.bg, ejem1)\n        suce1 = []\n        for n in range(1, 101):\n            x_n = Dot(point=np.array([6 / n, 0, 0]), radius=0.05, color=RED)\n            suce1.append(x_n)\n        sucesion1 = VGroup(*suce1)\n        preg1 = TextMobject('\u00bfCu\u00e1l es el l\u00edmite de esta sucesi\u00f3n?')\n        preg2 = TextMobject('Demu\u00e9stralo usando la definici\u00f3n.')\n        eje2 = TextMobject('Observemos un segundo ejemplo:')\n        ejem2 = TexMobject('X_n=\\\\left(\\\\cos\\\\left(\\\\frac{1}{n}\\\\right),e^{1/n}\\\\right)')\n        ejem2.bg = SurroundingRectangle(ejem2, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        ej2 = VGroup(ejem2.bg, ejem2)\n        suce2 = []\n        for n in range(1, 101):\n            x_n = Dot(point=np.array([np.cos(1 / n), np.exp(1 / n), 0]), radius=0.04, color=PINK)\n            suce2.append(x_n)\n        sucesion2 = VGroup(*suce2)\n        preg1 = TextMobject('\u00bfCu\u00e1l es el l\u00edmite de esta sucesi\u00f3n?')\n        preg2 = TextMobject('Demu\u00e9stralo usando la definici\u00f3n.')\n        diverg = TextMobject('Ahora, visualicemos una', ' sucesi\u00f3n no convergente:')\n        diverg[1].set_color(YELLOW)\n        ejem3 = TexMobject('X_n=\\\\left(\\\\frac{n}{10},\\\\frac{1}{n}\\\\right)')\n        ejem3.bg = SurroundingRectangle(ejem3, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        ej3 = VGroup(ejem3.bg, ejem3)\n        suce3 = []\n        for n in range(1, 101):\n            x_n = Dot(point=np.array([n / 10, 1 / n, 0]), radius=0.05, color=YELLOW)\n            suce3.append(x_n)\n        sucesion3 = VGroup(*suce3)\n        eje4 = TextMobject('Veamos un \u00faltimo ejemplo:')\n        ejem4 = TexMobject('X_n=\\\\left(e^{n/50}\\\\cos\\\\left(\\\\frac{n}{5}\\\\right),e^{n/50}\\\\sin\\\\left(\\\\frac{n}{5}\\\\right)\\\\right)')\n        ejem4.bg = SurroundingRectangle(ejem4, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        ej4 = VGroup(ejem4.bg, ejem4)\n        suce4 = []\n        for n in range(1, 101):\n            x_n = Dot(point=np.array([np.exp(n / 50) * np.cos(n / 5), np.exp(n / 50) * np.sin(n / 5), 0]), radius=0.05, color=GREEN_SCREEN)\n            suce4.append(x_n)\n        sucesion4 = VGroup(*suce4)\n        preg_1 = TextMobject('\u00bfC\u00f3mo demostrar\u00edas que el l\u00edmite de esta sucesi\u00f3n no existe? \\n\\n                                Usa la definici\u00f3n.')\n        preg_2 = TextMobject('Usando lo que sabes de sucesiones en $\\\\mathbb{R}$, \\n\\n                                        \u00bfde qu\u00e9 otro modo probar\u00edas la convergencia, \\n\\n                                        o no convergencia, de una sucesi\u00f3n?  ')\n        self.play(Write(title))\n        self.wait()\n        self.play(ReplacementTransform(title, converg))\n        self.wait(2)\n        self.play(FadeOut(converg))\n        self.play(ShowCreation(plano), run_time=0.5)\n        self.play(GrowFromCenter(ej1))\n        self.wait(1)\n        self.play(ApplyMethod(ej1.to_edge, UP))\n        self.play(Write(sucesion1), run_time=3)\n        self.wait()\n        self.play(FadeOut(ej1), FadeOut(plano), FadeOut(sucesion1))\n        self.play(Write(eje2))\n        self.wait()\n        self.play(FadeOut(eje2))\n        self.play(ShowCreation(plano), run_time=0.5)\n        self.play(GrowFromCenter(ej2))\n        self.wait(1)\n        self.play(ApplyMethod(ej2.to_edge, DOWN))\n        self.play(Write(sucesion2), run_time=3)\n        self.wait(0.5)\n        self.play(FadeOut(plano), FadeOut(sucesion2))\n        self.play(ApplyMethod(ej2.to_edge, UP))\n        self.play(Write(preg1))\n        self.wait(1.5)\n        self.play(FadeOut(ej2))\n        self.play(ReplacementTransform(preg1, preg2))\n        self.wait(10)\n        self.play(FadeOut(preg2))\n        self.wait()\n        self.play(Write(diverg))\n        self.wait()\n        self.play(FadeOut(diverg))\n        self.play(ShowCreation(plano), run_time=0.5)\n        self.play(GrowFromCenter(ej3))\n        self.wait(1)\n        self.play(ApplyMethod(ej3.to_edge, UP))\n        self.play(Write(sucesion3), run_time=3)\n        self.wait()\n        self.play(FadeOut(ej3), FadeOut(plano), FadeOut(sucesion3))\n        self.play(Write(eje4))\n        self.wait()\n        self.play(ShrinkToCenter(eje4))\n        self.play(ShowCreation(plano), run_time=0.5)\n        self.play(GrowFromCenter(ej4))\n        self.wait(1)\n        self.play(ApplyMethod(ej4.to_edge, UP))\n        self.play(Write(sucesion4), run_time=3)\n        self.wait()\n        self.play(FadeOut(plano), FadeOut(sucesion4))\n        self.play(ApplyMethod(ej4.to_edge, UP))\n        self.play(Write(preg_1))\n        self.wait(2)\n        self.play(FadeOut(ej4))\n        self.play(ReplacementTransform(preg_1, preg_2))\n        self.wait(7)\n        self.play(FadeOut(preg_2))"}]}
{"messages": [{"role": "user", "content": "Present the \"Teorema Puente\" with mathematical definitions and then illustrate its application with animated sequences of points converging in a 2D plane, representing mathematical sequences."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Teo_Puente(Scene):\n\n    def construct(self):\n        plano = NumberPlane()\n        title = TextMobject('Teorema Puente')\n        title.scale(1.2)\n        title.set_color(YELLOW)\n        intro = TextMobject('El teorema dice:').shift(2 * UP)\n        teo1 = TexMobject(\"\\\\text{Sea } \\\\{X_n\\\\}\\\\subset\\\\mathbb{R}^m\\\\text{ sucesi\\\\'{o}n. } \\\\forall k\\\\in\\\\{1,...,m\\\\} \\\\lim_{n\\\\to\\\\infty}X_{n,k}=L_k\")\n        teo2 = TexMobject('\\\\Longleftrightarrow \\\\lim_{n\\\\to\\\\infty} X_{n}=L=(L_1,...,L_k,...,L_m)')\n        teo2.next_to(teo1, DOWN)\n        teo = VGroup(teo1, teo2)\n        ejemplos = TextMobject('Veamos algunos ejemplos de su aplicaci\u00f3n')\n        ejem1 = TexMobject('X_n=\\\\left(\\\\frac{6}{n},0\\\\right)').shift(1.5 * UP)\n        desc1 = TexMobject('\\\\Rightarrow X_{n,1}=\\\\frac{6}{n}\\\\quad X_{n,2}=0')\n        teoapl1 = TexMobject('\\\\lim_{n\\\\to\\\\infty}\\\\frac{6}{n}=0,\\\\ \\\\lim_{n\\\\to\\\\infty}0=0\\\\Rightarrow\\\\lim_{n\\\\to\\\\infty}X_n=(0,0)').shift(1.5 * DOWN)\n        vis = TextMobject(\"Veamos esta sucesi\\\\'{o}n\")\n        ejem1.set_color(RED)\n        ejem1.bg = SurroundingRectangle(ejem1, color=RED, fill_color=BLACK, fill_opacity=1)\n        Group11 = VGroup(ejem1.bg, ejem1)\n        suce1 = []\n        for n in range(1, 101):\n            x_n = Dot(point=np.array([6 / n, 0, 0]), radius=0.05, color=RED)\n            suce1.append(x_n)\n        sucesion1 = VGroup(*suce1)\n        ejem2 = TexMobject('X_n  =\\\\left(\\\\frac{n}{10},\\\\frac{1}{n}\\\\right)').shift(1.5 * UP)\n        desc2 = TexMobject('\\\\Rightarrow X_{n,1}=\\\\frac{n}{10}\\\\quad X_{n,2}=\\\\frac{1}{n}')\n        teoapl2 = TexMobject('\\\\nexists\\\\lim_{n\\\\to\\\\infty}\\\\frac{n}{10} \\\\Rightarrow \\\\nexists\\\\lim_{n\\\\to\\\\infty}X_n').shift(1.5 * DOWN)\n        vis = TextMobject(\"Veamos esta sucesi\\\\'{o}n\")\n        ejem2.set_color(YELLOW_E)\n        ejem2.bg = SurroundingRectangle(ejem2, color=YELLOW_E, fill_color=BLACK, fill_opacity=1)\n        Group12 = VGroup(ejem2.bg, ejem2)\n        suce2 = []\n        for n in range(1, 101):\n            x_n = Dot(point=np.array([n / 10, 1 / n, 0]), radius=0.05, color=YELLOW_E)\n            suce2.append(x_n)\n        sucesion2 = VGroup(*suce2)\n        desa1 = TextMobject('Es tu turno de usar el teorema')\n        desa2 = TextMobject(\"Demuestra el valor del l\\\\'{i}mite de la siguiente sucesi\\\\'{o}n. Usa \\n \\n                                la definici\\\\'{o}n e int\\\\'{e}ntalo despu\\\\'{e}s usando el teorema puente:\").shift(UP)\n        desa = TexMobject('X_n=\\\\left(6\\\\frac{(-1)^n}{n},\\\\frac{4}{n}\\\\right)').shift(DOWN)\n        desa.set_color(ORANGE)\n        desa.bg = SurroundingRectangle(desa, color=ORANGE, fill_color=BLACK, fill_opacity=1)\n        Group13 = VGroup(desa.bg, desa)\n        suce5 = []\n        for n in range(1, 101):\n            x_n = Dot(point=np.array([6 * (-1) ** n / n, 4 / n, 0]), radius=0.05, color=ORANGE)\n            suce5.append(x_n)\n        sucesion5 = VGroup(*suce5)\n        self.play(Write(title))\n        self.wait(2)\n        self.play(ReplacementTransform(title, intro), Write(teo))\n        self.wait(20)\n        self.play(FadeOut(intro), FadeOut(teo))\n        self.play(Write(ejemplos))\n        self.wait(3.2)\n        self.play(ReplacementTransform(ejemplos, ejem1))\n        self.wait(2.5)\n        self.play(Write(desc1))\n        self.wait(7)\n        self.play(Write(teoapl1))\n        self.wait(10)\n        self.play(ReplacementTransform(desc1, vis), FadeOut(teoapl1))\n        self.wait(2)\n        self.play(Transform(ejem1, Group11))\n        self.play(ApplyMethod(Group11.to_edge, UP), FadeOut(vis))\n        self.add_foreground_mobjects(Group11)\n        self.play(ShowCreation(plano), run_time=0.5)\n        self.play(Write(sucesion1), run_time=5)\n        self.wait(3)\n        self.play(FadeOut(Group11), FadeOut(plano), FadeOut(sucesion1))\n        self.play(Write(ejem2))\n        self.wait(2.5)\n        self.play(Write(desc2))\n        self.wait(2)\n        self.play(Write(teoapl2))\n        self.wait(7)\n        self.play(ReplacementTransform(desc2, vis), FadeOut(teoapl2))\n        self.wait(2)\n        self.play(Transform(ejem2, Group12))\n        self.play(ApplyMethod(Group12.to_edge, UP), FadeOut(vis))\n        self.add_foreground_mobjects(Group12)\n        self.play(ShowCreation(plano), run_time=0.5)\n        self.play(Write(sucesion2), run_time=5)\n        self.wait(3)\n        self.play(FadeOut(Group12), FadeOut(plano), FadeOut(sucesion2))\n        self.play(Write(desa1))\n        self.wait(2.5)\n        self.play(FadeOut(desa1), Write(desa2), Write(desa))\n        self.wait(15)\n        self.play(Transform(desa, Group13))\n        self.play(FadeOut(desa2), ApplyMethod(Group13.to_edge, UP))\n        self.add_foreground_mobjects(Group13)\n        self.play(ShowCreation(plano), run_time=0.5)\n        self.play(Write(sucesion5), run_time=5)\n        self.wait(4)\n        self.play(FadeOut(plano), FadeOut(sucesion5), FadeOut(Group13))"}]}
{"messages": [{"role": "user", "content": "Illustrate the definition of the limit of a sequence with a visual explanation of the epsilon-delta definition, showing a sequence converging to a point on a number plane."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Definicion_Limite_Sucesiones(MovingCameraScene, Scene):\n\n    def setup(self):\n        Scene.setup(self)\n        MovingCameraScene.setup(self)\n\n    def construct(self):\n        titulo = TextMobject('L\u00edmite de sucesiones.').scale(1.5)\n        definicion = TextMobject('Definici\u00f3n:')\n        def_1 = TexMobject('\\\\lim_{n\\\\rightarrow\\\\infty}\\\\vec{x}_n = \\\\vec{x}_0')\n        def_2 = TexMobject('\\\\Leftrightarrow')\n        def_3 = TexMobject('\\\\forall r>0 \\\\ \\\\exists \\\\ N\\\\in \\\\mathbb{N} \\\\ tq \\\\ \\\\forall n>N \\\\ \\\\vec{x} \\\\in \\\\mathbb{B}_{r}(\\\\vec{x}_0)')\n        def_1.move_to((0, 1, 0))\n        def_2.move_to((0, 0, 0))\n        def_3.move_to((0, -1, 0))\n        definicion.move_to((0, 2.2, 0))\n        gpo_1 = VGroup(definicion, def_1, def_2, def_3)\n        text_1 = TextMobject(\"\\\\text{Pero... \\\\textquestiondown qu\\\\'{e} nos dice geom\\\\'{e}tricamente esta definici\\\\'{o}n?}\")\n        grid = NumberPlane()\n        text_2 = TexMobject('\\\\text{Consideremos la siguiente sucesi\u00f3n en el plano: }', '\\\\vec{x}_n=(\\\\frac{1}{n}, \\\\frac{1}{n})', color=WHITE).scale(0.5).to_edge(LEFT + 2 * UP)\n        text_3 = TexMobject(\"\\\\text{Recuerda que es una funci\\\\'{o}n de }\", '\\\\mathbb{N}\\\\rightarrow\\\\mathbb{R}^{2}', color=WHITE).next_to(text_2, 0.5 * DOWN).scale(0.5)\n        text_3_1 = TexMobject(\"\\\\text{Supongamos que queremos probar que el l\\\\'{i}mite es el vector }\", '(0,0).}', color=WHITE).next_to(text_3, 0.7 * DOWN).scale(0.5)\n        text_2[1].set_color(ORANGE)\n        text_3[1].set_color(ORANGE)\n        text_3_1[1].set_color(ORANGE)\n        text_c = VGroup(text_2, text_3, text_3_1)\n        text_c.bg = SurroundingRectangle(text_c, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo_2 = VGroup(text_c.bg, text_c)\n        puntos_objetos = []\n        puntos_objetos_1 = []\n        for i in cjto_pts_sucesion:\n            punto_i = Dot(point=i, radius=0.025)\n            punto_i_1 = Dot(point=i, radius=0.001)\n            puntos_objetos.append(punto_i)\n            puntos_objetos_1.append(punto_i_1)\n        gpo_4 = VGroup(*puntos_objetos)\n        gpo_4_1 = VGroup(*puntos_objetos_1)\n        circulo = Circle(radius=0.5)\n        circulo_t = TextMobject(\"\\\\text{Entonces damos a la bola de radio \\\\'{e}psilon...}\", '($\\\\epsilon$)').set_color(RED).move_to((-0.55, -0.8, 0))\n        radio = Brace(circulo, RIGHT)\n        radio_t = TextMobject('$2\\\\epsilon$').next_to(radio.get_center(), RIGHT, buff=0.2)\n        text_4_1 = TexMobject('\\\\text{Recordando de la definici\u00f3n: }', '\\\\forall r >0 \\\\exists N \\\\in \\\\mathbb{N} \\\\text{ tq. } \\\\forall n > N, \\\\vec{x} \\\\in \\\\mathbb{B}_{r}(\\\\vec{x}_0),', color=WHITE)\n        text_4_2 = TexMobject('\\\\text{en este caso }', '\\\\vec{x}_0=(0,0)', color=WHITE).next_to(text_4_1, DOWN)\n        text_4_1[1].set_color(ORANGE)\n        text_4_2[1].set_color(ORANGE)\n        text_4 = VGroup(text_4_1, text_4_2)\n        text_4.bg = SurroundingRectangle(text_4, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo_5 = VGroup(text_4.bg, text_4).scale(0.4).move_to((0, -1, 0))\n        text_5 = TextMobject('Esta $N$ debe ser tal que todos los elementos de la sucesi\u00f3n \\n\\n                                inmediatos despu\u00e9s del $N$-\u00e9simo elemento, est\u00e1n dentro \\n\\n                                de la bola de radio r ')\n        text_5.bg = SurroundingRectangle(text_5, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo_6 = VGroup(text_5.bg, text_5).scale(0.4).move_to((0, -1.25, 0))\n        N_esimo_pto = Dot(point=gpo_4[14].get_center(), radius=0.01, color=YELLOW)\n        N_m_u_esimo_pto = Dot(point=gpo_4[13].get_center(), radius=0.01, color=YELLOW)\n        text_6 = TextMobject('Nota c\u00f3mo estos dos puntos podr\u00edan ser el $N$-\u00e9simo, \\n\\n                                ya que todos los siguientes puntos de la sucesi\u00f3n \\n\\n                                est\u00e1n dentro de la bola de radio r ')\n        text_6.bg = SurroundingRectangle(text_6, color=WHITE, fill_color=BLACK, fill_opacity=1)\n        gpo_7 = VGroup(text_6.bg, text_6).scale(0.04).move_to((1 / (2 * np.sqrt(2)), 1 / (2 * np.sqrt(2)) + 0.07, 0))\n        dentro_bola_antes_dentro = [i for i in puntos_objetos_1[15:]]\n        dentro_bola_despues_dentro = [Dot(point=i.get_center(), radius=0.01, color=BLUE) for i in puntos_objetos_1[15:]]\n        dentro_bola_antes_fuera = [i for i in puntos_objetos_1[0:13]]\n        dentro_bola_despues_fuera = [Dot(point=i.get_center(), radius=0.01, color=ORANGE) for i in puntos_objetos_1[0:13]]\n        dentro_bola_g_antes_dentro = VGroup(*dentro_bola_antes_dentro)\n        dentro_bola_g_despues_dentro = VGroup(*dentro_bola_despues_dentro)\n        dentro_bola_g_antes_fuera = VGroup(*dentro_bola_antes_fuera)\n        dentro_bola_g_despues_fuera = VGroup(*dentro_bola_despues_fuera)\n        text_7 = TextMobject('Por \u00faltimo, nota c\u00f3mo hay solamente una cantidad finita \\n\\n                                fuera de la bola y una cantidad infinita numerable dentro \\n\\n                                de la bola, \u00bfc\u00f3mo puedes probar esto?')\n        text_7.bg = SurroundingRectangle(text_7, color=WHITE, fill_color=BLACK, fill_opacity=10)\n        gpo_8 = VGroup(text_7.bg, text_7).scale(0.25).move_to((0, 1.5, 0))\n        self.play(Write(titulo))\n        self.wait(1.5)\n        self.play(FadeOut(titulo))\n        self.play(Write(gpo_1))\n        self.wait(15)\n        self.play(ReplacementTransform(gpo_1, text_1))\n        self.wait()\n        self.play(FadeOut(text_1))\n        self.wait()\n        self.play(Write(grid))\n        self.wait()\n        self.play(Write(gpo_2))\n        self.wait(11)\n        self.play(Write(gpo_4), run_time=3)\n        self.wait()\n        self.play(Write(circulo_t))\n        self.wait()\n        self.play(FadeOut(circulo_t), self.camera_frame.scale, 0.25, self.camera_frame.move_to, (0, 0, 0))\n        self.wait()\n        self.play(Write(circulo))\n        self.wait()\n        self.play(Write(radio), Write(radio_t))\n        self.wait()\n        self.play(FadeOut(radio), FadeOut(radio_t))\n        self.wait()\n        self.play(FadeOut(gpo_2))\n        self.play(self.camera_frame.scale, 2)\n        self.wait()\n        self.play(Write(gpo_5))\n        self.wait(7)\n        self.play(ReplacementTransform(gpo_5, gpo_6))\n        self.wait(5.5)\n        self.play(FadeOut(gpo_6), self.camera_frame.scale, 0.075, self.camera_frame.move_to, (0.35, 0.35, 0), ReplacementTransform(gpo_4, gpo_4_1))\n        self.wait()\n        self.play(ReplacementTransform(gpo_4_1[14], N_esimo_pto), ReplacementTransform(gpo_4_1[13], N_m_u_esimo_pto))\n        self.wait()\n        self.play(Write(gpo_7))\n        self.wait(9)\n        self.play(self.camera_frame.scale, 10, FadeOut(gpo_7))\n        self.play(ReplacementTransform(dentro_bola_g_antes_dentro, dentro_bola_g_despues_dentro))\n        self.wait()\n        self.play(Write(gpo_8))\n        self.wait(11)\n        self.play(ReplacementTransform(dentro_bola_g_antes_fuera, dentro_bola_g_despues_fuera))\n        self.wait(5)\n        self.play(FadeOut(gpo_8), FadeOut(grid), FadeOut(circulo), FadeOut(dentro_bola_g_despues_fuera), FadeOut(dentro_bola_g_despues_dentro), FadeOut(N_esimo_pto), FadeOut(N_m_u_esimo_pto))"}]}
{"messages": [{"role": "user", "content": "Explain the nested rectangles theorem by defining rectangles and their diagonals in n-dimensions, visualizing in 2D with an animated shrinking sequence of nested rectangles and corresponding diagonals, and concluding with the theorem's statement."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass RectangulosAnidados(Scene):\n\n    def construct(self):\n        titulo = TextMobject('El Teorema de los', ' Rect\u00e1ngulos Anidados').scale(1.2)\n        titulo[1].set_color(ORANGE)\n        def_rect_a = TexMobject('\\\\text{Dados los intervalos cerrados } I_i=[a_i,b_i],\\\\ a_i\\\\leq b_i\\\\ \\\\forall i \\\\in (1...n)').scale(0.9).shift(2 * UP)\n        def_rect_b = TextMobject('definimos un', ' rect\u00e1ngulo', ' en', ' $\\\\mathbb{R}^n$', ' de la siguiente forma:').scale(0.9).shift(UP)\n        def_rect_b[1].set_color(ORANGE)\n        def_rect_b[3].set_color(ORANGE)\n        def_rect_c = TexMobject('R = [a_1,b_1]\\\\times[a_2,b_2]\\\\times ... \\\\times[a_n,b_n]').next_to(def_rect_b, 1.5 * DOWN).scale(0.9).set_color(ORANGE)\n        def_rect_d = TextMobject('y su', ' diagonal', ' como:').next_to(def_rect_c, 1.5 * DOWN).scale(0.9)\n        def_rect_d[1].set_color(YELLOW)\n        def_rect_e = TexMobject('diag(R) = \\\\Vert (b_1,b_2,...,b_n)-(a_1,a_2,...,a_n) \\\\Vert').next_to(def_rect_d, 1.5 * DOWN).scale(0.9).set_color(YELLOW)\n        def_rect = VGroup(def_rect_a, def_rect_b, def_rect_c, def_rect_d, def_rect_e)\n        enr2 = TextMobject('Visualicemos lo anterior en $\\\\mathbb{R}^2$').to_edge(UP)\n        ab_eje_x = VGroup(TexMobject('a_1').shift(2.3 * LEFT), TexMobject('b_1').shift(2.3 * RIGHT))\n        ab_eje_y = VGroup(TexMobject('a_2').shift(2.3 * DOWN), TexMobject('b_2').shift(2.3 * UP))\n        linea_ejex = DashedLine(start=(-2, 0, 0), end=(2, 0, 0))\n        linea_ejey = DashedLine(start=(0, -2, 0), end=(0, 2, 0))\n        ejes = VGroup(ab_eje_x, ab_eje_y, linea_ejex, linea_ejey)\n        text_R = TexMobject('R = [a_1,b_1]\\\\times[a_2,b_2]').move_to(enr2).set_color(ORANGE)\n        text_diagR = TexMobject('diag(R) = \\\\Vert (b_1,b_2)-(a_1,a_2) \\\\Vert').move_to(enr2).set_color(YELLOW)\n        R = Square(side_length=4.0, color=ORANGE)\n        R.set_fill(ORANGE, opacity=0.5)\n        diagR = DoubleArrow(start=(2, 2, 0), end=(-2, -2, 0), stroke_width=2, color=YELLOW).scale(1.1)\n        diagR.set_fill(YELLOW, opacity=0.5)\n        al_teorema = TextMobject('Procedamos a enunciar \\n\\n                                 el teorema: ').shift(3 * RIGHT)\n        teo_1a = TextMobject('Sea', ' $\\\\{R_k\\\\}$', ' una sucesi\u00f3n').shift(3 * RIGHT + 2 * UP)\n        teo_1a[1].set_color(ORANGE)\n        teo_1b = TextMobject('de rect\u00e1ngulos anidados').next_to(teo_1a, DOWN)\n        teo_1c = TexMobject('(R_{k+1} \\\\subset R_k \\\\ \\\\forall k \\\\in \\\\mathbb{N})').next_to(teo_1b, 2 * DOWN).set_color(RED)\n        teo_1 = VGroup(teo_1a, teo_1b, teo_1c)\n        color_seq = [ORANGE, YELLOW, BLUE, GREEN, PINK, RED]\n        rec_seq = []\n        for i in range(2, 50):\n            rec_seq.append(Square(side_length=4 / i, color=color_seq[i % 6]).set_fill(color_seq[i % 5], opacity=0.3).shift(3 * LEFT))\n        rect_group = VGroup(*rec_seq)\n        teo_2a = TextMobject('Si adem\u00e1s, se tiene que').move_to(teo_1a)\n        teo_2b = TexMobject('\\\\lim_{k\\\\to \\\\infty}diag(R_k) = 0').next_to(teo_2a, DOWN).set_color(YELLOW)\n        teo_2 = VGroup(teo_2a, teo_2b)\n        diag_seq = []\n        for i in range(1, 50):\n            diag_seq.append(DoubleArrow(start=(2 / i, 2 / i, 0), end=(-2 / i, -2 / i, 0), tip_length=0.2, stroke_width=2, color=YELLOW).scale(1.1).shift(3 * LEFT))\n        diag_group = VGroup(*diag_seq)\n        conclu_a = TextMobject('Entonces,').move_to(teo_1b)\n        conclu_b = TexMobject('\\\\cap_{k=1}^{\\\\infty}R_k = \\\\{\\\\vec{x}_0\\\\}').next_to(conclu_a, DOWN).set_color(ORANGE)\n        conclu = VGroup(conclu_a, conclu_b).shift(2 * DOWN)\n        x0 = BCustomDot().shift(3 * LEFT)\n        puedes = TextMobject('\u00bfPuedes hacer otra sucesi\u00f3n de rect\u00e1ngulos anidados?').shift(UP)\n        otra_pregunta = TextMobject('\u00bfQu\u00e9 pasa si los intervalos no son cerrados?').shift(DOWN)\n        self.play(Write(titulo))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.play(Write(def_rect_a))\n        self.wait()\n        self.play(Write(def_rect_b))\n        self.wait()\n        self.play(Write(def_rect_c))\n        self.wait()\n        self.play(Write(def_rect_d), Write(def_rect_e))\n        self.wait(3)\n        self.play(FadeOut(def_rect))\n        self.wait()\n        self.play(Write(enr2))\n        self.wait()\n        self.play(ShowCreation(ejes))\n        self.play(ReplacementTransform(enr2, text_R))\n        self.wait()\n        self.play(ShowCreation(R, run_time=2.0))\n        self.wait(1.8)\n        self.play(ReplacementTransform(text_R, text_diagR))\n        self.wait()\n        self.play(ShowCreation(diagR))\n        self.wait()\n        self.play(FadeOut(diagR))\n        self.play(ejes.shift, 3 * LEFT, R.shift, 3 * LEFT)\n        self.play(ReplacementTransform(text_diagR, al_teorema))\n        self.wait(3)\n        self.play(FadeOut(al_teorema))\n        self.play(Write(teo_1))\n        self.wait()\n        self.play(ShowIncreasingSubsets(rect_group, run_time=4.0))\n        self.wait()\n        self.play(FadeOut(teo_1))\n        self.wait()\n        self.play(Write(teo_2))\n        self.wait()\n        self.play(ShowIncreasingSubsets(diag_group, run_time=4.0))\n        self.wait()\n        self.play(Write(conclu))\n        self.play(FadeOut(diag_group))\n        self.play(ApplyMethod(x0.custom_method, WHITE))\n        self.play(ApplyMethod(x0.other_method))\n        self.wait(2)\n        self.play(FadeOut(teo_2), FadeOut(conclu), FadeOut(ejes), FadeOut(R), FadeOut(rect_group), FadeOut(x0))\n        self.play(Write(puedes))\n        self.wait()\n        self.play(Write(otra_pregunta))\n        self.wait(2)\n        self.play(FadeOut(puedes), FadeOut(otra_pregunta))"}]}
{"messages": [{"role": "user", "content": "Demonstrate the concept of open sets in topology by illustrating the definition and properties of interior points with text and geometric shapes."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Conjuntos_abiertos(Scene):\n\n    def construct(self):\n        titulo = TextMobject('Conjuntos Abiertos').scale(1.5)\n        text1 = TextMobject('Veamos el siguiente conjunto')\n        text1.move_to(3 * UP)\n        text2 = TextMobject('A').scale(2)\n        text2.move_to(text1.get_center() + DOWN)\n        text2.set_color(PURPLE)\n        text3_10 = TextMobject('Consideramos un ', 'borde', ' a\u00f1adido alrededor del conjunto ', 'A')\n        text3_10[1].set_color(BLUE_C)\n        text3_10[3].set_color(PURPLE)\n        text3_10.move_to(text1.get_center() + 0.3 * DOWN)\n        text3_11 = TextMobject('Podemos dibujar una bola con centro en')\n        text3_11_1 = TextMobject('cualquier punto de este ', 'borde').next_to(text3_11, DOWN)\n        text3_11_1[1].set_color(BLUE_C)\n        text3 = VGroup(text3_11, text3_11_1)\n        text3.move_to(text1.get_center() + 0.3 * DOWN)\n        text3_1_1 = TextMobject('Y con cualquier radio, la bola intersecta el')\n        text3_1_2 = TextMobject('conjunto ', 'A', ' y el exterior de este').next_to(text3_1_1, DOWN)\n        text3_1_2[1].set_color(PURPLE)\n        text3_1 = VGroup(text3_1_1, text3_1_2)\n        text3_1.move_to(text3)\n        text4_1 = TextMobject('Con esta observaci\u00f3n decimos que todos los puntos')\n        text4_2 = TextMobject('en el ', 'borde', ' representan la ', 'frontera de ', 'A').next_to(text4_1, DOWN)\n        text4_2[4].set_color(PURPLE)\n        text4_2[3].set_color(BLUE_C)\n        text4_2[1].set_color(BLUE_C)\n        text4 = VGroup(text4_1, text4_2)\n        text4.move_to(text3.get_center())\n        text5_1 = TextMobject('Sin embargo,', ' ning\u00fan elemento de la ', 'frontera de ', 'A')\n        text5_2 = TextMobject('est\u00e1 contenido en ', 'A').next_to(text5_1, DOWN)\n        text5_1[3].set_color(PURPLE)\n        text5_1[2].set_color(BLUE_C)\n        text5_2[1].set_color(PURPLE)\n        text5 = VGroup(text5_1, text5_2)\n        text5.move_to(text4.get_center())\n        def1_1 = TextMobject('A los conjuntos que cumplen con lo anterior')\n        def1_2 = TextMobject('se les denomina conjuntos ', 'ABIERTOS').next_to(def1_1, DOWN)\n        def1_2[1].set_color(YELLOW)\n        def1 = VGroup(def1_1, def1_2)\n        def2 = TextMobject('En otras palabras, un conjunto A es ', 'abierto', ' si', '$$Fr(A) \\\\cap A=\\\\emptyset $$')\n        def2[1].set_color(YELLOW)\n        def2[3].set_color(YELLOW)\n        creature = SVGMobject('Topologia_SVGs/abierto.svg', fill_color=PURPLE, color=BLACK)\n        creature.move_to(DOWN)\n        creature.scale(3)\n        creature1 = SVGMobject('Topologia_SVGs/abierto.svg', fill_color=PURPLE, color=BLUE_C)\n        creature1.move_to(DOWN)\n        creature1.scale(3)\n        creature2 = creature.copy()\n        punto1 = Dot(color=BLUE_C)\n        punto1.next_to(creature, RIGHT, buff=1)\n        circulo1 = Circle(color=RED, radius=1)\n        circulo1.move_to(punto1)\n        circulo1_1 = Circle(color=RED, radius=0.5)\n        circulo1_1.move_to(punto1)\n        punto2 = Dot(color=BLUE_C)\n        punto2.next_to(creature, LEFT, buff=1.12)\n        circulo2 = Circle(color=RED, radius=1)\n        circulo2.move_to(punto2)\n        circulo2_1 = Circle(color=RED, radius=2)\n        circulo2_1.move_to(punto2)\n        titulo1 = TextMobject('Segunda Caracterizaci\u00f3n \\n \\n                             de Conjuntos Abiertos')\n        text7_1 = TextMobject('Decimos que un conjunto es ', 'abierto', ' si')\n        text7_2 = TextMobject('todos sus puntos son interiores').next_to(text7_1, DOWN)\n        text7_1[1].set_color(YELLOW)\n        text7 = VGroup(text7_1, text7_2)\n        text8_1 = TextMobject('Consideremos el mismo conjunto')\n        text8_1.move_to(3 * UP)\n        text8_2 = TextMobject('A').scale(2)\n        text8_2.move_to(text1.get_center() + DOWN)\n        text8_2.set_color(PURPLE)\n        text9_1 = TextMobject('Notemos que al tomar cualquier punto en ', 'A', ',')\n        text9_2 = TextMobject('este se mantiene en el interior de ', 'A').next_to(text9_1, DOWN)\n        text9_1[1].set_color(PURPLE)\n        text9_2[1].set_color(PURPLE)\n        text9 = VGroup(text9_1, text9_2)\n        text9.move_to(text1)\n        text10_1 = TextMobject('Por ello decimos que todos los elementos')\n        text10_2 = TextMobject('de ', 'A', ' son puntos interiores').next_to(text10_1, DOWN)\n        text10_2[1].set_color(PURPLE)\n        text10 = VGroup(text10_1, text10_2)\n        text11_1 = TextMobject('Entonces decimos que un conjunto es ', 'abierto', ' si')\n        text11_2 = TextMobject('todos sus puntos son interiores').next_to(text11_1, DOWN)\n        text11_1[1].set_color(YELLOW)\n        text11 = VGroup(text11_1, text11_2)\n        text12_1 = TextMobject('De manera m\u00e1s formal,')\n        text12_2 = TextMobject('Un conjunto ', 'A', ' es ', 'abierto', ' si').next_to(text12_1, DOWN + 0.5 * DOWN)\n        text12_3 = TexMobject('\\\\forall x \\\\in A', '\\\\text{, x es punto interior}').next_to(text12_2, DOWN)\n        text12_2[3].set_color(YELLOW)\n        text12 = VGroup(text12_1, text12_2, text12_3)\n        text12_1.move_to(UP)\n        creature3 = SVGMobject('Topologia_SVGs/abierto.svg', fill_color=PURPLE, fill_opacity=1, color=BLACK)\n        creature3.move_to(DOWN)\n        creature3.scale(3)\n        punto3 = Dot()\n        punto3.move_to(creature3.get_center() + 0.5 * RIGHT)\n        circulo3 = Circle(color=RED, radius=0.5)\n        circulo3.move_to(punto3)\n        punto4 = Dot()\n        punto4.move_to(creature3.get_center() + 1.5 * RIGHT + 2 * UP)\n        circulo4 = Circle(color=RED, radius=0.15)\n        circulo4.move_to(punto4)\n        punto5 = Dot()\n        punto5.move_to(creature3.get_center() + 1.9 * LEFT + 1.41 * DOWN)\n        circulo5 = Circle(color=RED, radius=0.12)\n        circulo5.move_to(punto5)\n        self.play(Write(titulo))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.wait(0.5)\n        self.play(Write(text1))\n        self.play(Write(text2))\n        self.play(SpinInFromNothing(creature))\n        self.wait()\n        self.play(FadeOut(text1), FadeOut(text2))\n        self.play(Write(text3_10), ReplacementTransform(creature, creature1))\n        self.wait(1.5)\n        self.play(ReplacementTransform(text3_10, text3))\n        self.wait()\n        self.play(FadeIn(punto1), FadeIn(circulo1))\n        self.wait(1.5)\n        self.play(ReplacementTransform(text3, text3_1))\n        self.wait()\n        self.play(ReplacementTransform(circulo1, circulo1_1))\n        self.wait(0.5)\n        self.play(FadeOut(punto1), FadeOut(circulo1_1))\n        self.play(FadeIn(punto2), FadeIn(circulo2))\n        self.wait()\n        self.play(ReplacementTransform(circulo2, circulo2_1))\n        self.play(FadeOut(punto2), FadeOut(circulo2_1))\n        self.play(ReplacementTransform(text3_1, text4))\n        self.wait(3.5)\n        self.play(ReplacementTransform(text4, text5))\n        self.wait(1.5)\n        self.play(ReplacementTransform(creature1, creature2))\n        self.wait(1.5)\n        self.play(FadeOut(creature2))\n        self.play(Write(def1))\n        self.wait(3)\n        self.play(FadeOut(def1), FadeOut(text5))\n        self.play(Write(def2))\n        self.wait(3.5)\n        self.play(FadeOut(def2))\n        self.wait()\n        self.play(Write(titulo1))\n        self.wait()\n        self.play(FadeOut(titulo1))\n        self.play(Write(text7))\n        self.play(FadeOut(text7))\n        self.wait()\n        self.play(Write(text8_1))\n        self.play(Write(text8_2))\n        self.play(GrowFromCenter(creature3))\n        self.wait()\n        self.play(ReplacementTransform(text8_1, text9), FadeOut(text8_2))\n        self.play(FadeIn(punto3), FadeIn(circulo3))\n        self.wait()\n        self.play(ReplacementTransform(punto3, punto4), ReplacementTransform(circulo3, circulo4))\n        self.wait()\n        self.play(ReplacementTransform(punto4, punto5), ReplacementTransform(circulo4, circulo5))\n        self.wait()\n        self.play(FadeOut(punto5), FadeOut(circulo5))\n        self.wait(3)\n        self.play(FadeOut(creature3))\n        self.play(ReplacementTransform(text9, text10))\n        self.wait()\n        self.play(FadeOut(text10))\n        self.play(Write(text11))\n        self.wait(2.5)\n        self.play(ReplacementTransform(text11, text12))\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Explain the concept of a \"bola\" or \"neighborhood\" in a space by introducing a point and a radius, then showing the definition and discussing different norms."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Bolas(Scene):\n\n    def construct(self):\n        grid = NumberPlane()\n        titulo = TextMobject('Bolas o Vecindades')\n        titulo.scale(1.5)\n        text1 = TextMobject('Tomemos un punto en el espacio, $\\\\vec{x}_0$')\n        text1.move_to((0, 3, 0))\n        text2 = TextMobject('Y un radio ', 'r ', '> 0')\n        text2[1].set_color(TEAL)\n        text2.move_to(text1)\n        text_3_1 = TextMobject('Podemos seleccionar los puntos que se encuentran')\n        text_3_2 = TextMobject('a una distancia menor a ', 'r', ' de $\\\\vec{x}_0$').next_to(text_3_1, DOWN)\n        text_3_2[1].set_color(TEAL)\n        text3 = VGroup(text_3_1, text_3_2)\n        text3.move_to(text1)\n        text4 = TextMobject('Esto es conocido como una bola o vecindad')\n        text4.move_to(text1)\n        text5 = TextMobject('De manera formal, definimos bola o vecindad como:')\n        text6 = TexMobject('B_r(\\\\vec{x}_0) :=\\\\lbrace \\\\vec{x} \\\\  | \\\\ d(\\\\vec{x},\\\\vec{x}_0)=\\\\norm{\\\\vec{x}-\\\\vec{x}_0}<r \\\\rbrace')\n        text5.move_to(text6.get_center() + UP)\n        text7 = TextMobject('Notemos que, por lo anterior, la bola depende de la \\n\\n                           m\u00e9trica o norma definida en el espacio')\n        text8 = TextMobject(\" \\\\textquestiondown Puedes imaginar c\\\\'{o}mo se ver\\\\'{i}a una bola \\n\\n                            con otras normas, por ejemplo con la norma \\n\\n                             infinito o la norma 1?\")\n        text1.bg = SurroundingRectangle(text1, color=YELLOW_E, fill_color=BLACK, fill_opacity=1)\n        Group11 = VGroup(text1.bg, text1)\n        text2.bg = SurroundingRectangle(text2, color=YELLOW_E, fill_color=BLACK, fill_opacity=1)\n        Group12 = VGroup(text2.bg, text2)\n        text3.bg = SurroundingRectangle(text3, color=YELLOW_E, fill_color=BLACK, fill_opacity=1)\n        Group13 = VGroup(text3.bg, text3)\n        text4.bg = SurroundingRectangle(text4, color=YELLOW_E, fill_color=BLACK, fill_opacity=1)\n        Group14 = VGroup(text4.bg, text4)\n        r = 2\n        x0 = np.array([0, 0, 0])\n        punto = Dot()\n        punto.scale(1.14)\n        punto.set_color(YELLOW)\n        puntolabel = TextMobject('$$\\\\vec{x}_0$$')\n        puntolabel.scale(1.15)\n        punto.move_to(x0)\n        puntolabel.set_color(YELLOW_B)\n        puntolabel.move_to((0.39, 0.39, 0))\n        bola = Dot(radius=r, fill_color=YELLOW_D, fill_opacity=0.6)\n        linea_r = Line((0, 0, 0), (2, 0, 0)).set_color(TEAL)\n        label_r = TextMobject('r').move_to(0.75 * RIGHT + 0.25 * DOWN).set_color(TEAL)\n        Bola_1 = VGroup(bola, linea_r, label_r)\n        self.play(Write(titulo))\n        self.wait(2)\n        self.play(FadeOut(titulo))\n        self.play(Write(grid))\n        self.play(Write(Group11))\n        self.play(FadeIn(punto), FadeIn(puntolabel))\n        self.wait(3.2)\n        self.play(ReplacementTransform(Group11, Group12))\n        self.wait(5)\n        self.play(ReplacementTransform(Group12, Group13))\n        self.wait(6)\n        self.play(FadeIn(Bola_1))\n        self.wait()\n        self.play(ReplacementTransform(Group13, Group14), FadeOut(puntolabel))\n        self.wait(4.5)\n        self.play(FadeOut(Bola_1), FadeOut(grid), FadeOut(Group14), FadeOut(punto))\n        self.wait()\n        self.play(Write(text5))\n        self.play(Write(text6))\n        self.wait(2)\n        self.play(FadeOut(text5), FadeOut(text6))\n        self.play(Write(text7))\n        self.wait(5.5)\n        self.play(ReplacementTransform(text7, text8))\n        self.wait(10)\n        self.play(FadeOut(text8))"}]}
{"messages": [{"role": "user", "content": "Explain isolated points and accumulation points with a graphical demonstration, followed by key properties of derived sets."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Puntos_Aislado_y_Acumulacion(Scene):\n\n    def construct(self):\n        title = TextMobject('Puntos Aislados y \\n\\n                            Puntos de Acumulaci\u00f3n').scale(1.5)\n        text1 = TextMobject('Considera el siguiente conjunto ', '$A$')\n        text1.set_color_by_tex_to_color_map({'A': YELLOW})\n        text2 = TextMobject('F\u00edjate en los puntos ', '$x$', ' e ', '$y$').to_edge(UP)\n        text2.set_color_by_tex_to_color_map({'x': RED, 'y': BLUE})\n        B = SVGMobject('Topologia_SVGs/cjtoA.svg', color=YELLOW, fill_color=YELLOW).shift(1.5 * LEFT).scale(2)\n        x = Dot(point=(1, 0, 0), color=YELLOW, radius=0.1)\n        x_label = TexMobject('x', color=RED).next_to(x, DOWN)\n        cjto = VGroup(B, x)\n        y = Dot(point=(-1.8, 0.5, 0), color=BLUE, radius=0.1)\n        y_label = TexMobject('y', color=BLUE).next_to(y, DOWN)\n        grupo = VGroup(y, x_label, y_label)\n        bola = Circle(radius=1, color=PURPLE_B).move_to((1, 0, 0))\n        radio = Line((1, 0, 0), (2, 0, 0), color=PURPLE_B)\n        eps = TexMobject('\\\\varepsilon').next_to(radio, UP)\n        aislado = VGroup(bola, radio, eps)\n        text3 = TextMobject('\u00bfCu\u00e1l crees que sea un', ' punto aislado', '?').to_edge(UP)\n        text3.set_color_by_tex_to_color_map({'punto aislado': PURPLE_B})\n        text4 = TextMobject('\u00bfCu\u00e1l crees que sea un', ' punto de acumulaci\u00f3n', '?').to_edge(UP)\n        text4.set_color_by_tex_to_color_map({'punto de acumulaci\u00f3n': GREEN_D})\n        text5 = TextMobject('$x$', ' es un', ' punto aislado', ', al tomar alguna $\\\\varepsilon >0$ \\n\\n                             vemos que $B_{\\\\varepsilon}($', '$x$', ')$\\\\cap$ ', '$A$', '$=$', '$\\\\{x\\\\}$').to_edge(UP)\n        text5.set_color_by_tex_to_color_map({'punto aislado': PURPLE_B, '$A$': YELLOW, '$x$': RED})\n        text5[8][1].set_color(RED)\n        text6 = TextMobject('Mientras que ', '$y$', ' es un', ' punto de acumulaci\u00f3n', ' pues $\\\\forall\\\\varepsilon >0$ \\n\\n                            se cumple que $(B_{\\\\varepsilon}($', '$y$', ')$\\\\backslash$', '$\\\\{y\\\\}$', '$)\\\\cap $', '$A$', '$\\\\neq \\\\emptyset$').to_edge(UP)\n        text6.set_color_by_tex_to_color_map({'punto de acumulaci\u00f3n': GREEN_D, '$A$': YELLOW, '$y$': BLUE})\n        text6[7][1].set_color(BLUE)\n        text7 = TextMobject('El conjunto de todos los', ' puntos de acumulaci\u00f3n', ' de ', '$A$', ' \\\\\\\\ se llama', ' conjunto derivado', ', y se denota por ', '$der(A)$').scale(0.9)\n        text7.set_color_by_tex_to_color_map({'puntos de acumulaci\u00f3n': GREEN_D, 'conjunto derivado': RED, '$der(A)$': RED, '$A$': YELLOW})\n        text8 = TextMobject('Intenta demostrar las siguientes propiedades \\\\\\\\ de dicho conjunto:').move_to((0, 2.5, 0))\n        prop1 = TextMobject('$der(A)$', ' es la uni\u00f3n de $int(A)$ y los puntos frontera no aislados').move_to((0, 1, 0))\n        prop2 = TextMobject('$cl(A)=$', '$A$', '$\\\\cup$', '$der(A)$').next_to(prop1, DOWN)\n        prop3 = TextMobject('Todos los', ' puntos', ' de $int(A)$ son', ' de acumulaci\u00f3n').next_to(prop2, DOWN)\n        prop1.set_color_by_tex_to_color_map({'$der(A)$': RED})\n        prop2.set_color_by_tex_to_color_map({'$der(A)$': RED, '$A$': YELLOW})\n        prop3.set_color_by_tex_to_color_map({'puntos': GREEN_D, 'de acumulaci\u00f3n': GREEN_D})\n        prop4 = TextMobject('Todos los ', 'puntos aislados', ' de ', '$A$', ' son puntos frontera de ', '$A$').next_to(prop3, DOWN)\n        prop4.set_color_by_tex_to_color_map({'puntos aislados': PURPLE_B, '$A$': YELLOW})\n        propiedades = VGroup(text8, prop1, prop2, prop3, prop4)\n        self.play(Write(title))\n        self.wait()\n        self.play(ReplacementTransform(title, text1))\n        self.play(ApplyMethod(text1.to_edge, UP))\n        self.play(DrawBorderThenFill(cjto))\n        self.wait()\n        self.play(ReplacementTransform(text1, text2), ApplyMethod(x.set_color, RED), Write(grupo))\n        self.wait(2)\n        self.play(ReplacementTransform(text2, text3))\n        self.wait(2)\n        self.play(ReplacementTransform(text3, text4))\n        self.wait(2)\n        self.play(ReplacementTransform(text4, text5), ShowCreation(aislado))\n        self.wait(13)\n        self.play(ReplacementTransform(text5, text6), FadeOut(aislado))\n        i = 4\n        bola_ant = Circle(radius=i, color=GREEN_D).move_to((-1.8, 0.5, 0))\n        while i > 0.2:\n            bola_sig = Circle(radius=i, color=GREEN_D).move_to((-1.8, 0.5, 0))\n            self.play(ReplacementTransform(bola_ant, bola_sig))\n            self.wait()\n            bola_ant = bola_sig\n            i = 0.5 * i\n        self.wait(5)\n        self.play(FadeOut(text6), FadeOut(bola_ant), FadeOut(cjto), FadeOut(grupo))\n        self.wait(2)\n        self.play(Write(text7))\n        self.wait(10)\n        self.play(ReplacementTransform(text7, text8))\n        self.wait(5)\n        self.play(Write(prop1))\n        self.wait(8)\n        self.play(Write(prop2))\n        self.wait(7)\n        self.play(Write(prop3))\n        self.wait(6)\n        self.play(Write(prop4))\n        self.wait(6)\n        self.play(FadeOut(propiedades))"}]}
{"messages": [{"role": "user", "content": "Explain the concept of closed sets in mathematics using text, mathematical notation, and visual aids like a shape and dots with circles."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Conjuntos_cerrados(Scene):\n\n    def construct(self):\n        titulo = TextMobject('Conjuntos Cerrados').scale(1.5)\n        text1 = TextMobject('Consideremos el siguiente conjunto')\n        text1.move_to(3 * UP)\n        text1_1 = TextMobject('B').scale(2)\n        text1_1.move_to(text1.get_center() + DOWN)\n        text1_1.set_color(BLUE_C)\n        text2_1 = TextMobject('Podemos tomar un punto sobre la orilla de ', 'B')\n        text2_2 = TextMobject('y dibujar una bola con centro en ese punto').next_to(text2_1, DOWN)\n        text2_1[1].set_color(BLUE_C)\n        text2 = VGroup(text2_1, text2_2)\n        text2.move_to(2.5 * UP)\n        text3_1 = TextMobject('Para todo radio, la bola intersecta al')\n        text3_2 = TextMobject('conjunto ', 'B', ' y a su complemento').next_to(text3_1, DOWN)\n        text3_2[1].set_color(BLUE_B)\n        text3 = VGroup(text3_1, text3_2)\n        text3.move_to(text2)\n        text4_1 = TextMobject('A esta ', 'orilla', ' se le llama ', 'frontera de ', 'B')\n        text4_2 = TextMobject('y se denota como ', '$Fr($', 'B', '$)$').next_to(text4_1, DOWN)\n        text4_1[1].set_color(RED)\n        text4_1[3].set_color(RED)\n        text4_1[4].set_color(BLUE_C)\n        text4_2[1].set_color(RED)\n        text4_2[2].set_color(BLUE_C)\n        text4_2[3].set_color(RED)\n        text4 = VGroup(text4_1, text4_2)\n        text4.move_to(text2)\n        text5_1 = TextMobject('Obs\u00e9rvese que todos los puntos en la ', 'frontera de ', 'B')\n        text5_2 = TextMobject('est\u00e1n contenidos en el mismo conjunto ', 'B').next_to(text5_1, DOWN)\n        text5_1[1].set_color(RED)\n        text5_1[2].set_color(BLUE_C)\n        text5_2[1].set_color(BLUE_C)\n        text5 = VGroup(text5_1, text5_2)\n        text5.move_to(text2)\n        text6_1 = TextMobject('A los conjuntos que cumplen lo anterior se')\n        text6_2 = TextMobject('les denomina conjuntos ', 'CERRADOS').next_to(text6_1, DOWN)\n        text6_2[1].set_color(GREEN)\n        text6 = VGroup(text6_1, text6_2)\n        def1_1 = TextMobject('De manera m\u00e1s formal,')\n        def1_2 = TextMobject('un conjunto ', 'A', ' es ', 'cerrado', ' si:').next_to(def1_1, DOWN + 0.5 * DOWN)\n        def1_3 = TexMobject('Fr(A) \\\\subset A', color=ORANGE).next_to(def1_2, DOWN)\n        def1_2[1].set_color(ORANGE)\n        def1_2[3].set_color(GREEN)\n        def1 = VGroup(def1_1, def1_2, def1_3)\n        def1.move_to(UP)\n        cerrado = SVGMobject('cerrado.svg', color=WHITE, fill_color=BLUE_B)\n        cerrado.move_to(DOWN)\n        cerrado.scale(3)\n        cerrado1 = cerrado.copy()\n        cerrado1.set_stroke(RED)\n        cerrado2 = SVGMobject('cerrado.svg', color=WHITE, fill_color=BLUE_B)\n        cerrado2.move_to(DOWN)\n        cerrado2.scale(3)\n        punto1 = Dot(color=RED)\n        punto1.next_to(cerrado, LEFT, buff=-0.22)\n        circulo1 = Circle(color=RED, radius=0.5)\n        circulo1.move_to(punto1)\n        circulo1_1 = Circle(color=RED, radius=2)\n        circulo1_1.move_to(punto1)\n        punto2 = Dot(color=RED)\n        punto2.next_to(cerrado, UP + RIGHT, buff=-0.1)\n        circulo2 = Circle(color=RED, radius=1)\n        circulo2.move_to(punto2)\n        circulo2_1 = Circle(color=RED, radius=0.4)\n        circulo2_1.move_to(punto2)\n        titulo2 = TextMobject('Segunda Caracterizaci\u00f3n \\n\\n                            de Conjuntos Cerrados')\n        text7 = TextMobject('Tomemos el mismo conjunto')\n        text7.move_to(3 * UP)\n        text7_1 = TextMobject('B').scale(2)\n        text7_1.move_to(text7.get_center() + DOWN)\n        text7_1.set_color(BLUE_B)\n        text8_1 = TextMobject('Consideremos un punto que no est\u00e9 contenido')\n        text8_2 = TextMobject('en ', 'B', ', sino en su complemento,', ' B', '$^{\\\\text{c}}$').next_to(text8_1, DOWN)\n        text8_2[1].set_color(BLUE_C)\n        text8_2[3].set_color(BLUE_C)\n        text8_2[4].set_color(RED)\n        text8 = VGroup(text8_1, text8_2)\n        text8.move_to(text2)\n        text9_1 = TextMobject('Es entonces posible dibujar una bola que')\n        text9_2 = TextMobject('est\u00e9 completamente contenida en ', 'B', '$^{\\\\text{c}}$').next_to(text9_1, DOWN)\n        text9_2[1].set_color(BLUE_C)\n        text9_2[2].set_color(RED)\n        text9 = VGroup(text9_1, text9_2)\n        text9.move_to(text2)\n        text11_1 = TextMobject('Esto se cumple para todo punto en ', 'B', '$^{\\\\text{c}}$', ' y es')\n        text11_2 = TextMobject('equivalente a decir que ', 'B', '$^{\\\\text{c}}$', ' es un conjunto ', 'abierto').next_to(text11_1, DOWN)\n        text11_1[1].set_color(BLUE_C)\n        text11_1[2].set_color(RED)\n        text11_2[1].set_color(BLUE_C)\n        text11_2[2].set_color(RED)\n        text11_2[4].set_color(YELLOW)\n        text11 = VGroup(text11_1, text11_2)\n        text11.move_to(text2)\n        text12_1 = TextMobject('Entonces se dice que un conjunto ', 'B', ' es ', 'cerrado ', 'si')\n        text12_2 = TextMobject('B', '$^{\\\\text{c}}$', ' es un ', 'abierto').next_to(text12_1, DOWN)\n        text12_1[1].set_color(BLUE_C)\n        text12_1[3].set_color(GREEN)\n        text12_2[0].set_color(BLUE_C)\n        text12_2[1].set_color(RED)\n        text12_2[3].set_color(YELLOW)\n        text12 = VGroup(text12_1, text12_2)\n        pregunta_1 = TextMobject('\u00bfConsideras que los conjuntos se pueden')\n        pregunta_2 = TextMobject('clasificar \u00fanicamente como ', 'abiertos', ' y ', 'cerrados', '?').next_to(pregunta_1, DOWN)\n        pregunta_2[1].set_color(YELLOW)\n        pregunta_2[3].set_color(GREEN)\n        pregunta = VGroup(pregunta_1, pregunta_2)\n        cerrado3 = SVGMobject('cerrado.svg', color=WHITE, fill_color=BLUE_B)\n        cerrado3.move_to(DOWN)\n        cerrado3.scale(3)\n        punto3 = Dot(color=RED)\n        punto3.move_to(cerrado3.get_center() + LEFT + 2 * DOWN)\n        circulo3 = Circle(color=RED, radius=0.8)\n        circulo3.move_to(punto3)\n        punto4 = Dot(color=RED)\n        punto4.move_to(cerrado3.get_center() + 1.5 * RIGHT + 2 * UP)\n        circulo4 = Circle(color=RED, radius=0.24)\n        circulo4.move_to(punto4)\n        self.play(Write(titulo))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.play(Write(text1))\n        self.play(Write(text1_1))\n        self.play(SpinInFromNothing(cerrado))\n        self.wait()\n        self.play(FadeOut(text1_1), ReplacementTransform(text1, text2))\n        self.wait()\n        self.play(FadeIn(punto1))\n        self.wait(0.5)\n        self.play(FadeIn(circulo1))\n        self.wait()\n        self.play(ReplacementTransform(text2, text3))\n        self.play(ReplacementTransform(circulo1, circulo1_1))\n        self.wait()\n        self.play(FadeOut(circulo1_1), FadeOut(punto1))\n        self.play(ReplacementTransform(punto1, punto2), ReplacementTransform(circulo1_1, circulo2))\n        self.play(ReplacementTransform(circulo2, circulo2_1))\n        self.wait(1.5)\n        self.play(FadeOut(circulo2_1), FadeOut(punto2))\n        self.play(ReplacementTransform(cerrado, cerrado1))\n        self.play(ReplacementTransform(text3, text4))\n        self.wait()\n        self.play(ReplacementTransform(cerrado, cerrado1))\n        self.wait(3)\n        self.play(ReplacementTransform(text4, text5))\n        self.wait(3.5)\n        self.play(ReplacementTransform(cerrado1, cerrado2))\n        self.wait(1.5)\n        self.play(FadeOut(cerrado2))\n        self.wait()\n        self.play(Write(text6))\n        self.wait(2.5)\n        self.play(FadeOut(text5), FadeOut(text6))\n        self.wait(0.5)\n        self.play(Write(def1))\n        self.wait(8)\n        self.play(FadeOut(def1))\n        self.wait(0.5)\n        self.play(Write(titulo2))\n        self.play(FadeOut(titulo2))\n        self.play(Write(text7))\n        self.play(Write(text7_1))\n        self.play(DrawBorderThenFill(cerrado3))\n        self.wait()\n        self.play(FadeOut(text7_1), ReplacementTransform(text7, text8))\n        self.wait(2.5)\n        self.play(FadeIn(punto3))\n        self.wait()\n        self.play(ReplacementTransform(text8, text9))\n        self.wait(8)\n        self.play(FadeIn(circulo3))\n        self.wait(1.5)\n        self.play(ReplacementTransform(text9, text11))\n        self.wait(11)\n        self.play(ReplacementTransform(punto3, punto4), ReplacementTransform(circulo3, circulo4))\n        self.wait(2.5)\n        self.play(FadeOut(text11), FadeOut(cerrado3), FadeOut(punto4), FadeOut(circulo4))\n        self.play(Write(text12))\n        self.wait(11)\n        self.play(ReplacementTransform(text12, pregunta))\n        self.wait(5)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Explain the concept of a closure in topology by defining it, illustrating it with sets A and B, and presenting a property related to neighborhoods."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Cerradura(Scene):\n\n    def construct(self):\n        title = TextMobject('Cerradura')\n        defi = TextMobject('Definimos la', ' cerradura', ' de un conjunto', ' $A$', ' como ')\n        defi.set_color_by_tex_to_color_map({'cerradura': PURPLE, '$A$': YELLOW})\n        defi2 = TextMobject(' $\\\\bar{A}$', '=', '$cl(A)$', ':=', '$A$', '$\\\\cup$', '$Fr(A)$').next_to(defi, DOWN)\n        defi2.set_color_by_tex_to_color_map({'$\\\\bar{A}$': PURPLE, '$cl(A)$': PURPLE, '$A$': YELLOW, 'Fr(A)': RED})\n        conjuntoA = SVGMobject('Topologia_SVGs/cjtoA.svg', color=RED, fill_color=YELLOW, fill_opacity=1.2).scale(2)\n        nameA = TexMobject('A').next_to(conjuntoA, DOWN)\n        note = TextMobject('*Recuerda que el conjunto puede contener elementos de su frontera, es decir, \\n\\n                            el conjunto no es necesariamente igual a su interior.').scale(0.55).to_edge(DOWN)\n        group = VGroup(conjuntoA, defi, defi2, nameA, note)\n        group2 = VGroup(defi, defi2)\n        text1 = TextMobject('Veamos algunas propiedades sobre la', ' cerradura')\n        text1.set_color_by_tex_to_color_map({'cerradura': PURPLE})\n        text2 = TexMobject('cl(A\\\\cup B)', '=', 'cl(A)', '\\\\cup', 'cl(B)')\n        text2.set_color_by_tex_to_color_map({'cl(A)': YELLOW, 'cl(B)': BLUE})\n        conjuntoB = SVGMobject('Topologia_SVGs/cjtoB.svg', color=BLUE, fill_color=BLUE).shift(1.5 * RIGHT).scale(2)\n        conjuntoA1 = conjuntoA.copy()\n        conjuntoA1.set_color(YELLOW).shift(1.5 * LEFT)\n        A = TexMobject('A').next_to(conjuntoA1, DOWN)\n        B = TexMobject('B').next_to(conjuntoB, DOWN)\n        names = VGroup(A, B)\n        conjuntos = VGroup(conjuntoA1, conjuntoB)\n        conjuntoA2 = SVGMobject('Topologia_SVGs/cjtoA.svg', color=WHITE, fill_color=WHITE).shift(2.5 * LEFT).scale(2)\n        conjuntoB2 = SVGMobject('Topologia_SVGs/cjtoB.svg', color=WHITE, fill_color=WHITE).shift(2.5 * RIGHT).scale(2)\n        conjuntos2 = VGroup(conjuntoA2, conjuntoB2)\n        text3 = TextMobject('Intenta demostrar que:')\n        prop1 = TexMobject('x\\\\in cl(A) \\\\Leftrightarrow \\\\forall \\\\varepsilon>0,\\\\ B_{\\\\varepsilon}\\\\cap A\\\\neq\\\\emptyset').next_to(text3, DOWN)\n        self.play(Write(title.scale(1.5)))\n        self.wait()\n        self.play(FadeOut(title), run_time=0.5)\n        self.play(Write(defi))\n        self.play(Write(defi2))\n        self.wait(2)\n        self.play(ApplyMethod(group2.to_edge, UP))\n        self.play(DrawBorderThenFill(conjuntoA), rate_func=linear)\n        self.play(Write(nameA))\n        self.wait(1)\n        self.play(Write(note), run_time=6)\n        self.wait(1)\n        self.play(FadeOut(group))\n        self.play(Write(text1))\n        self.wait(2)\n        self.play(ReplacementTransform(text1, text2))\n        self.play(ApplyMethod(text2.to_edge, UP))\n        self.play(DrawBorderThenFill(conjuntos2), Write(names))\n        self.wait()\n        self.play(ReplacementTransform(conjuntos2, conjuntos))\n        self.wait(9)\n        self.play(FadeOut(conjuntos), FadeOut(text2), FadeOut(names))\n        self.play(Write(text3))\n        self.play(Write(prop1))\n        self.wait(14)\n        self.play(FadeOut(text3), FadeOut(prop1))"}]}
{"messages": [{"role": "user", "content": "Animate a visual explanation of topological connectedness and disconnectedness using text, mathematical formulas, and graphical representations of sets."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ConjuntosConexos(Scene):\n\n    def construct(self):\n        titulo = TextMobject('Disconexidad y Conexidad').scale(1.5)\n        intui = TextMobject('De forma intuitiva, un conjunto', ' disconexo', ' es aquel')\n        intui[1].set_color(GREEN_C)\n        tivo = TextMobject('compuesto por dos o m\u00e1s partes', ' separadas').next_to(intui, DOWN)\n        tivo[1].set_color(GREEN_C)\n        intuitivo = VGroup(intui, tivo)\n        tdisconexo_a = TextMobject('Formalmente, un conjunto es', ' disconexo', ' si y s\u00f3lo si')\n        tdisconexo_a[1].set_color(GREEN_C)\n        tdisconexo_b = TextMobject('satisface tres propiedades con respecto a otros conjuntos:').next_to(tdisconexo_a, DOWN)\n        tdisconexo = VGroup(tdisconexo_a, tdisconexo_b)\n        el_disconexo = TextMobject(' A', ' es un conjunto', ' disconexo', ' si y s\u00f3lo si ').to_edge(UP)\n        el_disconexo[0].set_color(GREEN_C)\n        el_disconexo[2].set_color(GREEN_C)\n        disconexo = SVGMobject('Topologia_SVGs/disconexo.svg', fill_color=GREEN_C, fill_opacity=1, stroke_opacity=0).shift(3 * LEFT)\n        disconexo_label = TextMobject('A').next_to(disconexo.get_center(), 5 * DOWN).set_color(GREEN_C)\n        gdisconexo = VGroup(disconexo, disconexo_label)\n        abiertos = TextMobject('Existen ', 'U', ' y', ' V', ' conjuntos abiertos tales que:').scale(0.9).shift(2 * UP + 3 * RIGHT)\n        abiertos[1].set_color(ORANGE)\n        abiertos[3].set_color(YELLOW)\n        cjtoU_set = Circle(radius=1.0, fill_opacity=0.6, stroke_opacity=0, stroke_width=0).shift(4.2 * LEFT).set_color(ORANGE)\n        cjtoU_label = TextMobject('U').next_to(cjtoU_set, UP).set_color(ORANGE)\n        cjtoU = VGroup(cjtoU_set, cjtoU_label)\n        cjtoV_set = Circle(radius=1.0, fill_opacity=0.6, stroke_opacity=0, stroke_width=0).shift(1.8 * LEFT).set_color(YELLOW)\n        cjtoV_label = TextMobject('V').next_to(cjtoV_set, UP).set_color(YELLOW)\n        cjtoV = VGroup(cjtoV_set, cjtoV_label)\n        cjtoU1_set = Circle(radius=1.5, fill_opacity=0.6, stroke_opacity=0, stroke_width=0).shift(4.2 * LEFT).set_color(ORANGE)\n        cjtoU1_label = TextMobject('U').next_to(cjtoU1_set, UP).set_color(ORANGE)\n        cjtoU1 = VGroup(cjtoU1_set, cjtoU1_label)\n        cjtoV1_set = Circle(radius=1.5, fill_opacity=0.6, stroke_opacity=0, stroke_width=0).shift(1.8 * LEFT).set_color(YELLOW)\n        cjtoV1_label = TextMobject('V').next_to(cjtoV1_set, UP).set_color(YELLOW)\n        cjtoV1 = VGroup(cjtoV1_set, cjtoV1_label)\n        inter = SVGMobject('Topologia_SVGs/inter.svg', stroke_opacity=0, fill_opacity=0.8).shift(3 * LEFT).scale(0.93)\n        inter_label = TexMobject(' U \\\\cap V').next_to(inter, 2 * UP)\n        intergroup = VGroup(inter, inter_label)\n        abiertos_labels = VGroup(cjtoU_label, cjtoV_label)\n        abiertos_labels1 = VGroup(cjtoU1_label, cjtoV1_label)\n        union_label = TexMobject(' U \\\\cup V').next_to(inter, 2.5 * UP).set_color(YELLOW_E)\n        prop_1 = TexMobject('1)\\\\ A \\\\subset U \\\\cup V').shift(1 * UP + 1.8 * RIGHT)\n        prop_1a = TexMobject('\\\\text{1)}', '\\\\ A ', '\\\\subset', '{U \\\\cup V}').shift(1 * UP + 1.8 * RIGHT)\n        prop_1a.set_color_by_tex_to_color_map({'A': GREEN_C, '{U \\\\cup V}': YELLOW_E})\n        prop_2 = TexMobject('2)\\\\ A \\\\cap U \\\\neq \\\\varnothing').shift(1.82 * RIGHT)\n        prop_2_2 = TexMobject('\\\\text{y}\\\\ A \\\\cap V \\\\neq \\\\varnothing').next_to(prop_2, RIGHT)\n        prop_3 = TexMobject('3) \\\\ U \\\\cap V = \\\\varnothing').shift(1 * DOWN + 1.82 * RIGHT)\n        caracts = VGroup(prop_1, prop_2, prop_3)\n        conex_a = TextMobject('Un conjunto es', ' conexo', '  si \\\\textbf{no} es', ' disconexo', ' es decir,')\n        conex_a[1].set_color(BLUE)\n        conex_a[3].set_color(GREEN_C)\n        conex_b = TextMobject('si cualesquiera dos conjuntos abiertos U y V no cumplen').next_to(conex_a, DOWN)\n        conex_c = TextMobject('alguna de las tres propiedades.').next_to(conex_b, DOWN)\n        conex = VGroup(conex_a, conex_b, conex_c)\n        ejs = TextMobject('Veamos algunos ejemplos:')\n        satisface = TextMobject('El conjunto satisface:').move_to(abiertos)\n        no_satisface1 = TextMobject('\\\\textbf{No} satisface la primera propiedad, pues:').shift(1 * DOWN + 3.2 * RIGHT).scale(0.75)\n        no_satisface2 = TextMobject('\\\\textbf{No} satisface la segunda propiedad, pues:').shift(1 * DOWN + 3.2 * RIGHT).scale(0.75)\n        no_satisface3 = TextMobject('\\\\textbf{No} satisface la tercera propiedad, pues:').shift(1 * DOWN + 3.2 * RIGHT).scale(0.75)\n        esconexo = TextMobject('Este conjunto es', ' conexo.').to_edge(DOWN)\n        esconexo[1].set_color(BLUE)\n        conexo1_svg = SVGMobject('Topologia_SVGs/conexo1.svg', stroke_opacity=0, fill_opacity=1, fill_color=BLUE).shift(3 * LEFT).scale(0.5)\n        conexo1_label = TextMobject('B').next_to(conexo1_svg, 4 * DOWN).set_color(BLUE)\n        conexo1 = VGroup(conexo1_svg, conexo1_label)\n        conexo1_p1 = TexMobject(' B \\\\subset U \\\\cup V').shift(1 * UP + 1.8 * RIGHT)\n        conexo1_p2 = TexMobject(' B \\\\cap U \\\\neq \\\\varnothing\\\\ \\\\text{y}\\\\ B \\\\cap V \\\\neq \\\\varnothing').shift(3.2 * RIGHT)\n        conexo1_p3 = TexMobject(' U \\\\cap V \\\\neq \\\\varnothing').next_to(no_satisface3, DOWN)\n        textc1 = VGroup(satisface, conexo1_p1, conexo1_p2, conexo1_p3, no_satisface3)\n        conexo2_svg = SVGMobject('Topologia_SVGs/conexo2.svg', stroke_opacity=0, fill_opacity=1, fill_color=BLUE).shift(4 * LEFT).scale(0.5)\n        conexo2_label = TextMobject('C').next_to(conexo2_svg, 5 * DOWN).set_color(BLUE)\n        conexo2 = VGroup(conexo2_svg, conexo2_label)\n        conexo2_p1 = TexMobject(' C \\\\subset U \\\\cup V').shift(1 * UP + 1.8 * RIGHT)\n        conexo2_p3 = TexMobject(' U \\\\cap V = \\\\varnothing').shift(2.2 * RIGHT)\n        conexo2_p2 = TexMobject('\\\\ C \\\\cap V = \\\\varnothing').next_to(no_satisface3, DOWN)\n        textc2 = VGroup(satisface, conexo2_p1, conexo2_p2, conexo2_p3, no_satisface2)\n        conexo3_svg = SVGMobject('Topologia_SVGs/conexo3.svg', stroke_opacity=0, fill_opacity=1, fill_color=BLUE).shift(3.05 * LEFT + 0.5 * UP).scale(1)\n        conexo3_label = TextMobject('D').next_to(conexo3_svg, 3 * UP).set_color(BLUE)\n        conexo3 = VGroup(conexo3_svg, conexo3_label)\n        inter_dlabel = TexMobject(' U \\\\cap V').next_to(inter, 2 * DOWN)\n        union_dlabel = TexMobject(' U \\\\cup V').next_to(inter, 2.5 * DOWN).set_color(YELLOW_E)\n        conexo3_p2 = TexMobject(' D \\\\cap U \\\\neq \\\\varnothing\\\\ \\\\text{y}\\\\ D \\\\cap V \\\\neq \\\\varnothing').shift(1 * UP + 3 * RIGHT)\n        conexo3_p3 = TexMobject(' U \\\\cap V = \\\\varnothing').shift(2.2 * RIGHT)\n        conexo3_p1 = TexMobject(' D \\\\not\\\\subset U \\\\cup V').next_to(no_satisface3, DOWN)\n        textc3 = VGroup(satisface, conexo3_p1, conexo3_p2, conexo3_p3, no_satisface1)\n        cfinal_a = TextMobject('\u00a1Si un conjunto es', ' conexo', ', ning\u00fan par de conjuntos abiertos')\n        cfinal_a[1].set_color(BLUE)\n        cfinal_b = TextMobject('podr\u00e1n satisfacer las tres propiedades mencionadas!').next_to(cfinal_a, DOWN)\n        cfinal = VGroup(cfinal_a, cfinal_b)\n        self.play(Write(titulo))\n        self.play(FadeOut(titulo))\n        self.play(Write(intuitivo))\n        self.wait(8)\n        self.play(FadeOut(intuitivo))\n        self.play(Write(tdisconexo))\n        self.wait(8)\n        self.play(FadeOut(tdisconexo))\n        self.play(Write(el_disconexo))\n        self.play(DrawBorderThenFill(disconexo), Write(disconexo_label))\n        self.wait()\n        self.play(Write(abiertos))\n        self.bring_to_back(cjtoU)\n        self.play(Write(cjtoU))\n        self.bring_to_back(cjtoV)\n        self.play(Write(cjtoV))\n        self.play(Write(prop_1), abiertos_labels.set_opacity, 0)\n        self.play(cjtoU_set.set_color, YELLOW_E, cjtoU_set.set_opacity, 0.6, cjtoV_set.set_color, YELLOW_E, cjtoV_set.set_opacity, 0.6, Write(union_label))\n        self.wait(1.5)\n        self.play(FadeOut(union_label), FadeOut(cjtoU_set), FadeOut(cjtoV_set))\n        self.wait()\n        self.play(Write(prop_2))\n        self.play(cjtoU_label.set_opacity, 0.9, cjtoU_set.set_color, ORANGE, cjtoU_set.set_opacity, 0.6)\n        self.wait()\n        self.play(FadeOut(cjtoU))\n        self.wait()\n        self.play(Write(prop_2_2))\n        self.play(cjtoV_label.set_opacity, 0.9, cjtoV_set.set_color, YELLOW, cjtoV_set.set_opacity, 0.6)\n        self.wait()\n        self.play(FadeOut(cjtoV))\n        self.wait(1.5)\n        self.play(Write(prop_3))\n        self.wait(1.5)\n        self.play(Write(cjtoU), Write(cjtoV))\n        self.wait(1.5)\n        self.play(FadeOut(cjtoU), FadeOut(cjtoV), FadeOut(gdisconexo), FadeOut(caracts), FadeOut(el_disconexo), FadeOut(abiertos), FadeOut(prop_2_2))\n        self.play(Write(conex_a))\n        self.wait()\n        self.play(Write(conex_b))\n        self.play(Write(conex_c))\n        self.wait()\n        self.play(FadeOut(conex))\n        self.play(Write(ejs))\n        self.wait()\n        self.play(FadeOut(ejs))\n        self.play(DrawBorderThenFill(conexo1))\n        self.wait()\n        self.play(Write(satisface))\n        self.bring_to_back(cjtoU1)\n        self.bring_to_back(cjtoV1)\n        self.play(Write(cjtoU1), Write(cjtoV1), abiertos_labels1.set_opacity, 1)\n        self.wait()\n        self.play(Write(conexo1_p1), abiertos_labels1.set_opacity, 0)\n        self.play(cjtoU1_set.set_color, YELLOW_E, cjtoU1_set.set_opacity, 0.6, cjtoV1_set.set_color, YELLOW_E, cjtoV1_set.set_opacity, 0.6, Write(union_label))\n        self.wait(1.5)\n        self.play(Write(conexo1_p2))\n        self.play(abiertos_labels1.set_opacity, 1, FadeOut(union_label))\n        self.play(cjtoU1_set.set_color, ORANGE, cjtoU1_set.set_opacity, 0.6, cjtoV1_set.set_color, YELLOW, cjtoV1_set.set_opacity, 0, cjtoV1_label.set_opacity, 0)\n        self.wait()\n        self.wait(1.5)\n        self.play(cjtoV1_set.set_opacity, 0.6)\n        self.wait(1.5)\n        self.play(cjtoU1_set.set_opacity, 0.6, cjtoV1_set.set_opacity, 0.6, cjtoV1_label.set_opacity, 1, cjtoU1_set.set_opacity, 0, cjtoU1_label.set_opacity, 0)\n        self.wait(1.5)\n        self.play(cjtoU1_set.set_opacity, 0.6, cjtoU1_label.set_opacity, 1)\n        self.play(Write(no_satisface3))\n        self.play(Write(conexo1_p3))\n        self.wait(2)\n        self.play(Write(esconexo))\n        self.wait(8)\n        self.play(FadeOut(textc1), FadeOut(conexo1), FadeOut(esconexo), FadeOut(abiertos_labels1), FadeOut(cjtoV1), FadeOut(cjtoU1))\n        self.play(DrawBorderThenFill(conexo2))\n        self.wait()\n        self.play(Write(satisface))\n        self.bring_to_back(cjtoU)\n        self.play(cjtoU_set.set_color, ORANGE, cjtoU_set.set_opacity, 0.6, cjtoV_set.set_opacity, 0.6, abiertos_labels.set_opacity, 1)\n        self.play(Write(conexo2_p1), abiertos_labels.set_opacity, 0)\n        self.play(cjtoU_set.set_color, YELLOW_E, cjtoU_set.set_opacity, 0.6, cjtoV_set.set_color, YELLOW_E, cjtoV_set.set_opacity, 0.6, Write(union_label))\n        self.wait(1.5)\n        self.play(Write(conexo2_p3))\n        self.play(FadeOut(union_label))\n        self.play(cjtoU_set.set_color, ORANGE, cjtoU_set.set_opacity, 0.6, cjtoU_label.set_opacity, 0.6, cjtoV_set.set_color, YELLOW, cjtoV_set.set_opacity, 0)\n        self.wait()\n        self.play(Write(no_satisface2))\n        self.play(Write(conexo2_p2))\n        self.play(Write(cjtoV_label))\n        self.play(cjtoV.set_opacity, 0.6)\n        self.wait()\n        self.play(Write(esconexo))\n        self.wait(1)\n        self.play(FadeOut(conexo2), FadeOut(textc2), FadeOut(esconexo), cjtoV.set_opacity, 0)\n        self.play(Write(conexo3))\n        self.wait()\n        self.play(cjtoU_set.set_color, ORANGE, cjtoU_set.set_opacity, 0.6, cjtoV_set.set_color, YELLOW, cjtoV_set.set_opacity, 0.6, cjtoU_label.set_opacity, 1, cjtoV_label.set_opacity, 1)\n        self.play(Write(satisface))\n        self.play(Write(conexo3_p2))\n        self.play(cjtoU.set_opacity, 0.6, cjtoV.set_opacity, 0)\n        self.wait(1.5)\n        self.play(cjtoU.set_opacity, 0, cjtoV.set_opacity, 0.6)\n        self.wait(1.5)\n        self.play(cjtoU_set.set_opacity, 0.6, cjtoV_set.set_opacity, 0.6, abiertos_labels.set_opacity, 1)\n        self.wait()\n        self.play(Write(conexo3_p3))\n        self.wait()\n        self.play(Write(no_satisface1))\n        self.bring_to_back(cjtoU)\n        self.bring_to_back(cjtoV)\n        self.play(cjtoU_set.set_opacity, 0.6, cjtoV_set.set_opacity, 0.6, abiertos_labels.set_opacity, 1)\n        self.play(Write(conexo3_p1))\n        self.play(cjtoU_set.set_color, YELLOW_E, cjtoU_set.set_opacity, 0.6, cjtoV_set.set_color, YELLOW_E, cjtoV_set.set_opacity, 0.6, abiertos_labels.set_opacity, 0, Write(union_dlabel))\n        self.wait(1.5)\n        self.play(Write(esconexo))\n        self.wait(5)\n        self.play(FadeOut(textc3), FadeOut(conexo3), FadeOut(esconexo), FadeOut(cjtoU), FadeOut(cjtoV), FadeOut(union_dlabel), cjtoV_set.set_opacity, 0, cjtoU_set.set_opacity, 0)\n        self.play(Write(cfinal))\n        self.wait(7)\n        self.play(FadeOut(cfinal))"}]}
{"messages": [{"role": "user", "content": "Present a textual explanation of the definition of compact sets in $\\mathbb{R}^n$ and illustrate the two main properties (open cover and closed/bounded) with visual aids and mathematical notation."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Compactos(Scene):\n\n    def construct(self):\n        titulo = TextMobject('Conjuntos Compactos').scale(1.5)\n        t_1 = TextMobject('Sean ', '$K$', '$\\\\subset \\\\mathbb{R}^n$').move_to(3 * UP)\n        t_1[1].set_color(PURPLE)\n        t_2 = TextMobject('y $\\\\mathcal{U} = \\\\{U_{\\\\alpha} \\\\subset \\\\mathbb{R}^n | \\\\alpha \\\\in I\\\\}$ una cubierta abierta de ', '$K$', '.').move_to(3 * UP)\n        t_2[1].set_color(PURPLE)\n        t_3 = TextMobject('Decimos que ', '$K$', ' es ', 'compacto', ' si toda cubierta abierta $\\\\mathcal{U}$  de ', '$K$', ',').move_to(3 * UP)\n        t_3[1].set_color(PURPLE)\n        t_3[3].set_color(ORANGE)\n        t_3[5].set_color(PURPLE)\n        t_4 = TextMobject('tiene una subcubierta finita, es decir,').move_to(3 * UP)\n        t_5 = TextMobject('si existen $\\\\alpha_1, ... , \\\\alpha_n \\\\in I$ tales que ').move_to(3 * UP)\n        t_6 = TextMobject('$K$', ' $\\\\subset U_{\\\\alpha_1} \\\\cup ... \\\\cup U_{\\\\alpha_n}$').move_to(3 * UP)\n        t_6[0].set_color(PURPLE)\n        t_7 = TextMobject('Se puede demostrar que un conjunto ', 'compacto', ' es cerrado').move_to(3 * UP)\n        t_7[1].set_color(ORANGE)\n        t_8 = TextMobject('Veamos esto gr\u00e1ficamente').move_to(3 * UP)\n        t_9 = TextMobject('Consideremos ', '$K$', ' compacto', ' y $x \\\\in $', '$K$', '$^{c}$').move_to(3 * UP)\n        t_9[1].set_color(PURPLE)\n        t_9[2].set_color(ORANGE)\n        t_9[4].set_color(PURPLE)\n        t_9_2 = TextMobject('Sea $\\\\mathcal{V}:=\\\\{ B_{r_k}(k)|k\\\\in K \\\\}$ con $r:=\\\\dfrac{1}{2}d(k,x)$').move_to(3 * UP)\n        t_9_3 = TextMobject('una cubierta abierta de ', 'K').next_to(t_9_2, DOWN)\n        t_9_3[1].set_color(PURPLE)\n        t_9_1 = VGroup(t_9_2, t_9_3)\n        t_10 = TextMobject('Tomemos una subcubierta finita de $N$ bolas abiertas').move_to(3 * UP)\n        t_11 = TextMobject('$\\\\mathcal{U} = \\\\{B_{r_i}(k_i) | k_i \\\\in K\\\\}$ \\n \\n        con $r_i := \\\\frac{1}{2}d(k_i,x)$\\n\\n        y $i \\\\in\\\\{1,..,N\\\\}$').move_to(4.6 * LEFT)\n        t_12 = TextMobject('Tomamos ', '$r_{min}$', '$ = \\\\text{min}\\\\{r_i| i \\\\in\\\\{1,..,N\\\\}\\\\}$').move_to(3 * UP)\n        t_12[1].set_color(TEAL)\n        t_13 = TextMobject('En el ejemplo, ', '$r_{min}$', '$=r_4$').move_to(3 * UP)\n        t_13[1].set_color(TEAL)\n        t_14 = TextMobject('Notamos que $B$', '$_{r_{min}}$', '$(x) \\\\cap B_{r_i}(k_i) = \\\\emptyset$, $\\\\forall i \\\\in \\\\{1,...,N\\\\}$').move_to(3 * UP)\n        t_14[1].set_color(TEAL)\n        t_15 = TextMobject('En otras palabras, $\\\\forall x \\\\in $', '$K$', '$^{c}$ existe una bola centrada en $x$').move_to(3 * UP)\n        t_15[1].set_color(PURPLE)\n        t_16 = TextMobject('que est\u00e1 contenida en ', '$K$', '$^{c}$').move_to(3 * UP)\n        t_16[1].set_color(PURPLE)\n        t_17 = TextMobject('Por lo tanto, ', '$K$', '$^{c}$ es abierto y ', '$K$', ' es cerrado.').move_to(3 * UP)\n        t_17[1].set_color(PURPLE)\n        t_17[3].set_color(PURPLE)\n        t_18 = TextMobject('Ahora, fijamos $x_0 \\\\in$', '$K$').move_to(3 * UP)\n        t_18[1].set_color(PURPLE)\n        t_18_1 = TextMobject('Sea $\\\\mathcal{V}:=\\\\{B_m(x_0)|m\\\\in\\\\mathbb{N}\\\\}$ una cubierta abierta de ', 'K').move_to(3 * UP)\n        t_18_1[1].set_color(PURPLE)\n        t_19 = TextMobject('Tomamos una subcubierta finita de N bolas centradas en $x_0$').move_to(3 * UP)\n        t_20 = TextMobject('$\\\\mathcal{U} := \\\\{B_{m_i}(x_0) | i\\\\in \\\\{1,...,N\\\\}\\\\}$').move_to(4.2 * LEFT + 1.5 * UP).scale(0.8)\n        t_21 = TextMobject('Consideramos ', '$r_{max}$', '$ = \\\\text{max}\\\\{ m_i | i \\\\in\\\\{1,..,N\\\\}\\\\}$').move_to(3 * UP)\n        t_21[1].set_color(TEAL)\n        t_21_1 = TextMobject('En el ejemplo, ', '$r_{max}$', '$=m_4$').move_to(3 * UP)\n        t_21_1[1].set_color(TEAL)\n        t_23 = TextMobject('Notamos que ', '$K$', '$ \\\\subset B$', '$_{r_{max}}$', '$(x_0)$').move_to(3 * UP)\n        t_23[1].set_color(PURPLE)\n        t_23[3].set_color(TEAL)\n        t_24 = TextMobject('y por lo tanto, ', '$K$', ' es acotado').move_to(3 * UP)\n        t_24[1].set_color(PURPLE)\n        t_25 = TextMobject('En general que un conjunto sea cerrado y acotado').move_to(1 * UP)\n        t_26 = TextMobject('no implica que sea ', 'compacto', ', pero en $\\\\mathbb{R}^n$ \\\\textbf{s\u00ed}, ').next_to(t_25, DOWN)\n        t_26[1].set_color(ORANGE)\n        t_27 = TextMobject('\u00bfpuedes probarlo?').next_to(t_26, DOWN)\n        x = TextMobject('$x$').move_to(3 * RIGHT + 0.2 * UP)\n        dot = Dot((0, 0, 0), color=WHITE, radius=0.05).move_to(3 * RIGHT)\n        centro_1 = Dot((0, 0, 0), color=WHITE, radius=0.05).move_to(2 * DOWN + LEFT)\n        bola_1 = Circle(radius=np.linalg.norm(2 * DOWN + LEFT - 3 * RIGHT) / 2, fill_color=RED, color=RED, fill_opacity=0.3).move_to(2 * DOWN + LEFT).set_stroke(RED, 0.3)\n        centro_2 = Dot((0, 0, 0), color=WHITE, radius=0.05).move_to(0.6 * UP + 0.4 * LEFT)\n        bola_2 = Circle(radius=np.linalg.norm(0.6 * UP + 0.4 * LEFT - 3 * RIGHT) / 2, fill_color=GREEN, color=GREEN, fill_opacity=0.3).move_to(0.6 * UP + 0.4 * LEFT).set_stroke(GREEN, 0.3)\n        centro_3 = Dot((0, 0, 0), color=WHITE, radius=0.05).move_to(1.2 * RIGHT + 1.4 * DOWN)\n        bola_3 = Circle(radius=np.linalg.norm(1.2 * RIGHT + 1.4 * DOWN - 3 * RIGHT) / 2, fill_color=YELLOW, color=YELLOW, fill_opacity=0.3).move_to(1.2 * RIGHT + 1.4 * DOWN).set_stroke(YELLOW, 0.3)\n        centro_4 = Dot((0, 0, 0), color=WHITE, radius=0.05).move_to(1.5 * RIGHT + 0.08 * UP)\n        bola_4 = Circle(radius=np.linalg.norm(1.5 * RIGHT + 0.08 * UP - 3 * RIGHT) / 2, fill_color=TEAL, color=TEAL, fill_opacity=0.3).move_to(1.5 * RIGHT + 0.08 * UP).set_stroke(TEAL, 0.3)\n        bola_5 = Circle(radius=np.linalg.norm(1.5 * RIGHT + 0.08 * UP - 3 * RIGHT) / 2, fill_color=WHITE, color=WHITE, fill_opacity=0.3).move_to(3 * RIGHT).set_stroke(WHITE, 0.3)\n        line = Line(np.array([1.5 / 2, 0.08 / 2, 0]), np.array([3 / 2, 0, 0])).move_to((7.5 / 4, 0.24 / 4, 0)).set_color(TEAL)\n        brace = Brace(line, 0.2 * UP)\n        r = TextMobject('$r_{min}$').next_to(brace, 0.5 * UP).set_color(TEAL)\n        dot_2 = Dot((0, 0, 0), color=WHITE, radius=0.05).move_to(0.5 * RIGHT + 0.5 * DOWN)\n        x_0 = TextMobject('$x_0$').next_to(dot_2, 0.25 * DOWN + 0.02 * RIGHT).scale(0.8)\n        Conjunto_Cubierto = SVGMobject('Topologia_SVGs/ConjuntoCompacto.svg').scale(3)\n        K = Conjunto_Cubierto[0].set_color(PURPLE).next_to(t_1, 7 * DOWN)\n        cover = Conjunto_Cubierto[1:16].next_to(t_2, DOWN)\n        index = VGroup()\n        colors = it.cycle([PINK, GREEN, YELLOW, RED, TEAL, GREEN_SCREEN, ORANGE, WHITE, BLUE, GOLD, MAROON, DARK_BROWN, BLUE_A, YELLOW_B, RED_B])\n        for i in range(len(cover)):\n            text = TextMobject('$U_{%d}$' % i)\n            color = next(colors)\n            cover[i].set_fill(color, opacity=0.2).set_stroke(color, 0.3)\n            text.move_to(cover[i])\n            index.add(text)\n        centros = VGroup(centro_1, centro_2, centro_3, centro_4)\n        index_2 = VGroup()\n        for i in range(len(centros)):\n            text = TextMobject('$k_{%d}$' % (i + 1))\n            text.next_to(centros[i], 0.2 * LEFT)\n            index_2.add(text)\n        k_1 = Dot((0, 0, 0), color=WHITE, radius=0.05).next_to(dot_2, 3.65 * UP)\n        k_2 = Dot((0, 0, 0), color=WHITE, radius=0.05).next_to(dot_2, 5.2 * RIGHT)\n        k_3 = Dot((0, 0, 0), color=WHITE, radius=0.05).next_to(dot_2, 5.2 * (UP + LEFT))\n        k_4 = Dot((0, 0, 0), color=WHITE, radius=0.05).next_to(dot_2, 7.35 * (DOWN + LEFT))\n        line_k_1 = Line((0.5, -0.5, 0), k_1.get_center()).set_color(GREEN)\n        line_k_2 = Line((0.5, -0.5, 0), k_2.get_center()).set_color(YELLOW)\n        line_k_3 = Line((0.5, -0.5, 0), k_3.get_center()).set_color(RED)\n        line_k_4 = Line((0.5, -0.5, 0), k_4.get_center()).set_color(TEAL)\n        tag_1 = TextMobject('$m_1$').move_to(line_k_1.get_center() + 0.3 * RIGHT).scale(0.8)\n        tag_2 = TextMobject('$m_2$').move_to(line_k_2.get_center() + 0.3 * DOWN).scale(0.8)\n        tag_3 = TextMobject('$m_3$').move_to(line_k_3.get_center() + 0.3 * LEFT + 0.3 * DOWN).scale(0.8)\n        tag_4 = TextMobject('$m_4$').move_to(line_k_4.get_center() + 0.3 * RIGHT + 0.3 * DOWN).scale(0.8)\n        tags = VGroup(tag_1, tag_2, tag_3, tag_4)\n        lineas = VGroup(line_k_1, line_k_2, line_k_3, line_k_4)\n        ks = VGroup(k_1, k_2, k_3, k_4)\n        U_2 = VGroup()\n        index_3 = VGroup()\n        colors_2 = it.cycle([GREEN, YELLOW, RED, TEAL, GREEN_SCREEN, ORANGE, WHITE, BLUE, GOLD, MAROON, DARK_BROWN, BLUE_A, YELLOW_B, RED_B])\n        for i in range(4):\n            text = TextMobject('$%d$' % (i + 1)).scale(0.7)\n            text.move_to(tags[i].get_center())\n            color = next(colors_2)\n            bola = Circle(radius=1.4 ** i, fill_color=color, color=color, fill_opacity=0.3).move_to(dot_2).set_stroke(color, 0.3)\n            index_3.add(text)\n            U_2.add(bola)\n        r_max_2 = TextMobject('$r_{max}$').move_to(tag_4.get_center() + 0.4 * UP + 0.5 * RIGHT).set_color(TEAL)\n        Group_1 = VGroup(t_1, K)\n        Group_2 = VGroup(cover[0], cover[8:])\n        Group_3 = VGroup(x, dot)\n        Group_4 = VGroup(bola_1, centro_1, bola_2, centro_2, bola_3, centro_3, bola_4, centro_4)\n        Group_5 = VGroup(line, brace, r)\n        Group_6 = VGroup(dot_2, x_0)\n        self.play(Write(titulo))\n        self.wait(2.75)\n        self.play(ReplacementTransform(titulo, Group_1))\n        self.wait(3.875)\n        self.play(ReplacementTransform(t_1, t_2), DrawBorderThenFill(cover))\n        self.wait(8.75)\n        self.play(ReplacementTransform(t_2, t_3))\n        self.wait(6.5)\n        self.play(ReplacementTransform(t_3, t_4), FadeOut(Group_2))\n        self.wait(4.25)\n        self.play(ReplacementTransform(t_4, t_5))\n        self.wait(6.125)\n        self.play(ReplacementTransform(t_5, t_6), Write(index[1:8]))\n        self.wait(7.25)\n        self.play(ReplacementTransform(t_6, t_7), FadeOut(cover[1:8]), FadeOut(index[1:8]))\n        self.wait(5.375)\n        self.play(ReplacementTransform(t_7, t_8))\n        self.wait(3.125)\n        self.play(ReplacementTransform(t_8, t_9), FadeIn(Group_3))\n        self.wait(5.75)\n        self.play(ReplacementTransform(t_9, t_9_1))\n        self.wait(13.626)\n        self.play(ReplacementTransform(t_9_1, t_10), FadeIn(Group_4))\n        self.wait(5)\n        self.play(Write(t_11), FadeIn(index_2))\n        self.wait(5)\n        self.play(ReplacementTransform(t_10, t_12))\n        self.wait(6.125)\n        self.play(ReplacementTransform(t_12, t_13))\n        self.play(ReplacementTransform(t_11, Group_5))\n        self.wait(4.25)\n        self.play(ReplacementTransform(t_13, t_14), DrawBorderThenFill(bola_5), FadeOut(brace), FadeOut(r), ApplyMethod(line.shift, 3 / 4 * RIGHT + 0.16 / 4 * DOWN))\n        self.wait(11.375)\n        self.play(ReplacementTransform(t_14, t_15))\n        self.wait(8.75)\n        self.play(ReplacementTransform(t_15, t_16))\n        self.wait(4.25)\n        self.play(ReplacementTransform(t_16, t_17))\n        self.wait(6.125)\n        self.play(FadeOut(line), FadeOut(Group_4), FadeOut(Group_3), FadeOut(bola_5), FadeOut(index_2))\n        self.play(ReplacementTransform(t_17, t_18), FadeIn(Group_6))\n        self.wait(3.875)\n        self.play(ReplacementTransform(t_18, t_18_1))\n        self.wait(9.5)\n        self.play(ReplacementTransform(t_18_1, t_19))\n        self.play(Write(t_20), ShowIncreasingSubsets(U_2, run_time=5.0), ShowIncreasingSubsets(tags, run_time=5.0), ShowIncreasingSubsets(ks, run_time=5.0), ShowIncreasingSubsets(lineas, runt_time=5.0))\n        self.wait(5.75)\n        self.play(ReplacementTransform(t_19, t_21))\n        self.wait(5)\n        self.play(ReplacementTransform(t_21, t_21_1))\n        self.play(FadeOut(tags[:3]))\n        self.wait(6.125)\n        self.play(ReplacementTransform(t_21_1, t_23))\n        self.wait(5)\n        self.play(FadeOut(U_2[:3]), FadeOut(lineas[:3]), FadeOut(ks[:3]), ReplacementTransform(tags[3], r_max_2))\n        self.wait(4.25)\n        self.play(ReplacementTransform(t_23, t_24))\n        self.wait(5)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.play(Write(t_25))\n        self.play(Write(t_26))\n        self.play(Write(t_27))\n        self.wait(7)\n        self.play(FadeOut(t_25), FadeOut(t_26), FadeOut(t_27))"}]}
{"messages": [{"role": "user", "content": "Visualize the definitions of convex and non-convex sets using SVG shapes and line segments connecting points."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ConjuntosConvexos(Scene):\n\n    def construct(self):\n        titulo = TextMobject('Conjuntos Convexos').scale(1.5)\n        pregunta = TextMobject('\u00bfCu\u00e1l es la diferencia entre estos dos conjuntos?').to_edge(UP)\n        lao_svg = SVGMobject('Topologia_SVGs/convexo.svg').set_height(FRAME_HEIGHT * 0.4).shift(3 * LEFT)\n        lao_svg.set_style(fill_opacity=0.7, stroke_width=0, stroke_opacity=1, fill_color=BLUE)\n        lao_label = TextMobject('A').next_to(lao_svg, DOWN)\n        lao = VGroup(lao_svg, lao_label)\n        lau_svg = SVGMobject('Topologia_SVGs/no_convexo.svg').set_height(FRAME_HEIGHT * 0.4).shift(3 * RIGHT)\n        lau_svg.set_style(fill_opacity=0.5, stroke_width=0, stroke_opacity=1, fill_color=YELLOW)\n        lau_label = TextMobject('B').next_to(lau_svg, DOWN)\n        lau = VGroup(lau_svg, lau_label)\n        casual_1 = TextMobject('De manera informal, podr\u00edamos decir que el').to_edge(UP)\n        casual_2 = TextMobject('conjunto B tiene una hendidura. ').next_to(casual_1, DOWN)\n        casual = VGroup(casual_1, casual_2)\n        formal = TextMobject('Formalicemos lo anterior.').to_edge(DOWN).scale(1.1)\n        equis_dot = Dot(point=(-3, 1, 0))\n        equis_label = TexMobject('\\\\vec{x}').next_to(equis_dot, UP + LEFT)\n        equis = VGroup(equis_dot, equis_label)\n        ye_dot = Dot(point=(3, -1, 0))\n        ye_label = TexMobject('\\\\vec{y}').next_to(ye_dot, DOWN + RIGHT)\n        ye = VGroup(ye_dot, ye_label)\n        segmento_a = TextMobject('Dados dos puntos en $\\\\mathbb{R}^n$,').to_edge(UP)\n        segmento_aa = TextMobject('definimos el segmento que los une como:').next_to(segmento_a, DOWN)\n        segmento_b = TexMobject('[\\\\vec{x},\\\\vec{y}]=\\\\{ (1-t)\\\\vec{x}+t\\\\vec{y}\\\\in \\\\mathbb{R}^n | t\\\\in [0,1]\\\\}')\n        segmento_c = TextMobject('Visualizando lo anterior en $\\\\mathbb{R}^2$, tenemos:').to_edge(UP)\n        segmento = Line(start=(-3, 1, 0), end=(3, -1, 0))\n        segmento_d = TexMobject('[\\\\vec{x},\\\\vec{y}]=\\\\{ (1-t)\\\\vec{x}+t\\\\vec{y}\\\\in \\\\mathbb{R}^2 | t\\\\in [0,1]\\\\}').to_edge(DOWN)\n        lao_svg_1 = SVGMobject('Topologia_SVGs/convexo.svg').set_height(FRAME_HEIGHT * 0.4)\n        lao_svg_1.set_style(fill_opacity=0.7, stroke_width=0, stroke_opacity=1, fill_color=BLUE)\n        Acomment = TextMobject('Para cualesquiera dos puntos $\\\\vec{x},\\\\vec{y} \\\\in$ A,  tenemos que $[\\\\vec{x},\\\\vec{y}]\\\\subset$ A').to_edge(UP).scale(0.9)\n        par_A1 = VGroup(Dot(point=(1, 1, 0)), Dot(point=(-1, -1, 0)), Line(start=(1, 1, 0), end=(-1, -1, 0)))\n        par_A2 = VGroup(Dot(point=(0, 1, 0)), Dot(point=(0, -1, 0)), Line(start=(0, 1, 0), end=(0, -1, 0)))\n        par_A3 = VGroup(Dot(point=(-0.7, 1.1, 0)), Dot(point=(0.5, -1.1, 0)), Line(start=(-0.7, 1.1, 0), end=(0.5, -1.1, 0)))\n        convexo = TextMobject('A esto se le conoce como un', ' conjunto convexo.').to_edge(DOWN).scale(0.9)\n        convexo[1].set_color(BLUE)\n        lau_svg_1 = SVGMobject('Topologia_SVGs/no_convexo.svg').set_height(FRAME_HEIGHT * 0.4)\n        lau_svg_1.set_style(fill_opacity=0.5, stroke_width=0, stroke_opacity=1, fill_color=YELLOW)\n        Bcomment_a = TextMobject('Esto no sucede para el conjunto B, pues').to_edge(UP)\n        Bcomment_b = TextMobject('existen $\\\\vec{x},\\\\vec{y}\\\\subset$ B tales que $[\\\\vec{x},\\\\vec{y}]\\\\not\\\\subseteq$ B').next_to(Bcomment_a, DOWN)\n        Bcomment = VGroup(Bcomment_a, Bcomment_b).scale(0.9)\n        par_B1 = VGroup(Dot(point=(-0.5, 1, 0)), Dot(point=(-0.5, -1, 0)), Line(start=(-0.5, 1, 0), end=(-0.5, -1, 0)))\n        par_B2 = VGroup(Dot(point=(-0.2, -1, 0)), Dot(point=(0.7, -1, 0)), Line(start=(-0.2, -1, 0), end=(0.7, -1, 0)))\n        par_B3 = VGroup(Dot(point=(-0.8, 1, 0)), Dot(point=(0.8, 1, 0)), Line(start=(-0.8, 1, 0), end=(0.8, 1, 0))).set_color(RED)\n        no_convexo = TextMobject('Este conjunto es', ' no convexo.').to_edge(DOWN).scale(0.9)\n        no_convexo[1].set_color(YELLOW)\n        entonces = TextMobject('Entonces, de manera formal:').to_edge(UP)\n        lao_conv = TextMobject('Convexo').next_to(lao_label, 2 * DOWN).set_color(BLUE)\n        lau_nconv = TextMobject('No convexo').next_to(lau_label, 2 * DOWN).set_color(YELLOW)\n        pregunta1 = TextMobject('Ahora es tu turno: ')\n        pregunta2 = TextMobject('Si un conjunto es convexo, \u00bftambi\u00e9n es conexo?').next_to(pregunta1, DOWN)\n        self.play(Write(titulo))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.play(Write(pregunta, run_time=2))\n        self.wait()\n        self.play(Write(lao), Write(lau))\n        self.wait()\n        self.play(FadeOut(pregunta))\n        self.play(Write(casual, run_time=5))\n        self.wait(2)\n        self.play(Write(formal))\n        self.wait(1)\n        self.play(FadeOut(casual), FadeOut(formal), FadeOut(lao), FadeOut(lau))\n        self.play(Write(segmento_a))\n        self.play(Write(segmento_aa, run_time=2))\n        self.wait()\n        self.play(Write(segmento_b, run_time=3))\n        self.wait(3)\n        self.play(FadeOut(segmento_aa))\n        self.play(ReplacementTransform(segmento_a, segmento_c))\n        self.play(ReplacementTransform(segmento_b, segmento_d))\n        self.play(Write(equis), Write(ye))\n        self.play(Write(segmento))\n        self.wait(3)\n        self.play(FadeOut(equis), FadeOut(ye), FadeOut(segmento), FadeOut(segmento_c), FadeOut(segmento_d))\n        self.play(Write(lao_svg_1))\n        self.play(Write(Acomment, run_time=3))\n        self.bring_to_back(lao_svg_1)\n        self.play(ShowCreation(par_A1))\n        self.wait(1.2)\n        self.play(ReplacementTransform(par_A1, par_A2))\n        self.wait(1.2)\n        self.play(ReplacementTransform(par_A2, par_A3))\n        self.wait(1.2)\n        self.play(Write(convexo))\n        self.wait()\n        self.play(FadeOut(Acomment), FadeOut(convexo), FadeOut(lao_svg_1), FadeOut(par_A3))\n        self.play(Write(lau_svg_1))\n        self.play(Write(Bcomment, run_time=3))\n        self.bring_to_back(lau_svg_1)\n        self.wait()\n        self.play(ShowCreation(par_B1))\n        self.wait(1.2)\n        self.play(ReplacementTransform(par_B1, par_B2))\n        self.wait(1.2)\n        self.play(ReplacementTransform(par_B2, par_B3))\n        self.play(par_B3.scale, 1.4)\n        self.play(par_B3.scale, 1 / 1.4)\n        self.wait()\n        self.play(Write(no_convexo))\n        self.wait()\n        self.play(FadeOut(Bcomment), FadeOut(no_convexo), FadeOut(lau_svg_1), FadeOut(par_B3))\n        self.play(Write(entonces))\n        self.play(Write(lao), Write(lau))\n        self.play(Write(lao_conv))\n        self.play(Write(lau_nconv))\n        self.wait(2)\n        self.play(FadeOut(entonces), FadeOut(lao), FadeOut(lau), FadeOut(lao_conv), FadeOut(lau_nconv))\n        self.wait()\n        self.play(Write(pregunta1))\n        self.play(Write(pregunta2))\n        self.wait(6)\n        self.play(FadeOut(pregunta1), FadeOut(pregunta2))"}]}
{"messages": [{"role": "user", "content": "Present the Lebesgue number lemma by displaying a title, then illustrating a set with a covering, a neighborhood of radius epsilon, and multiple points with their respective surrounding balls."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass NumLebesgue(Scene):\n\n    def construct(self):\n        grid = NumberPlane()\n        titulo = TextMobject(\"Lema del N\\\\'{u}mero de Lebesgue\")\n        titulo.scale(1.2)\n        t_1 = TextMobject('Sea $X \\\\subset \\\\mathbb{R}^{n}$ compacto').move_to(3 * UP)\n        t_2 = TextMobject('y $\\\\mathcal{F}$ una cubierta abierta de $X$').move_to(3 * UP)\n        t_3 = TextMobject('$\\\\implies \\\\exists$ $\\\\epsilon > 0$').move_to(3 * UP)\n        t_4 = TextMobject('tal que $\\\\forall$ $x \\\\in X$').move_to(3 * UP)\n        t_5 = TextMobject('$\\\\exists$ $U \\\\in \\\\mathcal{F}$').move_to(3 * UP)\n        t_6 = TextMobject('tal que $B(x, \\\\epsilon) \\\\subseteq U$').move_to(3 * UP)\n        t_7 = TextMobject(' \\\\textquestiondown Puedes probarlo formalmente?')\n        Conjunto_Cubierto = SVGMobject('Topologia_SVGs/Lebesgue.svg').scale(2)\n        X = Conjunto_Cubierto[0].set_color(GREEN).next_to(t_1, 5 * DOWN)\n        cover = Conjunto_Cubierto[1:7].next_to(t_2, 2 * DOWN)\n        colors = it.cycle([YELLOW, RED, PURPLE, PINK, BLUE, TEAL, WHITE])\n        for i in range(len(cover)):\n            color = next(colors)\n            cover[i].set_fill(color, opacity=0.4).set_stroke(color, 0.5)\n        line = Line(np.array([1, 0, 0]), np.array([1.27, 0, 0])).move_to((1, -0.8, 0))\n        brace = Brace(line, UP)\n        epsilon = TextMobject('$\\\\epsilon$').next_to(brace, UP)\n        dot = Dot((0, 0, 0), color=WHITE, radius=0.05).move_to(line, LEFT)\n        x = TextMobject('$x_1$').next_to(dot, LEFT)\n        U1 = TextMobject('$U_1$').next_to(cover[5], RIGHT)\n        U3 = TextMobject('$U_2$').next_to(cover[1], LEFT)\n        U4 = TextMobject('$U_3$').next_to(cover[0], LEFT)\n        U5 = TextMobject('$U_4$').next_to(cover[4], RIGHT)\n        circle = Circle(radius=0.2, fill_color=RED, color=RED, fill_opacity=0.8).move_to(dot)\n        line3 = Line(np.array([1, 0, 0]), np.array([1.27, 0, 0])).move_to((-0.85, -0.75, 0))\n        dot3 = Dot((0, 0, 0), color=WHITE, radius=0.05).move_to(line3, LEFT)\n        x3 = TextMobject('$x_2$').next_to(dot3, LEFT)\n        circle3 = Circle(radius=0.2, fill_color=RED, color=RED, fill_opacity=0.8).move_to(dot3)\n        line4 = Line(np.array([1, 0, 0]), np.array([1.27, 0, 0])).move_to((-1.7, 1, 0))\n        dot4 = Dot((0, 0, 0), color=WHITE, radius=0.05).move_to(line4, LEFT)\n        x4 = TextMobject('$x_3$').next_to(dot4, DOWN)\n        circle4 = Circle(radius=0.2, fill_color=RED, color=RED, fill_opacity=0.8).move_to(dot4)\n        line5 = Line(np.array([1, 0, 0]), np.array([1.27, 0, 0])).move_to((-0.55, 1.2, 0))\n        dot5 = Dot((0, 0, 0), color=WHITE, radius=0.05).move_to(line5, LEFT)\n        x5 = TextMobject('$x_4$').next_to(dot5, UP)\n        circle5 = Circle(radius=0.2, fill_color=RED, color=RED, fill_opacity=0.8).move_to(dot5)\n        Group_1 = VGroup(t_1, X)\n        Group_2 = VGroup(line, brace, epsilon)\n        Group_3 = VGroup(dot, dot3, dot4, dot5, x, x3, x4, x5)\n        Group_4 = VGroup(line, brace, epsilon, dot, dot3, dot4, dot5, x, x3, x4, x5)\n        Group_5 = VGroup(line, line3, line4, line5, brace, epsilon, dot, dot3, dot4, dot5, x, x3, x4, x5, cover, X, t_6, circle, circle3, circle4, circle5, U1, U3, U4, U5)\n        Group_6 = VGroup(x, x3, x4, x5)\n        Group_7 = VGroup(line3, line4, line5)\n        self.play(Write(titulo))\n        self.wait(2)\n        self.play(ReplacementTransform(titulo, Group_1))\n        self.wait(4)\n        self.play(ReplacementTransform(t_1, t_2))\n        self.play(FadeIn(cover))\n        self.wait(2)\n        self.play(ReplacementTransform(t_2, t_3))\n        self.play(FadeIn(Group_2))\n        self.play(FadeOut(brace))\n        self.play(FadeOut(epsilon))\n        self.add(Group_3)\n        self.play(ReplacementTransform(t_3, t_4))\n        self.play(FadeIn(Group_7))\n        self.wait(2.2)\n        self.play(FadeOut(Group_6))\n        self.play(ReplacementTransform(t_4, t_5))\n        self.play(DrawBorderThenFill(cover[5].set_stroke(WHITE, 1)))\n        self.add(U1)\n        self.play(DrawBorderThenFill(cover[1].set_stroke(WHITE, 1)))\n        self.add(U3)\n        self.play(DrawBorderThenFill(cover[0].set_stroke(WHITE, 1)))\n        self.add(U4)\n        self.play(DrawBorderThenFill(cover[4].set_stroke(WHITE, 1)))\n        self.add(U5)\n        self.wait(3)\n        self.play(ReplacementTransform(t_5, t_6))\n        self.play(DrawBorderThenFill(circle))\n        self.play(DrawBorderThenFill(circle3))\n        self.play(DrawBorderThenFill(circle4))\n        self.play(DrawBorderThenFill(circle5))\n        self.play(FadeIn(Group_4))\n        self.wait(4)\n        self.wait(4)\n        self.play(ReplacementTransform(Group_5, t_7))\n        self.wait(3)\n        self.play(FadeOut(t_7))"}]}
{"messages": [{"role": "user", "content": "Animate a mathematical explanation of topological coverings, illustrating key definitions and properties with animated text and diagrams."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Cubierta(Scene):\n\n    def construct(self):\n        title = TextMobject('Cubiertas').scale(1.5)\n        grid = ScreenGrid()\n        t_1 = TextMobject('Sea ', '$A$', ' $\\\\subset \\\\mathbb{R}^n$')\n        t_1.set_color_by_tex_to_color_map({'$A$': BLUE})\n        t_2 = TextMobject('Definimos una', ' cubierta', ' de ', '$A$')\n        t_2.set_color_by_tex_to_color_map({'cubierta': PURPLE_B, '$A$': BLUE})\n        t_3_1 = TextMobject('como una colecci\u00f3n de', ' subconjuntos ', '$\\\\mathcal{F}$', ' $\\\\subset \\\\mathcal{P}(\\\\mathbb{R}^n)$,')\n        t_3_1.set_color_by_tex_to_color_map({'subconjuntos': GREEN_D, '$\\\\mathcal{F}': PURPLE_B})\n        t_3_2 = TextMobject('donde $\\\\mathcal{P}(\\\\mathbb{R}^n)$ es el conjunto potencia de $\\\\mathbb{R}^n$').move_to(1 * DOWN)\n        t_3 = VGroup(t_3_1, t_3_2)\n        t_4 = TextMobject('tal que ', '$A$', ' $\\\\subseteq \\\\bigcup_{U \\\\subset \\\\mathcal{F}} U$, con $U\\\\subset\\\\mathbb{R}^n$')\n        t_4.set_color_by_tex_to_color_map({'$A$': BLUE})\n        t_4[2][4].set_color(PURPLE_B)\n        t_5 = TextMobject('Por ejemplo, sea ', '$A$', '  el siguiente', ' conjunto:').move_to(3 * UP)\n        t_5.set_color_by_tex_to_color_map({'conjunto': BLUE, '$A$': BLUE})\n        t_6 = TextMobject('Entonces una posible', ' cubierta $\\\\mathcal{F}$', ' podr\u00eda ser: ').move_to(3 * UP)\n        t_6.set_color_by_tex_to_color_map({'cubierta $\\\\mathcal{F}$': PURPLE_B})\n        t_7 = TextMobject('Una', ' cubierta', ' puede ser', ' abierta', ' o', ' cerrada').move_to(3 * UP)\n        t_7.set_color_by_tex_to_color_map({'cubierta': PURPLE_B, 'abierta': RED, 'cerrada': ORANGE})\n        t_8 = TextMobject('dependiendo de si los', ' subconjuntos $U_{i}$', ' que la componen').move_to(3 * UP)\n        t_8.set_color_by_tex_to_color_map({'subconjuntos $U_{i}$': GREEN_D})\n        t_9 = TextMobject('son todos', ' abiertos').move_to(3 * UP)\n        t_9.set_color_by_tex_to_color_map({'abiertos': RED})\n        t_10 = TextMobject('o todos', ' cerrados').move_to(3 * UP)\n        t_10.set_color_by_tex_to_color_map({'cerrados': ORANGE})\n        t_11 = TextMobject('Observemos que en este caso los ', 'subconjuntos $U_{i}$', '\\\\\\\\ se sobreponen').move_to(3 * UP)\n        t_11.set_color_by_tex_to_color_map({'subconjuntos $U_{i}$': GREEN_D})\n        t_12 = TextMobject('por lo que el', ' conjunto $A$', ' queda totalmente cubierto').move_to(3 * UP)\n        t_12.set_color_by_tex_to_color_map({'conjunto $A$': BLUE})\n        t_13 = TextMobject('independientemente de que ', '$\\\\mathcal{F}$', ' sea', ' abierta', ' o', ' cerrada').move_to(3 * UP)\n        t_13.set_color_by_tex_to_color_map({'abierta': RED, 'cerrada': ORANGE, '$\\\\mathcal{F}$': PURPLE_B})\n        t_14 = TextMobject('Si ', 'A', ' es ', 'cerrado', ' y $diam(U_i)<diam(A)$,').move_to(3 * UP)\n        t_14[1].set_color(BLUE)\n        t_14[3].set_color(ORANGE)\n        t_15_1 = TextMobject('\u00bfexiste ', 'cubierta ', 'abierta de ', 'A', ', donde').move_to(3 * UP)\n        t_15_2 = TextMobject('los elementos ', '$U_i$', ' \\\\textbf{no} se intersecten?').next_to(t_15_1, DOWN)\n        t_15_1[1].set_color(PURPLE_B)\n        t_15_1[3].set_color(BLUE)\n        t_15_2[1].set_color(GREEN_D)\n        t_15 = VGroup(t_15_1, t_15_2)\n        Conjunto_Cubierto = SVGMobject('Topologia_SVGs/Cubierta.svg').scale(2)\n        A = Conjunto_Cubierto[0].set_color(BLUE).next_to(t_5, 7 * DOWN)\n        cover_1 = Conjunto_Cubierto[1:6].next_to(t_6, 4 * DOWN)\n        index = VGroup()\n        colors = it.cycle([YELLOW, GREEN_D, PURPLE_B, PINK, RED, TEAL])\n        for i in range(len(cover_1)):\n            text = TextMobject('$U_{%d}$' % (i + 1))\n            color = next(colors)\n            cover_1[i].set_fill(color, opacity=0.4).set_stroke(color, 0.5)\n            text.move_to(cover_1[i])\n            index.add(text)\n        cover_2 = Conjunto_Cubierto[6:11].next_to(t_12, 4 * DOWN)\n        for i in range(len(cover_2)):\n            color = next(colors)\n            cover_2[i].set_fill(color, opacity=0.4).set_stroke(color, 0.5)\n        Group_1 = VGroup(t_5, A)\n        Group_2 = VGroup(t_6, A)\n        Group_3 = VGroup(cover_1, index)\n        Group_4 = VGroup(t_15, cover_2, A)\n        self.play(Write(title))\n        self.wait()\n        self.play(ReplacementTransform(title, t_1))\n        self.wait(2)\n        self.play(ReplacementTransform(t_1, t_2))\n        self.wait(2)\n        self.play(ReplacementTransform(t_2, t_3))\n        self.wait(6)\n        self.play(ReplacementTransform(t_3, t_4))\n        self.wait(11)\n        self.play(ReplacementTransform(t_4, Group_1))\n        self.wait(5)\n        self.play(ReplacementTransform(Group_1, Group_2))\n        self.wait(5)\n        self.play(FadeIn(Group_3))\n        self.wait(2.5)\n        self.play(ReplacementTransform(t_6, t_7))\n        self.wait(5)\n        self.play(ReplacementTransform(t_7, t_8))\n        self.wait(5)\n        self.play(ReplacementTransform(t_8, t_9))\n        self.wait(2)\n        self.play(ReplacementTransform(t_9, t_10))\n        self.remove(Group_3).add(cover_1.set_stroke(WHITE, 3))\n        self.wait(2)\n        self.play(ReplacementTransform(t_10, t_11))\n        self.wait(6)\n        self.play(ReplacementTransform(t_11, t_12))\n        self.wait(5)\n        self.play(ReplacementTransform(t_12, t_13))\n        self.wait(5)\n        self.play(ReplacementTransform(t_13, t_14))\n        self.play(ReplacementTransform(cover_1.set_stroke(WHITE, 3), cover_2))\n        self.wait(8)\n        self.play(ReplacementTransform(t_14, t_15))\n        self.wait(7)\n        self.play(FadeOut(Group_4))"}]}
{"messages": [{"role": "user", "content": "Present a mathematical explanation of open and closed sets, illustrating concepts with visual aids and posing questions about set properties."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ObservacionCerradosAbiertos(Scene):\n\n    def construct(self):\n        titulo = TextMobject('Ni abierto,\\n\\n                             ni cerrado ').scale(1.5)\n        text1 = TextMobject('Consideremos el siguiente conjunto')\n        text1.move_to(3 * UP)\n        text1_1 = TextMobject('A').scale(2)\n        text1_1.set_color(BLUE_E)\n        text1_1.move_to(text1.get_center() + 0.8 * DOWN)\n        text2_1 = TextMobject('Obs\u00e9rvese c\u00f3mo los puntos a\u00f1adidos en ', 'rojo')\n        text2_2 = TextMobject('completan la frontera de ', 'A').next_to(text2_1, DOWN)\n        text2_1[1].set_color(RED)\n        text2_2[1].set_color(BLUE_E)\n        text2 = VGroup(text2_1, text2_2)\n        text2.move_to(text1)\n        text3 = TextMobject('Sin embargo, ', 'estos', ' no est\u00e1n contenidos en ', 'A')\n        text3[1].set_color(RED)\n        text3[3].set_color(BLUE_E)\n        text3.move_to(text1.get_center() + 0.8 * DOWN)\n        text3_1_1 = TextMobject('Es decir,')\n        text3_1_2 = TexMobject('Fr(', 'A', ')', '\\\\not\\\\subset', 'A', color=ORANGE).next_to(text3_1_1, DOWN)\n        text3_1_2[1].set_color(BLUE_E)\n        text3_1_2[4].set_color(BLUE_E)\n        text3_1 = VGroup(text3_1_1, text3_1_2)\n        text3_1.move_to(text1)\n        text4 = TextMobject('Esto implica que ', 'A', ' no es ', 'cerrado')\n        text4[1].set_color(BLUE_E)\n        text4[3].set_color(GREEN)\n        text4.move_to(text1.get_center() + 0.8 * DOWN)\n        text5_1 = TextMobject('Por otro lado, los puntos blancos')\n        text5_2 = TextMobject('pertenecen a la frontera de ', 'A').next_to(text5_1, DOWN)\n        text5_2[1].set_color(BLUE_E)\n        text5 = VGroup(text5_1, text5_2)\n        text5.move_to(text1.get_center() + 0.8 * DOWN)\n        text5_1_1 = TextMobject('Es decir,')\n        text5_1_2 = TexMobject('Fr(', 'A', ')', '\\\\cap', 'A', '\\\\neq\\\\emptyset', color=ORANGE).next_to(text5_1_1, DOWN)\n        text5_1_2[1].set_color(BLUE_E)\n        text5_1_2[4].set_color(BLUE_E)\n        text5_1 = VGroup(text5_1_1, text5_1_2)\n        text5_1.move_to(text1)\n        text6 = TextMobject('Por lo tanto, ', 'A', ' no es ', 'cerrado', ' y no es ', 'abierto')\n        text6[1].set_color(BLUE_E)\n        text6[3].set_color(GREEN)\n        text6[5].set_color(YELLOW)\n        text6.move_to(text1.get_center() + 0.8 * DOWN)\n        text7_1 = TextMobject('Entonces las descripciones de ', 'abierto', ' y ', 'cerrado').move_to(text1.get_center() + 1.5 * DOWN)\n        text7_2 = TextMobject('no son caracter\u00edsticas complementarias ', 'de un conjunto,').next_to(text7_1, DOWN)\n        text7_3 = TextMobject('pues dado un conjunto ', 'A', ':').next_to(text7_2, DOWN)\n        text7_4 = TexMobject('\\\\text{A}', '\\\\text{ no abierto  }', '\\\\text{no implica}', '\\\\text{  A}', '\\\\text{ cerrado}', color=WHITE).next_to(text7_3, 2 * DOWN)\n        text7_5 = TexMobject('\\\\text{A}', '\\\\text{ no cerrado  }', '\\\\text{no implica}', '\\\\text{  A}', '\\\\text{ abierto}', color=WHITE).next_to(text7_4, 1.5 * DOWN)\n        text7_1[1].set_color(YELLOW)\n        text7_1[3].set_color(GREEN)\n        text7_4[2].set_color(RED)\n        text7_5[2].set_color(RED)\n        text7 = VGroup(text7_1, text7_2, text7_3)\n        pregunta_1 = TextMobject('Ahora que sabes m\u00e1s de los conjuntos ', 'abiertos')\n        pregunta_2 = TextMobject('y ', 'cerrados', ', \u00bfpuedes responder lo siguiente?').next_to(pregunta_1, DOWN)\n        pregunta_1[1].set_color(YELLOW)\n        pregunta_2[1].set_color(GREEN)\n        pregunta = VGroup(pregunta_1, pregunta_2)\n        pregunta_copy = pregunta.copy()\n        pregunta_copy.move_to(text1.get_center() + 0.8 * DOWN)\n        pregunta0 = TextMobject('Sea ', 'A', ' un conjunto:').next_to(pregunta_copy, DOWN * 2)\n        pregunta1 = TextMobject('\u00bfInt(A)', ' es ', 'abierto', ' o ', 'cerrado', '?').next_to(pregunta0, DOWN * 1.5)\n        pregunta1[2].set_color(YELLOW)\n        pregunta1[4].set_color(GREEN)\n        pregunta2 = TextMobject('\u00bfFr(A)', ' es ', 'abierta', ' o ', 'cerrada', '?').next_to(pregunta1, DOWN * 1.5)\n        pregunta2[2].set_color(YELLOW)\n        pregunta2[4].set_color(GREEN)\n        pregunta3 = TextMobject('Dado ', '$x_0$', '$\\\\in$', 'A', ' y ', 'r ', '$> 0$', ', \u00bf', '$B_r(x_0)$ ', ' es ', 'abierto', ' o ', 'cerrado', '?').next_to(pregunta2, DOWN * 1.5)\n        pregunta3[1].set_color(ORANGE)\n        pregunta3[10].set_color(YELLOW)\n        pregunta3[12].set_color(GREEN)\n        obs1 = SVGMobject('Topologia_SVGs/observacion1.svg')\n        obs1.move_to(1 * DOWN)\n        obs1.scale(2.5)\n        obs1[0:1].set_color(BLUE_E)\n        obs1[0:1].set_stroke(BLUE_E)\n        obs1[1:2].set_color(BLUE_E)\n        obs1[1:2].set_stroke(WHITE)\n        obs1[2:3].set_stroke(WHITE)\n        obs1[2:3].set_color(BLUE_E)\n        obs1_1 = obs1.copy()\n        obs1_1.move_to(1 * DOWN)\n        obs1_1[0:1].set_color(BLUE_E)\n        obs1_1[0:1].set_stroke(RED)\n        obs1_1[1:2].set_color(BLUE_E)\n        obs1_1[1:2].set_stroke(WHITE)\n        obs1[2:3].set_stroke(BLUE_E)\n        obs1[2:3].set_color(BLUE_E)\n        obs1_2 = SVGMobject('Topologia_SVGs/observacion1.svg')\n        obs1_2.move_to(1 * DOWN)\n        obs1_2.scale(2.5)\n        obs1_2[0:1].set_color(BLUE_E)\n        obs1_2[0:1].set_stroke(BLUE_E)\n        obs1_2[1:2].set_color(BLUE_E)\n        obs1_2[1:2].set_stroke(WHITE)\n        obs1_2[2:3].set_stroke(BLUE_E)\n        obs1_2[2:3].set_color(BLUE_E)\n        obs1_3 = obs1.copy()\n        self.play(Write(titulo))\n        self.wait()\n        self.play(FadeOut(titulo))\n        self.play(Write(text1))\n        self.play(Write(text1_1))\n        self.play(SpinInFromNothing(obs1))\n        self.wait(2)\n        self.play(ReplacementTransform(text1, text2), FadeOut(text1_1))\n        self.wait(7)\n        self.play(ReplacementTransform(obs1, obs1_1))\n        self.wait(1.5)\n        self.play(ReplacementTransform(text2, text3))\n        self.wait(1.5)\n        self.play(ReplacementTransform(obs1_1, obs1_2))\n        self.wait()\n        self.play(ReplacementTransform(text3, text3_1))\n        self.wait(6)\n        self.play(ReplacementTransform(text3_1, text4))\n        self.wait(2)\n        self.play(ReplacementTransform(obs1_2, obs1_3))\n        self.play(ReplacementTransform(text4, text5))\n        self.wait(2.5)\n        self.play(ReplacementTransform(text5, text5_1))\n        self.wait(7)\n        self.play(ReplacementTransform(text5_1, text6))\n        self.wait(3)\n        self.play(FadeOut(text6), ShrinkToCenter(obs1_3))\n        self.play(Write(text7))\n        self.wait(9)\n        self.play(Write(text7_4))\n        self.wait(1.5)\n        self.play(Write(text7_5))\n        self.wait(1.5)\n        self.play(FadeOut(text7), FadeOut(text7_4), FadeOut(text7_5))\n        self.play(Write(pregunta))\n        self.wait()\n        self.play(ReplacementTransform(pregunta, pregunta_copy))\n        self.play(Write(pregunta0))\n        self.wait(0.4)\n        self.play(Write(pregunta1))\n        self.wait(3)\n        self.play(Write(pregunta2))\n        self.wait(7)\n        self.play(Write(pregunta3))\n        self.wait(10)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Define and illustrate the concepts of interior, exterior, and boundary points of a set with their mathematical definitions and visual representations."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass TiposPuntos(Scene):\n\n    def construct(self):\n        titulo = TextMobject('Tipos de Puntos')\n        titulo.scale(1.5)\n        t_1 = TextMobject('Sea A un conjunto cualquiera')\n        interior_t = TextMobject('Punto interior de A')\n        interior_t.move_to((-3.75, 2.5, 0)).set_color(RED)\n        exterior_t = TextMobject('Punto exterior de A')\n        exterior_t.move_to((-3.75, 1, 0)).set_color(BLUE)\n        frontera_t = TextMobject('Punto frontera de A')\n        frontera_t.move_to((-3.75, 0, 0)).set_color(GREEN)\n        interior_def = TexMobject('\\\\exists r>0, \\\\ tq. \\\\ \\\\mathbb{B}_r(x_0)\\\\subset A')\n        interior_def.move_to((3, 2.5, 0)).set_color(WHITE)\n        exterior_def = TexMobject('\\\\exists r>0, \\\\ tq. \\\\ \\\\mathbb{B}_r(x_0)\\\\subset A^c')\n        exterior_def.move_to((3, 1, 0)).set_color(WHITE)\n        frontera_def = TexMobject('\\\\forall r>0, \\\\ tq.')\n        frontera_def_1 = TexMobject('\\\\mathbb{B}_r(x_0)\\\\cap A\\\\neq \\\\emptyset')\n        frontera_def_2 = TexMobject('y')\n        frontera_def_3 = TexMobject('\\\\mathbb{B}_r(x_0)\\\\cap A^c\\\\neq \\\\emptyset')\n        frontera_def.move_to((3, 0, 0)).set_color(WHITE)\n        frontera_def_1.next_to(frontera_def, DOWN, buff=0.1).set_color(WHITE)\n        frontera_def_2.next_to(frontera_def_1, DOWN, buff=0.1).set_color(WHITE)\n        frontera_def_3.next_to(frontera_def_2, DOWN, buff=0.1).set_color(WHITE)\n        texto_1 = TextMobject(\"Pero \\\\textquestiondown qu\\\\'{e} significa geom\\\\'{e}tricamente?\")\n        texto_3 = TextMobject(\" \\\\textexclamdown Por favor regresa el video e intenta \\n\\n                                 asociar las definiciones de cada tipo \\n\\n                                 de punto con el dibujo y visualiza cada \\n\\n                                 definici\\\\'{o}n en este dibujo!\").scale(0.5).move_to((-4.5, 2.5, 0))\n        texto_4 = TextMobject('El conjunto de todos los puntos \\n\\n                                interiores de un conjunto es el', ' INTERIOR', ' del \\n\\n                                conjunto.').move_to((0, 2, 0))\n        texto_4[1].set_color(RED)\n        texto_5 = TextMobject('El conjunto de todos los puntos \\n\\n                                exteriores de un conjunto es el', ' EXTERIOR', ' del \\n\\n                                conjunto. ').move_to((0, 0, 0))\n        texto_5[1].set_color(BLUE)\n        texto_6 = TextMobject('El conjunto de todos los puntos \\n\\n                                frontera de un conjunto es la', ' FRONTERA', ' del \\n\\n                                conjunto. ').move_to((0, -2, 0))\n        texto_6[1].set_color(GREEN)\n        texto_7t = TextMobject('Intenta probar lo siguiente: Si $A$ es un conjunto')\n        texto_71 = TextMobject('1) \\\\ $Int(A)\\\\cap Fr(A) = \\\\emptyset$')\n        texto_72 = TextMobject('2) \\\\ $Int(A)\\\\cap Ext(A) = \\\\emptyset$')\n        texto_73 = TextMobject('3) \\\\ $Ext(A)\\\\cap Fr(A) = \\\\emptyset$')\n        texto_74 = TextMobject('4) \\\\ $Int(A^c) = Ext(A)$')\n        texto_7t.shift(3 * UP)\n        texto_71.next_to(texto_7t, 2 * DOWN)\n        texto_72.next_to(texto_71, DOWN)\n        texto_73.next_to(texto_72, DOWN)\n        texto_74.next_to(texto_73, DOWN)\n        texto_7 = VGroup(texto_7t, texto_71, texto_72, texto_73, texto_74)\n        conjunto = Circle(radius=3, color=YELLOW_B, fill_color=YELLOW_D, fill_opacity=0.7)\n        punto_int = Dot(point=(1, 1, 0)).set_color(RED)\n        punto_ext = Dot(point=(3, 3, 0)).set_color(BLUE)\n        punto_fr = Dot(point=(1.5, np.sqrt(9 - 1.5 ** 2), 0)).set_color(GREEN)\n        flecha_int = Arrow((-1.5, 2.5, 0), (0.3, 2.5, 0)).set_color(RED)\n        flecha_ext = Arrow((-1.5, 1, 0), (0.3, 1, 0)).set_color(BLUE)\n        flecha_fr = Arrow((-1.5, 0, 0), (0.3, 0, 0)).set_color(GREEN)\n        cjto_int = Circle(radius=1, color=RED, fill_color=RED, fill_opacity=0.7).move_to((1, 1, 0))\n        cjto_ext = Circle(radius=0.5, color=BLUE, fill_color=BLUE, fill_opacity=0.7).move_to((3, 3, 0))\n        cjto_fr = Circle(radius=0.5, color=GREEN, fill_color=GREEN, fill_opacity=0.7).move_to(punto_fr.get_center())\n        gpo_1 = VGroup(interior_t, exterior_t, frontera_t, interior_def, exterior_def, frontera_def, flecha_int, flecha_ext, flecha_fr, frontera_def_1, frontera_def_2, frontera_def_3)\n        gpo_11 = VGroup(interior_t, interior_def, flecha_int)\n        gpo_12 = VGroup(exterior_t, exterior_def, flecha_ext)\n        gpo_13 = VGroup(frontera_t, frontera_def, flecha_fr, frontera_def_1, frontera_def_2, frontera_def_3)\n        self.play(Write(titulo))\n        self.wait(2)\n        self.play(FadeOut(titulo))\n        self.play(Write(t_1))\n        self.wait(2)\n        self.play(FadeOut(t_1))\n        self.play(Write(gpo_11))\n        self.wait(1.4)\n        self.play(Write(gpo_12))\n        self.wait(1.4)\n        self.play(Write(gpo_13))\n        self.wait(3)\n        self.play(ReplacementTransform(gpo_1, texto_1))\n        self.wait(2.6)\n        self.play(ReplacementTransform(texto_1, conjunto))\n        self.wait(2.7)\n        self.play(Write(punto_int), Write(punto_ext), Write(punto_fr))\n        self.wait(1.2)\n        self.play(DrawBorderThenFill(cjto_int), runtime=0.2)\n        self.play(DrawBorderThenFill(cjto_ext), runtime=0.2)\n        self.play(DrawBorderThenFill(cjto_fr), runtime=0.2)\n        self.play(Write(texto_3))\n        self.wait(4)\n        self.play(FadeOut(texto_3), FadeOut(cjto_int), FadeOut(cjto_ext), FadeOut(cjto_fr), FadeOut(conjunto), FadeOut(punto_int), FadeOut(punto_ext), FadeOut(punto_fr))\n        self.play(Write(texto_4))\n        self.wait(2)\n        self.play(Write(texto_5))\n        self.wait(2)\n        self.play(Write(texto_6))\n        self.wait(2)\n        self.play(FadeOut(texto_4), FadeOut(texto_5), FadeOut(texto_6))\n        self.play(Write(texto_7t))\n        self.wait(2)\n        self.play(Write(texto_71))\n        self.wait(2)\n        self.play(Write(texto_72))\n        self.wait(2)\n        self.play(Write(texto_73))\n        self.wait(2)\n        self.play(Write(texto_74))\n        self.wait(2)\n        self.play(FadeOut(texto_7))"}]}
