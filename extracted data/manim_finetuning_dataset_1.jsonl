{"messages": [{"role": "user", "content": "Animate a video that starts with a logo and slogan, then displays text content with corresponding audio, and concludes with platform information."}, {"role": "assistant", "content": "from manim import *\nfrom TTS.TTS import get_mp3_file\nfrom utils import cut, get_duration, deal_text\nimport time\n\nclass Video(Scene):\n\n    def construct(self):\n        LOGO = ImageMobject('./media/images/logo.png').scale(0.3).to_edge(UP, buff=2)\n        Slogan_text = '\u4e3a\u4f60\u6536\u96c6\u65e5\u843d\u65f6\u7684\u4e91\u6735\uff0c\u4e3a\u4f60\u6536\u85cf\u4e0b\u96e8\u540e\u7684\u5929\u7a7a'\n        get_mp3_file(text=f'{Slogan_text}', output_path='./media/sounds/video_start', rate='-10%')\n        Slogan = Text(Slogan_text, font='Muyao-Softbrush', weight=MEDIUM, color='#FCA113').scale(0.7).next_to(LOGO, DOWN, buff=1)\n        self.play(FadeIn(LOGO, run_time=0.1))\n        self.wait(0.5)\n        self.play(FadeIn(Slogan), run_time=1)\n        self.add_sound('./media/sounds/video_start.mp3')\n        self.wait(5)\n        self.play(FadeOut(Slogan, LOGO))\n        LOGO = ImageMobject('./media/images/logo.png').scale(0.1).to_edge(UL)\n        username = Text('@\u4ed9\u5973\u739b\u4e3d\u82cf\u5416', font='Muyao-Softbrush').scale(0.5).next_to(LOGO, RIGHT)\n        self.add(LOGO, username)\n        title = '\u5728\u672c\u5b50\u4e0a\u5199\u4e0a\u4ed6\u7684\u540d\u5b57'\n        title = '\u300a' + title + '\u300b'\n        title = Text(title, font='Muyao-Softbrush', color=ORANGE).scale(0.5).to_edge(UP, buff=0.75)\n        self.add(title)\n        with open('./media/words/words.txt', 'rt', encoding='utf-8') as f:\n            content = f.readline()\n            while content:\n                audio_path = './media/sounds/video_content_' + str(round(time.time() * 1000))\n                get_mp3_file(text=content, output_path=audio_path, rate='-10%')\n                audio_path = audio_path + '.mp3'\n                audio_time = get_duration(audio_path)\n                content = MarkupText(content, font='Muyao-Softbrush', font_size=60, justify=True).scale(0.5)\n                run_time = len(content) // 50\n                self.play(Write(content), run_time=run_time)\n                self.add_sound(audio_path, time_offset=1)\n                self.wait(audio_time)\n                self.play(FadeOut(content))\n                content = f.readline()\n        self.play(FadeOut(title, username, LOGO))\n        LOGO = ImageMobject('./media/images/logo.png').scale(0.2).to_edge(UP, buff=2)\n        messages_text = '\u4f60\u53ef\u4ee5\u5728\u4e0b\u9762\u7684\u5e73\u53f0\u627e\u5230\u6211\uff0c\u8fd9\u4e00\u671f\u5c31\u5148\u5230\u8fd9\u91cc\uff0c\u6211\u4eec\u4e0b\u671f\u518d\u89c1\u3002'\n        messages = Text('-\u4f60\u53ef\u4ee5\u5728\u4e0b\u9762\u7684\u5e73\u53f0\u627e\u5230\u6211-', font='Muyao-Softbrush').scale(0.4).next_to(LOGO, DOWN)\n        get_mp3_file(text=f'{messages_text}', output_path='./media/sounds/video_end', rate='-10%')\n        gonzhonghao = ImageMobject('./media/images/icon/weixin.png').scale(0.2)\n        username1 = Text('@\u4ed9\u5973\u739b\u4e3d\u82cf', font='Smartisan Compact CNS', weight=MEDIUM).scale(0.25).next_to(gonzhonghao)\n        zhihu = ImageMobject('./media/images/icon/zhihu.png').next_to(gonzhonghao, RIGHT, buff=1).scale(0.2)\n        username2 = Text('@\u4ed9\u5973\u739b\u4e3d\u82cf', font='Smartisan Compact CNS', weight=MEDIUM).scale(0.25).next_to(zhihu)\n        xiaohongshu = ImageMobject('./media/images/icon/xiaohongshu.png').next_to(zhihu, RIGHT, buff=1).scale(0.2)\n        username3 = Text('@\u4ed9\u5973\u739b\u4e3d\u82cf', font='Smartisan Compact CNS', weight=MEDIUM).scale(0.25).next_to(xiaohongshu)\n        bilibili = ImageMobject('./media/images/icon/bilibili.png').next_to(gonzhonghao).scale(0.2)\n        username4 = Text('@\u4ed9\u5973\u739b\u4e3d\u82cf\u5416', font='Smartisan Compact CNS', weight=MEDIUM).scale(0.25).next_to(bilibili)\n        douyin = ImageMobject('./media/images/icon/douyin.png').next_to(bilibili, RIGHT, buff=1).scale(0.2)\n        username5 = Text('@\u4ed9\u5973\u739b\u4e3d\u82cf', font='Smartisan Compact CNS', weight=MEDIUM).scale(0.25).next_to(douyin)\n        toutiao = ImageMobject('./media/images/icon/toutiao1.png').next_to(douyin, RIGHT, buff=1).scale(0.2)\n        username6 = Text('@\u4ed9\u5973\u739b\u4e3d\u82cf', font='Smartisan Compact CNS', weight=MEDIUM).scale(0.25).next_to(toutiao)\n        jianshu = ImageMobject('./media/images/icon/jianshu.png').next_to(bilibili).scale(0.2)\n        username7 = Text('@\u4ed9\u5973\u739b\u4e3d\u82cf', font='Smartisan Compact CNS', weight=MEDIUM).scale(0.25).next_to(jianshu)\n        kuaishou = ImageMobject('./media/images/icon/kuaishou.png').next_to(jianshu, RIGHT, buff=1).scale(0.2)\n        username8 = Text('@\u4ed9\u5973\u739b\u4e3d\u82cf\u5416', font='Smartisan Compact CNS', weight=MEDIUM).scale(0.25).next_to(kuaishou)\n        xiguashipin = ImageMobject('./media/images/icon/xiguashipin.png').next_to(kuaishou, RIGHT, buff=1).scale(0.2)\n        username9 = Text('@\u4ed9\u5973\u739b\u4e3d\u82cf', font='Smartisan Compact CNS', weight=MEDIUM).scale(0.25).next_to(xiguashipin)\n        Recommend_group1 = Group(gonzhonghao, username1, zhihu, username2, xiaohongshu, username3).next_to(LOGO, DOWN, buff=1)\n        Recommend_group2 = Group(bilibili, username4, douyin, username5, toutiao, username6).next_to(Recommend_group1, DOWN, buff=0.2)\n        Recommend_group3 = Group(jianshu, username7, kuaishou, username8, xiguashipin, username9).next_to(Recommend_group2, DOWN, buff=0.2)\n        Recommend_group = Group(Recommend_group1, Recommend_group2, Recommend_group3)\n        self.play(FadeIn(LOGO))\n        duration = get_duration('./media/sounds/video_end.mp3')\n        self.add_sound('./media/sounds/video_end.mp3', time_offset=0.5)\n        self.play(Write(messages), run_rime=0.5)\n        self.play(FadeIn(Recommend_group))\n        self.wait(duration)\n        self.play(FadeOut(Recommend_group, messages, LOGO))"}]}
{"messages": [{"role": "user", "content": "Animate the bubble sort algorithm with visual representations of the array elements and loop indices."}, {"role": "assistant", "content": "from src.array_manim import Element, random, swap_elements, SCALE\nfrom manim import *\n\nclass Bubble(Scene):\n\n    def construct(self):\n        text = Tex('Bubble Sort', color=YELLOW)\n        self.play(Write(text))\n        self.remove(text)\n        shuffled_arr = [2, 4, 5, 6, 7, 9, 1, 8, 0, 3]\n        random.shuffle(shuffled_arr)\n        els = [Element(n) for n in shuffled_arr]\n        ctrl_view_rectangle = Rectangle(width=2 * SCALE, height=1 * SCALE, color=GREEN)\n        for i, item in enumerate(els):\n            new_pos = [(-4.9 + i) * SCALE, 0, 0]\n            item.square.move_to(new_pos)\n            item.text.move_to(new_pos)\n        self.play(*[Create(el.square) for el in els], *[Write(el.text) for el in els])\n        intial_rect_pos = midpoint(els[0].square.get_center(), els[1].square.get_center())\n        ctrl_view_rectangle.move_to(intial_rect_pos)\n        self.play(Create(ctrl_view_rectangle))\n        n = len(shuffled_arr)\n        for i in range(n):\n            swapped = False\n            if i > 0:\n                self.remove(i_text)\n                self.remove(j_text)\n            i_text = Text(f'i = {i}', color=YELLOW).to_corner(DOWN)\n            self.play(Write(i_text))\n            for j in range(n - i - 1):\n                if j > 0:\n                    self.remove(j_text)\n                j_text = Tex(f'j = {j}', color=ORANGE).next_to(i_text, UP)\n                self.play(Write(j_text))\n                if els[j].val > els[j + 1].val:\n                    els[j], els[j + 1] = (els[j + 1], els[j])\n                    swapped = True\n                    self.play(*swap_elements(els[j], els[j + 1]))\n                if j != len(shuffled_arr) - (i + 2):\n                    self.play(ApplyMethod(ctrl_view_rectangle.shift, RIGHT * SCALE))\n            self.play(ApplyMethod(ctrl_view_rectangle.move_to, intial_rect_pos))\n            if not swapped:\n                break\n        self.play(*[ApplyMethod(el.square.set_color, GREEN_C) for el in els])\n        self.play(ApplyMethod(ctrl_view_rectangle.set_color, GREEN))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Render the Manim Tutorial logo with its distinct green circle, blue square, red triangle, and text elements."}, {"role": "assistant", "content": "from manim import *\n\nclass ManimTutorialLogo(Scene):\n\n    def construct(self):\n        tex_template = TexTemplate()\n        tex_template.add_to_preamble('\\\\usepackage{fontawesome5}')\n        self.camera.background_color = '#ffffff'\n        logo_green = '#87c2a5'\n        logo_blue = '#525893'\n        logo_red = '#e07a5f'\n        logo_black = '#343434'\n        ds_m = MathTex('\\\\mathbb{M}', fill_color=logo_black).scale(7)\n        ds_m.shift(2.25 * LEFT + 1.5 * UP)\n        tutorial = MathTex('\\\\mathbb{T}\\\\text{utorial}', fill_color=logo_black).scale(4)\n        tutorial.next_to(ds_m, DOWN)\n        tutorial.shift(DOWN)\n        book = Tex('\\\\faBookReader', fill_color=logo_black, tex_template=tex_template).scale(5)\n        book.next_to(ds_m, LEFT)\n        book.shift(LEFT + 0.5 * DOWN)\n        circle = Circle(color=logo_green, fill_opacity=1).shift(LEFT)\n        square = Square(color=logo_blue, fill_opacity=1).shift(UP)\n        triangle = Triangle(color=logo_red, fill_opacity=1).shift(RIGHT)\n        logo = VGroup(triangle, square, circle, ds_m, tutorial, book)\n        logo.move_to(ORIGIN)\n        self.add(logo)"}]}
{"messages": [{"role": "user", "content": "Animate a Fourier series approximation of a periodic function, showing the function and progressively more terms of the series."}, {"role": "assistant", "content": "from manim import *\nfrom func.x import *\n\nclass Fourier(Scene):\n\n    def construct(self):\n        self.create_axes()\n        graph_func = self.axes.plot(func_periodic, x_range=(func_x_range_min, func_x_range_max, plot_x_delta), discontinuities=func_discontinuities, use_smoothing=True, color=COLOR_FUNC)\n        txt_message = Text(message, font_size=40)\n        txt_message.set_color(COLOR_MESSAGE)\n        math_func = MathTex(tex_func, font_size=40)\n        math_func.set_color(COLOR_FUNC)\n        math_tilde = MathTex(tex_sim_or_equals, font_size=60)\n        math_tilde.set_color(COLOR_TILDE)\n        math_series = MathTex(tex_series, font_size=40)\n        math_series.set_color(COLOR_SERIES)\n        top_labels = VGroup(txt_message, math_tilde, math_series).arrange(RIGHT, buff=1)\n        top_labels.to_edge(UP, buff=1)\n        math_func.move_to(txt_message)\n        txt_periodic = Text('periodic', font_size=22, color=COLOR_PERIODIC).next_to(math_func, DOWN, buff=0.2)\n        self.play(Write(txt_message), DrawBorderThenFill(self.axes))\n        self.play(ReplacementTransform(txt_message, math_func), Write(txt_periodic), Create(graph_func))\n        self.play(Write(math_series))\n        self.play(Write(math_tilde))\n        self.prepare_fourier_animation()\n        self.animate_fourier_series(series_start, series_end, series_step)\n        self.animate_fourier_series(series_more_start, series_more_end, series_more_step)\n        self.wait()\n\n    def prepare_fourier_animation(self):\n        self.math_n_equals = MathTex('n = ', font_size=60, color=COLOR_N_TERM_COUNT)\n        self.math_n_equals.align_to(self.axes, UR).shift(LEFT)\n        self.play(FadeIn(self.math_n_equals))\n        self.graph_series = None\n        self.n_series = None\n\n    def animate_fourier_series(self, start, end, step):\n        each_run_time = series_run_time / (end - start)\n        fade_animation_on = each_run_time >= 0.4\n        for n in range(start, end + 1, step):\n            n_series_new = Integer(n).scale(1.1).next_to(self.math_n_equals, RIGHT, buff=0.2).shift(UP * 0.03)\n            n_series_new.set_color(COLOR_N_TERM_COUNT)\n            graph_series_new = self.axes.plot(func_series(n), x_range=[func_x_range_min, func_x_range_max, plot_x_delta], use_smoothing=True, color=COLOR_SERIES, stroke_width=3, stroke_opacity=0.9)\n            if self.graph_series is not None:\n                self.play(ReplacementTransform(self.graph_series, graph_series_new, run_time=each_run_time), FadeTransform(self.n_series, n_series_new, run_time=each_run_time if fade_animation_on else 0))\n            else:\n                self.play(Create(graph_series_new), Write(n_series_new))\n            self.graph_series = graph_series_new\n            self.n_series = n_series_new\n\n    def create_axes(self):\n        self.axes = Axes(x_range=(x_min, x_max, x_step), y_range=(y_min, y_max, y_step), y_length=y_length, axis_config={'include_ticks': include_ticks, 'include_tip': include_tip}).to_corner(DOWN, buff=1.8)\n        labels = self.axes.get_axis_labels(x_label='x', y_label='').set_color(WHITE)\n        self.axes.add(labels)\n        if is_pi_label:\n            self.add_pi_x_labels()\n\n    def add_pi_x_labels(self, scale=0.8, buff=0.4, buff_adjust=0.09, aligned_edge=DOWN):\n        x_min = self.axes.x_range[0]\n        x_max = self.axes.x_range[1]\n        if show_x_0_label and x_min <= 0 and (0 <= x_max):\n            self.axes.add(MathTex('0').next_to(self.axes.c2p(0, 0), aligned_edge, buff=buff).scale(scale))\n        if x_min <= -PI and -PI <= x_max:\n            self.axes.add(MathTex('-\\\\pi').next_to(self.axes.c2p(-PI, 0), aligned_edge, buff=buff + buff_adjust).scale(scale))\n        if x_min <= PI and PI <= x_max:\n            self.axes.add(MathTex('\\\\pi').next_to(self.axes.c2p(PI, 0), aligned_edge, buff=buff + buff_adjust).scale(scale))\n        for n in range(-10, 10):\n            if n in (-1, 0, 1):\n                continue\n            npi = n * PI\n            if x_min <= npi and npi <= x_max:\n                self.axes.add(MathTex(str(n) + '\\\\pi').next_to(self.axes.c2p(npi, 0), aligned_edge, buff=buff).scale(scale))"}]}
{"messages": [{"role": "user", "content": "Illustrate the Seven Circles Theorem by drawing a large circle, six smaller tangent inner circles, their intersection points with the outer circle, a hexagon formed by these points, and its three main diagonals that meet at a single point."}, {"role": "assistant", "content": "from itertools import product\nimport numpy as np\nfrom manim import Circle, Dot, Create, FadeIn, Line, Transform, MovingCameraScene, Flash, YELLOW, Text, UP, Write, DOWN, Tex, WHITE, PURPLE, GREY, Uncreate, AnimationGroup, Unwrite, ImageMobject, LEFT, RIGHT, MarkupText, Polygon, PI, DecimalNumber, ValueTracker, Arrow, VGroup, FadeOut, Indicate, ReplacementTransform, BLACK, VMobject, GREEN_B, ORANGE, DARK_GREY, RED, LIGHT_GRAY\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, tf_klein_to_poincare, get_intersections_of_n_tangent_circles, get_intersections_of_circles_with_unit_circle, get_intersection_from_angles, get_parallel_to_line_through_point, tf_poincare_to_klein, get_both_intersections_line_with_unit_circle, get_intersection, hyperbolic_distance_function\nfrom hexagon import HexagonCircles, HexagonMainDiagonals, HyperbolicArcBetweenPoints, HexagonAngles\nfrom hyperbolic_polygon import HyperbolicPolygon\n\nclass SevenCircles(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 9\n        OUTER_CIRCLE_COLOR = WHITE\n        INNER_CIRCLE_COLOR = GREEN_B\n        INNER_INTERSECTION_COLOR = PURPLE\n        OUTER_INTERSECTION_COLOR = DARK_GREY\n        HEXAGON_COLOR = GREY\n        DIAGONAL_COLOR = ORANGE\n        DIAGONAL_INTERSECTION_COLOR = YELLOW\n        title = Text('The Seven Circles Theorem').scale(0.8)\n        theorem_text_white = Tex('Let $C$ be a circle ', 'containing six smaller circles, ', 'such that each inner circle is tangent to $C$ ', 'and any two adjacent inner circles are also tangent to each other. ', 'Let there also be a hexagon formed by the intersection points of each inner circle with $C$. ', 'Then the three main diagonals of the hexagon will always meet in a single point.', '', stroke_width=0.05).scale(0.5).move_to([0, -2, 0])\n        theorem_text_colored = Tex('Let $C$ be a circle ', 'containing six smaller circles, ', 'such that each inner circle is tangent to $C$ ', 'and any two adjacent inner circles are also tangent to each other. ', 'Let there also be a hexagon formed by the intersection points of each inner circle with $C$. ', 'Then the three main diagonals of the hexagon will always meet in a single point.', '', substrings_to_isolate=['$C$', 'six smaller circles', 'tangent to $C$', 'adjacent inner circles are also tangent', 'hexagon', 'main diagonals', 'single point'], stroke_width=0.05).set_color_by_tex('$C$', OUTER_CIRCLE_COLOR).set_color_by_tex('six smaller circles', INNER_CIRCLE_COLOR).set_color_by_tex('tangent to $C$', OUTER_INTERSECTION_COLOR).set_color_by_tex('adjacent inner circles are also tangent', INNER_INTERSECTION_COLOR).set_color_by_tex('hexagon', HEXAGON_COLOR).set_color_by_tex('main diagonals', DIAGONAL_COLOR).set_color_by_tex('single point', DIAGONAL_INTERSECTION_COLOR).scale(0.5).move_to([0, -2, 0])\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=2)\n        phis = HexagonAngles(np.array([0.3, 1.6, 2.2, 3, 4.3]))\n        first_circle_radius = 0.4\n        hexagon = EuclideanHexagon(phis, color=HEXAGON_COLOR, stroke_width=2)\n        hexagon_circles = HexagonCircles(hexagon, first_circle_radius, stroke_width=2, color=INNER_CIRCLE_COLOR)\n        inner_intersections = get_intersections_of_n_tangent_circles(hexagon_circles.circles, color=INNER_INTERSECTION_COLOR)\n        outer_intersections = get_intersections_of_circles_with_unit_circle(hexagon_circles.circles, color=OUTER_INTERSECTION_COLOR)\n        diagonals = get_diagonals(hexagon, color=DIAGONAL_COLOR, stroke_width=2)\n        diagonal_intersection = Dot(get_intersection_from_angles(phis[0], phis[3], phis[1], phis[4]), color=DIAGONAL_INTERSECTION_COLOR, radius=0.05)\n        self.add_subcaption('Wir besch\u00e4ftigen uns heute mit dem Sieben-Kreise-Satz', duration=3)\n        self.play(Write(title))\n        self.wait(2)\n        self.add_subcaption('Der Sieben-Kreise-Satz sagt Folgendes aus:', duration=2)\n        self.play(title.animate.shift(1.4 * UP).scale(0.7), self.camera.frame.animate.shift(0.8 * DOWN))\n        self.wait(1)\n        self.add_subcaption('Sei C_0 ein Kreis', duration=2)\n        self.play(Write(theorem_text_white[0], run_time=1))\n        self.play(FadeIn(circle), FadeIn(theorem_text_colored[1]))\n        self.add_foreground_mobject(circle)\n        self.add_subcaption('und C_1,...,C_6 in C_0 enthaltene Kreise', duration=4)\n        self.play(Write(theorem_text_white[1], run_time=3))\n        self.play(Create(hexagon_circles, run_time=5), FadeIn(theorem_text_colored[4], run_time=1))\n        self.remove_foreground_mobjects(circle)\n        self.add_subcaption('sodass jeder innere Kreis zum \u00e4u\u00dferen Kreis tangential ist', duration=5)\n        self.play(Write(theorem_text_white[2], run_time=3))\n        self.play(FadeIn(theorem_text_colored[7]))\n        for i in range(6):\n            self.play(Create(outer_intersections[i], run_time=0.5))\n        self.add_foreground_mobjects(*outer_intersections)\n        self.add_subcaption('und je zwei nebeneinanderliegende innere Kreise ebenfalls zueinander tangential sind.', duration=8)\n        self.play(Write(theorem_text_white[3]), run_time=6)\n        self.play(FadeIn(theorem_text_colored[10]))\n        for i in range(6):\n            self.play(Create(inner_intersections[i], run_time=0.5))\n        self.add_subcaption('Dann treffen sich die drei Diagonalen des Hexagons, das von den Schnittpunkten der inneren Kreise mit dem \u00e4u\u00dferen Kreis gebildet wird,', duration=8)\n        self.play(Write(theorem_text_white[4]), run_time=6)\n        self.play(Create(hexagon, run_time=5), FadeIn(theorem_text_colored[13]))\n        self.add_subcaption('in einem Punkt', duration=7)\n        self.play(Write(theorem_text_white[5]), run_time=3)\n        self.play(FadeIn(theorem_text_colored[18], run_time=1))\n        for x in diagonals:\n            self.play(Create(x), run_time=1)\n        self.play(FadeIn(theorem_text_colored[22], run_time=1))\n        self.play(Create(diagonal_intersection))\n        self.wait(1)\n        self.play(Flash(diagonal_intersection))\n        self.wait(1)\n        self.add_subcaption('Unser Ziel ist es jetzt diesen Satz zu beweisen.', duration=4)\n        self.wait(4)\n        self.add_subcaption('Das wird uns mithilfe einer Einbettung des Problems in einen hyperbolischen Rahmen gelingen.', duration=5)\n        self.wait(5)\n        self.add_subcaption('Zuerst geben wir daf\u00fcr eine kleine Einf\u00fchrung in die hyperbolische Geometrie,', duration=4)\n        self.wait(4)\n        self.add_subcaption('um das Problem mit unserem neugewonnenen Wissen umzuformulieren und weiter zu bearbeiten.', duration=4)\n        self.wait(3)\n        everything = VGroup()\n        for mob in self.mobjects:\n            if isinstance(mob, VMobject):\n                everything.add(mob)\n        endDot = Dot(color=BLACK)\n        self.add(endDot)\n        self.play(Transform(everything, endDot), run_time=2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize the parallel axiom in Euclidean geometry and then transition to the question of representing hyperbolic geometry in the Euclidean plane."}, {"role": "assistant", "content": "from itertools import product\nimport numpy as np\nfrom manim import Circle, Dot, Create, FadeIn, Line, Transform, MovingCameraScene, Flash, YELLOW, Text, UP, Write, DOWN, Tex, WHITE, PURPLE, GREY, Uncreate, AnimationGroup, Unwrite, ImageMobject, LEFT, RIGHT, MarkupText, Polygon, PI, DecimalNumber, ValueTracker, Arrow, VGroup, FadeOut, Indicate, ReplacementTransform, BLACK, VMobject, GREEN_B, ORANGE, DARK_GREY, RED, LIGHT_GRAY\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, tf_klein_to_poincare, get_intersections_of_n_tangent_circles, get_intersections_of_circles_with_unit_circle, get_intersection_from_angles, get_parallel_to_line_through_point, tf_poincare_to_klein, get_both_intersections_line_with_unit_circle, get_intersection, hyperbolic_distance_function\nfrom hexagon import HexagonCircles, HexagonMainDiagonals, HyperbolicArcBetweenPoints, HexagonAngles\nfrom hyperbolic_polygon import HyperbolicPolygon\n\nclass ParallelAxiom(MovingCameraScene):\n\n    def construct(self):\n        center = [0, 2, 0]\n        left = -7\n        right = 25\n        title = Text('Parallel axiom').scale(0.7).shift(5.4 * UP)\n        g_fun = lambda x: -0.7 * x\n        g_points = [[left, g_fun(left), 0], [right, g_fun(right), 0]]\n        g = Line(g_points[0], g_points[1], name='g')\n        g_text = Tex('$g$', stroke_width=0.05).move_to([-3.7, 3, 0])\n        p_array = polar_to_point(1)\n        p = Dot(p_array, name='P', color=YELLOW)\n        p_text = Tex('$P$', stroke_width=0.05).next_to(p, UP)\n        h_fun = get_parallel_to_line_through_point(g_points, p_array)\n        h_points = [[left, h_fun(left), 0], [right, h_fun(right), 0]]\n        h = Line(h_points[0], h_points[1], name='h')\n        h_text = Tex('$h$', stroke_width=0.05).move_to([-1.7, 3, 0])\n        similar_to_g = [lambda x: x * -0.65, lambda x: x * -0.8, lambda x: x * -0.57, lambda x: x * -0.77]\n        similar_points = [[[left, _(left), 0.0], [right, _(right), 0.0]] for _ in similar_to_g]\n        similar_funcs = [get_parallel_to_line_through_point(sim_points, p_array) for sim_points in similar_points]\n        sim_h_points = [[[left, _(left), 0.0], [right, _(right), 0.0]] for _ in similar_funcs]\n        similar_lines = [Line(_[0], _[1], stroke_width=1) for _ in sim_h_points]\n        intersection_points = [get_intersection(g_points[0], g_points[1], [left, _(left), 0.0], [right, _(right), 0.0]) for _ in similar_funcs]\n        intersection_dots = [Dot(point=p, color=RED) for p in intersection_points]\n        elements = [title, g, g_text, h, h_text, p, p_text, similar_lines[0], similar_lines[1], similar_lines[2], similar_lines[3], intersection_dots[0], intersection_dots[1], intersection_dots[2], intersection_dots[3]]\n        uncreate = AnimationGroup(*[Uncreate(i, run_time=1) for i in elements])\n        camera_shift = 1.7 * np.array([10, -7, 0])\n        question = Text('How can we represent the hyperbolic in the Euclidean plane?').scale(0.65).move_to(center)\n        self.camera.frame.move_to(center)\n        self.add_subcaption('Axiomatisch unterscheidet sich der hyperbolische Raum vom Euklidischen', duration=4)\n        self.wait(4)\n        self.add_subcaption('dadurch, dass das Parallelenaxiom nicht gilt.', duration=4)\n        self.wait(2)\n        self.play(Write(title), run_time=2)\n        self.add_subcaption('Das Parallelenaxiom sagt aus, dass zu jeder Geraden g', duration=3)\n        self.play(Create(g))\n        self.play(Write(g_text))\n        self.wait(2)\n        self.add_subcaption('und jedem Punkt P, der nicht auf g liegt', duration=3)\n        self.play(Create(p))\n        self.play(Write(p_text))\n        self.add_foreground_mobject(p)\n        self.wait(2)\n        self.add_subcaption('genau eine Gerade h existiert, die durch P verl\u00e4uft und zu g parallel ist.', duration=4)\n        self.play(Create(h))\n        self.play(Write(h_text))\n        self.wait(2)\n        self.add_subcaption('Parallel hei\u00dft hier einfach, dass sich die beiden Geraden nicht schneiden.', duration=4)\n        self.wait(5)\n        self.add_subcaption('In hyperbolischer Geometrie ist diese Eigenschaft nicht gegeben.', duration=3)\n        self.wait(4)\n        self.add_subcaption('Dort gibt es f\u00fcr jede solche g und P mehrere - sogar unendlich viele - Geraden durch P, die zu g parallel sind also g nicht schneiden.', duration=10)\n        self.play(Create(similar_lines[0]))\n        self.play(Create(similar_lines[1]))\n        self.play(Create(similar_lines[2]))\n        self.play(Create(similar_lines[3]))\n        for intersection_dot in intersection_dots:\n            self.add(intersection_dot)\n        self.wait(6)\n        self.add_subcaption('Unsere Darstellung hier ist aber irref\u00fchrend, denn nat\u00fcrlich wird g von allen au\u00dfer der urspr\u00fcnglichen Geraden h geschnitten, wenn wir ihnen nur lange genug folgen.', duration=10)\n        self.play(self.camera.frame.animate.shift(camera_shift), title.animate.shift(camera_shift), run_time=5)\n        self.wait(5)\n        self.add_subcaption('Allgemein haben wir das Problem, dass wir einen hyperbolischen Raum in der euklidischen Ebene - diesem Video - darstellen wollen.', duration=9)\n        self.wait(9)\n        self.add_subcaption('Die Frage die wir jetzt angehen ist also: Wie stellt man die hyperbolische Ebene im Euklidischen dar?', duration=7)\n        self.play(uncreate)\n        self.play(self.camera.frame.animate.move_to(center))\n        self.play(Write(question))\n        self.wait(3)\n        self.play(Unwrite(question))"}]}
{"messages": [{"role": "user", "content": "Demonstrate the Klein and Poincar\u00e9 models of the hyperbolic plane, focusing on the Poincar\u00e9 model's representation of geodesics and distance."}, {"role": "assistant", "content": "from itertools import product\nimport numpy as np\nfrom manim import Circle, Dot, Create, FadeIn, Line, Transform, MovingCameraScene, Flash, YELLOW, Text, UP, Write, DOWN, Tex, WHITE, PURPLE, GREY, Uncreate, AnimationGroup, Unwrite, ImageMobject, LEFT, RIGHT, MarkupText, Polygon, PI, DecimalNumber, ValueTracker, Arrow, VGroup, FadeOut, Indicate, ReplacementTransform, BLACK, VMobject, GREEN_B, ORANGE, DARK_GREY, RED, LIGHT_GRAY\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, tf_klein_to_poincare, get_intersections_of_n_tangent_circles, get_intersections_of_circles_with_unit_circle, get_intersection_from_angles, get_parallel_to_line_through_point, tf_poincare_to_klein, get_both_intersections_line_with_unit_circle, get_intersection, hyperbolic_distance_function\nfrom hexagon import HexagonCircles, HexagonMainDiagonals, HyperbolicArcBetweenPoints, HexagonAngles\nfrom hyperbolic_polygon import HyperbolicPolygon\n\nclass HyperbolicModelsPoincare(MovingCameraScene):\n\n    def construct(self):\n        center = np.array([0, 0, 0])\n        klein_origin = np.array([3.5, -1, 0])\n        poincare_origin = np.array([-3.5, -1, 0])\n        MY_BLUE = '#22c1dd'\n        title = MarkupText('Models for the hyperbolic plane').scale(0.8).shift(3.5 * UP)\n        klein_model = ImageMobject('tessellation_klein.png').scale(0.7).move_to(klein_origin)\n        klein_text = Text('Klein model').scale(0.6).move_to(3.5 * RIGHT + 2.2 * UP)\n        poincare_model = ImageMobject('tessellation_poincare.png').scale(0.7).move_to(poincare_origin)\n        poincare_text = Text('Poincar\u00e9 model').scale(0.6).move_to(3.5 * LEFT + 2.2 * UP)\n        p1 = np.array([[0.0, 0.0, 0.0], [1.25, 0, 0], [0.78, 0.98, 0]])\n        p2 = np.array([[-0.28, 1.23, 0], [-1.12, 0.55, 0], [-1.12, 1.42, 0]])\n        scale_front = 0.4\n        scale_back = 2.5\n        p1 = scale_front * p1\n        p2 = scale_front * p2\n        pcircle = Circle(color=MY_BLUE, stroke_width=1).scale(scale_back).move_to(poincare_origin)\n        ptri1 = HyperbolicPolygon(p1, stroke_width=1.5, dot_radius=0.02, color=YELLOW, dot_color=YELLOW).scale(scale_back)\n        ptri1.move_to(ptri1.get_center() * scale_back).shift(poincare_origin)\n        ptri2 = HyperbolicPolygon(p2, stroke_width=1.5, dot_radius=0.02, color=YELLOW, dot_color=YELLOW).scale(scale_back)\n        ptri2.move_to(ptri2.get_center() * scale_back).shift(poincare_origin)\n        ptri1_text = Tex('$\\\\Delta_1$').next_to(ptri1).scale(0.6).shift(0.5 * LEFT)\n        ptri2_text = Tex('$\\\\Delta_2$').next_to(ptri2).scale(0.6).shift(0.3 * LEFT)\n        ptri_size_text = Tex('$A(\\\\Delta_1) = A(\\\\Delta_2)$', font_size=35).next_to(pcircle, buff=0.4)\n        phis = [[0.4, 2], [1.3, 6], [3.5, 5], [4, 1.5]]\n        phis_as_points = [[polar_to_point(x), polar_to_point(y)] for [x, y] in phis]\n        p_geodesics_raw = [HyperbolicArcBetweenPoints(x, y) for [x, y] in phis_as_points]\n        p_geodesics = [geo.scale(scale_back).move_to(geo.get_center() * scale_back).shift(poincare_origin) for geo in p_geodesics_raw]\n        angle_color = LIGHT_GRAY\n        right_angles = [[[Line(0.925 * polar_to_point(x), 0.925 * polar_to_point(x - 0.08), color=angle_color), Dot(0.925 * polar_to_point(x - 0.08), color=angle_color, radius=0.008), Line(0.92 * polar_to_point(x - 0.08), polar_to_point(x - 0.08), color=angle_color)], [Line(0.925 * polar_to_point(y), 0.925 * polar_to_point(y - 0.08), color=angle_color), Dot(0.925 * polar_to_point(y - 0.08), color=angle_color, radius=0.008), Line(0.92 * polar_to_point(y - 0.08), polar_to_point(y - 0.08), color=angle_color)]] for [x, y] in phis]\n        right_angles_shifted = [[[l1.scale(scale_back).move_to(l1.get_center() * scale_back).shift(poincare_origin), p.scale(scale_back).move_to(p.get_center() * scale_back).shift(poincare_origin), l2.scale(scale_back).move_to(l2.get_center() * scale_back).shift(poincare_origin)], [m1.scale(scale_back).move_to(m1.get_center() * scale_back).shift(poincare_origin), q.scale(scale_back).move_to(q.get_center() * scale_back).shift(poincare_origin), m2.scale(scale_back).move_to(m2.get_center() * scale_back).shift(poincare_origin)]] for [[l1, p, l2], [m1, q, m2]] in right_angles]\n        point_coords = [0, -0.3, 0]\n        p_point = Dot(point_coords)\n        p_point.move_to(p_point.get_center() * scale_back).shift(poincare_origin)\n        p_point_text = Tex('$P$').scale(0.8).next_to(p_point, direction=UP + 0.2 * RIGHT)\n        point_geodesic_point_phis = [0, 2.3, 2.9, 3.15, 3.4, 3.8, 4.1, 4.5, 5]\n        p_point_geodesic_points = [polar_to_point(x) for x in point_geodesic_point_phis]\n        p_point_geodesics_both_points = [get_both_intersections_line_with_unit_circle(x, tf_poincare_to_klein(point_coords)) for x in p_point_geodesic_points]\n        p_point_geodesics = [HyperbolicArcBetweenPoints(points[0], points[1], color=MY_BLUE) for points in p_point_geodesics_both_points]\n        p_point_moved_geodesics = [geo.scale(scale_back).move_to(geo.get_center() * scale_back).shift(poincare_origin) for geo in p_point_geodesics]\n        p_moving_dot = Dot(poincare_origin)\n        p_moving_text = Tex('$P$', font_size=25).next_to(p_moving_dot, 0.5 * RIGHT + 0.6 * UP, buff=0)\n        p_moving_dot_phi = 5 * PI / 3\n        norm_factor = 6 / pow(PI, 2)\n        p_origin = Dot(poincare_origin)\n        p_origin_text = Tex('0', font_size=25).next_to(p_origin, LEFT, buff=0.1)\n        p_current_point = np.array(center)\n        p_distance_text = Tex('$\\\\mathrm{dist}(0,P) = $ ', font_size=30).next_to(pcircle, buff=0.2)\n        p_distance_number = DecimalNumber(0.0, num_decimal_places=2, show_ellipsis=True, group_with_commas=False, font_size=35).next_to(p_distance_text, buff=0.15)\n        label = VGroup(p_distance_text, p_distance_number)\n        p_distance_infty = Tex('$\\\\infty$', font_size=30).next_to(p_distance_text, buff=0.15)\n        p_distance_tracker = ValueTracker(0.0)\n        self.add_subcaption('Es gibt verschiedene Modelle f\u00fcr die hyperbolische Ebene.', duration=3)\n        self.play(Write(title), run_time=2)\n        self.add_foreground_mobject(title)\n        self.wait(1)\n        self.add_subcaption('Solche Modelle sind einfach Abbildungen von der hyperbolischen in die euklidische Ebene', duration=5)\n        self.wait(5)\n        self.add_subcaption('Wir besch\u00e4ftigen uns genauer mit dem Poincare-', duration=3)\n        self.add_foreground_mobject(poincare_text)\n        self.play(Write(poincare_text), FadeIn(poincare_model), run_time=3)\n        self.add_subcaption('und dem Klein-Modell.', duration=3)\n        self.add_foreground_mobject(klein_text)\n        self.play(Write(klein_text), FadeIn(klein_model), run_time=3)\n        self.wait(3)\n        self.add_subcaption('Zuerst schauen wir uns das Poincare-Modell etwas genauer an.', duration=4)\n        self.add(pcircle)\n        self.play(self.camera.frame.animate.scale(0.8).move_to(np.add(poincare_origin, [0, 0.4, 0])), FadeOut(klein_model), FadeOut(klein_text), FadeOut(poincare_model), run_time=1.5)\n        self.wait(2.5)\n        self.add_subcaption('Die Darstellung der hyperbolischen Ebene im Poincare-Modell beschr\u00e4nkt sich auf die Einheitsscheibe', duration=6)\n        self.wait(3)\n        self.play(Indicate(pcircle, color=MY_BLUE, scale_factor=1.1))\n        self.wait(2)\n        self.add_subcaption('Die Geod\u00e4tischen des Poincare-Modells sind - im Gegensatz zu Geraden im Euklidischen - ', duration=5)\n        self.play(Create(p_geodesics[0]))\n        self.play(Create(p_geodesics[1]))\n        self.play(Create(p_geodesics[2]))\n        self.play(Create(p_geodesics[3]))\n        self.add_foreground_mobjects(*p_geodesics)\n        self.play(*[Create(right_angles_shifted[i][j][0]) for i, j in product(range(4), range(2))], run_time=0.5, rate_func=lambda x: x)\n        self.add(*[right_angles_shifted[i][j][1] for i, j in product(range(4), range(2))])\n        self.play(*[Create(right_angles_shifted[i][j][2]) for i, j in product(range(4), range(2))], run_time=0.5, rate_func=lambda x: x)\n        self.add_subcaption('Kreissegmente, die den Einheitskreis im rechten Winkel schneiden', duration=4)\n        self.wait(4)\n        self.add_subcaption('Damit wird klar, dass das Parallelenaxiom hier nicht gilt:', duration=4)\n        self.play(*[Uncreate(right_angles_shifted[i][j][2]) for i, j in product(range(4), range(2))], run_time=0.5, rate_func=lambda x: 1 - x)\n        self.remove(*[right_angles_shifted[i][j][1] for i, j in product(range(4), range(2))])\n        self.play(*[Uncreate(right_angles_shifted[i][j][0]) for i, j in product(range(4), range(2))], run_time=0.5, rate_func=lambda x: 1 - x)\n        self.play(Uncreate(p_geodesics[1], run_time=2), Uncreate(p_geodesics[2], run_time=2), Uncreate(p_geodesics[3], run_time=2), Create(p_point, run_time=1), Write(p_point_text, run_time=1))\n        self.wait(2)\n        self.add_subcaption('F\u00fcr einen Punkt P und eine Geod\u00e4tische findet man', duration=3)\n        self.add_foreground_mobject(p_point)\n        self.add_foreground_mobject(p_point_text)\n        self.wait(3)\n        self.add_subcaption('beliebig viele andere Geod\u00e4tische, die P, aber nicht die urspr\u00fcngliche Geod\u00e4tische schneiden.', duration=6)\n        self.play(Create(p_point_moved_geodesics[0]))\n        self.play(Create(p_point_moved_geodesics[1]))\n        self.play(Create(p_point_moved_geodesics[2]))\n        self.play(Create(p_point_moved_geodesics[3]))\n        self.play(Create(p_point_moved_geodesics[4]))\n        self.play(Create(p_point_moved_geodesics[5]))\n        self.play(Create(p_point_moved_geodesics[6]))\n        self.add_subcaption('Auch wenn es auf den ersten Blick so scheint, ist die hyperbolische Ebene keineswegs beschr\u00e4nkt.', duration=6)\n        self.wait(2)\n        self.play(Uncreate(p_geodesics[0]), Uncreate(p_point_moved_geodesics[0]), Uncreate(p_point_moved_geodesics[1]), Uncreate(p_point_moved_geodesics[2]), Uncreate(p_point_moved_geodesics[3]), Uncreate(p_point_moved_geodesics[4]), Uncreate(p_point_moved_geodesics[5]), Uncreate(p_point_moved_geodesics[6]), Uncreate(p_point), Unwrite(p_point_text))\n        self.wait(3)\n        self.add_subcaption('Lassen wir einen Punkt in der hyperbolischen Ebene mit konstanter Geschwindigkeit in eine Richtung laufen, so sehen wir, dass dieser den Rand des Poincare-Modell nie erreicht.', duration=12)\n        self.play(Create(p_moving_dot), Create(p_origin), Write(p_distance_text), Write(p_origin_text), Write(p_moving_text))\n        self.play(Write(p_distance_number))\n        self.wait(4)\n        p_distance_number.add_updater(lambda d: d.set_value(p_distance_tracker.get_value()))\n        steps = 30\n        frames = 420\n        duration = 7\n        frame_rate = duration / frames\n        batch_size = frames / steps\n        offset = 0\n        for t in range(1, frames):\n            if batch_size == 1:\n                r = t\n            else:\n                r = 1 + int(t / batch_size)\n            if t % batch_size == 1 or batch_size == 1:\n                offset = np.array(polar_to_point(p_moving_dot_phi, norm_factor / (batch_size * pow(r, 2))))\n            p_current_point = p_current_point + offset\n            pos = p_current_point * scale_back + np.array(poincare_origin)\n            moving_dot = Dot(pos, radius=0.08)\n            p_distance_number.font_size = 35\n            p_distance_tracker.set_value(np.exp(hyperbolic_distance_function(center, p_current_point)))\n            label.arrange(buff=0.15)\n            label.next_to(pcircle, buff=0.2)\n            p_moving_text.next_to(p_moving_dot, 0.5 * RIGHT + 0.6 * UP, buff=0)\n            self.play(Transform(p_moving_dot, moving_dot), run_time=frame_rate, rate_func=lambda a: a)\n            self.remove(p_moving_dot)\n            p_moving_dot = moving_dot\n        label.arrange(buff=0.05)\n        label.next_to(pcircle, buff=0.2)\n        self.add_subcaption('Der Einheitskreis liegt im Unendlichen und geh\u00f6rt nicht zum Poincare-Modell', duration=5)\n        moving_dot = Dot(polar_to_point(p_moving_dot_phi) * scale_back + np.array(poincare_origin))\n        self.play(Transform(p_moving_dot, moving_dot), FadeOut(p_distance_number), FadeIn(p_distance_infty), FadeOut(p_moving_text), run_time=0.25)\n        self.wait(4)\n        self.play(FadeOut(p_moving_dot), FadeOut(p_distance_infty), FadeOut(p_distance_text))\n        self.add_subcaption('Zum weiteren Verst\u00e4ndnis ist folgende Darstellung der Verzerrung hilfreich', duration=5)\n        self.wait(3)\n        self.play(FadeIn(poincare_model), FadeOut(pcircle), run_time=2)\n        self.add_subcaption('Dies ist eine Parkettierung der hyperbolischen Ebene. All diese Dreiecke haben die gleiche Form und Fl\u00e4che im Hyperbolischen.', duration=8)\n        self.play(Create(ptri1), run_time=2)\n        self.play(Write(ptri1_text.shift(0.6 * LEFT + 0.15 * DOWN)))\n        self.wait(1)\n        self.play(Create(ptri2), run_time=2)\n        self.play(Write(ptri2_text.shift(0.8 * LEFT + 0.07 * UP)))\n        self.wait(1)\n        self.play(Write(ptri_size_text), run_time=2)\n        self.add_subcaption('Das Poincare-Modell liefert also eine stark verzerrte Darstellung des hyperbolischen Raumes.', duration=6)\n        self.wait(4)\n        self.play(Uncreate(ptri1), Uncreate(ptri2), Unwrite(ptri1_text), Unwrite(ptri2_text), Unwrite(ptri_size_text), run_time=2)\n        self.play(self.camera.frame.animate.scale(1.25).move_to(center), FadeIn(klein_model), FadeIn(klein_text))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate a demonstration of the Klein and Poincar\u00e9 models of the hyperbolic plane, showing their differences and transformations between them."}, {"role": "assistant", "content": "from itertools import product\nimport numpy as np\nfrom manim import Circle, Dot, Create, FadeIn, Line, Transform, MovingCameraScene, Flash, YELLOW, Text, UP, Write, DOWN, Tex, WHITE, PURPLE, GREY, Uncreate, AnimationGroup, Unwrite, ImageMobject, LEFT, RIGHT, MarkupText, Polygon, PI, DecimalNumber, ValueTracker, Arrow, VGroup, FadeOut, Indicate, ReplacementTransform, BLACK, VMobject, GREEN_B, ORANGE, DARK_GREY, RED, LIGHT_GRAY\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, tf_klein_to_poincare, get_intersections_of_n_tangent_circles, get_intersections_of_circles_with_unit_circle, get_intersection_from_angles, get_parallel_to_line_through_point, tf_poincare_to_klein, get_both_intersections_line_with_unit_circle, get_intersection, hyperbolic_distance_function\nfrom hexagon import HexagonCircles, HexagonMainDiagonals, HyperbolicArcBetweenPoints, HexagonAngles\nfrom hyperbolic_polygon import HyperbolicPolygon\n\nclass HyperbolicModelsKlein(MovingCameraScene):\n\n    def construct(self):\n        center = np.array([0, 0, 0])\n        klein_origin = np.array([3.5, -1, 0])\n        poincare_origin = np.array([-3.5, -1, 0])\n        MY_BLUE = '#22c1dd'\n        title = MarkupText('Models for the hyperbolic plane').scale(0.8).shift(3.5 * UP)\n        klein_model = ImageMobject('tessellation_klein.png').scale(0.7).move_to(klein_origin)\n        klein_text = Text('Klein model').scale(0.6).move_to(3.5 * RIGHT + 2.2 * UP)\n        poincare_model = ImageMobject('tessellation_poincare.png').scale(0.7).move_to(poincare_origin)\n        poincare_text = Text('Poincar\u00e9 model').scale(0.6).move_to(3.5 * LEFT + 2.2 * UP)\n        title2 = Text('Transformations between hyperbolic models').scale(0.75).shift(3.5 * UP)\n        scale_back = 2.5\n        phis = [[0.4, 2], [1.3, 6], [3.5, 5], [4, 1.5]]\n        k1 = np.array([[0, 0, 0], [2, 0, 0], [1.24, 1.58, 0]])\n        k2 = np.array([[-0.46, 1.95, 0], [-1.79, 0.89, 0], [-1.49, 1.86, 0]])\n        raw_ktri1 = Polygon(*k1, color=YELLOW, stroke_width=1.5).shift(klein_origin)\n        kpoints1 = [Dot(np.add(p, klein_origin), color=YELLOW, radius=0.06) for p in k1]\n        raw_ktri2 = Polygon(*k2, color=YELLOW, stroke_width=1.5).shift(klein_origin)\n        kpoints2 = [Dot(np.add(p, klein_origin), color=YELLOW, radius=0.06) for p in k2]\n        kcircle = Circle(color=MY_BLUE, stroke_width=1).scale(scale_back).move_to(klein_origin)\n        pcircle = Circle(color=MY_BLUE, stroke_width=1).scale(scale_back).move_to(poincare_origin)\n        p_geodesics_raw = [HyperbolicArcBetweenPoints(polar_to_point(x), polar_to_point(y)) for [x, y] in phis]\n        p_geodesics = [geo.scale(scale_back).move_to(geo.get_center() * scale_back).shift(poincare_origin) for geo in p_geodesics_raw]\n        k_geodesics_raw = [Line(polar_to_point(x), polar_to_point(y)) for [x, y] in phis]\n        k_geodesics = [geo.scale(scale_back).move_to(geo.get_center() * scale_back).shift(klein_origin) for geo in k_geodesics_raw]\n        point_coords = [0, -0.3, 0]\n        point_geodesic_point_phis = [0, 2.3, 2.9, 3.15, 3.4, 3.8, 4.1, 4.5, 5]\n        k_point = Dot(point_coords)\n        k_point.move_to(k_point.get_center() * scale_back).shift(klein_origin)\n        k_point_text = Tex('$P$').scale(0.8).next_to(k_point, direction=UP + 0.2 * RIGHT)\n        k_point_geodesics_intersections = [get_both_intersections_line_with_unit_circle(point_coords, polar_to_point(phi)) for phi in point_geodesic_point_phis]\n        k_point_geodesics_raw = [Line(x, y, color=MY_BLUE) for [x, y] in k_point_geodesics_intersections]\n        k_point_geodesics = [l.scale(scale_back).move_to(l.get_center() * scale_back).shift(klein_origin) for l in k_point_geodesics_raw]\n        ktri1_text = Tex('$\\\\Delta_1$').next_to(raw_ktri1, LEFT).scale(0.6).shift(1.6 * RIGHT + 0.2 * DOWN)\n        ktri2_text = Tex('$\\\\Delta_2$').next_to(raw_ktri2, LEFT).scale(0.6).shift(1.05 * RIGHT + 0.2 * UP)\n        ktri_size_text = Tex('$A(\\\\Delta_1) = A(\\\\Delta_2)$', font_size=37).next_to(kcircle, LEFT, buff=0.35)\n        arrow_lr = Arrow(start=2.5 * LEFT, end=2.5 * RIGHT, stroke_width=4, max_tip_length_to_length_ratio=0.5)\n        arrow_rl = Arrow(start=2.5 * RIGHT, end=2.5 * LEFT, stroke_width=4, max_tip_length_to_length_ratio=0.5)\n        arrow_group = VGroup(arrow_lr, arrow_rl).arrange(DOWN)\n        arrow_group.shift(DOWN)\n        f_text = Tex('$f$', font_size=40).next_to(arrow_lr, UP, buff=0)\n        f_inv_text = Tex('$f^{-1}$', font_size=40).next_to(arrow_rl, DOWN, buff=0)\n        f_formula = Tex('$f(x,y) = \\\\frac{1}{1+\\\\sqrt{1-x^2-y^2}}(x,y)$', font_size=40).move_to(0.5 * UP)\n        f_inv_formula = Tex('$f^{-1}(x,y) = \\\\frac{1}{1+x^2+y^2}(2x,2y)$', font_size=40).move_to(2.5 * DOWN)\n        p_geo0 = p_geodesics[0].copy()\n        p_geo0 = p_geo0.shift(-poincare_origin).scale(0.7).move_to(p_geo0.get_center() * 0.7).shift(poincare_origin + 1.5 * LEFT)\n        p_geo0_copy = p_geo0.copy()\n        p_geo1 = p_geodesics[1].copy()\n        p_geo1 = p_geo1.shift(-poincare_origin).scale(0.7).move_to(p_geo1.get_center() * 0.7).shift(poincare_origin + 1.5 * LEFT)\n        k_geo0 = k_geodesics[0].copy()\n        k_geo0 = k_geo0.shift(-klein_origin).scale(0.7).move_to(k_geo0.get_center() * 0.7).shift(klein_origin + 1.5 * RIGHT)\n        k_geo1 = k_geodesics[1].copy()\n        k_geo1 = k_geo1.shift(-klein_origin).scale(0.7).move_to(k_geo1.get_center() * 0.7).shift(klein_origin + 1.5 * RIGHT)\n        k_geo1_copy = k_geo1.copy()\n        k_geo_intersect_coords = get_intersection_from_angles(phis[0][0], phis[0][1], phis[1][0], phis[1][1])\n        p_geo_intersect_coords = tf_klein_to_poincare(k_geo_intersect_coords)\n        k_geo_intersect_raw = Dot(k_geo_intersect_coords, color=YELLOW, radius=0.075)\n        k_geo_intersect_moved = k_geo_intersect_raw.move_to(k_geo_intersect_raw.get_center() * 1.75).shift(klein_origin + 1.5 * RIGHT)\n        p_geo_intersect_raw = Dot(p_geo_intersect_coords, color=YELLOW, radius=0.075)\n        p_geo_intersect_moved = p_geo_intersect_raw.move_to(p_geo_intersect_raw.get_center() * 1.75).shift(poincare_origin + 1.5 * LEFT)\n        self.add(title, poincare_text, poincare_model, klein_text, klein_model)\n        self.add_subcaption('Nun betrachten wir das Klein-Modell. Wir werden starke \u00c4hnlichkeiten zum Poincare-Modell erkennen.', duration=7)\n        self.wait(4)\n        self.add(kcircle)\n        self.play(self.camera.frame.animate.scale(0.8).move_to(np.add(klein_origin, [0, 0.4, 0])), FadeOut(poincare_model), FadeOut(poincare_text), FadeOut(klein_model))\n        self.wait(2)\n        self.add_subcaption('Der gr\u00f6\u00dfte Unterschied ist, dass Geod\u00e4tische hier tats\u00e4chlich euklidischen Geraden entsprechen.', duration=6)\n        self.play(Create(k_geodesics[0]))\n        self.play(Create(k_geodesics[1]))\n        self.play(Create(k_geodesics[2]))\n        self.play(Create(k_geodesics[3]))\n        self.wait(2)\n        self.play(Uncreate(k_geodesics[1]), Uncreate(k_geodesics[2]), Uncreate(k_geodesics[3]), Create(k_point), Write(k_point_text))\n        self.add_subcaption('Da diese aber wie im Poincare-Modell durch den Einheitskreis beschr\u00e4nkt werden, gilt das Parallelenaxiom auch hier nicht.', duration=7)\n        self.add_foreground_mobject(k_point)\n        self.add_foreground_mobject(k_point_text)\n        self.wait(2)\n        self.play(Create(k_point_geodesics[0]))\n        self.play(Create(k_point_geodesics[1]))\n        self.play(Create(k_point_geodesics[2]))\n        self.play(Create(k_point_geodesics[3]))\n        self.play(Create(k_point_geodesics[4]))\n        self.play(Create(k_point_geodesics[5]))\n        self.wait(2)\n        self.play(Uncreate(k_geodesics[0]), Uncreate(k_point_geodesics[0]), Uncreate(k_point_geodesics[1]), Uncreate(k_point_geodesics[2]), Uncreate(k_point_geodesics[3]), Uncreate(k_point_geodesics[4]), Uncreate(k_point_geodesics[5]), Uncreate(k_point), Unwrite(k_point_text))\n        self.add_subcaption('Ebenso gibt es im Klein-Modell eine starke Verzerrung des Raumes', duration=4)\n        self.wait(3)\n        self.play(FadeIn(klein_model), FadeOut(kcircle))\n        self.add_subcaption('Hier sehen wir die gleiche Parkettierung der hyperbolischen Ebene im Klein-Modell.', duration=6)\n        self.play(Create(kpoints1[0]), Create(kpoints1[1]), Create(kpoints1[2]))\n        self.play(Create(raw_ktri1), run_time=2)\n        self.play(Write(ktri1_text))\n        self.wait(1)\n        self.play(Create(kpoints2[0]), Create(kpoints2[1]), Create(kpoints2[2]))\n        self.play(Create(raw_ktri2), run_time=2)\n        self.play(Write(ktri2_text))\n        self.wait(1)\n        self.add_subcaption('Zum Rand hin werden Distanzen auch hier immer gr\u00f6\u00dfer', duration=4)\n        self.play(Write(ktri_size_text), run_time=2)\n        self.wait(4)\n        self.play(Uncreate(raw_ktri1), Uncreate(kpoints1[0]), Uncreate(kpoints1[1]), Uncreate(kpoints1[2]), Uncreate(raw_ktri2), Uncreate(kpoints2[0]), Uncreate(kpoints2[1]), Uncreate(kpoints2[2]), Unwrite(ktri1_text), Unwrite(ktri2_text), Unwrite(ktri_size_text), run_time=2)\n        self.wait(2)\n        self.play(self.camera.frame.animate.scale(1.25).move_to(center), FadeIn(poincare_model), FadeIn(poincare_text))\n        self.add_subcaption('Da beide Modelle den gleichen Raum darstellen, ist es naheliegend, dass es Abbildungen gibt, die die Punkte der Modelle miteinander identifizieren.', duration=8)\n        self.wait(1)\n        self.play(Transform(title, title2))\n        self.wait(2)\n        self.play(poincare_model.animate.scale(0.7).shift(1.5 * LEFT), klein_model.animate.scale(0.7).shift(1.5 * RIGHT), poincare_text.animate.shift(1.5 * LEFT + 0.5 * DOWN), klein_text.animate.shift(1.5 * RIGHT + 0.5 * DOWN))\n        self.add(pcircle.scale(0.7).shift(1.5 * LEFT), kcircle.scale(0.7).shift(1.5 * RIGHT))\n        self.wait(3)\n        self.add_subcaption('Tats\u00e4chlich gibt es diese, wir nennen sie f und f^-1. ', duration=4)\n        self.play(Write(arrow_group))\n        self.wait(3)\n        self.play(Write(f_text), Write(f_inv_text))\n        self.add_subcaption('Wie wir hier sehen, sind die Formeln f\u00fcr diese Abbildungen ziemlich einfach.', duration=4)\n        self.wait(2)\n        self.play(Write(f_formula))\n        self.wait(1)\n        self.play(Write(f_inv_formula))\n        self.wait(5)\n        self.add_subcaption('Mit f und f^-1 k\u00f6nnen wir jetzt Objekte aus dem einen Modell ins andere \u00fcbertragen. Insbesondere Geod\u00e4tische.', duration=7)\n        self.play(Create(p_geo0), FadeOut(poincare_model))\n        self.add(p_geo0_copy)\n        self.wait(2)\n        self.play(Transform(p_geo0, k_geo0), FadeOut(klein_model), Indicate(f_text))\n        self.wait(1)\n        self.play(Create(k_geo1))\n        self.add(k_geo1_copy)\n        self.wait(1)\n        self.play(Transform(k_geo1, p_geo1), Indicate(f_inv_text))\n        self.add_subcaption('Da die Abbildungen punktweise agieren, bleiben Schnittpunkte zwischen Geod\u00e4tischen erhalten.', duration=6)\n        self.wait(2)\n        self.play(Create(k_geo_intersect_moved), Create(p_geo_intersect_moved), Flash(k_geo_intersect_moved), Flash(p_geo_intersect_moved))\n        self.wait(3)\n        self.add_subcaption('Das liefert uns jetzt die folgende Umformulierung des Sieben-Kreise-Satzes.', duration=4)\n        everything = VGroup(*filter(lambda x: isinstance(x, VMobject), self.mobjects))\n        self.wait(3)\n        endDot = Dot(color=BLACK)\n        self.play(Transform(everything, endDot))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Illustrate the Seven Circles Theorem in hyperbolic geometry, showing the construction of the hexagon, inner and outer circles, their intersection points, and the diagonals meeting at a point, followed by a transformation to the Euclidean model."}, {"role": "assistant", "content": "from itertools import product\nimport numpy as np\nfrom manim import Circle, Dot, Create, FadeIn, Line, Transform, MovingCameraScene, Flash, YELLOW, Text, UP, Write, DOWN, Tex, WHITE, PURPLE, GREY, Uncreate, AnimationGroup, Unwrite, ImageMobject, LEFT, RIGHT, MarkupText, Polygon, PI, DecimalNumber, ValueTracker, Arrow, VGroup, FadeOut, Indicate, ReplacementTransform, BLACK, VMobject, GREEN_B, ORANGE, DARK_GREY, RED, LIGHT_GRAY\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, tf_klein_to_poincare, get_intersections_of_n_tangent_circles, get_intersections_of_circles_with_unit_circle, get_intersection_from_angles, get_parallel_to_line_through_point, tf_poincare_to_klein, get_both_intersections_line_with_unit_circle, get_intersection, hyperbolic_distance_function\nfrom hexagon import HexagonCircles, HexagonMainDiagonals, HyperbolicArcBetweenPoints, HexagonAngles\nfrom hyperbolic_polygon import HyperbolicPolygon\n\nclass SevenCirclesHyperbolic(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 9\n        OUTER_CIRCLE_COLOR = WHITE\n        INNER_CIRCLE_COLOR = GREEN_B\n        INNER_INTERSECTION_COLOR = PURPLE\n        OUTER_INTERSECTION_COLOR = DARK_GREY\n        HEXAGON_COLOR = GREY\n        DIAGONAL_COLOR = ORANGE\n        DIAGONAL_INTERSECTION_COLOR = YELLOW\n        title = Text('The hyperbolic Seven Circles Theorem').scale(0.8)\n        theorem_text_colored = Tex('Let $C\\\\ $be a circle ', 'containing six smaller circles, ', 'such that each inner circle is tangent to $C$ ', 'and any two adjacent inner circles are tangent. ', 'Let there also be a hyperbolic hexagon formed by the intersection points of each inner cicle and $C$. ', 'Then the three hyperbolic diagonals will always meet at a single point.', '', substrings_to_isolate=['$C\\\\ $', 'six smaller circles', 'tangent to $C$', 'adjacent inner circles are tangent', 'hyperbolic hexagon', 'hyperbolic diagonals', 'single point'], stroke_width=0.05).set_color_by_tex('$C\\\\ $', OUTER_CIRCLE_COLOR).set_color_by_tex('six smaller circles', INNER_CIRCLE_COLOR).set_color_by_tex('tangent to $C$', OUTER_INTERSECTION_COLOR).set_color_by_tex('adjacent inner circles are tangent', INNER_INTERSECTION_COLOR).set_color_by_tex('hyperbolic hexagon', HEXAGON_COLOR).set_color_by_tex('hyperbolic diagonals', DIAGONAL_COLOR).set_color_by_tex('single point', DIAGONAL_INTERSECTION_COLOR).scale(0.5).move_to([0, -2, 0])\n        theorem_text_white = Tex('Let $C\\\\ $be a circle ', 'containing six smaller circles, ', 'such that each inner circle is tangent to $C$ ', 'and any two adjacent inner circles are tangent. ', 'Let there also be a hyperbolic hexagon formed by the intersection points of each inner cicle and $C$. ', 'Then the three hyperbolic diagonals will always meet at a single point.', '', stroke_width=0.05).scale(0.5).move_to([0, -2, 0])\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=2)\n        phis = HexagonAngles(np.array([0.3, 1.6, 2.2, 3, 4.3]))\n        first_circle_radius = 0.4\n        hexagon = HyperbolicPolygon([polar_to_point(phi) for phi in phis], color=HEXAGON_COLOR, dot_color=OUTER_INTERSECTION_COLOR, stroke_width=2)\n        hexagon_circles = HexagonCircles(hexagon, first_circle_radius, stroke_width=2, color=INNER_CIRCLE_COLOR)\n        inner_intersections = get_intersections_of_n_tangent_circles(hexagon_circles.circles, color=INNER_INTERSECTION_COLOR)\n        outer_intersections = get_intersections_of_circles_with_unit_circle(hexagon_circles.circles, color=OUTER_INTERSECTION_COLOR)\n        diagonals = HexagonMainDiagonals(hexagon, color=DIAGONAL_COLOR, stroke_width=2)\n        diagonal_intersection = Dot(tf_klein_to_poincare(get_intersection_from_angles(phis[0], phis[3], phis[1], phis[4])), color=DIAGONAL_INTERSECTION_COLOR, radius=0.05)\n        eucl_hexagon = EuclideanHexagon(phis, color=HEXAGON_COLOR, stroke_width=2)\n        eucl_diagonals = get_diagonals(hexagon, color=DIAGONAL_COLOR, stroke_width=2)\n        eucl_intersection = Dot(get_intersection_from_angles(phis[0], phis[3], phis[1], phis[4]), color=DIAGONAL_INTERSECTION_COLOR, radius=0.05)\n        self.camera.frame.shift(0.8 * DOWN)\n        self.play(Write(title.shift(1.4 * UP).scale(0.7)))\n        self.wait(2)\n        self.add_subcaption('Sei C_0 ein Kreis', duration=2)\n        self.play(Write(theorem_text_white[0], run_time=2))\n        self.play(FadeIn(circle), FadeIn(theorem_text_colored[1]))\n        self.add_foreground_mobject(circle)\n        self.add_subcaption('und C_1,...,C_6 in C_0 enthaltene Kreise', duration=4)\n        self.play(Write(theorem_text_white[1], run_time=3))\n        self.play(Create(hexagon_circles, run_time=4), FadeIn(theorem_text_colored[4], run_time=1))\n        self.remove_foreground_mobjects(circle)\n        self.add_subcaption('sodass jeder innere Kreis zum \u00e4u\u00dferen Kreis tangential ist', duration=5)\n        self.play(Write(theorem_text_white[2], run_time=3))\n        self.play(FadeIn(theorem_text_colored[7]))\n        self.play(Create(outer_intersections[0]), Create(outer_intersections[1]), Create(outer_intersections[2]), Create(outer_intersections[3]), Create(outer_intersections[4]), Create(outer_intersections[5]), run_time=1)\n        self.add_foreground_mobjects(*outer_intersections)\n        self.add_subcaption('und je zwei nebeneinanderliegende innere Kreise ebenfalls zueinander tangential sind.', duration=7)\n        self.play(Write(theorem_text_white[3]), run_time=6)\n        self.play(FadeIn(theorem_text_colored[10]))\n        self.play(Create(inner_intersections[0]), Create(inner_intersections[1]), Create(inner_intersections[2]), Create(inner_intersections[3]), Create(inner_intersections[4]), Create(inner_intersections[5]), run_time=1)\n        for i in range(6):\n            self.add_foreground_mobject(inner_intersections[i])\n        self.add_subcaption('Dann treffen sich die drei hyperbolischen Diagonalen des hyperbolischen Hexagons, das von den Schnittpunkten der inneren Kreise mit dem \u00e4u\u00dferen Kreis gebildet wird,', duration=10)\n        self.play(Write(theorem_text_white[4]), run_time=8)\n        self.play(Create(hexagon, run_time=5), FadeIn(theorem_text_colored[13], run_time=1))\n        self.add_subcaption('in einem Punkt', duration=3)\n        self.play(Write(theorem_text_white[5]), run_time=3)\n        self.play(FadeIn(theorem_text_colored[16]))\n        for x in diagonals:\n            self.play(Create(x), run_time=1)\n        self.play(FadeIn(theorem_text_colored[18], run_time=1))\n        self.play(Create(diagonal_intersection))\n        self.wait(1)\n        self.play(Flash(diagonal_intersection))\n        self.add_subcaption('Wenn wir diesen Satz bewiesen haben, wenden wir einfach die Transformation vom Poincare- zum Klein-Modell an', duration=6)\n        self.wait(3)\n        self.play(*[ReplacementTransform(hexagon.arcs[i], eucl_hexagon.edges[i]) for i in range(6)], ReplacementTransform(diagonals.arc1, eucl_diagonals[0].reverse_direction()), ReplacementTransform(diagonals.arc2, eucl_diagonals[1].reverse_direction()), ReplacementTransform(diagonals.arc3, eucl_diagonals[2].reverse_direction()), ReplacementTransform(diagonal_intersection, eucl_intersection), run_time=3)\n        self.add_subcaption('und haben somit auch den urspr\u00fcnglichen Satz bewiesen.', duration=4)\n        self.wait(4)\n        everything = VGroup()\n        for mob in self.mobjects:\n            if isinstance(mob, VMobject):\n                everything.add(mob)\n        endDot = Dot(color=BLACK)\n        self.add(endDot)\n        self.play(Transform(everything, endDot), run_time=2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Demonstrate the definitions and visual representations of Euclidean and hyperbolic space, including circles and distances, and animate movement within each space."}, {"role": "assistant", "content": "from math import pi\nfrom manim import *\nfrom manim import Scene, Square, Circle, Dot, Group, Text, Create, FadeIn, FadeOut, MoveAlongPath, Line, BLUE, Transform, MovingCameraScene, Uncreate, VGroup, Tex, MathTex, Write, RED, NumberPlane\nfrom animation_constants import *\nfrom geometry_util import moving_circle, moving_line, polar_to_point, tf_poincare_to_klein, get_both_intersections_line_with_unit_circle\nfrom hyperbolic_polygon import HyperbolicArcBetweenPoints\n\nclass Scene1(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 8\n        self.wait(4)\n        def_ball = MathTex('B(P,r)=\\\\{z:\\\\mathrm{dist}(z,P)= r\\\\}', font_size=20).move_to([0, -1.9, 0])\n        def_dist_eukl = MathTex('\\\\mathrm{dist_e}(b,c)=|c-b|', font_size=20).move_to([-2, -1.45, 0])\n        def_dist_hyp = MathTex('\\\\mathrm{dist_h}(b,c)=\\\\log \\\\frac{(a-c)(b-d)}{(a-b)(c-d)}', font_size=20).move_to([2, -1.45, 0])\n        radius_tex = MathTex('r', font_size=18, color=RED)\n        title_hyp = Tex('Hyperbolic space', font_size=25, stroke_width=0.5).move_to([2, 1.7, 0])\n        subtitle_hyp = Tex('Poincar\u00e9 model', font_size=18, stroke_width=0.5).move_to([2, 1.5, 0])\n        title_eucl = Tex('Euclidean space', font_size=25, stroke_width=0.5).move_to([-2, 1.7, 0])\n        black_background = Rectangle(width=3, height=0.5, color=BLACK, fill_opacity=1).move_to([0, -1.9, 0])\n        white_rectangle = Rectangle(width=3, height=0.5, color=WHITE, stroke_width=2).move_to([0, -1.9, 0])\n        self.play(Write(title_hyp))\n        self.play(Write(subtitle_hyp))\n        separating_line = Line(start=[0, 8, 0], end=[0, -3, 0], stroke_width=2)\n        self.play(FadeIn(separating_line))\n        self.add_foreground_mobjects(title_eucl)\n        self.play(Write(title_eucl))\n        self.wait(2)\n        eucl_dot = Dot([-2, 0, 0], color=WHITE, radius=0.03, stroke_width=2)\n        eucl_dot_tex = MathTex('P', font_size=20).move_to([-1.9, 0.1, 0])\n        eucl_circles = [Circle(arc_center=[-2, 0, 0], color=BLUE_A, stroke_width=2, radius=0.25), Circle(arc_center=[-2, 0, 0], color=BLUE, stroke_width=2, radius=0.5), Circle(arc_center=[-2, 0, 0], color=BLUE_E, stroke_width=2, radius=0.75)]\n        eucl_mov_points = np.array([[-2, 0, 0], [-2.5, 0, 0], [-3, 0, 0], [-1.5, 0, 0]])\n        radius_red = Line(start=[-2, 0, 0], end=[-1.25, 0, 0], color=RED, stroke_width=2)\n        grid = NumberPlane(x_range=[-8, -2, 0.25], y_range=[1, 9, 0.25], background_line_style={'stroke_color': GREY, 'stroke_width': 0.5}).move_to([-3, 0, 0])\n        self.play(FadeIn(grid))\n        self.play(FadeIn(black_background), Create(white_rectangle))\n        self.play(Write(def_ball))\n        self.play(FadeIn(eucl_dot), FadeIn(eucl_dot_tex))\n        self.add_foreground_mobjects(eucl_dot_tex)\n        self.add_foreground_mobjects(eucl_dot)\n        self.play(Create(eucl_circles[2]))\n        dot = Dot(radius=0.0)\n        dot.move_to(eucl_circles[2].point_from_proportion(0))\n        self.t_offset = 0\n\n        def get_line_to_circle():\n            return Line([-2, 0, 0], dot.get_center(), stroke_width=2, color=RED)\n\n        def go_around_circle(mob, dt):\n            self.t_offset += dt * 0.5\n            mob.move_to(eucl_circles[2].point_from_proportion(self.t_offset % 1))\n        dot.add_updater(go_around_circle)\n        origin_to_circle_line = always_redraw(get_line_to_circle)\n        self.play(Create(radius_red), FadeIn(radius_tex.next_to(radius_red, direction=0.3 * UP)))\n        self.wait(1)\n        self.remove(radius_red)\n        self.add(origin_to_circle_line)\n        self.add(dot)\n        self.play(FadeOut(radius_tex), run_time=0.5)\n        self.wait(1.51665)\n        self.add(radius_red)\n        dot.remove_updater(go_around_circle)\n        self.remove(origin_to_circle_line)\n        self.wait(2)\n        self.play(FadeOut(radius_red))\n        self.play(Create(eucl_circles[0]), Create(eucl_circles[1]))\n        circle_radius_group = VGroup(*eucl_circles, eucl_dot, eucl_dot_tex)\n        self.play(Write(def_dist_eukl))\n        self.wait(2)\n        self.wait(4)\n        self.play(Write(def_dist_hyp))\n        self.wait(2)\n        center = [2, 0, 0]\n        start_points = np.array([center, center, center, center])\n        length = [1 / 2, 1 / 2, -3 / 2]\n        angles = [0, pi / 4, 4 * pi / 3]\n        outer_circle = Circle(color=WHITE, radius=1, stroke_width=HEXAGON_STROKE_WIDTH).move_to(center)\n        self.add_foreground_mobjects(outer_circle)\n        circle = [Dot(color=WHITE, radius=0.04), Circle(color=BLUE_A, radius=0.25, stroke_width=2), Circle(color=BLUE, radius=0.5, stroke_width=2), Circle(color=BLUE_E, radius=0.75, stroke_width=2)]\n        circles = Group(circle[0], circle[1], circle[2], circle[3]).move_to(center)\n        self.play(FadeIn(outer_circle))\n        self.play(FadeIn(circle[0]))\n        self.add_foreground_mobjects(circle[0])\n        self.wait(duration=2)\n        self.play(Create(circle[1]), Create(circle[2]), Create(circle[3]))\n        self.wait(2)\n        for t in range(3):\n            end_points = np.array([start_points[0] - [1 * length[t], 0, 0], start_points[1] - [0.75 * length[t], 0, 0], start_points[2] - [0.5 * length[t], 0, 0], start_points[3] - [0.25 * length[t], 0, 0]])\n            lines = moving_line(start_points, end_points)\n            self.play(MoveAlongPath(circle_radius_group, Line(start=eucl_mov_points[t], end=eucl_mov_points[t + 1])), MoveAlongPath(circle[0], lines[0]), MoveAlongPath(circle[3], lines[3]), MoveAlongPath(circle[2], lines[2]), MoveAlongPath(circle[1], lines[1]), run_time=2)\n            self.wait(duration=1)\n            start_points = end_points\n        for t in range(2):\n            arcs = moving_circle(angles[t], angles[t + 1], center)\n            self.play(MoveAlongPath(circle_radius_group, Arc(start_angle=angles[t], angle=angles[t + 1], arc_center=[-2, 0, 0], radius=0.5)), MoveAlongPath(circle[0], arcs[0]), MoveAlongPath(circle[3], arcs[1]), MoveAlongPath(circle[2], arcs[2]), MoveAlongPath(circle[1], arcs[3]), run_time=2)\n            self.wait(duration=1)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])"}]}
{"messages": [{"role": "user", "content": "Visualize the hyperbolic distance formula by animating points moving along concentric circles and illustrating the calculation of distance using intersections with a unit circle."}, {"role": "assistant", "content": "from math import pi\nfrom manim import *\nfrom manim import Scene, Square, Circle, Dot, Group, Text, Create, FadeIn, FadeOut, MoveAlongPath, Line, BLUE, Transform, MovingCameraScene, Uncreate, VGroup, Tex, MathTex, Write, RED, NumberPlane\nfrom animation_constants import *\nfrom geometry_util import moving_circle, moving_line, polar_to_point, tf_poincare_to_klein, get_both_intersections_line_with_unit_circle\nfrom hyperbolic_polygon import HyperbolicArcBetweenPoints\n\nclass Scene2(MovingCameraScene):\n\n    def construct(self):\n        outer_circle = Circle(color=WHITE, radius=1, stroke_width=HEXAGON_STROKE_WIDTH)\n        circle = [Dot(color=WHITE, radius=0.04), Circle(color=BLUE_A, radius=0.25, stroke_width=2), Circle(color=BLUE, radius=0.5, stroke_width=2), Circle(color=BLUE_E, radius=0.75, stroke_width=2)]\n        def_dist_hyp = MathTex('\\\\mathrm{dist_h}(b,c)=\\\\log \\\\frac{(a-c)(b-d)}{(a-b)(c-d)}', font_size=20).move_to([2, -1.6, 0])\n        radius_tex = MathTex('r', font_size=18, color=RED)\n        self.play(self.camera.frame.animate.set(width=8).move_to([0, -0.8, 0]))\n        self.play(FadeIn(outer_circle))\n        self.add_foreground_mobjects(outer_circle)\n        self.play(FadeIn(circle[0].move_to(polar_to_point(19 * PI / 12, 0.5))), Create(circle[3].move_to(polar_to_point(19 * PI / 12, 0.125))))\n        self.add_foreground_mobjects(circle[0])\n        self.play(Write(def_dist_hyp.move_to([0, -2, 0])))\n        self.wait(2)\n        dot = Dot(radius=0.0)\n        dot.move_to(circle[3].point_from_proportion(0))\n        self.t_offset = 0\n\n        def get_line_to_circle_h():\n            return HyperbolicArcBetweenPoints(dot.get_center(), circle[0].get_center(), stroke_width=2, color=RED)\n\n        def go_around_circle_h(mob, dt):\n            self.t_offset += dt * 0.25\n            mob.move_to(circle[3].point_from_proportion(self.t_offset % 1))\n        start_radius = HyperbolicArcBetweenPoints(dot.get_center(), circle[0].get_center(), stroke_width=2, color=RED)\n        b = Dot(dot.get_center(), radius=0.05, color=ORANGE)\n        c = Dot(circle[0].get_center(), radius=0.05, color=ORANGE)\n        klein_point1 = tf_poincare_to_klein(dot.get_center())\n        klein_point2 = tf_poincare_to_klein(circle[0].get_center())\n        intersection1, intersection2 = get_both_intersections_line_with_unit_circle(klein_point1, klein_point2)\n        a = Dot(intersection1, radius=0.05, color=ORANGE)\n        d = Dot(intersection2, radius=0.05, color=ORANGE)\n        dot.add_updater(go_around_circle_h)\n        origin_to_circle_line = always_redraw(get_line_to_circle_h)\n        self.add_foreground_mobjects(circle[3])\n        self.play(Create(start_radius.reverse_direction()))\n        abcd_group = VGroup(a, b, c, d, MathTex('a', font_size=18, color=ORANGE), MathTex('b', font_size=18, color=ORANGE), MathTex('c', font_size=18, color=ORANGE), MathTex('d', font_size=18, color=ORANGE))\n        unit_arc = ArcBetweenPoints(a.get_center(), d.get_center(), color=RED, stroke_width=2)\n        self.add_foreground_mobjects(abcd_group[1])\n        self.remove_foreground_mobjects(circle[3])\n        self.play(FadeIn(abcd_group[1]), FadeIn(abcd_group[5].next_to(b, direction=0.05 * UP + 0.1 * LEFT)))\n        self.add_foreground_mobjects(abcd_group[2])\n        self.play(FadeIn(abcd_group[2]), FadeIn(abcd_group[6].next_to(c, direction=0.5 * LEFT)))\n        self.wait(5)\n        self.add_foreground_mobjects(abcd_group[0])\n        self.play(FadeIn(abcd_group[0]))\n        self.add_foreground_mobjects(abcd_group[3])\n        self.play(FadeIn(abcd_group[3]))\n        self.play(Create(unit_arc), FadeOut(start_radius))\n        self.wait(2)\n        self.play(FadeIn(abcd_group[4].next_to(a, direction=0.5 * RIGHT)), FadeIn(abcd_group[7].next_to(d, direction=0.5 * DOWN)))\n        self.wait(2)\n        self.play(Indicate(def_dist_hyp, color=ORANGE))\n        self.wait(1)\n        self.remove_foreground_mobjects(abcd_group[0], abcd_group[1], abcd_group[2], abcd_group[3], circle[0])\n        self.add(start_radius, circle[0], circle[3])\n        self.remove_foreground_mobjects(outer_circle)\n        self.add(unit_arc)\n        self.play(FadeOut(abcd_group), FadeOut(unit_arc), FadeIn(start_radius))\n        self.add_foreground_mobjects(circle[0], outer_circle)\n        self.wait(5)\n        self.play(FadeIn(radius_tex.next_to(start_radius, direction=0.15 * UP)))\n        self.wait(1)\n        self.play(FadeOut(radius_tex))\n        self.add_foreground_mobjects(circle[3])\n        self.remove(start_radius)\n        self.add(origin_to_circle_line)\n        self.add(dot)\n        self.wait(4.01)\n        dot.remove_updater(go_around_circle_h)\n        self.wait(2)\n        self.play(FadeOut(origin_to_circle_line), FadeOut(def_dist_hyp))\n        self.remove_foreground_mobject(circle[3])\n        self.wait(1)\n        self.play(FadeIn(circle[1].move_to(polar_to_point(19 * PI / 12, 0.375))), FadeIn(circle[2].move_to(polar_to_point(19 * PI / 12, 0.25))))\n        self.wait(2)\n        start_points = np.array([polar_to_point(19 * PI / 12, 0.5), polar_to_point(19 * PI / 12, 0.375), polar_to_point(19 * PI / 12, 0.25), polar_to_point(19 * PI / 12, 0.125)])\n        end_points = np.array([polar_to_point(19 * PI / 12), polar_to_point(19 * PI / 12, 0.75), polar_to_point(19 * PI / 12, 0.5), polar_to_point(19 * PI / 12, 0.25)])\n        lines = moving_line(start_points, end_points)\n        self.play(MoveAlongPath(circle[0], lines[0]), MoveAlongPath(circle[3], lines[3]), MoveAlongPath(circle[2], lines[2]), MoveAlongPath(circle[1], lines[1]), run_time=2)\n        self.wait(3)\n        unit_radius = HyperbolicArcBetweenPoints(circle[0].get_center(), circle[3].point_from_proportion(0), color=RED, stroke_width=2)\n        self.add_foreground_mobjects(circle[3], outer_circle)\n        self.play(Create(unit_radius))\n        self.play(Write(radius_tex.move_to([0.35, -0.3, 0])))\n        radius_length = MathTex('r = \\\\infty', font_size=25)\n        self.play(Write(radius_length.move_to([0, -2, 0])))\n        dot = Dot(radius=0.0)\n        dot.move_to(circle[3].point_from_proportion(0))\n        self.t_offset = 0\n        dot.add_updater(go_around_circle_h)\n        origin_to_circle_line = always_redraw(get_line_to_circle_h)\n        self.add(origin_to_circle_line)\n        self.add(dot)\n        self.remove(unit_radius)\n        self.play(FadeOut(radius_tex))\n        self.wait(3.01)\n        dot.remove_updater(go_around_circle_h)\n        self.wait(10)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])"}]}
{"messages": [{"role": "user", "content": "Animate the sequential writing of six rectangles arranged in a two-by-three grid."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import MovingCameraScene, WHITE, GREEN_B, PURPLE, DARK_GREY, GREY, ORANGE, YELLOW, Circle, Dot, FadeIn, Write, Create, RED, BLUE, MathTex, LEFT, ReplacementTransform, DOWN, Group, FadeOut, Transform, ImageMobject, Line, RIGHT, Arrow, VGroup, VMobject, DecimalNumber, ArcBetweenPoints, GREY_B, BLUE_A, BLUE_E, MoveAlongPath, Rectangle\nfrom animation_constants import OUTER_CIRCLE_STROKE_WIDTH, HEXAGON_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import get_intersection_from_angles, get_intersection_in_unit_circle_of_two_tangent_circles, polar_to_point, hyperbolic_distance_function, moving_line, moving_circle, hyperbolic_circle_to_euclidean_circle\nfrom hexagon import HexagonAngles, HexagonCircles, HexagonMainDiagonals\nfrom hexagon_util import create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Rectangles(MovingCameraScene):\n\n    def construct(self):\n        static = False\n        scaling = 0.25\n        rectangle1 = Rectangle(height=9 * scaling, width=16 * scaling).move_to([-4.5, 2, 0])\n        rectangle2 = Rectangle(height=9 * scaling, width=16 * scaling).move_to([0, 2, 0])\n        rectangle3 = Rectangle(height=9 * scaling, width=16 * scaling).move_to([4.5, 2, 0])\n        rectangle4 = Rectangle(height=9 * scaling, width=16 * scaling).move_to([-4.5, -2, 0])\n        rectangle5 = Rectangle(height=9 * scaling, width=16 * scaling).move_to([0, -2, 0])\n        rectangle6 = Rectangle(height=9 * scaling, width=16 * scaling).move_to([4.5, -2, 0])\n        if not static:\n            self.wait(2)\n            self.play(Write(rectangle1))\n            self.wait(2)\n            self.play(Write(rectangle2))\n            self.wait(2)\n            self.play(Write(rectangle3))\n            self.wait(2)\n            self.play(Write(rectangle4))\n            self.wait(2)\n            self.play(Write(rectangle5))\n            self.wait(2)\n            self.play(Write(rectangle6))\n            self.wait(2)\n        else:\n            self.add(rectangle1, rectangle2, rectangle3, rectangle4, rectangle5, rectangle6)"}]}
{"messages": [{"role": "user", "content": "Animate a hexagon's shape changing through three different configurations, updating its inner circles, diagonals, and intersection point with each change."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import MovingCameraScene, WHITE, GREEN_B, PURPLE, DARK_GREY, GREY, ORANGE, YELLOW, Circle, Dot, FadeIn, Write, Create, RED, BLUE, MathTex, LEFT, ReplacementTransform, DOWN, Group, FadeOut, Transform, ImageMobject, Line, RIGHT, Arrow, VGroup, VMobject, DecimalNumber, ArcBetweenPoints, GREY_B, BLUE_A, BLUE_E, MoveAlongPath, Rectangle\nfrom animation_constants import OUTER_CIRCLE_STROKE_WIDTH, HEXAGON_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import get_intersection_from_angles, get_intersection_in_unit_circle_of_two_tangent_circles, polar_to_point, hyperbolic_distance_function, moving_line, moving_circle, hyperbolic_circle_to_euclidean_circle\nfrom hexagon import HexagonAngles, HexagonCircles, HexagonMainDiagonals\nfrom hexagon_util import create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene1(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.scale(0.3)\n        OUTER_CIRCLE_COLOR = WHITE\n        INNER_CIRCLE_COLOR = GREEN_B\n        INNER_INTERSECTION_COLOR = PURPLE\n        OUTER_INTERSECTION_COLOR = DARK_GREY\n        HEXAGON_COLOR = GREY\n        DIAGONAL_COLOR = ORANGE\n        DIAGONAL_INTERSECTION_COLOR = YELLOW\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=2)\n        phis1 = HexagonAngles(np.array([0.3, 1.6, 2.2, 3, 4.3]))\n        phis2 = HexagonAngles(np.array([0.3, 1.2, 2.7, 3.6, 4.2]))\n        phis3 = HexagonAngles(np.array([0.7, 1.4, 2.3, 3.0, 4.1]))\n        first_circle_radius = 0.4\n        self.add(circle)\n        self.add_foreground_mobject(circle)\n        frame_rate = 60\n        frame_time = 1 / 60\n        run_time = 4\n        frames = run_time * frame_rate\n        i = 0\n        phis = np.array([phis1[j] + i * (phis2[j] - phis1[j]) / frames for j in range(5)])\n        hexagon = EuclideanHexagon(HexagonAngles(np.array(phis)), color=HEXAGON_COLOR, stroke_width=2)\n        hex_circles = HexagonCircles(hexagon, first_circle_radius, stroke_width=2, color=INNER_CIRCLE_COLOR)\n        diagonals = get_diagonals(hexagon, color=DIAGONAL_COLOR, stroke_width=2)\n        diagonal_intersection = Dot(get_intersection_from_angles(phis[0], phis[3], phis[1], phis[4]), color=DIAGONAL_INTERSECTION_COLOR, radius=0.05)\n        self.add(*hex_circles.circles, *diagonals, diagonal_intersection)\n        for i in range(1, frames):\n            prev_hex_circles = hex_circles\n            prev_diagonals = diagonals\n            prev_diagonal_intersection = diagonal_intersection\n            phis = np.array([phis1[j] + i * (phis2[j] - phis1[j]) / frames for j in range(5)])\n            hexagon = EuclideanHexagon(HexagonAngles(np.array(phis)), color=HEXAGON_COLOR, stroke_width=2)\n            hex_circles = HexagonCircles(hexagon, first_circle_radius, stroke_width=2, color=INNER_CIRCLE_COLOR)\n            diagonals = get_diagonals(hexagon, color=DIAGONAL_COLOR, stroke_width=2)\n            diagonal_intersection = Dot(get_intersection_from_angles(phis[0], phis[3], phis[1], phis[4]), color=DIAGONAL_INTERSECTION_COLOR, radius=0.05)\n            self.play(Transform(prev_hex_circles[0], hex_circles[0]), Transform(prev_hex_circles[1], hex_circles[1]), Transform(prev_hex_circles[2], hex_circles[2]), Transform(prev_hex_circles[3], hex_circles[3]), Transform(prev_hex_circles[4], hex_circles[4]), Transform(prev_hex_circles[5], hex_circles[5]), Transform(prev_diagonals[0], diagonals[0]), Transform(prev_diagonals[1], diagonals[1]), Transform(prev_diagonals[2], diagonals[2]), Transform(prev_diagonal_intersection, diagonal_intersection), run_time=frame_time)\n            self.remove(*prev_hex_circles, *prev_diagonals, prev_diagonal_intersection)\n        for i in range(frames):\n            prev_hex_circles = hex_circles\n            prev_diagonals = diagonals\n            prev_diagonal_intersection = diagonal_intersection\n            phis = np.array([phis2[j] + i * (phis3[j] - phis2[j]) / frames for j in range(5)])\n            hexagon = EuclideanHexagon(HexagonAngles(np.array(phis)), color=HEXAGON_COLOR, stroke_width=2)\n            hex_circles = HexagonCircles(hexagon, first_circle_radius, stroke_width=2, color=INNER_CIRCLE_COLOR)\n            diagonals = get_diagonals(hexagon, color=DIAGONAL_COLOR, stroke_width=2)\n            diagonal_intersection = Dot(get_intersection_from_angles(phis[0], phis[3], phis[1], phis[4]), color=DIAGONAL_INTERSECTION_COLOR, radius=0.05)\n            self.play(Transform(prev_hex_circles[0], hex_circles[0]), Transform(prev_hex_circles[1], hex_circles[1]), Transform(prev_hex_circles[2], hex_circles[2]), Transform(prev_hex_circles[3], hex_circles[3]), Transform(prev_hex_circles[4], hex_circles[4]), Transform(prev_hex_circles[5], hex_circles[5]), Transform(prev_diagonals[0], diagonals[0]), Transform(prev_diagonals[1], diagonals[1]), Transform(prev_diagonals[2], diagonals[2]), Transform(prev_diagonal_intersection, diagonal_intersection), run_time=frame_time)\n            self.remove(*prev_hex_circles, *prev_diagonals, prev_diagonal_intersection)\n        for i in range(frames):\n            prev_hex_circles = hex_circles\n            prev_diagonals = diagonals\n            prev_diagonal_intersection = diagonal_intersection\n            phis = np.array([phis3[j] + i * (phis1[j] - phis3[j]) / frames for j in range(5)])\n            hexagon = EuclideanHexagon(HexagonAngles(np.array(phis)), color=HEXAGON_COLOR, stroke_width=2)\n            hex_circles = HexagonCircles(hexagon, first_circle_radius, stroke_width=2, color=INNER_CIRCLE_COLOR)\n            diagonals = get_diagonals(hexagon, color=DIAGONAL_COLOR, stroke_width=2)\n            diagonal_intersection = Dot(get_intersection_from_angles(phis[0], phis[3], phis[1], phis[4]), color=DIAGONAL_INTERSECTION_COLOR, radius=0.05)\n            self.play(Transform(prev_hex_circles[0], hex_circles[0]), Transform(prev_hex_circles[1], hex_circles[1]), Transform(prev_hex_circles[2], hex_circles[2]), Transform(prev_hex_circles[3], hex_circles[3]), Transform(prev_hex_circles[4], hex_circles[4]), Transform(prev_hex_circles[5], hex_circles[5]), Transform(prev_diagonals[0], diagonals[0]), Transform(prev_diagonals[1], diagonals[1]), Transform(prev_diagonals[2], diagonals[2]), Transform(prev_diagonal_intersection, diagonal_intersection), run_time=frame_time)\n            self.remove(*prev_hex_circles, *prev_diagonals, prev_diagonal_intersection)\n        self.add(*hex_circles, *diagonals, diagonal_intersection)"}]}
{"messages": [{"role": "user", "content": "Visualize the convergence of a hyperbolic polygon to a point by animating its transformation along with associated disks and arcs."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import MovingCameraScene, WHITE, GREEN_B, PURPLE, DARK_GREY, GREY, ORANGE, YELLOW, Circle, Dot, FadeIn, Write, Create, RED, BLUE, MathTex, LEFT, ReplacementTransform, DOWN, Group, FadeOut, Transform, ImageMobject, Line, RIGHT, Arrow, VGroup, VMobject, DecimalNumber, ArcBetweenPoints, GREY_B, BLUE_A, BLUE_E, MoveAlongPath, Rectangle\nfrom animation_constants import OUTER_CIRCLE_STROKE_WIDTH, HEXAGON_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import get_intersection_from_angles, get_intersection_in_unit_circle_of_two_tangent_circles, polar_to_point, hyperbolic_distance_function, moving_line, moving_circle, hyperbolic_circle_to_euclidean_circle\nfrom hexagon import HexagonAngles, HexagonCircles, HexagonMainDiagonals\nfrom hexagon_util import create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene2(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 4.1\n        self.camera.frame.move_to([1, 0, 0])\n        outer_circle = Circle(color=WHITE, stroke_width=2)\n        self.add(outer_circle)\n        konvergenz = MathTex('P_n \\\\xrightarrow{n \\\\rightarrow \\\\infty}P_\\\\infty', font_size=30).move_to([2, 0, 0])\n        radius = np.array([0.7, 0.6, 0.75, 0.56, 0.65, 0.53])\n        phis = [0.47654, 2.065432, 2.876, 3.87623, 5.024, 5.673]\n        circle_radius = np.array([0.8, 0.8, 0.8, 0.8, 0.5, 0.4])\n        self.add(konvergenz)\n        self.add_foreground_mobjects(outer_circle)\n        hex_n_ideal = HyperbolicPolygon.from_polar(phis, radius, dot_radius=0.01, stroke_width=2)\n        disks = []\n        euclidean_centers = []\n        euclidean_radii = []\n        for k in range(0, 6):\n            hyperbolic_center = hex_n_ideal.polygon_points[k]\n            hyperbolic_radius = circle_radius[k]\n            eucl_center, eucl_radius = hyperbolic_circle_to_euclidean_circle(hyperbolic_center, hyperbolic_radius)\n            euclidean_centers.append(eucl_center)\n            euclidean_radii.append(eucl_radius)\n            circle = Circle(arc_center=eucl_center, radius=eucl_radius, color=GREEN_B, fill_opacity=0.5, stroke_width=2)\n            disks.append(circle)\n            self.add_foreground_mobjects(circle)\n            self.add(circle)\n        euclidean_centers = np.array(euclidean_centers)\n        euclidean_radii = np.array(euclidean_radii)\n        dynamic_arcs = []\n        for k in range(0, 6):\n            point1 = euclidean_centers[k]\n            radius1 = euclidean_radii[k]\n            point2 = euclidean_centers[(k + 1) % 6]\n            radius2 = euclidean_radii[(k + 1) % 6]\n            arc = hex_n_ideal.arcs[k]\n            intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(arc.circle_center, arc.radius, point1, radius1)\n            intersection2 = get_intersection_in_unit_circle_of_two_tangent_circles(point2, radius2, arc.circle_center, arc.radius)\n            arc_new = ArcBetweenPoints(intersection2, intersection1, color=ORANGE, radius=arc.radius, stroke_width=2).reverse_direction()\n            dynamic_arcs.append(arc_new)\n        disks_group = VGroup(disks[0], disks[1], disks[2], disks[3], disks[4], disks[5])\n        arc_group = VGroup(dynamic_arcs[0], dynamic_arcs[1], dynamic_arcs[2], dynamic_arcs[3], dynamic_arcs[4], dynamic_arcs[5])\n        step_size = 50\n        new_disk_group = VGroup()\n        new_arc_group = VGroup()\n        transition = create_radius_transition(start_point=radius, step_size=step_size)\n        disk_transition = create_radius_transition(start_point=np.linalg.norm(euclidean_centers, axis=1), step_size=step_size, end_point=1 - euclidean_radii)\n        for t in range(1, step_size):\n            hexagon_new = HyperbolicPolygon.from_polar(phis, transition[t], dot_radius=0.01, stroke_width=2)\n            for i in range(0, 6):\n                circle = Circle(radius=euclidean_radii[i], arc_center=polar_to_point(phis[i], disk_transition[t][i]), color=GREEN_B, fill_opacity=0.5, stroke_width=2)\n                new_disk_group.add(circle)\n                moving_arc = HyperbolicArcBetweenPoints(polar_to_point(phis[i], transition[t][i]), polar_to_point(phis[(i + 1) % 6], transition[t][(i + 1) % 6]))\n                moving_intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(moving_arc.circle_center, moving_arc.radius, polar_to_point(phis[i], disk_transition[t][i]), euclidean_radii[i])\n                intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(polar_to_point(phis[(i + 1) % 6], disk_transition[t][(i + 1) % 6]), euclidean_radii[(i + 1) % 6], moving_arc.circle_center, moving_arc.radius)\n                arc_new = ArcBetweenPoints(intersection1, moving_intersection1, color=ORANGE, radius=moving_arc.radius, stroke_width=2).reverse_direction()\n                new_arc_group.add(arc_new)\n            self.play(Transform(hex_n_ideal, hexagon_new), Transform(disks_group, new_disk_group), Transform(arc_group, new_arc_group), run_time=0.05, rate_func=lambda a: a)\n            new_disk_group = VGroup()\n            new_arc_group = VGroup()\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate the transformation between a hyperbolic hexagon with diagonals and its Euclidean counterpart, including intersections."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import MovingCameraScene, WHITE, GREEN_B, PURPLE, DARK_GREY, GREY, ORANGE, YELLOW, Circle, Dot, FadeIn, Write, Create, RED, BLUE, MathTex, LEFT, ReplacementTransform, DOWN, Group, FadeOut, Transform, ImageMobject, Line, RIGHT, Arrow, VGroup, VMobject, DecimalNumber, ArcBetweenPoints, GREY_B, BLUE_A, BLUE_E, MoveAlongPath, Rectangle\nfrom animation_constants import OUTER_CIRCLE_STROKE_WIDTH, HEXAGON_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import get_intersection_from_angles, get_intersection_in_unit_circle_of_two_tangent_circles, polar_to_point, hyperbolic_distance_function, moving_line, moving_circle, hyperbolic_circle_to_euclidean_circle\nfrom hexagon import HexagonAngles, HexagonCircles, HexagonMainDiagonals\nfrom hexagon_util import create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene3(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 4\n        OUTER_CIRCLE_COLOR = WHITE\n        INNER_CIRCLE_COLOR = GREEN_B\n        INNER_INTERSECTION_COLOR = PURPLE\n        OUTER_INTERSECTION_COLOR = DARK_GREY\n        HEXAGON_COLOR = GREY\n        DIAGONAL_COLOR = ORANGE\n        DIAGONAL_INTERSECTION_COLOR = YELLOW\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=OUTER_CIRCLE_STROKE_WIDTH)\n        phis = HexagonAngles(np.array([0.3, 1.6, 2.2, 3, 4.3]))\n        hexagon = HyperbolicPolygon.from_polar(phis, color=HEXAGON_COLOR, add_dots=False, stroke_width=HEXAGON_STROKE_WIDTH)\n        inner_circles = HexagonCircles(hexagon, first_circle_radius=0.4, color=GREEN_B, stroke_width=HEXAGON_STROKE_WIDTH)\n        diagonals = HexagonMainDiagonals(hexagon, color=ORANGE, stroke_width=HEXAGON_STROKE_WIDTH)\n        intersection = get_intersection_in_unit_circle_of_two_tangent_circles(diagonals.arc1.circle_center, diagonals.arc1.radius, diagonals.arc2.circle_center, diagonals.arc2.radius)\n        intersection_dot = Dot(intersection, color=YELLOW, radius=0.03)\n        self.add(circle, hexagon, inner_circles, diagonals, intersection_dot)\n        self.add_foreground_mobject(circle)\n        self.add_foreground_mobjects(hexagon, diagonals, intersection_dot, circle)\n        self.wait(1)\n        euclidean_hexagon = EuclideanHexagon(phis, color=GREY, stroke_width=2)\n        euclidean_diagonals = get_diagonals(hexagon, color=ORANGE, stroke_width=2)\n        euclidean_intersection_dot = Dot(get_intersection_from_angles(phis[0], phis[3], phis[1], phis[4]), color=YELLOW, radius=0.03)\n        self.add_foreground_mobjects(hexagon, diagonals, intersection_dot, circle)\n        self.play(*[ReplacementTransform(hexagon.arcs[i], euclidean_hexagon.edges[i]) for i in range(6)], ReplacementTransform(diagonals.arc1, euclidean_diagonals[0].reverse_direction()), ReplacementTransform(diagonals.arc2, euclidean_diagonals[1].reverse_direction()), ReplacementTransform(diagonals.arc3, euclidean_diagonals[2].reverse_direction()), ReplacementTransform(intersection_dot, euclidean_intersection_dot), run_time=3)\n        self.wait(2)\n        hexagon = HyperbolicPolygon.from_polar(phis, color=HEXAGON_COLOR, add_dots=False, stroke_width=HEXAGON_STROKE_WIDTH)\n        diagonals = HexagonMainDiagonals(hexagon, color=ORANGE, stroke_width=HEXAGON_STROKE_WIDTH)\n        intersection = get_intersection_in_unit_circle_of_two_tangent_circles(diagonals.arc1.circle_center, diagonals.arc1.radius, diagonals.arc2.circle_center, diagonals.arc2.radius)\n        intersection_dot = Dot(intersection, color=YELLOW, radius=0.03)\n        self.play(*[ReplacementTransform(euclidean_hexagon.edges[i], hexagon.arcs[i]) for i in range(6)], ReplacementTransform(euclidean_diagonals[0], diagonals.arc1), ReplacementTransform(euclidean_diagonals[1], diagonals.arc2), ReplacementTransform(euclidean_diagonals[2], diagonals.arc3), ReplacementTransform(euclidean_intersection_dot, intersection_dot), run_time=3)\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Display and animate a transformation between hyperbolic geodesics in the Poincare and Klein models."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import MovingCameraScene, WHITE, GREEN_B, PURPLE, DARK_GREY, GREY, ORANGE, YELLOW, Circle, Dot, FadeIn, Write, Create, RED, BLUE, MathTex, LEFT, ReplacementTransform, DOWN, Group, FadeOut, Transform, ImageMobject, Line, RIGHT, Arrow, VGroup, VMobject, DecimalNumber, ArcBetweenPoints, GREY_B, BLUE_A, BLUE_E, MoveAlongPath, Rectangle\nfrom animation_constants import OUTER_CIRCLE_STROKE_WIDTH, HEXAGON_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import get_intersection_from_angles, get_intersection_in_unit_circle_of_two_tangent_circles, polar_to_point, hyperbolic_distance_function, moving_line, moving_circle, hyperbolic_circle_to_euclidean_circle\nfrom hexagon import HexagonAngles, HexagonCircles, HexagonMainDiagonals\nfrom hexagon_util import create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene4(MovingCameraScene):\n\n    def construct(self):\n        center = np.array([0, 0, 0])\n        klein_origin = np.array([2, 0, 0])\n        poincare_origin = np.array([-2, 0, 0])\n        MY_BLUE = '#22c1dd'\n        klein_model = ImageMobject('tessellation_klein.png').scale(1.0).move_to(klein_origin)\n        poincare_model = ImageMobject('tessellation_poincare.png').scale(1.0).move_to(poincare_origin)\n        scale_back = 3.57\n        phis = [[0.4, 2], [3.3, 5.2]]\n        kcircle = Circle(color=MY_BLUE, stroke_width=1).scale(scale_back).move_to(klein_origin)\n        pcircle = Circle(color=MY_BLUE, stroke_width=1).scale(scale_back).move_to(poincare_origin)\n        p_geodesics_raw = [HyperbolicArcBetweenPoints(polar_to_point(x), polar_to_point(y)) for [x, y] in phis]\n        p_geodesics = [geo.scale(scale_back).move_to(geo.get_center() * scale_back).shift(poincare_origin) for geo in p_geodesics_raw]\n        k_geodesics_raw = [Line(polar_to_point(x), polar_to_point(y)) for [x, y] in phis]\n        k_geodesics = [geo.scale(scale_back).move_to(geo.get_center() * scale_back).shift(klein_origin) for geo in k_geodesics_raw]\n        arrow_lr = Arrow(start=LEFT, end=RIGHT, stroke_width=4, max_tip_length_to_length_ratio=0.5)\n        arrow_rl = Arrow(start=RIGHT, end=LEFT, stroke_width=4, max_tip_length_to_length_ratio=0.5)\n        arrow_group = VGroup(arrow_lr, arrow_rl).arrange(DOWN)\n        p_geo0 = p_geodesics[0].copy()\n        p_geo0 = p_geo0.shift(-poincare_origin).scale(0.7).move_to(p_geo0.get_center() * 0.7).shift(poincare_origin + 1.5 * LEFT)\n        p_geo0_copy = p_geo0.copy()\n        p_geo1 = p_geodesics[1].copy()\n        p_geo1 = p_geo1.shift(-poincare_origin).scale(0.7).move_to(p_geo1.get_center() * 0.7).shift(poincare_origin + 1.5 * LEFT)\n        k_geo0 = k_geodesics[0].copy()\n        k_geo0 = k_geo0.shift(-klein_origin).scale(0.7).move_to(k_geo0.get_center() * 0.7).shift(klein_origin + 1.5 * RIGHT)\n        k_geo1 = k_geodesics[1].copy()\n        k_geo1 = k_geo1.shift(-klein_origin).scale(0.7).move_to(k_geo1.get_center() * 0.7).shift(klein_origin + 1.5 * RIGHT)\n        k_geo1_copy = k_geo1.copy()\n        poincare_model.scale(0.7).shift(1.5 * LEFT)\n        klein_model.scale(0.7).shift(1.5 * RIGHT)\n        self.add(poincare_model, klein_model, arrow_group)\n        self.add(pcircle.scale(0.7).shift(1.5 * LEFT), kcircle.scale(0.7).shift(1.5 * RIGHT))\n        self.wait(1)\n        self.play(Create(p_geo0), FadeOut(poincare_model))\n        self.add(p_geo0_copy)\n        self.wait(1)\n        self.play(Transform(p_geo0, k_geo0), FadeOut(klein_model))\n        self.wait(1)\n        self.play(Create(k_geo1))\n        self.add(k_geo1_copy)\n        self.wait(1)\n        self.play(Transform(k_geo1, p_geo1))\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Animate the hyperbolic distance between two points on a polygon's arc, updating the distance value and interpolating the arc and points as they approach infinity."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import MovingCameraScene, WHITE, GREEN_B, PURPLE, DARK_GREY, GREY, ORANGE, YELLOW, Circle, Dot, FadeIn, Write, Create, RED, BLUE, MathTex, LEFT, ReplacementTransform, DOWN, Group, FadeOut, Transform, ImageMobject, Line, RIGHT, Arrow, VGroup, VMobject, DecimalNumber, ArcBetweenPoints, GREY_B, BLUE_A, BLUE_E, MoveAlongPath, Rectangle\nfrom animation_constants import OUTER_CIRCLE_STROKE_WIDTH, HEXAGON_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import get_intersection_from_angles, get_intersection_in_unit_circle_of_two_tangent_circles, polar_to_point, hyperbolic_distance_function, moving_line, moving_circle, hyperbolic_circle_to_euclidean_circle\nfrom hexagon import HexagonAngles, HexagonCircles, HexagonMainDiagonals\nfrom hexagon_util import create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene5(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.move_to([1, 0, 0])\n        self.camera.frame.width = 6\n        radius_disks = [0.5, 0.4]\n        circle = Circle(color=WHITE, stroke_width=HEXAGON_STROKE_WIDTH)\n        phis = [0.47654, 2.065432, 2.876, 3.87623, 5.024, 5.673]\n        hexagon = HyperbolicPolygon.from_polar(phis, add_dots=False, color=GREY_B, stroke_width=2)\n        arc_colored = HyperbolicPolygon.from_polar(phis, add_dots=False, color=ORANGE, stroke_width=2).arcs[0]\n        point1 = hexagon.polygon_points[0]\n        point2 = hexagon.polygon_points[1]\n        arc = hexagon.arcs[0]\n        distance_text = MathTex('\\\\mathrm{dist_h}(a,b) =', font_size=27).move_to([1.2, 0, 0], aligned_edge=LEFT)\n        infinity = MathTex('\\\\infty', font_size=27).next_to(distance_text, buff=0.05)\n        s_0 = Dot(hexagon.polygon_points[0], radius=0.02, color=ORANGE)\n        s_1 = Dot(hexagon.polygon_points[1], radius=0.02, color=ORANGE)\n        self.add(hexagon, circle, arc_colored, s_0, s_1, distance_text, infinity)\n        self.add_foreground_mobjects(circle)\n        self.wait(1)\n        distance_number = DecimalNumber(6343.242564, num_decimal_places=2, show_ellipsis=True, group_with_commas=False, font_size=27).next_to(distance_text, buff=0.05)\n        self.remove(infinity)\n        label = VGroup(distance_text, distance_number)\n        step_size = 450\n        for t in range(1, step_size):\n            if t < step_size / 2:\n                transition = 2 * t / step_size\n            else:\n                transition = (1 - t / step_size) * 2\n            interp_point1 = get_intersection_in_unit_circle_of_two_tangent_circles(arc.circle_center, arc.radius, point1, transition * radius_disks[0])\n            interp_point2 = get_intersection_in_unit_circle_of_two_tangent_circles(point2, transition * radius_disks[1], arc.circle_center, arc.radius)\n            new_arc = ArcBetweenPoints(interp_point2, interp_point1, color=ORANGE, radius=arc.radius, stroke_width=2).reverse_direction()\n            distance = np.exp(hyperbolic_distance_function(interp_point2, interp_point1))\n            distance_number.font_size = 27\n            label.arrange(buff=0.05)\n            label.move_to([1.2, 0, 0], aligned_edge=LEFT)\n            if t == step_size - 1:\n                self.play(Transform(arc_colored, new_arc), Transform(s_0, Dot(interp_point1, radius=0.02, color=ORANGE)), Transform(s_1, Dot(interp_point2, radius=0.02, color=ORANGE)), Transform(distance_number, infinity), run_time=1 / 60, rate_func=lambda a: a)\n            else:\n                self.play(Transform(arc_colored, new_arc), Transform(s_0, Dot(interp_point1, radius=0.02, color=ORANGE)), Transform(s_1, Dot(interp_point2, radius=0.02, color=ORANGE)), distance_number.animate.set_value(distance), run_time=1 / 60, rate_func=lambda a: a)\n        self.remove(s_0, s_1)\n        self.wait(2)\n        everything = VGroup(*filter(lambda x: isinstance(x, VMobject), self.mobjects))"}]}
{"messages": [{"role": "user", "content": "Animate concentric circles expanding outwards and moving along straight and curved paths."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import MovingCameraScene, WHITE, GREEN_B, PURPLE, DARK_GREY, GREY, ORANGE, YELLOW, Circle, Dot, FadeIn, Write, Create, RED, BLUE, MathTex, LEFT, ReplacementTransform, DOWN, Group, FadeOut, Transform, ImageMobject, Line, RIGHT, Arrow, VGroup, VMobject, DecimalNumber, ArcBetweenPoints, GREY_B, BLUE_A, BLUE_E, MoveAlongPath, Rectangle\nfrom animation_constants import OUTER_CIRCLE_STROKE_WIDTH, HEXAGON_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import get_intersection_from_angles, get_intersection_in_unit_circle_of_two_tangent_circles, polar_to_point, hyperbolic_distance_function, moving_line, moving_circle, hyperbolic_circle_to_euclidean_circle\nfrom hexagon import HexagonAngles, HexagonCircles, HexagonMainDiagonals\nfrom hexagon_util import create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene6(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 4\n        center = [0, 0, 0]\n        start_points = np.array([center, center, center, center])\n        length = [1 / 2, 1 / 2, -3 / 2]\n        angles = [0, np.pi / 4, 4 * np.pi / 3]\n        outer_circle = Circle(color=WHITE, radius=1, stroke_width=HEXAGON_STROKE_WIDTH).move_to(center)\n        self.add_foreground_mobjects(outer_circle)\n        circle = [Dot(color=WHITE, radius=0.04), Circle(color=BLUE_A, radius=0.25, stroke_width=2), Circle(color=BLUE, radius=0.5, stroke_width=2), Circle(color=BLUE_E, radius=0.75, stroke_width=2)]\n        Group(circle[0], circle[1], circle[2], circle[3]).move_to(center)\n        self.add(outer_circle, circle[0])\n        self.add_foreground_mobjects(circle[0])\n        self.play(Create(circle[1]), Create(circle[2]), Create(circle[3]))\n        for t in range(3):\n            end_points = np.array([start_points[0] - [1 * length[t], 0, 0], start_points[1] - [0.75 * length[t], 0, 0], start_points[2] - [0.5 * length[t], 0, 0], start_points[3] - [0.25 * length[t], 0, 0]])\n            lines = moving_line(start_points, end_points)\n            self.play(MoveAlongPath(circle[0], lines[0]), MoveAlongPath(circle[3], lines[3]), MoveAlongPath(circle[2], lines[2]), MoveAlongPath(circle[1], lines[1]))\n            start_points = end_points\n        for t in range(2):\n            arcs = moving_circle(angles[t], angles[t + 1], center)\n            self.play(MoveAlongPath(circle[0], arcs[0]), MoveAlongPath(circle[3], arcs[1]), MoveAlongPath(circle[2], arcs[2]), MoveAlongPath(circle[1], arcs[3]))\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Animate the creation of a hyperbolic polygon with labeled vertices and arcs, then fade everything out."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import MovingCameraScene, WHITE, GREEN_B, PURPLE, DARK_GREY, GREY, ORANGE, YELLOW, Circle, Dot, FadeIn, Write, Create, RED, BLUE, MathTex, LEFT, ReplacementTransform, DOWN, Group, FadeOut, Transform, ImageMobject, Line, RIGHT, Arrow, VGroup, VMobject, DecimalNumber, ArcBetweenPoints, GREY_B, BLUE_A, BLUE_E, MoveAlongPath, Rectangle\nfrom animation_constants import OUTER_CIRCLE_STROKE_WIDTH, HEXAGON_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import get_intersection_from_angles, get_intersection_in_unit_circle_of_two_tangent_circles, polar_to_point, hyperbolic_distance_function, moving_line, moving_circle, hyperbolic_circle_to_euclidean_circle\nfrom hexagon import HexagonAngles, HexagonCircles, HexagonMainDiagonals\nfrom hexagon_util import create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene6Unused(MovingCameraScene):\n\n    def construct(self):\n        s_1 = MathTex('S_1', color=BLUE, font_size=15).move_to([0.15, 0.5, 0])\n        s_2 = MathTex('S_2', color=BLUE, font_size=15).move_to([-0.6, 0.45, 0])\n        s_2_red = MathTex('S_2', color=RED, font_size=15).move_to([-0.6, 0.45, 0])\n        s_3 = MathTex('S_3', color=BLUE, font_size=15).move_to([-0.7, -0.1, 0])\n        s_4 = MathTex('S_4', color=BLUE, font_size=15).move_to([-0.1, -0.6, 0])\n        s_4_red = MathTex('S_4', color=RED, font_size=15).move_to([-0.1, -0.6, 0])\n        s_5 = MathTex('S_5', color=BLUE, font_size=15).move_to([0.4, -0.55, 0])\n        s_6 = MathTex('S_6', color=BLUE, font_size=15).move_to([0.6, 0, 0])\n        s_6_red = MathTex('S_6', color=RED, font_size=15).move_to([0.6, 0, 0])\n        s_k = [s_1, s_2, s_3, s_4, s_5, s_6]\n        s_k_colored = [s_1, s_2_red, s_3, s_4_red, s_5, s_6_red]\n        formula_size = 15\n        self.camera.frame.width = 6\n        circle = Circle(color=WHITE, stroke_width=HEXAGON_STROKE_WIDTH)\n        self.wait(1)\n        radius = [0.5, 0.7, 0.6, 0.7, 0.5, 0.6]\n        phis = [0.47654, 2.065432, 2.876, 3.87623, 5.024, 5.673]\n        hexagon = HyperbolicPolygon.from_polar(phis, radius, dot_radius=0.01, stroke_width=2)\n        hex_name = MathTex('P', font_size=15).move_to([0.6, 0.4, 0])\n        self.play(FadeIn(circle, hexagon), Write(hex_name))\n        self.wait(2)\n        arc = HyperbolicPolygon.from_polar(phis, radius, dot_radius=0.01, color=BLUE, stroke_width=2).arcs\n        dots = hexagon.dots\n        dots[-1].set_color(BLUE)\n        for i in range(0, 6):\n            dots[i].set_color(BLUE)\n            self.play(Create(arc[i]), Write(s_k[i], stroke_width=0.5), rate_func=lambda a: a, run_time=1)\n        self.wait(2)\n        self.play(FadeOut(*self.mobjects))"}]}
{"messages": [{"role": "user", "content": "Create an animation of an ideal hexagon in the Poincare disk, showing its diagonals forming an inner triangle, then display a theorem relating their perimeters with colored hexagons and animated labels, and finally fade out all elements."}, {"role": "assistant", "content": "from typing import Union\nimport numpy as np\nfrom manim import Create, Circle, MovingCameraScene, BLUE, Tex, Write, FadeOut, FadeIn, PURPLE, WHITE, YELLOW, GREEN, Uncreate, RED, VGroup, LEFT, DOWN, Dot, TransformFromCopy, Transform, Flash, MathTex, ReplacementTransform, ApplyWave, Group, GREY, Unwrite, Square, Indicate, UP, TexTemplate, RIGHT, GREEN_B, ORANGE, GREEN_E, PURPLE_E\nfrom manim.utils import rate_functions\nfrom animation_constants import OUTER_CIRCLE_COLOR, HEXAGON_STROKE_WIDTH, HEXAGON_DOT_CIRCLE_RADIUS, OUTER_CIRCLE_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, get_intersection_in_unit_circle_of_two_tangent_circles, get_intersections_of_n_tangent_circles, get_intersection_points_of_n_tangent_circles, get_intersection_from_angles, mobius_transform_poincare_disk\nfrom hexagon import HexagonMainDiagonals, IntersectionTriangle, HexagonAngles, HexagonCircles\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene1(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 6\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=OUTER_CIRCLE_STROKE_WIDTH)\n        self.add_foreground_mobjects(circle)\n        self.play(Create(circle))\n        phis = [1.80224806, 2.30601184, 2.77326535, 3.20993453, 4.48582486, 6.15595698]\n        print(f'Phis = {phis}')\n        hexagon = HyperbolicPolygon.from_polar(phis, add_dots=False, stroke_width=HEXAGON_STROKE_WIDTH)\n        hexagon_label = MathTex('P', font_size=15).move_to([-0.05, 0.8, 0])\n        print(hexagon.phis)\n        diagonals = HexagonMainDiagonals(hexagon, stroke_width=HEXAGON_STROKE_WIDTH)\n        self.play(Create(hexagon), run_time=5, subcaption='Betrachten wir nun ein ideales Hexagon.')\n        self.play(Write(hexagon_label))\n        self.play(Create(diagonals), run_time=6, subcaption='Wenn wir bei diesem Hexagon die gegen\u00fcberliegenden Seiten verbinden, sehen wir,')\n        triangle = IntersectionTriangle(diagonals, color=GREEN, add_dots=True, dot_radius=0.01, dot_color=GREEN, stroke_width=HEXAGON_STROKE_WIDTH)\n        triangle_label = MathTex('T_P', color=GREEN, font_size=15).move_to([-0.2, 0.25, 0])\n        self.play(Create(triangle), Write(triangle_label), run_time=2, subcaption='dass ein Dreieck in der Mitte entsteht. Nennen wir dieses Dreieck T_P.')\n        self.play(Flash(triangle, color=GREEN, line_stroke_width=HEXAGON_STROKE_WIDTH))\n        self.wait(5)\n        self.play(self.camera.frame.animate.set(width=4).move_to([0.8, 0, 0]))\n        hexagon_colored = HyperbolicPolygon.from_polar(phis, color=[RED, BLUE, RED, BLUE, RED, BLUE], add_dots=False, stroke_width=2)\n        self.add_subcaption('Wir zeigen jetzt den folgenden Satz: F\u00fcr jedes ideale Hexagon gilt, dass der alternierende Umfang bis auf das Vorzeichen genau zweimal dem Umfang von T_P entspricht.', duration=10)\n        self.play(Create(hexagon_colored), run_time=6)\n        self.remove(hexagon)\n        proposition = Tex('For any ideal hexagon $P$:', font_size=11).move_to([1.9, 0.1, 0])\n        formula = altper, equal, per = VGroup(MathTex('\\\\mathrm{altPer}(P)', font_size=11), MathTex('= \\\\pm 2 \\\\cdot ', font_size=11), MathTex('\\\\mathrm{Per}(T_P)', font_size=11)).arrange(buff=0.05)\n        formula.next_to(proposition, 0.5 * DOWN)\n        self.play(Write(proposition))\n        self.play(TransformFromCopy(VGroup(*hexagon_colored.arcs), altper))\n        self.play(Write(equal), TransformFromCopy(triangle, per))\n        self.wait(10)\n        self.play(FadeOut(triangle, triangle_label, hexagon_colored, hexagon_label, diagonals, proposition, formula, hexagon), self.camera.frame.animate.set(width=6).move_to([0, 0, 0]))"}]}
{"messages": [{"role": "user", "content": "Demonstrate semi-ideal triangles within a hyperbolic setting, first showing a single example and then highlighting three pairs of triangles within a hexagon."}, {"role": "assistant", "content": "from typing import Union\nimport numpy as np\nfrom manim import Create, Circle, MovingCameraScene, BLUE, Tex, Write, FadeOut, FadeIn, PURPLE, WHITE, YELLOW, GREEN, Uncreate, RED, VGroup, LEFT, DOWN, Dot, TransformFromCopy, Transform, Flash, MathTex, ReplacementTransform, ApplyWave, Group, GREY, Unwrite, Square, Indicate, UP, TexTemplate, RIGHT, GREEN_B, ORANGE, GREEN_E, PURPLE_E\nfrom manim.utils import rate_functions\nfrom animation_constants import OUTER_CIRCLE_COLOR, HEXAGON_STROKE_WIDTH, HEXAGON_DOT_CIRCLE_RADIUS, OUTER_CIRCLE_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, get_intersection_in_unit_circle_of_two_tangent_circles, get_intersections_of_n_tangent_circles, get_intersection_points_of_n_tangent_circles, get_intersection_from_angles, mobius_transform_poincare_disk\nfrom hexagon import HexagonMainDiagonals, IntersectionTriangle, HexagonAngles, HexagonCircles\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene2(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 6\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=OUTER_CIRCLE_STROKE_WIDTH)\n        self.add(circle)\n        self.add_foreground_mobjects(circle)\n        p1 = polar_to_point(0.2)\n        p2 = polar_to_point(0.8)\n        p3 = polar_to_point(0.7) * 0.3\n        print(p1, p2, p3)\n        triangle = HyperbolicPolygon([p1, p2, p3], color=[BLUE, WHITE, WHITE], stroke_width=HEXAGON_STROKE_WIDTH, dot_radius=0.04)\n        triangle.dots[0].set_color(BLUE)\n        triangle.dots[1].set_color(BLUE)\n        triangle_dot = Dot(triangle.polygon_points[2], radius=HEXAGON_DOT_CIRCLE_RADIUS)\n        self.add_subcaption('F\u00fcr den Beweis definieren wir uns zuerst den Begriff des semiidealen Dreiecks. ', duration=4)\n        self.wait(3)\n        self.play(Create(triangle.arcs[0]), run_time=1)\n        self.add_subcaption('Es hat zwei Ecken am Rand des Kreises - also ideale Punkte - sowie eine Ecke in der hyperbolischen Ebene.', duration=6)\n        self.add_foreground_mobjects(triangle.arcs[0], circle)\n        self.play(Create(triangle.arcs[1]), run_time=1)\n        self.add(triangle_dot)\n        self.play(Create(triangle.arcs[2]), run_time=1)\n        self.add_foreground_mobjects(triangle.dots[0])\n        self.play(Create(triangle.dots[0]))\n        self.add_foreground_mobjects(triangle.dots[1])\n        self.play(Create(triangle.dots[1]))\n        self.wait(1.5)\n        self.play(Create(triangle.dots[2]))\n        self.wait(2.5)\n        self.play(FadeOut(triangle, triangle_dot))\n        self.clear()\n        self.add(circle)\n        self.add_foreground_mobject(circle)\n        phis = [0.3, 1.6, 2.2, 3.4, 4.3, 5.9]\n        hexagon = HyperbolicPolygon.from_polar(phis, add_dots=False, stroke_width=HEXAGON_STROKE_WIDTH)\n        diagonals = HexagonMainDiagonals(hexagon, stroke_width=HEXAGON_STROKE_WIDTH)\n        self.add_subcaption('In unserem idealen Sechseck gibt es drei solcher Dreiecke:', duration=3)\n        self.play(FadeIn(hexagon, diagonals), self.camera.frame.animate.set(width=4))\n        self.wait(2)\n        y1, y2, y3, g1, g2, g3 = get_y_g_triangles(hexagon, stroke_width=HEXAGON_STROKE_WIDTH)\n        y1_label = MathTex('Y_1', font_size=15).move_to([0.5, 0, 0])\n        y2_label = MathTex('Y_2', font_size=15).move_to([-0.2, 0.55, 0])\n        y3_label = MathTex('Y_3', font_size=15).move_to([-0.35, -0.25, 0])\n        g1_label = MathTex('G_1', font_size=15).move_to([-0.3, 0.15, 0])\n        g2_label = MathTex('G_2', font_size=15).move_to([0.1, -0.2, 0])\n        g3_label = MathTex('G_3', font_size=15).move_to([0.2, 0.25, 0])\n        self.play(FadeIn(y1), Write(y1_label), subcaption='Y1, ')\n        self.play(FadeOut(y1), FadeIn(y2), Write(y2_label), subcaption='Y2 ')\n        self.play(FadeOut(y2), FadeIn(y3), Write(y3_label), subcaption='sowie Y3.')\n        self.play(FadeOut(y3))\n        self.add_subcaption('Auf den jeweils gegen\u00fcberliegenden Seiten gibt es au\u00dferdem noch drei weitere semiideale Dreiecke, die das innere Dreieck T_P schneiden.', duration=8)\n        self.wait(8)\n        self.play(FadeIn(g1), Write(g1_label), subcaption='Die nennen wir G1, ')\n        self.play(FadeOut(g1), FadeIn(g2), Write(g2_label), subcaption='G2 ')\n        self.play(FadeOut(g2), FadeIn(g3), Write(g3_label), subcaption='und G3.')\n        self.play(FadeOut(g3))\n        self.wait(3)\n        self.play(Unwrite(y1_label), Unwrite(y2_label), Unwrite(y3_label), Unwrite(g1_label), Unwrite(g2_label), Unwrite(g3_label), FadeOut(hexagon, diagonals))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate the construction of hyperbolic triangle arcs labeled L1', L2', and L3', then form a formula using these arcs, and finally demonstrate how the lengths change while the formula remains constant."}, {"role": "assistant", "content": "from typing import Union\nimport numpy as np\nfrom manim import Create, Circle, MovingCameraScene, BLUE, Tex, Write, FadeOut, FadeIn, PURPLE, WHITE, YELLOW, GREEN, Uncreate, RED, VGroup, LEFT, DOWN, Dot, TransformFromCopy, Transform, Flash, MathTex, ReplacementTransform, ApplyWave, Group, GREY, Unwrite, Square, Indicate, UP, TexTemplate, RIGHT, GREEN_B, ORANGE, GREEN_E, PURPLE_E\nfrom manim.utils import rate_functions\nfrom animation_constants import OUTER_CIRCLE_COLOR, HEXAGON_STROKE_WIDTH, HEXAGON_DOT_CIRCLE_RADIUS, OUTER_CIRCLE_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, get_intersection_in_unit_circle_of_two_tangent_circles, get_intersections_of_n_tangent_circles, get_intersection_points_of_n_tangent_circles, get_intersection_from_angles, mobius_transform_poincare_disk\nfrom hexagon import HexagonMainDiagonals, IntersectionTriangle, HexagonAngles, HexagonCircles\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene3(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 4\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=OUTER_CIRCLE_STROKE_WIDTH)\n        self.add_foreground_mobject(circle)\n        self.add(circle)\n        p1 = polar_to_point(0.2)\n        p2 = polar_to_point(2.1)\n        p3 = polar_to_point(5) * 0.3\n        print(p1, p2, p3)\n        self.wait(1)\n        triangle = HyperbolicPolygon([p1, p2, p3], stroke_width=HEXAGON_STROKE_WIDTH)\n        self.add_subcaption('Wir definieren uns eine \u00e4hnliche Gr\u00f6\u00dfe wie den alternierenden Umfang f\u00fcr hyperbolische Dreiecke.', duration=4)\n        triangle_label = MathTex('V', font_size=20).move_to([-0.1, -0.3, 0])\n        self.play(Create(triangle, run_time=3), Write(triangle_label))\n        dot = Dot(triangle.polygon_points[2], radius=HEXAGON_DOT_CIRCLE_RADIUS)\n        self.add(dot)\n        self.wait(3)\n        circle1_radius = 0.2\n        circle1_center = (1 - circle1_radius) * p1\n        circle2_radius = 0.15\n        circle2_center = (1 - circle2_radius) * p2\n        circle1 = Circle(radius=circle1_radius, color=GREEN_B, fill_opacity=0.5, stroke_width=HEXAGON_STROKE_WIDTH).move_to(circle1_center)\n        circle2 = Circle(radius=circle2_radius, color=GREEN_B, fill_opacity=0.5, stroke_width=HEXAGON_STROKE_WIDTH).move_to(circle2_center)\n        self.add_foreground_mobjects(circle1, circle2)\n        self.add_subcaption('Wenn wir disjunkte Horodisks von den beiden idealen Knoten des Dreiecks entfernen, ', duration=5)\n        self.play(Create(VGroup(circle1, circle2)), run_time=3)\n        self.wait(2)\n        arc = triangle.arcs[1]\n        intersection = get_intersection_in_unit_circle_of_two_tangent_circles(circle2_center, circle2_radius, arc.circle_center, arc.radius)\n        l1_prime = HyperbolicArcBetweenPoints(intersection, triangle.polygon_points[2], color=BLUE, stroke_width=HEXAGON_STROKE_WIDTH)\n        l1_prime_label = MathTex(\"L_1'\", color=BLUE, font_size=20).move_to([-0.3, 0.1, 0])\n        self.play(Create(l1_prime), Write(l1_prime_label), subcaption=\"erhalten wir die L\u00e4ngen L_1',\")\n        dot.set_color(BLUE)\n        arc = triangle.arcs[2]\n        intersection = get_intersection_in_unit_circle_of_two_tangent_circles(circle1_center, circle1_radius, arc.circle_center, arc.radius)\n        l2_prime = HyperbolicArcBetweenPoints(intersection, triangle.polygon_points[2], color=BLUE, stroke_width=HEXAGON_STROKE_WIDTH).reverse_direction()\n        l2_prime_label = MathTex(\"L_2'\", color=BLUE, font_size=20).move_to([0.4, -0.25, 0])\n        self.play(Create(l2_prime), Write(l2_prime_label), subcaption=\"L_2'\")\n        arc = triangle.arcs[0]\n        intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(circle1_center, circle1_radius, arc.circle_center, arc.radius)\n        intersection2 = get_intersection_in_unit_circle_of_two_tangent_circles(circle2_center, circle2_radius, arc.circle_center, arc.radius)\n        l3_prime = HyperbolicArcBetweenPoints(intersection1, intersection2, color=RED, stroke_width=HEXAGON_STROKE_WIDTH)\n        l3_prime_label = MathTex(\"L_3'\", color=RED, font_size=20).move_to([0.2, 0.55, 0])\n        self.add_subcaption(\"und L_3'.\", duration=2)\n        self.play(Create(l3_prime), Write(l3_prime_label))\n        self.wait(2)\n        self.play(self.camera.frame.animate.set(width=4).move_to([0.8, 0, 0]))\n        template = TexTemplate()\n        template.add_to_preamble('\\\\usepackage{mathtools}')\n        formula = MathTex('A(V) \\\\coloneqq ', \"L_1'\", '+', \"L_2'\", '-', \"L_3'\", font_size=15, tex_template=template)\n        formula[1].set_color(BLUE)\n        formula[3].set_color(BLUE)\n        formula[5].set_color(RED)\n        formula.move_to([1.15, 0, 0], aligned_edge=LEFT)\n        self.add_subcaption('Damit definieren wir uns den alternierenden Umfang eines semiidealen Dreiecks,', duration=4)\n        self.wait(1)\n        self.play(Write(formula[0]), run_time=2)\n        self.wait(1)\n        self.add_subcaption('indem wir die beiden blauen L\u00e4ngen aufeinander addieren und die rote abziehen.', duration=4)\n        self.play(TransformFromCopy(l1_prime_label, formula[1]), run_time=1)\n        self.play(Write(formula[2]), TransformFromCopy(l2_prime_label, formula[3]), run_time=1)\n        self.play(Write(formula[4]), TransformFromCopy(l3_prime_label, formula[5]), run_time=1)\n        self.wait(2)\n        step_size_one_direction = 10\n        circle1_radii_transition = [circle1_radius * (1 - t / step_size_one_direction) + 0.1 * t / step_size_one_direction for t in range(step_size_one_direction)] + [circle1_radius * t / step_size_one_direction + 0.1 * (1 - t / step_size_one_direction) for t in range(step_size_one_direction + 1)]\n        print(circle1_radii_transition)\n        num_steps = 2 * step_size_one_direction + 1\n        self.add_subcaption('Der alternierende Umfang h\u00e4ngt nicht von der Gr\u00f6\u00dfe der einzelnen Kreise ab, da die gleiche L\u00e4nge sowohl dazuaddiert als auch abgezogen wird.', duration=6)\n        self.wait(2)\n        for t in range(num_steps):\n            radius = circle1_radii_transition[t]\n            center = triangle.polygon_points[0] * (1 - radius)\n            new_circle = Circle(radius, color=GREEN_B, fill_opacity=0.5, stroke_width=HEXAGON_STROKE_WIDTH).move_to(center)\n            arc = triangle.arcs[0]\n            intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(center, radius, arc.circle_center, arc.radius)\n            intersection2 = get_intersection_in_unit_circle_of_two_tangent_circles(circle2_center, circle2_radius, arc.circle_center, arc.radius)\n            new_l3_prime = HyperbolicArcBetweenPoints(intersection1, intersection2, color=RED, stroke_width=HEXAGON_STROKE_WIDTH)\n            arc = triangle.arcs[2]\n            intersection = get_intersection_in_unit_circle_of_two_tangent_circles(center, radius, arc.circle_center, arc.radius)\n            new_l2_prime = HyperbolicArcBetweenPoints(intersection, triangle.polygon_points[2], color=BLUE, stroke_width=HEXAGON_STROKE_WIDTH).reverse_direction()\n            self.play(Transform(circle1, new_circle), Transform(l2_prime, new_l2_prime), Transform(l3_prime, new_l3_prime), rate_func=lambda a: a, run_time=3 / num_steps)\n        self.wait(5)\n        self.play(FadeOut(formula, triangle, circle1, circle2, dot, l1_prime, l1_prime_label, l2_prime, l2_prime_label, l3_prime, l3_prime_label, triangle_label), self.camera.frame.animate.set(width=4).move_to([0, 0, 0]))\n        self.remove(circle1, circle2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Demonstrate the construction of isometries in the hyperbolic plane by transforming triangles using Mobius transformations and point reflections, illustrating the concept I_k(Y_k) = G_k."}, {"role": "assistant", "content": "from typing import Union\nimport numpy as np\nfrom manim import Create, Circle, MovingCameraScene, BLUE, Tex, Write, FadeOut, FadeIn, PURPLE, WHITE, YELLOW, GREEN, Uncreate, RED, VGroup, LEFT, DOWN, Dot, TransformFromCopy, Transform, Flash, MathTex, ReplacementTransform, ApplyWave, Group, GREY, Unwrite, Square, Indicate, UP, TexTemplate, RIGHT, GREEN_B, ORANGE, GREEN_E, PURPLE_E\nfrom manim.utils import rate_functions\nfrom animation_constants import OUTER_CIRCLE_COLOR, HEXAGON_STROKE_WIDTH, HEXAGON_DOT_CIRCLE_RADIUS, OUTER_CIRCLE_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, get_intersection_in_unit_circle_of_two_tangent_circles, get_intersections_of_n_tangent_circles, get_intersection_points_of_n_tangent_circles, get_intersection_from_angles, mobius_transform_poincare_disk\nfrom hexagon import HexagonMainDiagonals, IntersectionTriangle, HexagonAngles, HexagonCircles\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene4(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 4\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=OUTER_CIRCLE_STROKE_WIDTH)\n        self.add_foreground_mobject(circle)\n        self.add(circle)\n        phis = [0.3, 1.6, 2.2, 3.4, 4.3, 5.9]\n        hexagon = HyperbolicPolygon.from_polar(phis, add_dots=False, stroke_width=HEXAGON_STROKE_WIDTH)\n        diagonals = HexagonMainDiagonals(hexagon, stroke_width=HEXAGON_STROKE_WIDTH)\n        self.play(FadeIn(hexagon, diagonals))\n        self.wait(2)\n        y1, y2, y3, g1, g2, g3 = get_y_g_triangles(hexagon, stroke_width=HEXAGON_STROKE_WIDTH)\n        dot1 = Dot(y1.polygon_points[2], radius=0.04)\n        dot2 = Dot(y2.polygon_points[2], radius=0.04)\n        dot3 = Dot(y3.polygon_points[2], radius=0.04)\n        self.add_subcaption('Die Dreiecke G_k und Y_k teilen sich jeweils genau einen Knoten f\u00fcr k = 1, 2, 3.', duration=6)\n        self.play(FadeIn(y1, g1, dot1))\n        self.play(Flash(dot1, line_stroke_width=1, line_length=0.1, color=WHITE))\n        self.play(FadeOut(y1, g1, dot1), FadeIn(y2, g2, dot2))\n        self.play(Flash(dot2, line_stroke_width=1, line_length=0.1, color=WHITE))\n        self.play(FadeOut(y2, g2, dot2), FadeIn(y3, g3, dot3))\n        self.play(Flash(dot3, line_stroke_width=1, line_length=0.1, color=WHITE))\n        self.play(FadeOut(y3, g3, dot3))\n        self.add_subcaption('Es gibt jeweils eine Isometrie I_k, die die gegen\u00fcberliegende Dreiecke aufeinander abbildet.', duration=5)\n        y1, y2, y3, g1, g2, g3 = get_y_g_triangles(hexagon, GREEN, GREEN, stroke_width=HEXAGON_STROKE_WIDTH)\n        isometry_label = MathTex(f'I_1', font_size=30).move_to([1.5, 0, 0])\n        for i, (y, g) in enumerate(zip([y1, y2, y3], [g1, g2, g3])):\n            if i == 0:\n                self.play(FadeIn(y), Write(isometry_label))\n            else:\n                self.play(FadeIn(y), Transform(isometry_label, MathTex(f'I_{i + 1}', font_size=30).move_to([1.5, 0, 0])))\n            self.play(ReplacementTransform(y, g))\n            self.wait(1 / 3)\n            if i == 2:\n                self.play(FadeOut(g), Unwrite(isometry_label))\n            else:\n                self.play(FadeOut(g))\n        self.add_subcaption('Diese k\u00f6nnen wir uns folgenderma\u00dfen konstruieren.', duration=2)\n        self.wait(2)\n        self.add_subcaption('Mithilfe sogenannter M\u00f6biustransformationen, Isometrien in der hyperbolischen Ebene, ', duration=5)\n        self.wait(5)\n        p = y1.polygon_points[2]\n        zero = np.array([0, 0, 0])\n        mobius_transform = mobius_transform_poincare_disk(p, zero)\n        transformed_hexagon_points = [mobius_transform(point) for point in hexagon.polygon_points]\n        transformed_hexagon = HyperbolicPolygon(transformed_hexagon_points, add_dots=False, stroke_width=HEXAGON_STROKE_WIDTH)\n        transformed_diagonals = HexagonMainDiagonals(transformed_hexagon, stroke_width=HEXAGON_STROKE_WIDTH)\n        dot_p = Dot(p, radius=0.05, color=YELLOW)\n        self.add_foreground_mobjects(dot_p)\n        self.add_subcaption('k\u00f6nnen wir den Schnittpunkt der beiden Dreiecke auf den Ursprung abbilden.', duration=3)\n        self.play(Create(dot_p))\n        self.play(dot_p.animate.move_to(mobius_transform(p)), ReplacementTransform(hexagon, transformed_hexagon), ReplacementTransform(diagonals, transformed_diagonals), run_time=2)\n        self.wait(3)\n        self.add_subcaption('Die beiden Diagonalen, die den Punkt schneiden, sind nun beides Geraden durch den Ursprung.', duration=3)\n        self.wait(1)\n        self.add_foreground_mobjects(transformed_diagonals.arc1, transformed_diagonals.arc3)\n        self.play(Indicate(transformed_diagonals.arc1), Indicate(transformed_diagonals.arc3))\n        self.remove_foreground_mobjects(transformed_diagonals.arc1, transformed_diagonals.arc3)\n        self.wait(4)\n        self.add_subcaption('Deshalb k\u00f6nnen wir einfach eine Punktspiegelung am Ursprung durchf\u00fchren, sodass das rechte Dreieck auf das linke transformiert wird.', duration=7)\n        triangle1 = HyperbolicPolygon([transformed_hexagon_points[-1], transformed_hexagon_points[0], zero], add_dots=False, color=YELLOW, stroke_width=HEXAGON_STROKE_WIDTH)\n        triangle2 = HyperbolicPolygon([transformed_hexagon_points[2], transformed_hexagon_points[3], zero], add_dots=False, color=YELLOW, stroke_width=HEXAGON_STROKE_WIDTH)\n        self.play(FadeIn(triangle1))\n        self.wait(2)\n        y1_label = MathTex('Y_1', font_size=15).move_to([0.35, -0.2, 0])\n        g1_label = MathTex('G_1', font_size=15).move_to([-0.4, 0.2, 0])\n        isometry_formula1 = MathTex('I_1(Y_1) = G_1', font_size=20).move_to([1.35, 0, 0], LEFT)\n        isometry_formula2 = MathTex('I_2(Y_2) = G_2', font_size=20).move_to([1.35, 0, 0], LEFT)\n        isometry_formula3 = MathTex('I_3(Y_3) = G_3', font_size=20).next_to(isometry_formula2, DOWN, buff=0.1)\n        self.play(Write(y1_label), Write(g1_label))\n        self.play(self.camera.frame.animate.set(width=6), ReplacementTransform(triangle1, triangle2), Write(isometry_formula1))\n        self.wait(4)\n        self.add_subcaption('Das ganze geht nat\u00fcrlich nicht nur f\u00fcr das erste Dreieckspaar, sondern f\u00fcr alle.', duration=3)\n        self.wait(2)\n        self.play(isometry_formula1.animate.next_to(isometry_formula2, UP, buff=0.1))\n        self.play(TransformFromCopy(isometry_formula1, isometry_formula2))\n        self.play(TransformFromCopy(isometry_formula2, isometry_formula3))\n        isometry_formula_transformed = MathTex('I_k(Y_k) = G_k', font_size=20).move_to([1.35, 0, 0], LEFT)\n        self.play(ReplacementTransform(isometry_formula1, isometry_formula_transformed), ReplacementTransform(isometry_formula2, isometry_formula_transformed), ReplacementTransform(isometry_formula3, isometry_formula_transformed))\n        self.wait(2)\n        self.play(self.camera.frame.animate.move_to(isometry_formula_transformed.get_center()), FadeOut(circle, g1_label, y1_label, transformed_hexagon, transformed_diagonals, dot_p, triangle2), isometry_formula_transformed.animate.set(font_size=48))\n        self.remove(circle, dot_p)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Demonstrate a series of algebraic manipulations of mathematical formulas related to geometric properties, culminating in the visualization of a hyperbolic hexagon and related geometric elements."}, {"role": "assistant", "content": "from typing import Union\nimport numpy as np\nfrom manim import Create, Circle, MovingCameraScene, BLUE, Tex, Write, FadeOut, FadeIn, PURPLE, WHITE, YELLOW, GREEN, Uncreate, RED, VGroup, LEFT, DOWN, Dot, TransformFromCopy, Transform, Flash, MathTex, ReplacementTransform, ApplyWave, Group, GREY, Unwrite, Square, Indicate, UP, TexTemplate, RIGHT, GREEN_B, ORANGE, GREEN_E, PURPLE_E\nfrom manim.utils import rate_functions\nfrom animation_constants import OUTER_CIRCLE_COLOR, HEXAGON_STROKE_WIDTH, HEXAGON_DOT_CIRCLE_RADIUS, OUTER_CIRCLE_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, get_intersection_in_unit_circle_of_two_tangent_circles, get_intersections_of_n_tangent_circles, get_intersection_points_of_n_tangent_circles, get_intersection_from_angles, mobius_transform_poincare_disk\nfrom hexagon import HexagonMainDiagonals, IntersectionTriangle, HexagonAngles, HexagonCircles\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene5(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 6\n        isometry_formula = MathTex('I_k(Y_k) = G_k')\n        formula = MathTex('\\\\Rightarrow ', 'A(Y_k)', ' = ', 'A(G_k)')\n        self.add(isometry_formula)\n        self.add_subcaption('Da wir eine Isometrie zwischen den beiden Dreiecken haben, sind die alternierenden Umf\u00e4nge der Dreiecke gleich.', duration=6)\n        self.wait(1)\n        self.play(isometry_formula.animate.next_to(formula, UP))\n        self.play(Write(formula.shift(0.1 * RIGHT)))\n        self.wait(5)\n        formula1, formula2, formula3 = VGroup(MathTex('A(Y_1)', ' = ', 'A(G_1)'), MathTex('A(Y_2)', ' = ', 'A(G_2)'), MathTex('A(Y_3)', ' = ', 'A(G_3)')).arrange(DOWN)\n        self.add_subcaption('Diese Formeln k\u00f6nnen wir explizit f\u00fcr alle drei Dreieckspaare aufschreiben', duration=3)\n        self.play(FadeOut(isometry_formula), TransformFromCopy(formula[1], formula1[0]), TransformFromCopy(formula[2], formula1[1]), TransformFromCopy(formula[3], formula1[2]))\n        self.play(TransformFromCopy(formula[1], formula3[0]), TransformFromCopy(formula[2], formula3[1]), TransformFromCopy(formula[3], formula3[2]))\n        self.play(ReplacementTransform(formula[1], formula2[0]), ReplacementTransform(formula[2], formula2[1]), ReplacementTransform(formula[3], formula2[2]), FadeOut(formula[0]))\n        self.wait(2)\n        formula1_transformed, formula2_transformed, formula3_transformed = VGroup(MathTex('A(Y_1)', ' - ', 'A(G_1)', ' = ', '0'), MathTex('A(Y_2)', ' - ', 'A(G_2)', ' = ', '0'), MathTex('A(Y_3)', ' - ', 'A(G_3)', ' = ', '0')).arrange(DOWN)\n        self.add_subcaption('und den Umfang von G_k auf die andere Seite bringen.', duration=3)\n        self.play(ReplacementTransform(formula1[0], formula1_transformed[0]), ReplacementTransform(formula1[1], formula1_transformed[3]), ReplacementTransform(formula1[2], formula1_transformed[2]), Write(formula1_transformed[1]), Write(formula1_transformed[4]), ReplacementTransform(formula2[0], formula2_transformed[0]), ReplacementTransform(formula2[1], formula2_transformed[3]), ReplacementTransform(formula2[2], formula2_transformed[2]), Write(formula2_transformed[1]), Write(formula2_transformed[4]), ReplacementTransform(formula3[0], formula3_transformed[0]), ReplacementTransform(formula3[1], formula3_transformed[3]), ReplacementTransform(formula3[2], formula3_transformed[2]), Write(formula3_transformed[1]), Write(formula3_transformed[4]))\n        self.wait(3.5)\n        formula_combined = MathTex('A(Y_1)', ' + ', 'A(Y_2)', ' + ', 'A(Y_3)', ' - ', '(', 'A(G_1)', ' + ', 'A(G_2)', ' + ', 'A(G_3)', ')', ' = ', '0', font_size=20)\n        self.add_subcaption('Nun k\u00f6nnen wir alles zusammenaddieren und erhalten folgende Formel.', duration=4)\n        self.play(ReplacementTransform(formula1_transformed[0], formula_combined[0]), ReplacementTransform(formula2_transformed[0], formula_combined[2]), ReplacementTransform(formula3_transformed[0], formula_combined[4]), ReplacementTransform(formula1_transformed[2], formula_combined[7]), ReplacementTransform(formula3_transformed[2], formula_combined[9]), ReplacementTransform(formula2_transformed[2], formula_combined[11]), FadeOut(formula1_transformed[1], formula2_transformed[1], formula3_transformed[1]), ReplacementTransform(VGroup(formula1_transformed[1], formula2_transformed[1], formula3_transformed[1]), formula_combined[5]), ReplacementTransform(VGroup(formula1_transformed[3], formula2_transformed[3], formula3_transformed[3]), formula_combined[13]), ReplacementTransform(VGroup(formula1_transformed[4], formula2_transformed[4], formula3_transformed[4]), formula_combined[14]), Write(formula_combined[1]), Write(formula_combined[3]), Write(formula_combined[6]), Write(formula_combined[8]), Write(formula_combined[10]), Write(formula_combined[12]))\n        self.wait(3.5)\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=OUTER_CIRCLE_STROKE_WIDTH)\n        phis = [0.3, 1.6, 2.2, 3.4, 4.3, 5.9]\n        hexagon = HyperbolicPolygon.from_polar(phis, add_dots=False, stroke_width=HEXAGON_STROKE_WIDTH)\n        diagonals = HexagonMainDiagonals(hexagon, stroke_width=HEXAGON_STROKE_WIDTH)\n        new_formula = MathTex('0 &=', 'A(Y_1)', '+', 'A(Y_2)', '+', 'A(Y_3)', '\\\\\\\\', '&-(', 'A(G_1)', '+', 'A(G_2)', '+', 'A(G_3)', ')', font_size=17).move_to([1.25, 0.5, 0], aligned_edge=LEFT)\n        self.play(FadeIn(circle, hexagon, diagonals), ReplacementTransform(formula_combined, new_formula), self.camera.frame.animate.move_to([0.8, 0, 0]))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Animate a hyperbolic hexagon and its diagonals, then illustrate the relationship between triangle perimeters and the hexagon's alternating perimeter using labels, sub-captions, and graphical transformations."}, {"role": "assistant", "content": "from typing import Union\nimport numpy as np\nfrom manim import Create, Circle, MovingCameraScene, BLUE, Tex, Write, FadeOut, FadeIn, PURPLE, WHITE, YELLOW, GREEN, Uncreate, RED, VGroup, LEFT, DOWN, Dot, TransformFromCopy, Transform, Flash, MathTex, ReplacementTransform, ApplyWave, Group, GREY, Unwrite, Square, Indicate, UP, TexTemplate, RIGHT, GREEN_B, ORANGE, GREEN_E, PURPLE_E\nfrom manim.utils import rate_functions\nfrom animation_constants import OUTER_CIRCLE_COLOR, HEXAGON_STROKE_WIDTH, HEXAGON_DOT_CIRCLE_RADIUS, OUTER_CIRCLE_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, get_intersection_in_unit_circle_of_two_tangent_circles, get_intersections_of_n_tangent_circles, get_intersection_points_of_n_tangent_circles, get_intersection_from_angles, mobius_transform_poincare_disk\nfrom hexagon import HexagonMainDiagonals, IntersectionTriangle, HexagonAngles, HexagonCircles\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene6(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 6\n        self.camera.frame.move_to([0.8, 0, 0])\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=OUTER_CIRCLE_STROKE_WIDTH)\n        self.add_foreground_mobject(circle)\n        self.add(circle)\n        phis = [0.3, 1.6, 2.2, 3.4, 4.3, 5.9]\n        hexagon = HyperbolicPolygon.from_polar(phis, add_dots=False, stroke_width=HEXAGON_STROKE_WIDTH)\n        diagonals = HexagonMainDiagonals(hexagon, stroke_width=HEXAGON_STROKE_WIDTH)\n        self.add(hexagon, diagonals)\n        y1_label = MathTex('Y_1', font_size=15).move_to([0.5, 0, 0])\n        y2_label = MathTex('Y_2', font_size=15).move_to([-0.2, 0.55, 0])\n        y3_label = MathTex('Y_3', font_size=15).move_to([-0.35, -0.25, 0])\n        g1_label = MathTex('G_1', font_size=15).move_to([-0.3, 0.15, 0])\n        g2_label = MathTex('G_2', font_size=15).move_to([0.1, -0.2, 0])\n        g3_label = MathTex('G_3', font_size=15).move_to([0.2, 0.25, 0])\n        y1, y2, y3, g1, g2, g3 = get_y_g_triangles(hexagon, [RED, BLUE, BLUE], [BLUE, RED, RED], stroke_width=HEXAGON_STROKE_WIDTH)\n        intersecting_triangle = IntersectionTriangle(diagonals, color=RED, dot_color=RED, stroke_width=HEXAGON_STROKE_WIDTH)\n        intersecting_triangle2 = IntersectionTriangle(diagonals, color=PURPLE, dot_color=PURPLE, stroke_width=HEXAGON_STROKE_WIDTH)\n        formula1 = MathTex('0 &=', 'A(Y_1)', '+', 'A(Y_2)', '+', 'A(Y_3)', '\\\\\\\\', '&-(', 'A(G_1)', '+', 'A(G_2)', '+', 'A(G_3)', ')', font_size=17).move_to([1.25, 0.5, 0], aligned_edge=LEFT)\n        self.add(formula1)\n        self.add_subcaption('Was bedeutet diese Summe jetzt eigentlich? Betrachten wir das ganze im Bild.', duration=4)\n        self.wait(2)\n        self.play(formula1[1].animate.set_color(BLUE), ApplyWave(formula1[1], amplitude=0.05), Write(y1_label))\n        self.play(Create(y1), run_time=3)\n        self.play(formula1[3].animate.set_color(BLUE), ApplyWave(formula1[3], amplitude=0.05), Unwrite(y1_label), Write(y2_label))\n        self.play(Create(y2), run_time=3)\n        self.play(formula1[5].animate.set_color(BLUE), ApplyWave(formula1[5], amplitude=0.05), Unwrite(y2_label), Write(y3_label))\n        self.play(Create(y3), run_time=3)\n        self.add_subcaption('Wenn wir den Umfang der G_i abziehen, k\u00fcrzt sich ein Teil mit dem Umfang der Y_i weg.', duration=4)\n        self.play(formula1[8].animate.set_color(RED), ApplyWave(formula1[8], amplitude=0.05), Unwrite(y3_label), Write(g1_label))\n        self.play(Create(g1.arcs[0]))\n        self.play(Uncreate(y3.arcs[2]))\n        self.add(intersecting_triangle.dots[2])\n        self.play(Create(intersecting_triangle.arcs[1].reverse_direction()))\n        self.add(intersecting_triangle.dots[1])\n        self.play(Create(intersecting_triangle.arcs[0].reverse_direction()), rate_func=rate_functions.ease_out_cubic)\n        self.add(intersecting_triangle.dots[0])\n        self.play(Uncreate(y2.arcs[1]))\n        self.play(formula1[10].animate.set_color(RED), ApplyWave(formula1[10], amplitude=0.05), Unwrite(g1_label), Write(g2_label))\n        self.play(Create(g2.arcs[0]))\n        self.play(Uncreate(y1.arcs[2]))\n        self.add(intersecting_triangle2.dots[1])\n        self.play(Create(intersecting_triangle2.arcs[0].reverse_direction()))\n        self.add(intersecting_triangle2.dots[0])\n        self.play(Create(intersecting_triangle.arcs[2].reverse_direction()))\n        self.play(Uncreate(y3.arcs[1]))\n        self.play(formula1[12].animate.set_color(RED), ApplyWave(formula1[12], amplitude=0.05), Unwrite(g2_label), Write(g3_label))\n        self.play(Create(g3.arcs[0]))\n        self.play(Uncreate(y2.arcs[2]))\n        self.play(Create(intersecting_triangle2.arcs[2].reverse_direction()))\n        self.add(intersecting_triangle2.dots[2])\n        self.play(Create(intersecting_triangle2.arcs[1].reverse_direction()))\n        self.play(Uncreate(y1.arcs[1]))\n        self.remove(*[intersecting_triangle.arcs[i] for i in range(3)])\n        self.add_subcaption('Wir sehen, dass wir zweimal den Umfang des inneren Dreiecks sowie den alternierenden Umfang des Hexagons aufsummiert haben.', duration=7)\n        self.play(Unwrite(g3_label))\n        self.wait(4)\n        formula2 = MathTex('\\\\mathrm{altPer}(P) - 2 \\\\cdot \\\\mathrm{Per}(T_P) = 0', font_size=17).next_to(formula1, DOWN)\n        self.play(TransformFromCopy(formula1, formula2))\n        self.wait(3)\n        self.add_subcaption('Insgesamt folgt unsere Behauptung.', duration=3)\n        formula3 = MathTex('\\\\mathrm{altPer}(P) = 2 \\\\cdot \\\\mathrm{Per}(T_P)', font_size=17).next_to(formula2, DOWN)\n        self.play(TransformFromCopy(formula2, formula3))\n        self.wait(5)\n        self.play(self.camera.frame.animate.move_to([0, 0, 0]), FadeOut(formula1, formula2, formula3, hexagon, intersecting_triangle2, diagonals, *[triangle.arcs[0] for triangle in [g1, g2, g3, y1, y2, y3]], y1, y2, y3, *intersecting_triangle.dots, *intersecting_triangle2.dots))\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Animate the construction of a hyperbolic hexagon with inscribed tangent circles and demonstrate the alternating perimeter property, culminating in the transformation to a Euclidean hexagon."}, {"role": "assistant", "content": "from typing import Union\nimport numpy as np\nfrom manim import Create, Circle, MovingCameraScene, BLUE, Tex, Write, FadeOut, FadeIn, PURPLE, WHITE, YELLOW, GREEN, Uncreate, RED, VGroup, LEFT, DOWN, Dot, TransformFromCopy, Transform, Flash, MathTex, ReplacementTransform, ApplyWave, Group, GREY, Unwrite, Square, Indicate, UP, TexTemplate, RIGHT, GREEN_B, ORANGE, GREEN_E, PURPLE_E\nfrom manim.utils import rate_functions\nfrom animation_constants import OUTER_CIRCLE_COLOR, HEXAGON_STROKE_WIDTH, HEXAGON_DOT_CIRCLE_RADIUS, OUTER_CIRCLE_STROKE_WIDTH\nfrom euclidean_hexagon import EuclideanHexagon, get_diagonals\nfrom geometry_util import polar_to_point, get_intersection_in_unit_circle_of_two_tangent_circles, get_intersections_of_n_tangent_circles, get_intersection_points_of_n_tangent_circles, get_intersection_from_angles, mobius_transform_poincare_disk\nfrom hexagon import HexagonMainDiagonals, IntersectionTriangle, HexagonAngles, HexagonCircles\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene7(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 6\n        circle = Circle(color=OUTER_CIRCLE_COLOR, stroke_width=OUTER_CIRCLE_STROKE_WIDTH)\n        self.add(circle)\n        self.add_foreground_mobject(circle)\n        phis = HexagonAngles(np.array([0.3, 1.6, 2.2, 3, 4.3]))\n        hexagon = HyperbolicPolygon.from_polar(phis, color=[RED, BLUE, RED, BLUE, RED, BLUE], add_dots=False, stroke_width=HEXAGON_STROKE_WIDTH)\n        self.add_subcaption('Jetzt beweisen wir endlich den Sieben-Kreise-Satz.', duration=3)\n        self.wait(3)\n        self.add_subcaption('Schauen wir uns hierf\u00fcr ein hyperbolisches Hexagon mit Kreisen an, die tangential zum gro\u00dfen Kreis liegen,', duration=5)\n        self.play(Create(hexagon), run_time=4)\n        inner_circles = HexagonCircles(hexagon, first_circle_radius=0.4, color=GREEN_B, stroke_width=HEXAGON_STROKE_WIDTH)\n        inner_intersections = get_intersections_of_n_tangent_circles(inner_circles.circles, color=PURPLE, radius=0.03)\n        inner_intersection_points = get_intersection_points_of_n_tangent_circles(inner_circles.circles)\n        self.play(Create(inner_circles[0]), run_time=1)\n        self.add_subcaption('wobei sich benachbarte Kreise in exakt einem Punkt ber\u00fchren.', duration=5)\n        for i in range(1, 6):\n            self.play(Create(inner_circles.circles[i]), run_time=1)\n            self.play(Create(inner_intersections[i - 1]), run_time=0.5)\n        self.play(Create(inner_intersections[-1]), run_time=0.5)\n        self.add_foreground_mobjects(*inner_intersections)\n        self.add(hexagon)\n        self.play(self.camera.frame.animate.set(width=4).move_to([0.8, 0, 0]))\n        self.add_subcaption('Wenn wir nun den alternierenden Umfang dieses Hexagons betrachten, sehen wir, dass dieser genau null ist, da sich die einzelnen St\u00fccke in den Kreisen rausk\u00fcrzen.', duration=9)\n        formula = MathTex('\\\\mathrm{AltPer}(P)', '=', '0', '+', '0', font_size=18).move_to([1.15, 0, 0], LEFT)\n        self.play(Write(formula[0]))\n        zero_0 = formula[2]\n        plus_1 = formula[3].copy()\n        zero_1 = formula[4].copy()\n        plus_2 = formula[3].copy()\n        zero_2 = formula[4].copy()\n        plus_3 = formula[3].copy()\n        zero_3 = formula[4].copy()\n        plus_4 = formula[3].copy()\n        zero_4 = formula[4].copy()\n        plus_5 = formula[3].copy()\n        zero_5 = formula[4].copy()\n        arcs = self._get_half_arcs(inner_intersection_points, hexagon.polygon_points, 0, RED, BLUE)\n        grey_arcs = []\n        arcs_grey = self._get_half_arcs(inner_intersection_points, hexagon.polygon_points, 0, GREY, GREY)\n        grey_arcs.append(arcs_grey)\n        self.add(arcs_grey)\n        self.add(arcs)\n        self.play(Write(formula[1]), ReplacementTransform(arcs, zero_0))\n        self.wait(1)\n        grey_arcs.append(self._perform_arc_transform(plus_1, zero_1, zero_0, 1, inner_intersection_points, hexagon.polygon_points))\n        grey_arcs.append(self._perform_arc_transform(plus_2, zero_2, zero_0, 2, inner_intersection_points, hexagon.polygon_points))\n        grey_arcs.append(self._perform_arc_transform(plus_3, zero_3, zero_0, 3, inner_intersection_points, hexagon.polygon_points))\n        grey_arcs.append(self._perform_arc_transform(plus_4, zero_4, zero_0, 4, inner_intersection_points, hexagon.polygon_points))\n        grey_arcs.append(self._perform_arc_transform(plus_5, zero_5, zero_0, 5, inner_intersection_points, hexagon.polygon_points))\n        self.add_subcaption('Und das entspricht genau dem Umfang des Dreiecks in der Mitte aufgrund des Satzes, den wir gerade eben bewiesen haben.', duration=6)\n        diagonals = HexagonMainDiagonals(hexagon, color=ORANGE, stroke_width=HEXAGON_STROKE_WIDTH)\n        formula2 = MathTex('\\\\mathrm{AltPer}(P) = 0', font_size=formula.font_size).move_to(formula.get_left(), LEFT)\n        self.add(formula2)\n        self.remove(formula[0], formula[1], formula[2])\n        self.play(formula2.animate.set(font_size=12).move_to([1.1, 0, 0], LEFT))\n        formula3 = MathTex('= \\\\pm 2 \\\\cdot \\\\mathrm{Per}(T_P)', font_size=12).next_to(formula2, buff=0.05)\n        self.play(Write(formula3))\n        self.wait(3)\n        self.add_foreground_mobjects(*inner_intersections, circle)\n        self.play(Create(diagonals), run_time=3)\n        self.add_subcaption('Also treffen sich die Hauptdiagonalen des Hexagons in einem Punkt.', duration=3)\n        intersection = get_intersection_in_unit_circle_of_two_tangent_circles(diagonals.arc1.circle_center, diagonals.arc1.radius, diagonals.arc2.circle_center, diagonals.arc2.radius)\n        intersection_dot = Dot(intersection, color=YELLOW, radius=0.03)\n        self.remove(*grey_arcs)\n        for i in range(6):\n            hexagon.arcs[i].set_color(GREY)\n        self.play(Create(intersection_dot))\n        self.play(Flash(intersection_dot, line_stroke_width=HEXAGON_STROKE_WIDTH), FadeOut(formula2, formula3))\n        self.wait(1)\n        self.add_subcaption('Nun m\u00fcssen wir nur noch die Transformation vom Poincar\u00e9-Modell in das Klein-Modell durchf\u00fchren.', duration=4)\n        euclidean_hexagon = EuclideanHexagon(phis, color=GREY, stroke_width=2)\n        euclidean_diagonals = get_diagonals(hexagon, color=ORANGE, stroke_width=2)\n        euclidean_intersection_dot = Dot(get_intersection_from_angles(phis[0], phis[3], phis[1], phis[4]), color=YELLOW, radius=0.03)\n        self.add_foreground_mobjects(hexagon, diagonals, *inner_intersections, intersection_dot, circle)\n        self.play(self.camera.frame.animate.set(width=6).move_to([0, 0, 0]))\n        self.play(*[ReplacementTransform(hexagon.arcs[i], euclidean_hexagon.edges[i]) for i in range(6)], ReplacementTransform(diagonals.arc1, euclidean_diagonals[0].reverse_direction()), ReplacementTransform(diagonals.arc2, euclidean_diagonals[1].reverse_direction()), ReplacementTransform(diagonals.arc3, euclidean_diagonals[2].reverse_direction()), ReplacementTransform(intersection_dot, euclidean_intersection_dot), *[inner_circles[i].animate.set_color(GREEN_E) for i in range(len(inner_circles))], *[inner_intersections[i].animate.set_color(PURPLE_E) for i in range(len(inner_intersections))], run_time=3)\n        self.wait(2)\n        self.add_subcaption('Die Aussage gilt auch hier, weil die Schnittpunkte der Diagonalen weiterhin durch einen Punkt verlaufen.', duration=6)\n        self.wait(6)\n        self.add_subcaption('Das entspricht genau dem Szenario aus dem urspr\u00fcnglichen Sieben-Kreise-Satz, den wir somit bewiesen haben.', duration=6)\n        self.wait(6)\n        proof_square = Square(side_length=0.15, stroke_width=2).move_to([2, -1, 0], DOWN)\n        self.play(Create(proof_square), run_time=2)\n        self.wait(5)\n\n    def _perform_arc_transform(self, plus, zero, zero_0, i, intersection_points, polygon_points):\n        col1 = RED if i % 2 == 0 else BLUE\n        col2 = BLUE if i % 2 == 0 else RED\n        arcs = self._get_half_arcs(intersection_points, polygon_points, i, col1=col1, col2=col2)\n        arcs_grey = self._get_half_arcs(intersection_points, polygon_points, i, col1=GREY, col2=GREY)\n        self.add(arcs_grey)\n        self.add(arcs)\n        self.play(Write(plus), ReplacementTransform(arcs, zero))\n        self.play(ReplacementTransform(Group(plus, zero), zero_0))\n        self.wait(1)\n        return arcs_grey\n\n    @staticmethod\n    def _get_half_arcs(intersection_points, polygon_points, i, col1, col2):\n        arc1 = HyperbolicArcBetweenPoints(intersection_points[i], polygon_points[i], color=col1, stroke_width=HEXAGON_STROKE_WIDTH)\n        arc2 = HyperbolicArcBetweenPoints(intersection_points[i - 1], polygon_points[i], color=col2, stroke_width=HEXAGON_STROKE_WIDTH)\n        return Group(arc1, arc2)"}]}
{"messages": [{"role": "user", "content": "Animate the creation of hexagonal shapes with varying properties, transitioning to a single hexagonal shape and then displaying its perimeter and alternating perimeter formulas with corresponding visual elements."}, {"role": "assistant", "content": "from math import pi\nimport numpy as np\nfrom manim import Scene, Circle, Dot, Create, FadeIn, FadeOut, WHITE, BLUE, GREEN_B, Transform, MovingCameraScene, VGroup, DecimalNumber, RIGHT, Tex, LEFT, UP, MathTex, Write, Indicate, TransformFromCopy, RED, DOWN, GREY_B, ORANGE, ArcBetweenPoints, GREEN_D, ORIGIN, FadeTransform\nfrom animation_constants import *\nfrom geometry_util import polar_to_point, hyperbolic_distance_function, create_min_circle_radius, get_intersection_in_unit_circle_of_two_tangent_circles, hyperbolic_circle_to_euclidean_circle\nfrom hexagon_util import create_phis, create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene1(MovingCameraScene):\n\n    def construct(self):\n        s_1 = MathTex('S_1', color=BLUE, font_size=15).move_to([0.15, 0.5, 0])\n        s_2 = MathTex('S_2', color=BLUE, font_size=15).move_to([-0.6, 0.45, 0])\n        s_2_red = MathTex('S_2', color=RED, font_size=15).move_to([-0.6, 0.45, 0])\n        s_3 = MathTex('S_3', color=BLUE, font_size=15).move_to([-0.7, -0.1, 0])\n        s_4 = MathTex('S_4', color=BLUE, font_size=15).move_to([-0.1, -0.6, 0])\n        s_4_red = MathTex('S_4', color=RED, font_size=15).move_to([-0.1, -0.6, 0])\n        s_5 = MathTex('S_5', color=BLUE, font_size=15).move_to([0.4, -0.55, 0])\n        s_6 = MathTex('S_6', color=BLUE, font_size=15).move_to([0.6, 0, 0])\n        s_6_red = MathTex('S_6', color=RED, font_size=15).move_to([0.6, 0, 0])\n        s_k = [s_1, s_2, s_3, s_4, s_5, s_6]\n        s_k_colored = [s_1, s_2_red, s_3, s_4_red, s_5, s_6_red]\n        timings = [8, 5]\n        timings.reverse()\n        formula_size = 15\n        self.camera.frame.width = 9\n        text_non_ideal_ideal = VGroup(Tex('nonideal\\\\, hexagon', font_size=20, color=BLUE, stroke_width=1), Tex('ideal\\\\, hexagon', font_size=20, color=GREEN_B, stroke_width=1)).arrange(aligned_edge=LEFT, direction=DOWN)\n        position = [[-3, 1.3, 0], [0, 1.3, 0], [3, 1.3, 0], [-3, -1.3, 0], [0, -1.3, 0], [3, -1.3, 0]]\n        fixed_phis = [[0.2, 1.5, 1.8, 4, 4.8, 6], [0.5, 1.5, 2.4, 3.2, 4, 5], [1, 1.8, 2.5, 3.3, 3.8, 5.5], [0.5, 2, 2.4, 2.9, 4, 4.6, 5], [1.5, 2.4, 3.2, 4, 5, 5.5]]\n        fixed_radius = [[0.7, 0.73, 0.8, 0.7, 0.6, 0.7], [0.6, 0.8, 0.9, 0.66, 0.5, 0.6], [0.5, 0.6, 0.7, 0.8, 0.6, 0.6], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]\n        for i in range(0, 6):\n            if i == 5:\n                self.play(Write(text_non_ideal_ideal.move_to(position[i]), stroke_width=0.5))\n            else:\n                hexagon = HyperbolicPolygon.from_polar(fixed_phis[i], fixed_radius[i], dot_radius=0.01, dot_color=BLUE, stroke_width=2, color=BLUE)\n                group = VGroup(hexagon, Circle(color=WHITE)).move_to(position[i])\n                if i == 3 or i == 4:\n                    hexagon = HyperbolicPolygon.from_polar(fixed_phis[i], add_dots=False, stroke_width=2, color=GREEN_B)\n                    group = VGroup(hexagon, Circle(color=WHITE, stroke_width=HEXAGON_STROKE_WIDTH)).move_to(position[i])\n                    self.play(FadeIn(group[1]))\n                    self.add_foreground_mobjects(group[1])\n                    self.play(Create(group[0]), run_time=2.5, rate_func=lambda a: a)\n                else:\n                    self.play(FadeIn(Circle(color=WHITE, stroke_width=HEXAGON_STROKE_WIDTH).move_to(position[i])))\n                    for k in range(0, 6):\n                        self.add(hexagon.dots[k])\n                        self.play(Create(group[0].arcs[k]), run_time=0.4, rate_func=lambda a: a)\n        self.wait(2)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.camera.frame.width = 6\n        circle = Circle(color=WHITE, stroke_width=HEXAGON_STROKE_WIDTH)\n        self.play(Create(circle))\n        radius = [0.5, 0.7, 0.6, 0.7, 0.5, 0.6]\n        phis = [0.47654, 2.065432, 2.876, 3.87623, 5.024, 5.673]\n        hexagon = HyperbolicPolygon.from_polar(phis, radius, dot_radius=0.01, stroke_width=2)\n        hex_name = MathTex('P', font_size=15).move_to([0.6, 0.4, 0])\n        self.play(FadeIn(hexagon, hex_name))\n        self.wait(2)\n        arc = HyperbolicPolygon.from_polar(phis, radius, dot_radius=0.01, color=BLUE, stroke_width=2).arcs\n        dots = hexagon.dots\n        dots[-1].set_color(BLUE)\n        for i in range(0, 6):\n            dots[i].set_color(BLUE)\n            self.play(Create(arc[i]), Write(s_k[i], stroke_width=0.5), rate_func=lambda a: a, run_time=1)\n        self.play(self.camera.frame.animate.set(width=6).move_to([1.5, 0, 0]))\n        sum1 = per, sum_sk = VGroup(MathTex('\\\\mathrm{Per}(P) = ', font_size=formula_size), MathTex('S_1', ' +', ' S_2', ' + ', 'S_3', ' + ', 'S_4', ' + ', 'S_5', ' + ', 'S_6', font_size=formula_size)).arrange(buff=0.05).move_to([2.5, 0.2, 0])\n        (sum_sk[0].set_color(BLUE), sum_sk[2].set_color(BLUE), sum_sk[4].set_color(BLUE))\n        (sum_sk[6].set_color(BLUE), sum_sk[8].set_color(BLUE), sum_sk[10].set_color(BLUE))\n        alt_sum = MathTex('S_1', '-', ' S_2', '+', ' S_3', '-', ' S_4', '+', ' S_5', '-', ' S_6', font_size=15)\n        (alt_sum[2].set_color(RED), alt_sum[6].set_color(RED), alt_sum[10].set_color(RED))\n        (alt_sum[0].set_color(BLUE), alt_sum[4].set_color(BLUE), alt_sum[8].set_color(BLUE))\n        alt_per = MathTex('\\\\mathrm{AltPer}(P) =', font_size=formula_size)\n        sum2 = VGroup(alt_per, alt_sum).arrange(buff=0.05).next_to(sum1, 0.5 * DOWN, aligned_edge=LEFT)\n        self.play(Write(per, stroke_width=0.5))\n        self.play(TransformFromCopy(VGroup(*arc, *s_k), sum_sk))\n        self.wait(3)\n        hexagon_bi_colored = HyperbolicPolygon.from_polar(phis, radius, dot_radius=0.01, dot_color=RED, stroke_width=2, color=[BLUE, RED, BLUE, RED, BLUE, RED])\n        self.play(FadeIn(hexagon_bi_colored, s_2_red, s_4_red, s_6_red), FadeOut(*hexagon.arcs, *arc, s_2, s_4, s_6))\n        red_arcs = VGroup(hexagon_bi_colored.arcs[1], hexagon_bi_colored.arcs[3], hexagon_bi_colored.arcs[5], s_2_red, s_4_red, s_6_red, *hexagon_bi_colored.dots)\n        self.play(Indicate(red_arcs, color=RED))\n        self.wait(2)\n        self.play(Write(sum2[0], stroke_width=0.5))\n        self.play(TransformFromCopy(VGroup(hexagon_bi_colored, *s_k_colored), sum2[1]))\n        self.wait(5)\n        self.play(*[FadeOut(mob) for mob in self.mobjects], FadeIn(Circle(color=WHITE, stroke_width=HEXAGON_STROKE_WIDTH)))\n        self.play(self.camera.frame.animate.move_to([0, 0, 0]))\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Visualize hyperbolic space by animating a hexagon's transformation, highlighting its vertices and an arc, and showing a changing hyperbolic distance calculation between two points."}, {"role": "assistant", "content": "from math import pi\nimport numpy as np\nfrom manim import Scene, Circle, Dot, Create, FadeIn, FadeOut, WHITE, BLUE, GREEN_B, Transform, MovingCameraScene, VGroup, DecimalNumber, RIGHT, Tex, LEFT, UP, MathTex, Write, Indicate, TransformFromCopy, RED, DOWN, GREY_B, ORANGE, ArcBetweenPoints, GREEN_D, ORIGIN, FadeTransform\nfrom animation_constants import *\nfrom geometry_util import polar_to_point, hyperbolic_distance_function, create_min_circle_radius, get_intersection_in_unit_circle_of_two_tangent_circles, hyperbolic_circle_to_euclidean_circle\nfrom hexagon_util import create_phis, create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene2(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 6\n        s_1 = MathTex('S_1', color=BLUE, font_size=15).move_to([0.2, 0.5, 0])\n        s_1_yellow = MathTex('S_1', color=ORANGE, font_size=15).move_to([0.2, 0.5, 0])\n        s_2 = MathTex('S_2', color=RED, font_size=15).move_to([-0.65, 0.5, 0])\n        s_3 = MathTex('S_3', color=BLUE, font_size=15).move_to([-0.75, -0.1, 0])\n        s_4 = MathTex('S_4', color=RED, font_size=15).move_to([-0.2, -0.7, 0])\n        s_5 = MathTex('S_5', color=BLUE, font_size=15).move_to([0.53, -0.67, 0])\n        s_6 = MathTex('S_6', color=RED, font_size=15).move_to([0.7, 0, 0])\n        s_k = VGroup(s_1, s_2, s_3, s_4, s_5, s_6)\n        radius_disks = [0.5, 0.4]\n        circle = Circle(color=WHITE, stroke_width=HEXAGON_STROKE_WIDTH)\n        self.add_foreground_mobjects(circle)\n        phis = [0.47654, 2.065432, 2.876, 3.87623, 5.024, 5.673]\n        hexagon = HyperbolicPolygon.from_polar(phis, add_dots=False, stroke_width=2, color=[BLUE, RED, BLUE, RED, BLUE, RED])\n        hexagon_grey = HyperbolicPolygon.from_polar(phis, add_dots=False, color=GREY_B, stroke_width=2)\n        arc_colored = HyperbolicPolygon.from_polar(phis, add_dots=False, color=ORANGE, stroke_width=2).arcs[0]\n        self.add(circle)\n        self.play(Create(hexagon, run_time=5))\n        self.play(FadeIn(s_k))\n        self.play(self.camera.frame.animate.move_to([1, 0, 0]))\n        self.wait(1)\n        self.play(FadeIn(hexagon_grey), FadeOut(s_k), FadeOut(hexagon), FadeIn(arc_colored, s_1_yellow))\n        self.wait(1)\n        point1 = hexagon.polygon_points[0]\n        point2 = hexagon.polygon_points[1]\n        arc = hexagon.arcs[0]\n        distance_text = MathTex('\\\\mathrm{dist_h}(a,b) =', font_size=20).move_to([1.2, 0, 0], aligned_edge=LEFT)\n        infinity = MathTex('\\\\infty', font_size=20).next_to(distance_text, buff=0.05)\n        s_0 = Dot(hexagon.polygon_points[0], radius=0.02, color=ORANGE)\n        s_1 = Dot(hexagon.polygon_points[1], radius=0.02, color=ORANGE)\n        a = MathTex('a', font_size=15, color=ORANGE).next_to(s_0, direction=0.16 * DOWN + 0.01 * LEFT)\n        b = MathTex('b', font_size=15, color=ORANGE).next_to(s_1, direction=0.18 * DOWN + 0.01 * LEFT)\n        self.play(Write(VGroup(distance_text, infinity), stroke_width=0.5), FadeIn(a, b, s_0, s_1))\n        self.add_foreground_mobjects(a, b)\n        self.wait(6)\n        distance_number = DecimalNumber(6343.242564, num_decimal_places=2, show_ellipsis=True, group_with_commas=False, font_size=20).next_to(distance_text, buff=0.05)\n        self.remove(infinity)\n        label = VGroup(distance_text, distance_number)\n        step_size = 450\n        for t in range(1, step_size):\n            if t < step_size / 2:\n                transition = 2 * t / step_size\n            else:\n                transition = (1 - t / step_size) * 2\n            interp_point1 = get_intersection_in_unit_circle_of_two_tangent_circles(arc.circle_center, arc.radius, point1, transition * radius_disks[0])\n            interp_point2 = get_intersection_in_unit_circle_of_two_tangent_circles(point2, transition * radius_disks[1], arc.circle_center, arc.radius)\n            new_arc = ArcBetweenPoints(interp_point2, interp_point1, color=ORANGE, radius=arc.radius, stroke_width=2).reverse_direction()\n            self.remove(a, b)\n            self.add(a.next_to(interp_point1, direction=0.2 * DOWN + 0.05 * LEFT), b.next_to(interp_point2, direction=0.2 * DOWN + 0.1 * LEFT))\n            distance = np.exp(hyperbolic_distance_function(interp_point2, interp_point1))\n            distance_number.font_size = 20\n            label.arrange(buff=0.05)\n            label.move_to([1.2, 0, 0], aligned_edge=LEFT)\n            if t == step_size - 1:\n                self.play(Transform(arc_colored, new_arc), Transform(s_0, Dot(interp_point1, radius=0.02, color=ORANGE)), Transform(s_1, Dot(interp_point2, radius=0.02, color=ORANGE)), Transform(distance_number, infinity), run_time=1 / 60, rate_func=lambda a: a)\n            else:\n                self.play(Transform(arc_colored, new_arc), Transform(s_0, Dot(interp_point1, radius=0.02, color=ORANGE)), Transform(s_1, Dot(interp_point2, radius=0.02, color=ORANGE)), distance_number.animate.set_value(distance), run_time=1 / 60, rate_func=lambda a: a)\n        self.remove(s_0, s_1)\n        self.play(FadeOut(a, b))\n        self.wait(9)\n        self.play(*[FadeOut(mob) for mob in self.mobjects], FadeIn(Circle(color=WHITE, stroke_width=HEXAGON_STROKE_WIDTH)))\n        self.play(self.camera.frame.animate.move_to([0, 0, 0]))\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Visualize the convergence of hyperbolic polygons with dynamically shrinking and shifting circles, demonstrating a formula for alternating perimeter."}, {"role": "assistant", "content": "from math import pi\nimport numpy as np\nfrom manim import Scene, Circle, Dot, Create, FadeIn, FadeOut, WHITE, BLUE, GREEN_B, Transform, MovingCameraScene, VGroup, DecimalNumber, RIGHT, Tex, LEFT, UP, MathTex, Write, Indicate, TransformFromCopy, RED, DOWN, GREY_B, ORANGE, ArcBetweenPoints, GREEN_D, ORIGIN, FadeTransform\nfrom animation_constants import *\nfrom geometry_util import polar_to_point, hyperbolic_distance_function, create_min_circle_radius, get_intersection_in_unit_circle_of_two_tangent_circles, hyperbolic_circle_to_euclidean_circle\nfrom hexagon_util import create_phis, create_radius_transition\nfrom hyperbolic_polygon import HyperbolicPolygon, HyperbolicArcBetweenPoints\n\nclass Scene3(MovingCameraScene):\n\n    def construct(self):\n        self.camera.frame.width = 6\n        outer_circle = Circle(color=WHITE, stroke_width=2)\n        self.add(outer_circle)\n        p1 = MathTex('P_1', font_size=20).move_to(ORIGIN)\n        konvergenz = MathTex('P_n \\\\xrightarrow{n \\\\rightarrow \\\\infty}P_\\\\infty', font_size=25).move_to([2.5, 0, 0])\n        s_1 = MathTex('\\\\tilde{S_1}', color=ORANGE, font_size=20).move_to([[0.25, 0.6, 0]])\n        s_2 = MathTex('\\\\tilde{S_2}', color=ORANGE, font_size=20).move_to([-0.65, 0.5, 0])\n        s_3 = MathTex('\\\\tilde{S_3}', color=ORANGE, font_size=20).move_to([-0.8, -0.1, 0])\n        s_4 = MathTex('\\\\tilde{S_4}', color=ORANGE, font_size=20).move_to([-0.14, -0.7, 0])\n        s_5 = MathTex('\\\\tilde{S_5}', color=ORANGE, font_size=20).move_to([0.53, -0.6, 0])\n        s_6 = MathTex('\\\\tilde{S_6}', color=ORANGE, font_size=20).move_to([0.7, -0.1, 0])\n        s_k_text = VGroup(s_1, s_2, s_3, s_4, s_5, s_6)\n        radius = np.array([0.7, 0.6, 0.75, 0.56, 0.65, 0.53])\n        phis = [0.47654, 2.065432, 2.876, 3.87623, 5.024, 5.673]\n        circle_radius = np.array([0.8, 0.8, 0.8, 0.8, 0.5, 0.4])\n        step_size = 50\n        transition = create_radius_transition(radius, step_size=step_size)\n        hexagon = HyperbolicPolygon.from_polar(phis, transition[0], dot_radius=0.01, stroke_width=2)\n        for k in range(0, 6):\n            self.add(hexagon.dots[k])\n            self.play(Create(hexagon.arcs[k]), run_time=0.85, rate_func=lambda a: a)\n        self.play(Write(p1, stroke_width=0.5))\n        self.play(FadeOut(p1))\n        self.play(self.camera.frame.animate.move_to([1.5, 0, 0]))\n        self.play(Write(konvergenz, stroke_width=0.5))\n        for t in range(1, step_size - 1):\n            hexagon_new = HyperbolicPolygon.from_polar(phis, transition[t], dot_radius=0.01, stroke_width=2)\n            self.play(Transform(hexagon, hexagon_new), run_time=0.05, rate_func=lambda a: a)\n        hexagon_new = HyperbolicPolygon.from_polar(phis, transition[-1], dot_radius=0.01, stroke_width=2)\n        self.play(Transform(hexagon, hexagon_new), run_time=0.05, rate_func=lambda a: a)\n        self.wait(3)\n        self.play(FadeOut(hexagon, konvergenz))\n        hex_n_ideal = HyperbolicPolygon.from_polar(phis, radius, dot_radius=0.01, stroke_width=2)\n        self.play(FadeIn(hex_n_ideal), Write(p1, stroke_width=0.5))\n        disks = []\n        euclidean_centers = []\n        euclidean_radii = []\n        for k in range(0, 6):\n            hyperbolic_center = hex_n_ideal.polygon_points[k]\n            hyperbolic_radius = circle_radius[k]\n            eucl_center, eucl_radius = hyperbolic_circle_to_euclidean_circle(hyperbolic_center, hyperbolic_radius)\n            euclidean_centers.append(eucl_center)\n            euclidean_radii.append(eucl_radius)\n            circle = Circle(arc_center=eucl_center, radius=eucl_radius, color=GREEN_B, fill_opacity=0.5, stroke_width=2)\n            disks.append(circle)\n            self.add_foreground_mobjects(circle)\n            self.play(FadeIn(circle))\n        euclidean_centers = np.array(euclidean_centers)\n        euclidean_radii = np.array(euclidean_radii)\n        dynamic_arcs = []\n        for k in range(0, 6):\n            point1 = euclidean_centers[k]\n            radius1 = euclidean_radii[k]\n            point2 = euclidean_centers[(k + 1) % 6]\n            radius2 = euclidean_radii[(k + 1) % 6]\n            arc = hex_n_ideal.arcs[k]\n            intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(arc.circle_center, arc.radius, point1, radius1)\n            intersection2 = get_intersection_in_unit_circle_of_two_tangent_circles(point2, radius2, arc.circle_center, arc.radius)\n            arc_new = ArcBetweenPoints(intersection2, intersection1, color=ORANGE, radius=arc.radius, stroke_width=2).reverse_direction()\n            dynamic_arcs.append(arc_new)\n            self.play(Create(arc_new), Write(s_k_text[k], stroke_width=0.5))\n            if k == 0:\n                distance_text, distance_number = label = VGroup(Tex('$\\\\tilde{S_1}=$', font_size=20), DecimalNumber(np.exp(hyperbolic_distance_function(intersection2, intersection1)), num_decimal_places=2, show_ellipsis=True, group_with_commas=False, font_size=20)).arrange(buff=0.05).move_to([2.4, 0, 0])\n                self.play(Write(label, stroke_width=0.5))\n                self.wait(1)\n                self.play(FadeOut(label))\n        formula = MathTex('&\\\\tilde{S_1} - \\\\tilde{S_2} + \\\\tilde{S_3} - \\\\tilde{S_4} + \\\\tilde{S_5} - \\\\tilde{S_6} \\\\\\\\', '= \\\\, &S_1 - S_2 + S_3 - S_4 + S_5 - S_6 \\\\\\\\', '= \\\\, &\\\\mathrm{AltPer}', '(P_1)', font_size=20).move_to([2.6, 1, 0])\n        self.play(TransformFromCopy(s_k_text, formula[0]))\n        self.wait(2)\n        transformed_disk = disks[0]\n        transformed_arc1 = dynamic_arcs[0]\n        transformed_arc2 = dynamic_arcs[5]\n        step_size_one_direction = 20\n        arc_k = [hex_n_ideal.arcs[0], hex_n_ideal.arcs[1], hex_n_ideal.arcs[2], hex_n_ideal.arcs[3], hex_n_ideal.arcs[4], hex_n_ideal.arcs[5]]\n        circle1_radii_transition = [circle_radius[0] * (1 - t / step_size_one_direction) + 0.3 * t / step_size_one_direction for t in range(step_size_one_direction)] + [circle_radius[0] * t / step_size_one_direction + 0.3 * (1 - t / step_size_one_direction) for t in range(step_size_one_direction + 1)]\n        num_steps = 2 * step_size_one_direction + 1\n        for t in range(num_steps):\n            hyperbolic_radius = circle1_radii_transition[t]\n            eucl_center, eucl_radius = hyperbolic_circle_to_euclidean_circle(hex_n_ideal.polygon_points[0], hyperbolic_radius)\n            new_circle = Circle(eucl_radius, arc_center=eucl_center, color=GREEN_B, fill_opacity=0.5, stroke_width=2)\n            moving_intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(arc_k[0].circle_center, arc_k[0].radius, eucl_center, eucl_radius)\n            intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(euclidean_centers[1], euclidean_radii[1], arc_k[0].circle_center, arc_k[0].radius)\n            arc_new1 = ArcBetweenPoints(intersection1, moving_intersection1, color=ORANGE, radius=arc_k[0].radius, stroke_width=2).reverse_direction()\n            moving_intersection2 = get_intersection_in_unit_circle_of_two_tangent_circles(eucl_center, eucl_radius, arc_k[5].circle_center, arc_k[5].radius)\n            intersection2 = get_intersection_in_unit_circle_of_two_tangent_circles(arc_k[5].circle_center, arc_k[5].radius, euclidean_centers[5], euclidean_radii[5])\n            arc_new2 = ArcBetweenPoints(moving_intersection2, intersection2, color=ORANGE, radius=arc_k[5].radius, stroke_width=2).reverse_direction()\n            self.play(Transform(transformed_disk, new_circle), Transform(transformed_arc1, arc_new1), Transform(transformed_arc2, arc_new2), rate_func=lambda a: a, run_time=3 / num_steps)\n        self.wait(7)\n        transformed_disks = VGroup(disks[0], disks[1], disks[2], disks[3], disks[4], disks[5])\n        transformed_arcs = VGroup(dynamic_arcs[0], dynamic_arcs[1], dynamic_arcs[2], dynamic_arcs[3], dynamic_arcs[4], dynamic_arcs[5])\n        circle_radii_transition = [circle_radius * (1 - t / step_size_one_direction) for t in range(step_size_one_direction)] + [circle_radius * t / step_size_one_direction for t in range(step_size_one_direction + 1)]\n        num_steps = 2 * step_size_one_direction + 1\n        new_circle_group = VGroup()\n        new_arcs_group = VGroup()\n        for t in range(num_steps):\n            if t == (num_steps + 1) / 2:\n                helping_dots = VGroup()\n                for i in range(0, 6):\n                    helping_dots.add(Dot(hex_n_ideal.polygon_points[i], color=ORANGE, radius=0.01))\n                self.add(helping_dots)\n                self.wait(2)\n                self.play(TransformFromCopy(formula[0], formula[1]), TransformFromCopy(formula[0], VGroup(formula[2], formula[3])))\n                self.wait(3)\n                self.remove(helping_dots)\n            for i in range(0, 6):\n                hyperbolic_center1 = hex_n_ideal.polygon_points[i]\n                hyperbolic_radius1 = circle_radii_transition[t][i]\n                hyperbolic_center2 = hex_n_ideal.polygon_points[(i + 1) % 6]\n                hyperbolic_radius2 = circle_radii_transition[t][(i + 1) % 6]\n                eucl_center1, eucl_radius1 = hyperbolic_circle_to_euclidean_circle(hyperbolic_center1, hyperbolic_radius1)\n                eucl_center2, eucl_radius2 = hyperbolic_circle_to_euclidean_circle(hyperbolic_center2, hyperbolic_radius2)\n                new_circle_group.add(Circle(eucl_radius1, arc_center=eucl_center1, color=GREEN_B, fill_opacity=0.5, stroke_width=2))\n                moving_intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(arc_k[i].circle_center, arc_k[i].radius, eucl_center1, eucl_radius1)\n                moving_intersection2 = get_intersection_in_unit_circle_of_two_tangent_circles(eucl_center2, eucl_radius2, arc_k[i].circle_center, arc_k[i].radius)\n                arc_new1 = ArcBetweenPoints(moving_intersection2, moving_intersection1, color=ORANGE, radius=arc_k[i].radius, stroke_width=2).reverse_direction()\n                new_arcs_group.add(arc_new1)\n            self.play(Transform(transformed_disks, new_circle_group), Transform(transformed_arcs, new_arcs_group), rate_func=lambda a: a, run_time=3 / num_steps)\n            new_circle_group = VGroup()\n            new_arcs_group = VGroup()\n        self.wait(3)\n        self.play(FadeOut(s_k_text), FadeOut(p1))\n        self.play(Write(konvergenz, stroke_width=0.5))\n        self.add_foreground_mobjects(outer_circle)\n        disks_group = VGroup(disks[0], disks[1], disks[2], disks[3], disks[4], disks[5])\n        arc_group = VGroup(dynamic_arcs[0], dynamic_arcs[1], dynamic_arcs[2], dynamic_arcs[3], dynamic_arcs[4], dynamic_arcs[5])\n        step_size = 50\n        new_disk_group = VGroup()\n        new_arc_group = VGroup()\n        transition = create_radius_transition(start_point=radius, step_size=step_size)\n        disk_transition = create_radius_transition(start_point=np.linalg.norm(euclidean_centers, axis=1), step_size=step_size, end_point=1 - euclidean_radii)\n        for t in range(1, step_size):\n            hexagon_new = HyperbolicPolygon.from_polar(phis, transition[t], dot_radius=0.01, stroke_width=2)\n            for i in range(0, 6):\n                circle = Circle(radius=euclidean_radii[i], arc_center=polar_to_point(phis[i], disk_transition[t][i]), color=GREEN_B, fill_opacity=0.5, stroke_width=2)\n                new_disk_group.add(circle)\n                moving_arc = HyperbolicArcBetweenPoints(polar_to_point(phis[i], transition[t][i]), polar_to_point(phis[(i + 1) % 6], transition[t][(i + 1) % 6]))\n                moving_intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(moving_arc.circle_center, moving_arc.radius, polar_to_point(phis[i], disk_transition[t][i]), euclidean_radii[i])\n                intersection1 = get_intersection_in_unit_circle_of_two_tangent_circles(polar_to_point(phis[(i + 1) % 6], disk_transition[t][(i + 1) % 6]), euclidean_radii[(i + 1) % 6], moving_arc.circle_center, moving_arc.radius)\n                arc_new = ArcBetweenPoints(intersection1, moving_intersection1, color=ORANGE, radius=moving_arc.radius, stroke_width=2).reverse_direction()\n                new_arc_group.add(arc_new)\n            self.play(Transform(hex_n_ideal, hexagon_new), Transform(disks_group, new_disk_group), Transform(arc_group, new_arc_group), run_time=0.05, rate_func=lambda a: a)\n            new_disk_group = VGroup()\n            new_arc_group = VGroup()\n        self.wait(2)\n        self.play(FadeOut(konvergenz), formula.animate.shift(DOWN))\n        altper_infty = MathTex('(P_\\\\infty)', font_size=20).next_to(formula[2], direction=RIGHT, buff=0.05)\n        self.play(FadeTransform(formula[3], altper_infty))\n        self.wait(6)\n        self.play(*[FadeOut(mob) for mob in self.mobjects])\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Fade in the mathematical formula for the sum of the reciprocals of squares."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass latex_formules(Scene):\n\n    def construct(self):\n        latex = MathTex('\\\\sum_{n=1}^\\\\infty \\\\frac{1}{n^2} = \\\\frac{\\\\pi^2}{6}')\n        self.play(FadeInFrom(latex))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show the expansion of (a-b)^2, coloring the terms red and blue as they are revealed."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass IR_amoinsb_2(Scene):\n\n    def construct(self):\n        formula = TexMobject('(', 'a', '-', 'b', ')', '^{2}', '=', 'a', '^{2}', '-', '2', 'a', 'b', '+', 'b', '^{2}')\n        formula.scale(2)\n        self.play(Write(formula[0:7]))\n        formula[7].set_color(RED)\n        formula[14].set_color(BLUE)\n        formula[11].set_color(RED)\n        formula[12].set_color(BLUE)\n        self.wait()\n        self.play(ReplacementTransform(formula[1].copy(), formula[7]), Write(formula[8]), ReplacementTransform(formula[2].copy(), formula[9]), ReplacementTransform(formula[3].copy(), formula[9]), Write(formula[13]), ReplacementTransform(formula[3].copy(), formula[14]), Write(formula[15]), run_time=2)\n        self.wait(1.5)\n        self.play(Write(formula[10]), ReplacementTransform(formula[1].copy(), formula[11]), ReplacementTransform(formula[3].copy(), formula[12]), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the algebraic identity a\u00b2 - b\u00b2 = (a - b)(a + b) by highlighting and transforming terms."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass IR_a_b_2(Scene):\n\n    def construct(self):\n        formula = Tex('a', '^{2}', '-', 'b', '^{2}', '=', '(', 'a', '-', 'b', ')', '(', 'a', '+', 'b', ')')\n        formula.scale(2)\n        self.play(Write(formula[0:6]))\n        formula[7].set_color(RED)\n        formula[9].set_color(BLUE)\n        formula[14].set_color(RED)\n        formula[12].set_color(BLUE)\n        self.wait()\n        self.play(ReplacementTransform(formula[0].copy(), formula[7]), ReplacementTransform(formula[0].copy(), formula[12]), Write(formula[6]), Write(formula[11]), Write(formula[10]), Write(formula[15]), run_time=1.5)\n        self.wait(0.5)\n        self.play(Write(formula[8]), Write(formula[13]), ReplacementTransform(formula[3].copy(), formula[9]), ReplacementTransform(formula[3].copy(), formula[14]), run_time=1.5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a linear equation, color-code its terms, and sequentially highlight the coefficients 'a' and 'b' with explanatory text."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass TextColor(Scene):\n\n    def construct(self):\n        text = Tex('f(x)', '=', 'a', 'x', '+', 'b')\n        text[0].set_color(WHITE)\n        text[1].set_color(WHITE)\n        text[2].set_color(BLUE)\n        text[3].set_color(WHITE)\n        text[4].set_color('#FFFFFF')\n        text[5].set_color(RED)\n        frameBoxa = SurroundingRectangle(text[2], buff=0.8 * SMALL_BUFF)\n        frameBoxa.set_stroke(BLUE, 3)\n        boxtextea = Tex('{\\\\normalsize On fait varier a}')\n        boxtextea.set_color(BLUE, 3)\n        boxtextea.next_to(text[2].get_center(), UP, buff=0.7)\n        frameBoxb = SurroundingRectangle(text[5], buff=0.8 * SMALL_BUFF)\n        frameBoxb.set_stroke(RED)\n        boxtexteb = Tex('{\\\\normalsize et b}')\n        boxtexteb.set_color(RED)\n        boxtexteb.next_to(text[5].get_center(), UP, buff=0.7)\n        self.play(Write(text))\n        self.wait(0.1)\n        self.play(ShowCreation(frameBoxa))\n        self.play(Write(boxtextea))\n        self.wait(0.4)\n        self.remove(frameBoxa)\n        self.wait(0.1)\n        self.remove(boxtextea)\n        self.play(ShowCreation(frameBoxb))\n        self.play(Write(boxtexteb))\n        self.wait(0.4)\n        self.remove(frameBoxb)\n        self.wait(0.1)\n        self.remove(boxtexteb)\n        self.wait(0.5)"}]}
{"messages": [{"role": "user", "content": "Arrange three pieces of text horizontally with equal spacing and center the arrangement."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass Aligner_text(Scene):\n\n    def construct(self):\n        text1 = Tex('text1').shift(2 * UL)\n        text2 = Tex('text2')\n        text3 = Tex('text3').shift(2 * DR)\n        group = VGroup(text1, text2, text3).scale(1.1)\n        self.add(group)\n        self.play(group.animate.arrange(RIGHT, 0.25, center=False))"}]}
{"messages": [{"role": "user", "content": "Create a horizontal line with a rainbow gradient."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass LigneGradient(Scene):\n\n    def construct(self):\n        line_gradient = Line(LEFT * 4, RIGHT * 4)\n        line_gradient.set_color(color=[PURPLE, BLUE, YELLOW, GREEN, RED])\n        self.add(line_gradient)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Warp a square using the complex exponential function."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass WarpSquare(Scene):\n\n    def construct(self):\n        square = Square()\n        self.add(square)\n        self.play(ApplyPointwiseFunction(lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a red sphere moving upwards and then scaling down."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass movecircle(Scene):\n\n    def construct(self):\n        sphere = Sphere().set_color(RED)\n        self.add(sphere)\n        self.play(ApplyMethod(sphere.shift, UP), run_time=2)\n        self.play(ApplyMethod(sphere.scale, 0.4), run_time=2)\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Show a sequence of 3D surfaces transforming into each other, starting with a sphere and ending with a cylinder, then fade out the cylinder."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass SurfacesAnimation(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes()\n        cylinder = ParametricSurface(lambda u, v: np.array([np.cos(TAU * v), np.sin(TAU * v), 2 * (1 - u)]), resolution=(6, 32)).fade(0.5)\n        paraboloid = ParametricSurface(lambda u, v: np.array([np.cos(v) * u, np.sin(v) * u, u ** 2]), v_max=TAU, checkerboard_colors=[PURPLE_D, PURPLE_E], resolution=(10, 32)).scale(2)\n        para_hyp = ParametricSurface(lambda u, v: np.array([u, v, u ** 2 - v ** 2]), v_min=-2, v_max=2, u_min=-2, u_max=2, checkerboard_colors=[BLUE_D, BLUE_E], resolution=(15, 32)).scale(1)\n        cone = ParametricSurface(lambda u, v: np.array([u * np.cos(v), u * np.sin(v), u]), v_min=0, v_max=TAU, u_min=-2, u_max=2, checkerboard_colors=[GREEN_D, GREEN_E], resolution=(15, 32)).scale(1)\n        hip_one_side = ParametricSurface(lambda u, v: np.array([np.cosh(u) * np.cos(v), np.cosh(u) * np.sin(v), np.sinh(u)]), v_min=0, v_max=TAU, u_min=-2, u_max=2, checkerboard_colors=[YELLOW_D, YELLOW_E], resolution=(15, 32))\n        ellipsoid = ParametricSurface(lambda u, v: np.array([1 * np.cos(u) * np.cos(v), 2 * np.cos(u) * np.sin(v), 0.5 * np.sin(u)]), v_min=0, v_max=TAU, u_min=-PI / 2, u_max=PI / 2, checkerboard_colors=[TEAL_D, TEAL_E], resolution=(15, 32)).scale(2)\n        sphere = ParametricSurface(lambda u, v: np.array([1.5 * np.cos(u) * np.cos(v), 1.5 * np.cos(u) * np.sin(v), 1.5 * np.sin(u)]), v_min=0, v_max=TAU, u_min=-PI / 2, u_max=PI / 2, checkerboard_colors=[RED_D, RED_E], resolution=(15, 32)).scale(2)\n        self.set_camera_orientation(phi=75 * DEGREES)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.add(axes)\n        self.play(Write(sphere))\n        self.wait()\n        self.play(ReplacementTransform(sphere, ellipsoid))\n        self.wait()\n        self.play(ReplacementTransform(ellipsoid, cone))\n        self.wait()\n        self.play(ReplacementTransform(cone, hip_one_side))\n        self.wait()\n        self.play(ReplacementTransform(hip_one_side, para_hyp))\n        self.wait()\n        self.play(ReplacementTransform(para_hyp, paraboloid))\n        self.wait()\n        self.play(ReplacementTransform(paraboloid, cylinder))\n        self.wait()\n        self.play(FadeOut(cylinder))"}]}
{"messages": [{"role": "user", "content": "Animate two stick figures, one waving and saying \"Salut!\" and the other waving and saying \"Hey!\", then returning to their original poses."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass SVGStickMan(GraphScene, MovingCameraScene):\n\n    def construct(self):\n        start_man = SVGMobject('/Users/antoninlefevre/Downloads/ManimCE/SVG_files/stick_man_plain.svg').set_color(WHITE)\n        start_man_2 = SVGMobject('/Users/antoninlefevre/Downloads/ManimCE/SVG_files/stick_man_plain.svg').set_color(WHITE)\n        wave_man = SVGMobject('/Users/antoninlefevre/Downloads/ManimCE/SVG_files/stick_man_wave.svg').set_color(WHITE)\n        wave_man_2 = SVGMobject('/Users/antoninlefevre/Downloads/ManimCE/SVG_files/stick_man_wave.svg').set_color(WHITE)\n        base = SVGMobject('/Users/antoninlefevre/Downloads/ManimCE/SVG_files/stick_man_plain.svg').set_color(WHITE)\n        self.camera.frame.save_state()\n        self.add(start_man.move_to(2 * LEFT))\n        self.add(start_man_2.move_to(2 * RIGHT))\n        self.play(self.camera.frame.animate.move_to(start_man.get_top()).scale(0.4))\n        self.wait(0.5)\n        salut = Tex('Salut !').set_color(YELLOW).next_to(start_man, UP + LEFT, buff=0.5)\n        self.play(Transform(start_man, wave_man.move_to(2 * LEFT)), FadeIn(salut))\n        self.wait()\n        self.play(self.camera.frame.animate.move_to(start_man_2.get_top()))\n        self.wait(0.5)\n        salut_2 = Tex('Hey !').set_color(YELLOW).next_to(start_man_2, UP + RIGHT, buff=0.5)\n        self.play(Transform(start_man_2, wave_man_2.move_to(2 * RIGHT)), FadeIn(salut_2))\n        self.play(FadeOut(salut), FadeOut(salut_2), run_time=0.01)\n        self.play(Transform(start_man, base.move_to(2 * LEFT)), Transform(start_man_2, base.copy().move_to(2 * RIGHT)))\n        self.play(Restore(self.camera.frame))"}]}
{"messages": [{"role": "user", "content": "Animate a neuron SVG, zoom into a specific part of it, and then zoom back out to reveal the full neuron."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\nfrom scipy import signal\nimport scipy.stats\nimport scipy\n\nclass ZoomOnNeuron(ZoomedScene, MovingCameraScene):\n\n    def __init__(self, **kwargs):\n        ZoomedScene.__init__(self, zoom_factor=0.4, zoomed_display_height=3, zoomed_display_width=4, image_frame_stroke_width=15, zoomed_camera_config={'default_frame_stroke_width': 2}, **kwargs)\n\n    def construct(self):\n        neurone_1 = SVGMobject('/Users/antoninlefevre/Downloads/ManimCE/SVG_files/neuron_video.svg').set_color(WHITE).scale(3).rotate(PI / 2)\n        self.play(Write(neurone_1))\n        zoomed_camera = self.zoomed_camera\n        zoomed_display = self.zoomed_display\n        frame = zoomed_camera.frame\n        zoomed_display_frame = zoomed_display.display_frame\n        frame.move_to(neurone_1[0].get_left())\n        frame.set_color(PURPLE)\n        zd_rect = BackgroundRectangle(zoomed_display.move_to(neurone_1[0].get_left() + DOWN), fill_opacity=0, buff=MED_SMALL_BUFF)\n        self.add_foreground_mobject(zd_rect)\n        unfold_camera = UpdateFromFunc(zd_rect, lambda rect: rect.replace(zoomed_display))\n        self.play(ShowCreation(frame), direction=DOWN)\n        self.activate_zooming()\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera)\n        self.wait(2)\n        self.play(self.get_zoomed_display_pop_out_animation(), unfold_camera, rate_func=lambda t: smooth(1 - t))\n        self.play(Uncreate(zoomed_display_frame), FadeOut(frame))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show two circles expanding from opposite sides and trace their intersection points."}, {"role": "assistant", "content": "from manim import *\n\nclass TwoCircleImpingement(Scene):\n\n    def construct(self):\n        time_tracker = ValueTracker(0)\n        circ_1_x, circ_1_y, circ_1_z = (-1.5, 0, 0)\n        circ_1_start_radius = 1.5\n        circ_1_growth_rate = 0.5\n        circ_1_radius_tracker = ValueTracker(circ_1_start_radius).add_updater(lambda tracker: tracker.set_value(circ_1_start_radius + circ_1_growth_rate * time_tracker.get_value()))\n        circ_1 = always_redraw(lambda: Circle(radius=circ_1_radius_tracker.get_value(), arc_center=np.array([circ_1_x, circ_1_y, circ_1_z])))\n        circ_2_x, circ_2_y, circ_2_z = (1.5, 0, 0)\n        circ_2_start_radius = 1.5\n        circ_2_growth_rate = 1\n        circ_2_radius_tracker = ValueTracker(circ_2_start_radius).add_updater(lambda tracker: tracker.set_value(circ_2_start_radius + circ_2_growth_rate * time_tracker.get_value()))\n        circ_2 = always_redraw(lambda: Circle(radius=circ_2_radius_tracker.get_value(), arc_center=np.array([circ_2_x, circ_2_y, circ_2_z])))\n        self.add(circ_1_radius_tracker, circ_2_radius_tracker, circ_1, circ_2)\n        self.wait()\n        distance_between_circles = np.sqrt((circ_2_x - circ_1_x) ** 2 + (circ_2_y - circ_1_y) ** 2)\n        intersec_points = always_redraw(lambda: get_circ_intersec(circ_1_x, circ_1_y, circ_2_x, circ_2_y, circ_1_radius_tracker.get_value(), circ_2_radius_tracker.get_value()))\n        intersec_point_1_path = TracedPath(intersec_points.submobjects[0].get_center, stroke_color=YELLOW, stroke_width=4)\n        intersec_point_2_path = TracedPath(intersec_points.submobjects[1].get_center, stroke_color=YELLOW, stroke_width=4)\n        self.add(intersec_points, intersec_point_1_path, intersec_point_2_path)\n        self.play(time_tracker.animate(run_time=2, rate_func=linear).set_value(2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a title slide with university logos, names, affiliations, and page numbers, animating the title's color."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass IntroSlide(Scene):\n\n    def construct(self):\n        title = Text('Deriving the JMAK Equation Using\\nthe Time Cone Method', font_size=50)\n        title.shift(UP * 1.2)\n        logo = ImageMobject('./figure/umich_mse_logo.png')\n        logo.scale(1.2)\n        logo.align_to(title, LEFT).shift(DOWN * 2)\n        name = Text('Peiwen Ren', font_size=40, slant=ITALIC)\n        affiliation = Text('Visiting Student\\nWenhao Sun Research Group\\nUniversity of Michigan\\nMaterials Science and Engineering', font_size=30)\n        name.next_to(logo, RIGHT).align_to(logo, UP)\n        affiliation.next_to(name, DOWN).align_to(name, LEFT)\n        page_1 = Tex('1', font_size=40)\n        page_1.to_edge(DR)\n        self.add(title, logo, name, affiliation, page_1)\n        self.wait(1)\n        self.play(FadeOut(logo), FadeOut(name), FadeOut(affiliation), title.animate.shift(DOWN * 1.2), run_time=1)\n        self.wait(1)\n        self.play(title.animate.set_color_by_t2c(t2c={'[8:23]': BLUE, '[28:-1]': RED}), run_time=1)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display five tiny circles that grow and shrink, then move upwards and leftwards, accompanied by a graph of a physical equation with its associated labels and formulas."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass PhysicalPic(Scene):\n\n    def construct(self):\n        rectangle = ScreenRectangle()\n        rectangle_mask = ScreenRectangle(stroke_width=200, stroke_color=BLACK, height=6, aspect_ratio=4 * 20.5 / 9 / 6)\n        circles = [Circle(color=YELLOW, fill_color=YELLOW, fill_opacity=1, radius=1e-06, arc_center=shift_vec) for shift_vec in [UR + 0.5 * RIGHT, 2 * UL, -0.5 * LEFT, DR + RIGHT, DL + LEFT]]\n        phase_fraction_axes = Axes(x_range=[0, 1000, 100], y_range=[0, 1.2, 0.2], x_length=7, y_length=3, y_axis_config={'numbers_to_include': np.arange(0, 1 + 0.2, 0.2)})\n        phase_fraction_axes.to_edge(DOWN, buff=0.01)\n        phase_fraction_x_label = phase_fraction_axes.get_x_axis_label(Tex('$t$'))\n        phase_fraction_y_label = phase_fraction_axes.get_y_axis_label(Tex('$f_{\\\\text{transformed}}$').scale(0.7).rotate(PI / 2), edge=LEFT, direction=LEFT, buff=0.4)\n        fraction_curve = phase_fraction_axes.plot(lambda t: 1 - np.exp(-np.pi / 3 * 0.012 * 0.001 ** 3 * t ** 4), color=YELLOW)\n        jmak_formula_1 = Tex('$f_{\\\\text{transformed}}$', color=YELLOW)\n        jmak_formula_2 = Tex('$=1-e^{-\\\\frac{\\\\pi}{3}J\\\\dot{R}^3t^4}$', color=YELLOW)\n        jmak_formula_1.shift(4.5 * RIGHT + UP)\n        jmak_formula_2.align_to(jmak_formula_1, LEFT).next_to(jmak_formula_1, DOWN)\n        jmak_formula = VGroup(jmak_formula_1, jmak_formula_2)\n        jmak_label = Tex('JMAK Equation').next_to(jmak_formula, UP)\n        nucleation_rate = Tex('$J:\\\\,$', 'nucleation rate', font_size=40).next_to(jmak_formula, DOWN, buff=LARGE_BUFF)\n        growth_rate = Tex('$\\\\dot{R}:\\\\,$', 'growth rate', font_size=40).next_to(nucleation_rate, DOWN).align_to(nucleation_rate, LEFT)\n        self.add(*circles)\n        self.add_foreground_mobjects(rectangle, rectangle_mask)\n        self.play(LaggedStart(*[circle.animate(rate_func=linear, run_time=5).scale(3000000.0) for circle in circles], lag_ratio=0.1))\n        self.wait()\n        self.play(LaggedStart(*[circle.animate(rate_func=linear, run_time=1).scale(1 / 3000000.0) for circle in circles[::-1]], lag_ratio=0.1))\n        self.wait()\n        self.play(*[obj.animate.shift(2 * UP) for obj in [*circles, rectangle, rectangle_mask]])\n        self.wait()\n        self.add_foreground_mobjects(phase_fraction_axes, phase_fraction_x_label, phase_fraction_y_label)\n        self.play(Create(phase_fraction_axes), Write(phase_fraction_x_label), Write(phase_fraction_y_label), run_time=2)\n        self.wait()\n        self.add_foreground_mobjects(fraction_curve)\n        self.play(LaggedStart(*[circle.animate(rate_func=linear, run_time=5).scale(2600000.0) for circle in circles], lag_ratio=0.1), Create(fraction_curve, rate_func=linear, run_time=6))\n        self.wait()\n        self.play(*[obj.animate.shift(2 * LEFT) for obj in self.mobjects])\n        self.wait()\n        self.add_foreground_mobjects(jmak_label)\n        self.play(Write(jmak_label))\n        self.wait()\n        self.add_foreground_mobjects(jmak_formula_1, jmak_formula_2)\n        self.play(LaggedStart(Write(jmak_formula_1), Write(jmak_formula_2), lag_ratio=1))\n        self.wait()\n        self.add_foreground_mobjects(nucleation_rate, growth_rate)\n        self.play(LaggedStart(Write(nucleation_rate), Write(growth_rate), lag_ratio=1.1))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present a presentation on the motivation for the Time Cone Method, showing transformations between \"what to make\" and \"how to make them\", followed by a Time-Temperature-Transformation diagram and a phase fraction graph, with arrows illustrating the concepts."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass Motivation(Scene):\n\n    def construct(self):\n        slide_title = Tex('Motivation', font_size=40)\n        slide_title.to_corner(UL)\n        page_2 = Tex('$2$', font_size=40)\n        page_2.to_edge(DR)\n        self.add(slide_title, page_2)\n        self.wait()\n        problem_statement_1 = Tex('What', ' to ', 'make', '?')\n        problem_statement_2 = Tex('How', ' to ', 'make', ' them', '?')\n        problem_statement_2.align_to(problem_statement_1, LEFT)\n        problem_statement_2.shift(problem_statement_1[1].get_center() - problem_statement_2[1].get_center())\n        self.play(Write(problem_statement_1))\n        self.wait()\n        self.play(TransformMatchingTex(problem_statement_1, problem_statement_2, transform_mismatches=True))\n        self.wait()\n        self.play(FadeOut(problem_statement_2))\n        self.wait()\n        motivation_statement = Tex('In predictive synthesis, we want to know what is\\\\\\\\the ', 'optimal thermal processing pathway\\\\\\\\', 'to transition from', ' a precursor phase ', 'to ', 'a target phase', '?', font_size=45)\n        motivation_statement.set_color_by_tex_to_color_map({'optimal thermal processing pathway': YELLOW, 'a precursor phase': PURPLE_C, 'a target phase': ORANGE})\n        motivation_statement.shift(UP * 2)\n        precursor_phase_a = Tex('A', font_size=45, color=PURPLE_C)\n        precursor_phase_a.shift(3.2 * RIGHT + 2.2 * DOWN)\n        target_phase_b = Tex('B', font_size=45, color=ORANGE)\n        target_phase_b.shift(5 * RIGHT + 2.2 * DOWN)\n        self.play(Write(motivation_statement), run_time=3)\n        self.wait()\n        ttt_diagram = ImageMobject('./figure/ttt_diagram.png')\n        ttt_diagram.scale(1.2)\n        ttt_diagram.to_edge(RIGHT, buff=0.6).shift(DOWN * 1.7)\n        ttt_diagram_label = Tex('Time-Temperature-Transformation Diagram', font_size=25)\n        ttt_diagram_label.next_to(ttt_diagram, UP)\n        ttt_diagram_line_2 = Line(LEFT * 1.5, RIGHT * 1.5).set_color(RED).move_to(ttt_diagram.get_center()).shift(UP * 0.09 + RIGHT * 0.05)\n        ttt_diagram_line_1 = Line(start=ttt_diagram.get_corner(UL) + 0.62 * DR, end=ttt_diagram_line_2.get_left()).set_color(RED)\n        phase_fraction = ImageMobject('./figure/phase_fraction.png')\n        phase_fraction.scale(1.2)\n        phase_fraction.shift(DOWN * 1.7).next_to(ttt_diagram, LEFT, buff=0.8)\n        phase_fraction_label = Tex('(Volume) Phase Fraction Transformed', font_size=30)\n        phase_fraction_label.next_to(phase_fraction, UP).shift(LEFT * 0.7)\n        question_mark = Tex('$?$', font_size=50)\n        question_mark.shift(DOWN * 1.7).next_to(phase_fraction, LEFT, buff=2)\n        arrow_1 = Arrow(start=ttt_diagram.get_left(), end=phase_fraction.get_right())\n        arrow_1.move_to((ttt_diagram.get_left() + phase_fraction.get_right()) / 2)\n        arrow_2 = arrow_1.copy()\n        arrow_2.move_to((phase_fraction.get_left() + question_mark.get_right()) / 2 + (phase_fraction.get_left() - question_mark.get_right()) / 4)\n        time_cone_method_label = Tex('Time Cone Method', font_size=30, color=BLUE)\n        time_cone_method_label.move_to(question_mark.get_center())\n        self.play(FadeIn(ttt_diagram), Write(ttt_diagram_label))\n        self.wait()\n        self.play(Transform(motivation_statement[3].copy(), precursor_phase_a), Transform(motivation_statement[5].copy(), target_phase_b))\n        self.wait()\n        self.play(Create(ttt_diagram_line_1))\n        self.play(Create(ttt_diagram_line_2))\n        self.wait()\n        self.play(Create(arrow_1))\n        self.play(FadeIn(phase_fraction), Write(phase_fraction_label))\n        self.wait()\n        self.play(Create(arrow_2))\n        self.play(Write(question_mark))\n        self.wait()\n        self.play(ReplacementTransform(question_mark, time_cone_method_label))\n        self.wait()\n        self.play(arrow_2.animate.rotate(PI))\n        self.play(arrow_1.animate.rotate(PI))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present images of John Cahn and his time cone paper, then animate a 1D growth cone spreading on a 3D axes setup, culminating in a 2D representation of the cone using circles and a cone object."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass TimeCone1D2D(ThreeDScene):\n\n    def construct(self):\n        slide_title = Tex('What is a time cone?', font_size=40)\n        slide_title.to_corner(UL)\n        page_3 = Tex('$3$', font_size=40)\n        page_3.to_edge(DR)\n        self.add_fixed_in_frame_mobjects(slide_title, page_3)\n        self.wait()\n        john_cahn_image = ImageMobject('./figure/john_cahn_image.jpg')\n        john_cahn_image.scale(1.5)\n        john_cahn_image.to_edge(LEFT, buff=3 * DEFAULT_MOBJECT_TO_EDGE_BUFFER)\n        john_cahn_image_caption = Tex('John W. Cahn\\\\\\\\(1928-2016)')\n        john_cahn_image_caption.next_to(john_cahn_image, DOWN)\n        time_cone_paper = ImageMobject('./figure/time_cone_paper.png')\n        time_cone_paper.scale(0.6)\n        time_cone_paper.to_edge(RIGHT, buff=2 * DEFAULT_MOBJECT_TO_EDGE_BUFFER)\n        self.play(FadeIn(john_cahn_image))\n        self.play(Write(john_cahn_image_caption))\n        self.wait()\n        self.play(FadeIn(time_cone_paper))\n        self.wait()\n        self.play(FadeOut(john_cahn_image, john_cahn_image_caption, time_cone_paper))\n        self.wait()\n        axes = ThreeDAxes(x_range=[-7, 7], y_range=[-7, 7], z_range=[-7, 7], x_length=7, y_length=7, z_length=7)\n        axes_scale_factor = 1.7\n        axes.scale(axes_scale_factor)\n        axes.shift(2 * DOWN + 2 * LEFT)\n        x_label = axes.get_x_axis_label(Tex('$x$'))\n        x_label.add_updater(lambda x: x.move_to(axes.get_x_axis_label(Tex('$x$')).get_center()))\n        y_label = axes.get_y_axis_label(Tex('$t$'))\n        y_label.add_updater(lambda x: x.move_to(axes.get_y_axis_label(Tex('$t$')).get_center()))\n        line = Line(start=axes.c2p(3 - np.interp(5, [0, 5], [0, 1]), 2, 0), end=axes.c2p(3 + np.interp(5, [0, 5], [0, 1]), 2, 0))\n        dot = Dot(radius=line.stroke_width / DOT_TO_LINE)\n        dot.move_to(line.get_center())\n        growth_cone_graph_left = axes.plot(lambda x: -5 * (x - 3), x_range=[2, 3])\n        growth_cone_graph_right = axes.plot(lambda x: 5 * (x - 3), x_range=[3, 4])\n        growth_cones_1d = VGroup(growth_cone_graph_left, growth_cone_graph_right)\n        line_1 = Line(start=axes.c2p(3 - np.interp(1, [0, 5], [0, 1]), 1, 0), end=axes.c2p(3 + np.interp(1, [0, 5], [0, 1]), 1, 0))\n        line_2 = Line(start=axes.c2p(3 - np.interp(2, [0, 5], [0, 1]), 2, 0), end=axes.c2p(3 + np.interp(2, [0, 5], [0, 1]), 2, 0))\n        line_3 = Line(start=axes.c2p(3 - np.interp(3, [0, 5], [0, 1]), 3, 0), end=axes.c2p(3 + np.interp(3, [0, 5], [0, 1]), 3, 0))\n        line_4 = Line(start=axes.c2p(3 - np.interp(4, [0, 5], [0, 1]), 4, 0), end=axes.c2p(3 + np.interp(4, [0, 5], [0, 1]), 4, 0))\n        line_5 = Line(start=axes.c2p(3 - np.interp(5, [0, 5], [0, 1]), 5, 0), end=axes.c2p(3 + np.interp(5, [0, 5], [0, 1]), 5, 0))\n        lines_lst = [line_5, line_4, line_3, line_2, line_1]\n        twod_group = VGroup(axes.get_x_axis(), axes.get_y_axis(), growth_cones_1d)\n        self.play(FadeIn(dot))\n        self.play(GrowFromCenter(line), rate_func=linear)\n        self.remove(dot)\n        self.wait()\n        self.play(line.animate.move_to(line_5.get_center()), run_time=2)\n        self.play(Create(axes.get_x_axis()))\n        self.play(Write(x_label))\n        self.play(Create(axes.get_y_axis()))\n        self.play(Write(y_label))\n        self.wait()\n        self.play(LaggedStart(*[FadeIn(ind_line) for ind_line in lines_lst], lag_ratio=0.5))\n        self.remove(line)\n        self.play(Create(growth_cones_1d))\n        self.wait()\n        self.play(LaggedStart(*[FadeOut(ind_line) for ind_line in lines_lst]))\n        self.wait()\n        self.play(twod_group.animate.shift(2 * UP + 2 * RIGHT))\n        self.play(twod_group.animate.scale(1 / axes_scale_factor))\n        self.add(axes.get_z_axis().shift(2 * UP + 2 * RIGHT).scale(1 / axes_scale_factor), axes.get_z_axis_label(Tex('$y$')))\n        self.wait()\n        self.move_camera(phi=60 * DEGREES, theta=-45 * DEGREES)\n        self.wait()\n        circle_1 = Circle(radius=1 / 10)\n        circle_2 = Circle(radius=2 / 10)\n        circle_3 = Circle(radius=3 / 10)\n        circle_4 = Circle(radius=4 / 10)\n        circle_5 = Circle(radius=5 / 10)\n        circle_lst = [circle_1, circle_2, circle_3, circle_4, circle_5]\n        circle_lst = [circle.shift(axes.c2p(3, num + 1, 0)).rotate(PI / 2, axis=X_AXIS) for num, circle in enumerate(circle_lst)]\n        cone = Cone(base_radius=1 / 2, height=5 / 2, direction=-Y_AXIS)\n        cone.shift(axes.c2p(3, 0, 0))\n        self.play(LaggedStart(*[GrowFromCenter(circle) for circle in circle_lst], lag_ratio=0.5))\n        self.play(Uncreate(growth_cones_1d))\n        self.play(Create(cone), run_time=2)\n        self.play(LaggedStart(*[FadeOut(circle) for circle in circle_lst]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of a time cone by displaying an axes, a point of interest, a single growth cone that moves and fades, followed by multiple growth cones that are highlighted and form a nucleation region, and finally animate a growth cone moving along a path derived from the nucleation region."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass TimeConeIntuition(Scene):\n\n    def construct(self):\n        slide_title = Tex('How do we use the time cone?', font_size=40)\n        slide_title.to_corner(UL).shift(UP * 0.3)\n        page_4 = Tex('$4$', font_size=40)\n        page_4.to_edge(DR)\n        self.add(slide_title, page_4)\n        self.wait()\n        axes = Axes(x_range=[0, 7], y_range=[0, 7], x_length=8, y_length=6)\n        x_label = axes.get_x_axis_label(Tex('$x$'))\n        y_label = axes.get_y_axis_label(Tex('$t$'))\n        growth_cone, growth_cone_shade = create_single_growth_cone_with_shade(axes, 3.5, 0, 1.5, 6)\n        point_of_interest = Dot()\n        point_of_interest_x, point_of_interest_y = (3.5, 3.5)\n        point_of_interest.move_to(axes.c2p(point_of_interest_x, point_of_interest_y))\n        point_of_interest_label = Tex('$(x, t)$')\n        point_of_interest_label.next_to(point_of_interest, RIGHT)\n        self.play(Create(axes))\n        self.play(Write(x_label), Write(y_label))\n        self.wait()\n        self.play(FadeIn(point_of_interest))\n        self.play(Write(point_of_interest_label))\n        self.wait()\n        self.play(Unwrite(point_of_interest_label))\n        self.wait()\n        self.play(Create(growth_cone))\n        self.wait()\n        self.play(FadeIn(growth_cone_shade))\n        self.wait()\n        self.play(growth_cone.animate.shift(LEFT * 1.5))\n        self.wait()\n        self.play(growth_cone.animate.shift(RIGHT * 3))\n        self.wait()\n        self.play(growth_cone.animate.shift(LEFT * 0.5))\n        self.wait()\n        self.play(growth_cone.animate.shift(LEFT * 0.5))\n        self.wait()\n        self.play(FadeOut(growth_cone), FadeOut(growth_cone_shade))\n        self.wait()\n        growth_cone_lst = VGroup()\n        growth_cone_tip_y = 0\n        growth_cone_base_radius = 1.5\n        growth_cone_height = 6\n        for x_tip in np.arange(0, 7.5, 0.5):\n            ind_growth_cone, ind_growth_cone_shade = create_single_growth_cone_with_shade(axes, x_tip, growth_cone_tip_y, growth_cone_base_radius, growth_cone_height, shade_opacity=0.2)\n            growth_cone_lst.add(VGroup(ind_growth_cone, ind_growth_cone_shade))\n        self.play(LaggedStart(*[FadeIn(growth_cone) for growth_cone in growth_cone_lst], lag_ratio=0.5))\n        self.wait()\n        self.play(*[growth_cone_lst[_][0].animate.set_color(YELLOW) for _ in [6, 7, 8]], *[growth_cone_lst[_][1].animate.set_fill(YELLOW, opacity=0.2) for _ in [6, 7, 8]])\n        self.wait()\n        nucleation_region_top = point_of_interest.get_center()\n        nucleation_region_left = axes.c2p(point_of_interest_x - point_of_interest_y / (growth_cone_height / growth_cone_base_radius), 0)\n        nucleation_region_right = axes.c2p(point_of_interest_x + point_of_interest_y / (growth_cone_height / growth_cone_base_radius), 0)\n        nucleation_region_line_1 = DashedLine(start=nucleation_region_top, end=nucleation_region_left)\n        nucleation_region_line_2 = DashedLine(start=nucleation_region_left, end=nucleation_region_right)\n        nucleation_region_line_3 = DashedLine(start=nucleation_region_right, end=nucleation_region_top)\n        nucleation_region = VGroup(nucleation_region_line_1, nucleation_region_line_2, nucleation_region_line_3)\n        nucleation_region.set_stroke(color=BLUE)\n        self.play(Create(nucleation_region))\n        self.wait()\n        self.play(FadeOut(growth_cone_lst))\n        self.wait()\n        path_correction_vector = growth_cone.get_center() - growth_cone.get_bottom()\n        growth_cone.move_to(nucleation_region_left + path_correction_vector)\n        path = VMobject()\n        path_points = create_triangle_path_points(nucleation_region_top, nucleation_region_left, nucleation_region_right, num_segments=6)\n        path.set_points_as_corners([point + path_correction_vector for point in path_points])\n        self.play(FadeIn(growth_cone), FadeIn(growth_cone_shade))\n        self.wait()\n        self.play(MoveAlongPath(growth_cone, path, rate_func=linear), run_time=10)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the causality of a point on a graph using a time cone and illustrate the conditions for transformation."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass TimeConeIntuitionEmphasis(Scene):\n\n    def construct(self):\n        slide_title = Tex('How do we use the time cone?', font_size=40)\n        slide_title.to_corner(UL).shift(UP * 0.3)\n        page_4 = Tex('$4$', font_size=40)\n        page_4.to_edge(DR)\n        self.add(slide_title, page_4)\n        axes = Axes(x_range=[0, 7], y_range=[0, 7], x_length=8, y_length=6)\n        x_label = axes.get_x_axis_label(Tex('$x$'))\n        y_label = axes.get_y_axis_label(Tex('$t$'))\n        growth_cone_base_radius = 1.5\n        growth_cone_height = 6\n        point_of_interest = Dot()\n        point_of_interest_x, point_of_interest_y = (3.5, 3.5)\n        point_of_interest.move_to(axes.c2p(point_of_interest_x, point_of_interest_y))\n        self.add(axes, x_label, y_label, point_of_interest)\n        nucleation_region_top = point_of_interest.get_center()\n        nucleation_region_left = axes.c2p(point_of_interest_x - point_of_interest_y / (growth_cone_height / growth_cone_base_radius), 0)\n        nucleation_region_right = axes.c2p(point_of_interest_x + point_of_interest_y / (growth_cone_height / growth_cone_base_radius), 0)\n        nucleation_region_line_1 = DashedLine(start=nucleation_region_top, end=nucleation_region_left)\n        nucleation_region_line_2 = DashedLine(start=nucleation_region_left, end=nucleation_region_right)\n        nucleation_region_line_3 = DashedLine(start=nucleation_region_right, end=nucleation_region_top)\n        nucleation_region = VGroup(nucleation_region_line_1, nucleation_region_line_2, nucleation_region_line_3)\n        nucleation_region.set_stroke(color=BLUE)\n        growth_cone, growth_cone_shade = create_single_growth_cone_with_shade(axes, 3.5, 0, 1.5, 6)\n        path_correction_vector = growth_cone.get_center() - growth_cone.get_bottom()\n        growth_cone.move_to(nucleation_region_right + path_correction_vector)\n        self.add(nucleation_region, growth_cone, growth_cone_shade)\n        self.wait()\n        self.play(growth_cone.animate.move_to(nucleation_region_top + path_correction_vector))\n        self.wait()\n        nucleation_region_bottom_middle = (nucleation_region_left + nucleation_region_right) / 2\n        as_nucleation_origin = DashedLine(start=nucleation_region_top, end=nucleation_region_bottom_middle)\n        self.play(Create(as_nucleation_origin))\n        self.wait()\n        self.play(growth_cone.animate.move_to(nucleation_region_bottom_middle + path_correction_vector))\n        self.wait()\n        self.play(growth_cone.animate.move_to(nucleation_region_left + path_correction_vector))\n        self.wait()\n        self.play(growth_cone.animate.move_to((nucleation_region_bottom_middle + nucleation_region_left) / 2 + path_correction_vector))\n        self.wait()\n        takeaway_message_1 = Tex('&\\\\text{For this point to be ', 'transformed}', ',\\\\\\\\', '&\\\\text{there should be', ' at least 1 }', '\\\\\\\\&\\\\text{nucleation event or time cone}\\\\\\\\', '&\\\\text{present in the blue triangle region.}', font_size=0.7 * DEFAULT_FONT_SIZE, tex_environment='align*')\n        takeaway_message_1.to_corner(UR, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER)\n        self.play(Write(takeaway_message_1))\n        self.wait()\n        takeaway_message_2 = Tex('&\\\\text{For this point to be ', 'un', 'transformed}', ',\\\\\\\\', '&\\\\text{there should be', ' no }', '\\\\\\\\&\\\\text{nucleation event or time cone}\\\\\\\\', '&\\\\text{present in the blue triangle region.}', font_size=0.7 * DEFAULT_FONT_SIZE, tex_environment='align*')\n        takeaway_message_2.to_corner(UR, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER)\n        self.play(TransformMatchingTex(takeaway_message_1, takeaway_message_2), FadeOut(growth_cone, growth_cone_shade))\n        self.wait()\n        self.play(Circumscribe(takeaway_message_2, time_width=2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Introduce a physics concept relating phase transformation to probability and then transition to a new slide explaining how to calculate probability from a time cone."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass ConnectTimeConeWithPhaseFraction(Scene):\n\n    def construct(self):\n        slide_title = Text(\"Let's connect time cone to phase fraction transformed\", font_size=30)\n        slide_title.to_edge(UL)\n        page_5 = Tex('$5$', font_size=40)\n        page_5.to_edge(DR)\n        statement_1 = Tex('$\\\\text{the phase fraction transformed}=1-\\\\text{the phase fraction untransformed}$', font_size=35)\n        statement_1.shift(UP * 2)\n        statement_2 = Tex('$\\\\text{the phase fraction untransformed}=P(\\\\text{no phase transformation has occurred})$', font_size=35)\n        statement_2.next_to(statement_1, DOWN, buff=0.5)\n        statement_3 = Tex('$\\\\text{the phase fraction transformed}=1-P(\\\\text{no phase transformation has occurred})$', font_size=35)\n        statement_4 = Tex('$P(\\\\text{no phase transformation has occurred})$', font_size=35)\n        statement_4.align_to(statement_3, RIGHT)\n        next_slide_title = Tex('$\\\\text{How to calculate } P(\\\\text{no phase transformation has occurred})\\\\text{ from time cone?}$', font_size=35)\n        next_slide_title.to_corner(UL)\n        self.add(slide_title, page_5)\n        self.wait()\n        self.play(Write(statement_1))\n        self.wait()\n        self.play(Write(statement_2), statement_1.animate.set_fill(color=WHITE, opacity=0.4))\n        self.wait()\n        self.play(Write(statement_3), statement_2.animate.set_fill(color=WHITE, opacity=0.4))\n        self.add(statement_4)\n        self.wait()\n        self.play(LaggedStart(FadeOut(slide_title, statement_1, statement_2, statement_3), statement_4.animate.move_to(ORIGIN).scale(1.2), lag_ratio=0.5), run_time=3)\n        self.wait()\n        page_6 = Tex('$6$', font_size=40)\n        page_6.to_edge(DR)\n        self.play(Transform(statement_4, next_slide_title), Transform(page_5, page_6))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a grid of random numbers, highlight those exceeding a threshold, and then represent the count of these numbers as dots that animate into a percentage and a horizontal line."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass ProbToPhaseFraction(ZoomedScene, SpaceScene):\n\n    def __init__(self):\n        ZoomedScene.__init__(self, zoomed_display_width=5, zoomed_display_height=5)\n\n    def construct(self):\n        sampling_box_axes = Axes(x_range=[0, 10], y_range=[0, 10], x_length=6, y_length=6, y_axis_config={'numbers_to_include': np.arange(0, 10 + 1, 1)}, tips=False)\n        grid_dimension_x = sampling_box_axes.x_range[1]\n        grid_dimension_y = sampling_box_axes.y_range[1]\n        bounding_box_left = Line(start=sampling_box_axes.c2p(0, grid_dimension_y), end=sampling_box_axes.c2p(0, 0))\n        bounding_box_bottom = Line(start=sampling_box_axes.c2p(0, 0), end=sampling_box_axes.c2p(grid_dimension_x, 0))\n        bounding_box_right = Line(start=sampling_box_axes.c2p(grid_dimension_x, 0), end=sampling_box_axes.c2p(grid_dimension_x, grid_dimension_y))\n        bounding_box = VGroup(bounding_box_left, bounding_box_bottom, bounding_box_right)\n        self.add(sampling_box_axes, bounding_box)\n        self.wait()\n        grid_lines_vertical = [Line(start=sampling_box_axes.c2p(_, 0), end=sampling_box_axes.c2p(_, 10), stroke_opacity=0.3) for _ in range(1, 10)]\n        grid_lines_horizontal = [Line(start=sampling_box_axes.c2p(0, _), end=sampling_box_axes.c2p(10, _), stroke_opacity=0.3) for _ in range(1, 11)]\n        self.play(LaggedStart(*[Create(grid_line) for grid_line in grid_lines_vertical], lag_ratio=0.2), run_time=1)\n        self.play(LaggedStart(*[Create(grid_line) for grid_line in grid_lines_horizontal], lag_ratio=0.2), run_time=1)\n        self.wait()\n        zoomed_camera = self.zoomed_camera\n        zoomed_display = self.zoomed_display\n        zoomed_camera_frame = zoomed_camera.frame\n        zoomed_display_frame = zoomed_display.display_frame\n        zoomed_camera_frame.set_color(YELLOW)\n        zoomed_display_frame.set_color(YELLOW)\n        zoomed_camera_frame.move_to(sampling_box_axes.c2p(4.5, 5.5))\n        self.play(Create(zoomed_camera_frame))\n        self.activate_zooming()\n        self.play(self.get_zoomed_display_pop_out_animation())\n        self.wait()\n        demo_dot = Dot(point=sampling_box_axes.c2p(4.5, 5.5), radius=(sampling_box_axes.c2p(0.5, 0) - sampling_box_axes.c2p(0, 0))[0])\n        self.play(FadeIn(demo_dot))\n        self.wait()\n        self.play(FadeOut(demo_dot))\n        self.wait()\n        self.play(self.get_zoomed_display_pop_out_animation(), rate_func=lambda t: smooth(1 - t))\n        self.wait()\n        self.play(FadeOut(zoomed_camera_frame, zoomed_display_frame))\n        self.remove(self.zoomed_camera.frame, self.zoomed_display.display_frame, self.zoomed_display)\n        self.zoom_activated = False\n        self.wait()\n        rng = np.random.default_rng(0)\n        random_num_grid = rng.uniform(size=(grid_dimension_x, grid_dimension_y))\n        prob_untransformed = 0.2\n        transformed_grid = random_num_grid >= prob_untransformed\n        random_num_grid_truncated = np.trunc(random_num_grid * 1000) / 1000\n        random_num_grid_visualized = [DecimalNumber(number=random_num_grid_truncated[row_index][col_index], font_size=0.4 * DEFAULT_FONT_SIZE, num_decimal_places=3).move_to(sampling_box_axes.c2p(row_index + 0.5, col_index + 0.5)) for row_index in range(grid_dimension_x) for col_index in range(grid_dimension_y)]\n        random_num_grid_visualized = VGroup(*random_num_grid_visualized)\n        random_num_grid_visualized.sort(lambda num: np.dot(num, UP + RIGHT))\n        transformed_dot_lst = [Dot(point=sampling_box_axes.c2p(row_index + 0.5, col_index + 0.5), radius=(sampling_box_axes.c2p(0.5, 0) - sampling_box_axes.c2p(0, 0))[0]) for row_index in range(grid_dimension_x) for col_index in range(grid_dimension_y) if transformed_grid[row_index][col_index]]\n        count_tracker = ValueTracker(0)\n        count_tracker_label = always_redraw(lambda: Integer(count_tracker.get_value()).next_to(bounding_box, RIGHT, buff=1))\n        num_of_dots = len(transformed_dot_lst)\n        count_perc_eqn = MathTex('\\\\frac{}{100}', '={num_dots}\\\\%'.format(num_dots=num_of_dots), arg_separator='')\n        count_perc_eqn.align_to(count_tracker_label, UL).shift(np.array([(count_tracker_label.get_top() - count_perc_eqn.submobjects[0].get_top())[0] * 0.7, 0, 0])).shift(np.array([0, (count_perc_eqn.submobjects[0].get_center() - count_tracker_label.get_center())[1] * 0.8, 0]))\n        self.play(Write(random_num_grid_visualized))\n        self.wait()\n        self.play(*[Indicate(random_num) for random_num in random_num_grid_visualized if random_num.get_value() >= prob_untransformed], run_time=2)\n        self.wait()\n        self.play(*[Indicate(random_num, color=RED) for random_num in random_num_grid_visualized if random_num.get_value() < prob_untransformed], run_time=2)\n        self.wait()\n        self.play(Unwrite(random_num_grid_visualized))\n        self.play(LaggedStart(*[FadeOut(grid_line) for grid_line in grid_lines_horizontal[::-1]], *[FadeOut(grid_line) for grid_line in grid_lines_vertical[::-1]], lag_ratio=0.2), run_time=1)\n        self.wait()\n        self.play(LaggedStart(*[FadeIn(dot) for dot in transformed_dot_lst], lag_ratio=0.01))\n        self.wait()\n        self.play(Write(count_tracker_label))\n        self.play(LaggedStart(*[ShowPassingFlash(Circle().surround(dot, buffer_factor=1.1).set_color(YELLOW), time_width=2) for dot in transformed_dot_lst], lag_ratio=0.05, run_time=4), count_tracker.animate(run_time=4, rate_func=linear).set_value(num_of_dots))\n        self.wait()\n        self.play(Write(count_perc_eqn))\n        self.wait()\n        transformed_fraction_fill_line = DashedLine(start=sampling_box_axes.c2p(0, 10 * (1 - prob_untransformed)), end=sampling_box_axes.c2p(grid_dimension_x, 10 * (1 - prob_untransformed)), stroke_color=YELLOW)\n        self.play(Create(transformed_fraction_fill_line))\n        self.wait()\n        self.make_static_body(bounding_box)\n        self.make_rigid_body(*transformed_dot_lst)\n        self.wait(8)"}]}
{"messages": [{"role": "user", "content": "Explain the probability of no phase transformation using the Poisson distribution and visualize the concept with a time cone."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass ConnectProbToTimeCone(Scene):\n\n    def construct(self):\n        slide_title = Tex('$\\\\text{How to calculate } P(\\\\text{no phase transformation has occurred})\\\\text{ from time cone?}$', font_size=35)\n        slide_title.to_corner(UL)\n        page_6 = Tex('$6$', font_size=40)\n        page_6.to_edge(DR)\n        poisson_assumption = Text('Assumption: nucleation events are random and independent', font_size=35)\n        poisson_assumption.shift(UP * 2)\n        poisson_assumption.set_color_by_t2c({'[:10]': YELLOW})\n        poisson_equation = MathTex('P(X=k)=\\\\frac{\\\\lambda^ke^{-\\\\lambda}}{k!}')\n        poisson_equation_zero_event_1 = MathTex('P(X=0)=\\\\frac{\\\\lambda^0e^{-\\\\lambda}}{0!}')\n        poisson_equation_zero_event_2 = MathTex('P(X=0)=', '\\\\frac{\\\\lambda^0e^{-\\\\lambda}}{0!}')\n        poisson_equation_zero_event_simplified = MathTex('P(X=0)=', 'e^{-\\\\lambda}')\n        poisson_equation_zero_event_simplified.align_to(poisson_equation_zero_event_2, LEFT)\n        poisson_equation_zero_event_expected_number = MathTex('P(X=0)=', 'e^{-\\\\langle X\\\\rangle}')\n        poisson_equation_zero_event_expected_number.align_to(poisson_equation_zero_event_simplified, LEFT)\n        expect_num_nuclei = Tex('$\\\\langle X\\\\rangle$', '$:\\\\text{ expected number of nucleation events}$', arg_separator=' ')\n        expect_num_nuclei.next_to(poisson_equation_zero_event_expected_number, DOWN)\n        expect_num_nuclei_new_symbol = Tex('$\\\\langle X\\\\rangle$', '$\\\\equiv$', '$\\\\langle N\\\\rangle$', arg_separator=' ')\n        expect_num_nuclei_new_symbol.move_to(expect_num_nuclei.get_center())\n        poisson_equation_zero_event_expected_number_new_symbol = MathTex('P(X=0)=', 'e^{-\\\\langle N\\\\rangle}')\n        expect_num_nuclei_unit_analysis = Tex('$\\\\langle N\\\\rangle$', '$=$', '$\\\\frac{\\\\text{\\\\# of nucleation events}}{\\\\text{unit volume}\\\\cdot\\\\text{unit time}}$', '$\\\\cdot$', '$\\\\text{unit volume}$', '$\\\\cdot$', '$\\\\text{unit time}$', arg_separator=' ')\n        expect_num_nuclei_unit_analysis.move_to(expect_num_nuclei_new_symbol.get_center())\n        expect_num_nuclei_unit_analysis_symbols = Tex('$\\\\langle N\\\\rangle$', '$=$', '$J$', '$\\\\cdot$', '$V$', '$\\\\cdot$', '$t$', arg_separator=' ')\n        expect_num_nuclei_unit_analysis_symbols.move_to(expect_num_nuclei_unit_analysis.get_center())\n        expect_num_nuclei_jvt = Tex('$\\\\langle N\\\\rangle$', ' $=$', ' $J$', ' $\\\\cdot$', ' $($', '$V$', '$t$', '$)$', arg_separator='')\n        expect_num_nuclei_jvt.move_to(expect_num_nuclei_unit_analysis_symbols.get_center())\n        expect_num_nuclei_jomega = Tex('$\\\\langle N\\\\rangle$', ' $=$', ' $J$', ' $\\\\cdot$', ' $||\\\\Omega_N||$', arg_separator='')\n        expect_num_nuclei_jomega.move_to(expect_num_nuclei_jvt.get_center())\n        prob_no_nucleation = MathTex('P(X=0)=', 'e^{-J||\\\\Omega_N||}')\n        nucleation_rate_sym = expect_num_nuclei_unit_analysis.submobjects[2].copy()\n        nucleation_rate_brace = BraceText(nucleation_rate_sym, '$J$')\n        volume_sym = expect_num_nuclei_unit_analysis.submobjects[4].copy()\n        volume_brace = BraceText(volume_sym, '$V$')\n        time_sym = expect_num_nuclei_unit_analysis.submobjects[6].copy()\n        time_brace = BraceText(time_sym, '$t$')\n        self.add(slide_title, page_6)\n        self.wait()\n        self.play(Write(poisson_assumption))\n        self.wait()\n        self.play(Write(poisson_equation))\n        self.wait()\n        self.play(ReplacementTransform(poisson_equation, poisson_equation_zero_event_1))\n        self.add(poisson_equation_zero_event_2)\n        self.remove(poisson_equation_zero_event_1)\n        self.wait()\n        self.play(TransformMatchingTex(poisson_equation_zero_event_2, poisson_equation_zero_event_simplified))\n        self.wait()\n        self.play(ReplacementTransform(poisson_equation_zero_event_simplified, poisson_equation_zero_event_expected_number))\n        self.wait()\n        self.play(Write(expect_num_nuclei))\n        self.wait()\n        self.play(TransformMatchingTex(expect_num_nuclei, expect_num_nuclei_new_symbol))\n        self.wait()\n        self.play(LaggedStart(ReplacementTransform(poisson_equation_zero_event_expected_number, poisson_equation_zero_event_expected_number_new_symbol), TransformMatchingTex(expect_num_nuclei_new_symbol, expect_num_nuclei_unit_analysis), lag_ratio=1))\n        self.wait()\n        self.play(LaggedStart(Write(nucleation_rate_brace), Write(volume_brace), Write(time_brace), lag_ratio=1), run_time=2)\n        self.wait()\n        self.play(TransformMatchingShapes(VGroup(expect_num_nuclei_unit_analysis, nucleation_rate_brace, volume_brace, time_brace), VGroup(expect_num_nuclei_unit_analysis_symbols)))\n        self.wait()\n        self.play(TransformMatchingTex(expect_num_nuclei_unit_analysis_symbols, expect_num_nuclei_jvt))\n        self.wait()\n        self.play(TransformMatchingTex(expect_num_nuclei_jvt, expect_num_nuclei_jomega))\n        self.wait()\n        self.play(LaggedStart(ReplacementTransform(poisson_equation_zero_event_expected_number_new_symbol, prob_no_nucleation), FadeOut(expect_num_nuclei_jomega), lag_ratio=1))\n        self.wait()\n        self.play(prob_no_nucleation.animate.next_to(poisson_assumption, DOWN))\n        self.wait()\n        axes = Axes(x_range=[0, 7], y_range=[0, 7], x_length=8, y_length=6)\n        axes.move_to(prob_no_nucleation.get_bottom(), aligned_edge=UP)\n        axes.scale(0.6)\n        x_label = axes.get_x_axis_label(Tex('$x$'))\n        y_label = axes.get_y_axis_label(Tex('$t$'))\n        point_of_interest = Dot()\n        point_of_interest_x, point_of_interest_y = (3.5, 3.5)\n        point_of_interest.move_to(axes.c2p(point_of_interest_x, point_of_interest_y))\n        growth_cone_height = 6\n        growth_cone_base_radius = 1.5\n        nucleation_region_top = point_of_interest.get_center()\n        nucleation_region_left = axes.c2p(point_of_interest_x - point_of_interest_y / (growth_cone_height / growth_cone_base_radius), 0)\n        nucleation_region_right = axes.c2p(point_of_interest_x + point_of_interest_y / (growth_cone_height / growth_cone_base_radius), 0)\n        nucleation_region_line_1 = DashedLine(start=nucleation_region_top, end=nucleation_region_left)\n        nucleation_region_line_2 = DashedLine(start=nucleation_region_left, end=nucleation_region_right)\n        nucleation_region_line_3 = DashedLine(start=nucleation_region_right, end=nucleation_region_top)\n        nucleation_region = VGroup(nucleation_region_line_1, nucleation_region_line_2, nucleation_region_line_3)\n        nucleation_region.set_stroke(color=BLUE)\n        nucleation_region_polygon = Polygon(nucleation_region_top, nucleation_region_left, nucleation_region_right)\n        nucleation_region_polygon.set_stroke(opacity=0)\n        nucleation_region_polygon.set_fill(BLUE, opacity=0.2)\n        self.play(Create(axes))\n        self.play(Create(x_label), Create(y_label))\n        self.play(FadeIn(point_of_interest))\n        self.play(Create(nucleation_region), FadeIn(nucleation_region_polygon), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the calculation of spacetime volume in 1D, 2D, and 3D, showing the progression of formulas and geometric representations."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass CalcTimeConeVolume(ThreeDScene):\n\n    def construct(self):\n        slide_title = Tex('$\\\\text{Calculate } ||\\\\Omega_N|| \\\\text{ in 1D, 2D, 3D space-time}$', font_size=40)\n        slide_title.to_corner(UL)\n        page_7 = Tex('$7$', font_size=40)\n        page_7.to_edge(DR)\n        axes = ThreeDAxes(x_range=[0, 7], y_range=[0, 7], z_range=[0, 7], x_length=8, y_length=8, z_length=6)\n        axes.shift(-Z_AXIS * 3.3)\n        axes.scale(0.6)\n        x_axis = axes.get_x_axis()\n        y_axis = axes.get_y_axis()\n        z_axis = axes.get_z_axis()\n        axes.x_axis = x_axis.rotate(PI / 2, axis=X_AXIS)\n        x_label = axes.get_x_axis_label(Tex('$x$')).rotate(PI / 2, axis=X_AXIS)\n        y_label = axes.get_y_axis_label(Tex('$y$')).rotate(PI / 2, axis=X_AXIS)\n        z_label = axes.get_z_axis_label(Tex('$t$'))\n        point_of_interest_x, point_of_interest_y, point_of_interest_z = (3.5, 0, 3.5)\n        point_of_interest = Dot3D(point=axes.c2p(point_of_interest_x, point_of_interest_y, point_of_interest_z))\n        growth_cone_height = 6\n        growth_cone_base_radius = 1.5\n        nucleation_region_top = point_of_interest.get_center()\n        nucleation_region_left = axes.c2p(point_of_interest_x - point_of_interest_z / (growth_cone_height / growth_cone_base_radius), 0, 0)\n        nucleation_region_right = axes.c2p(point_of_interest_x + point_of_interest_z / (growth_cone_height / growth_cone_base_radius), 0, 0)\n        nucleation_region_bottom_mid = axes.c2p(point_of_interest_x, 0, 0)\n        nucleation_region_line_1 = DashedLine(start=nucleation_region_top, end=nucleation_region_left)\n        nucleation_region_line_2 = DashedLine(start=nucleation_region_left, end=nucleation_region_right)\n        nucleation_region_line_3 = DashedLine(start=nucleation_region_right, end=nucleation_region_top)\n        nucleation_region = VGroup(nucleation_region_line_1, nucleation_region_line_2, nucleation_region_line_3)\n        nucleation_region.set_stroke(color=BLUE)\n        height_2d = DashedLine(start=nucleation_region_top, end=nucleation_region_bottom_mid)\n        height_2d_brace = Brace(height_2d, direction=X_AXIS).rotate(PI / 2, axis=X_AXIS, about_point=(nucleation_region_bottom_mid + nucleation_region_top) / 2)\n        height_2d_brace_label = height_2d_brace.get_tex('t').rotate(PI / 2, axis=X_AXIS, about_point=(nucleation_region_bottom_mid + nucleation_region_top) / 2)\n        base_2d_brace = BraceText(Line(start=nucleation_region_bottom_mid, end=nucleation_region_right), '$\\\\dot{R}t$').rotate(PI / 2, axis=X_AXIS, about_point=nucleation_region_bottom_mid)\n        self.add_fixed_in_frame_mobjects(slide_title, page_7)\n        self.wait()\n        self.set_camera_orientation(phi=90 * DEGREES, theta=-90 * DEGREES)\n        self.play(Create(x_axis), Create(z_axis))\n        self.play(Create(x_label), Create(z_label))\n        self.play(FadeIn(point_of_interest))\n        self.play(Create(nucleation_region), run_time=2)\n        self.wait()\n        self.play(Create(height_2d))\n        self.wait()\n        self.play(Write(height_2d_brace))\n        self.play(Write(height_2d_brace_label))\n        self.wait()\n        self.play(Write(base_2d_brace))\n        self.wait()\n        time_cone_1d_area_eqn = Tex('$||\\\\Omega_N||_{\\\\text{1D}}$', ' $=$', ' $\\\\frac{1}{2}$', ' $\\\\cdot$', ' $2$', '$\\\\dot{R}$', '$t$', ' $\\\\cdot$', ' $t$')\n        time_cone_1d_area_eqn.shift(UP * 2.8 + RIGHT * 4)\n        time_cone_1d_area_eqn_symbols = Tex('$||\\\\Omega_N||_{\\\\text{1D}}$', ' $=$', ' $\\\\dot{R}$', '$t^2$')\n        time_cone_1d_area_eqn_symbols.align_to(time_cone_1d_area_eqn, LEFT)\n        time_cone_1d_area_eqn_symbols.align_to(time_cone_1d_area_eqn, UP)\n        self.add_fixed_in_frame_mobjects(time_cone_1d_area_eqn)\n        self.play(Write(time_cone_1d_area_eqn))\n        self.wait()\n        self.play(ReplacementTransform(time_cone_1d_area_eqn, time_cone_1d_area_eqn_symbols))\n        self.add_fixed_in_frame_mobjects(time_cone_1d_area_eqn_symbols)\n        self.wait()\n        self.move_camera(phi=85 * DEGREES, theta=-85 * DEGREES)\n        self.wait()\n        self.play(Create(y_axis))\n        self.play(Create(y_label))\n        self.wait()\n        cone_2d_space_time = Cone(base_radius=nucleation_region_bottom_mid[0] - nucleation_region_left[0], height=nucleation_region_top[-1] - nucleation_region_bottom_mid[-1], direction=Z_AXIS)\n        cone_2d_space_time.shift(axes.c2p(point_of_interest_x, point_of_interest_y, point_of_interest_z))\n        self.play(LaggedStart(Rotate(nucleation_region, angle=PI, axis=Z_AXIS), FadeIn(cone_2d_space_time), lag_ratio=0.1), run_time=2)\n        self.wait()\n        time_cone_2d_area_eqn = Tex('$||\\\\Omega_N||_{\\\\text{2D}}$', ' $=$', ' $\\\\frac{1}{3}$', ' $\\\\cdot$', ' $\\\\pi$', '$(\\\\dot{R}t)^2$', ' $\\\\cdot$', ' $t$')\n        time_cone_2d_area_eqn.shift(UP * 2.8 + RIGHT * 4)\n        time_cone_2d_area_eqn.next_to(time_cone_1d_area_eqn_symbols, DOWN)\n        time_cone_2d_area_eqn.align_to(time_cone_1d_area_eqn_symbols, LEFT)\n        self.add_fixed_in_frame_mobjects(time_cone_2d_area_eqn)\n        self.play(Write(time_cone_2d_area_eqn))\n        self.wait()\n        time_cone_2d_area_eqn_symbols = Tex('$||\\\\Omega_N||_{\\\\text{2D}}$', ' $=$', ' $\\\\frac{\\\\pi}{3}$', '$\\\\dot{R}^2$', '$t^3$')\n        time_cone_2d_area_eqn_symbols.rotate(PI / 2, axis=(axes.c2p(2, 0, 0) - axes.c2p(1, 0, 0)) / np.linalg.norm(axes.c2p(2, 0, 0) - axes.c2p(1, 0, 0)), about_point=time_cone_2d_area_eqn_symbols.get_center())\n        time_cone_2d_area_eqn_symbols.align_to(time_cone_2d_area_eqn, LEFT)\n        time_cone_2d_area_eqn_symbols.align_to(time_cone_2d_area_eqn, UP)\n        time_cone_2d_area_eqn_symbols.shift(np.array((0.0, 0.0, 2.0)))\n        self.play(ReplacementTransform(time_cone_2d_area_eqn, time_cone_2d_area_eqn_symbols))\n        self.wait()\n        circle_lst = []\n        for circle_height in np.linspace(0, point_of_interest_z, 4, endpoint=False):\n            base_rad = np.interp(circle_height, [0, point_of_interest_z], [nucleation_region_bottom_mid[0] - nucleation_region_left[0], 0])\n            circle_to_add = Circle(radius=base_rad)\n            circle_to_add.set_fill(color=RED, opacity=0.6)\n            circle_lst.append(circle_to_add)\n        circle_lst = [circle.shift(axes.c2p(point_of_interest_x, 0, num)) for num, circle in enumerate(circle_lst)]\n        sphere_lst = [Sphere(center=circle.get_center(), radius=circle.radius, fill_opacity=0.6).set_color(RED) for circle in circle_lst]\n        self.play(FadeIn(*circle_lst))\n        self.wait()\n        alter_time_cone_2d_area_eqn = MathTex(\"\\\\int_{t'=0}^{t'=t}\\\\pi(\\\\dot{R}t')^2dt'\", \"&=\\\\pi\\\\dot{R}^2\\\\frac{{t'}^3}{3}\\\\bigg|_{t'=0}^{t'=t}\\\\\\\\\", '&=\\\\frac{\\\\pi}{3}\\\\dot{R}^2t^3', arg_separator='')\n        alter_time_cone_2d_area_eqn.shift(UP * 0.3 + RIGHT)\n        self.add_fixed_in_frame_mobjects(alter_time_cone_2d_area_eqn)\n        self.play(Write(alter_time_cone_2d_area_eqn))\n        self.wait()\n        self.play(Uncreate(cone_2d_space_time))\n        self.wait()\n        self.play(LaggedStart(AnimationGroup(*[Rotate(circle, angle=PI, axis=Y_AXIS) for circle in circle_lst]), AnimationGroup(FadeIn(*sphere_lst)), lag_ratio=0.1))\n        self.play(FadeOut(*circle_lst))\n        self.wait()\n        alter_time_cone_3d_area_eqn = MathTex(\"\\\\int_{t'=0}^{t'=t}\\\\frac{4}{3}\\\\pi(\\\\dot{R}t')^3dt'\", \"&=\\\\frac{4\\\\pi}{3}\\\\dot{R}^3\\\\frac{{t'}^4}{4}\\\\bigg|_{t'=0}^{t'=t}\\\\\\\\\", '&=\\\\frac{\\\\pi}{3}\\\\dot{R}^3t^4', arg_separator='')\n        alter_time_cone_3d_area_eqn.rotate(PI / 2, axis=X_AXIS, about_point=alter_time_cone_3d_area_eqn.get_center())\n        alter_time_cone_3d_area_eqn.align_to(alter_time_cone_2d_area_eqn, LEFT)\n        alter_time_cone_3d_area_eqn.align_to(alter_time_cone_2d_area_eqn, UP)\n        self.play(TransformMatchingShapes(alter_time_cone_2d_area_eqn, alter_time_cone_3d_area_eqn))\n        self.wait()\n        time_cone_3d_area_eqn = Tex('$||\\\\Omega_N||_{\\\\text{3D}}=\\\\frac{\\\\pi}{3}\\\\dot{R}^3t^4$')\n        time_cone_3d_area_eqn.next_to(time_cone_2d_area_eqn_symbols, DOWN, buff=0.8)\n        time_cone_3d_area_eqn.align_to(time_cone_2d_area_eqn_symbols, LEFT)\n        self.add_fixed_in_frame_mobjects(time_cone_3d_area_eqn)\n        self.play(LaggedStart(FadeOut(alter_time_cone_3d_area_eqn), Write(time_cone_3d_area_eqn), lag_ratio=0.8), run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show the derivation of the JMAK equation and then animate the phase fraction as a function of time, illustrating the effect of changing nucleation and growth rates."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass SinglePhaseFraction(Scene):\n\n    def construct(self):\n        slide_title = Tex('Phase fraction transformed as a function of time', font_size=40)\n        slide_title.to_corner(UL)\n        page_8 = Tex('$8$', font_size=40)\n        page_8.to_edge(DR)\n        statement_1 = Tex('the phase fraction transformed', '$=$', '$1-$', 'the phase fraction untransformed', font_size=37, arg_separator=' ')\n        statement_1.shift(UP * 2)\n        statement_2 = Tex('the phase fraction transformed', '$=$', '$1-$', '$P(\\\\text{no phase transformation has occurred})$', font_size=37, arg_separator=' ')\n        statement_2.move_to(statement_1.get_center())\n        statement_3 = Tex('the phase fraction transformed', '$=$', '$1-$', '$e^{-J||\\\\Omega_N||}$', font_size=37, arg_separator=' ')\n        statement_3.move_to(statement_2.get_center()).align_to(statement_2, LEFT)\n        statement_4 = Tex('the phase fraction transformed', '$=$', '$\\\\begin{cases} 1-\\\\exp(-J\\\\dot{R}t^2) & \\\\text{1D}\\\\\\\\ 1-\\\\exp(-\\\\frac{\\\\pi}{3}J\\\\dot{R}^2t^3) & \\\\text{2D}\\\\\\\\ 1-\\\\exp(-\\\\frac{\\\\pi}{3}J\\\\dot{R}^3t^4) & \\\\text{3D}\\\\end{cases}$')\n        jmak_box = Rectangle(width=6, height=0.8)\n        jmak_box.set_stroke(color=YELLOW)\n        jmak_box.move_to(statement_4.get_corner(direction=DR)).shift((statement_4.get_top()[1] - statement_4.get_bottom()[1]) / 6 + LEFT * 3)\n        jmak_box_brace = BraceText(jmak_box, 'JMAK Equation')\n        phase_fraction_all_cases = VGroup(statement_4, jmak_box, jmak_box_brace)\n        axes = Axes(x_range=[0, 6, 1], y_range=[0, 1.2, 0.2], x_length=8, y_length=4, x_axis_config={'numbers_to_include': np.arange(0, 5 + 1, 1)}, y_axis_config={'numbers_to_include': np.arange(0, 1 + 0.2, 0.2)})\n        axes.shift(DOWN * 1.4)\n        x_label = axes.get_x_axis_label(Tex('$t$'))\n        y_label = axes.get_y_axis_label(Tex('$f_{\\\\text{transformed}}$'))\n        nucleation_rate = ValueTracker(0.24)\n        growth_rate = ValueTracker(0.76)\n        t_valuetracker = ValueTracker(0)\n        fraction_curve = always_redraw(lambda: axes.plot(lambda t: 1 - np.exp(-np.pi / 3 * nucleation_rate.get_value() * growth_rate.get_value() ** 3 * t ** 4), x_range=[0, t_valuetracker.get_value()], color=YELLOW))\n        nucleation_rate_text = Tex('$J$: ').next_to(axes, RIGHT, buff=0.5).shift(UP)\n        nucleation_rate_value = always_redraw(lambda: DecimalNumber(num_decimal_places=2).set_value(nucleation_rate.get_value()).next_to(nucleation_rate_text))\n        growth_rate_text = Tex('$\\\\dot{R}$: ').next_to(nucleation_rate_text, DOWN, buff=0.3)\n        growth_rate_value = always_redraw(lambda: DecimalNumber(num_decimal_places=2).set_value(growth_rate.get_value()).next_to(growth_rate_text).align_to(growth_rate_text.get_bottom(), DOWN).align_to(nucleation_rate_value, LEFT))\n        j_decrease_arrow = Arrow(start=nucleation_rate_text.get_top(), end=nucleation_rate_text.get_bottom(), stroke_width=2).next_to(nucleation_rate_text, LEFT, buff=0.1)\n        r_increase_arrow = Arrow(start=nucleation_rate_text.get_bottom(), end=nucleation_rate_text.get_top(), stroke_width=2).next_to(growth_rate_text, LEFT, buff=0.1).align_to(j_decrease_arrow, LEFT).align_to(growth_rate_text, DOWN)\n        self.add(slide_title, page_8)\n        self.wait()\n        self.play(Write(statement_1))\n        self.wait()\n        self.play(TransformMatchingTex(statement_1, statement_2))\n        self.wait()\n        self.play(ReplacementTransform(statement_2, statement_3))\n        self.wait()\n        self.play(TransformMatchingTex(statement_3, statement_4))\n        self.wait()\n        self.play(Create(jmak_box))\n        self.wait()\n        self.play(Write(jmak_box_brace))\n        self.wait()\n        self.play(phase_fraction_all_cases.animate.shift(UP * 2).scale(0.8), run_time=2)\n        self.wait()\n        self.play(FadeOut(jmak_box_brace))\n        self.wait()\n        self.play(Create(axes))\n        self.play(Write(x_label), Write(y_label))\n        self.wait()\n        self.add(fraction_curve)\n        self.play(Write(VGroup(nucleation_rate_text, nucleation_rate_value, growth_rate_text, growth_rate_value)))\n        self.play(t_valuetracker.animate.set_value(6), run_time=5, rate_func=linear)\n        self.wait()\n        self.play(growth_rate.animate(run_time=5, rate_func=linear).set_value(1.5), FadeIn(r_increase_arrow, run_time=0.5))\n        self.play(FadeOut(r_increase_arrow, run_time=0.5))\n        self.wait()\n        self.play(nucleation_rate.animate(run_time=5, rate_func=linear).set_value(0.01), FadeIn(j_decrease_arrow, run_time=0.5))\n        self.play(FadeOut(j_decrease_arrow, run_time=0.5))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Plot a phase fraction curve against time and illustrate the time it takes to reach 10%, 50%, and 99% transformed with corresponding temperature markings."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass PhaseFractionToTTT(Scene):\n\n    def construct(self):\n        animation_duration = 5\n        phase_fraction_axes = Axes(x_range=[0, 1100, 100], y_range=[0, 1.3, 0.01], x_length=8, y_length=2, y_axis_config={'numbers_to_include': [0.1, 0.5, 0.99], 'include_ticks': False})\n        phase_fraction_axes.shift(LEFT * 0.5)\n        phase_fraction_axes.to_edge(UP, buff=0.5)\n        phase_fraction_x_label = phase_fraction_axes.get_x_axis_label(Tex('$t$'))\n        phase_fraction_y_label = phase_fraction_axes.get_y_axis_label(Tex('$f_{\\\\text{transformed}}$').scale(0.7).rotate(PI / 2), edge=LEFT, direction=LEFT, buff=0.4)\n        phase_fraction_y_axis = phase_fraction_axes.y_axis\n        ticks = VGroup()\n        for _ in [0.1, 0.5, 0.99]:\n            ticks.add(phase_fraction_y_axis.get_tick(_, phase_fraction_y_axis.tick_size))\n        phase_fraction_y_axis.add(ticks)\n        phase_fraction_y_axis.ticks = ticks\n        ttt_axes = Axes(x_range=[0, 1100, 100], y_range=[0, animation_duration + 2, 1], x_length=8, y_length=4, x_axis_config={'numbers_to_include': np.arange(0, 1000 + 100, 100)})\n        ttt_axes.shift(LEFT * 0.5)\n        ttt_axes.to_edge(DOWN, buff=0.1)\n        ttt_x_label = ttt_axes.get_x_axis_label(Tex('$t$'))\n        ttt_y_label = ttt_axes.get_y_axis_label(Tex('$T$'), edge=LEFT, direction=LEFT, buff=0.4)\n        nucleation_start_value, nucleation_end_value = (0.01, 1e-05)\n        growth_rate_start_value, growth_rate_end_value = (0.0008, 0.01)\n        temp_proxy_tracker = ValueTracker(0)\n        nucleation_rate = ValueTracker(nucleation_start_value).add_updater(lambda num: num.set_value(nucleation_start_value + (nucleation_end_value - nucleation_start_value) / animation_duration * temp_proxy_tracker.get_value()))\n        growth_rate = ValueTracker(growth_rate_start_value).add_updater(lambda num: num.set_value(growth_rate_start_value + (growth_rate_end_value - growth_rate_start_value) / animation_duration * temp_proxy_tracker.get_value()))\n        self.add(nucleation_rate, growth_rate)\n        fraction_curve = always_redraw(lambda: phase_fraction_axes.plot(lambda t: 1 - np.exp(-np.pi / 3 * nucleation_rate.get_value() * growth_rate.get_value() ** 3 * t ** 4)))\n        nucleation_rate_text = Tex('$J$: ').next_to(phase_fraction_axes, RIGHT, buff=0.4).shift(UP)\n        nucleation_rate_value = always_redraw(lambda: DecimalNumber(num_decimal_places=1).set_value(nucleation_rate.get_value() * 10000.0).next_to(nucleation_rate_text))\n        scale_factor_nucleation = Tex('$\\\\times 10^{-4}$')\n        scale_factor_nucleation.add_updater(lambda x: x.next_to(nucleation_rate_value, RIGHT, buff=0.1).align_to(nucleation_rate_value, DOWN))\n        growth_rate_text = Tex('$\\\\dot{R}$: ').next_to(nucleation_rate_text, DOWN, buff=0.3)\n        growth_rate_value = always_redraw(lambda: DecimalNumber(num_decimal_places=1).set_value(growth_rate.get_value() * 10000.0).next_to(growth_rate_text).align_to(growth_rate_text.get_bottom(), DOWN).align_to(nucleation_rate_value, LEFT))\n        scale_factor_growth_rate = Tex('$\\\\times 10^{-4}$')\n        scale_factor_growth_rate.add_updater(lambda x: x.next_to(growth_rate_value, RIGHT, buff=0.1).align_to(growth_rate_value, DOWN))\n        self.play(Create(phase_fraction_axes))\n        self.play(Write(phase_fraction_x_label), Write(phase_fraction_y_label))\n        self.wait()\n        self.play(Create(ttt_axes))\n        self.play(Write(ttt_x_label), Write(ttt_y_label))\n        self.wait()\n        self.play(Write(VGroup(nucleation_rate_text, nucleation_rate_value, scale_factor_nucleation, growth_rate_text, growth_rate_value, scale_factor_growth_rate)))\n        self.play(Create(fraction_curve), run_time=3)\n        self.wait()\n        time_it_takes_10_perc = ValueTracker(np.power(-3 * np.log(1 - 0.1) / (np.pi * nucleation_rate.get_value() * growth_rate.get_value() ** 3), 0.25)).add_updater(lambda num: num.set_value(np.power(-3 * np.log(1 - 0.1) / (np.pi * nucleation_rate.get_value() * growth_rate.get_value() ** 3), 0.25)))\n        fraction_line_horizontal_10_perc = always_redraw(lambda: DashedLine(start=phase_fraction_axes.c2p(0, 0.1), end=phase_fraction_axes.c2p(time_it_takes_10_perc.get_value(), 0.1), color=BLUE))\n        fraction_line_vertical_10_perc = always_redraw(lambda: DashedLine(start=phase_fraction_axes.c2p(time_it_takes_10_perc.get_value(), 0.1), end=ttt_axes.c2p(time_it_takes_10_perc.get_value(), temp_proxy_tracker.get_value() + 1), color=BLUE))\n        fraction_dot_10_perc = always_redraw(lambda: Dot(point=phase_fraction_axes.c2p(time_it_takes_10_perc.get_value(), 0.1), color=BLUE))\n        ttt_dot_10_perc = always_redraw(lambda: Dot(point=ttt_axes.c2p(time_it_takes_10_perc.get_value(), temp_proxy_tracker.get_value() + 1), color=BLUE))\n        ttt_dot_10_perc_path = TracedPath(ttt_dot_10_perc.get_center, stroke_color=BLUE, stroke_width=4)\n        self.add(time_it_takes_10_perc)\n        self.play(Create(fraction_line_horizontal_10_perc))\n        self.play(Create(fraction_dot_10_perc))\n        self.play(Create(fraction_line_vertical_10_perc))\n        self.play(Create(ttt_dot_10_perc))\n        self.add(ttt_dot_10_perc_path)\n        time_it_takes_50_perc = ValueTracker(np.power(-3 * np.log(1 - 0.5) / (np.pi * nucleation_rate.get_value() * growth_rate.get_value() ** 3), 0.25)).add_updater(lambda num: num.set_value(np.power(-3 * np.log(1 - 0.5) / (np.pi * nucleation_rate.get_value() * growth_rate.get_value() ** 3), 0.25)))\n        fraction_line_horizontal_50_perc = always_redraw(lambda: DashedLine(start=phase_fraction_axes.c2p(0, 0.5), end=phase_fraction_axes.c2p(time_it_takes_50_perc.get_value(), 0.5), color=YELLOW))\n        fraction_line_vertical_50_perc = always_redraw(lambda: DashedLine(start=phase_fraction_axes.c2p(time_it_takes_50_perc.get_value(), 0.5), end=ttt_axes.c2p(time_it_takes_50_perc.get_value(), temp_proxy_tracker.get_value() + 1), color=YELLOW))\n        fraction_dot_50_perc = always_redraw(lambda: Dot(point=phase_fraction_axes.c2p(time_it_takes_50_perc.get_value(), 0.5), color=YELLOW))\n        ttt_dot_50_perc = always_redraw(lambda: Dot(point=ttt_axes.c2p(time_it_takes_50_perc.get_value(), temp_proxy_tracker.get_value() + 1), color=YELLOW))\n        ttt_dot_50_perc_path = TracedPath(ttt_dot_50_perc.get_center, stroke_color=YELLOW, stroke_width=4)\n        self.add(time_it_takes_50_perc)\n        self.play(Create(fraction_line_horizontal_50_perc))\n        self.play(Create(fraction_dot_50_perc))\n        self.play(Create(fraction_line_vertical_50_perc))\n        self.play(Create(ttt_dot_50_perc))\n        self.add(ttt_dot_50_perc_path)\n        time_it_takes_99_perc = ValueTracker(np.power(-3 * np.log(1 - 0.99) / (np.pi * nucleation_rate.get_value() * growth_rate.get_value() ** 3), 0.25)).add_updater(lambda num: num.set_value(np.power(-3 * np.log(1 - 0.99) / (np.pi * nucleation_rate.get_value() * growth_rate.get_value() ** 3), 0.25)))\n        fraction_line_horizontal_99_perc = always_redraw(lambda: DashedLine(start=phase_fraction_axes.c2p(0, 0.99), end=phase_fraction_axes.c2p(time_it_takes_99_perc.get_value(), 0.99), color=RED))\n        fraction_line_vertical_99_perc = always_redraw(lambda: DashedLine(start=phase_fraction_axes.c2p(time_it_takes_99_perc.get_value(), 0.99), end=ttt_axes.c2p(time_it_takes_99_perc.get_value(), temp_proxy_tracker.get_value() + 1), color=RED))\n        fraction_dot_99_perc = always_redraw(lambda: Dot(point=phase_fraction_axes.c2p(time_it_takes_99_perc.get_value(), 0.99), color=RED))\n        ttt_dot_99_perc = always_redraw(lambda: Dot(point=ttt_axes.c2p(time_it_takes_99_perc.get_value(), temp_proxy_tracker.get_value() + 1), color=RED))\n        ttt_dot_99_perc_path = TracedPath(ttt_dot_99_perc.get_center, stroke_color=RED, stroke_width=4)\n        self.add(time_it_takes_99_perc)\n        self.play(Create(fraction_line_horizontal_99_perc))\n        self.play(Create(fraction_dot_99_perc))\n        self.play(Create(fraction_line_vertical_99_perc))\n        self.play(Create(ttt_dot_99_perc))\n        self.add(ttt_dot_99_perc_path)\n        ttt_temperature_line = always_redraw(lambda: DashedLine(start=ttt_axes.c2p(0, temp_proxy_tracker.get_value() + 1), end=ttt_axes.c2p(ttt_axes.x_range[1], temp_proxy_tracker.get_value() + 1), stroke_opacity=0.6))\n        self.play(Create(ttt_temperature_line))\n        self.wait()\n        self.play(temp_proxy_tracker.animate(run_time=animation_duration, rate_func=smooth).set_value(animation_duration))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the formation and interaction of two phases on a time-space diagram, illustrating their growth, allowed regions, and impingement."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass TwoPhaseTimeCone(Scene):\n\n    def construct(self):\n        slide_title = Tex('What happens when we have two phases?', font_size=40)\n        slide_title.to_corner(UL)\n        page_9 = Tex('$9$', font_size=40)\n        page_9.to_edge(DR)\n        axes = Axes(x_range=[-3, 3, 0.5], y_range=[0, 3, 0.5], x_length=10, y_length=6)\n        axes.shift(DOWN * 0.8)\n        x_label = axes.get_x_axis_label(Tex('$x$'))\n        y_label = axes.get_y_axis_label(Tex('$t$'))\n        point_of_interest_x_tracker = ValueTracker(axes.c2p(1.5, 2.5)[0])\n        point_of_interest_y_tracker = ValueTracker(axes.c2p(1.5, 2.5)[1])\n        green_phase_growth_rate_tracker = ValueTracker(0.2)\n        orange_phase_growth_rate_tracker = ValueTracker(1 / 1.1)\n        point_of_interest = always_redraw(lambda: Dot(point=np.array([point_of_interest_x_tracker.get_value(), point_of_interest_y_tracker.get_value(), 0])))\n        inverted_time_cone_green_poi_left = always_redraw(lambda: DashedVMobject(axes.plot(lambda x: 1 / green_phase_growth_rate_tracker.get_value() * (x - axes.p2c(point_of_interest.get_center())[0]) + axes.p2c(point_of_interest.get_center())[1], x_range=[axes.p2c(point_of_interest.get_center())[0] - axes.p2c(point_of_interest.get_center())[1] / (1 / green_phase_growth_rate_tracker.get_value()), axes.p2c(point_of_interest.get_center())[0]], color=GREEN)))\n        inverted_time_cone_green_poi_right = always_redraw(lambda: DashedVMobject(axes.plot(lambda x: -(1 / green_phase_growth_rate_tracker.get_value()) * (x - axes.p2c(point_of_interest.get_center())[0]) + axes.p2c(point_of_interest.get_center())[1], x_range=[axes.p2c(point_of_interest.get_center())[0], axes.p2c(point_of_interest.get_center())[0] + axes.p2c(point_of_interest.get_center())[1] / (1 / green_phase_growth_rate_tracker.get_value())], color=GREEN)))\n        inverted_time_cone_green_poi = VGroup(inverted_time_cone_green_poi_left, inverted_time_cone_green_poi_right)\n        inverted_time_cone_orange_poi_left = always_redraw(lambda: DashedVMobject(axes.plot(lambda x: 1 / orange_phase_growth_rate_tracker.get_value() * (x - axes.p2c(point_of_interest.get_center())[0]) + axes.p2c(point_of_interest.get_center())[1], x_range=[axes.p2c(point_of_interest.get_center())[0] - axes.p2c(point_of_interest.get_center())[1] / (1 / orange_phase_growth_rate_tracker.get_value()), axes.p2c(point_of_interest.get_center())[0]], color=ORANGE)))\n        inverted_time_cone_orange_poi_right = always_redraw(lambda: DashedVMobject(axes.plot(lambda x: -(1 / orange_phase_growth_rate_tracker.get_value()) * (x - axes.p2c(point_of_interest.get_center())[0]) + axes.p2c(point_of_interest.get_center())[1], x_range=[axes.p2c(point_of_interest.get_center())[0], axes.p2c(point_of_interest.get_center())[0] + axes.p2c(point_of_interest.get_center())[1] / (1 / orange_phase_growth_rate_tracker.get_value())], color=ORANGE)))\n        inverted_time_cone_orange_poi = VGroup(inverted_time_cone_orange_poi_left, inverted_time_cone_orange_poi_right)\n        grow_rate_relation_1 = Tex('$\\\\dot{R}_O$', color=ORANGE)\n        grow_rate_relation_1.shift(RIGHT * 3 + UP * 3)\n        grow_rate_relation_2 = Tex('$>$')\n        grow_rate_relation_2.next_to(grow_rate_relation_1, RIGHT)\n        grow_rate_relation_3 = Tex('$\\\\dot{R}_G$', color=GREEN)\n        grow_rate_relation_3.next_to(grow_rate_relation_2, RIGHT)\n        grow_rate_relation = VGroup(grow_rate_relation_1, grow_rate_relation_2, grow_rate_relation_3)\n        self.add(slide_title, page_9)\n        self.wait()\n        self.play(Create(axes))\n        self.play(Write(VGroup(x_label, y_label)))\n        self.wait()\n        self.play(FadeIn(point_of_interest), FadeIn(inverted_time_cone_green_poi))\n        self.wait()\n        self.play(FadeIn(inverted_time_cone_orange_poi))\n        self.wait()\n        self.play(point_of_interest_x_tracker.animate.set_value(axes.c2p(0, 2.5)[0]), run_time=2)\n        self.wait()\n        self.play(Write(grow_rate_relation))\n        self.wait()\n        self.play(FadeOut(grow_rate_relation))\n        self.wait()\n        orange_x_tracker = ValueTracker(1)\n        orange_t_tracker = ValueTracker(0.3)\n        orange_t_cone_opacity_tracker = ValueTracker(1)\n        time_cone_orange_left = always_redraw(lambda: axes.plot(lambda x: -(1 / orange_phase_growth_rate_tracker.get_value()) * (x - orange_x_tracker.get_value()) + orange_t_tracker.get_value(), color=ORANGE, x_range=[axes.x_range[0], orange_x_tracker.get_value()]).set_stroke(opacity=orange_t_cone_opacity_tracker.get_value()))\n        time_cone_orange_right = always_redraw(lambda: axes.plot(lambda x: 1 / orange_phase_growth_rate_tracker.get_value() * (x - orange_x_tracker.get_value()) + orange_t_tracker.get_value(), color=ORANGE, x_range=[orange_x_tracker.get_value(), axes.x_range[1]]).set_stroke(opacity=orange_t_cone_opacity_tracker.get_value()))\n        time_cone_orange = VGroup(time_cone_orange_left, time_cone_orange_right)\n        orange_phase_allowed_region = always_redraw(lambda: Polygon(point_of_interest.get_center(), axes.c2p(axes.p2c(point_of_interest.get_center())[0] - axes.p2c(point_of_interest.get_center())[1] / (1 / orange_phase_growth_rate_tracker.get_value()), 0, 0), axes.c2p(axes.p2c(point_of_interest.get_center())[0] + axes.p2c(point_of_interest.get_center())[1] / (1 / orange_phase_growth_rate_tracker.get_value()), 0, 0)).set_stroke(color=ORANGE, opacity=0.4).set_fill(color=ORANGE, opacity=0.3))\n        self.play(FadeIn(time_cone_orange))\n        self.wait()\n        self.play(DrawBorderThenFill(orange_phase_allowed_region))\n        self.wait()\n        self.play(orange_x_tracker.animate(run_time=3).set_value(0.5), orange_t_tracker.animate(run_time=3).set_value(0.8))\n        self.wait()\n        self.play(orange_x_tracker.animate(run_time=3).set_value(-1.5), orange_t_tracker.animate(run_time=3).set_value(0.2))\n        self.wait()\n        self.play(FadeOut(orange_phase_allowed_region), orange_t_cone_opacity_tracker.animate.set_value(0))\n        self.wait()\n        green_x_tracker = ValueTracker(0)\n        green_t_tracker = ValueTracker(0.1)\n        time_cone_green_left = always_redraw(lambda: axes.plot(lambda x: -(1 / green_phase_growth_rate_tracker.get_value()) * (x - green_x_tracker.get_value()) + green_t_tracker.get_value(), color=GREEN, x_range=[axes.x_range[0], green_x_tracker.get_value()]))\n        time_cone_green_right = always_redraw(lambda: axes.plot(lambda x: 1 / green_phase_growth_rate_tracker.get_value() * (x - green_x_tracker.get_value()) + green_t_tracker.get_value(), color=GREEN, x_range=[green_x_tracker.get_value(), axes.x_range[1]]))\n        time_cone_green = VGroup(time_cone_green_left, time_cone_green_right)\n        green_phase_allowed_region = always_redraw(lambda: Polygon(point_of_interest.get_center(), axes.c2p(axes.p2c(point_of_interest.get_center())[0] - axes.p2c(point_of_interest.get_center())[1] / (1 / green_phase_growth_rate_tracker.get_value()), 0, 0), axes.c2p(axes.p2c(point_of_interest.get_center())[0] + axes.p2c(point_of_interest.get_center())[1] / (1 / green_phase_growth_rate_tracker.get_value()), 0, 0)).set_stroke(color=GREEN, opacity=0.4).set_fill(color=GREEN, opacity=0.3))\n        self.play(FadeIn(time_cone_green))\n        self.wait()\n        self.play(DrawBorderThenFill(green_phase_allowed_region))\n        self.wait()\n        self.play(green_t_tracker.animate(run_time=3).set_value(0.8))\n        self.wait()\n        self.play(green_x_tracker.animate(run_time=3).set_value(0.4), green_t_tracker.animate(run_time=3).set_value(0.3))\n        self.wait()\n        self.play(green_x_tracker.animate(run_time=3).set_value(-1), green_t_tracker.animate(run_time=3).set_value(0.5))\n        self.wait()\n        self.play(FadeOut(green_phase_allowed_region))\n        self.wait()\n        self.play(orange_x_tracker.animate(run_time=2).set_value(1.5), orange_t_tracker.animate(run_time=2).set_value(0.1), orange_t_cone_opacity_tracker.animate.set_value(1))\n        self.play(green_x_tracker.animate(run_time=2).set_value(-0.26), green_t_tracker.animate(run_time=2).set_value(0.4))\n        impingement_line = always_redraw(lambda: DashedLine(start=axes.c2p(orange_phase_growth_rate_tracker.get_value() * green_phase_growth_rate_tracker.get_value() / (orange_phase_growth_rate_tracker.get_value() + green_phase_growth_rate_tracker.get_value()) * (orange_x_tracker.get_value() / orange_phase_growth_rate_tracker.get_value() + green_x_tracker.get_value() / green_phase_growth_rate_tracker.get_value() + orange_t_tracker.get_value() - green_t_tracker.get_value()), (green_phase_growth_rate_tracker.get_value() * green_t_tracker.get_value() + orange_phase_growth_rate_tracker.get_value() * orange_t_tracker.get_value() - green_x_tracker.get_value() + orange_x_tracker.get_value()) / (orange_phase_growth_rate_tracker.get_value() + green_phase_growth_rate_tracker.get_value()), 0), end=axes.c2p(orange_phase_growth_rate_tracker.get_value() * green_phase_growth_rate_tracker.get_value() / (orange_phase_growth_rate_tracker.get_value() + green_phase_growth_rate_tracker.get_value()) * (orange_x_tracker.get_value() / orange_phase_growth_rate_tracker.get_value() + green_x_tracker.get_value() / green_phase_growth_rate_tracker.get_value() + orange_t_tracker.get_value() - green_t_tracker.get_value()), 5, 0)).set_stroke(color=ORANGE if orange_phase_growth_rate_tracker.get_value() * green_phase_growth_rate_tracker.get_value() / (orange_phase_growth_rate_tracker.get_value() + green_phase_growth_rate_tracker.get_value()) * (orange_x_tracker.get_value() / orange_phase_growth_rate_tracker.get_value() + green_x_tracker.get_value() / green_phase_growth_rate_tracker.get_value() + orange_t_tracker.get_value() - green_t_tracker.get_value()) <= 0 else GREEN))\n        self.add(impingement_line)\n        self.play(orange_x_tracker.animate(run_time=2).set_value(1.0))\n        self.wait()\n        self.play(orange_x_tracker.animate(run_time=2).set_value(1.2))\n        self.wait()\n        self.play(orange_t_tracker.animate(run_time=2).set_value(1.0))\n        self.wait()\n        orange_win_region_1 = always_redraw(lambda: Polygon(axes.c2p(0, -green_x_tracker.get_value() / green_phase_growth_rate_tracker.get_value() + green_t_tracker.get_value()), axes.c2p(green_x_tracker.get_value(), green_t_tracker.get_value()), axes.c2p(green_x_tracker.get_value() + green_t_tracker.get_value() * orange_phase_growth_rate_tracker.get_value(), 0), axes.c2p(orange_phase_growth_rate_tracker.get_value() * (green_t_tracker.get_value() - green_x_tracker.get_value() / green_phase_growth_rate_tracker.get_value()), 0)).set_stroke(color=BLUE, opacity=0.6).set_fill(color=BLUE, opacity=0.3))\n        self.play(FadeIn(orange_win_region_1))\n        self.wait()\n        self.play(orange_x_tracker.animate.set_value(orange_phase_growth_rate_tracker.get_value() * (green_t_tracker.get_value() - green_x_tracker.get_value() / green_phase_growth_rate_tracker.get_value()) - 0.1), orange_t_tracker.animate.set_value(0), run_time=2)\n        self.play(orange_x_tracker.animate.set_value(0), orange_t_tracker.animate.set_value(-green_x_tracker.get_value() / green_phase_growth_rate_tracker.get_value() + green_t_tracker.get_value() - 0.1), run_time=2)\n        self.wait()\n        self.play(orange_x_tracker.animate.set_value(0), orange_t_tracker.animate.set_value(0.5), run_time=2)\n        self.wait()\n        self.play(orange_x_tracker.animate.set_value(green_x_tracker.get_value() + green_t_tracker.get_value() * orange_phase_growth_rate_tracker.get_value()), orange_t_tracker.animate.set_value(0), run_time=2)\n        self.wait()\n        self.play(orange_x_tracker.animate.set_value(2), orange_t_tracker.animate.set_value(0.2), run_time=2)\n        self.wait()\n        self.play(FadeOut(impingement_line))\n        self.wait()\n        impingement_line.suspend_updating()\n        self.play(green_t_tracker.animate(run_time=2).set_value(0.1))\n        self.wait()\n        self.play(green_x_tracker.animate(run_time=2).set_value(-0.45), green_t_tracker.animate(run_time=2).set_value(0))\n        self.wait()\n        self.play(green_x_tracker.animate(run_time=2).set_value(0))\n        self.wait()\n        impingement_line.resume_updating()\n        self.add(impingement_line)\n        self.play(orange_x_tracker.animate(run_time=2).set_value(0.2))\n        self.wait()\n        self.play(FadeOut(impingement_line))\n        self.wait()\n        impingement_line.suspend_updating()\n        self.play(green_x_tracker.animate(run_time=2).set_value(-0.15), green_t_tracker.animate(run_time=2).set_value(0.7))\n        self.wait()\n        orange_win_region_2 = always_redraw(lambda: Polygon(axes.c2p(green_x_tracker.get_value(), green_t_tracker.get_value()), axes.c2p(green_x_tracker.get_value() - green_t_tracker.get_value() * orange_phase_growth_rate_tracker.get_value(), 0), axes.c2p(green_x_tracker.get_value() + green_t_tracker.get_value() * orange_phase_growth_rate_tracker.get_value(), 0)).set_stroke(color=BLUE, opacity=0.6).set_fill(color=BLUE, opacity=0.3))\n        self.play(DrawBorderThenFill(orange_win_region_2))\n        self.wait()\n        self.play(orange_x_tracker.animate(run_time=2).set_value(-0.4))\n        self.wait()\n        self.play(orange_t_tracker.animate(run_time=2).set_value(0))\n        self.wait()\n        self.play(FadeOut(time_cone_orange))\n        self.wait()\n        time_cone_orange.suspend_updating()\n        self.play(green_t_tracker.animate(run_time=2).set_value(1.35))\n        self.wait()\n        self.play(green_x_tracker.animate(run_time=2).set_value(-0.05), green_t_tracker.animate(run_time=2).set_value(0.05))\n        self.wait()\n        question_statement = Tex('Question: ', 'what is the fraction of the\\\\\\\\total nucleation volume where\\\\\\\\the orange phase can win?', font_size=30)\n        question_statement.to_corner(UR)\n        self.play(Write(question_statement))\n        self.wait()\n        self.play(FadeIn(orange_phase_allowed_region))\n        self.wait()\n        orange_phase_allowed_region_area_eqn_1 = Tex('$||\\\\Omega_N||_{\\\\text{1D}}$', ' $=$', ' $\\\\dot{R}$', '$t^2$')\n        orange_phase_allowed_region_area_eqn_1.shift(LEFT * 3)\n        orange_phase_allowed_region_area_eqn_2 = Tex('$||\\\\Omega_N||_{\\\\text{1D}}$', ' $=$', ' $\\\\dot{R}_O$', '$t^2$')\n        orange_phase_allowed_region_area_eqn_2.align_to(orange_phase_allowed_region_area_eqn_1, LEFT)\n        self.play(Write(orange_phase_allowed_region_area_eqn_1))\n        self.wait()\n        self.play(TransformMatchingTex(orange_phase_allowed_region_area_eqn_1, orange_phase_allowed_region_area_eqn_2))\n        self.wait()\n        fraction = Tex('$\\\\iint$', '$($', '$||\\\\Omega||_{\\\\text{orange wins}}$', '$/$', '$||\\\\Omega_N||_{\\\\text{tot}}$', '$)$', '$dx_Gdt_G$', font_size=40)\n        fraction.to_edge(RIGHT, buff=0.1)\n        fraction.shift(UP)\n        fraction_orange_wins_eqn = Tex('$||\\\\Omega||_O$', ' $=$ ', '$\\\\frac{1}{6}$', '$t^2$', '$($', '$5$', '$\\\\dot{R}_O$', ' $-$ ', '2', '$\\\\dot{R}_G$', '$)$')\n        fraction_orange_wins_eqn.next_to(fraction, DOWN)\n        self.play(ReplacementTransform(VGroup(orange_win_region_1, orange_win_region_2).copy(), VGroup(fraction.submobjects[2])))\n        self.wait()\n        self.play(ReplacementTransform(VGroup(orange_phase_allowed_region).copy(), VGroup(fraction.submobjects[4])))\n        self.wait()\n        self.play(Write(fraction.submobjects[1]), Write(fraction.submobjects[3]), Write(fraction.submobjects[5]))\n        self.wait()\n        self.play(Write(fraction.submobjects[0]), Write(fraction.submobjects[-1]))\n        self.wait()\n        self.play(ShowCreationThenFadeOut(green_phase_allowed_region))\n        self.wait()\n        self.play(Write(fraction_orange_wins_eqn))\n        self.wait()\n        self.play(FadeOut(fraction))\n        self.wait()\n        self.play(fraction_orange_wins_eqn.animate.move_to(question_statement.get_bottom(), UP).shift(DOWN * 0.1))\n        self.wait()\n        fraction_green_wins_eqn = Tex('$||\\\\Omega||_G$', ' $=$ ', '$\\\\frac{1}{6}$', '$t^2$', '$($', '$\\\\dot{R}_O$', ' $+$ ', '2', '$\\\\dot{R}_G$', '$)$')\n        fraction_green_wins_eqn.next_to(fraction_orange_wins_eqn, DOWN).shift(DOWN * 0.1)\n        self.play(Write(fraction_green_wins_eqn))\n        self.wait()\n        fraction_combined = Tex('$||\\\\Omega||_O$', ' $+$ ', '$||\\\\Omega||_G$', ' $=$ ', '$\\\\dot{R}_O$', '$t^2$')\n        fraction_combined.next_to(fraction_green_wins_eqn, DOWN).shift(DOWN * 0.1)\n        self.play(TransformMatchingShapes(VGroup(fraction_orange_wins_eqn, fraction_green_wins_eqn).copy(), VGroup(fraction_combined)))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Fade in a dot, grow a line from its center, remove the dot, and then move the line upwards."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass TestSlide2(Scene):\n\n    def construct(self):\n        dot = Dot(radius=0.06)\n        line = Line()\n        line.set_stroke(width=dot.radius * DOT_TO_LINE)\n        self.play(FadeIn(dot), run_time=2)\n        self.wait(1)\n        self.play(GrowFromPoint(line, point=dot), run_time=2, rate_func=linear)\n        self.remove(dot)\n        self.wait(1)\n        self.play(line.animate.shift(UP * 2), run_time=2)\n        self.wait(0.5)"}]}
{"messages": [{"role": "user", "content": "Create and label an x and y axis for a Manim scene."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass TestAxes(Scene):\n\n    def construct(self):\n        ax = Axes(x_range=[0, 15], y_range=[0, 10], x_length=8, y_length=6)\n        x_ax = ax.get_x_axis()\n        x_ax_label = ax.get_x_axis_label(Tex('$x$'))\n        y_ax = ax.get_y_axis()\n        y_ax_label = ax.get_y_axis_label(Tex('$t$'))\n        self.play(Create(x_ax), run_time=2)\n        self.play(Write(x_ax_label), run_time=2)\n        self.wait()\n        self.play(Create(y_ax), run_time=2)\n        self.play(Write(y_ax_label), run_time=2)\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Color specific words in a title with different colors."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass TestTitle(Scene):\n\n    def construct(self):\n        title = Text('Using the Time Cone Method to\\nModel Competitive Phase Transformation', font_size=50)\n        self.add(title)\n        self.play(title.animate.set_color_by_t2c(t2c={'[8:22]': BLUE, '[29:-1]': RED}))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a rectangle transforming into a circle."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass TestLineToCircle(Scene):\n\n    def construct(self):\n        circle = Circle()\n        line = Rectangle(height=0.1, width=circle.radius * 2)\n        line.set_fill(color=WHITE, opacity=1)\n        self.play(ReplacementTransform(line, circle))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create a 3D scene with axes and a circle, then animate a continuous camera rotation around the scene."}, {"role": "assistant", "content": "import numpy as np\nfrom manim import *\nfrom manim_physics import *\nfrom manim.utils.rate_functions import unit_interval\n\nclass ThreeDCameraIllusionRotation(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes()\n        circle = Circle()\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(circle, axes)\n        self.begin_3dillusion_camera_rotation(rate=2)\n        self.wait(PI / 2)\n        self.stop_3dillusion_camera_rotation()"}]}
{"messages": [{"role": "user", "content": "Animate the creation of a hypocycloid by showing a smaller circle rolling inside a larger circle and tracing the path of a point on the smaller circle."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Hypocy(Scene):\n\n    def construct(self):\n        big_circle = 3\n        small_circle = -big_circle / 4\n        self.Hyp(big_circle, small_circle)\n\n    def Hyp(self, r1, r2):\n        c1 = Circle(radius=r1, color=BLUE)\n        c2 = Circle(radius=r2, color=GREEN).rotate(PI)\n        c2.next_to(c1, LEFT, buff=0)\n        c2.start = c2.copy()\n        c2.flip(about_point=c2.point_from_proportion(0))\n        dot = Dot(c2.point_from_proportion(0), color=YELLOW)\n        line = Line(c2.get_center(), dot.get_center()).set_stroke(PINK, 2.5)\n        trace = VMobject(color=RED)\n        trace.set_points_as_corners([dot.get_center(), dot.get_center() + UP * 0.0001])\n        trace_group = VGroup(line, dot, trace)\n        self.add(line, c1, c2, dot)\n\n        def update_group(group):\n            l, mob, previus_trace = group\n            mob.move_to(c2.point_from_proportion(0))\n            old_trace = trace.copy()\n            old_trace.append_vectorized_mobject(Line(old_trace.points[-1], dot.get_center()))\n            old_trace.make_smooth()\n            l.put_start_and_end_on(c2.get_center(), dot.get_center())\n            trace.become(old_trace)\n\n        def update_c2(c, alpha):\n            c.become(c.start)\n            c.flip(about_point=c2.point_from_proportion(0))\n            c.rotate(2 * PI * alpha, about_point=c1.get_center())\n            c.rotate(2 * PI * (r1 / r2) * alpha, about_point=c.get_center())\n        trace_group.add_updater(update_group)\n        self.add(trace_group)\n        self.play(UpdateFromAlphaFunc(c2, update_c2, rate_func=linear, run_time=5))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the polar relationship r = theta by plotting points, coloring primes red and non-primes blue, and then zooming out to encompass the entire plot."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport sympy as sp\nimport math as m\n\nclass Number(MovingCameraScene):\n\n    def construct(self):\n        title = TextMobject('Plot of numbers (r,$\\\\theta$) when r = $\\\\theta$')\n        title.set_color(YELLOW)\n        self.play(Write(title))\n        Note = TextMobject('Red ', '= Prime Numbers ;', 'Blue ', '= Non-Primes')\n        Note.next_to(title, DOWN)\n        Note.set_color(GREEN)\n        Note[0].set_color(RED)\n        Note[2].set_color(BLUE)\n        self.play(Write(Note))\n        self.play(FadeOut(title), FadeOut(Note))\n        q = Square()\n        factor = n * np.sin(n) / 1.5 - 20\n        q.scale(factor)\n        for i in range(1, n + 1):\n            x = i * np.cos(i)\n            y = i * np.sin(i)\n            point = Dot()\n            if i <= 25:\n                fact = 11\n            else:\n                fact = np.sqrt(i / 1.2)\n                point.scale(fact)\n            if sp.isprime(i) == True:\n                point.set_color(RED)\n            else:\n                point.set_color(BLUE)\n            point.move_to(np.array([x, y, 0]))\n            self.add(point)\n        self.play(self.camera_frame.set_height, q.get_width(), run_time=10)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a title, then introductory text, followed by a \"previous video scene\" marker, and finally a matrix formula with its components."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Introduction(Scene):\n\n    def construct(self):\n        Titl = Title('Fibonacci Matrix and Torus')\n        Titl.to_edge(UP)\n        Titl.set_color(RED)\n        Titl.scale(0.8)\n        self.play(Write(Titl), run_time=2)\n        Text = TextMobject('In the previous Video on the same topic you see We have told\\\\\\\\about how to visualize matrix as a Linear-Transformation(specially for Fibonacci Matrix).')\n        Text.set_color(BLUE)\n        Text.scale(0.7)\n        Text.next_to(Titl, DOWN)\n        self.play(Write(Text), run_time=3)\n        self.wait(2)\n        pp = TextMobject('previous Video Scene')\n        pp.set_color(YELLOW)\n        pp.scale(0.7)\n        pp.to_edge(DOWN)\n        self.play(Write(pp), run_time=2)\n        self.wait(15)\n        self.play(FadeOut(pp), FadeOut(Text), run_time=3)\n        self.wait(2)\n        formula = TexMobject('\\n            \\\\Gamma= \\n            \\\\left[\\n                \\\\begin{array}{cc}\\n                    2 & 1 \\\\\\\\\\n                    1 & 1\\n                \\\\end{array}\\n            \\\\right]')\n        formula.set_color(YELLOW)\n        formula.next_to(Titl, DOWN)\n        self.play(Write(formula), run_time=3)\n        self.wait(7)\n        formula1 = TexMobject('\\n            \\\\Gamma(0) = ', '\\\\left[\\n                \\\\begin{array}{c}\\n                    2 \\\\\\\\\\n                    1\\n                \\\\end{array}\\n            \\\\right]', ';', '\\\\Gamma(1) = ', '\\\\left[\\n                \\\\begin{array}{c}\\n                    1 \\\\\\\\\\n                    1\\n                \\\\end{array}\\n            \\\\right]')\n        color = [YELLOW, RED, WHITE, YELLOW, GREEN]\n        for i in range(5):\n            formula1[i].set_color(color[i])\n        formula1.next_to(formula, DOWN)\n        self.play(Transform(formula.copy(), formula1), run_time=2)\n        self.wait(10)\n        Where = TextMobject('Here $1^{st}$ one describes where x axis unit vector goes and \\\\\\\\ $2^{nd}$ one describes where y axis unit vector goes.')\n        Where.scale(0.8)\n        Where.shift(2 * DOWN)\n        Where.set_color(BLUE)\n        self.play(Write(Where), run_time=2)\n        self.wait(10)\n        self.play(*[FadeOut(mob) for mob in self.mobjects], run_time=2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display a red, scaled SVG object named 'abu'."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass test(Scene):\n\n    def construct(self):\n        hammer = SVGMobject('abu')\n        hammer.set_color(RED)\n        hammer.scale(2)\n        self.add(hammer)"}]}
{"messages": [{"role": "user", "content": "Animate the logistic map with cobweb plots and a parametric function."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass logistic_map(MovingCameraScene):\n\n    def func(self, t):\n        return np.array([t, logistic(r, t), 0])\n\n    def construct(self):\n        s = Square(color=YELLOW)\n        s.scale(0.5)\n        s.move_to(np.array([0.5, 0.5, 0]))\n        T = Title('Logistic Map')\n        T.set_color(GREEN)\n        self.play(Write(T))\n        self.wait(2)\n        self.play(FadeOut(T))\n        x_axis = Line(np.array([-3, 0.1, 0]), np.array([3, 0.1, 0]))\n        x_axis.set_color(GREEN)\n        x_axis.set_stroke(None, 3.1)\n        self.play(self.camera_frame.set_width, s.get_width() * 1.5, self.camera_frame.move_to, s)\n        self.camera_frame.shift(0.015 * UP)\n        func = ParametricFunction(self.func, t_min=0, t_max=1, fill_opacity=0)\n        func.set_color(RED)\n        self.play(Write(x_axis))\n        self.play(Write(func))\n        X = []\n        Y = []\n        x0 = 0.1\n        for i in range(60):\n            x = x0\n            y = logistic(r, x0)\n            lin = Line(np.array([x, x, 0]), np.array([x, y, 0]), color=BLUE)\n            lin1 = Line(np.array([x, y, 0]), np.array([y, y, 0]), color=BLUE)\n            lin.set_stroke(None, 1.8)\n            lin1.set_stroke(None, 1.8)\n            D = Dot(radius=0.006, color=YELLOW)\n            D.move_to(np.array([x, y, 0]))\n            self.play(Write(lin), run_time=0.2)\n            self.play(Write(lin1), run_time=0.2)\n            self.add(D)\n            X.append(x)\n            Y.append(y)\n            x0 = y"}]}
{"messages": [{"role": "user", "content": "Generate a bifurcation diagram for the logistic map, showing the convergence of values as the parameter r increases."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass bifurcation(MovingCameraScene):\n\n    def construct(self):\n        iterations = 200000\n        r = np.linspace(2.5, 4.0, 200000)\n        N = NumberPlane()\n        self.add(N)\n        s = Polygon(np.array([2.5, 0, 0]), np.array([4, 0, 0]), np.array([4, 1, 0]), np.array([2.5, 1, 0]))\n        T = Title('Bifurcation Diagram')\n        T.set_color(GREEN)\n        self.play(Write(T))\n        self.wait(2)\n        self.play(FadeOut(T))\n        self.play(self.camera_frame.set_width, s.get_width() * 1.5, self.camera_frame.move_to, s)\n        self.wait()\n        x = 1e-05\n        X = []\n        dot = []\n        for i in range(iterations):\n            x = logistic(r[i], x)\n            X.append(x)\n            c = Dot(radius=0.00055, color=YELLOW)\n            c.move_to(np.array([r[i], x, 0]))\n            dot.append(c)\n        q = VGroup(*[dot[i] for i in range(len(dot))])\n        self.add(q)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Animate the Lorenz attractor in 3D, following its trajectory with a moving particle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.integrate import odeint\n\nclass Butterflyf(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes(number_line_config={'color': DARK_BROWN, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        self.play(FadeIn(axes))\n        self.set_camera_orientation(phi=80 * DEGREES, theta=35 * DEGREES, distance=17)\n        self.sol_plot(28, 10, 8 / 3, 2.0, 10.0, 1.0, YELLOW_C, RED_D, RED_C, BLUE_D)\n\n    def sol_plot(self, rho, sigma, beta, inix, iniy, iniz, colpart, col1, col2, col3):\n\n        def f(state, t):\n            x, y, z = state\n            return (sigma * (y - x), x * (rho - z) - y, x * y - beta * z)\n        state0 = [inix, iniy, iniz]\n        t = np.arange(0.0, 60.0, 0.01)\n        states = odeint(f, state0, t)\n        p = VMobject()\n        p.set_points_as_corners([*[[a, b, c] for a, b, c in zip(states[:, 0], states[:, 1], states[:, 2])]])\n        p.make_smooth().set_stroke(None, 2)\n        new_func = CurvesAsSubmobjects(p)\n        new_func.set_color_by_gradient(col1, col2, col3, TEAL_C, MAROON_B)\n        particle = ParametricSurface(lambda u, v: np.array([0.5 * np.cos(u) * np.cos(v), 0.5 * np.sin(u) * np.cos(v), 0.5 * np.sin(v)]), u_max=2 * PI, u_min=0, v_max=2 * PI, v_min=0, checkerboard_colors=[colpart, colpart], resolution=(10, 20))\n        group = VGroup(particle, p, new_func).scale(0.1).move_to(ORIGIN)\n        particle.add_updater(lambda m: m.move_to(p.get_end()))\n        p.fade(1)\n        self.add(particle)\n        v = VGroup(particle, p, new_func)\n        v.scale(1.7)\n        self.begin_ambient_camera_rotation(0.2)\n        self.play(ShowCreation(new_func), ShowCreation(p), rate_func=linear, run_time=20)"}]}
{"messages": [{"role": "user", "content": "Animate the trajectory of a double pendulum with the given initial conditions and physical parameters."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom numpy import sin, cos\nfrom scipy.integrate import odeint\n\nclass DouPen(Scene):\n\n    def construct(self):\n        Tit = Title('Double-Pendulum')\n        Tit.to_edge(UP)\n        Tit.set_color(COBALT)\n        Tit.scale(0.9)\n        self.play(Write(Tit))\n        self.Double(100, 90, 5, 0, 9.8, RED, BLUE, GREEN, YELLOW)\n        self.wait()\n\n    def Double(self, th1, th2, w1, w2, G, xcol1, xcol1l, xcol2, xcol2l):\n        L1 = 2.0\n        L2 = 2.0\n        M1 = 40\n        M2 = 40\n\n        def derivs(state, t):\n            dydx = np.zeros_like(state)\n            dydx[0] = state[1]\n            del_ = state[2] - state[0]\n            den1 = (M1 + M2) * L1 - M2 * L1 * cos(del_) * cos(del_)\n            dydx[1] = (M2 * L1 * state[1] * state[1] * sin(del_) * cos(del_) + M2 * G * sin(state[2]) * cos(del_) + M2 * L2 * state[3] * state[3] * sin(del_) - (M1 + M2) * G * sin(state[0])) / den1\n            dydx[2] = state[3]\n            den2 = L2 / L1 * den1\n            dydx[3] = (-M2 * L2 * state[3] * state[3] * sin(del_) * cos(del_) + (M1 + M2) * G * sin(state[0]) * cos(del_) - (M1 + M2) * L1 * state[1] * state[1] * sin(del_) - (M1 + M2) * G * sin(state[2])) / den2\n            return dydx\n        dt = 0.05\n        t = np.arange(0.0, 60, dt)\n        state = np.radians([th1, w1, th2, w2])\n        y = odeint(derivs, state, t)\n        p1 = VMobject()\n        p1.set_points_as_corners([*[[L1 * sin(a), -L1 * cos(a), 0] for a in y[:, 0]]])\n        p1.make_smooth().set_stroke(None, 2)\n        p2 = VMobject()\n        p2.set_points_as_corners([*[[L2 * sin(b) + L1 * sin(a), -L2 * cos(b) - L1 * cos(a), 0] for a, b in zip(y[:, 0], y[:, 2])]])\n        p2.make_smooth().set_stroke(None, 2)\n        new_func1 = CurvesAsSubmobjects(p1)\n        new_func1.set_color_by_gradient(BLACK)\n        new_func1.set_opacity(0)\n        new_func2 = CurvesAsSubmobjects(p2)\n        new_func2.set_color_by_gradient(RED)\n        center = np.array([0, -0.3, 0])\n        zero = Dot(color=PURPLE)\n        zero.move_to(center)\n        self.add(zero)\n        Blob1 = Dot(color=xcol1)\n        Blob1.move_to(p1.get_end())\n        Blob1.scale(1.2)\n        Blob1.add_updater(lambda m: m.move_to(p1.get_end()))\n        line1 = Line(center, Blob1)\n        line1.set_color(xcol1l)\n        self.play(Write(line1))\n        line1.add_updater(lambda m: m.become(Line(zero.get_center(), Blob1.get_center(), color=xcol1l)))\n        self.add(Blob1, line1)\n        Blob2 = Dot(color=xcol2)\n        Blob2.scale(1.6)\n        Blob2.move_to(p2.get_end())\n        Blob2.add_updater(lambda m: m.move_to(p2.get_end()))\n        line2 = Line(Blob1, Blob2)\n        line2.set_color(xcol2l)\n        self.play(Write(line2))\n        line2.add_updater(lambda m: m.become(Line(Blob1.get_center(), Blob2.get_center(), color=xcol2l)))\n        self.add(Blob2, line2)\n        p1.fade(1)\n        p2.fade(1)\n        self.play(ShowCreation(new_func1), ShowCreation(p1), ShowCreation(new_func2), ShowCreation(p2), rate_func=linear, run_time=30)"}]}
{"messages": [{"role": "user", "content": "Generate a Sierpinski triangle using the chaos game algorithm."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport random\n\nclass triangle(Scene):\n\n    def construct(self):\n        tt = Title('Sierpinski Triangle')\n        tt.set_color(GREEN)\n        self.play(Write(tt))\n        a = Triangle()\n        a.scale(4)\n        self.play(Write(a))\n        self.play(FadeOut(tt))\n        p1, p2, p3 = (a.get_points()[0], a.get_points()[3], a.get_points()[7])\n        tit = [p1, p2, p3]\n        points = [self.generate_point_in_polygon(p1, p2, p3) for i in range(1)]\n        r = Dot(color=RED)\n        r.scale(0.2)\n        r.move_to(np.array(points[0]))\n        self.play(Write(r))\n        self.wait()\n        y = np.array(points[0])\n        X = GREEN\n        for i in range(1000):\n            ran = random.choice(tit)\n            if np.array_equal(ran, tit[0]):\n                X = RED\n            elif np.array_equal(ran, tit[1]):\n                X = BLUE\n            else:\n                X = YELLOW\n            q = Dot(color=X)\n            q.scale(0.15)\n            new = np.array([(y[0] + ran[0]) / 2, (y[1] + ran[1]) / 2, 0])\n            q.move_to(new)\n            self.play(Write(q), run_time=0.002)\n            y = new\n\n    def generate_point_in_polygon(self, p1, p2, p3, **kwargs):\n        s, t = sorted([random.random(), random.random()])\n        return (s * p1[0] + (t - s) * p2[0] + (1 - t) * p3[0], s * p1[1] + (t - s) * p2[1] + (1 - t) * p3[1], 0)"}]}
{"messages": [{"role": "user", "content": "Animate a large green square from which many colored dots are generated by repeatedly moving halfway towards a randomly chosen vertex of the square."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport random\n\nclass square(Scene):\n\n    def construct(self):\n        a = Rectangle()\n        a.set_color(GREEN)\n        a.scale(2)\n        self.add(a)\n        p1, p2, p3, p4 = (a.get_points()[0], a.get_points()[4], a.get_points()[8], a.get_points()[12])\n        tit = [p1, p2, p3]\n        points = [self.generate_point_in_polygon(p1, p2, p3, p4) for i in range(1)]\n        r = Dot(color=RED)\n        r.scale(0.2)\n        r.move_to(np.array(points))\n        self.add(r)\n        tti = np.array(points[0])\n        b = p4\n        for i in range(9000):\n            y = len(tit) - 1\n            w = random.randint(0, y)\n            c = tit[w]\n            if np.array_equal(c, tit[0]):\n                X = RED\n            elif np.array_equal(c, tit[1]):\n                X = BLUE\n            elif np.array_equal(c, tit[2]):\n                X = LIGHT\n            else:\n                X = YELLOW\n            g = Dot(color=X)\n            g.scale(0.18)\n            new = np.array([(tti[0] + c[0]) / 2, (tti[1] + c[1]) / 2, 0])\n            g.move_to(new)\n            self.play(Write(g), run_time=0.001)\n            tit.pop(w)\n            tit.append(b)\n            b = c\n            tti = new\n\n    def generate_point_in_polygon(self, p1, p2, p3, p4, **kwargs):\n        s, t, q = sorted([random.random(), random.random(), random.random()])\n        return (s * p1[0] + (t - s) * p2[0] + (q - t) * p3[0] + (1 - q) * p4[0], s * p1[1] + (t - s) * p2[1] + (q - t) * p3[1] + (1 - q) * p4[1], 0)"}]}
{"messages": [{"role": "user", "content": "Generate a Sierpinski gasket by repeatedly selecting random vertices of a polygon and marking the midpoint between the current point and the selected vertex."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport random\n\nclass N_gon(Scene):\n\n    def construct(self):\n        self.generate_sierpinski(5, 0.17, 10000, 0.001)\n\n    def generate_sierpinski(self, n, scale_dot, Points_number, time, **kwargs):\n        a = Circle().set_height(FRAME_HEIGHT)\n        a.set_color(GREEN)\n        a.rotate(90 * DEGREES)\n        p = []\n        for i in range(n):\n            p.append(a.point_from_proportion(i / n))\n        Aust = Polygon(*[p[i] for i in range(n)])\n        Aust.set_color(GREEN)\n        self.play(Write(Aust))\n        points = [self.generate_points_in_polygon(p) for i in range(1)]\n        r = Dot(color=YELLOW_C)\n        r.scale(0.2)\n        r.move_to(np.array(points))\n        self.play(Write(r))\n        tti = np.array(points[0])\n        b = p[n - 1]\n        p.pop(n - 1)\n        for i in range(Points_number + 1):\n            y = len(p) - 1\n            w = random.randint(0, y)\n            c = p[w]\n            g = Dot(color=RED_C)\n            g.scale(scale_dot)\n            new = np.array([(tti[0] + c[0]) / 2, (tti[1] + c[1]) / 2, 0])\n            g.move_to(new)\n            self.play(Write(g), run_time=time)\n            p.pop(w)\n            p.append(b)\n            b = c\n            tti = new\n\n    def generate_points_in_polygon(self, p, **kwargs):\n        s = []\n        for i in range(len(p) - 2):\n            s.append(random.random())\n        s.insert(len(s), 1)\n        so = 0\n        sumx = 0\n        sumy = 0\n        for i in range(len(p) - 1):\n            sumx = (s[i] - so) * p[i][0]\n            so = s[i]\n        for i in range(len(p) - 1):\n            sumy = (s[i] - so) * p[i][1]\n            so = s[i]\n        return (sumx, sumy, 0)"}]}
{"messages": [{"role": "user", "content": "Render a 3D knot curve with a gradient of colors, accompanied by a small particle that follows its path, while the camera rotates."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport random\n\nclass knot(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes(number_line_config={'color': GREEN, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        self.play(FadeIn(axes))\n        self.set_camera_orientation(phi=80 * DEGREES, theta=35 * DEGREES)\n        particle = ParametricSurface(lambda u, v: np.array([0.06 * np.cos(u) * np.cos(v), 0.06 * np.sin(u) * np.cos(v), 0.06 * np.sin(v)]), u_max=2 * PI, u_min=0, v_max=4 * PI, v_min=0, checkerboard_colors=[YELLOW_C, YELLOW_D], resolution=(20, 30))\n\n        def func(t):\n            return np.array([(2 + np.cos(3 * t)) * np.cos(2 * t), (2 + np.cos(3 * t)) * np.sin(2 * t), np.sin(3 * t)])\n        func = ParametricFunction(func, t_max=2 * PI, fill_opacity=0)\n        new_func = CurvesAsSubmobjects(func)\n        new_func.set_color_by_gradient(BLUE_D, BLUE_C, RED_C, RED_D, RED_C, BLUE_C)\n        particle.add_updater(lambda m: m.move_to(func.get_end()))\n        func.fade(1)\n        particle.move_to(np.array([3, 0, 0]))\n        self.add(particle)\n        self.begin_ambient_camera_rotation(0.2)\n        self.play(ShowCreation(new_func), ShowCreation(func), rate_func=linear, run_time=7)\n        self.play(FadeOut(particle))\n        self.set_camera_orientation(phi=0 * DEGREES)\n        self.wait(4)"}]}
{"messages": [{"role": "user", "content": "Draw a green number plane and animate a parametric curve with a color gradient, showing its path with a moving dot and a changing radius arrow."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport random\n\nclass draw(Scene):\n\n    def construct(self):\n        q = NumberPlane()\n        q.set_color(GREEN)\n        q.set_opacity(0.5)\n        self.play(Write(q), run_time=1)\n        dot = Dot(color=YELLOW_C)\n\n        def fun(t):\n            return np.array([(2 + np.cos(3 * t)) * np.cos(2 * t), (2 + np.cos(3 * t)) * np.sin(2 * t), 0])\n        fun = ParametricFunction(fun, t_max=2 * PI, fill_opacity=0)\n        new_fun = CurvesAsSubmobjects(fun)\n        new_fun.set_color_by_gradient(BLUE_D, BLUE_C, RED_C, RED_D, RED_C, BLUE_C)\n        dot.add_updater(lambda m: m.move_to(fun.get_end()))\n        fun.fade(1)\n        origin = Dot(color=MY_PINK)\n        origin.move_to(np.array([0, 0, 0]))\n        origin.scale(0.5)\n        self.add(origin)\n        dot.move_to(np.array([3, 0, 0]))\n        dot.scale(0.5)\n        self.add(dot)\n        radius = Arrow(origin, dot, buff=0, color=MY_PINK)\n        self.add(radius)\n        radius.add_updater(lambda m: m.become(Arrow(origin.get_center(), dot.get_center(), buff=0, color=MY_PINK)))\n        self.add(radius)\n        self.play(ShowCreation(new_fun), ShowCreation(fun), rate_func=linear, run_time=7)\n        self.play(FadeOut(dot))\n        self.wait(4)"}]}
{"messages": [{"role": "user", "content": "Animate the Aizawa attractor with a trailing particle and a rotating camera."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom scipy.integrate import odeint\n\nclass Aizawaa(Scene):\n\n    def construct(self):\n        a = self.sol(0.1, 0, 0, YELLOW_C, RED_D, RED_C, BLUE_D)\n        self.wait(3)\n\n    def sol_plot(self, inix, iniy, iniz, colpart, col1, col2, col3, a=0.95, b=0.7, c=0.6, d=3.5, e=0.25, g=0.1):\n\n        def f(state, t):\n            x, y, z = state\n            return ((z - b) * x - d * y, d * x + (z - b) * y, c + a * z - pow(z, 3) / 3 - (x * x + y * y) * (1 + e * z) + g * z * pow(x, 3))\n        state0 = [inix, iniy, iniz]\n        t = np.arange(0.0, 60.0, 0.01)\n        states = odeint(f, state0, t)\n        p = VMobject()\n        p.set_points_as_corners([*[[a, b, c] for a, b, c in zip(states[:, 0], states[:, 1], states[:, 2])]]).set_shade_in_3d(True)\n        p.make_smooth().set_stroke(None, 2)\n        new_func = CurvesAsSubmobjects(p).set_shade_in_3d(True)\n        new_func.set_color_by_gradient(col1, col2, col3, GREEN, TEAL_C, MAROON_B)\n        r = 0.05\n        particle = ParametricSurface(lambda u, v: np.array([r * np.cos(u) * np.cos(v), r * np.sin(u) * np.cos(v), r * np.sin(v)]), u_max=2 * PI, u_min=0, v_max=2 * PI, v_min=0, checkerboard_colors=[colpart, colpart], resolution=(10, 20)).set_shade_in_3d(True)\n        group = VGroup(particle, p, new_func).scale(0.1).move_to(ORIGIN)\n        particle.add_updater(lambda m: m.move_to(p.get_end()))\n        p.fade(1)\n        self.add(particle)\n        v = VGroup(particle, p, new_func)\n        v.scale(20)\n        self.begin_ambient_camera_rotation(0.2)\n        self.play(ShowCreation(new_func), ShowCreation(p), rate_func=linear, run_time=15)\n        self.move_camera(phi=0 * DEGREES, run_time=4)\n\n    def sol(self, inix, iniy, iniz, colpart, col1, col2, col3, a=0.95, b=0.7, c=0.6, d=3.5, e=0.25, g=0.1):\n\n        def f(state, t):\n            x, y, z = state\n            return ((z - b) * x - d * y, d * x + (z - b) * y, c + a * z - pow(z, 3) / 3 - (x * x + y * y) * (1 + e * z) + g * z * pow(x, 3))\n        state0 = [inix, iniy, iniz]\n        t = np.arange(0.0, 60.0, 0.01)\n        states = odeint(f, state0, t)\n        p = VMobject()\n        p.set_points_as_corners([*[[a, b, 0] for a, b, c in zip(states[:, 0], states[:, 1], states[:, 2])]])\n        p.make_smooth().set_stroke(None, 2)\n        new_func = CurvesAsSubmobjects(p)\n        new_func.set_color_by_gradient(col1, col2, col3, GREEN, TEAL_C, MAROON_B)\n        group = VGroup(p, new_func).scale(0.1).move_to(ORIGIN)\n        vectpr = Arrow(ORIGIN, p.get_end(), color=YELLOW)\n        vectpr.add_updater(lambda m: m.become(Arrow(ORIGIN, p.get_end(), color=YELLOW)))\n        p.fade(1)\n        self.add(vectpr)\n        v = VGroup(vectpr, p, new_func)\n        v.scale(20)\n        self.play(ShowCreation(new_func), ShowCreation(p), rate_func=linear, run_time=15)"}]}
{"messages": [{"role": "user", "content": "Visualize Minkowski's inequality for p=2 by drawing a geometric proof that involves triangles and distance measurements."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Minkowsli2(Scene):\n\n    def construct(self):\n        Text = TextMobject('If $a_1,a_2,..,a_n$ and $b_1,b_2,..,b_n$ are positive Integers,Then')\n        Text.set_color(ORANGE)\n        Tex = TexMobject('\\\\sqrt{(\\\\sum_{i=1}^{n}a_i)^2+(\\\\sum_{i=1}^{n}b_i)^2}\\\\leq\\\\sum_{i=1}^{n}\\\\sqrt{a_i^2+b_i^2}')\n        Tex.set_color(YELLOW)\n        plane = NumberPlane()\n        Tit = Title(\"Polygonal Path Inequality(Minkowsli's Inequality For p=2)\")\n        Tit.set_color(RED)\n        self.play(Write(Tit))\n        Text.next_to(Tit, DOWN)\n        self.play(Write(Text))\n        Tex.next_to(Text, DOWN)\n        self.play(Write(Tex))\n        self.wait()\n        self.play(FadeOut(Text), FadeOut(Tex))\n        Fist = TextMobject(\"Let's First see it's 2 variable form's Proof.\")\n        Fist.next_to(Tit, DOWN)\n        Fist.set_color(GREEN)\n        self.play(FadeIn(Fist))\n        self.play(FadeOut(Fist))\n        p1 = np.array([-4, -2, 0])\n        p2 = np.array([2, -2, 0])\n        p3 = np.array([2, 2, 0])\n        Triangle = Polygon(p1, p2, p3)\n        Triangle.set_color(PURPLE)\n        self.play(Write(Triangle), run_time=2.5)\n        np1 = np.array([0, -2, 0])\n        np3 = np.array([2, -1, 0])\n        np2 = np.array([2, -2, 0])\n        np4 = np.array([0, -1, 0])\n        rec1 = DashedLine(np1, np2)\n        rec2 = DashedLine(np2, np3)\n        rec3 = DashedLine(np3, np4)\n        rec4 = DashedLine(np4, np1)\n        rec = VGroup(rec1, rec2, rec3, rec4)\n        rec.set_color(BLUE)\n        self.play(Write(rec), run_time=2)\n        self.wait(2)\n        measure_line1 = Line(np2, np1)\n        measure1 = MeasureDistance(measure_line1).add_tips()\n        measure_tex1 = measure1.get_tex('y')\n        measure_tex1.set_color(GREEN)\n        measure_line2 = Line(np3, np2)\n        measure2 = MeasureDistance(measure_line2).add_tips()\n        measure_tex2 = measure2.get_tex('u')\n        measure_tex2.set_color(GREEN)\n        self.play(Write(measure1), Write(measure_tex1), Write(measure2), Write(measure_tex2))\n        self.wait(1)\n        measure_line3 = Line(np1, p1)\n        measure3 = MeasureDistance(measure_line3).add_tips()\n        measure_tex3 = measure3.get_tex('x')\n        measure_tex3.set_color(GREEN)\n        measure_line4 = Line(p3, np3)\n        measure4 = MeasureDistance(measure_line4).add_tips()\n        measure_tex4 = measure4.get_tex('v')\n        measure_tex4.set_color(GREEN)\n        self.play(Write(measure3), Write(measure_tex3), Write(measure4), Write(measure_tex4))\n        self.wait(1.5)\n        point = Dot()\n        point.scale(0.85)\n        point.move_to(np4)\n        point.set_color(GREEN)\n        self.play(FadeIn(point))\n        Triangle1 = Polygon(np1, np4, p1)\n        Triangle1.set_color(YELLOW)\n        Triangle1.set_stroke(None, 1.5)\n        Triangle2 = Polygon(np4, np3, p3)\n        Triangle2.set_color(ORANGE)\n        Triangle2.set_stroke(None, 1.5)\n        Linee1 = Line(p1, np4)\n        Linee1.set_color(YELLOW)\n        Linee2 = Line(np4, p3)\n        Linee2.set_color(ORANGE)\n        LL = VGroup(Linee2, Linee1)\n        self.play(Write(Linee1), Write(Linee2))\n        self.wait(1)\n        self.play(Write(Triangle1), Write(Triangle2))\n        self.play(FadeOut(Linee1), FadeOut(Linee2))\n        self.wait(2)\n        Names = TexMobject('Q', 'P', 'R')\n        Names.set_color(BLUE)\n        Names.scale(0.87)\n        Names[0].move_to(p1)\n        Names[0].shift(LEFT * 0.2)\n        Names[1].move_to(np4)\n        Names[1].shift(0.2 * DOWN + 0.2 * RIGHT)\n        Names[2].move_to(p3)\n        Names[2].shift(UP * 0.2)\n        self.play(Write(Names))\n        self.wait()\n        QPo = TextMobject('From This one,')\n        QPo.scale(0.75)\n        QPo.set_color(BLUE)\n        QPo.next_to(Tit, DOWN)\n        QPo.shift(LEFT * 4.5)\n        self.play(Write(QPo), WiggleOutThenIn(Triangle1))\n        self.play(WiggleOutThenIn(Triangle1))\n        QP = TexMobject('QP=\\\\sqrt{x^2+u^2}')\n        QP.scale(0.8)\n        QP.set_color(YELLOW)\n        QP.next_to(QPo, DOWN)\n        self.play(Write(QP))\n        QPp = TextMobject('From This one,')\n        QPp.scale(0.75)\n        QPp.set_color(BLUE)\n        QPp.next_to(QPo, RIGHT)\n        QPp.shift(RIGHT * 0.8)\n        self.play(Write(QPp), WiggleOutThenIn(Triangle2))\n        self.play(WiggleOutThenIn(Triangle2))\n        PR = TexMobject('PR=\\\\sqrt{y^2+v^2}')\n        PR.scale(0.8)\n        PR.set_color(ORANGE)\n        PR.next_to(QPp, DOWN)\n        self.play(Write(PR))\n        self.wait(2)\n        QPO = TextMobject('From big-one')\n        QPO.scale(0.75)\n        QPO.set_color(BLUE)\n        QPO.next_to(Tit, DOWN)\n        QPO.shift(5 * RIGHT)\n        self.play(Write(QPO), WiggleOutThenIn(Triangle))\n        self.play(WiggleOutThenIn(Triangle))\n        QR = TexMobject('QR=\\\\sqrt{(x+y)^2+(u+v)^2}')\n        QR.scale(0.65)\n        QR.set_color(ORANGE)\n        QR.next_to(QPO, DOWN)\n        self.play(Write(QR))\n        self.wait(2)\n        Conc = TextMobject('From This,')\n        Conc.scale(0.75)\n        Conc.set_color(GREEN)\n        Conc.next_to(QR, DOWN)\n        Conc.shift(DOWN * 3.7)\n        Trianglee = Polygon(p1, np4, p3)\n        Trianglee.set_stroke(None, 1.5)\n        Trianglee.set_color(RED)\n        self.play(Write(Conc), WiggleOutThenIn(Trianglee))\n        self.wait()\n        inq = TexMobject('QP+PR\\\\geq QR')\n        inq.scale(0.75)\n        inq.next_to(Conc, DOWN)\n        inq.set_color_by_gradient(RED, ORANGE, YELLOW)\n        self.play(Write(inq))\n        self.wait(2)\n        Inequalityy = TexMobject('\\\\sqrt{x^2+u^2}+\\\\sqrt{y^2+v^2}\\\\geq \\\\sqrt{(x+y)^2+(u+v)^2}')\n        Inequalityy.next_to(Conc, DOWN)\n        Inequalityy.scale(0.7)\n        Inequalityy.shift(2 * LEFT)\n        Inequalityy.set_color_by_gradient(BLUE, GREEN, YELLOW, ORANGE, RED)\n        self.play(Transform(inq, Inequalityy))\n        self.wait()\n        Rec = SurroundingRectangle(Inequalityy)\n        Rec.set_color(BLUE)\n        self.play(Write(Rec))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize Minkowski's inequality for p=2 by constructing a polygonal path on a coordinate plane and demonstrating the relationship between the path length and the distance between its endpoints."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Minkowsli_n(Scene):\n\n    def construct(self):\n        plane = NumberPlane()\n        Tit = Title(\"Polygonal Path Inequality(Minkowsli's Inequality For p=2)\")\n        Tit.set_color(RED)\n        Tit.scale(0.6)\n        Tit.shift(UP * 0.5)\n        self.play(Write(Tit))\n        Fist = TextMobject(\"Now Let's see the proof for n Integers.\")\n        Fist.next_to(Tit, DOWN)\n        Fist.set_color(GREEN)\n        self.play(FadeIn(Fist))\n        self.play(FadeOut(Fist))\n        origin = np.array([-6, -3, 0])\n        y_max = np.array([-6, 3.5, 0])\n        x_max = np.array([1, -3, 0])\n        mirror = np.array([0, 3, 0])\n        x_axis = Line(origin, x_max)\n        x_axis.set_stroke(None, 1.5)\n        x_axis.set_color(GREEN)\n        y_axis = Line(origin, y_max)\n        y_axis.set_stroke(None, 1.5)\n        y_axis.set_color(GREEN)\n        tan45 = Line(origin, mirror)\n        tan45.set_stroke(None, 1.6)\n        tan45.set_color(RED)\n        O = Dot(color=YELLOW)\n        O.move_to(origin)\n        O.scale(0.8)\n        Axis = VGroup(x_axis, y_axis, O)\n        self.play(Write(Axis))\n        self.wait()\n        self.play(Write(tan45))\n        p1 = np.array([-5, -3, 0])\n        p2 = np.array([-4, -3, 0])\n        p_n = np.array([-1.5, -3, 0])\n        pn = np.array([0, -3, 0])\n        q1 = np.array([-6, -2.5, 0])\n        q2 = np.array([-6, -0.5, 0])\n        q_n = np.array([-6, 2, 0])\n        qn = np.array([-6, 3, 0])\n        mid1 = np.array([-5, -2.5, 0])\n        mid2 = np.array([-4, -0.5, 0])\n        mid3 = np.array([-1.5, 2, 0])\n        mid4 = np.array([0, 3, 0])\n        rec11 = DashedLine(p1, mid1)\n        rec12 = DashedLine(q1, mid1)\n        p1q1 = Dot(color=YELLOW)\n        p1q1.scale(0.8)\n        p1q1.move_to(mid1)\n        recf = VGroup(rec11, rec12)\n        recf.set_stroke(None, 1.5)\n        recf.set_color(BLUE)\n        self.play(Write(recf), FadeIn(p1q1))\n        measure_linep1 = Line(p1, origin)\n        measurep1 = MeasureDistance(measure_linep1).add_tips()\n        measure_texp1 = measurep1.get_tex('a_1')\n        measure_texp1.scale(0.8)\n        measure_texp1.set_color(YELLOW)\n        self.play(Write(measurep1), Write(measure_texp1))\n        self.wait()\n        measure_lineq1 = Line(origin, q1)\n        measureq1 = MeasureDistance(measure_lineq1).add_tips()\n        measure_texq1 = measureq1.get_tex('b_1')\n        measure_texq1.scale(0.8)\n        measure_texq1.set_color(YELLOW)\n        self.play(Write(measureq1), Write(measure_texq1))\n        self.wait(2)\n        rec21 = DashedLine(p2, mid2)\n        rec22 = DashedLine(q2, mid2)\n        p2q2 = Dot(color=YELLOW)\n        p2q2.scale(0.8)\n        p2q2.move_to(mid2)\n        recf2 = VGroup(rec21, rec22)\n        recf2.set_stroke(None, 1.5)\n        recf2.set_color(BLUE)\n        self.play(Write(recf2), FadeIn(p2q2))\n        measure_linep2 = Line(p2, p1)\n        measurep2 = MeasureDistance(measure_linep2).add_tips()\n        measure_texp2 = measurep2.get_tex('a_2')\n        measure_texp2.scale(0.8)\n        measure_texp2.set_color(YELLOW)\n        self.play(Write(measurep2), Write(measure_texp2))\n        measure_lineq2 = Line(q1, q2)\n        measureq2 = MeasureDistance(measure_lineq2).add_tips()\n        measure_texq2 = measureq2.get_tex('b_2')\n        measure_texq2.scale(0.8)\n        measure_texq2.set_color(YELLOW)\n        self.play(Write(measureq2), Write(measure_texq2))\n        self.wait(2)\n        Tex = TextMobject('..............')\n        Tex.set_color(ORANGE)\n        Tex.next_to(x_axis, DOWN)\n        Tex.shift(LEFT * 0.2)\n        self.play(Write(Tex))\n        Texx = TextMobject('.........')\n        Texx.set_color(ORANGE)\n        Texx.rotate(PI / 2)\n        Texx.next_to(y_axis, LEFT)\n        Texx.shift(UP * 0.4)\n        self.play(Write(Texx))\n        self.wait(2)\n        midd = np.array([-2, 0.5, 0])\n        pww = np.array([-2, -3, 0])\n        qww = np.array([-6, 0.5, 0])\n        recc = DashedLine(pww, midd)\n        reccc = DashedLine(qww, midd)\n        pqe = Dot(color=YELLOW)\n        pqe.scale(0.8)\n        pqe.move_to(midd)\n        recf34 = VGroup(recc, reccc)\n        recf34.set_stroke(None, 1.5)\n        recf34.set_color(BLUE)\n        self.play(Write(recf34), FadeIn(pqe))\n        rec31 = DashedLine(p_n, mid3)\n        rec32 = DashedLine(q_n, mid3)\n        p3q3 = Dot(color=YELLOW)\n        p3q3.scale(0.8)\n        p3q3.move_to(mid3)\n        recf3 = VGroup(rec31, rec32)\n        recf3.set_stroke(None, 1.5)\n        recf3.set_color(BLUE)\n        self.play(Write(recf3), FadeIn(p3q3))\n        rec41 = DashedLine(pn, mid4)\n        rec42 = DashedLine(qn, mid4)\n        p4q4 = Dot(color=YELLOW)\n        p4q4.scale(0.8)\n        p4q4.move_to(mid4)\n        recf4 = VGroup(rec41, rec42)\n        recf4.set_stroke(None, 1.5)\n        recf4.set_color(BLUE)\n        self.play(Write(recf4), FadeIn(p4q4))\n        measure_linepn = Line(pn, p_n)\n        measurepn = MeasureDistance(measure_linepn).add_tips()\n        measure_texpn = measurepn.get_tex('a_n')\n        measure_texpn.scale(0.8)\n        measure_texpn.set_color(YELLOW)\n        self.play(Write(measurepn), Write(measure_texpn))\n        measure_lineqn = Line(q_n, qn)\n        measureqn = MeasureDistance(measure_lineqn).add_tips()\n        measure_texqn = measureqn.get_tex('b_n')\n        measure_texqn.scale(0.8)\n        measure_texqn.set_color(YELLOW)\n        self.play(Write(measureqn), Write(measure_texqn))\n        self.wait(2)\n        path = VMobject()\n        path.set_points_as_corners([origin, mid1, mid2, midd, mid3, mid4])\n        path.set_color(YELLOW)\n        path.set_stroke(None, 1.7)\n        self.play(Write(path), run_time=2)\n        self.wait(2)\n        base1 = np.array([p1[0], q1[1], 0])\n        base2 = np.array([p2[0], q1[1], 0])\n        base3 = np.array([pn[0], q_n[1], 0])\n        Triangle = VGroup(Polygon(origin, p1, base1), Polygon(mid1, base2, mid2), Polygon(mid3, base3, mid4), Polygon(origin, pn, mid4))\n        Triangle.set_color(ORANGE)\n        Name = TexMobject('O', 'A', 'B', 'C', 'D')\n        Name.scale(0.75)\n        Name.set_color(BLUE)\n        Name[0].next_to(origin, LEFT)\n        Name[0].shift(DOWN * 0.3)\n        Name[1].next_to(p1q1, DOWN)\n        Name[1].shift(UP * 0.2)\n        Name[2].next_to(p2q2, UP)\n        Name[2].shift(DOWN * 0.1)\n        Name[3].next_to(p3q3, UP)\n        Name[3].shift(DOWN * 0.1)\n        Name[4].next_to(p4q4, RIGHT)\n        self.play(Write(Name), run_time=2)\n        self.wait(2)\n        tt = TexMobject('OA=\\\\sqrt{a_1^2+b_1^2}', 'AB=\\\\sqrt{a_2^2+b_2^2}', 'CD=\\\\sqrt{a_n^2+b_n^2}', 'OD=\\\\sqrt{(\\\\sum_{i=1}^{n}a_i)^2+(\\\\sum_{i=1}^{n}b_i)^2}')\n        for i in range(4):\n            tt[i].next_to(Tit, DOWN)\n            tt[i].shift(3 * RIGHT)\n        tt.scale(0.7)\n        tt.set_color(GREEN)\n        tt[1].next_to(tt[0], DOWN)\n        tt[2].next_to(tt[1], DOWN)\n        tt[3].next_to(tt[2], DOWN)\n        for i in range(4):\n            self.play(Write(tt[i]), WiggleOutThenIn(Triangle[i]), run_time=1)\n            self.play(FadeOut(Triangle[i]))\n        self.wait(2)\n        Text = TextMobject('$\\\\to$Straight Line', '$\\\\leq$', 'Path')\n        Text.set_color(BLUE)\n        Text.scale(0.8)\n        Text.set_stroke(YELLOW)\n        Text.next_to(tt[3], DOWN)\n        self.play(Write(Text[0]), WiggleOutThenIn(tan45))\n        self.add(Text[1])\n        self.play(Write(Text[2]), WiggleOutThenIn(path))\n        self.wait()\n        maineq = TexMobject('\\\\sqrt{(\\\\sum_{i=1}^{n}a_i)^2+(\\\\sum_{i=1}^{n}b_i)^2}\\\\leq\\\\sum_{i=1}^{n}\\\\sqrt{a_i^2+b_i^2}')\n        maineq.set_color_by_gradient(RED, ORANGE, YELLOW, GREEN, BLUE)\n        maineq.scale(0.65)\n        maineq.move_to(DOWN * 3 + 3.9 * RIGHT)\n        self.play(Write(maineq))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display a background image that fades in and out, followed by animated text saying \"Seeing You Next Time,With something new\" and then transforming into \"LIKE--SHARE--SUBSCRIBE\" with a color gradient."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Endingsq(Scene):\n\n    def construct(self):\n        image1 = ImageMobject('Path')\n        image1.scale(4)\n        self.bring_to_back(image1)\n        self.play(FadeIn(image1))\n        self.play(FadeOut(image1))\n        FQQ = TextMobject('Seeing You Next Time,With something new.')\n        FQQ.set_color(YELLOW)\n        self.play(Write(FQQ), run_time=4)\n        self.wait()\n        EQQ = TextMobject('LIKE--SHARE--SUBSCRIBE')\n        EQQ.set_color_by_gradient(RED, GREEN, BLUE, PURPLE)\n        self.play(Transform(FQQ, EQQ), run_time=3)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Demonstrate the AM-GM inequality by visually constructing a square and its components to derive the formula."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass AM_GM(Scene):\n\n    def construct(self):\n        plane = NumberPlane()\n        Tit = Title('Proof of Arithmetic and Geometric Mean Inequality')\n        Tit.set_color(RED)\n        self.play(Write(Tit))\n        words = TextMobject(\"\\n\\t\\t\\t`` Two things are Infinite: the Universe and Human stupidity; and I'm not sure about the Universe.''\\n\\t\\t\\t\", organize_left_to_right=False)\n        words.scale(0.75)\n        words.set_width(2 * (FRAME_X_RADIUS - 1))\n        words.next_to(Tit, DOWN)\n        words.set_color(BLUE)\n        author = TextMobject('-Albert Einstein')\n        author.set_color(YELLOW)\n        author.next_to(words, DOWN)\n        author.shift(3 * RIGHT)\n        self.play(Write(words), run_time=7)\n        self.wait()\n        self.play(FadeIn(author))\n        self.wait(2)\n        self.play(FadeOut(words), FadeOut(author))\n        proof1 = TextMobject('Proof:')\n        proof1.set_color(YELLOW)\n        proof1.scale(0.7)\n        proof1.move_to(6.5 * LEFT + 2 * UP)\n        self.play(Write(proof1))\n        main_square = Square(color=PURPLE)\n        main_square.scale(2.5)\n        main_square.shift(0.7 * DOWN + LEFT)\n        self.play(Write(main_square))\n        p = []\n        for i in range(16):\n            q = main_square.get_points()[i]\n            p.append(q)\n        measure_line = Line(p[8], p[4])\n        measure = MeasureDistance(measure_line).add_tips()\n        measure_tex = measure.get_tex('a+b')\n        measure_tex.set_color(GREEN)\n        self.play(Write(measure), Write(measure_tex))\n        small_rec1 = Polygon(p[14], p[0], p[2], np.array([p[2][0], p[14][1], 0]))\n        self.play(Write(small_rec1))\n        measure_line1 = Line(p[14], p[0])\n        measure1 = MeasureDistance(measure_line1).add_tips()\n        measure_tex1 = measure1.get_tex('b')\n        measure_tex1.set_color(GREEN)\n        self.play(Write(measure1), Write(measure_tex1))\n        measure_line2 = Line(p[0], p[2])\n        measure2 = MeasureDistance(measure_line2).add_tips()\n        measure_tex2 = measure2.get_tex('a')\n        measure_tex2.set_color(GREEN)\n        self.play(Write(measure2), Write(measure_tex2))\n        small_rec2 = Polygon(p[14], p[11], p[10], np.array([p[10][0], p[14][1], 0]))\n        small_rec1_2 = Polygon(p[14], p[0], p[2], np.array([p[2][0], p[14][1], 0]))\n        tt = TextMobject('Generate 4 copies of The small Rectangle \\\\\\\\ Paste them as shown')\n        tt.set_color(YELLOW)\n        self.play(Write(tt))\n        self.play(FadeOut(tt))\n        small_rec1_2.generate_target()\n        small_rec1_2.target.rotate(-PI / 2, about_point=p[14])\n        self.play(MoveToTarget(small_rec1_2))\n        self.wait()\n        small_rec2.generate_target()\n        small_rec2.target.rotate(-PI / 2, about_point=p[10])\n        self.play(MoveToTarget(small_rec2))\n        measure_line3 = Line(p[11], p[7])\n        measure3 = MeasureDistance(measure_line3).add_tips()\n        measure_tex3 = measure3.get_tex('a+b')\n        measure_tex3.set_color(GREEN)\n        self.play(Transform(measure_tex, measure_tex3), Transform(measure, measure3))\n        small_rec2.target.rotate(-PI / 2, about_point=p[6])\n        self.play(MoveToTarget(small_rec2.copy()))\n        self.wait()\n        x1 = p[2][0]\n        Srqa = Polygon(np.array([p[10][0], p[14][1], 0]), np.array([p[2][0], p[14][1], 0]), np.array([p[9][0], p[6][1], 0]), np.array([p[10][0], p[13][1], 0]))\n        Srqa.set_color(YELLOW)\n        self.add(Srqa)\n        self.wait()\n        measure_line4 = Line(np.array([p[10][0], p[14][1], 0]), np.array([p[2][0], p[14][1], 0]))\n        measure4 = MeasureDistance(measure_line4).add_tips()\n        measure_tex4 = measure4.get_tex('a-b')\n        measure_tex4.set_color(GREEN)\n        self.play(FadeIn(measure4), FadeIn(measure_tex4))\n        Area = TextMobject('Area of the big Square:')\n        Area.scale(0.7)\n        Area.set_color(TEAL_B)\n        Area.move_to(np.array([4.5, 2, 0]))\n        self.play(Write(Area))\n        Cal = TexMobject('(a+b)^2', '=', '(a-b)^2', '+', '4ab')\n        Cal.set_color(RED)\n        Cal[0].set_color(PURPLE)\n        Cal[2].set_color(YELLOW)\n        Cal[4].set_color(BLUE)\n        Cal.scale(0.9)\n        Cal.next_to(Area, DOWN)\n        self.play(WiggleOutThenIn(main_square), Write(Cal[0]))\n        self.add(Cal[1])\n        self.play(WiggleOutThenIn(Srqa), Write(Cal[2]))\n        self.add(Cal[3])\n        self.play(WiggleOutThenIn(small_rec2), Write(Cal[4]))\n        Cal1 = TexMobject('Gives,', '(a+b)^2', '\\\\geq', '4ab')\n        Cal1.set_color(RED)\n        Cal1[1].set_color(PURPLE)\n        Cal1[3].set_color(BLUE)\n        Cal1.scale(0.9)\n        Cal1.next_to(Cal, DOWN)\n        self.play(Write(Cal1))\n        Cl = TexMobject('\\\\frac{a+b}{2}\\\\geq\\\\sqrt{ab}')\n        Cl.set_color(RED)\n        Cl.next_to(Cal, DOWN)\n        self.play(Transform(Cal1, Cl))\n        self.wait(4)"}]}
{"messages": [{"role": "user", "content": "Show an image, then display text about seeing you next time, and finally transform that text into a \"LIKE--SHARE--SUBSCRIBE\" message with a gradient."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Endingsq(Scene):\n\n    def construct(self):\n        image1 = ImageMobject('AM_GM')\n        image1.scale(4)\n        self.bring_to_back(image1)\n        self.play(FadeIn(image1))\n        FQQ = TextMobject('Seeing You Next Time,With a new proof of same topic.')\n        FQQ.set_color(YELLOW)\n        self.play(Write(FQQ), run_time=4)\n        self.wait()\n        EQQ = TextMobject('LIKE--SHARE--SUBSCRIBE')\n        EQQ.set_color_by_gradient(RED, GREEN, BLUE, PURPLE)\n        self.play(FadeOut(image1))\n        self.wait(0.5)\n        self.play(Transform(FQQ, EQQ), run_time=3)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize the Collatz conjecture by drawing a sequence of colored lines based on whether the next number in the sequence is odd or even, and then zoom out to encompass all drawn lines."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Collatz_con(MovingCameraScene):\n\n    def construct(self):\n        tt = Title('Collatz Conjecture')\n        tt.set_color(YELLOW)\n        self.play(Write(tt))\n        self.play(FadeOut(tt), run_time=0.1)\n        seq = []\n        s = 1\n        f = 1\n        a = 0\n        ia = 8.5944\n        x = 0\n        y = 0.2\n        M = []\n        NUMBER = 1000\n        iniposi = [2, -2, 0]\n        incre = [x, y, 0]\n        newpos = [iniposi[0] + incre[0], iniposi[1] + incre[1], 0]\n        for n in range(1, NUMBER + 1):\n            while n != 1:\n                col = colz(n)\n                seq.append(col)\n                n = col\n            seq.reverse()\n            for i in seq:\n                if i % 2 == 1:\n                    q = Line(iniposi, newpos, stroke_width=1.2, opacity=0.7)\n                    q.set_color(RED)\n                    a = a - ia\n                    q.rotate(a * DEGREES, about_point=iniposi)\n                    self.play(Write(q), run_time=0.0007)\n                    iniposi = q.get_end()\n                    newpos = [iniposi[0] + incre[0], iniposi[1] + incre[1], 0]\n                    M.append(q)\n                else:\n                    w = Line(iniposi, newpos, stroke_width=1.2, opacity=0.7)\n                    w.set_color(BLUE)\n                    a = a + ia\n                    w.rotate(a * DEGREES, about_point=iniposi)\n                    self.play(Write(w), run_time=0.0007)\n                    iniposi = w.get_end()\n                    newpos = [iniposi[0] + incre[0], iniposi[1] + incre[1], 0]\n                    M.append(w)\n            n = VGroup(*[M[i] for i in range(len(M))])\n            a = 0\n            iniposi = [2, -2, 0]\n            incre = [x, y, 0]\n            newpos = [iniposi[0] + incre[0], iniposi[1] + incre[1], 0]\n            seq = []\n        self.wait(2)\n        self.play(self.camera_frame.set_height, n.get_width() * 2, run_time=3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Present an introductory animation explaining Laplace's equation, its relation to Poisson's equation, and the definition of harmonic functions."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Opening_Quote(Scene):\n\n    def construct(self):\n        quote1 = TextMobject('Imagination is more important than knowledge')\n        quote1.set_color(RED)\n        quote1.to_edge(UP)\n        author = TextMobject('-Albert Einstein')\n        author.set_color(GOLD_B)\n        author.scale(0.75)\n        author.next_to(quote1.get_corner(DOWN + RIGHT), DOWN)\n        self.play(Write(quote1), Write(author))\n        LINE1 = TextMobject(\"What is Laplace's equation?\\\\\\\\ It is a second-order P.D.E of form $$\\\\nabla^2f=0$$\")\n        LINE1.to_edge(UP, buff=2)\n        LINE1.set_color(BLUE)\n        self.play(FadeIn(LINE1))\n        self.wait()\n        LINE2 = TextMobject('Where $\\\\nabla^2 = \\\\vec \\\\nabla \\\\cdot \\\\vec \\\\nabla $ and f is scalar valued function.')\n        LINE2.next_to(LINE1, DOWN)\n        self.play(FadeIn(LINE2))\n        self.wait(2)\n        Poission = TexMobject('\\\\nabla^2V=-\\\\frac{\\\\rho}{\\\\epsilon}')\n        Poission.set_color(GREEN)\n        title = Title(\"Laplace's Equation\")\n        title.set_color(RED)\n        title.to_edge(UP)\n        self.play(Transform(quote1, title), FadeOut(author))\n        self.remove(LINE2)\n        self.wait()\n        Poission.next_to(title, DOWN)\n        Laplace = TexMobject('\\\\nabla^2V=0')\n        Laplace.set_color(GREEN)\n        rect = SurroundingRectangle(Poission)\n        rect.set_color(GOLD_B)\n        rect1 = SurroundingRectangle(Laplace)\n        rect.set_color(GOLD_B)\n        Poission_T = TextMobject('Poisson Equation')\n        Poission_T.next_to(rect, RIGHT)\n        Poission_T.scale(0.75)\n        self.play(Transform(LINE1, Poission), ShowCreation(rect), Write(Poission_T))\n        self.wait(2)\n        LINE3 = TextMobject(\"When $\\\\rho =0$ Poisson's eqn Transform to Laplace eqn.\")\n        LINE3.next_to(Poission.get_corner(DOWN + RIGHT), DOWN)\n        self.play(Write(LINE3))\n        self.wait()\n        Laplace_T = TextMobject('Laplace Equation')\n        Laplace_T.scale(0.75)\n        Laplace_T.next_to(rect1, RIGHT)\n        self.play(Transform(Poission, Laplace), Transform(rect, rect1), Transform(Poission_T, Laplace_T))\n        self.wait(2)\n        LINE4 = TextMobject('The Solution of Laplace eqn are called $\\\\textbf{Harmonic Functions}$.')\n        LINE4.set_color(ORANGE)\n        LINE4.next_to(Laplace, DOWN)\n        self.play(Write(LINE4))\n        self.wait(2)\n        LINE5 = TextMobject(\"Laplacian is used in various fields of maths and physics but\\\\\\\\We will examine its's value in electrostatics.\")\n        LINE5.next_to(LINE4, DOWN)\n        self.play(GrowFromCenter(LINE5))\n        self.wait(2)\n        self.remove(*self.mobjects)\n        Laplace.next_to(title.get_corner(DOWN + LEFT), DOWN)\n        self.play(Write(title), FadeIn(Laplace))\n        self.wait(2)\n        TYPE = TextMobject('Here We will learn the topic in 2 steps:')\n        TYPE.set_color(BLUE)\n        TYPE.next_to(title, DOWN)\n        TYPE1 = TextMobject('1.General Intution of Laplacian', \"2.Laplace's Equation in many dimension and their Solution\")\n        TYPE1[0].set_color(GOLD_B)\n        TYPE1[1].set_color(GOLD_B)\n        TYPE1[0].next_to(TYPE, DOWN)\n        TYPE1[1].next_to(TYPE1[0], DOWN)\n        self.play(Write(TYPE), GrowFromCenter(TYPE1[0]), GrowFromCenter(TYPE1[1]))\n        self.wait(2)\n        LINE6 = TextMobject('We will see the Intution and significance.. \\\\\\\\ and also what it means to be the Laplacian in next video.')\n        LINE6.set_color(ORANGE)\n        LINE6.to_edge(DOWN)\n        self.play(GrowFromCenter(LINE6))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Introduce Laplace's equation with colored text and then explain its components, highlighting \"Divergence\" and \"Gradient\" at the end."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Introduction_Intution(Scene):\n\n    def construct(self):\n        INTEXT1 = TextMobject('In the previous video we have seen that', \" $\\\\nabla^2V=0$ is called Laplace's Equation\", 'But have does it signify?,', 'Here we will learn that:')\n        INTEXT1[0].set_color(RED)\n        INTEXT1[1].set_color(BLUE)\n        INTEXT1[2].set_color(GOLD_B)\n        INTEXT1[3].set_color(GREEN)\n        INTEXT1[0].to_edge(UP + RIGHT)\n        INTEXT1[1].next_to(INTEXT1[0], DOWN)\n        INTEXT1[2].next_to(INTEXT1[1], DOWN)\n        INTEXT1[3].next_to(INTEXT1[2], DOWN)\n        self.play(Write(INTEXT1[0]), Write(INTEXT1[1]), Write(INTEXT1[2]), Write(INTEXT1[3]))\n        self.wait(3)\n        self.play(FadeOut(INTEXT1[0]), FadeOut(INTEXT1[1]), FadeOut(INTEXT1[2]), FadeOut(INTEXT1[3]))\n        self.wait()\n        INtitle = Title(\"Laplace's Equation\")\n        INtitle.set_color(RED)\n        INtitle.to_edge(UP)\n        self.play(GrowFromCenter(INtitle))\n        INTEXT2 = TextMobject('Now to understand the equation we have to understand', '$\\\\nabla^2 \\\\simeq \\\\vec{\\\\nabla}\\\\cdot\\\\vec{\\\\nabla}$ itself.', '$\\\\nabla^2 V \\\\simeq ((divergence)(gradient)(V)$')\n        INTEXT2[0].set_color(BLUE)\n        INTEXT2[1].set_color(GOLD_B)\n        INTEXT2[2].set_color(GREEN)\n        INTEXT2[0].next_to(INtitle, DOWN)\n        INTEXT2[1].next_to(INTEXT2[0], DOWN)\n        INTEXT2[2].next_to(INTEXT2[1], DOWN)\n        INTEXT2[2].scale(0.7)\n        INTEXT3 = TextMobject('Divergence', 'Gradient')\n        INTEXT3[0].set_color(RED)\n        INTEXT3[1].set_color(RED)\n        INTEXT3[0].to_edge(DOWN + RIGHT)\n        INTEXT3[1].to_edge(DOWN + LEFT)\n        self.play(FadeIn(INTEXT2[0]), Write(INTEXT2[1]))\n        self.wait(2)\n        self.play(Write(INTEXT2[2]), runtime=4)\n        self.play(FadeIn(INTEXT3[0]), FadeIn(INTEXT3[1]))\n        self.wait(74)\n        self.remove(INTEXT2[0], INTEXT2[1], INTEXT2[2], INTEXT3[0], INTEXT3[1])\n        self.remove(7)"}]}
{"messages": [{"role": "user", "content": "Display a 3D parabolic surface with axes and then animate vectors connecting specific points on the surface, with some vectors transforming and others fading out with the surface."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass LaplacianSig1(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes(number_line_config={'color': RED, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        parabola = ParametricSurface(lambda u, v: np.array([u, v, 7 * u * v / np.exp(u ** 2 + v ** 2)]), u_max=2, u_min=-2, v_max=2, v_min=-2, checkerboard_colors=[PURPLE_D, PURPLE_E], resolution=(10, 32)).scale(2)\n        self.set_camera_orientation(phi=75 * DEGREES)\n        self.begin_ambient_camera_rotation(0.3)\n        self.play(Write(parabola), Write(axes))\n        self.wait()\n        circle1 = Circle(radius=0.1, fill_opacity=1.0)\n        circle2 = Circle(radius=0.1, fill_opacity=1.0)\n        circle7 = Circle(radius=0.1, fill_opacity=1.0)\n        circle8 = Circle(radius=0.1, fill_opacity=1.0)\n        vect1 = np.array([np.sqrt(2), -np.sqrt(2), -2 * 1.2876])\n        vect2 = np.array([-np.sqrt(2), np.sqrt(2), -2 * 1.2876])\n        vect7 = np.array([np.sqrt(2), np.sqrt(2), 2 * 1.2876])\n        vect8 = np.array([-np.sqrt(2), -np.sqrt(2), 2 * 1.2876])\n        circle1.move_to(vect1)\n        circle2.move_to(vect2)\n        circle7.move_to(vect7)\n        circle8.move_to(vect8)\n        line0 = Arrow(np.array([np.sqrt(2), np.sqrt(2), 2 * 1.2876]), np.array([-np.sqrt(2), np.sqrt(2), -2 * 1.2876]))\n        line1 = Arrow(np.array([np.sqrt(2), -np.sqrt(2), -2 * 1.2876]), np.array([np.sqrt(2), np.sqrt(2), 2 * 1.2876]))\n        line2 = Arrow(np.array([np.sqrt(2), -np.sqrt(2), 2 * 1.2876]), np.array([-np.sqrt(2), -np.sqrt(2), 2 * 1.2876]))\n        line2.set_color(BLUE)\n        line1.set_color(BLUE)\n        line0.set_color(GREEN)\n        line3 = Arrow(np.array([-np.sqrt(2), np.sqrt(2), -2 * 1.2876]), np.array([-np.sqrt(2), -np.sqrt(2), 2 * 1.2876]))\n        line4 = Arrow(np.array([-np.sqrt(2), np.sqrt(2), -2 * 1.2876]), np.array([np.sqrt(2), np.sqrt(2), 2 * 1.2876]))\n        line3.set_color(GOLD_B)\n        line4.set_color(GOLD_B)\n        circle7.set_color(GREEN)\n        circle8.set_color(GREEN)\n        self.set_camera_orientation(phi=0 * DEGREES)\n        self.play(FadeIn(circle1), FadeIn(circle2), FadeIn(circle7), FadeIn(circle8))\n        self.wait(21)\n        self.play(Write(line2), Write(line1), Write(line3), Write(line0))\n        self.wait(12)\n        self.play(Transform(line0, line4))\n        self.begin_ambient_camera_rotation(0.0)\n        self.wait()\n        self.wait(5)\n        self.remove(line1, line2, line3, line4, circle2, circle1, circle7, circle8, line0)\n        self.play(FadeOut(parabola), FadeOut(axes))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a vector field with colored arrows, then introduce points representing sources and sinks, and finally display and transform Maxwell's equations."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Field(Scene):\n    CONFIG = {'color_list': ['#2be22b', '#e88e10', '#eae600', '#88ea00', '#00eae2', '#0094ea', '#2700ea', '#bf00ea', '#ea0078'], 'prop': 0}\n\n    def construct(self):\n        axes_config = {'x_min': -5, 'x_max': 5, 'y_min': -5, 'y_max': 5, 'z_axis_config': {}, 'z_min': -1, 'z_max': 1, 'z_normal': DOWN, 'num_axis_pieces': 20, 'light_source': 9 * DOWN + 7 * LEFT + 10 * OUT, 'number_line_config': {'include_tip': False}}\n        axes = Axes(**axes_config)\n        axes.set_color(PURPLE_D)\n        f = VGroup(*[self.calc_field_color(x * RIGHT + y * UP, self.vect, prop=0) for x in np.arange(-5, 5, 1) for y in np.arange(-5, 5, 1)])\n        field = VGroup(axes, f)\n        circle3 = Circle(radius=0.5)\n        circle3.set_color(BLUE)\n        vect3 = np.array([1 / np.sqrt(2), 1 / np.sqrt(2), 0])\n        circle3.move_to(vect3)\n        circle4 = Circle(radius=0.5)\n        circle4.set_color(BLUE)\n        vect4 = np.array([-1 / np.sqrt(2), -1 / np.sqrt(2), 0])\n        circle4.move_to(vect4)\n        circle5 = Circle(radius=0.5)\n        circle5.set_color(GOLD_B)\n        vect5 = np.array([-1 / np.sqrt(2), 1 / np.sqrt(2), 0])\n        circle5.move_to(vect5)\n        circle6 = Circle(radius=0.5)\n        circle6.set_color(GOLD_B)\n        vect6 = np.array([1 / np.sqrt(2), -1 / np.sqrt(2), 0])\n        circle6.move_to(vect6)\n        Source1 = TextMobject('-SOURCE')\n        Source2 = TextMobject('-SOURCE')\n        Source1.next_to(circle3)\n        Source2.next_to(circle4, LEFT)\n        Source3 = TextMobject('+SOURCE')\n        Source4 = TextMobject('+SOURCE')\n        Source3.next_to(circle5, LEFT)\n        Source4.next_to(circle6)\n        Gauss = TexMobject('\\\\vec E =-\\\\nabla V')\n        Gauss.set_color(BLUE)\n        Gauss.to_edge(DOWN)\n        Poision2 = TexMobject('\\\\nabla^2V=-\\\\frac{\\\\rho}{\\\\epsilon}', '\\\\vec \\\\nabla\\\\cdot\\\\vec E=-\\\\frac{\\\\rho}{\\\\epsilon}')\n        Poision2[0].set_color(RED)\n        Poision2[1].set_color(RED)\n        Poision2[0].to_edge(DOWN)\n        Poision2[1].to_edge(DOWN)\n        self.wait(2)\n        self.play(ShowCreation(field))\n        self.wait(17)\n        self.play(Write(circle3), Write(circle4))\n        self.wait(5)\n        self.play(Write(circle5), Write(circle6))\n        self.wait(16)\n        self.play(Write(Source1), Write(Source2))\n        self.wait(8)\n        self.play(Write(Source3), Write(Source4))\n        self.wait(55)\n        self.play(FadeIn(Gauss))\n        self.wait(2)\n        self.wait(34)\n        self.play(FadeOut(Gauss))\n        self.wait(20)\n        self.play(Write(Poision2[1]))\n        self.play(ReplacementTransform(Poision2[1], Poision2[0]))\n        self.wait(37)\n\n    def calc_field_color(self, point, f, prop=0.0, opacity=None):\n        x, y = point[:2]\n        func = f(x, y)\n        magnitude = math.sqrt(func[0] ** 2 + func[1] ** 2)\n        func = func / magnitude if magnitude != 0 else np.array([0, 0])\n        func = func / 1.7\n        v = int(magnitude / 10 ** prop)\n        index = len(self.color_list) - 1 if v > len(self.color_list) - 1 else v\n        c = self.color_list[index]\n        v = Vector(func, color=c).shift(point)\n        if opacity:\n            v.set_fill(opacity=opacity)\n        return v\n\n    @staticmethod\n    def vect(x, y):\n        return np.array([7 * y * (1 - 2 * x ** 2) / np.exp(x ** 2 + y ** 2), 7 * x * (1 - 2 * y ** 2) / np.exp(x ** 2 + y ** 2), 0])"}]}
{"messages": [{"role": "user", "content": "Render a 3D plot of a potential field and transform it into a tilted plane."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Source_term(ThreeDScene):\n\n    def construct(self):\n        axes = ThreeDAxes(number_line_config={'color': RED, 'include_tip': False, 'exclude_zero_from_default_numbers': True})\n        potential = ParametricSurface(lambda u, v: np.array([u, v, 0.25 + 7 * u * v / np.exp(u ** 2 + v ** 2)]), u_max=2, u_min=-2, v_max=2, v_min=-2, checkerboard_colors=[PURPLE_D, PURPLE_E], resolution=(10, 32)).scale(2)\n        plane = ParametricSurface(lambda u, v: np.array([u, v, 0.25]), u_max=2, u_min=-2, v_max=2, v_min=-2, checkerboard_colors=[PURPLE_D, PURPLE_E], resolution=(10, 32)).scale(2)\n        self.set_camera_orientation(phi=75 * DEGREES)\n        self.begin_ambient_camera_rotation(0.2)\n        self.play(Write(potential), Write(axes))\n        self.wait()\n        self.wait(10)\n        self.play(ReplacementTransform(potential, plane), run_time=5)\n        self.wait(5)\n        self.wait(2)\n        plane_tilt = ParametricSurface(lambda u, v: np.array([u, v, 0.6 * (u + 0.01 * v)]), u_max=2, u_min=-2, v_max=2, v_min=-2, checkerboard_colors=[PURPLE_D, PURPLE_E], resolution=(10, 32)).scale(2)\n        self.play(ReplacementTransform(plane, plane_tilt), run_time=4)\n        self.wait(3)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate a rotating camera observing a transforming ball moving along a trajectory above a 3D surface."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass They_See_Me_Rolling(ThreeDScene):\n    CONFIG = {'t': 4, 'r': 0.2, 'R': 4, 'laps': 2 * 2 * np.pi}\n\n    def they_hating(self, da):\n        ball_1 = ParametricSurface(lambda u, v: np.array([self.r * np.cos(u) * np.cos(v), self.r * np.sin(u) * np.cos(v), self.r * np.sin(v)]), v_min=0, v_max=TAU / 2, u_min=0, u_max=TAU / 2, checkerboard_colors=[BLUE_D, BLUE_D], resolution=(20, 20))\n        ball_2 = ParametricSurface(lambda u, v: np.array([self.r * np.cos(u) * np.cos(v), self.r * np.sin(u) * np.cos(v), self.r * np.sin(v)]), v_min=TAU / 2, v_max=TAU, u_min=TAU / 2, u_max=TAU, checkerboard_colors=[RED_D, RED_D], resolution=(20, 20))\n        ball = VGroup(ball_1, ball_2)\n        trajectory = ParametricFunction(lambda j: np.array([1 / np.sqrt(2), j, 7 * j / (np.sqrt(2) * np.exp(0.5 + j ** 2))]), j_min=-1 / (4 * np.sqrt(2)), j_max=1 / (4 * np.sqrt(2)), color=PURPLE_D)\n        ball.rotate(self.t * self.R / self.r * da, [1 / np.sqrt(2), 1 / np.sqrt(2), 7 / (2 * np.exp(1))])\n        position_ball = np.array([1 / np.sqrt(2), 1 / np.sqrt(2), 7 / (np.sqrt(2) * np.exp(0.5 + 0.5)) * da + self.r])\n        ball.move_to(position_ball)\n        group = VGroup(ball, trajectory)\n        return group\n\n    def construct(self):\n        ball_1 = ParametricSurface(lambda u, v: np.array([self.r * np.cos(u) * np.cos(v), self.r * np.sin(u) * np.cos(v), self.r * np.sin(v)]), v_min=0, v_max=TAU / 2, u_min=0, u_max=TAU / 2, checkerboard_colors=[BLUE_D, BLUE_D], resolution=(20, 20))\n        ball_2 = ParametricSurface(lambda u, v: np.array([self.r * np.cos(u) * np.cos(v), self.r * np.sin(u) * np.cos(v), self.r * np.sin(v)]), v_min=TAU / 2, v_max=TAU, u_min=TAU / 2, u_max=TAU, checkerboard_colors=[RED_D, RED_D], resolution=(20, 20))\n        ball = VGroup(ball_1, ball_2)\n        Random_Surface = ParametricSurface(lambda u, v: np.array([u, v, 7 * u * v / np.exp(u ** 2 + v ** 2)]), v_min=-1.8 * TAU, v_max=TAU, u_min=-1.8 * TAU, u_max=TAU, checkerboard_colors=[PURPLE_D, PURPLE_E], resolution=(40, 40))\n        ball.move_to([1 / np.sqrt(2), 1 / np.sqrt(2), 7 / (2 * np.exp(1)) + self.r])\n        trajectory = ParametricFunction(lambda da: np.array([0, 0, 0]), t_min=0, t_max=1, color=RED)\n        group = VGroup(ball, trajectory)\n\n        def update(iteration, da):\n            new_it = self.they_hating(da)\n            iteration.become(new_it)\n            return iteration\n        self.set_camera_orientation(phi=50 * DEGREES, theta=50 * DEGREES, distance=8)\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.play(GrowFromCenter(ball), ShowCreation(Random_Surface))\n        self.wait(5)\n        self.play(UpdateFromAlphaFunc(group, update), run_time=self.t, rate_func=linear)\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Present the properties of Laplace's equation solutions with sequential text and notes, culminating in a preview of the next video topic."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Ending(Scene):\n\n    def construct(self):\n        title = Title(\"Laplace's Equation Solution Properties\")\n        title.set_color(RED)\n        title.to_edge(UP)\n        PROPERTY1 = TextMobject(\"1.The Solution tolerates no local maxima or minima.\\\\\\\\If is does, then it will become poisson's solution.\")\n        PROPERTY1.set_color(BLUE)\n        PROPERTY2 = TextMobject('2.It represent average around the point of interest.\\\\\\\\ i.e., It is a averaging function.')\n        PROPERTY2.set_color(BLUE)\n        PROPERTY1.next_to(title.get_corner(DOWN), DOWN)\n        note1 = TextMobject('The maxima and minima can only exist at the boundaries.')\n        note1.set_color(GOLD_B)\n        note1.scale(0.7)\n        note1.next_to(PROPERTY1.get_corner(DOWN), DOWN)\n        note2 = TextMobject('The first points is explained the second one will \\\\\\\\ be explaned seperately for different dimensions.')\n        note2.set_color(GOLD_B)\n        note2.next_to(PROPERTY2.get_corner(DOWN), DOWN)\n        note2.scale(0.7)\n        PROPERTY2.next_to(note1.get_corner(DOWN), DOWN)\n        self.play(Write(title))\n        self.wait(3)\n        self.play(Write(PROPERTY1), run_time=5)\n        self.wait()\n        self.play(Write(note1))\n        self.wait(3)\n        self.play(Write(PROPERTY2), run_time=4)\n        self.wait()\n        self.play(Write(note2))\n        self.wait(3)\n        self.remove(title, PROPERTY1, PROPERTY2, note1, note2)\n        next1 = TextMobject('In the next video we will see Laplacian in 1D.\\\\\\\\ See you next time.')\n        next1.set_color(GREEN)\n        self.play(Write(next1))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize the Pappus chain construction with a central circle, tangent circles, and a chain of circles demonstrating the inversion principle, accompanied by explanatory text and measurements."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom collections import namedtuple\nimport numpy as np\nimport math\nimport random\n\nclass Inversion(Scene):\n\n    def construct(self):\n        titlem = Title('Reflection Of Pappus')\n        titlem.to_edge(UP)\n        titlem.set_color(RED)\n        words = TextMobject(\"\\n\\t\\t\\t`` Mathematics, rightly viewed, possesses not only truth but Supreme beauty...''\\n\\t\\t\\t\", organize_left_to_right=False)\n        words.scale(0.75)\n        words.set_width(2 * (FRAME_X_RADIUS - 1))\n        words.next_to(titlem, DOWN)\n        words.set_color(BLUE)\n        author = TextMobject('-Berlrand Russell')\n        author.set_color(YELLOW)\n        author.next_to(words, DOWN)\n        author.shift(3 * RIGHT)\n        self.play(GrowFromCenter(titlem))\n        self.wait()\n        self.play(Write(words), run_time=4)\n        self.wait(2)\n        self.play(FadeIn(author))\n        self.wait(4)\n        self.play(Uncreate(words), FadeOut(author), run_time=2)\n        self.wait(4)\n        plane = NumberPlane()\n        self.wait(7)\n        RADIUS = 3\n        Main_Circle = Circle(radius=RADIUS, color=DARK_BROWN)\n        Main_Circle.shift(3 * RIGHT + 2 * RADIUS / 1.6 * LEFT)\n        Main_Circle.shift(3.5 * RIGHT + 0.5 * DOWN)\n        Main_Circle.set_stroke(None, 1.5)\n        self.play(Write(Main_Circle), run_time=3)\n        self.wait(6)\n        center_big = Dot(radius=0.001, color=GREEN)\n        center_big.move_to(Main_Circle.get_center())\n        self.play(Write(center_big), run_time=2)\n        self.wait(2)\n        medium_circle = self.tangent_circle_pri(Main_Circle, RIGHT, 1, 2, RADIUS / 1.6, BLUE)\n        self.play(Write(medium_circle), run_time=2)\n        self.wait(2)\n        self.wait(7)\n        self.play(WiggleOutThenIn(Main_Circle), run_time=2)\n        self.wait(4)\n        self.play(WiggleOutThenIn(medium_circle), run_time=2)\n        self.wait(6)\n        small_circle = self.tangent_circle_pri(Main_Circle, LEFT, 0, 2, RADIUS - RADIUS / 1.6, PURPLE)\n        self.play(Write(small_circle), run_time=2)\n        self.wait(3)\n        self.wait(7)\n        color = [MAROON_C, RED_D, TEAL_C, BLUE_C, PURPLE_E, ORANGE, TEAL_A, RED_A]\n        circle = []\n        for i in range(-21, 21):\n            c = RADIUS\n            b = RADIUS / 1.6\n            a = c - b\n            if i == 3:\n                q = self.pappus_chain_circle_n(a, b, c, i, 1, YELLOW_C)\n                circle.append(q)\n                self.play(Write(q))\n            elif i == -3:\n                q = self.pappus_chain_circle_n(a, b, c, i, 1, YELLOW_C)\n                circle.append(q)\n                self.play(Write(q))\n            elif i == 0:\n                pass\n            elif -10 <= i <= 10:\n                q = self.pappus_chain_circle_n(a, b, c, i, 1, color[i % 3])\n                circle.append(q)\n                self.play(Write(q), run_time=0.5)\n                self.wait()\n            else:\n                q = self.pappus_chain_circle_n(a, b, c, i, 1, color[i % 3])\n                circle.append(q)\n                self.add(q)\n        self.wait(9)\n        diameter = Line(np.array([-0.25, -0.5, 0]), np.array([5.75, -0.5, 0]))\n        diameter.set_stroke(None, 1.7)\n        diameter.set_color(RED)\n        self.play(Write(diameter), run_time=2)\n        self.wait(3)\n        c = RADIUS\n        b = RADIUS / 1.6\n        a = c - b\n        denominator = pow(3 * a, 2) + b * c\n        rn = a * b * c / denominator\n        xn = -2 * b + b * c * (b + c) / denominator\n        yn = 2 * 3 * rn\n        point1 = Dot(radius=0.05, color=BLUE)\n        point1.move_to([xn + 3.5, yn - 0.5, 0])\n        point2 = Dot(radius=0.05, color=BLUE)\n        point2.move_to([xn + 3.5, -0.5, 0])\n        cir1 = circle[23].copy()\n        cir2 = cir1.copy()\n        cir3 = cir2.copy()\n        self.bring_to_back(cir3)\n        self.play(ApplyMethod(cir1.shift, 2 * rn * DOWN), run_time=2)\n        self.wait()\n        self.play(ApplyMethod(cir2.shift, 4 * rn * DOWN), run_time=2)\n        self.wait()\n        self.play(ApplyMethod(cir3.shift, 6 * rn * DOWN), run_time=2)\n        self.wait()\n        self.play(Write(point1), Write(point2), run_time=3)\n        ll = Line(point2, point1)\n        ll.set_stroke(None, 1.7)\n        ll.set_color(BLUE)\n        self.play(Write(ll), run_time=2)\n        self.wait(3)\n        measure = MeasureDistance(ll).add_tips()\n        measure.set_color(BLUE)\n        measure_tex = measure.get_tex('2\\\\cdot 3\\\\cdot r')\n        measure_tex.set_color(GREEN)\n        rad = TextMobject('Where each circle of yellow colour,\\\\\\\\has a radius of r.')\n        nth = TextMobject('So,For $n^{th}$ circle it is $(2\\\\cross n\\\\cross r_n)$.')\n        nth.set_color(RED)\n        nth.scale(0.8)\n        rad.scale(0.75)\n        rad.next_to(titlem, DOWN)\n        rad.shift(2 * DOWN + 4 * LEFT)\n        rad.set_color(BLUE)\n        nth.next_to(rad, DOWN)\n        self.play(Write(measure), Write(measure_tex), Write(rad), run_time=3)\n        self.wait(8)\n        self.play(Write(nth), run_time=2)\n        self.wait(7)\n        self.play(*[Uncreate(i) for i in self.mobjects], run_time=3)\n        self.wait(5)\n\n    def tangent_circle_pri(self, objectt, Direction, i, n, RADIUS, COLOUR):\n        point = objectt.get_center()\n        at_point = objectt.point_from_proportion(i / n)\n        dd = Dot(radius=1e-07)\n        dd.move_to(at_point)\n        tangent_circle = Circle(radius=RADIUS, color=COLOUR)\n        tangent_circle.set_stroke(None, 1.5)\n        tangent_circle.move_to(point)\n        tangent_circle.next_to(dd, Direction, buff=0)\n        return tangent_circle\n\n    def pappus_chain_circle_n(self, a, b, c, n, opa, COLOUR):\n        denominator = pow(n * a, 2) + b * c\n        xn = -2 * b + b * c * (b + c) / denominator\n        rn = a * b * c / denominator\n        yn = 2 * n * rn\n        circle = Circle(color=COLOUR, radius=rn, fill_opacity=opa)\n        circle.move_to(np.array([xn, yn, 0]))\n        circle.shift(3.5 * RIGHT + 0.5 * DOWN)\n        circle.set_stroke(None, 1.5)\n        return circle"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of inversion through a circle, showing how points and shapes transform."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom collections import namedtuple\nimport numpy as np\nimport math\nimport random\n\nclass Inversion_define(Scene):\n\n    def construct(self):\n        Tit = Title('Inversion through a Circle')\n        Tit.set_color(RED)\n        self.play(Write(Tit), run_time=3)\n        Start = np.array([-4, 2, 0])\n        end = np.array([-4, -2, 0])\n        mirror = Line(Start, end)\n        mirror.set_color(YELLOW)\n        mirror.set_stroke(None, 1.8)\n        mid = np.array([-4, 0, 0])\n        objects = Dot(radius=0.1, color=GREEN)\n        objects.move_to(np.array([-5, 0, 0]))\n        reflection = objects.copy()\n        self.play(FadeIn(mirror), Write(objects), run_time=3)\n        self.wait(4)\n        measure1 = MeasureDistance(Line(objects, mid)).add_tips()\n        measure1.set_color(BLUE)\n        measure_tex1 = measure1.get_tex('x')\n        measure_tex1.scale(0.7)\n        measure_tex1.set_color(GREEN)\n        measure2 = MeasureDistance(Line(np.array([-3, 0, 0]), mid)).add_tips()\n        measure2.set_color(BLUE)\n        measure_tex2 = measure2.get_tex('x')\n        measure_tex2.scale(0.7)\n        measure_tex2.set_color(GREEN)\n        self.play(Write(measure1), Write(measure_tex1))\n        self.wait(3)\n        self.wait(9)\n        self.play(ApplyMethod(reflection.move_to, np.array([-3, 0, 0])), run_time=3)\n        self.play(FadeIn(measure_tex2), FadeIn(measure2))\n        self.wait(3)\n        Tex = TextMobject('So, For Linear mirror \\\\\\\\Object Distance = Reflection Distance(w.r.t mirror).')\n        Tex.next_to(reflection)\n        Tex.scale(0.7)\n        Tex.shift(0.4 * LEFT)\n        Tex.set_color(YELLOW)\n        self.play(Write(Tex), run_time=3)\n        self.wait(10)\n        group = VGroup(mirror, objects, reflection, measure1, measure2, measure_tex1, measure_tex2, Tex)\n        self.play(*[FadeOut(i) for i in group])\n        self.wait(3)\n        circle = Circle(radius=3, color=BLUE)\n        circle.shift(3 * LEFT + 0.5 * DOWN)\n        self.play(Write(circle), run_time=3)\n        self.wait(3)\n        point = Dot(radius=0.05, color=GREEN)\n        origin = circle.get_center()\n        point.move_to(origin)\n        self.play(Write(point), run_time=2)\n        self.wait(3)\n        Patricle = Dot(radius=0.05, color=PURPLE)\n        Patricle.move_to([-1, -1, 0])\n        self.play(Write(Patricle), run_time=2)\n        self.wait(6)\n        measure3 = MeasureDistance(Line(np.array([-6, -0.7, 0]), origin + np.array([0, -0.2, 0]))).add_tips()\n        measure3.set_color(RED)\n        measure_tex3 = measure3.get_tex('R')\n        measure_tex3.scale(0.7)\n        measure_tex3.set_color(YELLOW)\n        self.play(Write(measure_tex3), Write(measure3), run_time=3)\n        self.wait(3)\n        reflection = Patricle.copy()\n        self.play(ApplyMethod(reflection.move_to, rif(3, origin[0], origin[1], -1, -1)), run_time=2)\n        self.wait(5)\n        Names = TexMobject('O', 'P_1', 'P_2')\n        Names.set_color(GREEN)\n        Names.scale(0.7)\n        Names[0].next_to(origin, UP, buff=SMALL_BUFF)\n        Names[0].shift(0.1 * RIGHT)\n        Names[1].next_to(Patricle, UP, buff=SMALL_BUFF)\n        Names[2].next_to(reflection, UP, buff=SMALL_BUFF)\n        self.play(Write(Names), run_time=2)\n        self.wait(6)\n        OP1 = Line(origin, Patricle)\n        OP2 = Line(origin, reflection)\n        GG = VGroup(OP1, OP2)\n        GG.set_stroke(None, 1.5)\n        GG.set_color(RED)\n        self.bring_to_back(GG)\n        reflection.shift(DOWN * 0.01)\n        self.remove(reflection)\n        self.add(reflection)\n        self.play(Write(GG), run_time=2)\n        self.wait(4)\n        Formula = TextMobject('Here Inversion is defined as\\\\\\\\ $OP_1\\\\cross OP_2 = R^2$')\n        Formula.scale(0.7)\n        Formula.set_color(BLUE)\n        Formula.move_to(np.array([4, 2, 0]))\n        self.play(Write(Formula), run_time=2)\n        self.wait(7)\n        before = TextMobject(\"Before moving on\\\\\\\\ let's find some properties.\")\n        before.scale(0.65)\n        before.next_to(Formula, DOWN)\n        before.set_color(GREEN)\n        self.play(Write(before), run_time=2)\n        self.wait(4)\n        self.play(*[FadeOut(i) for i in self.mobjects])\n        self.wait(3)\n        self.wait(4)\n        circle = Circle(color=BLUE)\n        circle.set_stroke(None, 1.5)\n        self.play(Write(circle), run_time=3)\n        self.wait()\n        er = []\n        cood = []\n        for i in range(100):\n            sign1 = random.choice([-1, 1])\n            sign2 = random.choice([-1, 1])\n            x = sign1 * random.random()\n            y = sign2 * random.random()\n            position = np.array([x, y, 0])\n            cood.append(position)\n            q = Dot(radius=0.02)\n            q.move_to(position)\n            if x * x + y * y <= 1:\n                q.set_color(YELLOW)\n            else:\n                q.set_color(RED)\n            er.append(q)\n            self.play(Write(q), run_time=0.01)\n        self.wait(10)\n        self.wait(5)\n        for i in range(100):\n            pp = rif(1, 0, 0, cood[i][0], cood[i][1])\n            self.play(ApplyMethod(er[i].move_to, pp, run_time=0.2))\n        self.wait(4)\n        self.wait(10)\n        Plane = NumberPlane(color=YELLOW)\n        TT = TextMobject('Points inside the circle goes outside\\\\\\\\Points outside of circle comes inside \\\\\\\\and points on the boundary stays there.')\n        TT.set_color(PURPLE)\n        TT.move_to(np.array([-4, -2, 0]))\n        TT.scale(0.65)\n        self.play(Write(TT), run_time=3)\n        self.wait(5)\n        self.remove(*[er[i] for i in range(100)])\n        self.play(FadeOut(TT), run_time=3)\n        self.wait(3)\n        self.play(ApplyMethod(circle.scale, 2), run_time=2)\n        self.wait(3)\n        self.wait(5)\n        Text = TexMobject('OP_2 = \\\\frac{R^2}{OP_1} =\\\\lim_{OP_1\\\\to 0}\\\\frac{R^2}{OP_1}=\\\\infty}')\n        Text.set_color(RED)\n        Text.scale(0.75)\n        Text.move_to(np.array([-4, 2.5, 0]))\n        small_circle = Circle(radius=1, color=YELLOW)\n        small_circle.shift(RIGHT)\n        small_circle.set_stroke(None, 1.6)\n        self.play(Write(small_circle), run_time=2)\n        self.wait(3)\n        pp = Dot(radius=0.08)\n        pp.set_color(MAROON_C)\n        pp.move_to(circle.get_center())\n        self.wait(10)\n        self.play(Write(pp))\n        self.play(WiggleOutThenIn(pp), run_time=3)\n        self.remove(pp)\n        self.play(Write(Text), run_time=2)\n        self.wait(3)\n        pp1 = Dot(radius=0.08)\n        pp1.set_color(MAROON_C)\n        pp1.move_to(np.array([2, 0, 0]))\n        self.play(Write(pp1))\n        self.wait(2)\n        self.play(WiggleOutThenIn(pp1), run_time=2)\n        Text1 = TexMobject('OP_2 = \\\\frac{R^2}{OP_1} =\\\\frac{R^2}{R}=R')\n        Text1.set_color(RED)\n        Text1.scale(0.75)\n        Text1.move_to(np.array([-4, 2.5, 0]))\n        self.play(Transform(Text, Text1), run_time=2)\n        self.wait(5)\n        self.remove(Text, pp1)\n        self.wait(3)\n        self.play(small_circle.apply_function, lambda p: rif(2, 0, 0, p[0], p[1]), run_time=0.1)\n        self.wait(3)\n        self.wait(5)\n        ty = TextMobject(\"So Circles which are tangent to the circle of inversion \\\\\\\\and goes through the inversion circle's center will be \\\\\\\\converted into a straight line,tangent to the circle of inversion.\")\n        ty.set_color(GREEN)\n        ty.scale(0.65)\n        ty.move_to(np.array([-2.5, 2.5, 0]))\n        self.play(Write(ty), run_time=3)\n        self.wait(5)\n        self.wait(5)\n        self.wait(4)\n        self.play(Uncreate(small_circle), FadeOut(ty))\n        ss_circle = Circle(radius=0.66, color=RED, fill_opacity=1)\n        self.bring_to_back(ss_circle)\n        ss_circle.move_to(np.array([-1, 1, 0]))\n        self.play(Write(ss_circle), run_time=2)\n        self.wait(8)\n        self.play(WiggleOutThenIn(ss_circle), run_time=2)\n        self.wait(10)\n        self.play(ss_circle.apply_function, lambda p: rif(2, 0, 0, p[0], p[1]), run_time=3)\n        self.wait(5)\n        TDTFT = TextMobject('So, In circular Inversion circles invert to circles .\\\\\\\\It will only be a straight-line,\\\\\\\\If It goes through the origin.')\n        TDTFT.scale(0.65)\n        TDTFT.next_to(ss_circle, DOWN)\n        TDTFT.shift(3 * DOWN)\n        TDTFT.set_color(YELLOW)\n        self.play(Write(TDTFT), run_time=4)\n        self.wait(6)\n        yy = TextMobject(\"Let's end the property view by seeing\\\\\\\\the transformation of the whole plane.\")\n        yy.next_to(ss_circle, DOWN)\n        yy.shift(3 * DOWN)\n        yy.scale(0.73)\n        yy.set_color(RED)\n        self.play(Transform(TDTFT, yy), run_time=3)\n        self.wait(3)\n        self.play(*[Uncreate(i) for i in self.mobjects], run_time=2)\n        self.wait(2)\n        Plane1 = NumberPlane()\n        Plane1.set_color_by_gradient(RED, BLUE, GREEN, YELLOW, GREEN, BLUE, RED)\n        self.play(Write(Plane1), run_time=2)\n        self.wait(4)\n        Plane1.prepare_for_nonlinear_transform()\n        self.play(Plane1.apply_function, lambda p: rif(3, 0, 0, p[0], p[1]), run_time=3)\n        self.wait(5)\n        self.wait(3)\n        self.play(*[Uncreate(i) for i in self.mobjects], run_time=2)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Demonstrate the construction of a Pappus chain of circles with a main circle, two tangent circles, and subsequent circles in the chain, explaining the process with text and highlighting key elements."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom collections import namedtuple\nimport numpy as np\nimport math\nimport random\n\nclass Solution(Scene):\n\n    def construct(self):\n        titlem = Title('Reflection Of Pappus')\n        titlem.to_edge(UP)\n        titlem.set_color(RED)\n        self.add(titlem)\n        self.wait()\n        RADIUS = 3\n        Main_Circle = Circle(radius=RADIUS, color=DARK_BROWN)\n        Main_Circle.shift(3 * RIGHT + 2 * RADIUS / 1.6 * LEFT)\n        Main_Circle.shift(3.5 * RIGHT + 0.5 * DOWN)\n        Main_Circle.set_stroke(None, 1.7)\n        self.add(Main_Circle)\n        medium_circle = self.tangent_circle_pri(Main_Circle, RIGHT, 1, 2, RADIUS / 1.6, GREEN)\n        self.play(Write(medium_circle))\n        small_circle = self.tangent_circle_pri(Main_Circle, LEFT, 0, 2, RADIUS - RADIUS / 1.6, PURPLE)\n        self.play(Write(small_circle))\n        self.wait(2)\n        color = [MAROON_C, RED_D, TEAL_C, BLUE_C, PURPLE_E, ORANGE, TEAL_A, RED_A]\n        circle = []\n        for i in range(-21, 22):\n            c = RADIUS\n            b = RADIUS / 1.6\n            a = c - b\n            if i == 3:\n                q = self.pappus_chain_circle_n(a, b, c, i, 1, YELLOW_C)\n                circle.append(q)\n                self.play(Write(q))\n            elif i == -3:\n                q = self.pappus_chain_circle_n(a, b, c, i, 1, YELLOW_C)\n                circle.append(q)\n                self.play(Write(q))\n            elif i == 0:\n                pass\n            elif -10 <= i <= 10:\n                q = self.pappus_chain_circle_n(a, b, c, i, 1, color[i % 3])\n                circle.append(q)\n                self.play(Write(q), run_time=0.1)\n                self.wait()\n            else:\n                q = self.pappus_chain_circle_n(a, b, c, i, 1, color[i % 3])\n                circle.append(q)\n                self.add(q)\n        self.wait(9)\n        diameter = Line(np.array([-0.25, -0.5, 0]), np.array([5.75, -0.5, 0]))\n        diameter.set_stroke(None, 1.7)\n        diameter.set_color(RED)\n        self.add(diameter)\n        self.wait(3)\n        pp = NumberPlane()\n        Algorithm1 = TextMobject('1. Take the yellow point as the Center of Inversion\\\\\\\\i.e., center of the inversion circle.')\n        Algorithm2 = TextMobject('2.The circle of inversion is chosen such that \\\\\\\\it is orthogonal with the $n^{th}$ circle.')\n        Algorithm3 = TextMobject('3.Now Invert all the preceding (n-1) circles of the\\\\\\\\ chain one after another and also the small purple circle.')\n        Algorithm = VGroup(Algorithm1, Algorithm2, Algorithm3)\n        Algorithm.scale(0.6)\n        Algorithm3.scale(0.8)\n        Algorithm.set_color(YELLOW)\n        Algorithm[0].next_to(titlem, DOWN)\n        Algorithm[0].shift(3.5 * LEFT)\n        Algorithm[1].next_to(Algorithm[0], DOWN)\n        Algorithm[1].shift(0.5 * LEFT)\n        Algorithm[2].next_to(Algorithm[1], DOWN)\n        Main_Circle_copy = Main_Circle.copy()\n        Main_Circle_copy.shift(LEFT * RADIUS)\n        self.wait(14)\n        ori = Main_Circle_copy.get_center()\n        origin = Dot(radius=0.05, color=YELLOW)\n        origin.move_to(ori)\n        self.play(Write(origin), run_time=2)\n        self.wait(5)\n        self.wait(5)\n        self.play(Write(Algorithm[0]), run_time=2)\n        self.wait(4)\n        self.play(Write(Algorithm[1]), run_time=2)\n        self.wait(4)\n        self.play(Write(Algorithm[2]), run_time=2)\n        self.wait(7)\n        self.play(WiggleOutThenIn(circle[23]))\n        self.wait(2)\n        self.play(WiggleOutThenIn(circle[23]))\n        self.wait(4)\n        self.wait(10)\n        c = RADIUS\n        b = RADIUS / 1.6\n        a = c - b\n        denominator = pow(3 * a, 2) + b * c\n        x3 = -2 * b + b * c * (b + c) / denominator\n        r3 = a * b * c / denominator\n        invert_of_big = Line(np.array([x3 - r3, -FRAME_Y_RADIUS, 0]), np.array([x3 - r3, FRAME_Y_RADIUS, 0]))\n        invert_of_big.shift(3.5 * RIGHT)\n        invert_of_big.set_color(DARK_BROWN)\n        invert_of_big.set_stroke(None, 1.7)\n        qwe = Main_Circle.copy()\n        radd = np.sqrt((ori[0] - (x3 + 3.5)) ** 2 + (ori[1] - 1.9) ** 2)\n        print(ori)\n        print(radd)\n        inversion_circle = Circle(radius=radd - 0.16, color=GREEN)\n        inversion_circle.set_stroke(None, 1.7)\n        inversion_circle.move_to(ori)\n        self.play(Write(inversion_circle), run_time=2)\n        self.wait(4)\n        self.play(Flash(origin), color=YELLOW)\n        self.wait(2)\n        self.wait(12)\n        Main_Circle_copy.shift(RIGHT * RADIUS)\n        self.play(Transform(qwe, invert_of_big))\n        self.wait(5)\n        invert_of_middle = Line(np.array([x3 + r3, -FRAME_Y_RADIUS, 0]), np.array([x3 + r3, FRAME_Y_RADIUS, 0]))\n        invert_of_middle.shift(3.5 * RIGHT)\n        invert_of_middle.set_color(GREEN)\n        invert_of_middle.set_stroke(None, 1.7)\n        qwee = medium_circle.copy()\n        self.play(Transform(qwee, invert_of_middle))\n        self.wait(5)\n        self.play(WiggleOutThenIn(circle[22]), WiggleOutThenIn(circle[21]), WiggleOutThenIn(small_circle), run_time=2)\n        self.wait(5)\n        self.play(circle[22].copy().apply_function, lambda p: rif(radd - 0.16, ori[0], ori[1], p[0], p[1]), run_time=2)\n        self.wait()\n        self.play(circle[21].copy().apply_function, lambda p: rif(radd - 0.16, ori[0], ori[1], p[0], p[1]), run_time=2)\n        self.wait()\n        self.play(small_circle.copy().apply_function, lambda p: rif(radd - 0.16, ori[0], ori[1], p[0], p[1]), run_time=2)\n        self.wait(5)\n        self.play(FadeOut(inversion_circle), run_time=2)\n        self.wait(10)\n        FGH = TextMobject('As there are (n-1) chain circles and 1 Extra circle.\\\\\\\\so $y_n = n\\\\cross d_n = 2n \\\\cross r_n$ ($d_n$= diameter of the $n^{th}$ circle).')\n        FGH.set_color(BLUE)\n        FGH.next_to(Algorithm3, DOWN)\n        FGH.scale(0.6)\n        FGH.shift(2 * DOWN + RIGHT * 0.5)\n        self.play(Write(FGH), run_time=5)\n        self.wait(10)\n        self.wait(3)\n        self.play(*[ShrinkToCenter(i) for i in self.mobjects], run_time=2)\n        self.wait(5)\n\n    def tangent_circle_pri(self, objectt, Direction, i, n, RADIUS, COLOUR):\n        point = objectt.get_center()\n        at_point = objectt.point_from_proportion(i / n)\n        dd = Dot(radius=1e-07)\n        dd.move_to(at_point)\n        tangent_circle = Circle(radius=RADIUS, color=COLOUR)\n        tangent_circle.set_stroke(None, 1.5)\n        tangent_circle.move_to(point)\n        tangent_circle.next_to(dd, Direction, buff=0)\n        return tangent_circle\n\n    def pappus_chain_circle_n(self, a, b, c, n, opa, COLOUR):\n        denominator = pow(n * a, 2) + b * c\n        xn = -2 * b + b * c * (b + c) / denominator\n        rn = a * b * c / denominator\n        yn = 2 * n * rn\n        circle = Circle(color=COLOUR, radius=rn, fill_opacity=opa)\n        circle.move_to(np.array([xn, yn, 0]))\n        circle.shift(3.5 * RIGHT + 0.5 * DOWN)\n        circle.set_stroke(None, 1.5)\n        return circle"}]}
{"messages": [{"role": "user", "content": "Display a gradient-colored text message that reads \"If you want things related to this comment below. Seeing You Next Time---By AzavZya\" and hold it for ten seconds."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom collections import namedtuple\nimport numpy as np\nimport math\nimport random\n\nclass Endingsq(Scene):\n\n    def construct(self):\n        FQQ = TextMobject('If you want things related to this comment below. \\\\\\\\Seeing You Next Time---By AzavZya')\n        FQQ.set_color_by_gradient(RED, GREEN, BLUE, PURPLE)\n        self.play(Write(FQQ), run_time=2)\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Display a checkered circle."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom collections import namedtuple\nimport numpy as np\nimport math\nimport random\n\nclass Check(Scene):\n\n    def construct(self):\n        dd = CheckeredCircle()\n        self.add(dd)"}]}
{"messages": [{"role": "user", "content": "Animate a series of expanding triangles and circles, followed by transformations on planes and the display of image assets."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom Austin_new.Reflections_On_Pappus import *\n\nclass OpeningScene(Scene):\n\n    def func(self, t):\n        return np.array([t * t - 0.5, 1.4 * t, 0])\n\n    def construct(self):\n        dot = Dot()\n        dot_end = Dot()\n        plane = NumberPlane()\n        plane.set_color_by_gradient(YELLOW, ORANGE, GREEN)\n        self.add(plane)\n        square = Square()\n        self.wait(1)\n        self.add(dot)\n        self.wait(0.1)\n        q = []\n        c = []\n        for k in range(1, 4):\n            triangle = Polygon(k * np.array([1, 0, 0]), k * np.array([0, 1, 0]), k * np.array([1, 1, 0]))\n            self.play(Transform(dot, triangle))\n            self.add(triangle)\n            q.append(triangle)\n            triangle = Polygon(k * np.array([0, -1, 0]), k * np.array([1, 0, 0]), k * np.array([1, -1, 0]))\n            self.play(Transform(dot, triangle))\n            self.add(triangle)\n            q.append(triangle)\n            triangle = Polygon(k * np.array([-1, 0, 0]), k * np.array([0, -1, 0]), k * np.array([-1, -1, 0]))\n            self.play(Transform(dot, triangle))\n            self.add(triangle)\n            q.append(triangle)\n            triangle = Polygon(k * np.array([0, 1, 0]), k * np.array([-1, 0, 0]), k * np.array([-1, 1, 0]))\n            self.play(Transform(dot, triangle))\n            self.add(triangle)\n            q.append(triangle)\n            self.wait(0.1)\n        for k in range(1, 4):\n            circle = Circle(radius=k)\n            circle.set_fill(GREEN, opacity=0.2)\n            self.play(Transform(dot, circle))\n            self.add(circle)\n            self.play(Transform(dot, dot_end))\n            self.wait(0.1)\n            c.append(circle)\n        self.wait(0.2)\n        group = VGroup(*[q[i] for i in range(len(q))], *[c[i] for i in range(len(c))])\n        self.play(group.apply_function, lambda p: rif(2, 0, 0, p[0], p[1]), run_time=2)\n        self.play(*[FadeOut(i) for i in self.mobjects])\n        func = ParametricFunction(self.func, t_min=-TAU, t_max=TAU, fill_opacity=0)\n        func.set_color_by_gradient(BLUE, RED)\n        self.play(Write(func))\n        self.play(func.apply_function, lambda p: rif(1, 0, 0, p[0], p[1]), run_time=2)\n        self.play(*[FadeOut(i) for i in self.mobjects])\n        Plane1 = NumberPlane()\n        Plane1.set_color_by_gradient(RED, BLUE, GREEN, YELLOW, GREEN, BLUE, RED)\n        self.add(Plane1)\n        self.wait()\n        Plane1.prepare_for_nonlinear_transform()\n        self.play(Plane1.apply_function, lambda p: rif(3, 0, 0, p[0], p[1]), run_time=2)\n        self.wait(10)\n        img1 = ImageMobject('cheenta1')\n        img1.scale(2)\n        img1.shift(3.5 * LEFT + 2 * UP)\n        img2 = ImageMobject('cheenta2')\n        img2.scale(2)\n        img2.next_to(img1, RIGHT)\n        img3 = ImageMobject('cheenta3')\n        img3.scale(2)\n        img3.next_to(img1, DOWN)\n        img3.shift(2 * RIGHT)\n        self.add(img1, img2, img3)\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of inversion through a circle with a point's reflection, explaining the formula $OP_1 \\times OP_2 = R^2$."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom Austin_new.Reflections_On_Pappus import *\n\nclass Introduction(Scene):\n\n    def construct(self):\n        Tit = Title('Inversion through a Circle')\n        Tit.set_color(RED)\n        self.play(Write(Tit), run_time=3)\n        Start = np.array([-4, 2, 0])\n        end = np.array([-4, -2, 0])\n        mirror = Line(Start, end)\n        mirror.set_color(YELLOW)\n        mirror.set_stroke(None, 1.8)\n        mid = np.array([-4, 0, 0])\n        objects = Dot(radius=0.1, color=GREEN)\n        objects.move_to(np.array([-5, 0, 0]))\n        reflection = objects.copy()\n        self.play(FadeIn(mirror), Write(objects), run_time=3)\n        self.wait(4)\n        measure1 = MeasureDistance(Line(objects, mid)).add_tips()\n        measure1.set_color(BLUE)\n        measure_tex1 = measure1.get_tex('x')\n        measure_tex1.scale(0.7)\n        measure_tex1.set_color(GREEN)\n        measure2 = MeasureDistance(Line(np.array([-3, 0, 0]), mid)).add_tips()\n        measure2.set_color(BLUE)\n        measure_tex2 = measure2.get_tex('x')\n        measure_tex2.scale(0.7)\n        measure_tex2.set_color(GREEN)\n        self.play(Write(measure1), Write(measure_tex1))\n        self.wait(3)\n        self.wait(9)\n        self.play(ApplyMethod(reflection.move_to, np.array([-3, 0, 0])), run_time=3)\n        self.play(FadeIn(measure_tex2), FadeIn(measure2))\n        self.wait(3)\n        Tex = TextMobject('So, For Linear mirror \\\\\\\\Object Distance = Reflection Distance(w.r.t mirror).')\n        Tex.next_to(reflection)\n        Tex.scale(0.7)\n        Tex.shift(0.4 * LEFT)\n        Tex.set_color(YELLOW)\n        self.play(Write(Tex), run_time=3)\n        self.wait(10)\n        group = VGroup(mirror, objects, reflection, measure1, measure2, measure_tex1, measure_tex2, Tex)\n        self.play(*[FadeOut(i) for i in group])\n        self.wait(3)\n        circle = Circle(radius=3, color=BLUE)\n        circle.shift(3 * LEFT + 0.5 * DOWN)\n        self.play(Write(circle), run_time=3)\n        self.wait(3)\n        point = Dot(radius=0.05, color=GREEN)\n        origin = circle.get_center()\n        point.move_to(origin)\n        self.play(Write(point), run_time=2)\n        self.wait(3)\n        Patricle = Dot(radius=0.05, color=PURPLE)\n        Patricle.move_to([-1, -1, 0])\n        self.play(Write(Patricle), run_time=2)\n        self.wait(6)\n        measure3 = MeasureDistance(Line(np.array([-6, -0.7, 0]), origin + np.array([0, -0.2, 0]))).add_tips()\n        measure3.set_color(RED)\n        measure_tex3 = measure3.get_tex('R')\n        measure_tex3.scale(0.7)\n        measure_tex3.set_color(YELLOW)\n        self.play(Write(measure_tex3), Write(measure3), run_time=3)\n        self.wait(3)\n        reflection = Patricle.copy()\n        self.play(ApplyMethod(reflection.move_to, rif(3, origin[0], origin[1], -1, -1)), run_time=2)\n        self.wait(5)\n        Names = TexMobject('O', 'P_1', 'P_2')\n        Names.set_color(GREEN)\n        Names.scale(0.7)\n        Names[0].next_to(origin, UP, buff=SMALL_BUFF)\n        Names[0].shift(0.1 * RIGHT)\n        Names[1].next_to(Patricle, UP, buff=SMALL_BUFF)\n        Names[2].next_to(reflection, UP, buff=SMALL_BUFF)\n        self.play(Write(Names), run_time=2)\n        self.wait(6)\n        OP1 = Line(origin, Patricle)\n        OP2 = Line(origin, reflection)\n        GG = VGroup(OP1, OP2)\n        GG.set_stroke(None, 1.5)\n        GG.set_color(RED)\n        self.bring_to_back(GG)\n        reflection.shift(DOWN * 0.01)\n        self.remove(reflection)\n        self.add(reflection)\n        self.play(Write(GG), run_time=2)\n        self.wait(4)\n        Formula = TextMobject('Here Inversion is defined as\\\\\\\\ $OP_1\\\\cross OP_2 = R^2$')\n        Formula.scale(0.7)\n        Formula.set_color(BLUE)\n        Formula.move_to(np.array([4, 2, 0]))\n        self.play(Write(Formula), run_time=2)\n        self.wait(5)\n        things1 = TextMobject('Remember $P_1$ and $P_2$ are colinear.')\n        things1.scale(0.6)\n        things1.set_color(YELLOW)\n        things1.next_to(Formula, DOWN)\n        self.add(things1)\n        self.wait(9)"}]}
{"messages": [{"role": "user", "content": "Demonstrate the properties of inversion with a circle, a point, and a line segment, showing their transformations and related formulas."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom Austin_new.Reflections_On_Pappus import *\n\nclass Propterties(MovingCameraScene):\n\n    def construct(self):\n        Tit = Title('Region and Length')\n        Tit.set_color(RED)\n        self.play(Write(Tit), run_time=3)\n        self.wait(2)\n        self.wait(8)\n        circle_of_inversion = Circle(color=BLUE, radius=2)\n        self.play(Write(circle_of_inversion))\n        self.wait(6)\n        point = Dot(radius=0.05, color=YELLOW)\n        point.move_to(np.array([0.5, 0.5, 0]))\n        self.play(Write(point))\n        ray = Line(ORIGIN, point.get_center())\n        ray.set_color(GREEN)\n        ray.set_stroke(None, 1.7)\n        self.play(Write(ray))\n        self.wait(4)\n        Formula = TexMobject('OP_2=\\\\frac{R^2}{\\tOP_1}')\n        Formula.set_color(BLUE)\n        Formula.scale(0.7)\n        Formula.move_to(np.array([3.5, 2, 0]))\n        self.play(Write(Formula))\n        Form = TexMobject('OP_1< R')\n        Form.set_color(RED)\n        Form.scale(0.6)\n        Form.align_to(Formula, LEFT)\n        Form.shift(1.2 * UP)\n        self.add(Form)\n        self.wait(5)\n        Form3 = TexMobject('OP_2=\\\\frac{R^2}{OP_1}>\\\\frac{R^2}{R}')\n        Form3.scale(0.7)\n        Form3.set_color(BLUE)\n        Form3.next_to(Form, DOWN)\n        Form3.align_to(Formula, LEFT)\n        self.play(Write(Form3))\n        self.wait(7)\n        self.play(FadeOut(Tit))\n        refPos = rif(2, 0, 0, 0.5, 0.5)\n        self.wait(2)\n        image = point.copy()\n        self.play(self.camera_frame.set_height, self.camera_frame.get_width() * 0.6, run_time=2)\n        self.play(ApplyMethod(image.move_to, refPos), run_time=2)\n        rayim = Line(ORIGIN, refPos)\n        rayim.set_color(GREEN)\n        rayim.set_stroke(None, 1.7)\n        self.play(Write(rayim))\n        self.wait(11)\n        self.remove(*[i for i in self.mobjects])\n        self.add(circle_of_inversion)\n        self.wait(4)\n        er = []\n        cood = []\n        for i in range(100):\n            sign1 = random.choice([-2, 2])\n            sign2 = random.choice([-2, 2])\n            x = sign1 * random.random()\n            y = sign2 * random.random()\n            position = np.array([x, y, 0])\n            cood.append(position)\n            q = Dot(radius=0.02)\n            q.move_to(position)\n            if x * x + y * y <= 4:\n                q.set_color(YELLOW)\n            else:\n                q.set_color(RED)\n            er.append(q)\n            self.play(Write(q), run_time=0.01)\n        self.wait(10)\n        self.wait(5)\n        for i in range(100):\n            pp = rif(2, 0, 0, cood[i][0], cood[i][1])\n            self.play(ApplyMethod(er[i].move_to, pp, run_time=0.2))\n        self.wait(4)\n        self.wait(10)\n        self.wait(8)\n        Formula = TexMobject('OP_2=\\\\frac{R^2}{\\tR}=R')\n        Formula.set_color(BLUE)\n        Formula.scale(0.7)\n        Formula.move_to(np.array([3.5, 2, 0]))\n        self.play(Write(Formula))\n        self.wait(3)\n        self.wait(8)\n        self.remove(Formula, *[er[i] for i in range(len(er))])\n        self.wait(3)\n        center = Dot(radius=0.04, color=PURPLE)\n        self.add(center)\n        self.wait(5)\n        a = Dot(radius=0.04, color=YELLOW)\n        a.move_to(np.array([-1.5, 0.5, 0]))\n        b = Dot(radius=0.04, color=YELLOW)\n        b.move_to(np.array([-1, -0.6, 0]))\n        self.play(Write(a), Write(b))\n        lline = Line(a.get_center(), b.get_center())\n        lline.set_color(YELLOW)\n        lline.set_stroke(None, 1.7)\n        self.wait(8)\n        self.play(Write(lline))\n        self.wait(2)\n        self.wait(6)\n        a_img = rif(2, 0, 0, a.get_center()[0], a.get_center()[1])\n        b_img = rif(2, 0, 0, b.get_center()[0], b.get_center()[1])\n        a_re = a.copy()\n        b_re = b.copy()\n        a_re.set_color(GREEN)\n        b_re.set_color(GREEN)\n        self.play(ApplyMethod(a_re.move_to, a_img), ApplyMethod(b_re.move_to, b_img), run_time=2)\n        self.wait(2)\n        self.play(self.camera_frame.set_height, self.camera_frame.get_width() * 0.3, run_time=2)\n        self.wait(3)\n        a1 = TexMobject('a')\n        b1 = TexMobject('b')\n        a1.set_color(YELLOW)\n        b1.set_color(YELLOW)\n        a2 = TexMobject('\\\\bar{a}')\n        b2 = TexMobject('\\\\bar{b}')\n        a2.set_color(GREEN)\n        b2.set_color(GREEN)\n        group1 = VGroup(a, b, a_re, b_re)\n        group2 = VGroup(a1, b1, a2, b2)\n        group2.scale(0.6)\n        for i in range(4):\n            if i % 2 == 0:\n                group2[i].next_to(group1[i], UP, buff=SMALL_BUFF)\n            else:\n                group2[i].next_to(group1[i], DOWN, buff=SMALL_BUFF)\n        self.play(Write(group2), run_time=2)\n        self.wait(5)\n        self.wait(9)\n        lline_re = Line(a_re.get_center(), b_re.get_center())\n        lline_re.set_color(GREEN)\n        lline_re.set_stroke(None, 1.7)\n        self.play(Write(lline_re))\n        self.wait(8)\n        ex1 = Line(ORIGIN, a_re.get_center())\n        ex2 = Line(ORIGIN, b_re.get_center())\n        ex1.set_color(RED)\n        ex2.set_color(RED)\n        ex1.set_stroke(None, 1.7)\n        ex2.set_stroke(None, 1.7)\n        self.play(Write(ex2), Write(ex1))\n        self.remove(group1)\n        self.add(group1)\n        self.wait(3)\n        O = TexMobject('O')\n        O.scale(0.6)\n        O.next_to(center, RIGHT, buff=SMALL_BUFF)\n        self.play(Write(O))\n        self.wait(6)\n        formula2 = TexMobject('Oa\\\\cross O\\\\bar{a}=Ob\\\\cross O\\\\bar{b}=R^2')\n        formula2.scale(0.45)\n        formula2.set_color(ORANGE)\n        formula2.move_to(np.array([2, 1.5, 0]))\n        self.play(Write(formula2))\n        self.wait(5)\n        self.wait(4)\n        triangle1 = Polygon(center.get_center(), a.get_center(), b.get_center())\n        triangle2 = Polygon(center.get_center(), a_re.get_center(), b_re.get_center())\n        triangle1.set_color(YELLOW)\n        triangle2.set_color(GREEN)\n        self.play(WiggleOutThenIn(triangle1))\n        self.remove(triangle1)\n        self.play(WiggleOutThenIn(triangle2))\n        self.remove(triangle2)\n        self.wait(3)\n        formula1 = TexMobject('\\\\bar{a}\\\\bar{b}=\\\\frac{R^2}{Oa\\\\cross Ob}(ab)')\n        formula1.scale(0.5)\n        formula1.set_color(ORANGE)\n        formula1.move_to(np.array([3, 1.5, 0]))\n        self.play(Transform(formula2, formula1), run_time=2)\n        self.wait(10)\n        self.play(*[Uncreate(i) for i in self.mobjects], run_time=2)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Demonstrate the preservation of circles under inversion by animating a main circle and several smaller dots, showing their transformations and concluding with a textual explanation."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom Austin_new.Reflections_On_Pappus import *\n\nclass Propterty2(MovingCameraScene):\n\n    def construct(self):\n        self.wait(2)\n        Tit = Title('Preservation of Circles')\n        Tit.set_color(RED)\n        self.play(Write(Tit), run_time=3)\n        self.wait(5)\n        main_Circle = Circle(radius=2, color=BLUE)\n        self.play(Write(main_Circle))\n        self.wait(3)\n        circle1 = Dot(radius=0.4, color=GREEN)\n        circle1.move_to(np.array([-1, 0.9, 0]))\n        self.wait(5)\n        self.play(FadeIn(circle1))\n        self.wait(2)\n        self.wait(8)\n        circle2 = Dot(radius=0.06, color=RED)\n        circle3 = Dot(radius=0.06, color=YELLOW)\n        circle2.move_to(np.array([-0.85, 0.65, 0]))\n        circle3.move_to(np.array([-1.2, 1, 0]))\n        self.play(Write(circle2))\n        self.play(Write(circle3))\n        self.wait(3)\n        group = VGroup(circle1, circle2, circle3)\n        circle2_pos = rif(2, 0, 0, circle2.get_center()[0], circle2.get_center()[1])\n        circle3_pos = rif(2, 0, 0, circle3.get_center()[0], circle3.get_center()[1])\n        self.wait(5)\n        self.play(Uncreate(Tit))\n        self.play(group.apply_function, lambda p: rif(2, 0, 0, p[0], p[1]), ApplyMethod(circle2.move_to, circle2_pos), ApplyMethod(circle3.move_to, circle3_pos), run_time=2)\n        self.wait(3)\n        self.wait(8)\n        self.play(FadeOut(group))\n        self.wait(2)\n        ss_circle = Circle(radius=0.66, color=RED, fill_opacity=1)\n        self.bring_to_back(ss_circle)\n        ss_circle.move_to(np.array([-1, 1, 0]))\n        self.play(Write(ss_circle), run_time=2)\n        self.wait(4)\n        self.camera_frame.save_state()\n        self.play(self.camera_frame.set_height, self.camera_frame.get_width() * 0.6, run_time=2)\n        self.wait(8)\n        self.wait(10)\n        self.play(ss_circle.apply_function, lambda p: rif(2, 0, 0, p[0], p[1]), run_time=3)\n        self.wait(3)\n        self.remove(ss_circle)\n        self.wait(2)\n        self.wait(4)\n        Text = TexMobject('OP_2 = \\\\frac{R^2}{OP_1} =\\\\lim_{OP_1\\\\to 0}\\\\frac{R^2}{OP_1}=\\\\infty}')\n        Text.set_color(RED)\n        Text.scale(0.75)\n        Text.move_to(np.array([-4, 2.5, 0]))\n        small_circle = Circle(radius=1, color=YELLOW)\n        small_circle.shift(RIGHT)\n        small_circle.set_stroke(None, 1.6)\n        self.wait(10)\n        self.play(Write(small_circle), run_time=2)\n        self.wait(3)\n        pp = Dot(radius=0.08)\n        pp.set_color(MAROON_C)\n        pp.move_to(main_Circle.get_center())\n        self.wait(10)\n        self.wait(3)\n        self.play(Write(pp))\n        self.play(WiggleOutThenIn(pp), run_time=3)\n        self.remove(pp)\n        self.play(Write(Text), run_time=2)\n        self.wait(3)\n        pp1 = Dot(radius=0.08)\n        pp1.set_color(MAROON_C)\n        pp1.move_to(np.array([2, 0, 0]))\n        self.play(Write(pp1))\n        self.wait(2)\n        self.play(WiggleOutThenIn(pp1), run_time=2)\n        Text1 = TexMobject('OP_2 = \\\\frac{R^2}{OP_1} =\\\\frac{R^2}{R}=R')\n        Text1.set_color(RED)\n        Text1.scale(0.75)\n        Text1.move_to(np.array([-4, 2.5, 0]))\n        self.play(Transform(Text, Text1), run_time=2)\n        self.wait(5)\n        self.remove(Text, pp1)\n        self.wait(3)\n        self.play(small_circle.apply_function, lambda p: rif(2, 0, 0, p[0], p[1]), run_time=0.1)\n        self.wait(3)\n        self.wait(5)\n        ty = TextMobject(\"So Circles which goes through the inversion circle's center will be \\\\\\\\converted into a straight line,tangent to the circle of inversion.\")\n        ty.set_color(GREEN)\n        ty.scale(0.65)\n        ty.move_to(np.array([-2.5, 2.5, 0]))\n        self.play(Write(ty), run_time=3)\n        self.wait(5)\n        self.play(Uncreate(small_circle), FadeOut(ty))\n        self.wait(10)\n        self.play(*[FadeOut(i) for i in self.mobjects])\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Visualize Ptolemy's Theorem by drawing a circle, inscribing a quadrilateral, labeling its vertices and sides, and then demonstrating the theorem's formula through a series of transformations and text animations, including inversive geometry concepts."}, {"role": "assistant", "content": "from manimlib.imports import *\nfrom Austin_new.Reflections_On_Pappus import *\n\nclass Ptolemy_Theorem(MovingCameraScene):\n\n    def construct(self):\n        Tit = Title(\"Ptolemy's Theorem\")\n        Tit.set_color(RED)\n        self.play(Write(Tit), run_time=2)\n        self.wait(5)\n        self.wait(3)\n        circle = Circle(radius=2, color=YELLOW)\n        self.play(Write(circle))\n        self.wait(2)\n        self.wait(5)\n        d_pos = circle.point_from_proportion(0)\n        d = Dot(radius=0.07, color=BLUE)\n        d.move_to(d_pos)\n        a_pos = circle.point_from_proportion(1 / 4)\n        a = Dot(radius=0.07, color=BLUE)\n        a.move_to(a_pos)\n        b_pos = circle.point_from_proportion(6 / 11)\n        b = Dot(radius=0.07, color=BLUE)\n        b.move_to(b_pos)\n        c_pos = circle.point_from_proportion(9 / 11)\n        c = Dot(radius=0.07, color=BLUE)\n        c.move_to(c_pos)\n        corners = VGroup(d, a, b, c)\n        quadrilaterial = Polygon(*[corners[i].get_center() for i in range(len(corners))])\n        quadrilaterial.set_color(ORANGE)\n        quadrilaterial.set_stroke(None, 1.7)\n        self.play(Write(quadrilaterial), run_time=2)\n        self.add(corners)\n        self.wait(3)\n        self.wait(5)\n        Theorem = TextMobject('The sum of the product of the opposite sides is the Product of the diagonals.')\n        Theorem.set_color(GREEN)\n        Theorem.scale(0.7)\n        Theorem.shift(2.7 * DOWN)\n        self.play(Write(Theorem))\n        self.wait(5)\n        d_tex = TextMobject('d')\n        a_tex = TextMobject('a')\n        b_tex = TextMobject('b')\n        c_tex = TextMobject('c')\n        names = VGroup(d_tex, a_tex, b_tex, c_tex)\n        names.set_color(RED)\n        names.scale(0.9)\n        d_tex.next_to(d, RIGHT, buff=SMALL_BUFF)\n        a_tex.next_to(a, UP, buff=SMALL_BUFF)\n        b_tex.next_to(b, LEFT, buff=SMALL_BUFF)\n        c_tex.next_to(c, LEFT + DOWN, buff=SMALL_BUFF)\n        self.play(Write(names), lag_ratio=0.5)\n        self.wait(2)\n        theorem = TexMobject('(ad\\\\cross bc) + (ab \\\\cross cd) = ac \\\\cross bd')\n        theorem.scale(0.8)\n        theorem.next_to(Theorem, DOWN)\n        theorem.set_color(YELLOW)\n        self.play(Write(theorem), run_time=2)\n        self.wait(5)\n        self.wait(8)\n        self.play(FadeOut(Tit), FadeOut(Theorem), FadeOut(theorem), run_time=2)\n        self.camera_frame.save_state()\n        self.wait(15)\n        self.play(Flash(a, color=RED, flash_radius=0.5))\n        self.wait(5)\n        self.play(self.camera_frame.set_height, self.camera_frame.get_width() * 1.05, run_time=2)\n        invertcircle = Circle(radius=4.4, color=PURPLE)\n        invertcircle.set_stroke(None, 1.5)\n        invertcircle.move_to(a_pos)\n        self.play(ShowCreation(invertcircle), run_time=2)\n        self.wait(3)\n        self.play(Restore(self.camera_frame))\n        self.wait(2)\n        d_rif = rif(4.4, a_pos[0], a_pos[1], d.get_center()[0], d.get_center()[1])\n        b_rif = rif(4.4, a_pos[0], a_pos[1], b.get_center()[0], b.get_center()[1])\n        c_rif = rif(4.4, a_pos[0], a_pos[1], c.get_center()[0], c.get_center()[1])\n        d_re = d.copy()\n        b_re = b.copy()\n        c_re = c.copy()\n        self.wait(7)\n        self.remove(quadrilaterial)\n        ll = Line(np.array([-50, d_rif[1], 0]), np.array([50, d_rif[1], 0]))\n        ll.set_color(YELLOW)\n        ll.set_stroke(None, 1.6)\n        self.play(Transform(circle.copy(), ll), ApplyMethod(d_re.move_to, d_rif), ApplyMethod(b_re.move_to, b_rif), ApplyMethod(c_re.move_to, c_rif), run_time=3)\n        self.wait(3)\n        d_rif_tex = TexMobject('\\\\bar{d}')\n        b_rif_tex = TexMobject('\\\\bar{b}')\n        c_rif_tex = TexMobject('\\\\bar{c}')\n        rif_tex = VGroup(d_rif_tex, b_rif_tex, c_rif_tex)\n        rif_tex.scale(0.85)\n        rif_tex.set_color(RED)\n        riff = VGroup(d_re, b_re, c_re)\n        for i in range(len(riff)):\n            rif_tex[i].next_to(riff[i], DOWN, buff=SMALL_BUFF)\n        self.wait(5)\n        self.play(Write(rif_tex))\n        self.wait(3)\n        self.wait(6)\n        abb = Line(a.get_center(), b_re.get_center())\n        acc = Line(a.get_center(), c_re.get_center())\n        add = Line(a.get_center(), d_re.get_center())\n        lines = VGroup(abb, acc, add)\n        lines.set_stroke(None, 1.6)\n        lines.set_color(GREEN)\n        self.bring_to_back(lines)\n        self.play(Write(lines))\n        self.wait(3)\n        self.camera_frame.save_state()\n        self.play(ApplyMethod(self.camera_frame.shift, 2.5 * RIGHT), run_time=2)\n        self.wait(3)\n        self.wait(4)\n        cal = TexMobject('\\\\bar{b}\\\\bar{c}+\\\\bar{c}\\\\bar{d}=\\\\bar{b}\\\\bar{d}')\n        cal.set_color(RED)\n        cal.scale(0.9)\n        cal.move_to(np.array([7, 3, 0]))\n        self.play(Write(cal), run_time=2)\n        self.wait(3)\n        self.wait(5)\n        formula1 = TexMobject('\\\\bar{a}\\\\bar{b}=\\\\frac{R^2}{Oa\\\\cross Ob}(ab)')\n        formula1.scale(0.6)\n        formula1.set_color(ORANGE)\n        formula1.next_to(cal, DOWN)\n        self.play(Write(formula1))\n        self.wait(4)\n        self.play(WiggleOutThenIn(formula1))\n        self.wait(4)\n        self.play(FadeOut(formula1))\n        self.wait(3)\n        self.wait(3)\n        call = TexMobject('\\\\frac{bc}{(ab\\\\cross ac)} +\\\\frac{cd}{(ac\\\\cross ad)}=\\\\frac{bd}{(ab\\\\cross ad)}')\n        call.set_color(BLUE)\n        call.scale(0.6)\n        call.next_to(cal, DOWN)\n        self.play(Write(call), run_time=2)\n        self.wait(3)\n        self.wait(4)\n        tt = TextMobject('Multiplying by $(ab\\\\cross ac \\\\cross ad)$')\n        tt.scale(0.6)\n        tt.next_to(call, DOWN)\n        self.play(Write(tt))\n        self.wait(3)\n        self.wait(4)\n        final = TexMobject('(ad\\\\cross bc) + (ab \\\\cross cd) = ac \\\\cross bd')\n        final.next_to(call, DOWN)\n        final.set_color(YELLOW)\n        final.scale(0.7)\n        self.play(Transform(tt, final))\n        self.wait(9)\n        self.play(*[FadeOut(i) for i in self.mobjects])\n        self.play(Restore(self.camera_frame))\n        self.wait(3)\n        tt6 = TextMobject('In the next video we will learn some other\\\\\\\\properties and will solve another problem.')\n        tt6.set_color_by_gradient(RED, ORANGE, YELLOW, GREEN, BLUE)\n        tt6.shift(2.5 * UP)\n        self.play(Write(tt6), run_time=2)\n        self.wait(8)"}]}
{"messages": [{"role": "user", "content": "Animate the inversion of a smaller circle within a larger circle."}, {"role": "assistant", "content": "from manimlib.imports import *\nimport numpy as np\n\nclass Inversion_define(Scene):\n\n    def construct(self):\n        rad = 3\n        cc = Circle(radius=3, color=BLUE)\n        tt = Circle(radius=1.5, color=YELLOW_C)\n        tt.shift(1.5 * RIGHT)\n        r = tt.copy()\n        self.add(cc, tt)\n        self.play(cc.apply_function, lambda p: np.array([rif(rad, 0, 0, p[0], p[1])[0], rif(rad, 0, 0, p[0], p[1])[1], 0]), tt.apply_function, lambda p: rif(rad, 0, 0, p[0], p[1]), run_time=5)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Animate a wooden box moving and returning to its original position, followed by an Earth rotating and a sun appearing, all while displaying a title about frames of reference."}, {"role": "assistant", "content": "from manimlib import *\nimport numpy as np\nfrom math import radians as rad, degrees as deg\n\nclass opening(Scene):\n\n    def construct(self):\n        title = Title('Idea of Frame of reference').set_color(RED)\n        title.fix_in_frame()\n        self.play(Write(title), run_time=2)\n        self.wait(2)\n        frame = self.camera.frame\n        frame.save_state()\n        frame.set_euler_angles(theta=-30 * DEGREES, phi=70 * DEGREES)\n        wood_box = Cube(side_length=1).set_color(YELLOW)\n        wood_box.save_state()\n        self.play(FadeIn(wood_box), run_time=2)\n        self.wait(2)\n        self.play(wood_box.animate.shift(2 * RIGHT))\n        self.play(wood_box.animate.shift(2 * UP))\n        self.play(wood_box.animate.shift(6 * LEFT))\n        self.play(wood_box.animate.restore())\n        self.wait(6)\n        earth_sp = Sphere(radius=1)\n        day_texture = 'earth_day_map'\n        night_texture = 'earth_night_map'\n        earth = TexturedSurface(earth_sp, day_texture, night_texture)\n        self.play(FadeOut(wood_box), FadeIn(earth))\n        self.wait(3)\n        self.play(Rotate(earth, 2 * PI), run_time=2)\n        self.wait(5)\n        self.play(earth.animate.shift(2 * UP - 4.5 * LEFT))\n        self.wait(4)\n        sun_sp = Sphere(radius=2.5)\n        sun_texture = 'sun_map'\n        sun = TexturedSurface(sun_sp, sun_texture)\n        sun.shift(LEFT)\n        self.play(FadeIn(sun), run_time=2)\n        self.wait(9)\n        self.play(frame.animate.restore())\n        self.wait(2)\n        self.play(*[FadeOut(i) for i in self.mobjects])\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate the concept of a frame of reference in 1D by animating a moving triangle on a number line, then demonstrating a car moving on a road."}, {"role": "assistant", "content": "from manimlib import *\nimport numpy as np\nfrom math import radians as rad, degrees as deg\n\nclass explanation_one(Scene):\n\n    def construct(self):\n        title = Title('Idea of Frame of reference in 1D').set_color(RED)\n        title.fix_in_frame()\n        self.add(title)\n        self.wait(4)\n        tri = Triangle(fill_opacity=1, fill_color=YELLOW, color=YELLOW).shift(4 * LEFT)\n        a = tri.point_from_proportion(0)\n        tri_cpy = tri.copy()\n        tri_cpy.set_opacity(0.4)\n        self.play(Write(tri), Write(tri_cpy), run_time=2)\n        self.wait(5)\n        tri.save_state()\n        self.play(tri.animate.shift(7 * RIGHT), run_time=6)\n        self.wait(3)\n        pause = SVGMobject('play_symbol')\n        self.add(pause)\n        self.wait(12)\n        reference_point = Dot(radius=0.08, color=BLUE).move_to(a)\n        self.play(Write(reference_point))\n        self.wait(7)\n        line = NumberLine(color=RED, x_range=[0, 8, 1])\n        line.shift(a[1] * UP)\n        self.play(Write(line), run_time=2)\n        self.remove(reference_point)\n        self.add(reference_point)\n        self.wait(15)\n        self.remove(pause)\n        self.play(tri.animate.restore(), run_time=2)\n        dist = DecimalNumber(0, unit='cm').scale(0.8)\n        dist.add_updater(lambda d: d.next_to(tri, UP, buff=0.1))\n        dist.add_updater(lambda d: d.set_value(line.p2n(tri.point_from_proportion(0))))\n        self.add(dist)\n        self.play(tri.animate.shift(7 * RIGHT), run_time=6)\n        self.wait(8)\n        names = Tex('O', 'A').scale(0.8)\n        names[0].set_color(BLUE)\n        names[1].set_color(YELLOW)\n        names[0].next_to(reference_point, UP, buff=0.2)\n        names[1].move_to(tri.point_from_proportion(0) + 0.3 * UP)\n        self.play(FadeIn(names), FadeOut(dist))\n        self.wait(5)\n        value = TexText('position of the triangle w.r.t ', 'blue-point', ' = ', 'OA').set_color(GREEN)\n        value[1].set_color(BLUE)\n        value[3].set_color_by_gradient(BLUE, YELLOW)\n        value.shift(2 * DOWN)\n        self.play(Write(value))\n        self.wait(10)\n        direction = Arrow(line.n2p(0) + [0, 0.2, 0], line.n2p(1) + [0, 0.2, 0], buff=0, color=YELLOW)\n        self.play(Write(direction), run_time=2)\n        self.wait(6)\n        val_vec = Tex('OA', '\\\\ ', '\\\\hat{i}').set_width(value[3].get_width())\n        val_vec[0].set_color_by_gradient(BLUE, YELLOW)\n        val_vec.move_to(value[3].get_center())\n        self.play(Transform(value[3], val_vec))\n        self.wait(10)\n        foref = TexText('The ', 'red Number-Line', ' is the frame of reference for this case.').next_to(value, DOWN)\n        foref[1].set_color(RED)\n        self.play(Write(foref), run_time=2)\n        self.wait(7)\n        self.play(FadeOut(VGroup(tri, tri_cpy, reference_point, line, names, value, direction, foref)))\n        self.wait(5)\n        road = Line([-7, -1.5, 0], [7, -1.5, 0], color=GREEN)\n        self.play(Write(road), run_time=2)\n        self.wait(6)\n        any_shape = ImageMobject('road').scale(0.7).shift(UP + 3 * RIGHT)\n        straight_shape = ImageMobject('straight_road').set_width(any_shape.get_width()).next_to(any_shape, LEFT, buff=2)\n        self.play(FadeIn(any_shape), run_time=2)\n        self.wait(8)\n        self.play(FadeIn(straight_shape))\n        self.wait(10)\n        self.play(FadeOut(any_shape), FadeOut(straight_shape))\n        self.wait(2)\n        car = SVGMobject('car', color=BLUE).scale(0.8).shift(0.7 * DOWN + LEFT * 5)\n        self.play(Write(car), run_time=2)\n        self.wait(5)\n        self.play(car.animate.shift(7 * RIGHT), run_time=6)\n        self.wait(7)\n        self.play(*[FadeOut(i) for i in self.mobjects], run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show a football match from the side, introduce text about player positions, transition to a top-down view, and explain it as a 2D problem."}, {"role": "assistant", "content": "from manimlib import *\nimport numpy as np\nfrom math import radians as rad, degrees as deg\n\nclass explanation_two_int(Scene):\n\n    def construct(self):\n        title = Title('Idea of Frame of reference in 2D').set_color(RED)\n        title.fix_in_frame()\n        self.play(Write(title), run_time=2)\n        self.wait(4)\n        foot_ball_match_side = ImageMobject('football_match_side').shift(3.5 * LEFT)\n        self.play(FadeIn(foot_ball_match_side), run_time=2)\n        self.wait(10)\n        want = TexText('Position of all the players in field').set_color(BLUE).set_width(foot_ball_match_side.get_width())\n        want.next_to(foot_ball_match_side, DOWN)\n        self.play(Write(want), run_time=2)\n        self.wait(10)\n        foot_ball_match_top = ImageMobject('football_match_top').shift(3 * LEFT)\n        self.play(FadeOut(foot_ball_match_side), FadeIn(foot_ball_match_top))\n        self.wait(10)\n        a = TexText('It is now just a 2-D problem', ' i.e., finding positions of object in 2-D plane.').set_color_by_gradient(BLUE, YELLOW)\n        a[0].next_to(foot_ball_match_top, DOWN)\n        a[1].next_to(a[0], DOWN)\n        a[1].shift(RIGHT * 0.5)\n        self.play(ReplacementTransform(want, a[0]))\n        self.wait(4)\n        self.play(Write(a[1]))\n        self.wait(12)\n        self.play(FadeOut(foot_ball_match_top), Uncreate(a))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a leaf moving on a plane, demonstrating coordinate systems, vectors, and transformations."}, {"role": "assistant", "content": "from manimlib import *\nimport numpy as np\nfrom math import radians as rad, degrees as deg\n\nclass explanation_two(Scene):\n\n    def construct(self):\n        title = Title('Idea of Frame of reference in 2D').set_color(RED)\n        title.fix_in_frame()\n        self.add(title)\n        ball = SVGMobject('oak_leap').set_color(GREEN)\n        self.play(Write(ball), run_time=2)\n        self.wait(10)\n        self.play(ball.animate.shift(2 * DOWN + 4 * RIGHT), run_time=2)\n        self.play(ball.animate.shift(-4 * DOWN - 8 * RIGHT), run_time=2)\n        self.play(ball.animate.shift(3 * DOWN + 2 * RIGHT), run_time=2)\n        self.wait(16)\n        axes = Axes(x_range=(-7, 7), y_range=(-4, 4), height=6, width=14, axis_config={'stroke_color': GREY_A, 'stroke_width': 2}, y_axis_config={'include_tip': False}, x_axis_config={'include_tip': False})\n        axes.add_coordinate_labels(font_size=17, num_decimal_places=1)\n        a = axes.copy()\n        self.play(Write(a), run_time=2)\n        self.wait(10)\n        axes2 = Axes(x_range=(-7, 7), y_range=(-4, 4), angle=30, height=8, width=14, axis_config={'stroke_color': GREY_A, 'stroke_width': 2}, y_axis_config={'include_tip': False}, x_axis_config={'include_tip': False})\n        axes2.add_coordinate_labels(font_size=17, num_decimal_places=1)\n        self.play(ReplacementTransform(a, axes2), run_time=2)\n        self.wait(10)\n        self.play(ReplacementTransform(axes2, axes), run_time=2)\n        self.wait(5)\n        self.play(ball.animate.shift(LEFT + DOWN), run_time=2)\n        self.wait(6)\n        com = Dot(radius=0.06, color=YELLOW, point=ball.get_center_of_mass())\n        self.play(Write(com), run_time=2)\n        self.wait(6)\n        self.play(ball.animate.set_opacity(0.1), run_time=2)\n        self.wait(5)\n        f_always(com.move_to, lambda: ball.get_center_of_mass())\n        h_line = always_redraw(lambda: axes.get_h_line(com.get_center(), color=BLUE, stroke_width=6))\n        x_arrow = Arrow(axes.c2p(0, 0), [ball.get_center()[0], 0, 0], buff=0).set_color(BLUE)\n        self.play(Write(x_arrow), run_time=2)\n        self.wait(6)\n        self.play(ReplacementTransform(x_arrow, h_line), run_time=2)\n        self.remove(com)\n        self.add(com)\n        self.wait(4)\n        v_line = always_redraw(lambda: axes.get_v_line(com.get_center(), color=BLUE, stroke_width=6))\n        y_arrow = Arrow(axes.c2p(0, 0), [0, ball.get_center()[1], 0], buff=0).set_color(BLUE)\n        self.play(Write(y_arrow), run_time=2)\n        self.wait(6)\n        self.play(ReplacementTransform(y_arrow, v_line), run_time=2)\n        self.remove(com)\n        self.add(com)\n        self.wait(4)\n        x_val = DecimalNumber(axes.p2c(com.get_center_of_mass())[0], num_decimal_places=1).scale(0.5)\n        y_val = DecimalNumber(axes.p2c(com.get_center_of_mass())[1], num_decimal_places=1).scale(0.5)\n        position_val = TexText('position', ' = ', '(', ',', ')').set_color(YELLOW)\n        position_val[0].set_color(BLUE)\n        position_val.next_to(title, DOWN).shift(5 * LEFT)\n        x_val.move_to(position_val[-2].get_center()).shift(0.2 * RIGHT + 0.13 * UP)\n        position_val[-2].shift(x_val.get_width() * RIGHT)\n        position_val[-1].shift(2 * x_val.get_width() * RIGHT)\n        y_val.next_to(position_val[-2], buff=0.01).shift(UP * 0.13 + 0.08 * RIGHT)\n        x_val_c = x_val.copy().scale(0.6).set_color(RED).next_to(h_line, DOWN)\n        y_val_c = y_val.copy().scale(0.6).set_color(RED).next_to(v_line, LEFT)\n        self.play(Write(VGroup(x_val_c, y_val_c)), run_time=2)\n        self.wait(8)\n        self.play(Write(position_val), Write(VGroup(x_val, y_val)), run_time=2)\n        self.wait(10)\n        x_val.add_updater(lambda d: d.set_value(axes.p2c(com.get_center_of_mass())[0]))\n        y_val.add_updater(lambda d: d.set_value(axes.p2c(com.get_center_of_mass())[1]))\n        x_val_c.add_updater(lambda d: d.become(x_val.copy().scale(0.6).set_color(RED)))\n        y_val_c.add_updater(lambda d: d.become(y_val.copy().scale(0.6).set_color(RED)))\n        x_val_c.add_updater(lambda d: d.next_to(h_line, DOWN))\n        y_val_c.add_updater(lambda d: d.next_to(v_line, LEFT))\n        self.add(x_val, y_val, x_val_c, y_val_c)\n        self.play(ball.animate.move_to([0, 0, 0]), run_time=2)\n\n        def fun(t):\n            return np.array([5 * np.sin(2 * t), 2 * np.sin(3 * t), 0])\n        curve = ParametricCurve(fun, t_range=[0, 2 * PI])\n        self.play(MoveAlongPath(ball, curve), run_time=15)\n        self.wait(5)\n        self.play(FadeOut(VGroup(position_val, x_val, y_val)), run_time=2)\n        self.play(ball.animate.shift(2.5 * RIGHT + 1.5 * UP), run_time=3)\n        self.wait(13)\n        names = Tex('O', 'A', 'B', 'P').set_color(RED).scale(0.6)\n        names[0].move_to(axes.c2p(-0.15, -0.15))\n        names[1].move_to([com.get_center()[0], -0.3, 0])\n        names[2].move_to([-0.3, com.get_center()[1], 0])\n        names[-1].next_to(com, RIGHT)\n        self.play(Write(names))\n        self.wait(6)\n        x_vec = Arrow([0, 0, 0], [com.get_center()[0], 0, 0], buff=0).set_color(YELLOW)\n        y_vec = Arrow([com.get_center()[0], 0, 0], com.get_center(), buff=0).set_color(YELLOW)\n        text = TexText('Position of the leaf = ', '+').scale(0.8).set_color(BLUE)\n        text.to_corner(UL).shift(DOWN + LEFT * 0.5)\n        self.play(Write(text[0]), run_time=2)\n        self.wait(5)\n        self.play(Write(x_vec), run_time=2)\n        self.wait(6)\n        x_vec_text = Tex('OA', '\\\\hat{i}').set_color(YELLOW)\n        x_vec_text[0].set_color(RED)\n        x_vec_text.next_to(text[0])\n        self.play(ReplacementTransform(x_vec.copy(), x_vec_text))\n        self.wait(6)\n        text[1].next_to(x_vec_text)\n        self.play(FadeIn(text[1]))\n        self.play(Write(y_vec), run_time=2)\n        self.wait(4)\n        y_vec_text = Tex('OB', '\\\\hat{j}').set_color(YELLOW)\n        y_vec_text[0].set_color(RED)\n        y_vec_text.next_to(text[1])\n        self.play(ReplacementTransform(y_vec.copy(), y_vec_text))\n        self.wait(10)\n        final = Vector(com.get_center()).set_color(RED)\n        self.play(ReplacementTransform(VGroup(x_vec, y_vec), final), run_time=2)\n        self.wait(10)\n        self.play(*[FadeOut(i) for i in self.mobjects])\n        a = NumberPlane()\n        self.play(Write(a), run_time=2)\n        a.prepare_for_nonlinear_transform()\n        self.play(a.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait(6)\n        self.play(*[FadeOut(i) for i in self.mobjects], run_time=2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate an animation demonstrating the Fourier series by drawing rotating vectors and their corresponding circles, and plotting the resulting path."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass FourierCirclesScene(Scene):\n    CONFIG = {'n_vectors': 10, 'big_radius': 2, 'colors': [BLUE_D, BLUE_C, BLUE_E, GREY_BROWN], 'circle_style': {'stroke_width': 2}, 'vector_config': {'buff': 0, 'max_tip_length_to_length_ratio': 0.35, 'tip_length': 0.15, 'max_stroke_width_to_length_ratio': 10, 'stroke_width': 2}, 'circle_config': {'stroke_width': 1}, 'base_frequency': 1, 'slow_factor': 0.25, 'center_point': ORIGIN, 'parametric_function_step_size': 0.001, 'drawn_path_color': BLUE, 'drawn_path_stroke_width': 2}\n\n    def setup(self):\n        self.slow_factor_tracker = ValueTracker(self.slow_factor)\n        self.vector_clock = ValueTracker(0)\n        self.vector_clock.add_updater(lambda m, dt: m.increment_value(self.get_slow_factor() * dt))\n        self.add(self.vector_clock)\n\n    def get_slow_factor(self):\n        return self.slow_factor_tracker.get_value()\n\n    def get_vector_time(self):\n        return self.vector_clock.get_value()\n\n    def get_freqs(self):\n        n = self.n_vectors\n        all_freqs = list(range(n // 2, -n // 2, -1))\n        all_freqs.sort(key=abs)\n        return all_freqs\n\n    def get_coefficients(self):\n        return [complex(0) for x in range(self.n_vectors)]\n\n    def get_color_iterator(self):\n        return it.cycle(self.colors)\n\n    def get_rotating_vectors(self, freqs=None, coefficients=None):\n        vectors = VGroup()\n        self.center_tracker = VectorizedPoint(self.center_point)\n        if freqs is None:\n            freqs = self.get_freqs()\n        if coefficients is None:\n            coefficients = self.get_coefficients()\n        last_vector = None\n        for freq, coefficient in zip(freqs, coefficients):\n            if last_vector:\n                center_func = last_vector.get_end\n            else:\n                center_func = self.center_tracker.get_location\n            vector = self.get_rotating_vector(coefficient=coefficient, freq=freq, center_func=center_func)\n            vectors.add(vector)\n            last_vector = vector\n        return vectors\n\n    def get_rotating_vector(self, coefficient, freq, center_func):\n        vector = Vector(RIGHT, **self.vector_config)\n        vector.scale(abs(coefficient))\n        if abs(coefficient) == 0:\n            phase = 0\n        else:\n            phase = np.log(coefficient).imag\n        vector.rotate(phase, about_point=ORIGIN)\n        vector.freq = freq\n        vector.coefficient = coefficient\n        vector.center_func = center_func\n        vector.add_updater(self.update_vector)\n        return vector\n\n    def update_vector(self, vector, dt):\n        time = self.get_vector_time()\n        coef = vector.coefficient\n        freq = vector.freq\n        phase = np.log(coef).imag\n        vector.set_length(abs(coef))\n        vector.set_angle(phase + time * freq * TAU)\n        vector.shift(vector.center_func() - vector.get_start())\n        return vector\n\n    def get_circles(self, vectors):\n        return VGroup(*[self.get_circle(vector, color=color) for vector, color in zip(vectors, self.get_color_iterator())])\n\n    def get_circle(self, vector, color=BLUE):\n        circle = Circle(color=color, **self.circle_config)\n        circle.center_func = vector.get_start\n        circle.radius_func = vector.get_length\n        circle.add_updater(self.update_circle)\n        return circle\n\n    def update_circle(self, circle):\n        circle.set_width(2 * circle.radius_func())\n        circle.move_to(circle.center_func())\n        return circle\n\n    def get_vector_sum_path(self, vectors, color=YELLOW):\n        coefs = [v.coefficient for v in vectors]\n        freqs = [v.freq for v in vectors]\n        center = vectors[0].get_start()\n        path = ParametricFunction(lambda t: center + reduce(op.add, [complex_to_R3(coef * np.exp(TAU * 1j * freq * t)) for coef, freq in zip(coefs, freqs)]), t_min=0, t_max=1, color=color, step_size=self.parametric_function_step_size)\n        return path\n\n    def get_drawn_path_alpha(self):\n        return self.get_vector_time()\n\n    def get_drawn_path(self, vectors, stroke_width=None, **kwargs):\n        if stroke_width is None:\n            stroke_width = self.drawn_path_stroke_width\n        path = self.get_vector_sum_path(vectors, **kwargs)\n        broken_path = CurvesAsSubmobjects(path)\n        broken_path.curr_time = 0\n\n        def update_path(path, dt):\n            alpha = self.get_drawn_path_alpha()\n            n_curves = len(path)\n            for a, sp in zip(np.linspace(0, 1, n_curves), path):\n                b = alpha - a\n                if b < 0:\n                    width = 0\n                else:\n                    width = stroke_width * (1 - b % 1)\n                sp.set_stroke(width=width)\n            path.curr_time += dt\n            return path\n        broken_path.set_color(self.drawn_path_color)\n        broken_path.add_updater(update_path)\n        return broken_path\n\n    def get_y_component_wave(self, vectors, left_x=1, color=PINK, n_copies=2, right_shift_rate=5):\n        path = self.get_vector_sum_path(vectors)\n        wave = ParametricFunction(lambda t: op.add(right_shift_rate * t * LEFT, path.function(t)[1] * UP), t_min=path.t_min, t_max=path.t_max, color=color)\n        wave_copies = VGroup(*[wave.copy() for x in range(n_copies)])\n        wave_copies.arrange(RIGHT, buff=0)\n        top_point = wave_copies.get_top()\n        wave.creation = ShowCreation(wave, run_time=1 / self.get_slow_factor(), rate_func=linear)\n        cycle_animation(wave.creation)\n        wave.add_updater(lambda m: m.shift((m.get_left()[0] - left_x) * LEFT))\n\n        def update_wave_copies(wcs):\n            index = int(wave.creation.total_time * self.get_slow_factor())\n            wcs[:index].match_style(wave)\n            wcs[index:].set_stroke(width=0)\n            wcs.next_to(wave, RIGHT, buff=0)\n            wcs.align_to(top_point, UP)\n        wave_copies.add_updater(update_wave_copies)\n        return VGroup(wave, wave_copies)\n\n    def get_wave_y_line(self, vectors, wave):\n        return DashedLine(vectors[-1].get_end(), wave[0].get_end(), stroke_width=1, dash_length=DEFAULT_DASH_LENGTH * 0.5)\n\n    def get_coefficients_of_path(self, path, n_samples=10000, freqs=None):\n        if freqs is None:\n            freqs = self.get_freqs()\n        dt = 1 / n_samples\n        ts = np.arange(0, 1, dt)\n        samples = np.array([path.point_from_proportion(t) for t in ts])\n        samples -= self.center_point\n        complex_samples = samples[:, 0] + 1j * samples[:, 1]\n        result = []\n        for freq in freqs:\n            riemann_sum = np.array([np.exp(-TAU * 1j * freq * t) * cs for t, cs in zip(ts, complex_samples)]).sum() * dt\n            result.append(riemann_sum)\n        return result"}]}
{"messages": [{"role": "user", "content": "Present Kirchhoff's laws, capacitor and inductor formulas, an RLC circuit, a mechanical system, and the transfer function."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\n\nclass KirchhoffsLaws(Scene):\n\n    def construct(self):\n        title = Text('Circuit and Mechanical System Modeling', font_size=48)\n        self.play(Write(title))\n        self.wait()\n        self.play(FadeOut(title))\n        kcl_title = Text(\"Kirchhoff's Current Law (KCL)\", font_size=40)\n        kcl_formula = MathTex('\\\\sum_{k=1}^{n} I_k = 0', font_size=36)\n        kcl_explanation = Text('Sum of currents at a node equals zero', font_size=30)\n        kcl_group = VGroup(kcl_title, kcl_formula, kcl_explanation).arrange(DOWN, buff=0.5)\n        self.play(Write(kcl_group))\n        self.wait(2)\n        self.play(FadeOut(kcl_group))\n        kvl_title = Text(\"Kirchhoff's Voltage Law (KVL)\", font_size=40)\n        kvl_formula = MathTex('\\\\sum_{k=1}^{n} V_k = 0', font_size=36)\n        kvl_explanation = Text('Sum of voltages around a loop equals zero', font_size=30)\n        kvl_group = VGroup(kvl_title, kvl_formula, kvl_explanation).arrange(DOWN, buff=0.5)\n        self.play(Write(kvl_group))\n        self.wait(2)\n        self.play(FadeOut(kvl_group))\n        capacitor_title = Text('Capacitor', font_size=40)\n        capacitor_formula = MathTex('i_C = C \\\\frac{dv_C}{dt}', font_size=36)\n        capacitor_formula2 = MathTex('v_C = \\\\frac{1}{C} \\\\int i_C \\\\, dt', font_size=36)\n        capacitor_group = VGroup(capacitor_title, capacitor_formula, capacitor_formula2).arrange(DOWN, buff=0.5)\n        self.play(Write(capacitor_group))\n        self.wait(2)\n        self.play(FadeOut(capacitor_group))\n        inductor_title = Text('Inductor', font_size=40)\n        inductor_formula = MathTex('v_L = L \\\\frac{di_L}{dt}', font_size=36)\n        inductor_formula2 = MathTex('i_L = \\\\frac{1}{L} \\\\int v_L \\\\, dt', font_size=36)\n        inductor_group = VGroup(inductor_title, inductor_formula, inductor_formula2).arrange(DOWN, buff=0.5)\n        self.play(Write(inductor_group))\n        self.wait(2)\n        self.play(FadeOut(inductor_group))\n        self.show_example_circuit()\n        self.show_mechanical_system()\n        transfer_title = Text('Transfer Function', font_size=40)\n        transfer_formula = MathTex('H(s) = \\\\frac{Y_o(s)}{Y_i(s)}', font_size=36)\n        transfer_group = VGroup(transfer_title, transfer_formula).arrange(DOWN, buff=0.5)\n        self.play(Write(transfer_group))\n        self.wait(2)\n        self.play(FadeOut(transfer_group))\n\n    def show_example_circuit(self):\n        circuit_title = Text('RLC Circuit Example', font_size=40)\n        self.play(Write(circuit_title))\n        self.play(circuit_title.animate.to_edge(UP))\n        source_circle = Circle(radius=0.3).set_color(BLUE)\n        source_plus = Line(UP * 0.15, DOWN * 0.15, stroke_width=2).set_color(WHITE)\n        source_minus = Line(LEFT * 0.15, RIGHT * 0.15, stroke_width=2).set_color(WHITE)\n        source = VGroup(source_circle, source_plus, source_minus)\n        resistor = VGroup()\n        resistor_base = Rectangle(height=0.2, width=0.8).set_color(ORANGE)\n        for i in range(4):\n            line = Line(LEFT * 0.4 + RIGHT * 0.2 * i, LEFT * 0.4 + RIGHT * 0.2 * i + UP * 0.2, stroke_width=2).set_color(ORANGE)\n            resistor.add(line)\n        resistor.add(resistor_base)\n        inductor = VGroup()\n        for i in range(5):\n            arc = Arc(radius=0.1, start_angle=PI, angle=-PI, stroke_width=2).set_color(GREEN)\n            arc.shift(RIGHT * 0.2 * i)\n            inductor.add(arc)\n        capacitor = VGroup(Line(LEFT * 0.2, LEFT * 0.2 + UP * 0.3, stroke_width=2), Line(LEFT * 0.2, LEFT * 0.2 + DOWN * 0.3, stroke_width=2), Line(RIGHT * 0.2, RIGHT * 0.2 + UP * 0.3, stroke_width=2), Line(RIGHT * 0.2, RIGHT * 0.2 + DOWN * 0.3, stroke_width=2)).set_color(RED)\n        source.move_to(LEFT * 3)\n        resistor.move_to(UP * 0.5)\n        inductor.move_to(UP * 0.5 + RIGHT * 2)\n        capacitor.rotate(PI / 2)\n        capacitor.move_to(RIGHT * 3.5)\n        source_label = MathTex('V_s').next_to(source, LEFT, buff=0.2)\n        resistor_label = MathTex('R').next_to(resistor, UP, buff=0.3)\n        inductor_label = MathTex('L').next_to(inductor, UP, buff=0.3)\n        wire1 = Line(source.get_top(), LEFT * 3 + UP * 0.5, stroke_width=2)\n        wire2 = Line(LEFT * 3 + UP * 0.5, resistor.get_left(), stroke_width=2)\n        wire3 = Line(resistor.get_right(), inductor.get_left(), stroke_width=2)\n        wire4 = Line(inductor.get_right(), RIGHT * 3.5 + UP * 0.5, stroke_width=2)\n        wire5 = Line(RIGHT * 3.5 + UP * 0.5, capacitor.get_top(), stroke_width=2)\n        wire6 = Line(capacitor.get_bottom(), RIGHT * 3.5 + DOWN * 0.5, stroke_width=2)\n        wire7 = Line(RIGHT * 3.5 + DOWN * 0.5, LEFT * 3 + DOWN * 0.5, stroke_width=2)\n        wire8 = Line(LEFT * 3 + DOWN * 0.5, source.get_bottom(), stroke_width=2)\n        circuit = VGroup(source, source_label, resistor, resistor_label, inductor, inductor_label, capacitor, wire1, wire2, wire3, wire4, wire5, wire6, wire7, wire8)\n        circuit.move_to(ORIGIN)\n        self.play(Create(circuit))\n        circuit_eq = MathTex('L\\\\frac{d^2q}{dt^2} + R\\\\frac{dq}{dt} + \\\\frac{1}{C}q = V_s', font_size=32).next_to(circuit, DOWN, buff=1.2)\n        self.play(Write(circuit_eq))\n        self.wait(2)\n        self.play(FadeOut(circuit), FadeOut(circuit_eq), FadeOut(circuit_title))\n\n    def show_mechanical_system(self):\n        mech_title = Text('Mechanical System Modeling', font_size=40)\n        self.play(Write(mech_title))\n        self.play(mech_title.animate.to_edge(UP))\n        wall = Line(DOWN * 1.5, UP * 1.5, stroke_width=4).set_color(GRAY)\n        wall.move_to(LEFT * 3.5)\n\n        def create_spring(start, end, coils=10, width=0.1):\n            spring = VMobject()\n            points = []\n            length = np.linalg.norm(end - start)\n            direction = (end - start) / length\n            perpendicular = np.array([-direction[1], direction[0], 0])\n            segment_length = length / (2 * coils)\n            points.append(start)\n            for i in range(coils):\n                points.append(start + direction * segment_length * (2 * i + 0.5) - perpendicular * width)\n                points.append(start + direction * segment_length * (2 * i + 1.5) + perpendicular * width)\n            points.append(end)\n            spring.set_points_smoothly(points)\n            return spring\n        spring1 = create_spring(start=wall.get_right(), end=wall.get_right() + RIGHT * 2).set_color(BLUE)\n        spring1_label = MathTex('k_1').next_to(spring1, UP, buff=0.2)\n        mass = Square(side_length=0.8).set_color(RED).set_fill(RED_E, opacity=0.8)\n        mass.next_to(spring1, RIGHT, buff=0)\n        mass_label = MathTex('m').move_to(mass).set_color(WHITE)\n        spring2 = create_spring(start=mass.get_right(), end=mass.get_right() + RIGHT * 2).set_color(BLUE)\n        spring2_label = MathTex('k_2').next_to(spring2, UP, buff=0.2)\n        damper_cylinder = Rectangle(height=0.6, width=1.2, fill_opacity=0.5).set_color(GREEN)\n        damper_piston = Rectangle(height=0.6, width=0.2, fill_opacity=1).set_color(GREEN_E)\n        damper = VGroup(damper_cylinder, damper_piston)\n        damper_cylinder.move_to(ORIGIN)\n        damper_piston.next_to(damper_cylinder, RIGHT, buff=0)\n        damper.next_to(mass, DOWN, buff=1.2)\n        damper_label = MathTex('c').next_to(damper, DOWN, buff=0.2)\n        line1 = Line(mass.get_bottom(), damper.get_top(), stroke_width=2)\n        line2 = Line(damper.get_left(), wall.get_right() + DOWN * (damper.get_center()[1] - wall.get_center()[1]), stroke_width=2)\n        line3 = Line(damper.get_right(), spring2.get_right() + DOWN * (damper.get_center()[1] - spring2.get_right()[1]), stroke_width=2)\n        input_arrow = Arrow(wall.get_bottom() + DOWN * 0.2 + LEFT * 0.5, wall.get_bottom() + DOWN * 0.2 + RIGHT * 0.5, color=YELLOW, max_stroke_width_to_length_ratio=5, stroke_width=2)\n        input_label = MathTex('y_i').next_to(input_arrow, DOWN, buff=0.1)\n        output_arrow = Arrow(damper.get_right() + RIGHT * 0.2, damper.get_right() + RIGHT * 1.2, color=YELLOW, max_stroke_width_to_length_ratio=5, stroke_width=2)\n        output_label = MathTex('y_o').next_to(output_arrow, DOWN, buff=0.1)\n        mech_system = VGroup(wall, spring1, spring1_label, mass, mass_label, spring2, spring2_label, damper, damper_label, line1, line2, line3, input_arrow, input_label, output_arrow, output_label)\n        mech_system.move_to(ORIGIN)\n        self.play(Create(mech_system))\n        self.wait(1)\n        mech_eq = MathTex('m\\\\frac{d^2y_o}{dt^2} + c\\\\frac{dy_o}{dt} + k_1(y_o-y_i) + k_2y_o = 0', font_size=32).move_to(DOWN * 3)\n        self.play(Write(mech_eq))\n        self.wait(2)\n        self.play(FadeOut(mech_system), FadeOut(mech_eq), FadeOut(mech_title))"}]}
{"messages": [{"role": "user", "content": "Present a table comparing mechanical and electrical system analogies, followed by their respective differential equations, and then fade out all elements."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\n\nclass MechanicalElectricalAnalogy(Scene):\n\n    def construct(self):\n        title = Text('Mechanical-Electrical System Duality', font_size=48)\n        self.play(Write(title))\n        self.wait()\n        self.play(title.animate.to_edge(UP))\n        table = Table([['Mechanical', 'Electrical'], ['Displacement (x)', 'Charge (q)'], ['Velocity (v)', 'Current (i)'], ['Force (F)', 'Voltage (V)'], ['Mass (m)', 'Inductance (L)'], ['Spring constant (k)', 'Inverse capacitance (1/C)'], ['Damping coefficient (c)', 'Resistance (R)']], row_labels=[Text('') for _ in range(7)], col_labels=[Text('') for _ in range(2)], include_outer_lines=True)\n        self.play(Create(table))\n        self.wait(2)\n        mech_eq = MathTex('m\\\\frac{d^2x}{dt^2} + c\\\\frac{dx}{dt} + kx = F(t)', font_size=36).next_to(table, DOWN, buff=1)\n        self.play(Write(mech_eq))\n        self.wait(1)\n        elec_eq = MathTex('L\\\\frac{d^2q}{dt^2} + R\\\\frac{dq}{dt} + \\\\frac{1}{C}q = V(t)', font_size=36).next_to(mech_eq, DOWN, buff=0.5)\n        self.play(Write(elec_eq))\n        self.wait(2)\n        self.play(FadeOut(table), FadeOut(mech_eq), FadeOut(elec_eq), FadeOut(title))"}]}
{"messages": [{"role": "user", "content": "Visualize a continuous flow field with stream lines."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\n\nclass ContinuousMotion(Scene):\n\n    def construct(self):\n        func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT\n        stream_lines = StreamLines(func, stroke_width=2, max_anchors_per_line=30)\n        self.add(stream_lines)\n        stream_lines.start_animation(warm_up=False, flow_speed=1.5)\n        self.wait(stream_lines.virtual_time / stream_lines.flow_speed)"}]}
{"messages": [{"role": "user", "content": "Illustrate the Fatou and Julia sets of a function, explaining the condition for a point belonging to the Fatou set."}, {"role": "assistant", "content": "from time import sleep\nfrom manim import *\nfrom functools import reduce\nimport random\nimport itertools as it\n\nclass MentionFatouSetsAndJuliaSets(Scene):\n    colors = [RED_E, BLUE_E, TEAL_E, MAROON_E]\n\n    def construct(self):\n        f_group, j_group = self.get_fractals()\n        f_name, j_name = VGroup(Text('Fatou set'), Text('Julia set'))\n        f_name.next_to(f_group, UP, MED_LARGE_BUFF)\n        j_name.next_to(j_group, UP, MED_LARGE_BUFF)\n        self.play(Write(j_name), GrowFromCenter(j_group))\n        self.wait()\n        self.play(Write(f_name), *map(GrowFromCenter, f_group))\n        self.wait()\n        fatou_condition = self.get_fatou_condition()\n        fatou_condition.set_width(FRAME_WIDTH - 1)\n        fatou_condition.center().to_edge(UP, buff=1.0)\n        lhs, arrow, rhs = fatou_condition\n        f_line = Line(LEFT, RIGHT)\n        f_line.match_width(fatou_condition)\n        f_line.next_to(fatou_condition, DOWN)\n        f_line.set_stroke(WHITE, 1)\n        self.play(FadeOut(j_name, RIGHT), FadeOut(j_group, RIGHT), Write(lhs))\n        self.wait()\n        for words in lhs[-1]:\n            self.play(Indicate(words, buff=0, time_width=1.5))\n        self.play(Write(arrow))\n        self.play(LaggedStart(FadeTransform(f_name.copy(), rhs[1][:8]), FadeIn(rhs), lag_ratio=0.5))\n        self.wait()\n        otherwise = Text('Otherwise...')\n        otherwise.next_to(rhs, DOWN, LARGE_BUFF)\n        j_condition = Tex('$z_0 \\\\in$', ' Julia set', ' of $f$')\n        j_condition.match_height(rhs)\n        j_condition.next_to(otherwise, DOWN, LARGE_BUFF)\n        j_group.set_height(4.0)\n        j_group.to_edge(DOWN)\n        j_group.set_x(-1.0)\n        j_name = j_condition.get_part_by_tex('Julia set')\n        j_underline = Underline(j_name, buff=0.05)\n        j_underline.set_color(YELLOW)\n        arrow = Arrow(j_name.get_bottom(), j_group.get_right(), path_arc=-45 * DEGREES)\n        arrow.set_stroke(YELLOW, 5)\n        julia_set = j_group[0]\n        julia_set.update()\n        julia_set.suspend_updating()\n        julia_copy = julia_set.copy()\n        julia_copy.clear_updaters()\n        julia_copy.set_colors(self.colors)\n        julia_copy.set_julia_highlight(0)\n        mover = f_group[:-4]\n        mover.generate_target()\n        mover.target.match_width(rhs)\n        mover.target.next_to(rhs, UP, MED_LARGE_BUFF)\n        mover.target.shift_onto_screen(buff=SMALL_BUFF)\n        self.play(Create(f_line), FadeOut(f_name), MoveToTarget(mover))\n        self.play(Write(otherwise), FadeIn(j_condition, 0.5 * DOWN))\n        self.wait()\n        self.play(Create(j_underline), Create(arrow), FadeIn(j_group[1]), FadeIn(julia_copy))\n        self.play(GrowFromPoint(julia_set, julia_set.get_corner(UL), run_time=2), julia_copy.animate.set_opacity(0.2))\n        self.wait()\n\n    def get_fractals(self, jy=1.5, fy=-2.5):\n        coefs = roots_to_coefficients([-1.5, 1.5, 1j, -1j])\n        n = len(coefs) - 1\n        colors = self.colors\n        f_planes = VGroup(*(self.get_plane() for x in range(n)))\n        f_planes.arrange(RIGHT, buff=LARGE_BUFF)\n        plusses = [Tex('+') for _ in range(n - 1)]\n        f_group = Group(*it.chain(*zip(f_planes, plusses)))\n        f_group.add(f_planes[-1])\n        f_group.arrange(RIGHT)\n        fatou = Group(*(NewtonFractal(f_plane, coefs=coefs, colors=colors) for f_plane in f_planes))\n        for i, fractal in enumerate(fatou):\n            opacities = n * [0.2]\n            opacities[i] = 1\n            fractal.set_opacities(*opacities)\n        f_group.add(*fatou)\n        f_group.set_y(fy)\n        j_plane = self.get_plane()\n        j_plane.set_y(jy)\n        julia = NewtonFractal(j_plane, coefs=coefs, colors=5 * [GREY_A])\n        julia.set_julia_highlight(0.001)\n        j_group = Group(julia, j_plane)\n        for fractal, plane in zip((*fatou, julia), (*f_planes, j_plane)):\n            fractal.plane = plane\n            fractal.add_updater(lambda m: m.set_offset(m.plane.get_center()).set_scale(m.plane.get_x_unit_size()).replace(m.plane))\n        fractals = Group(f_group, j_group)\n        return fractals\n\n    def get_plane(self):\n        plane = ComplexPlane((-2, 2), (-2, 2), background_line_style={'stroke_width': 1, 'stroke_color': GREY})\n        plane.set_height(2)\n        plane.set_opacity(0)\n        box = SurroundingRectangle(plane, buff=0)\n        box.set_stroke(WHITE, 1)\n        plane.add(box)\n        return plane\n\n    def get_fatou_condition(self):\n        zn = MathTex('z_0', '\\\\overset{f}{\\\\longrightarrow}', 'z_1', '\\\\overset{f}{\\\\longrightarrow}', 'z_2', '\\\\overset{f}{\\\\longrightarrow}', '\\\\dots', '\\\\longrightarrow')\n        words = VGroup(Tex('Stable fixed point'), Tex('Stable cycle'), Tex('$\\\\infty$'))\n        words.arrange(DOWN, aligned_edge=LEFT)\n        brace = Brace(words, LEFT)\n        zn.next_to(brace, LEFT)\n        lhs = VGroup(zn, brace, words)\n        arrow = MathTex('\\\\Rightarrow')\n        arrow.scale(2)\n        arrow.next_to(lhs, RIGHT, MED_LARGE_BUFF)\n        rhs = MathTex('z_0 \\\\in', ' \\\\text{Fatou set of $f$}')\n        rhs.next_to(arrow, RIGHT, buff=MED_LARGE_BUFF)\n        result = VGroup(lhs, arrow, rhs)\n        return result"}]}
{"messages": [{"role": "user", "content": "Render a bright Newton fractal with specific coefficients and a dark background."}, {"role": "assistant", "content": "from time import sleep\nfrom manim import *\nfrom functools import reduce\nimport random\nimport itertools as it\n\nclass TestScene(Scene):\n    coefs = [1.0, -1.0, 1.0, 0.0, 0.0, 1.0]\n    plane_config = {'x_range': (-4, 4), 'y_range': (-4, 4), 'height': 16, 'width': 16, 'background_line_style': {'stroke_color': GREY_A, 'stroke_width': 1.0}, 'axis_config': {'stroke_width': 1.0}}\n    n_steps = 30\n    colors = [RED_E, BLUE_E, TEAL_E, MAROON_E]\n\n    def get_fractal(self, plane, colors=ROOT_COLORS_DEEP, n_steps=30):\n        return NewtonFractal(plane, colors=colors, coefs=self.coefs, n_steps=n_steps)\n\n    def init_fractal(self, root_colors=ROOT_COLORS_DEEP):\n        plane = ComplexPlane()\n        fractal = self.get_fractal(plane, colors=root_colors, n_steps=self.n_steps)\n        return fractal\n\n    def construct(self):\n        fractal = self.init_fractal(root_colors=ROOT_COLORS_BRIGHT)\n        self.add(fractal)"}]}
{"messages": [{"role": "user", "content": "Display a circle and a square, then enter an interactive mode."}, {"role": "assistant", "content": "from time import sleep\nfrom manim import *\nfrom functools import reduce\nimport random\nimport itertools as it\n\nclass OpenGLShow(Scene):\n\n    def construct(self):\n        circ = Circle()\n        square = Square()\n        self.add(circ, square)\n        self.interactive_embed()"}]}
{"messages": [{"role": "user", "content": "Create a square and color it with a GLSL shader that blends blue and red based on the x-coordinate."}, {"role": "assistant", "content": "from time import sleep\nfrom manim import *\nfrom functools import reduce\nimport random\nimport itertools as it\n\nclass TestGlsl(Scene):\n\n    def construct(self):\n        square = Square(side_length=4)\n        square.set_color_by_code(f'\\n            vec3 blue = vec3{tuple(hex_to_rgb(BLUE))};\\n            vec3 red = vec3{tuple(hex_to_rgb(RED))};\\n            color.rgb = mix(blue, red, (point.x + 1.5) / 3);\\n        ')\n        self.add(square)"}]}
{"messages": [{"role": "user", "content": "Create an image from a NumPy array and draw a green bounding box around it."}, {"role": "assistant", "content": "from time import sleep\nfrom manim import *\nfrom functools import reduce\nimport random\nimport itertools as it\n\nclass GradientImageFromArray(Scene):\n\n    def construct(self):\n        n = 256\n        imageArray = np.uint8([[i * 256 / n for i in range(0, n)] for _ in range(0, n)])\n        image = ImageMobject(imageArray).scale(2)\n        image.background_rectangle = SurroundingRectangle(image, GREEN)\n        self.add(image, image.background_rectangle)"}]}
{"messages": [{"role": "user", "content": "Display an image multiple times, each with a different resampling algorithm and labeled accordingly."}, {"role": "assistant", "content": "from time import sleep\nfrom manim import *\nfrom functools import reduce\nimport random\nimport itertools as it\n\nclass ImageInterpolationEx(Scene):\n\n    def construct(self):\n        img = ImageMobject(np.uint8([[63, 0, 0, 0], [0, 127, 0, 0], [0, 0, 191, 0], [0, 0, 0, 255]]))\n        img.height = 2\n        img1 = img.copy()\n        img2 = img.copy()\n        img3 = img.copy()\n        img4 = img.copy()\n        img5 = img.copy()\n        img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS['nearest'])\n        img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS['lanczos'])\n        img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS['linear'])\n        img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS['cubic'])\n        img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS['box'])\n        img1.add(Text('nearest').scale(0.5).next_to(img1, UP))\n        img2.add(Text('lanczos').scale(0.5).next_to(img2, UP))\n        img3.add(Text('linear').scale(0.5).next_to(img3, UP))\n        img4.add(Text('cubic').scale(0.5).next_to(img4, UP))\n        img5.add(Text('box').scale(0.5).next_to(img5, UP))\n        x = Group(img1, img2, img3, img4, img5)\n        x.arrange()\n        self.add(x)"}]}
{"messages": [{"role": "user", "content": "Display a colorful image generated from a list of random integers."}, {"role": "assistant", "content": "from time import sleep\nfrom manim import *\nfrom functools import reduce\nimport random\nimport itertools as it\nimport random\n\nclass ColorfulArray(Scene):\n\n    def construct(self):\n        random_integers = [random.randint(0, 255) for _ in range(60)]\n        result = [random_integers[i:i + 3] for i in range(0, len(random_integers), 3)]\n        big_list = [result[i:i + 5] for i in range(0, len(result), 5)]\n        print(big_list)\n        image = ImageMobject(np.uint8(big_list))\n        image.set_resampling_algorithm(RESAMPLING_ALGORITHMS['box'])\n        image.height = 10\n        self.add(image)"}]}
{"messages": [{"role": "user", "content": "Generate a 5x5 grid of randomly colored pixels with a box resampling algorithm."}, {"role": "assistant", "content": "from time import sleep\nfrom manim import *\nfrom functools import reduce\nimport random\nimport itertools as it\nimport random\n\nclass UseRGB(Scene):\n\n    def convert_to_3d_rgb(self, rgb_list):\n        result = []\n        for row in rgb_list:\n            new_row = []\n            for rgb in row:\n                r = rgb >> 16 & 255\n                g = rgb >> 8 & 255\n                b = rgb & 255\n                new_row.append([r, g, b])\n            result.append(new_row)\n        return result\n\n    def convert_hex_to_int(hex_string):\n        return int(hex_string[1:], 16)\n\n    def construct(self):\n        random_int = [random.randint(0, 255) for _ in range(5 * 5 * 3)]\n        color_group = np.array(random_int).reshape(5, 5, 3)\n        random_int = color_group\n        image = ImageMobject(np.uint8(random_int))\n        print(image.get_pixel_array())\n        image.set_resampling_algorithm(RESAMPLING_ALGORITHMS['box'])\n        image.height = 5\n        self.add(image)\n        return super().construct()"}]}
{"messages": [{"role": "user", "content": "Generate a Sierpinski triangle animation that iteratively scales and transforms."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestSierpinski(Scene):\n    \"\"\"\n    \u8fd9\u662f\u4e00\u4efd\u7528\u6765\u68c0\u6d4b\u4e0a\u9762\u7684Sierpinski\u7c7b\u6709\u6ca1\u6709\u51fa\u95ee\u9898\u7684\u4e00\u4e2aScene\n    \u7ed3\u679c\u663e\u793a\u975e\u5e38\u6b63\u5e38\uff0c\u5f53\u7136\u4e5f\u987a\u4fbf\u723d\u6e32\u67d3\u4e86\u4e00\u628a\u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62\n    \"\"\"\n\n    def construct(self):\n        sierpinskistage = VGroup()\n        sierpinskistage.add(Sierpinski().get_seed_shape())\n        sierpinskistage.set_opacity(0.5).set_color([RED, YELLOW, BLUE])\n        for i in range(3):\n            self.play(Transform(sierpinskistage, selfsimilarfractal_iteration(sierpinskistage, 3, Sierpinski).scale(0.75)))\n        for i in range(3):\n            self.play(Transform(sierpinskistage, selfsimilarfractal_iteration(sierpinskistage, 3, Sierpinski).scale(0.55)))"}]}
{"messages": [{"role": "user", "content": "Render a Sierpinski carpet animation with text and transitioning shapes."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass RenderCover(Scene):\n    \"\"\"\n    \u8fd9\u4e2a\u662f\u7528\u6765\u6e32\u67d3\u5c01\u9762\u7684\n    \"\"\"\n\n    def construct(self):\n        text = Text('Sierpinski Carpet', weight=BOLD, font_size=40)\n        text.move_to(DOWN * 3.75)\n        var = Sierpinski().get_seed_shape()\n        var.set_opacity(0.55).set_color([RED, YELLOW, BLUE])\n        sierpinski = VGroup().add(var)\n        for i in range(3):\n            sierpinski = TestSierpinski.sierpinsk_ita(self, sierpinski).scale(0.8)\n        sierpinski.move_to(UP * 0.15)\n        self.add(sierpinski, text)"}]}
{"messages": [{"role": "user", "content": "Animate a diamond fractal evolving through multiple self-similar iterations."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestDiamondFractal(Scene):\n    \"\"\"\n    \u6ca1\u9519\uff0c\u8fd9\u4e2a\u6d4b\u8bd5\u4ee3\u7801\u662f\u6309\u7167\u4e0a\u9762\u7684\u8c22\u5c14\u5bbe\u65af\u57fa\u4e09\u89d2\u5f62\u7684\u6d4b\u8bd5\u4ee3\u7801\u6539\u8fc7\u6765\u7684\n    \u6e32\u67d3\u65f6\u95f4\u8f83\u957f\uff0c\u7a0d\u5b89\u52ff\u8e81\n    \"\"\"\n\n    def construct(self):\n        diamondstage = VGroup()\n        diamondstage.add(DiamondFractal().get_seed_shape())\n        diamondstage.set_opacity(0.5).set_color([RED, YELLOW, BLUE])\n        for i in range(3):\n            self.play(Transform(diamondstage, selfsimilarfractal_iteration(diamondstage, 4, DiamondFractal).scale(0.65)))\n        for i in range(3):\n            self.play(Transform(diamondstage, selfsimilarfractal_iteration(diamondstage, 4, DiamondFractal).scale(0.45)))"}]}
{"messages": [{"role": "user", "content": "Generate a pentagonal fractal by iteratively transforming a group of shapes."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestPentagonal(Scene):\n    \"\"\"\n    \u6d4b\u8bd5\u4e94\u8fb9\u5f62\u5206\u578b\u7684\u53ef\u884c\u6027\uff0c\uff0c\u4ee3\u7801\u8fd8\u662f\u7167\u6284\u4e0a\u9762\u7684\n    \"\"\"\n\n    def construct(self):\n        penstage = VGroup()\n        var = PentagonalFractal.get_seed_shape(self)\n        penstage.add(var)\n        for i in range(3):\n            self.play(Transform(penstage, selfsimilarfractal_iteration(penstage, 5, PentagonalFractal).scale(0.575)))"}]}
{"messages": [{"role": "user", "content": "Generate a fractal animation by iteratively transforming and scaling a hexagon shape."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestWonkyHexagon(Scene):\n\n    def construct(self):\n        penstage = VGroup()\n        var = WonkyHexagonFractal.get_seed_shape(self)\n        penstage.add(var)\n        for i in range(3):\n            self.play(Transform(penstage, selfsimilarfractal_iteration(penstage, 7, WonkyHexagonFractal).scale(0.5)))"}]}
{"messages": [{"role": "user", "content": "Generate a scene where a circular fractal is repeatedly transformed and scaled."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestCircular(Scene):\n\n    def construct(self):\n        penstage = VGroup()\n        var = CircularFractal.get_seed_shape(self)\n        penstage.add(var)\n        for i in range(6):\n            self.play(Transform(penstage, selfsimilarfractal_iteration(penstage, 3, CircularFractal).scale(0.5)))"}]}
{"messages": [{"role": "user", "content": "Animate a sequence of Hilbert curves transforming into increasingly complex versions of themselves."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestHilbertCurve(Scene):\n\n    def construct(self):\n        num = 7\n        hilbert_group = [HilbertCurve() for i in range(num)]\n        for i in range(num):\n            hilbert_group[i].order = i + 1\n            hilbert_group[i].init_points()\n            hilbert_group[i].init_colors()\n            hilbert_group[i].set_stroke(width=4)\n        self.play(Create(hilbert_group[0]))\n        self.wait()\n        for i in range(len(hilbert_group) - 1):\n            self.play(ReplacementTransform(hilbert_group[i], hilbert_group[i + 1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the creation and sequential transformation of four Peano curves of increasing order."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestPeanoCurve(Scene):\n\n    def construct(self):\n        num = 4\n        peano_group = [PeanoCurve() for i in range(num)]\n        for i in range(num):\n            peano_group[i].order = i + 1\n            peano_group[i].init_points()\n            peano_group[i].init_colors()\n            peano_group[i].set_stroke(width=4)\n        self.play(Create(peano_group[0]))\n        self.wait()\n        for i in range(len(peano_group) - 1):\n            self.play(ReplacementTransform(peano_group[i], peano_group[i + 1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the creation of a Peano curve of order 2, followed by the creation of another scaled Peano curve and its anchor points."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass RenderCover2(Scene):\n\n    def construct(self):\n        peano_curve = PeanoCurve()\n        peano_curve.set_stroke(width=4)\n        peano_curve.order = 2\n        pe1 = peano_curve.copy()\n        peano_curve.init_points()\n        peano_curve.init_colors()\n        peano_curve.scale(1.45)\n        points = peano_curve.get_anchor_points()\n        pe1.set_points(points)\n        dots = VGroup()\n        for var in points:\n            dots.add(Dot(radius=0.01).move_to(var * 1.45))\n        self.add(dots)\n        self.play(Create(peano_curve), run_time=2, rate_func=lambda t: t)\n        self.wait()\n        self.play(Create(pe1.scale(1.45)), run_time=2)"}]}
{"messages": [{"role": "user", "content": "Animate a sequence of increasing order triangle filling curves, transforming from one to the next."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestTriangleFillingCurve(Scene):\n\n    def construct(self):\n        num = 5\n        triangle_group = [TriangleFillingCurve() for i in range(num)]\n        for i in range(num):\n            triangle_group[i].order = i + 1\n            triangle_group[i].init_points()\n            triangle_group[i].init_colors()\n            triangle_group[i].set_stroke(width=4)\n        self.play(Create(triangle_group[0]))\n        self.wait()\n        for i in range(len(triangle_group) - 1):\n            self.play(ReplacementTransform(triangle_group[i], triangle_group[i + 1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a sequence of FlowSnake objects transforming into each other with increasing order."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestFlowSnake(Scene):\n\n    def construct(self):\n        num = 5\n        flowsnake_group = [FlowSnake() for i in range(num)]\n        for i in range(num):\n            flowsnake_group[i].order = i + 2\n            flowsnake_group[i].init_points()\n            flowsnake_group[i].init_colors()\n            flowsnake_group[i].set_stroke(width=4)\n        self.play(Create(flowsnake_group[0]))\n        self.wait()\n        for i in range(len(flowsnake_group) - 1):\n            self.play(ReplacementTransform(flowsnake_group[i], flowsnake_group[i + 1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate a sequence of Sierpinski curves, showing each progressively higher order replacing the previous one."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestSierpinskiCurve(Scene):\n\n    def construct(self):\n        num = 6\n        sierpinski_group = [SierpinskiCurve() for i in range(num)]\n        for i in range(num):\n            sierpinski_group[i].order = i + 2\n            sierpinski_group[i].init_points()\n            sierpinski_group[i].init_colors()\n            sierpinski_group[i].set_stroke(width=4)\n        self.play(Create(sierpinski_group[0]))\n        self.wait()\n        for i in range(len(sierpinski_group) - 1):\n            self.play(ReplacementTransform(sierpinski_group[i], sierpinski_group[i + 1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a sequence of Koch snowflakes, each with an increasing order of complexity, transitioning from one to the next."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestKochSnowFlake(Scene):\n\n    def construct(self):\n        num = 3\n        kochsnow_group = [KochSnowFlake() for i in range(num)]\n        for i in range(num):\n            kochsnow_group[i].order = i + 2\n            kochsnow_group[i].init_points()\n            kochsnow_group[i].init_colors()\n        self.play(Create(kochsnow_group[0]))\n        self.wait()\n        for i in range(len(kochsnow_group) - 1):\n            self.play(ReplacementTransform(kochsnow_group[i], kochsnow_group[i + 1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate a sequence of Koch curves, transforming from one order to the next."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestKochCurve(Scene):\n\n    def construct(self):\n        num = 3\n        kochcurve_group = [KochCurve() for i in range(num)]\n        for i in range(num):\n            kochcurve_group[i].order = i + 2\n            kochcurve_group[i].init_points()\n            kochcurve_group[i].init_colors()\n        self.play(Create(kochcurve_group[0]))\n        self.wait()\n        for i in range(len(kochcurve_group) - 1):\n            self.play(ReplacementTransform(kochcurve_group[i], kochcurve_group[i + 1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a series of increasingly complex quadratic Koch snowflakes, transitioning from one to the next."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestQuadraticKoch(Scene):\n\n    def construct(self):\n        num = 4\n        quadratic_group = [QuadraticKoch() for i in range(num)]\n        for i in range(num):\n            quadratic_group[i].order = i + 2\n            quadratic_group[i].init_points()\n            quadratic_group[i].init_colors()\n            quadratic_group[i].scale(3)\n        self.play(Create(quadratic_group[0]))\n        self.wait()\n        for i in range(len(quadratic_group) - 1):\n            self.play(ReplacementTransform(quadratic_group[i], quadratic_group[i + 1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a sequence of increasingly complex Quadratic Koch Islands, transforming from one to the next."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestQuadraticKochIsland(Scene):\n\n    def construct(self):\n        num = 3\n        quadratickocgisland_group = [QuadraticKochIsland() for i in range(num)]\n        for i in range(num):\n            quadratickocgisland_group[i].order = i + 2\n            quadratickocgisland_group[i].init_points()\n            quadratickocgisland_group[i].init_colors()\n        self.play(Create(quadratickocgisland_group[0]))\n        self.wait()\n        for i in range(len(quadratickocgisland_group) - 1):\n            self.play(ReplacementTransform(quadratickocgisland_group[i], quadratickocgisland_group[i + 1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the creation and sequential transformation of four stellar curves with increasing order and scale."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestStellarCurve(Scene):\n\n    def construct(self):\n        num = 4\n        stellarcurve_group = [StellarCurve() for i in range(num)]\n        for i in range(num):\n            stellarcurve_group[i].order = i + 2\n            stellarcurve_group[i].init_points()\n            stellarcurve_group[i].init_colors()\n            stellarcurve_group[i].scale(2)\n        self.play(Create(stellarcurve_group[0]))\n        self.wait()\n        for i in range(len(stellarcurve_group) - 1):\n            if i < len(stellarcurve_group) - 1 - 1:\n                self.play(ReplacementTransform(stellarcurve_group[i], stellarcurve_group[i + 1]))\n            else:\n                self.play(ReplacementTransform(stellarcurve_group[i], stellarcurve_group[i + 1].scale(0.9)))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Generate an animation of multiple snake curves appearing sequentially, with each subsequent curve transforming from the previous one."}, {"role": "assistant", "content": "from functools import reduce\nimport random\nfrom manim import *\nimport itertools as it\n\nclass TestSnakeCurve(Scene):\n\n    def construct(self):\n        num = 6\n        snakecurve_group = [SnakeCurve() for i in range(num)]\n        for i in range(num):\n            snakecurve_group[i].order = i + 2\n            snakecurve_group[i].init_points()\n            snakecurve_group[i].init_colors()\n            snakecurve_group[i].scale(1.3)\n        self.play(Create(snakecurve_group[0]))\n        self.wait()\n        for i in range(len(snakecurve_group) - 1):\n            self.play(ReplacementTransform(snakecurve_group[i], snakecurve_group[i + 1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate Manim's `Code` Mobject by displaying example Python code with various syntax highlighting styles."}, {"role": "assistant", "content": "from manim import *\n\nclass CodeMobject(Scene):\n\n    def construct(self):\n        I = Title('Code Mobject').move_to(ORIGIN).set_color(BLUE)\n        I1 = Text('Code Mobject adalah salah satu Mobject atau Preset yang dapat menampilkan kode\\ndari berbagai bahasa pemrograman dengan highlight sesuai dengan style yang tersedia.').scale(0.5)\n        I2 = Text('Berikut adalah 18 Style yang telah tersedia.').scale(0.5)\n        self.play(Write(I))\n        self.wait()\n        self.play(Uncreate(I))\n        self.play(Write(I1))\n        self.wait()\n        self.play(Uncreate(I1))\n        self.play(Write(I2))\n        self.wait()\n        self.play(Uncreate(I2))\n        self.wait()\n        code = 'from manim import*\\nclass CodeFromString(Scene):\\n    def construct(self):\\n        code = \\'\\'\\' Tulis Kode di sini\\n\\'\\'\\'\\n        rendered_code = Code(code=code, tab_width=4, background=\"window\",\\n                            language=\"Python\", font=\"Monospace\")\\n        self.play(Write(rendered_code))\\n        self.wait()\\n        self.play(Uncreate(rendered_code))\\n'\n        code_styles_list = {0: 'autumn', 1: 'borland', 2: 'bw', 3: 'colorful', 4: 'default', 5: 'emacs', 6: 'friendly', 7: 'fruity', 8: 'manni', 9: 'monokai', 10: 'murphy', 11: 'native', 12: 'pastie', 13: 'perldoc', 14: 'rrt', 15: 'tango', 16: 'trac', 17: 'vim', 18: 'vs'}\n        for number, styles in code_styles_list.items():\n            listing = Code(code=code, tab_width=4, background_stroke_width=1, background_stroke_color=WHITE, insert_line_no=True, style=Code.styles_list[number], background='window', language='python')\n            listing.scale(0.8)\n            Title1 = Text(f'This is code_style {number} name : {styles}', font='consolas', color=BLUE).next_to(listing, 1.5 * UP)\n            ccc = VGroup(Title1, listing)\n            D = VGroup()\n            D.add(ccc).arrange_in_grid()\n            self.play(Write(ccc))\n            self.wait()\n            self.play(FadeOut(ccc))\n            self.wait()\n        Z = Text('Thanks For Watching').set_color_by_gradient(GREEN, YELLOW)\n        self.play(Write(Z))\n        self.wait()\n        self.play(Uncreate(Z))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display the polar equation for the butterfly graph, its parametric equations, and then animate the graph of the polar equation on a polar plane."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\n\nclass Butterfly(Scene):\n\n    def construct(self):\n        J = Title('Butterfly Graph')\n        self.play(Write(J))\n        self.wait()\n        self.play(FadeOut(J))\n        P = Text('Persamaan Polar')\n        P.to_edge(UP)\n        PP = MathTex('r = e^{\\\\sin \\\\theta} - 2 \\\\cos(4\\\\theta)+ \\\\sin^5 \\\\left[ \\\\dfrac{1}{24}\\\\left(2\\\\theta-\\\\pi\\\\right) \\\\right]')\n        PP.next_to(P, DOWN)\n        PR = Text('Persamaan Parametrik')\n        PR.next_to(PP, DOWN)\n        PRX = MathTex('x = \\\\sin t \\\\left[e^{\\\\cos t}-2\\\\cos \\\\left( 4t \\\\right) + \\\\sin^5 \\\\left(\\\\dfrac{1}{12}t\\\\right) \\\\right]')\n        PRY = MathTex('y = \\\\cos t \\\\left[e^{\\\\cos t}-2\\\\cos \\\\left( 4t \\\\right) + \\\\sin^5 \\\\left(\\\\dfrac{1}{12}t\\\\right) \\\\right]')\n        PRX.next_to(PR, DOWN)\n        PRY.next_to(PRX, DOWN)\n        self.play(Write(P))\n        self.play(Write(PP))\n        self.play(Write(PR))\n        self.play(Write(PRX), Write(PRY))\n        self.wait(2)\n        self.play(FadeOut(*self.mobjects))\n        'Range = [0,24*PI]'\n        plane = PolarPlane(radius_max=24 * PI)\n        r = lambda t: np.exp(np.sin(t)) - 2 * np.cos(4 * t) + np.sin(1 / 24 * (2 * t - PI)) ** 5\n        graph = plane.plot(r, [0, 24 * PI], color=GREEN)\n        VGroup(plane, graph).scale(0.1)\n        self.play(Create(plane))\n        self.play(Create(graph))\n        self.wait(5)\n        self.play(Uncreate(graph), Uncreate(plane))\n        O = Text('Thanks For Watching')\n        O.scale(2)\n        self.play(FadeIn(O))\n        self.wait()\n        self.play(FadeOut(O))"}]}
{"messages": [{"role": "user", "content": "Visualize the constant pi as a Fourier epicycles drawing."}, {"role": "assistant", "content": "from manim import *\n\nclass Pi(Scene):\n\n    def construct(self):\n        N = 1000\n        tex = '\\\\pi'\n        shape = Tex(tex)\n\n        def get_shape(shape):\n            path = VMobject()\n            shape = shape\n            for sp in shape.family_members_with_points():\n                path.append_points(sp.get_points())\n            return path\n        path = get_shape(shape)\n        complex_points = np.array([complex(*path.point_from_proportion(alpha)[:2]) for alpha in np.arange(0, 1, 1 / N)])\n        complex_points = (complex_points - np.mean(complex_points)) / np.max(abs(complex_points)) * 4\n        ec = FourierEpicyclesMObject(complex_points, num_coefs=1000, speed_factor=1, circles_color='#118ab2', circles_opacity=1)\n        self.add(ec)\n        self.wait(2 * TAU)"}]}
{"messages": [{"role": "user", "content": "Animate a \"Thanks For Watching\" text with a blue-to-green gradient, then fade it out."}, {"role": "assistant", "content": "from manim import *\n\nclass Outro(Scene):\n\n    def construct(self):\n        A = Text('Thanks For Watching')\n        A.set_color_by_gradient(BLUE, GREEN).scale(1.5)\n        self.play(Create(A))\n        self.wait()\n        self.play(FadeOut(A))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a row of letters transforming into a row of math symbols, then scale and fade out the symbols."}, {"role": "assistant", "content": "from manim import *\n\nclass c(Scene):\n\n    def construct(self):\n        a1 = VGroup(Text('F'), Text('I'), Text('L'), Text('L'), Text('A'), Text('H'))\n        a1.scale(4).shift(4 * UP)\n        a1.arrange(RIGHT)\n        a2 = Tex('$\\\\vec{F}$', '$\\\\sqrt{-1}$', '$\\\\lambda^2$', '$\\\\alpha$', '$\\\\eta$')\n        a1[1].set_color(PURPLE)\n        a1[2].set_color(RED)\n        a1[3].set_color(GREEN)\n        a1[0].set_color(BLUE)\n        a1[4].set_color(BLUE)\n        a1[5].set_color(RED)\n        a2[0].set_color(BLUE)\n        a2[1].set_color(RED)\n        a2[2].set_color(GREEN)\n        a2[3].set_color(PURPLE)\n        a2[4].set_color(GREY)\n        a2.next_to(a1, 2 * DOWN).scale(2)\n        self.play(Write(a1))\n        self.wait(1)\n        self.play(TransformFromCopy(a1, a2))\n        self.wait(1)\n        self.play(FadeOut(a1), ApplyMethod(a2.move_to, ORIGIN))\n        self.wait(1)\n        self.play(ApplyMethod(a2.scale, 1.5))\n        self.wait(1)\n        self.play(FadeOut(a2))"}]}
{"messages": [{"role": "user", "content": "Display a \"Countdown\" title, animate a countdown from 10 to -1, show the Python code for the animation, and conclude with a \"Thanks For Watching\" message."}, {"role": "assistant", "content": "from manim import *\n\nclass Count(Scene):\n\n    def construct(self):\n        code = 'from manim import*\\nconfig.background_color = WHITE\\nclass Count(Scene):\\n    def construct(self):\\n        number = Text(\"10\").set_color(BLACK).scale(4)\\n        self.play(Write(number))\\n        for i in range(9,-2,-1):\\n            if i != -1 :\\n                self.play(Transform(number,\\n                Text(str(i)).set_color(BLACK).scale(4)),run_time=1)\\n                self.wait()\\n            elif i == -1 :\\n                self.play(Transform(number,\\n                Text(str(i)).set_color(WHITE).scale(4)),run_time=0.05)\\n        self.wait()\\n'\n        Title = Text('Countdown').set_color(BLACK).scale(2)\n        self.play(DrawBorderThenFill(Title))\n        self.wait()\n        self.play(Uncreate(Title))\n        number = Text('10').set_color(BLACK).scale(4)\n        self.play(Write(number))\n        self.wait()\n        for i in range(9, -2, -1):\n            if i != -1:\n                self.play(Transform(number, Text(str(i)).set_color(BLACK).scale(4)), run_time=1)\n                self.wait()\n            elif i == -1:\n                self.play(Transform(number, Text(str(i)).set_color(WHITE).scale(4)), run_time=0.001)\n        self.wait(0.5)\n        codes = Code(code=code, tab_width=4, background_stroke_width=1, background_stroke_color=WHITE, insert_line_no=True, style=Code.styles_list[14], background='window', language='python').scale(0.8)\n        self.play(Write(codes))\n        self.wait(3)\n        self.play(FadeOut(codes))\n        A = Text('Thanks For Watching').scale(1.5).set_color(BLACK)\n        self.play(GrowFromCenter(A))\n        self.wait()\n        self.play(FadeOut(A))"}]}
{"messages": [{"role": "user", "content": "Animate a 2x2 Rubik's cube with a dark background, smoothly rotating its camera while also rotating the cube itself randomly."}, {"role": "assistant", "content": "from manim import *\nfrom manim_rubikscube import *\nfrom random import *\n\nclass Rubiks(ThreeDScene):\n\n    def construct(self):\n        self.camera.background_color = '#0E1B24'\n        cube = RubiksCube(dim=2, x_offset=1e-15, y_offset=1e-15, z_offset=1e-15).scale(0.75)\n        cube.move_to(ORIGIN)\n        self.move_camera(phi=50 * DEGREES, theta=0 * DEGREES)\n        self.renderer.camera.frame_center = cube.get_center()\n        self.play(FadeIn(cube))\n        angle = ['theta', 'gamma', 'phi']\n        for a in range(20):\n            a = choice(angle)\n            self.begin_ambient_camera_rotation(rate=1, about=a)\n            self.play(Rotating(cube, radians=2 * PI, run_time=1))\n            self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Animate Conway's Game of Life, demonstrating various patterns like gliders, still lifes, oscillators, and spaceships, along with explanations of its rules."}, {"role": "assistant", "content": "import manimlib\nfrom manimlib import *\nimport sys\nfrom life_game import Life\n\nclass AppLife(Scene):\n\n    def construct(self) -> None:\n        num_rows = 40\n        num_cols = 72\n        life = Life(num_rows, num_cols)\n        grid = AppLife.create_grid(num_rows, num_cols, cell_height=14)\n        self.add(grid)\n        self.glider(grid, life, num_generations=30, wait_time=0.1)\n        self.show_title_n_body(title='Game of Life', body=\"Conway's Game of Life is a zero player game with a few simple rules\", wait_time=2.5)\n        self.show_rules(grid, life)\n        self.clear_screen(grid, life)\n        self.show_text('These rules turn simple starting patterns into complex ones.\\nSome completely vanish and some keep progressing forever', font_size=BODY_FONT_SIZE, wait_time=2.5)\n        self.clear_screen(grid, life)\n        self.show_text('R Pentomino', font_size=TITLE_FONT_SIZE, wait_time=1)\n        self.r_pentomino(grid, life, num_generations=1, wait_time=1)\n        self.wait(0.5)\n        self.r_pentomino(grid, life, num_generations=70)\n        self.clear_screen(grid, life)\n        self.show_title_n_body('Still Life', 'Patterns that do not change in subsequent generations')\n        self.still_life(grid, life, num_generations=15)\n        self.clear_screen(grid, life)\n        self.show_title_n_body('Oscillators', 'Come back to initial state after a few generations')\n        self.oscillators(grid, life, num_generations=25, wait_time=0.3)\n        self.clear_screen(grid, life)\n        self.show_title_n_body('Gosper Glider Gun', 'Emits a Glider at every 30th generation (discovered in 1970)')\n        self.glider_gun(grid, life, num_generations=1, wait_time=1)\n        self.wait(0.5)\n        self.glider_gun(grid, life, num_generations=90, wait_time=0.05)\n        self.clear_screen(grid, life)\n        self.show_title_n_body('Copperhead', 'Spaceship (discovered in 2016)')\n        self.copperhead(grid, life, num_generations=1, wait_time=1)\n        self.wait(0.5)\n        self.copperhead(grid, life, num_generations=100, wait_time=0.1)\n        self.clear_screen(grid, life)\n        self.show_question()\n\n    @staticmethod\n    def create_grid(num_rows, num_cols, cell_height=6):\n        square = Square()\n        square.set_fill(BLACK, opacity=_BLACK_OPACITY)\n        square.set_stroke(BLACK, width=0)\n        grid = square.get_grid(num_rows, num_cols, height=cell_height)\n        grid.arrange_in_grid(n_rows=num_rows, n_cols=num_cols, h_buff=0, v_buff=0)\n        return grid\n\n    def animate_grid(self, grid, life, num_generations, wait_time=0.1):\n        generation = 1\n        while generation <= num_generations:\n            self.wait(wait_time)\n            for i in range(len(life.board)):\n                for j in range(len(life.board[0])):\n                    grid_idx = life.num_cols * i + j\n                    if life.board[i][j] == 1:\n                        grid[grid_idx].set_fill(CUSTOM_WHITE)\n                        grid[grid_idx].set_stroke(BLACK, width=0.3)\n                    else:\n                        grid[grid_idx].set_fill(BLACK, opacity=_BLACK_OPACITY)\n            life.compute_next_state()\n            generation += 1\n\n    def show_title_n_body(self, title, body, wait_time=2.5):\n        title = Text(title, font_size=TITLE_FONT_SIZE, font=FONT_FAMILY)\n        body = Text(body, font_size=BODY_FONT_SIZE, font=FONT_FAMILY)\n        vgroup = VGroup(title, body).arrange(DOWN, buff=TITLE_BODY_BUFFER, center=False, aligned_edge=LEFT)\n        vgroup.to_edge(UP)\n        vgroup.to_edge(LEFT)\n        self.play(FadeIn(vgroup))\n        self.wait(wait_time)\n\n    def show_text(self, text_str, font_size, wait_time=2.5):\n        text = Text(text_str, font_size=font_size, font=FONT_FAMILY)\n        text.to_edge(UP)\n        text.to_edge(LEFT)\n        self.play(FadeIn(text))\n        self.wait(wait_time)\n\n    def show_question(self, wait_time=3):\n        text = Text('Q: Given a state of the board, is it possible to tell whether\\na certain pattern will vanish or live forever?', font_size=BODY_FONT_SIZE, font=FONT_FAMILY)\n        text.to_edge(UP)\n        text.to_edge(LEFT)\n        credits_text = Text('code: github.com/emadehsan/life', font_size=BODY_FONT_SIZE, font=FONT_FAMILY)\n        credits_text.to_edge(BOTTOM)\n        text.to_edge(LEFT)\n        self.play(FadeIn(text))\n        self.wait(wait_time)\n        self.play(FadeIn(credits_text))\n        self.wait(wait_time)\n\n    def show_rules(self, grid, life, wait_time=1.5):\n        rules = [{'title': 'Underpopulation', 'body': 'A live cell with fewer than two neighbours dies'}, {'title': 'Survival', 'body': 'A cell with two or three neighbours lives on to the next generation'}, {'title': 'Overpopulation', 'body': 'A cell with more than three neighbours dies'}, {'title': 'Reproduction', 'body': 'A dead cell with exactly three neighbours becomes a live cell'}]\n        board_state_functions = [life.put_underpopulation_example, life.put_survival_example, life.put_overpopulation_example, life.put_reproduction_example]\n        flash_indexes = [(0, 4), (-1, -1), (1, 1), (0, 1)]\n        for i, rule in enumerate(rules):\n            self.clear_screen(grid, life)\n            title = Text(rule['title'], font_size=TITLE_FONT_SIZE, font=FONT_FAMILY)\n            body = Text(rule['body'], font_size=BODY_FONT_SIZE, font=FONT_FAMILY)\n            vgroup = VGroup(title, body).arrange(DOWN, buff=TITLE_BODY_BUFFER, center=False, aligned_edge=LEFT)\n            vgroup.to_edge(UP)\n            vgroup.to_edge(LEFT)\n            self.play(FadeIn(vgroup))\n            self.display_rule_example(grid, life, board_state_functions[i], flash_indexes[i])\n            self.wait(wait_time)\n\n    def clear_screen(self, grid, life):\n        life.clear_board()\n        self.animate_grid(grid, life, num_generations=1)\n        self.clear()\n        self.add(grid)\n\n    def glider(self, grid, life, num_generations, wait_time=0.1):\n        life.clear_board()\n        life.put_glider_at(life.num_rows // 3, life.num_cols // 3)\n        self.animate_grid(grid, life, num_generations, wait_time)\n\n    def glider_gun(self, grid, life, num_generations, wait_time=0.1):\n        life.clear_board()\n        life.put_glider_gun(life.num_rows // 2 - 5, life.num_cols // 5)\n        self.animate_grid(grid, life, num_generations, wait_time)\n\n    def display_rule_example(self, grid, life: Life, set_board_state_func, flash_index, wait_time=1) -> None:\n        i = life.num_rows // 2 - 1\n        j = life.num_cols // 2 - 1\n        set_board_state_func(i, j)\n        self.animate_grid(grid, life, num_generations=1, wait_time=wait_time)\n        self.wait(wait_time)\n        a, b = flash_index\n        if a >= 0 and b >= 0:\n            self.play(Flash(grid[life.num_cols * (i + a) + (j + b)], color=RED_A, flash_radius=0.4))\n        self.animate_grid(grid, life, num_generations=1, wait_time=wait_time)\n        self.wait(wait_time)\n\n    def r_pentomino(self, grid, life, num_generations, wait_time=0.1):\n        life.clear_board()\n        life.put_r_pentomino(life.num_rows // 2, life.num_cols // 2)\n        self.animate_grid(grid, life, num_generations, wait_time)\n\n    def put_counter(self, wait_time):\n        counter = DecimalNumber(1)\n\n        def update_func(t):\n            return t * 10\n        counter.to_edge(UP)\n        counter.to_edge(RIGHT)\n        self.play(ChangingDecimal(counter, update_func), run_time=wait_time)\n\n    def still_life(self, grid, life, num_generations, wait_time=0.2):\n        life.clear_board()\n        life.put_still_life()\n        self.animate_grid(grid, life, num_generations, wait_time)\n\n    def oscillators(self, grid, life, num_generations, wait_time=0.2):\n        life.clear_board()\n        life.put_oscillators()\n        self.animate_grid(grid, life, num_generations, wait_time)\n\n    def copperhead(self, grid, life, num_generations, wait_time=0.2):\n        life.clear_board()\n        life.put_copperhead(life.num_rows // 2 - 4, life.num_cols // 2 - 6)\n        self.animate_grid(grid, life, num_generations, wait_time)"}]}
{"messages": [{"role": "user", "content": "Display graphs for the Sigmoid, ReLU, and Tanh functions along with their names and formulas."}, {"role": "assistant", "content": "from manimlib import *\n\nclass graph_scene(Scene):\n\n    def construct(self):\n        axes = Axes((-5, 5), (0, 1), y_axis_config={'decimal_number_config': {'num_decimal_places': 1}}, width=10).scale(0.4).shift(0.5 * UP)\n        sigmoid_graph = axes.get_graph(lambda x: 1.0 / (1.0 + math.exp(-x)), use_smoothing=False, color=YELLOW)\n        axes1 = Axes((-3, 5), (0, 5), y_axis_config={'decimal_number_config': {'num_decimal_places': 1}}, width=10).scale(0.4).shift(0.5 * DOWN)\n        relu_graph = axes1.get_graph(lambda x: max(0, x), use_smoothing=False, color=YELLOW)\n        axes2 = Axes((-5, 5), (-1, 1), y_axis_config={'decimal_number_config': {'num_decimal_places': 1}}, width=10).scale(0.4).shift(0.5 * DOWN)\n        tanh_graph = axes2.get_graph(lambda x: (math.exp(x) - math.exp(-x)) / (math.exp(x) + math.exp(-x)), use_smoothing=False, color=YELLOW)\n        sigmoid_name = TexText('Sigmoid Function').next_to(axes, DOWN)\n        relu_name = TexText('ReLU Function').next_to(axes1, DOWN)\n        tanh_name = TexText('Tanh Function').next_to(axes2, DOWN)\n        softmax_formula = Tex('\\\\text{Softmax}(x)=\\\\frac{e^z}{\\\\sum e^z}')\n        softmax_name = TexText('Softmax Function').next_to(softmax_formula, DOWN)\n        sigmoid_grp = VGroup(axes, sigmoid_graph, sigmoid_name).shift(1.2 * UP + 3 * LEFT)\n        relu_grp = VGroup(axes1, relu_graph, relu_name).shift(2.2 * UP + 3 * RIGHT)\n        tanh_grp = VGroup(axes2, tanh_graph, tanh_name).shift(1.5 * DOWN + 3 * LEFT)\n        softmax_grp = VGroup(softmax_name, softmax_formula).shift(2 * DOWN + 3 * RIGHT)\n        self.play(Write(sigmoid_grp))\n        self.wait()\n        self.play(Write(relu_grp))\n        self.wait()\n        self.play(Write(tanh_grp))\n        self.wait()\n        self.play(Write(softmax_grp))"}]}
{"messages": [{"role": "user", "content": "Animate a neural network with neurons and edges, then display a title and quote about machine learning."}, {"role": "assistant", "content": "from manimlib import *\nimport random\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\nclass NeuralNetwork(Scene):\n    arguments = {'network_size': 1, 'network_position': ORIGIN, 'layer_sizes': [6, 12, 10, 8, 6, 2], 'layer_buff': 1.25 * LARGE_BUFF, 'neuron_radius': 0.15, 'neuron_color': WHITE, 'neuron_width': 2, 'neuron_fill_color': BLACK, 'neuron_fill_opacity': 1, 'neuron_buff': MED_SMALL_BUFF, 'edge_color': YELLOW_B, 'edge_width': 2, 'edge_opacity': 1, 'layer_label_color': WHITE, 'layer_label_size': 0.5, 'neuron_label_color': WHITE}\n\n    def construct(self):\n        self.add_neurons()\n        self.add_edges()\n        self.group1()\n        self.intro()\n        self.grp.n = self.n\n        self.grp.add(self.n)\n        return self.grp\n\n    def group1(self):\n        grp = VGroup()\n        grp.layers = self.layers\n        grp.edges = self.edge_groups\n        grp.add(self.layers)\n        grp.add(self.edge_groups)\n        self.grp = grp\n        return grp\n\n    def intro(self):\n        grp1 = self.grp.copy().scale(0.8).shift(3 * RIGHT)\n        self.play(Transform(self.grp, grp1))\n        neural = TexText('Neural')\n        title = VGroup(neural, TexText('Network Crash'), TexText('Course')).arrange(DOWN, aligned_edge=LEFT).shift(3.5 * LEFT).scale(1.1)\n        line1 = Line(title.get_corner(UP + LEFT), neural.get_corner(UP + RIGHT), color=YELLOW_E, stroke_width=5).next_to(title, UP).shift(LEFT)\n        line = Line(title.get_corner(DOWN + LEFT), title.get_corner(DOWN + RIGHT), color=YELLOW_E, stroke_width=5).next_to(title, DOWN)\n        self.play(Write(title), ShowCreation(line), ShowCreation(line1))\n        ml = Text('Machine Learning:', font='consolas', font_size=24)\n        self.quote = VGroup(ml, Text('Programming with examples,', font='consolas', font_size=24, t2c={'examples': YELLOW}), Text('not instructions.', font='consolas', font_size=24, t2c={'instructions': YELLOW}), Tex('-\\\\ Kyle\\\\ Mcdonald')).arrange(DOWN, aligned_edge=LEFT).to_edge(LEFT).shift(0.5 * RIGHT)\n        self.introgrp = VGroup(title, line, line1)\n        title.add(line1)\n        title.add(line)\n        self.title = title\n        self.animation(self.grp)\n\n    def add_neurons(self, animation=True):\n        self.loop = False\n        layers = VGroup(*[self.get_layer(size) for size in NeuralNetwork.arguments['layer_sizes']])\n        layers.arrange(RIGHT, buff=NeuralNetwork.arguments['layer_buff'])\n        layers.scale(NeuralNetwork.arguments['network_size'])\n        self.layers = layers\n        layers.shift(NeuralNetwork.arguments['network_position'])\n        self.play(FadeInFromPoint(layers, ORIGIN), run_time=2) if animation is True else None\n\n    def get_layer(self, size):\n        layer = VGroup()\n        n_neurons = size\n        neurons = VGroup(*[Circle(radius=NeuralNetwork.arguments['neuron_radius'], stroke_color=NeuralNetwork.arguments['neuron_color'], stroke_width=NeuralNetwork.arguments['neuron_width'], fill_color=NeuralNetwork.arguments['neuron_fill_color'], fill_opacity=NeuralNetwork.arguments['neuron_fill_opacity']) for i in range(n_neurons)])\n        neurons.arrange(DOWN, buff=NeuralNetwork.arguments['neuron_buff'])\n        layer.neurons = neurons\n        layer.add(neurons)\n        if size == 6 and self.loop == False:\n            self.neurons1 = neurons\n            self.loop = True\n        return layer\n\n    def edge_security(self):\n        self.edge_groups = VGroup()\n        for l1, l2 in zip(self.layers[:-1], self.layers[1:]):\n            edge_group = VGroup()\n            for n1, n2 in it.product(l1.neurons, l2.neurons):\n                edge = self.get_edge(n1, n2)\n                edge_group.add(edge)\n            self.edge_groups.add(edge_group)\n\n    def add_edges(self, animation=True, color=True):\n        self.edge_groups = VGroup()\n        for l1, l2 in zip(self.layers[:-1], self.layers[1:]):\n            edge_group = VGroup()\n            for n1, n2 in it.product(l1.neurons, l2.neurons):\n                edge = self.get_edge(n1, n2, color)\n                edge_group.add(edge)\n            self.play(Write(edge_group), run_time=0.5) if animation is True else None\n            self.edge_groups.add(edge_group)\n\n    def get_edge(self, neuron1, neuron2, color):\n        colors = [red1, blue1, blue1]\n        r = random.randint(0, len(colors) - 1)\n        return Line(neuron1.get_center(), neuron2.get_center(), buff=NeuralNetwork.arguments['neuron_radius'], stroke_color=GREY if color is False else colors[r], stroke_width=NeuralNetwork.arguments['edge_width'], stroke_opacity=NeuralNetwork.arguments['edge_opacity'])\n\n    def set_bias(self, x):\n        x1 = 0\n        for i in range(self.arguments['layer_sizes'][x]):\n            print(x, x1)\n            self.edge_groups[x][x1].set_color(GREY)\n            x1 += self.arguments['layer_sizes'][x + 1]\n\n    def animation(self, grop, backward_teaser=False, L=1):\n        input_data1 = self.read_data('test.csv', False)\n        output = self.read_data('my_submission.csv', False)\n        if backward_teaser is True:\n            y = np.array(pd.read_csv('data/without_training/output_real.csv').T.reset_index().drop('index', axis=1)[0])\n            y_hat = np.array(pd.read_csv('data/without_training/output.csv').T.reset_index().drop('index', axis=1)[0])\n            p = np.zeros((1, y_hat.shape[0]))\n            for i in range(0, y_hat.shape[0]):\n                if y_hat[i] > 0.5:\n                    p[0, i] = 1\n                else:\n                    p[0, i] = 0\n            print(y[0])\n            self.ans = Tex(str(y[1])).next_to(self.grp.layers[len(self.arguments['layer_sizes']) - 1], RIGHT).shift(RIGHT)\n        self.activate = False\n        ans_output = False\n        for i in range(L):\n            self.input_data(input_data1.T[i], True, backward_teaser=True, y=y, i=i + 1) if backward_teaser is True else self.input_data(input_data1.T[i], True)\n            for i1 in range(4):\n                df = self.read_data('activation' + str(i1 + 1) + '.csv', True) if backward_teaser is False else self.read_data('without_training/activation' + str(i1 + 1) + '.csv', True)\n                self.play(*[ApplyMethod(grop.layers[i1 + 1][0][x].set_fill, WHITE, float(df[x][i])) for x in range(len(df.T))])\n                if i1 == 1 and backward_teaser is False:\n                    print('DEY')\n                    self.play(TransformMatchingParts(self.title, self.quote, transform_mismatches=True))\n            print(output['Survived'][i], 6)\n            self.output_data(output['Survived'][i], len(self.arguments['layer_sizes']) - 1) if backward_teaser is False else self.output_data(int(list(p[0])[i + 1]), len(self.arguments['layer_sizes']) - 1, y[i + 1])\n            if backward_teaser is True:\n                self.grp.layers.set_fill(WHITE, 0)\n                self.play(FadeOut(self.fade_out))\n            if backward_teaser is True and i == 1:\n                accuracy = TexText('Accuracy: 38\\\\%').move_to([4, 3, 0])\n                self.play(Write(accuracy)) if ans_output is False else None\n                ans_output = True\n                self.wait()\n                weights_random = TexText('Weights are initialized randomly!').next_to(self.grp.layers[2], UP).to_edge(LEFT).shift(RIGHT + 0.5 * DOWN)\n                grp = self.grp.copy()\n                grp.shift(DOWN).scale(0.8)\n                n = self.n.copy()\n                for i in range(6):\n                    n[i].move_to(self.grp.layers[0][0][i].get_center())\n                self.play(self.grp.animate.shift(DOWN).scale(0.8), accuracy.animate.shift(2.5 * DOWN), self.ans.animate.next_to(grp.layers[len(self.arguments['layer_sizes']) - 1], RIGHT).shift(RIGHT), Transform(self.n, n))\n                self.play(Write(weights_random))\n                self.play(Write(TexText('= Guessing Game!').next_to(weights_random, RIGHT)))\n\n    def preload(self):\n        input_data1 = self.read_data('test.csv', False)\n        self.input_data(input_data1.T[0], False)\n        print(1)\n\n    def label_layers(self):\n        braces = Brace(self.layers[0], LEFT)\n        self.t = braces.get_text('Input Layer').scale(0.8).shift(0.5 * RIGHT)\n        self.play(GrowFromCenter(braces), Write(self.t))\n        self.wait()\n        grp = VGroup()\n        line = Line(self.grp.layers[1][0][0].get_center(), self.grp.layers[4][0][0].get_center())\n        braces1 = Brace(line, direction=line.copy().rotate(PI / 2).get_unit_vector())\n        t1 = braces1.get_text('Hidden Layer').scale(0.8).shift(0.5 * RIGHT)\n        self.play(GrowFromCenter(braces1), Write(t1))\n        braces2 = Brace(self.grp.output_label, RIGHT)\n        t2 = braces2.get_text('Output Layer').scale(0.8).shift(0.5 * LEFT)\n        self.play(GrowFromCenter(braces2), Write(t2))\n\n    def read_data(self, fil, activation):\n        foo = pd.read_csv('data/' + fil)\n        if activation == True:\n            scaler = MinMaxScaler()\n            d = scaler.fit_transform(foo.T)\n            scaled_df = pd.DataFrame(d)\n            scaled_df, scaled_df_selected = train_test_split(scaled_df, test_size=0.1, random_state=42)\n        else:\n            scaled_df, scaled_df_selected = train_test_split(foo, test_size=0.1, random_state=42)\n        return scaled_df_selected.reset_index().drop('index', axis=1)\n\n    def input_data(self, a, animate, backward_teaser=False, y=None, i=None):\n        n = VGroup()\n        for s in a:\n            t = Tex(str(round(int(s), 2)))\n            n.add(t)\n        n.arrange(DOWN, buff=0.3)\n        n.next_to(self.grp.layers, LEFT)\n        ans = Tex(str(y[i])).next_to(self.grp.layers[len(self.arguments['layer_sizes']) - 1], RIGHT).shift(RIGHT) if backward_teaser is True else None\n        print(ans, 'ans') if backward_teaser is True else None\n        n1 = n.copy()\n        n1.scale(0.2)\n        for i in range(6):\n            n1[i].move_to(self.neurons1[i].get_center())\n        if animate is True:\n            try:\n                self.play(FadeOut(self.n))\n            except:\n                pass\n            print('hello')\n            if backward_teaser is True:\n                self.play(Transform(n, n1), Write(self.ans)) if self.activate is False else self.play(Transform(n, n1), Transform(self.ans, ans))\n                self.activate = True\n            else:\n                self.play(Transform(n, n1))\n            self.n = n\n        else:\n            self.n = n1\n\n    def label_stuff(self):\n        a = [str(random.randint(1, 10)) for i in range(2)]\n        n = VGroup()\n        survived = Tex('Survive').scale(0.8)\n        not_survived = Tex('Not Survive').scale(0.8)\n        n.add(survived)\n        n.add(not_survived)\n        n.arrange(DOWN, buff=MED_SMALL_BUFF)\n        n.next_to(self.layers, RIGHT)\n        self.play(Write(n))\n        title = TexText('Neural Network of Titanic Dataset', tex_to_color_map={'Neural': WHITE}).to_edge(UP)\n        self.play(Write(title))\n        self.output_label = n\n\n    def output_data(self, a, layer, y=None):\n        print(a, layer, 'output')\n        if self.arguments['layer_sizes'][-1] != 1 and y is None:\n            self.layers[layer][0][0].set_fill(WHITE, 0)\n            self.layers[layer][0][1].set_fill(WHITE, 0)\n            self.play(ApplyMethod(self.layers[layer][0][a].set_fill, WHITE, 1))\n        elif self.arguments['layer_sizes'][-1] is 1 and y is not None:\n            not_equal = Tex('!=', color=RED).next_to(self.grp.layers[len(self.arguments['layer_sizes']) - 1], RIGHT)\n            equal = Tex('==', color=GREEN).next_to(self.grp.layers[len(self.arguments['layer_sizes']) - 1], RIGHT)\n            self.play(ApplyMethod(self.layers[layer][0][0].set_fill, WHITE, a))\n            self.play(Write(not_equal)) if a != y else self.play(Write(equal))\n            self.wait()\n            self.fade_out = not_equal if a != y else equal\n\n    def content(self):\n        content = VGroup(TexText('Course Overview:'), TexText('1. What is Neural Network?'), TexText('2. Neuron'), TexText('3. Weights,'), TexText('Bias and Connections').shift(RIGHT), TexText('4. Layers')).arrange(DOWN, aligned_edge=LEFT).to_edge(UP + LEFT)\n        self.grp.add(self.t)\n        self.play(ReplacementTransform(self.t, content))\n        self.grp.remove(self.t)"}]}
{"messages": [{"role": "user", "content": "Create the Microsoft logo with its name animated letter by letter."}, {"role": "assistant", "content": "from manim import *\n\nclass MicrosoftLogo(Scene):\n\n    def construct(self):\n        square_one = Square(side_length=1.0, fill_color=orange, stroke_color=orange, fill_opacity=1).shift(UP + LEFT * 2.0)\n        square_two = Square(side_length=1.0, fill_color=green, stroke_color=green, fill_opacity=1).next_to(square_one, RIGHT, buff=0.2)\n        square_three = Square(side_length=1.0, fill_color=blue, stroke_color=blue, fill_opacity=1).next_to(square_one, DOWN, buff=0.2)\n        square_four = Square(side_length=1.0, fill_color='#E19823', stroke_color='#E19823', fill_opacity=1).next_to(square_two, DOWN, buff=0.2)\n        self.play(DrawBorderThenFill(square_one), DrawBorderThenFill(square_two), DrawBorderThenFill(square_three), DrawBorderThenFill(square_four))\n        self.wait()\n        text = Text(text='Microsoft', font_size=60, t2w={'Microsoft': BOLD}, font='Arial').next_to(square_two, RIGHT, buff=0.75).shift(DOWN * 0.6)\n        self.play(AddTextLetterByLetter(text))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Create an animation displaying the word \"amazon\" with a curved arrow underneath it."}, {"role": "assistant", "content": "from manim import *\n\nclass Amazon(Scene):\n\n    def construct(self):\n        letter = Text(text='amazon', font='Roman', font_size=60, t2w={'amazon': BOLD})\n        arrow = CurvedArrow(start_point=np.array([-1.2, -0.35, 0]), end_point=np.array([0.5, -0.35, 0]), angle=1.25, tip_length=0.2, color='#ffb703')\n        self.play(Write(letter), Create(arrow), run_time=2.0)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Create the Instagram logo and then display the text \"code.py\" with a gradient color."}, {"role": "assistant", "content": "from manim import *\n\nclass instagram_logo(Scene):\n\n    def construct(self):\n        rect_1 = RoundedRectangle(corner_radius=0.3, height=1.5, width=1.5, color=PINK)\n        obj = Circle(radius=0.4, color=PINK).next_to(rect_1, DOWN, buff=-1.15)\n        dot = Dot(color=PINK).scale(0.6).next_to(obj, buff=0.15).shift(UP * 0.4)\n        self.play(Create(rect_1), Create(obj), FadeIn(dot), run_time=1.2)\n        self.wait()\n        group = VGroup(rect_1, obj, dot)\n        self.play(group.animate.shift(UP + LEFT * 4), run_time=1.2)\n        my_id1 = Text('_ ', font='Times New Roman').scale(1.5).next_to(group, buff=0.3).set_color(BLUE)\n        my_id2 = MathTex('\\\\textrm{\\\\bf{code.py}}').scale(1.5).set_color_by_gradient(BLUE, ORANGE).next_to(my_id1, buff=0.1).shift(UP * 0.1)\n        my_id3 = Text('_', font='Times New Roman').scale(1.5).set_color(ORANGE).next_to(my_id2, buff=0.05).shift(DOWN * 0.2)\n        self.play(Write(my_id1), Write(my_id2), Write(my_id3), run_time=1.2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate the Facebook logo by drawing a blue circle and a white 'f' in the center, then move the logo to the top left."}, {"role": "assistant", "content": "from manim import *\n\nclass FacebookIcon(Scene):\n\n    def construct(self):\n        my_circle = Circle(radius=1.6, color=DARK_BLUE, fill_opacity=1.0)\n        icon = Text('f', font='Calibri').scale(6.0).set_color(WHITE).move_to(my_circle).shift(DOWN * 0.25)\n        self.play(GrowFromCenter(my_circle), Write(icon), run_time=1.2)\n        self.wait()\n        my_group = VGroup(my_circle, icon)\n        self.play(my_group.animate.shift(UP + LEFT * 2), run_time=1.2)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a car driving along two paths."}, {"role": "assistant", "content": "from manim import *\n\nclass Car(Scene):\n\n    def construct(self):\n        my_rect = Rectangle(width=3, height=1.0, color=BLUE).to_edge(LEFT, buff=1).shift(DOWN * 0.9)\n        s1 = Square().shift(DOWN * 0.9).scale(0.2).to_edge(LEFT, buff=3.3)\n        s2 = Square().shift(DOWN * 0.9).scale(0.2).to_edge(LEFT, buff=2.3)\n        s3 = Square().shift(DOWN * 0.9).scale(0.2).to_edge(LEFT, buff=1.3)\n        tier_1 = Circle(radius=0.1, color=ORANGE, fill_opacity=1.0).next_to(my_rect, DOWN, buff=0.02).shift(LEFT * 1)\n        tier_2 = Circle(radius=0.1, color=ORANGE, fill_opacity=1).next_to(my_rect, DOWN, buff=0.02).shift(RIGHT * 1)\n        cut = Cutout(my_rect, s1, s2, s3, fill_opacity=1, color=DARK_BLUE, stroke_color=RED)\n        car = VGroup(cut, tier_1, tier_2)\n        self.play(Write(cut), DrawBorderThenFill(tier_1), DrawBorderThenFill(tier_2), run_time=1.2)\n        self.wait(2)\n        path1 = Line([-5, -1, 0], [-0.2, -1, 0], color=WHITE)\n        path2 = Line([1.3, -0.4, 0], [2.7, 1.1, 0], color=WHITE)\n        path3 = Line([-6, -1.7, 0], [1, -1.7, 0], color=WHITE)\n        path4 = Line([1, -1.7, 0], [4, 1.3, 0], color=WHITE)\n        self.play(FadeIn(path3), FadeIn(path4))\n        self.wait()\n        self.play(MoveAlongPath(car, path1), run_time=1.5)\n        self.wait(2)\n        car.shift(RIGHT * 1)\n        car.rotate(45 * DEGREES)\n        self.wait(2)\n        self.play(MoveAlongPath(car, path2), run_time=1.5)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate a YouTube logo appearing and then displaying the text \"Code - Tech\" next to it."}, {"role": "assistant", "content": "from manim import *\n\nclass YouTubeIcon(Scene):\n\n    def construct(self):\n        rect = RoundedRectangle(corner_radius=0.3, height=1.5, width=1.5, color=RED_E, fill_opacity=1.0)\n        triangle = Triangle(color=WHITE, fill_opacity=1.0).scale(0.4).rotate(-PI / 2).next_to(rect, DOWN, buff=-1.1).shift(RIGHT * 0.1)\n        self.play(Create(rect), FadeIn(triangle), run_time=1.2)\n        self.wait()\n        group = VGroup(rect, triangle)\n        self.play(group.animate.shift(UP + LEFT * 4), run_time=1.2)\n        tex_1 = MathTex('\\\\textbf{Code}').scale(1.5).set_color_by_gradient(BLUE).next_to(group, buff=0.4)\n        tex_2 = Text('-').scale(1.5).set_color(RED).next_to(tex_1, buff=0.1).shift(DOWN * 0.2)\n        tex_3 = MathTex('\\\\textbf{Tech}').scale(1.5).set_color(ORANGE).next_to(tex_2, buff=0.1).shift(UP * 0.2)\n        self.play(Write(tex_1), Write(tex_2), Write(tex_3), run_time=1.2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Create a bullseye target animation with concentric rings of yellow, red, and blue."}, {"role": "assistant", "content": "from manim import *\n\nclass Target(Scene):\n\n    def construct(self):\n        ring_1 = Annulus(inner_radius=0.3, outer_radius=0.6, color=YELLOW_C, fill_opacity=1.0)\n        ring_2 = Annulus(inner_radius=0.6, outer_radius=0.9, color=YELLOW_C, fill_opacity=1.0)\n        ring_3 = Annulus(inner_radius=0.9, outer_radius=1.2, color=RED_E, fill_opacity=1.0)\n        ring_4 = Annulus(inner_radius=1.2, outer_radius=1.5, color=RED_E, fill_opacity=1.0)\n        ring_5 = Annulus(inner_radius=1.5, outer_radius=1.8, color=WHITE, fill_opacity=1.0)\n        ring_6 = Annulus(inner_radius=1.8, outer_radius=2.1, color=WHITE, fill_opacity=1.0)\n        ring_7 = Annulus(inner_radius=2.1, outer_radius=2.4, color=BLUE_D, fill_opacity=1.0)\n        ring_8 = Annulus(inner_radius=2.4, outer_radius=2.7, color=BLUE_D, fill_opacity=1.0)\n        self.play(DrawBorderThenFill(ring_1), DrawBorderThenFill(ring_2), DrawBorderThenFill(ring_3), DrawBorderThenFill(ring_4), DrawBorderThenFill(ring_5), DrawBorderThenFill(ring_6), DrawBorderThenFill(ring_7), DrawBorderThenFill(ring_8), run_time=1.5, rate_func=linear)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate the derivation of the quadratic formula by showing each step of the algebraic manipulation and highlighting the final formula with a dynamic boundary."}, {"role": "assistant", "content": "from manim import *\n\nclass quadratic_formula(Scene):\n\n    def construct(self):\n        text = Text('Quadratic Formula ').scale(0.8).to_edge(UP).set_color(BLUE)\n        self.play(Write(text), run_time=0.8)\n        self.wait()\n        formu = MathTex('ax^{2} + bx + c = 0').scale(1.0).set_color_by_gradient(YELLOW, ORANGE).to_edge(LEFT, buff=1.5).next_to(text, DOWN, buff=0.4)\n        frame = SurroundingRectangle(formu, buff=0.1, fill_opacity=0)\n        frame.set_color_by_gradient(BLUE, RED, GREEN_D)\n        self.play(Write(formu))\n        self.play(ShowCreation(frame))\n        self.wait(2)\n        self.play(Uncreate(frame), run_time=1.5)\n        text_1 = Text('Dividing this equation by a we get:').scale(0.7).set_color(ORANGE).next_to(formu, DOWN, buff=0.3)\n        self.play(Write(text_1), run_time=1.5)\n        self.wait()\n        formu_1 = MathTex('\\\\frac{a x^{2}+ bx + c}{a}=0').scale(1.0).set_color_by_gradient(PINK, GOLD_D).next_to(text_1, DOWN, buff=0.3)\n        self.play(ReplacementTransform(formu.copy(), formu_1), run_time=1.5)\n        self.wait(2)\n        formu_2 = MathTex('x^{2}+', '\\\\frac{b}{a}x+', '\\\\frac{c}{a}', '=0').scale(1.0).set_color_by_gradient(BLUE, YELLOW).next_to(formu_1, DOWN, buff=0.3)\n        self.play(Write(formu_2[0]))\n        self.play(Write(formu_2[1]))\n        self.play(Write(formu_2[2]))\n        self.play(Write(formu_2[3]))\n        self.wait(3)\n        text_2 = Text('Using completing the square method we get -:').scale(0.7).set_color(YELLOW).next_to(formu_2, DOWN, buff=0.3)\n        self.play(Write(text_2), run_time=1.5)\n        self.wait(2)\n        formu_3 = MathTex('x^{2}+\\\\frac{b}{a}x+', '\\\\left( \\\\frac{b}{2a} \\\\right)^{2}', '-\\\\left( \\\\frac{b}{2a} \\\\right)^{2}', '= -\\\\frac{c}{a}').scale(1.0)\n        formu_3[0].set_color(BLUE)\n        formu_3[1].set_color(ORANGE)\n        formu_3[2].set_color(GREEN_D)\n        formu_3[3].set_color(PINK)\n        formu_3[0].next_to(text_2, DOWN, buff=0.3)\n        formu_3[1].next_to(formu_3[0], buff=0.1)\n        formu_3[2].next_to(formu_3[1], buff=0.1)\n        formu_3[3].next_to(formu_3[2], buff=0.1)\n        group_1 = VGroup(formu_3[0], formu_3[1], formu_3[2], formu_3[3])\n        group_1.shift(LEFT * 2)\n        self.play(ReplacementTransform(formu_2[0].copy(), formu_3[0]), ReplacementTransform(formu_2[0].copy(), formu_3[0]), run_time=1.5)\n        self.play(Write(formu_3[1]), run_time=1.5)\n        self.play(Write(formu_3[2]), run_time=1.5)\n        self.play(ReplacementTransform(formu_2[2].copy(), formu_3[3]), run_time=1.5)\n        self.wait(3)\n        self.remove(text, text_1, text_2, formu, formu_1, formu_2[0], formu_2[1], formu_2[2], formu_2[3])\n        self.wait()\n        self.play(group_1.animate.shift(UP * 6), run_time=1.5)\n        self.wait(2)\n        formu_4 = MathTex('\\\\left ( x + \\\\frac{b}{2a} \\\\right )^{2}', '= \\\\frac{b^{2}}{4a^{2}} - \\\\frac{c}{a}').scale(1.0).set_color_by_gradient(ORANGE, GOLD_D, RED)\n        formu_4[0].next_to(formu_3[0], DOWN, buff=0.3)\n        formu_4[1].next_to(formu_4[0], buff=0.1)\n        self.play(ReplacementTransform(formu_3[0].copy(), formu_4[0]), ReplacementTransform(formu_3[1].copy(), formu_4[0]), run_time=1.5)\n        self.play(ReplacementTransform(formu_3[2].copy(), formu_4[1]), ReplacementTransform(formu_3[3].copy(), formu_4[1]), run_time=1.5)\n        self.wait(3)\n        formu_5 = MathTex('\\\\left ( x + \\\\frac{b}{2a} \\\\right )^{2}', '= \\\\frac{b^{2} - 4ac}{4a^{2}}').scale(1.0).set_color_by_gradient(BLUE, PINK)\n        formu_5[0].next_to(formu_4[0], DOWN, buff=0.3)\n        formu_5[1].next_to(formu_5[0], buff=0.1)\n        self.play(ReplacementTransform(formu_4[0].copy(), formu_5[0]), run_time=1.5)\n        self.wait()\n        self.play(ReplacementTransform(formu_4[1].copy(), formu_5[1]), run_time=1.5)\n        self.wait(3)\n        formu_6 = MathTex('\\\\left ( x + \\\\frac{b}{2a} \\\\right )', '= \\\\pm \\\\frac{\\\\sqrt{b^{2}-4ac}}{2a}').scale(1.0).set_color_by_gradient(ORANGE, GREEN_D)\n        formu_6[0].next_to(formu_5[0], DOWN, buff=0.3)\n        formu_6[1].next_to(formu_6[0], buff=0.1)\n        self.play(ReplacementTransform(formu_5[0].copy(), formu_6[0]), run_time=1.5)\n        self.wait()\n        self.play(ReplacementTransform(formu_5[1].copy(), formu_6[1]), run_time=1.5)\n        self.wait(3)\n        formu_7 = MathTex('x=-\\\\frac{b}{2a}', '\\\\pm \\\\frac{\\\\sqrt{b^{2}-4ac}}{2a}').scale(1.0).set_color_by_gradient(RED, YELLOW)\n        formu_7[0].next_to(formu_6[0], DOWN, buff=0.3)\n        formu_7[1].next_to(formu_7[0], buff=0.1)\n        self.play(ReplacementTransform(formu_6[0].copy(), formu_7[0]), run_time=1.5)\n        self.wait()\n        self.play(ReplacementTransform(formu_6[1].copy(), formu_7[1]), run_time=1.5)\n        self.wait(3)\n        formu_8 = MathTex('x = \\\\frac{-b \\\\pm \\\\sqrt{b^{2}-4ac}}{2a}').scale(1.0).set_color(BLUE).set_color_by_gradient(RED, GOLD_D)\n        box_1 = SurroundingRectangle(formu_8, buff=0.1)\n        background = AnimatedBoundary(box_1, colors=[BLUE, RED, ORANGE], cycle_rate=3)\n        self.remove(formu_4[0], formu_4[1], formu_5[0], formu_5[1], formu_6[0], formu_6[1], formu_3[0], formu_3[1], formu_3[2], formu_3[3])\n        self.play(ReplacementTransform(formu_7, formu_8), run_time=1.5)\n        self.play(ShowCreation(box_1), ShowCreation(background), run_time=2)\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Create a scene that displays \"Quadratic Formula\" with a gradient, followed by \"Why for quadratic equation\" in green, then the equation \"ax^2 + bx + c = 0\" in orange, and finally the quadratic formula with a color gradient and a question mark."}, {"role": "assistant", "content": "from manim import *\n\nclass thumbnail(Scene):\n\n    def construct(self):\n        text = Text('Quadratic Formula', font='Times New Roman').scale(2.0).set_color_by_gradient(YELLOW, PINK).to_edge(UP)\n        self.play(Write(text))\n        text_1 = Text('Why for quadratic equation ', font='Times New Roman').scale(1.8).set_color(GREEN_D).next_to(text, DOWN, buff=0.6).to_edge(LEFT, buff=0.5)\n        self.play(Write(text_1))\n        eqn = MathTex('ax^{2} + bx + c = 0').scale(2.0).set_color(ORANGE).next_to(text_1, DOWN, buff=0.4)\n        self.play(Write(eqn))\n        formu = MathTex('x = \\\\frac{-b \\\\pm \\\\sqrt{b^{2} - 4ac}}{2a} \\\\, \\\\, ?').scale(2.0).set_color_by_gradient(BLUE, ORANGE, RED).next_to(eqn, DOWN, buff=0.8)\n        self.play(Write(formu))"}]}
{"messages": [{"role": "user", "content": "Illustrate the creation of a sine wave by animating a dot orbiting a circle, drawing a line from the circle's center to the dot, and a line from the dot to the graph."}, {"role": "assistant", "content": "from manim import *\nfrom components.ListNode import ListNode\nfrom components.watermark import create_watermark\n\nclass Algorithms(Scene):\n\n    def construct(self):\n        self.show_axis()\n        self.show_circle()\n        self.move_dot_and_draw_curve()\n        self.wait()\n        self.move_dot_back()\n\n    def show_axis(self):\n        x_start = np.array([-6, 0, 0])\n        x_end = np.array([6, 0, 0])\n        y_start = np.array([-4, -2, 0])\n        y_end = np.array([-4, 2, 0])\n        x_axis = Line(x_start, x_end)\n        y_axis = Line(y_start, y_end)\n        self.add(x_axis, y_axis)\n        self.add_x_labels()\n        self.origin_point = np.array([-4, 0, 0])\n        self.curve_start = np.array([-3, 0, 0])\n\n    def add_x_labels(self):\n        x_labels = [MathTex('\\\\pi'), MathTex('2 \\\\pi'), MathTex('3 \\\\pi'), MathTex('4 \\\\pi')]\n        for i in range(len(x_labels)):\n            x_labels[i].next_to(np.array([-1 + 2 * i, 0, 0]), DOWN)\n            self.add(x_labels[i])\n\n    def show_circle(self):\n        circle = Circle(radius=1)\n        circle.move_to(self.origin_point)\n        self.add(circle)\n        self.circle = circle\n\n    def move_dot_and_draw_curve(self):\n        orbit = self.circle\n        origin_point = self.origin_point\n        self.dot = Dot(radius=0.08, color=YELLOW)\n        self.dot.move_to(orbit.point_from_proportion(0))\n        self.t_offset = 0\n        rate = 0.25\n\n        def go_around_circle(mob, dt):\n            self.t_offset += dt * rate\n            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))\n\n        def get_line_to_circle():\n            return Line(origin_point, self.dot.get_center(), color=BLUE)\n\n        def get_line_to_curve():\n            x = self.curve_start[0] + self.t_offset * 4\n            y = self.dot.get_center()[1]\n            return Line(self.dot.get_center(), np.array([x, y, 0]), color=YELLOW_A, stroke_width=2)\n        self.curve = VGroup()\n        self.curve.add(Line(self.curve_start, self.curve_start))\n\n        def get_curve():\n            last_line = self.curve[-1]\n            x = self.curve_start[0] + self.t_offset * 4\n            y = self.dot.get_center()[1]\n            new_line = Line(last_line.get_end(), np.array([x, y, 0]), color=YELLOW_D)\n            self.curve.add(new_line)\n            return self.curve\n        self.dot.add_updater(go_around_circle)\n        origin_to_circle_line = always_redraw(get_line_to_circle)\n        dot_to_curve_line = always_redraw(get_line_to_curve)\n        sine_curve_line = always_redraw(get_curve)\n        self.add(self.dot)\n        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)\n        self.wait(8.5)\n        self.dot.remove_updater(go_around_circle)\n\n    def move_dot_back(self):\n        orbit = self.circle\n        rate = 0.25\n\n        def go_back_around_circle(mob, dt):\n            self.t_offset -= dt * rate\n            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))\n        self.dot.add_updater(go_back_around_circle)\n        self.wait(8.5)\n        self.dot.remove_updater(go_back_around_circle)"}]}
{"messages": [{"role": "user", "content": "Create a linked list visualization with a title and watermark."}, {"role": "assistant", "content": "from manim import *\nfrom components.ListNode import ListNode\nfrom components.watermark import create_watermark\n\nclass BigO(Scene):\n\n    def construct(self):\n        self.showTitle = False\n        self.construction()\n        self.animate_scene()\n\n    def construction(self):\n        \"\"\"\n        Define and position the elements of the scene.\n        \"\"\"\n        self.node1 = ListNode('1', radius=1).create()\n        self.node2 = ListNode('1', radius=1).create()\n        self.node3 = ListNode('1', radius=1).create()\n        self.node4 = ListNode('1', radius=1).create()\n        self.node5 = ListNode('1', radius=1).create()\n\n    def animate_scene(self):\n        \"\"\"\n        Add elements to the scene and animate them.\n        \"\"\"\n        watermark = create_watermark()\n        self.add(watermark)\n        title = Text('Big O Notation').to_edge(UP, buff=0.5)\n        if self.showTitle:\n            self.add(title)\n        self.add(self.node1)"}]}
{"messages": [{"role": "user", "content": "Visualize an array with \"Two Pointers\" as a title, showing an array and two pointers moving inwards, swapping elements along the way, with accompanying step-by-step instructions."}, {"role": "assistant", "content": "from manim import *\nfrom components.Steps import Steps\nfrom components.watermark import create_watermark\nfrom components.Array import Array\n\nclass ArrayPointers(Scene):\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.nums = [1, 2, 3, 4, 5, 6]\n        self.array_len = len(self.nums)\n        self.random_seed = 1\n\n    def construct(self):\n        self.showTitle = False\n        self.setup_scene()\n        self.animate_scene()\n\n    def setup_scene(self):\n        \"\"\"\n        Define and position the elements of the scene.\n        \"\"\"\n        self.title = Text('Two Pointers').to_edge(UP, buff=0.5)\n        array_viz = Array(array=self.nums, indices_size=30, seed=self.random_seed, index_color=GRAY_C)\n        self.array, self.array_elements, self.indices = array_viz.construct_array()\n        self.left = self.create_pointer('Left', BLUE)\n        self.left[1].shift(UP * 0.1)\n        self.left.next_to(self.array_elements[0], UP, buff=0.3)\n        self.right = self.create_pointer('Right', ORANGE)\n        self.right.next_to(self.array_elements[-1], UP, buff=0.3)\n        step1 = Text('1. Swap elements at pointers')\n        step2 = Text('2. Move the left and right pointers')\n        self.steps = VGroup(step1, step2).arrange(DOWN, buff=0.4)\n        for step in self.steps:\n            step.align_to(self.steps, LEFT)\n        self.steps.scale(0.5).to_corner(DL)\n\n    def create_pointer(self, label, color):\n        \"\"\"\n        Create a pointer with a given label and color.\n        \"\"\"\n        arrow = Arrow(start=UP, end=DOWN, buff=0.2, color=color).scale(0.8)\n        text = Text(label, color=color, font_size=60)\n        pointer = VGroup(arrow, text).arrange(UP, buff=0.25).scale(0.5)\n        return pointer\n\n    def swap_elements(self, left_index, right_index):\n        \"\"\"\n        Swap the elements at the given indices using an arc motion.\n        \"\"\"\n        left_element = self.array_elements[left_index]\n        right_element = self.array_elements[right_index]\n        left_center = left_element.get_center()\n        right_center = right_element.get_center()\n        arc_left_to_right = ArcBetweenPoints(left_center, right_center, angle=TAU / 4)\n        arc_right_to_left = ArcBetweenPoints(right_center, left_center, angle=-TAU / 4)\n        if not self.played1:\n            self.play(Write(self.steps[0]), MoveAlongPath(left_element, arc_left_to_right), MoveAlongPath(right_element, arc_right_to_left))\n            self.played1 = True\n        else:\n            self.play(MoveAlongPath(left_element, arc_left_to_right), MoveAlongPath(right_element, arc_right_to_left))\n        self.array_elements[left_index], self.array_elements[right_index] = (right_element, left_element)\n\n    def animate_scene(self):\n        \"\"\"\n        Add elements to the scene and animate them.\n        \"\"\"\n        watermark = create_watermark()\n        self.add(watermark)\n        if self.showTitle:\n            self.add(self.title)\n        self.play(*[Write(element, run_time=2) for element in [self.array_elements, self.indices]], Write(self.array[0]), Write(self.array[-1]))\n        self.play(Write(self.left), Write(self.right))\n        left_index = 0\n        right_index = self.array_len - 1\n        left_index = 0\n        right_index = self.array_len - 1\n        self.played1 = False\n        played2 = False\n        while left_index < right_index:\n            self.swap_elements(left_index, right_index)\n            if not played2:\n                self.play(Write(self.steps[1]), self.left.animate.next_to(self.array_elements[left_index + 1], UP, buff=0.3), self.right.animate.next_to(self.array_elements[right_index - 1], UP, buff=0.3))\n                played2 = True\n            else:\n                self.play(self.left.animate.next_to(self.array_elements[left_index + 1], UP, buff=0.3), self.right.animate.next_to(self.array_elements[right_index - 1], UP, buff=0.3))\n            left_index += 1\n            right_index -= 1\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Illustrate stack operations by showing an array with elements being pushed, popped, and peeked at, accompanied by descriptive text steps."}, {"role": "assistant", "content": "from manim import *\nfrom components.Steps import Steps\nfrom components.watermark import create_watermark\nfrom components.Array import Array\n\nclass Stacks(Scene):\n\n    def construct(self):\n        self.showTitle = False\n        self.array_color = GRAY_C\n        self.construction()\n        self.animate_scene()\n\n    def construction(self):\n        \"\"\"\n        Define and position the elements of the scene.\n        \"\"\"\n        self.title = Text('Stacks').to_edge(UP, buff=0.5)\n        self.steps = Steps(['Push element to stack', 'Pop from the stack', 'Peek at the top element']).create()\n        arrayThings = Array(array_len=4, element_color=self.array_color).create()\n        arrayThings.scale(1.5)\n        self.array, self.indices = arrayThings\n        self.array.shift(LEFT * 0.82)\n        self.number = MathTex('8', font_size=60).scale(1.5).next_to(self.array, RIGHT * 6)\n        self.arrow = ArcBetweenPoints(start=self.number.get_bottom() + DL * 0.2, end=self.number.get_bottom() + DL * 0.2 + LEFT * 2, radius=-1.25).add_tip(tip_width=0.25)\n\n    def animate_scene(self):\n        \"\"\"\n        Add elements to the scene and animate them.\n        \"\"\"\n        watermark = create_watermark()\n        self.add(watermark)\n        if self.showTitle:\n            self.add(self.title)\n        self.add(self.array)\n        self.add(self.number)\n        self.play(Create(self.arrow), run_time=0.5)\n        self.play(Write(self.steps[0]), FadeOut(self.arrow), self.number.animate.next_to(self.array[1][-1], RIGHT, buff=1), self.array[-1].animate.shift(RIGHT * 1.4), run_time=1)\n        self.wait()\n        self.arrow2 = ArcBetweenPoints(start=self.number.get_bottom() + DR * 0.2, end=self.number.get_bottom() + DR * 0.2 + RIGHT * 2, radius=1.25).add_tip(tip_width=0.25)\n        self.play(Create(self.arrow2), run_time=0.5)\n        self.play(Write(self.steps[1]), FadeOut(self.arrow2), self.number.animate.next_to(self.array, RIGHT * 0.4), self.array[-1].animate.shift(LEFT * 1.4), run_time=1)\n        self.wait()\n        self.play(Write(self.steps[2]), self.array[1][0].animate.set_color(GREEN_A).scale(1.25), run_time=1)\n        self.wait(1)\n        self.play(self.array[1][0].animate.set_color(self.array_color).scale(0.8), FadeOut(self.steps))"}]}
{"messages": [{"role": "user", "content": "Visualize the process of storing a key-value pair in a hashmap, showing the hash function computation and placement into the correct bucket."}, {"role": "assistant", "content": "from manim import *\nfrom components.Hashmap import Hashmap\nfrom components.Steps import Steps\nfrom components.watermark import create_watermark\n\nclass HashFunction(Scene):\n\n    def construct(self):\n        self.show_title = False\n        self.construction()\n        self.animate_scene()\n\n    def construction(self):\n        \"\"\"\n        Define and position the elements of the scene.\n        \"\"\"\n        self.title = Text('Hash Function').to_edge(UP, buff=0.5)\n        steps_list = ['Input the key into hash function', 'Compute the hash value', 'Use hash value to store key-value pair at index']\n        self.steps = Steps(steps_list).create()\n        self.indices = VGroup(*[VGroup(Text('Index', font_size=25, color=GRAY_C), MathTex(f'{i}', font_size=40, color=BLUE)).arrange(RIGHT, aligned_edge=DOWN, buff=0.2) for i in range(4)]).arrange(DOWN, aligned_edge=LEFT, buff=0.4)\n        self.buckets = VGroup(*[VGroup(Text(':', font_size=25), Text('[]', font_size=25).shift(UP * 0.06)).arrange(RIGHT, buff=0.2) for _ in range(4)]).arrange(DOWN, aligned_edge=LEFT, buff=0.37).next_to(self.indices, RIGHT, aligned_edge=DOWN)\n        self.hashmap = VGroup(self.indices, self.buckets, Brace(self.indices, LEFT, sharpness=1), Brace(self.buckets, RIGHT, sharpness=1)).shift(LEFT * 4 + UP * 0.5)\n        self.hashmap_title = Text('Hashmap', font_size=25).next_to(self.hashmap, DOWN, buff=0.4)\n        self.key_value_pair = VGroup(Text('Key-Value Pair:', font_size=25), Text('[\"StudyDSA\"] = 100', font_size=25, t2c={'[0:1]': 'GRAY', '[1:11]': 'GREEN', '[11:12]': 'GRAY', '[15:]': 'ORANGE'})).arrange(RIGHT, buff=0.2).shift(UP * 1.5 + RIGHT * 2)\n        self.hash_function = VGroup(Text('Hash Function: ', font_size=25), MathTex('f(key) = index', font_size=40, tex_to_color_map={'key': GREEN, 'index': BLUE})).arrange(RIGHT, buff=0.1).next_to(self.key_value_pair, DOWN, buff=0.5, aligned_edge=LEFT)\n\n    def animate_scene(self):\n        \"\"\"\n        Add elements to the scene and animate them.\n        \"\"\"\n        watermark = create_watermark()\n        self.add(watermark)\n        if self.show_title:\n            self.add(self.title)\n        self.add(self.hashmap)\n        self.add(self.hashmap_title)\n        self.add(self.key_value_pair)\n        self.add(self.hash_function)\n        key_part = self.hash_function[1].get_part_by_tex('key')\n        target_key = Text('\"StudyDSA\"', font_size=25, color=GREEN).move_to(key_part.get_center()).shift(RIGHT * 0.6)\n        self.play(Transform(key_part, target_key), self.hash_function[1][2:].animate.move_to(target_key.get_center()).shift(RIGHT * 1.8), Write(self.steps[0], run_time=1.5))\n        self.wait()\n        two = MathTex('2', font_size=40, color=BLUE).next_to(self.hash_function[1][-1].get_center()).shift(LEFT * 0.75)\n        self.play(Transform(self.hash_function[1][-1], two), Write(self.steps[1], run_time=1.5))\n        self.wait()\n        self.play(Indicate(self.indices[2][-1], scale_factor=1.5, color=YELLOW), Indicate(self.hash_function[1][-1], scale_factor=1.5, color=YELLOW))\n        index_two_copy = self.indices[2].copy()\n        bucket_two_copy = self.buckets[2].copy()\n        new_group = VGroup(index_two_copy, bucket_two_copy).arrange(RIGHT, buff=0.2).next_to(self.hash_function, DOWN, buff=0.5, aligned_edge=LEFT)\n        self.play(Transform(VGroup(self.indices[2], self.buckets[2]), new_group))\n        self.wait()\n        text = Text('(\"StudyDSA\", 100)', font_size=25, t2c={'[0:1]': 'GRAY', '[1:11]': 'GREEN', '[11:12]': 'GRAY', '[13:16]': 'ORANGE', '[16:]': 'GRAY'}).next_to(self.buckets[2][1][0], RIGHT, buff=0.1)\n        self.play(self.buckets[2][1][1].animate.next_to(text, RIGHT, buff=0.1), Write(text), Write(self.steps[2]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the process of adding a new node to the beginning of a linked list, illustrating pointer updates and providing step-by-step explanations."}, {"role": "assistant", "content": "from manim import *\nfrom components.ListNode import ListNode\nfrom components.Steps import Steps\nfrom components.watermark import create_watermark\n\nclass AddingNodeToBeginning(Scene):\n\n    def construct(self):\n        self.construction()\n        self.animate_scene()\n\n    def construction(self):\n        \"\"\"\n        Define and position the elements of the scene.\n        \"\"\"\n        self.head = ListNode('Head', '0', color=GREEN_D, value_color=GREEN_A).create().shift(LEFT * 4)\n        self.node1 = ListNode('Node A', '1').create()\n        self.node2 = ListNode('Node B', '2').create().shift(RIGHT * 4)\n        self.arrow = Arrow(start=self.head[0].get_right(), end=self.node2[0].get_left(), color=GREEN_D)\n        self.arrow_label = MathTex('next', color=GREEN_A).next_to(self.arrow, UP * 0.5)\n        step1 = Text('1. Create new node')\n        step2 = Text(\"2. Update head's next pointer\")\n        step3 = Text('3. Link new node to next node')\n        self.steps = VGroup(step1, step2, step3).arrange(DOWN, buff=0.4).scale(0.5).shift(DOWN * 3)\n        self.steps[1].shift(RIGHT * 0.78)\n        self.steps[2].shift(RIGHT * 0.8 + UP * 0.08)\n        self.steps.to_edge(LEFT)\n\n    def animate_scene(self):\n        \"\"\"\n        Add elements to the scene and animate them.\n        \"\"\"\n        watermark = create_watermark()\n        self.add(watermark)\n        self.add(self.head, self.node2, self.arrow)\n        self.play(Write(self.arrow_label))\n        self.wait()\n        self.play(FadeOut(self.arrow), Unwrite(self.arrow_label))\n        self.play(self.head.animate.shift(LEFT), self.node2.animate.shift(RIGHT), FadeIn(self.node1, shift=UP, scale=0.66), Write(self.steps[0]))\n        self.wait()\n        arrow2 = Arrow(start=self.head[0].get_right(), end=self.node1[0].get_left(), color=GREEN_D)\n        arrow2_label = MathTex('next', color=GREEN_A).next_to(arrow2, UP * 0.5)\n        arrow3 = Arrow(start=self.node1[0].get_right(), end=self.node2[0].get_left(), color=WHITE)\n        arrow3_label = MathTex('next').next_to(arrow3, UP * 0.5)\n        self.play(GrowArrow(arrow2), Write(arrow2_label), Write(self.steps[1]))\n        self.play(GrowArrow(arrow3), Write(arrow3_label), Write(self.steps[2]))\n        self.wait(duration=2)"}]}
{"messages": [{"role": "user", "content": "Animate the creation and linking of sentinel nodes with descriptive text steps."}, {"role": "assistant", "content": "from manim import *\nfrom components.ListNode import ListNode\nfrom components.Steps import Steps\nfrom components.watermark import create_watermark\n\nclass SentinelNodes(Scene):\n\n    def construct(self):\n        self.construction()\n        self.animate_scene()\n\n    def construction(self):\n        \"\"\"\n        Define and position the elements of the scene.\n        \"\"\"\n        self.title = Text('Sentinel Nodes').to_edge(UP, buff=0.5)\n        self.left = ListNode('Left', 'null', color=GREEN_D, value_color=GREEN_A).create().shift(LEFT * 4)\n        self.node1 = ListNode('Head', '0').create()\n        self.right = ListNode('Right', 'null', color=GREEN_D, value_color=GREEN_A).create().shift(RIGHT * 4)\n        self.arrow = Arrow(start=self.left[0].get_right(), end=self.right[0].get_left(), color=GREEN_D)\n        self.arrow_label = MathTex('next', color=GREEN_A).next_to(self.arrow, UP * 0.5)\n        step1 = Text('1. Create a new head node')\n        step3 = Text('2. Link the head node to sentinel nodes')\n        self.steps = VGroup(step1, step3).arrange(DOWN, buff=0.4)\n        for step in self.steps:\n            step.align_to(self.steps, LEFT)\n        self.steps.scale(0.5).to_corner(DL)\n\n    def animate_scene(self):\n        \"\"\"\n        Add elements to the scene and animate them.\n        \"\"\"\n        watermark = create_watermark()\n        self.add(watermark)\n        self.add(self.title)\n        self.add(self.left, self.right, self.arrow)\n        self.play(Write(self.arrow_label))\n        self.wait()\n        self.play(FadeOut(self.arrow), Unwrite(self.arrow_label))\n        self.play(self.left.animate.shift(LEFT), self.right.animate.shift(RIGHT), FadeIn(self.node1, shift=UP, scale=0.66), Write(self.steps[0]))\n        self.wait()\n        arrow2 = Arrow(start=self.left[0].get_right(), end=self.node1[0].get_left(), color=GREEN_D)\n        arrow2_label = MathTex('next', color=GREEN_A).next_to(arrow2, UP * 0.5)\n        arrow3 = Arrow(start=self.node1[0].get_right(), end=self.right[0].get_left(), color=WHITE)\n        arrow3_label = MathTex('next').next_to(arrow3, UP * 0.5)\n        self.play(GrowArrow(arrow2), Write(arrow2_label), Write(self.steps[1]))\n        self.play(GrowArrow(arrow3), Write(arrow3_label))\n        self.wait(duration=2)"}]}
{"messages": [{"role": "user", "content": "Visualize a singly linked list being traversed by a 'cur' pointer, highlighting each node and its 'next' pointer sequentially."}, {"role": "assistant", "content": "from manim import *\nfrom components.ListNode import ListNode\nfrom components.Steps import Steps\nfrom components.watermark import create_watermark\n\nclass SinglyLinkedList(Scene):\n\n    def construct(self):\n        self.show_title = False\n        self.construction()\n        self.animate_scene()\n\n    def construction(self):\n        \"\"\"\n        Define and position the elements of the scene.\n        \"\"\"\n        self.title = Text('Singly Linked List').to_edge(UP, buff=0.5)\n        steps_text = ['Initialize `cur` pointer at the head node', 'Move `cur` pointer to the next node']\n        self.steps = Steps(steps_text).create()\n        self.create_linked_list([1, 2, 3, 4, 'null'])\n        self.create_arrows()\n        self.cur = Text('cur', font_size=30, color=GREEN).next_to(self.linked_list[0], UP)\n\n    def create_linked_list(self, nums: List[int]) -> None:\n        \"\"\"Creates the linked list nodes and positions them.\"\"\"\n        self.linked_list = VGroup()\n        radius = 0.75\n        for num in nums:\n            list_node = ListNode(str(num), radius=radius).create()\n            self.linked_list.add(list_node)\n        self.linked_list.arrange(RIGHT, aligned_edge=DOWN, buff=1).shift(UP)\n\n    def create_arrows(self):\n        \"\"\"Creates arrows pointing from one list node to the next.\"\"\"\n        self.next_arrows = VGroup()\n        for index, node in enumerate(self.linked_list[:-1]):\n            next_node = self.linked_list[index + 1]\n            arrow = ArcBetweenPoints(start=node.get_bottom() + DR * 0.2, end=next_node.get_bottom() + DL * 0.2, radius=1.5, color=GRAY_C).add_tip(tip_width=0.25)\n            next = Text('next', font_size=25, color=GRAY_A).next_to(arrow, DOWN)\n            element = VGroup().add(arrow, next)\n            self.next_arrows.add(element)\n\n    def animate_scene(self):\n        \"\"\"\n        Add elements to the scene and animate them.\n        \"\"\"\n        watermark = create_watermark()\n        self.add(watermark)\n        if self.show_title:\n            self.add(self.title)\n        self.add(self.linked_list)\n        self.play(*[Write(elements, run_time=2) for elements in [self.linked_list, self.next_arrows]])\n        self.play(Write(self.cur), Write(self.steps[0], run_time=1.5), ApplyMethod(self.linked_list[0].set_color, GREEN))\n        played = False\n        for i in range(len(self.linked_list) - 1):\n            self.play(Indicate(self.next_arrows[i][1], scale_factor=1.2, color=YELLOW))\n            if not played:\n                self.play(ApplyMethod(self.cur.next_to, self.linked_list[i + 1], UP), ApplyMethod(self.linked_list[i].set_color, WHITE), ApplyMethod(self.linked_list[i + 1].set_color, GREEN), Write(self.steps[1], run_time=1.5))\n                played = True\n            else:\n                self.play(ApplyMethod(self.cur.next_to, self.linked_list[i + 1], UP), ApplyMethod(self.linked_list[i].set_color, WHITE), ApplyMethod(self.linked_list[i + 1].set_color, GREEN))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize a doubly linked list with nodes, next and previous arrows, and animate a pointer named \"cur\" moving forward and backward through the list, highlighting steps."}, {"role": "assistant", "content": "from manim import *\nfrom components.ListNode import ListNode\nfrom components.Steps import Steps\nfrom components.watermark import create_watermark\n\nclass DoublyLinkedList(Scene):\n\n    def construct(self):\n        self.showTitle = False\n        self.construction()\n        self.animate_scene()\n\n    def construction(self):\n        \"\"\"\n        Define and position the elements of the scene.\n        \"\"\"\n        steps_text = ['Start `cur` at the head node', 'Move `cur` to the next node', 'Move `cur` to the previous node']\n        self.steps = Steps(steps_text).create()\n        self.create_linked_list([1, 2, 3, 4, 'null'])\n        self.create_arrows()\n        self.cur = Text('cur', font_size=35, color=GREEN).next_to(self.linked_list[0], DOWN * 2.5)\n\n    def create_linked_list(self, nums: List[int]) -> None:\n        \"\"\"Creates the linked list nodes and positions them.\"\"\"\n        self.linked_list = VGroup()\n        radius = 0.75\n        for num in nums:\n            list_node = ListNode(str(num), radius=radius).create()\n            self.linked_list.add(list_node)\n        self.linked_list.arrange(RIGHT, aligned_edge=DOWN, buff=1)\n\n    def create_arrows(self):\n        \"\"\"Creates arrows pointing from one list node to the next and previous.\"\"\"\n        self.next_arrows = VGroup()\n        self.prev_arrows = VGroup()\n        for index, node in enumerate(self.linked_list):\n            if not index == len(self.linked_list) - 1:\n                next_node = self.linked_list[index + 1]\n                next_arrow = ArcBetweenPoints(start=node.get_bottom() + (RIGHT * 0.2 - SMALL_BUFF), end=next_node.get_bottom() + (LEFT * 0.2 - SMALL_BUFF), radius=2, color=GRAY_C).add_tip(tip_width=0.25)\n                next_label = Text('next', font_size=22, color=GRAY_A).next_to(next_arrow, UP * 0.05)\n                next_element = VGroup().add(next_arrow, next_label)\n                self.next_arrows.add(next_element)\n            if index > 0:\n                prev_node = self.linked_list[index - 1]\n                prev_arrow = ArcBetweenPoints(start=node.get_top() + (LEFT * 0.2 + SMALL_BUFF), end=prev_node.get_top() + (RIGHT * 0.2 + SMALL_BUFF), radius=2, color=GRAY_C).add_tip(tip_width=0.25)\n                prev_label = Text('prev', font_size=22, color=GRAY_A).next_to(prev_arrow, DOWN * 0.05)\n                prev_element = VGroup().add(prev_arrow, prev_label)\n                self.prev_arrows.add(prev_element)\n\n    def animate_scene(self):\n        \"\"\"\n        Add elements to the scene and animate them.\n        \"\"\"\n        watermark = create_watermark()\n        self.add(watermark)\n        title = Text('Doubly Linked List').to_edge(UP, buff=0.5)\n        if self.showTitle:\n            self.add(title)\n        self.add(self.linked_list)\n        self.play(*[Write(elements, run_time=2) for elements in [self.linked_list, self.next_arrows, self.prev_arrows]])\n        self.play(Write(self.cur), Write(self.steps[0], run_time=1.5), ApplyMethod(self.linked_list[0].set_color, GREEN))\n        played = False\n        for i in range(2):\n            self.play(Indicate(self.next_arrows[i][1], scale_factor=1.2, color=YELLOW))\n            path = ArcBetweenPoints(self.cur.get_center(), self.linked_list[i + 1].get_bottom() + DOWN * 0.75, angle=TAU / 6)\n            if not played:\n                self.play(MoveAlongPath(self.cur, path), ApplyMethod(self.linked_list[i].set_color, WHITE), ApplyMethod(self.linked_list[i + 1].set_color, GREEN), Write(self.steps[1], run_time=1.5))\n                played = True\n            else:\n                self.play(MoveAlongPath(self.cur, path), ApplyMethod(self.linked_list[i].set_color, WHITE), ApplyMethod(self.linked_list[i + 1].set_color, GREEN))\n        played = False\n        for i in range(1, -1, -1):\n            self.play(Indicate(self.prev_arrows[i][1], scale_factor=1.2, color=YELLOW))\n            path_backward = ArcBetweenPoints(self.cur.get_center(), self.linked_list[i].get_bottom() + DOWN * 0.75, angle=-TAU / 6)\n            if not played:\n                self.play(MoveAlongPath(self.cur, path_backward), ApplyMethod(self.linked_list[i + 1].set_color, WHITE), ApplyMethod(self.linked_list[i].set_color, GREEN), Write(self.steps[2], run_time=1.5))\n                played = True\n            else:\n                self.play(MoveAlongPath(self.cur, path_backward), ApplyMethod(self.linked_list[i + 1].set_color, WHITE), ApplyMethod(self.linked_list[i].set_color, GREEN))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Visualize the step-by-step calculation of a 3x3 matrix determinant, highlighting intermediate products and their summation."}, {"role": "assistant", "content": "from yty_manim.matrix_yty import *\n\nclass MatrixDetShow(Scene):\n\n    def construct(self):\n        mat_input = matrix_3\n        length = len(mat_input)\n        mat_mob = MatrixDet(mat_input)\n        mat_mob_det = mat_mob.det_mat()\n        neg_mat = mat_mob.neg_with_brackets()\n        neg_mat = neg_mat.det_mat()\n        neg_mat.set_scale_fitness()\n        res_vgp = mat_mob_det.cal_result_addition().shift(DOWN * 2).scale_to_fit_width(12)\n        self.play(Write(mat_mob), run_time=2)\n        self.wait()\n        self.play(Transform(mat_mob, mat_mob_det))\n        self.wait()\n        self.play(mat_mob.animate.set_scale_fitness())\n        self.wait()\n        res_vgp_cp = res_vgp.copy()\n        for i in range(2 * length):\n            vgp, vgp_brackets, num_lst = mat_mob.get_process_inform(i if i < length else length - i - 1, neg_mat)\n            self.play(vgp.animate.set_color(color_list[i]))\n            pro_vgp = cal_progress_times(color_list[i], vgp_brackets, num_lst).shift(DOWN)\n            pro_vgp_cp = pro_vgp.copy()\n            for j in range(length):\n                pro_vgp[2 * j].move_to(vgp[j])\n                self.add(pro_vgp[2 * j])\n                self.play(pro_vgp[2 * j].animate.move_to(pro_vgp_cp[2 * j]), run_time=time_control)\n                self.play(FadeIn(pro_vgp[2 * j + 1]), run_time=time_control)\n            self.play(FadeIn(pro_vgp[-1]), run_time=time_control)\n            res_vgp[2 * i].move_to(pro_vgp[-1]).set_color(color_list[i])\n            self.add(res_vgp[2 * i])\n            self.play(res_vgp[2 * i].animate.move_to(res_vgp_cp[2 * i]), run_time=time_control)\n            self.play(FadeIn(res_vgp[2 * i + 1]), run_time=time_control)\n            self.play(FadeOut(pro_vgp), run_time=time_control)\n            if i == length - 1:\n                self.play(mat_mob.animate.set_color(WHITE), run_time=time_control)\n        self.play(FadeIn(res_vgp[-1]), run_time=time_control)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Illustrate matrix addition by showing the matrices, the operation, and the result, highlighting individual elements as they are added."}, {"role": "assistant", "content": "from yty_manim.matrix_yty import *\n\nclass MatrixAdditionShow(Scene):\n\n    def construct(self):\n        m1_input = matrix_4\n        m2_input = matrix_4_2\n        color_add = [RED, BLUE]\n        t = add_txt.copy().shift(UP * 2)\n        e = equal_txt.copy()\n        m1 = MatrixMath(m1_input)\n        m1.fit_screen(t, LEFT)\n        m2 = MatrixMath(m2_input)\n        m2.fit_screen(t, RIGHT)\n        m3 = m1.addition_mat(m2)\n        m3.fit_screen(edge=DR)\n        e.next_to(m3, LEFT)\n        s1 = Square().scale_to_fit_height(m1[0][0].height / 1.2).move_to(m1[0][0]).set_color(color_add[0])\n        s2 = Square().scale_to_fit_height(m2[0][0].height / 1.2).move_to(m2[0][0]).set_color(color_add[1])\n        total = VGroup(m1, t, m2, e, m3[-2:])\n        self.play(Write(total), run_time=4)\n        ori_vgp = VGroup(Text(f'{m1_input[0][0]}' if m1_input[0][0] >= 0 else f'({m1_input[0][0]})').set_color(color_add[0]), add_txt.copy(), Text(f'{m2_input[0][0]}' if m2_input[0][0] >= 0 else f'({m2_input[0][0]})').set_color(color_add[1]), equal_txt.copy(), Text(f'{m1_input[0][0] + m2_input[0][0]}')).arrange().shift(DOWN * 1.75 + LEFT * 3.5)\n        if ori_vgp.width > 5.5:\n            ori_vgp.scale_to_fit_width(5.5)\n        self.play(FadeIn(ori_vgp), FadeIn(s1), FadeIn(s2), run_time=0.5)\n        for i in range(len(m1_input)):\n            for j in range(len(m1_input[0])):\n                first_txt = Text(f'{m1_input[i][j]}' if m1_input[i][j] >= 0 else f'({m1_input[i][j]})').set_color(color_add[0])\n                second_txt = Text(f'{m2_input[i][j]}' if m2_input[i][j] >= 0 else f'({m2_input[i][j]})').set_color(color_add[1])\n                res_txt = Text(f'{m1_input[i][j] + m2_input[i][j]}')\n                txt_vgp = VGroup(first_txt, add_txt.copy(), second_txt, equal_txt.copy(), res_txt).arrange().shift(DOWN * 1.75 + LEFT * 3.5)\n                if txt_vgp.width > 5.5:\n                    txt_vgp.scale_to_fit_width(5.5)\n                self.play(s1.animate.move_to(m1[i][j]), s2.animate.move_to(m2[i][j]), Transform(ori_vgp, txt_vgp), run_time=0.5)\n                self.play(ori_vgp[-1].copy().animate.scale(m3[0][0].height / 1.3).move_to(m3[i][j]), run_time=0.5)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate the process of matrix multiplication by showing the element-wise multiplication and summation for each resulting element."}, {"role": "assistant", "content": "from yty_manim.matrix_yty import *\n\nclass MatrixMulShow(Scene):\n\n    def construct(self):\n        mat_a_input = matrix_2t3\n        mat_b_input = matrix_3t2\n        run_time = 0.5\n        t = times_txt.copy().shift(UP * 2)\n        a = MatrixMath(mat_a_input)\n        a.fit_screen(t, LEFT)\n        b = MatrixMath(mat_b_input)\n        b.fit_screen(t, RIGHT)\n        c = a.dot_multiplication_mat(b)\n        c.fit_screen(edge=DR)\n        total = VGroup(a, t, b, equal_txt.copy().next_to(c, LEFT), c[-2:])\n        self.play(Write(total), run_time=4)\n        s1 = SurroundingRectangle(a.get_row(0), buff=0, fill_opacity=0.5, stroke_opacity=0).set_color(color_mul[0])\n        sliding1 = SurroundingRectangle(a.get_row(0)[0], buff=0).set_color(color_mul[2])\n        s2 = SurroundingRectangle(b.get_column(0), buff=0, fill_opacity=0.5, stroke_opacity=0).set_color(color_mul[1])\n        sliding2 = SurroundingRectangle(b.get_column(0)[0], buff=0).set_color(color_mul[3])\n        ori_vgp = VGroup(Text(f'{mat_a_input[0][0]}' if mat_a_input[0][0] >= 0 else f'({mat_a_input[0][0]})').set_color(RED), times_txt.copy(), Text(f'{mat_b_input[0][0]}' if mat_b_input[0][0] >= 0 else f'({mat_b_input[0][0]})').set_color(BLUE), equal_txt.copy(), Text(f'{mat_a_input[0][0] * mat_b_input[0][0]}')).arrange().shift(DOWN * 0.75 + LEFT * 3.5)\n        if ori_vgp.width > 5.5:\n            ori_vgp.scale_to_fit_width(5.5)\n        part = VGroup(s1, s2, sliding1, sliding2, ori_vgp)\n        self.play(FadeIn(part))\n        res_mat = mat_a_input @ mat_b_input\n        for i in range(res_mat.shape[0]):\n            for j in range(res_mat.shape[1]):\n                res_vgp = c.get_mul_progress([i, j], color_mul)\n                res_vgp[0].to_edge(LEFT).shift(DOWN * 2.5)\n                res_vgp[1].shift(LEFT * 2.6 + DOWN * 2.6)\n                if res_vgp[1].width >= 4.3:\n                    res_vgp[1].scale_to_fit_width(4.5)\n                self.play(FadeIn(res_vgp[0]), s1.animate.move_to(a.get_row(i)), s2.animate.move_to(b.get_column(j)), run_time=run_time)\n                for k in range(mat_a_input.shape[1]):\n                    pro_vgp = VGroup(Text(f'{mat_a_input[i][k]}' if mat_a_input[i][k] >= 0 else f'({mat_a_input[i][k]})').set_color(RED), times_txt.copy(), Text(f'{mat_b_input[k][j]}' if mat_b_input[k][j] >= 0 else f'({mat_b_input[k][j]})').set_color(BLUE), equal_txt.copy(), Text(f'{mat_a_input[i][k] * mat_b_input[k][j]}')).arrange().shift(DOWN * 0.75 + LEFT * 3.5)\n                    self.play(Transform(ori_vgp, pro_vgp), sliding1.animate.move_to(a.get_row(i)[k]), sliding2.animate.move_to(b.get_column(j)[k]), run_time=run_time)\n                    r1_cp = res_vgp[1].copy()\n                    res_vgp[1][2 * k].move_to(ori_vgp[-1])\n                    self.play(res_vgp[1][2 * k].animate.move_to(r1_cp[2 * k]), FadeIn(res_vgp[1][2 * k + 1]), run_time=run_time)\n                self.play(FadeIn(res_vgp[1][-1]))\n                self.play(res_vgp[1][-1].copy().animate.scale(c[0][0].height / 1.3).move_to(c[i][j]), run_time=run_time)\n                self.play(FadeOut(res_vgp), run_time=run_time)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display a matrix with its determinant result."}, {"role": "assistant", "content": "from yty_math.matrix_yty import *\nimport yty_math.file_operation as fo\nimport os\n\nclass DetResult(Scene):\n\n    def __init__(self, data_load=None):\n        super().__init__()\n        self.data_load = data_load\n\n    def construct(self):\n        result_vgp = VGroup()\n        self.camera.background_color = WHITE\n        if self.data_load:\n            mat_input = self.data_load\n        else:\n            mat_input = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'matrix0_cache.txt'), 'numpy')\n        result = int(np.linalg.det(mat_input))\n        m = MatrixDet(mat_input).set_color(BLACK)\n        result_txt = Text(f'{result}').set_color(BLACK)\n        result_vgp.add(m, equal_txt.copy().set_color(BLACK), result_txt)\n        result_vgp.arrange(buff=1)\n        result_vgp.scale_to_fit_height(6)\n        self.add(result_vgp)"}]}
{"messages": [{"role": "user", "content": "Display two matrices and their sum with clear labels and formatting."}, {"role": "assistant", "content": "from yty_math.matrix_yty import *\nimport yty_math.file_operation as fo\nimport os\n\nclass AddResult(Scene):\n\n    def __init__(self, *data_load):\n        super().__init__()\n        self.data_load = data_load\n\n    def construct(self):\n        result_vgp = VGroup()\n        self.camera.background_color = WHITE\n        if self.data_load:\n            mat_input_1 = self.data_load[0]\n            mat_input_2 = self.data_load[1]\n        else:\n            mat_input_1 = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'matrix0_cache.txt'), 'numpy')\n            mat_input_2 = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'matrix1_cache.txt'), 'numpy')\n        m1 = MatrixMath(mat_input_1).set_color(BLACK)\n        m2 = MatrixMath(mat_input_2).set_color(BLACK)\n        m3 = m1.addition_mat(m2).set_color(BLACK)\n        result_vgp.add(m1, add_txt.copy().set_color(BLACK), m2, equal_txt.copy().set_color(BLACK), m3)\n        result_vgp.arrange(buff=1)\n        result_vgp.scale_to_fit_width(14)\n        self.add(result_vgp)"}]}
{"messages": [{"role": "user", "content": "Display two matrices and their dot product, separated by \"times\" and \"equals\" symbols."}, {"role": "assistant", "content": "from yty_math.matrix_yty import *\nimport yty_math.file_operation as fo\nimport os\n\nclass MulResult(Scene):\n\n    def __init__(self, *data_load):\n        super().__init__()\n        self.data_load = data_load\n\n    def construct(self):\n        result_vgp = VGroup()\n        self.camera.background_color = WHITE\n        if self.data_load:\n            mat_input_1 = self.data_load[0]\n            mat_input_2 = self.data_load[1]\n        else:\n            mat_input_1 = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'matrix0_cache.txt'), 'numpy')\n            mat_input_2 = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'matrix1_cache.txt'), 'numpy')\n        m1 = MatrixMath(mat_input_1).set_color(BLACK)\n        m2 = MatrixMath(mat_input_2).set_color(BLACK)\n        m3 = m1.dot_multiplication_mat(m2).set_color(BLACK)\n        result_vgp.add(m1, times_txt.copy().set_color(BLACK), m2, equal_txt.copy().set_color(BLACK), m3)\n        result_vgp.arrange(buff=1)\n        result_vgp.scale_to_fit_width(14)\n        self.add(result_vgp)"}]}
{"messages": [{"role": "user", "content": "Create a Manim scene that displays a matrix loaded from a file, scaled to fit the screen."}, {"role": "assistant", "content": "import os\nimport yty_math.file_operation as fo\nfrom yty_math.matrix_yty import *\n\nclass MatrixCreation(Scene):\n\n    def __init__(self, data_load=None):\n        super().__init__()\n        self.data_load = data_load\n\n    def construct(self):\n        if self.data_load:\n            matrix_data = self.data_load\n        else:\n            matrix_data = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'cache.txt'))\n        m = Matrix(matrix_data).set_color(BLACK)\n        screen_width = config.frame_width\n        screen_height = config.frame_height\n        matrix_width = m.width\n        matrix_height = m.height\n        scale_factor = min(screen_width / matrix_width, screen_height / matrix_height)\n        m.scale(scale_factor - 0.2)\n        m.move_to(ORIGIN)\n        self.add(m)"}]}
{"messages": [{"role": "user", "content": "Animate the step-by-step calculation of a matrix determinant, highlighting intermediate steps and the final result."}, {"role": "assistant", "content": "import os\nimport yty_math.file_operation as fo\nfrom yty_math.matrix_yty import *\n\nclass MatrixDetShow(Scene):\n\n    def __init__(self, data_load=None):\n        super().__init__()\n        self.data_load = data_load\n\n    def construct(self):\n        if self.data_load:\n            mat_input = self.data_load\n        else:\n            mat_input = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'matrix0_cache.txt'), 'numpy')\n        length = len(mat_input)\n        mat_mob = MatrixDet(mat_input)\n        mat_mob_det = mat_mob.det_mat()\n        neg_mat = mat_mob.neg_with_brackets()\n        neg_mat = neg_mat.det_mat()\n        neg_mat.set_scale_fitness()\n        res_vgp = mat_mob_det.cal_result_addition().shift(DOWN * 2).scale_to_fit_width(12)\n        self.play(Write(mat_mob), run_time=2)\n        self.wait()\n        self.play(Transform(mat_mob, mat_mob_det))\n        self.wait()\n        self.play(mat_mob.animate.set_scale_fitness())\n        self.wait()\n        res_vgp_cp = res_vgp.copy()\n        for i in range(2 * length):\n            vgp, vgp_brackets, num_lst = mat_mob.get_process_inform(i if i < length else length - i - 1, neg_mat)\n            self.play(vgp.animate.set_color(color_list[i]))\n            pro_vgp = cal_progress_times(color_list[i], vgp_brackets, num_lst).shift(DOWN)\n            pro_vgp_cp = pro_vgp.copy()\n            for j in range(length):\n                pro_vgp[2 * j].move_to(vgp[j])\n                self.add(pro_vgp[2 * j])\n                self.play(pro_vgp[2 * j].animate.move_to(pro_vgp_cp[2 * j]), run_time=time_control)\n                self.play(FadeIn(pro_vgp[2 * j + 1]), run_time=time_control)\n            self.play(FadeIn(pro_vgp[-1]), run_time=time_control)\n            res_vgp[2 * i].move_to(pro_vgp[-1]).set_color(color_list[i])\n            self.add(res_vgp[2 * i])\n            self.play(res_vgp[2 * i].animate.move_to(res_vgp_cp[2 * i]), run_time=time_control)\n            self.play(FadeIn(res_vgp[2 * i + 1]), run_time=time_control)\n            self.play(FadeOut(pro_vgp), run_time=time_control)\n            if i == length - 1:\n                self.play(mat_mob.animate.set_color(WHITE), run_time=time_control)\n        self.play(FadeIn(res_vgp[-1]), run_time=time_control)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Demonstrate matrix addition by showing two matrices, their sum, and then animating element-wise addition with corresponding number explanations."}, {"role": "assistant", "content": "import os\nimport yty_math.file_operation as fo\nfrom yty_math.matrix_yty import *\n\nclass MatrixAdditionShow(Scene):\n\n    def __init__(self, *data_load):\n        super().__init__()\n        self.data_load = data_load\n\n    def construct(self):\n        if self.data_load:\n            m1_input = self.data_load[0]\n            m2_input = self.data_load[1]\n        else:\n            m1_input = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'matrix0_cache.txt'), 'numpy')\n            m2_input = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'matrix1_cache.txt'), 'numpy')\n        color_add = [RED, BLUE]\n        t = add_txt.copy().shift(UP * 2)\n        e = equal_txt.copy()\n        m1 = MatrixMath(m1_input)\n        m1.fit_screen(t, LEFT)\n        m2 = MatrixMath(m2_input)\n        m2.fit_screen(t, RIGHT)\n        m3 = m1.addition_mat(m2)\n        m3.fit_screen(edge=DR)\n        e.next_to(m3, LEFT)\n        s1 = Square().scale_to_fit_height(m1[0][0].height / 1.2).move_to(m1[0][0]).set_color(color_add[0])\n        s2 = Square().scale_to_fit_height(m2[0][0].height / 1.2).move_to(m2[0][0]).set_color(color_add[1])\n        total = VGroup(m1, t, m2, e, m3[-2:])\n        self.play(Write(total), run_time=4)\n        ori_vgp = VGroup(Text(f'{m1_input[0][0]}' if m1_input[0][0] >= 0 else f'({m1_input[0][0]})').set_color(color_add[0]), add_txt.copy(), Text(f'{m2_input[0][0]}' if m2_input[0][0] >= 0 else f'({m2_input[0][0]})').set_color(color_add[1]), equal_txt.copy(), Text(f'{m1_input[0][0] + m2_input[0][0]}')).arrange().shift(DOWN * 1.75 + LEFT * 3.5)\n        if ori_vgp.width > 5.5:\n            ori_vgp.scale_to_fit_width(5.5)\n        self.play(FadeIn(ori_vgp), FadeIn(s1), FadeIn(s2), run_time=0.5)\n        for i in range(len(m1_input)):\n            for j in range(len(m1_input[0])):\n                first_txt = Text(f'{m1_input[i][j]}' if m1_input[i][j] >= 0 else f'({m1_input[i][j]})').set_color(color_add[0])\n                second_txt = Text(f'{m2_input[i][j]}' if m2_input[i][j] >= 0 else f'({m2_input[i][j]})').set_color(color_add[1])\n                res_txt = Text(f'{m1_input[i][j] + m2_input[i][j]}')\n                txt_vgp = VGroup(first_txt, add_txt.copy(), second_txt, equal_txt.copy(), res_txt).arrange().shift(DOWN * 1.75 + LEFT * 3.5)\n                if txt_vgp.width > 5.5:\n                    txt_vgp.scale_to_fit_width(5.5)\n                self.play(s1.animate.move_to(m1[i][j]), s2.animate.move_to(m2[i][j]), Transform(ori_vgp, txt_vgp), run_time=0.5)\n                self.play(ori_vgp[-1].copy().animate.scale(m3[0][0].height / 1.3).move_to(m3[i][j]), run_time=0.5)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Demonstrate matrix multiplication by showing the step-by-step calculation of each element."}, {"role": "assistant", "content": "import os\nimport yty_math.file_operation as fo\nfrom yty_math.matrix_yty import *\n\nclass MatrixMulShow(Scene):\n\n    def __init__(self, *data_load):\n        super().__init__()\n        self.data_load = data_load\n\n    def construct(self):\n        if self.data_load:\n            mat_a_input = self.data_load[0]\n            mat_b_input = self.data_load[1]\n        else:\n            mat_a_input = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'matrix0_cache.txt'), 'numpy')\n            mat_b_input = fo.read_matrix_from_file(os.path.join(fo.default_file_path, 'matrix1_cache.txt'), 'numpy')\n        run_time = 0.5\n        t = times_txt.copy().shift(UP * 2)\n        a = MatrixMath(mat_a_input)\n        a.fit_screen(t, LEFT)\n        b = MatrixMath(mat_b_input)\n        b.fit_screen(t, RIGHT)\n        c = a.dot_multiplication_mat(b)\n        c.fit_screen(edge=DR)\n        total = VGroup(a, t, b, equal_txt.copy().next_to(c, LEFT), c[-2:])\n        self.play(Write(total), run_time=4)\n        s1 = SurroundingRectangle(a.get_row(0), buff=0, fill_opacity=0.5, stroke_opacity=0).set_color(color_mul[0])\n        sliding1 = SurroundingRectangle(a.get_row(0)[0], buff=0).set_color(color_mul[2])\n        s2 = SurroundingRectangle(b.get_column(0), buff=0, fill_opacity=0.5, stroke_opacity=0).set_color(color_mul[1])\n        sliding2 = SurroundingRectangle(b.get_column(0)[0], buff=0).set_color(color_mul[3])\n        ori_vgp = VGroup(Text(f'{mat_a_input[0][0]}' if mat_a_input[0][0] >= 0 else f'({mat_a_input[0][0]})').set_color(RED), times_txt.copy(), Text(f'{mat_b_input[0][0]}' if mat_b_input[0][0] >= 0 else f'({mat_b_input[0][0]})').set_color(BLUE), equal_txt.copy(), Text(f'{mat_a_input[0][0] * mat_b_input[0][0]}')).arrange().shift(DOWN * 0.75 + LEFT * 3.5)\n        if ori_vgp.width > 5.5:\n            ori_vgp.scale_to_fit_width(5.5)\n        part = VGroup(s1, s2, sliding1, sliding2, ori_vgp)\n        self.play(FadeIn(part))\n        res_mat = mat_a_input @ mat_b_input\n        for i in range(res_mat.shape[0]):\n            for j in range(res_mat.shape[1]):\n                res_vgp = c.get_mul_progress([i, j], color_mul)\n                res_vgp[0].to_edge(LEFT).shift(DOWN * 2.5)\n                res_vgp[1].shift(LEFT * 2.6 + DOWN * 2.6)\n                if res_vgp[1].width >= 4.3:\n                    res_vgp[1].scale_to_fit_width(4.5)\n                self.play(FadeIn(res_vgp[0]), s1.animate.move_to(a.get_row(i)), s2.animate.move_to(b.get_column(j)), run_time=run_time)\n                for k in range(mat_a_input.shape[1]):\n                    pro_vgp = VGroup(Text(f'{mat_a_input[i][k]}' if mat_a_input[i][k] >= 0 else f'({mat_a_input[i][k]})').set_color(RED), times_txt.copy(), Text(f'{mat_b_input[k][j]}' if mat_b_input[k][j] >= 0 else f'({mat_b_input[k][j]})').set_color(BLUE), equal_txt.copy(), Text(f'{mat_a_input[i][k] * mat_b_input[k][j]}')).arrange().shift(DOWN * 0.75 + LEFT * 3.5)\n                    self.play(Transform(ori_vgp, pro_vgp), sliding1.animate.move_to(a.get_row(i)[k]), sliding2.animate.move_to(b.get_column(j)[k]), run_time=run_time)\n                    r1_cp = res_vgp[1].copy()\n                    res_vgp[1][2 * k].move_to(ori_vgp[-1])\n                    self.play(res_vgp[1][2 * k].animate.move_to(r1_cp[2 * k]), FadeIn(res_vgp[1][2 * k + 1]), run_time=run_time)\n                self.play(FadeIn(res_vgp[1][-1]))\n                self.play(res_vgp[1][-1].copy().animate.scale(c[0][0].height / 1.3).move_to(c[i][j]), run_time=run_time)\n                self.play(FadeOut(res_vgp), run_time=run_time)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Configure a scene to support and manage camera movement."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom manim.animation.animation import Animation\nfrom ..camera.moving_camera import MovingCamera\nfrom ..scene.scene import Scene\nfrom ..utils.family import extract_mobject_family_members\nfrom ..utils.iterables import list_update\n\nclass MovingCameraScene(Scene):\n    \"\"\"\n    This is a Scene, with special configurations and properties that\n    make it suitable for cases where the camera must be moved around.\n\n    .. SEEALSO::\n\n        :class:`.MovingCamera`\n    \"\"\"\n\n    def __init__(self, camera_class=MovingCamera, **kwargs):\n        super().__init__(camera_class=camera_class, **kwargs)\n\n    def get_moving_mobjects(self, *animations: Animation):\n        \"\"\"\n        This method returns a list of all of the Mobjects in the Scene that\n        are moving, that are also in the animations passed.\n\n        Parameters\n        ----------\n        *animations\n            The Animations whose mobjects will be checked.\n        \"\"\"\n        moving_mobjects = super().get_moving_mobjects(*animations)\n        all_moving_mobjects = extract_mobject_family_members(moving_mobjects)\n        movement_indicators = self.renderer.camera.get_mobjects_indicating_movement()\n        for movement_indicator in movement_indicators:\n            if movement_indicator in all_moving_mobjects:\n                return list_update(self.mobjects, moving_mobjects)\n        return moving_mobjects"}]}
{"messages": [{"role": "user", "content": "Create a Manim scene that supports 3D camera manipulations and provides methods for controlling camera orientation and movement."}, {"role": "assistant", "content": "from __future__ import annotations\nimport warnings\nfrom typing import Iterable, Sequence\nimport numpy as np\nfrom manim.mobject.geometry.line import Line\nfrom manim.mobject.graphing.coordinate_systems import ThreeDAxes\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\nfrom manim.mobject.three_d.three_dimensions import Sphere\nfrom manim.mobject.value_tracker import ValueTracker\nfrom .. import config\nfrom ..animation.animation import Animation\nfrom ..animation.transform import Transform\nfrom ..camera.three_d_camera import ThreeDCamera\nfrom ..constants import DEGREES, RendererType\nfrom ..mobject.mobject import Mobject\nfrom ..mobject.types.vectorized_mobject import VectorizedPoint, VGroup\nfrom ..renderer.opengl_renderer import OpenGLCamera\nfrom ..scene.scene import Scene\nfrom ..utils.config_ops import merge_dicts_recursively\n\nclass ThreeDScene(Scene):\n    \"\"\"\n    This is a Scene, with special configurations and properties that\n    make it suitable for Three Dimensional Scenes.\n    \"\"\"\n\n    def __init__(self, camera_class=ThreeDCamera, ambient_camera_rotation=None, default_angled_camera_orientation_kwargs=None, **kwargs):\n        self.ambient_camera_rotation = ambient_camera_rotation\n        if default_angled_camera_orientation_kwargs is None:\n            default_angled_camera_orientation_kwargs = {'phi': 70 * DEGREES, 'theta': -135 * DEGREES}\n        self.default_angled_camera_orientation_kwargs = default_angled_camera_orientation_kwargs\n        super().__init__(camera_class=camera_class, **kwargs)\n\n    def set_camera_orientation(self, phi: float | None=None, theta: float | None=None, gamma: float | None=None, zoom: float | None=None, focal_distance: float | None=None, frame_center: Mobject | Sequence[float] | None=None, **kwargs):\n        \"\"\"\n        This method sets the orientation of the camera in the scene.\n\n        Parameters\n        ----------\n        phi\n            The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        theta\n            The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.\n\n        focal_distance\n            The focal_distance of the Camera.\n\n        gamma\n            The rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        zoom\n            The zoom factor of the scene.\n\n        frame_center\n            The new center of the camera frame in cartesian coordinates.\n\n        \"\"\"\n        if phi is not None:\n            self.renderer.camera.set_phi(phi)\n        if theta is not None:\n            self.renderer.camera.set_theta(theta)\n        if focal_distance is not None:\n            self.renderer.camera.set_focal_distance(focal_distance)\n        if gamma is not None:\n            self.renderer.camera.set_gamma(gamma)\n        if zoom is not None:\n            self.renderer.camera.set_zoom(zoom)\n        if frame_center is not None:\n            self.renderer.camera._frame_center.move_to(frame_center)\n\n    def begin_ambient_camera_rotation(self, rate: float=0.02, about: str='theta'):\n        \"\"\"\n        This method begins an ambient rotation of the camera about the Z_AXIS,\n        in the anticlockwise direction\n\n        Parameters\n        ----------\n        rate\n            The rate at which the camera should rotate about the Z_AXIS.\n            Negative rate means clockwise rotation.\n        about\n            one of 3 options: [\"theta\", \"phi\", \"gamma\"]. defaults to theta.\n        \"\"\"\n        about: str = about.lower()\n        try:\n            if config.renderer == RendererType.CAIRO:\n                trackers = {'theta': self.camera.theta_tracker, 'phi': self.camera.phi_tracker, 'gamma': self.camera.gamma_tracker}\n                x: ValueTracker = trackers[about]\n                x.add_updater(lambda m, dt: x.increment_value(rate * dt))\n                self.add(x)\n            elif config.renderer == RendererType.OPENGL:\n                cam: OpenGLCamera = self.camera\n                methods = {'theta': cam.increment_theta, 'phi': cam.increment_phi, 'gamma': cam.increment_gamma}\n                cam.add_updater(lambda m, dt: methods[about](rate * dt))\n                self.add(self.camera)\n        except Exception:\n            raise ValueError('Invalid ambient rotation angle.')\n\n    def stop_ambient_camera_rotation(self, about='theta'):\n        \"\"\"\n        This method stops all ambient camera rotation.\n        \"\"\"\n        about: str = about.lower()\n        try:\n            if config.renderer == RendererType.CAIRO:\n                trackers = {'theta': self.camera.theta_tracker, 'phi': self.camera.phi_tracker, 'gamma': self.camera.gamma_tracker}\n                x: ValueTracker = trackers[about]\n                x.clear_updaters()\n                self.remove(x)\n            elif config.renderer == RendererType.OPENGL:\n                self.camera.clear_updaters()\n        except Exception:\n            raise ValueError('Invalid ambient rotation angle.')\n\n    def begin_3dillusion_camera_rotation(self, rate: float=1, origin_phi: float | None=None, origin_theta: float | None=None):\n        \"\"\"\n        This method creates a 3D camera rotation illusion around\n        the current camera orientation.\n\n        Parameters\n        ----------\n        rate\n            The rate at which the camera rotation illusion should operate.\n        origin_phi\n            The polar angle the camera should move around. Defaults\n            to the current phi angle.\n        origin_theta\n            The azimutal angle the camera should move around. Defaults\n            to the current theta angle.\n        \"\"\"\n        if origin_theta is None:\n            origin_theta = self.renderer.camera.theta_tracker.get_value()\n        if origin_phi is None:\n            origin_phi = self.renderer.camera.phi_tracker.get_value()\n        val_tracker_theta = ValueTracker(0)\n\n        def update_theta(m, dt):\n            val_tracker_theta.increment_value(dt * rate)\n            val_for_left_right = 0.2 * np.sin(val_tracker_theta.get_value())\n            return m.set_value(origin_theta + val_for_left_right)\n        self.renderer.camera.theta_tracker.add_updater(update_theta)\n        self.add(self.renderer.camera.theta_tracker)\n        val_tracker_phi = ValueTracker(0)\n\n        def update_phi(m, dt):\n            val_tracker_phi.increment_value(dt * rate)\n            val_for_up_down = 0.1 * np.cos(val_tracker_phi.get_value()) - 0.1\n            return m.set_value(origin_phi + val_for_up_down)\n        self.renderer.camera.phi_tracker.add_updater(update_phi)\n        self.add(self.renderer.camera.phi_tracker)\n\n    def stop_3dillusion_camera_rotation(self):\n        \"\"\"\n        This method stops all illusion camera rotations.\n        \"\"\"\n        self.renderer.camera.theta_tracker.clear_updaters()\n        self.remove(self.renderer.camera.theta_tracker)\n        self.renderer.camera.phi_tracker.clear_updaters()\n        self.remove(self.renderer.camera.phi_tracker)\n\n    def move_camera(self, phi: float | None=None, theta: float | None=None, gamma: float | None=None, zoom: float | None=None, focal_distance: float | None=None, frame_center: Mobject | Sequence[float] | None=None, added_anims: Iterable[Animation]=[], **kwargs):\n        \"\"\"\n        This method animates the movement of the camera\n        to the given spherical coordinates.\n\n        Parameters\n        ----------\n        phi\n            The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.\n\n        theta\n            The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.\n\n        focal_distance\n            The radial focal_distance between ORIGIN and Camera.\n\n        gamma\n            The rotation of the camera about the vector from the ORIGIN to the Camera.\n\n        zoom\n            The zoom factor of the camera.\n\n        frame_center\n            The new center of the camera frame in cartesian coordinates.\n\n        added_anims\n            Any other animations to be played at the same time.\n\n        \"\"\"\n        anims = []\n        if config.renderer == RendererType.CAIRO:\n            self.camera: ThreeDCamera\n            value_tracker_pairs = [(phi, self.camera.phi_tracker), (theta, self.camera.theta_tracker), (focal_distance, self.camera.focal_distance_tracker), (gamma, self.camera.gamma_tracker), (zoom, self.camera.zoom_tracker)]\n            for value, tracker in value_tracker_pairs:\n                if value is not None:\n                    anims.append(tracker.animate.set_value(value))\n            if frame_center is not None:\n                anims.append(self.camera._frame_center.animate.move_to(frame_center))\n        elif config.renderer == RendererType.OPENGL:\n            cam: OpenGLCamera = self.camera\n            cam2 = cam.copy()\n            methods = {'theta': cam2.set_theta, 'phi': cam2.set_phi, 'gamma': cam2.set_gamma, 'zoom': cam2.scale, 'frame_center': cam2.move_to}\n            if frame_center is not None:\n                if isinstance(frame_center, OpenGLMobject):\n                    frame_center = frame_center.get_center()\n                frame_center = list(frame_center)\n            for value, method in [[theta, 'theta'], [phi, 'phi'], [gamma, 'gamma'], [config.frame_height / (zoom * cam.height) if zoom is not None else None, 'zoom'], [frame_center, 'frame_center']]:\n                if value is not None:\n                    methods[method](value)\n            if focal_distance is not None:\n                warnings.warn('focal distance of OpenGLCamera can not be adjusted.', stacklevel=2)\n            anims += [Transform(cam, cam2)]\n        self.play(*anims + added_anims, **kwargs)\n        if frame_center is not None and config.renderer == RendererType.CAIRO:\n            self.remove(self.camera._frame_center)\n\n    def get_moving_mobjects(self, *animations: Animation):\n        \"\"\"\n        This method returns a list of all of the Mobjects in the Scene that\n        are moving, that are also in the animations passed.\n\n        Parameters\n        ----------\n        *animations\n            The animations whose mobjects will be checked.\n        \"\"\"\n        moving_mobjects = super().get_moving_mobjects(*animations)\n        camera_mobjects = self.renderer.camera.get_value_trackers() + [self.renderer.camera._frame_center]\n        if any((cm in moving_mobjects for cm in camera_mobjects)):\n            return self.mobjects\n        return moving_mobjects\n\n    def add_fixed_orientation_mobjects(self, *mobjects: Mobject, **kwargs):\n        \"\"\"\n        This method is used to prevent the rotation and tilting\n        of mobjects as the camera moves around. The mobject can\n        still move in the x,y,z directions, but will always be\n        at the angle (relative to the camera) that it was at\n        when it was passed through this method.)\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobject(s) whose orientation must be fixed.\n\n        **kwargs\n            Some valid kwargs are\n                use_static_center_func : bool\n                center_func : function\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.add(*mobjects)\n            self.renderer.camera.add_fixed_orientation_mobjects(*mobjects, **kwargs)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.fix_orientation()\n                self.add(mob)\n\n    def add_fixed_in_frame_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n        This method is used to prevent the rotation and movement\n        of mobjects as the camera moves around. The mobject is\n        essentially overlaid, and is not impacted by the camera's\n        movement in any way.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects whose orientation must be fixed.\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.add(*mobjects)\n            self.camera: ThreeDCamera\n            self.camera.add_fixed_in_frame_mobjects(*mobjects)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.fix_in_frame()\n                self.add(mob)\n\n    def remove_fixed_orientation_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n        This method \"unfixes\" the orientation of the mobjects\n        passed, meaning they will no longer be at the same angle\n        relative to the camera. This only makes sense if the\n        mobject was passed through add_fixed_orientation_mobjects first.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects whose orientation must be unfixed.\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.renderer.camera.remove_fixed_orientation_mobjects(*mobjects)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.unfix_orientation()\n                self.remove(mob)\n\n    def remove_fixed_in_frame_mobjects(self, *mobjects: Mobject):\n        \"\"\"\n         This method undoes what add_fixed_in_frame_mobjects does.\n         It allows the mobject to be affected by the movement of\n         the camera.\n\n        Parameters\n        ----------\n        *mobjects\n            The Mobjects whose position and orientation must be unfixed.\n        \"\"\"\n        if config.renderer == RendererType.CAIRO:\n            self.renderer.camera.remove_fixed_in_frame_mobjects(*mobjects)\n        elif config.renderer == RendererType.OPENGL:\n            for mob in mobjects:\n                mob: OpenGLMobject\n                mob.unfix_from_frame()\n                self.remove(mob)\n\n    def set_to_default_angled_camera_orientation(self, **kwargs):\n        \"\"\"\n        This method sets the default_angled_camera_orientation to the\n        keyword arguments passed, and sets the camera to that orientation.\n\n        Parameters\n        ----------\n        **kwargs\n            Some recognised kwargs are phi, theta, focal_distance, gamma,\n            which have the same meaning as the parameters in set_camera_orientation.\n        \"\"\"\n        config = dict(self.default_camera_orientation_kwargs)\n        config.update(kwargs)\n        self.set_camera_orientation(**config)"}]}
{"messages": [{"role": "user", "content": "Define a special 3D scene class with default configurations for axes, spheres, and camera orientation."}, {"role": "assistant", "content": "from __future__ import annotations\nimport warnings\nfrom typing import Iterable, Sequence\nimport numpy as np\nfrom manim.mobject.geometry.line import Line\nfrom manim.mobject.graphing.coordinate_systems import ThreeDAxes\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\nfrom manim.mobject.three_d.three_dimensions import Sphere\nfrom manim.mobject.value_tracker import ValueTracker\nfrom .. import config\nfrom ..animation.animation import Animation\nfrom ..animation.transform import Transform\nfrom ..camera.three_d_camera import ThreeDCamera\nfrom ..constants import DEGREES, RendererType\nfrom ..mobject.mobject import Mobject\nfrom ..mobject.types.vectorized_mobject import VectorizedPoint, VGroup\nfrom ..renderer.opengl_renderer import OpenGLCamera\nfrom ..scene.scene import Scene\nfrom ..utils.config_ops import merge_dicts_recursively\n\nclass SpecialThreeDScene(ThreeDScene):\n    \"\"\"An extension of :class:`ThreeDScene` with more settings.\n\n    It has some extra configuration for axes, spheres,\n    and an override for low quality rendering. Further key differences\n    are:\n\n    * The camera shades applicable 3DMobjects by default,\n      except if rendering in low quality.\n    * Some default params for Spheres and Axes have been added.\n\n    \"\"\"\n\n    def __init__(self, cut_axes_at_radius=True, camera_config={'should_apply_shading': True, 'exponential_projection': True}, three_d_axes_config={'num_axis_pieces': 1, 'axis_config': {'unit_size': 2, 'tick_frequency': 1, 'numbers_with_elongated_ticks': [0, 1, 2], 'stroke_width': 2}}, sphere_config={'radius': 2, 'resolution': (24, 48)}, default_angled_camera_position={'phi': 70 * DEGREES, 'theta': -110 * DEGREES}, low_quality_config={'camera_config': {'should_apply_shading': False}, 'three_d_axes_config': {'num_axis_pieces': 1}, 'sphere_config': {'resolution': (12, 24)}}, **kwargs):\n        self.cut_axes_at_radius = cut_axes_at_radius\n        self.camera_config = camera_config\n        self.three_d_axes_config = three_d_axes_config\n        self.sphere_config = sphere_config\n        self.default_angled_camera_position = default_angled_camera_position\n        self.low_quality_config = low_quality_config\n        if self.renderer.camera_config['pixel_width'] == config['pixel_width']:\n            _config = {}\n        else:\n            _config = self.low_quality_config\n        _config = merge_dicts_recursively(_config, kwargs)\n        super().__init__(**_config)\n\n    def get_axes(self):\n        \"\"\"Return a set of 3D axes.\n\n        Returns\n        -------\n        :class:`.ThreeDAxes`\n            A set of 3D axes.\n        \"\"\"\n        axes = ThreeDAxes(**self.three_d_axes_config)\n        for axis in axes:\n            if self.cut_axes_at_radius:\n                p0 = axis.get_start()\n                p1 = axis.number_to_point(-1)\n                p2 = axis.number_to_point(1)\n                p3 = axis.get_end()\n                new_pieces = VGroup(Line(p0, p1), Line(p1, p2), Line(p2, p3))\n                for piece in new_pieces:\n                    piece.shade_in_3d = True\n                new_pieces.match_style(axis.pieces)\n                axis.pieces.submobjects = new_pieces.submobjects\n            for tick in axis.tick_marks:\n                tick.add(VectorizedPoint(1.5 * tick.get_center()))\n        return axes\n\n    def get_sphere(self, **kwargs):\n        \"\"\"\n        Returns a sphere with the passed keyword arguments as properties.\n\n        Parameters\n        ----------\n        **kwargs\n            Any valid parameter of :class:`~.Sphere` or :class:`~.Surface`.\n\n        Returns\n        -------\n        :class:`~.Sphere`\n            The sphere object.\n        \"\"\"\n        config = merge_dicts_recursively(self.sphere_config, kwargs)\n        return Sphere(**config)\n\n    def get_default_camera_position(self):\n        \"\"\"\n        Returns the default_angled_camera position.\n\n        Returns\n        -------\n        dict\n            Dictionary of phi, theta, focal_distance, and gamma.\n        \"\"\"\n        return self.default_angled_camera_position\n\n    def set_camera_to_default_position(self):\n        \"\"\"\n        Sets the camera to its default position.\n        \"\"\"\n        self.set_camera_orientation(**self.default_angled_camera_position)"}]}
{"messages": [{"role": "user", "content": "Create a Manim scene that sets up a zoomed-in view of a specific part of the scene."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom ..animation.transform import ApplyMethod\nfrom ..camera.moving_camera import MovingCamera\nfrom ..camera.multi_camera import MultiCamera\nfrom ..constants import *\nfrom ..mobject.types.image_mobject import ImageMobjectFromCamera\nfrom ..scene.moving_camera_scene import MovingCameraScene\n\nclass ZoomedScene(MovingCameraScene):\n    \"\"\"\n    This is a Scene with special configurations made for when\n    a particular part of the scene must be zoomed in on and displayed\n    separately.\n    \"\"\"\n\n    def __init__(self, camera_class=MultiCamera, zoomed_display_height=3, zoomed_display_width=3, zoomed_display_center=None, zoomed_display_corner=UP + RIGHT, zoomed_display_corner_buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER, zoomed_camera_config={'default_frame_stroke_width': 2, 'background_opacity': 1}, zoomed_camera_image_mobject_config={}, zoomed_camera_frame_starting_position=ORIGIN, zoom_factor=0.15, image_frame_stroke_width=3, zoom_activated=False, **kwargs):\n        self.zoomed_display_height = zoomed_display_height\n        self.zoomed_display_width = zoomed_display_width\n        self.zoomed_display_center = zoomed_display_center\n        self.zoomed_display_corner = zoomed_display_corner\n        self.zoomed_display_corner_buff = zoomed_display_corner_buff\n        self.zoomed_camera_config = zoomed_camera_config\n        self.zoomed_camera_image_mobject_config = zoomed_camera_image_mobject_config\n        self.zoomed_camera_frame_starting_position = zoomed_camera_frame_starting_position\n        self.zoom_factor = zoom_factor\n        self.image_frame_stroke_width = image_frame_stroke_width\n        self.zoom_activated = zoom_activated\n        super().__init__(camera_class=camera_class, **kwargs)\n\n    def setup(self):\n        \"\"\"\n        This method is used internally by Manim to\n        setup the scene for proper use.\n        \"\"\"\n        super().setup()\n        zoomed_camera = MovingCamera(**self.zoomed_camera_config)\n        zoomed_display = ImageMobjectFromCamera(zoomed_camera, **self.zoomed_camera_image_mobject_config)\n        zoomed_display.add_display_frame()\n        for mob in (zoomed_camera.frame, zoomed_display):\n            mob.stretch_to_fit_height(self.zoomed_display_height)\n            mob.stretch_to_fit_width(self.zoomed_display_width)\n        zoomed_camera.frame.scale(self.zoom_factor)\n        zoomed_camera.frame.move_to(self.zoomed_camera_frame_starting_position)\n        if self.zoomed_display_center is not None:\n            zoomed_display.move_to(self.zoomed_display_center)\n        else:\n            zoomed_display.to_corner(self.zoomed_display_corner, buff=self.zoomed_display_corner_buff)\n        self.zoomed_camera = zoomed_camera\n        self.zoomed_display = zoomed_display\n\n    def activate_zooming(self, animate: bool=False):\n        \"\"\"\n        This method is used to activate the zooming for\n        the zoomed_camera.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the activation\n            of the zoomed camera.\n        \"\"\"\n        self.zoom_activated = True\n        self.renderer.camera.add_image_mobject_from_camera(self.zoomed_display)\n        if animate:\n            self.play(self.get_zoom_in_animation())\n            self.play(self.get_zoomed_display_pop_out_animation())\n        self.add_foreground_mobjects(self.zoomed_camera.frame, self.zoomed_display)\n\n    def get_zoom_in_animation(self, run_time: float=2, **kwargs):\n        \"\"\"\n        Returns the animation of camera zooming in.\n\n        Parameters\n        ----------\n        run_time\n            The run_time of the animation of the camera zooming in.\n        **kwargs\n            Any valid keyword arguments of ApplyMethod()\n\n        Returns\n        -------\n        ApplyMethod\n            The animation of the camera zooming in.\n        \"\"\"\n        frame = self.zoomed_camera.frame\n        full_frame_height = self.camera.frame_height\n        full_frame_width = self.camera.frame_width\n        frame.save_state()\n        frame.stretch_to_fit_width(full_frame_width)\n        frame.stretch_to_fit_height(full_frame_height)\n        frame.center()\n        frame.set_stroke(width=0)\n        return ApplyMethod(frame.restore, run_time=run_time, **kwargs)\n\n    def get_zoomed_display_pop_out_animation(self, **kwargs):\n        \"\"\"\n        This is the animation of the popping out of the\n        mini-display that shows the content of the zoomed\n        camera.\n\n        Returns\n        -------\n        ApplyMethod\n            The Animation of the Zoomed Display popping out.\n        \"\"\"\n        display = self.zoomed_display\n        display.save_state()\n        display.replace(self.zoomed_camera.frame, stretch=True)\n        return ApplyMethod(display.restore)\n\n    def get_zoom_factor(self):\n        \"\"\"\n        Returns the Zoom factor of the Zoomed camera.\n        Defined as the ratio between the height of the\n        zoomed camera and the height of the zoomed mini\n        display.\n        Returns\n        -------\n        float\n            The zoom factor.\n        \"\"\"\n        return self.zoomed_camera.frame.height / self.zoomed_display.height"}]}
{"messages": [{"role": "user", "content": "Demonstrate how vectors are represented in coordinate space by showing axes, basis vectors with labels, and then illustrating a vector's components and its coordinate matrix representation."}, {"role": "assistant", "content": "from __future__ import annotations\nfrom typing import Callable\nimport numpy as np\nfrom manim.mobject.geometry.arc import Dot\nfrom manim.mobject.geometry.line import Arrow, Line, Vector\nfrom manim.mobject.geometry.polygram import Rectangle\nfrom manim.mobject.graphing.coordinate_systems import Axes, NumberPlane\nfrom manim.mobject.opengl.opengl_mobject import OpenGLMobject\nfrom manim.mobject.text.tex_mobject import MathTex, Tex\nfrom manim.utils.config_ops import update_dict_recursively\nfrom .. import config\nfrom ..animation.animation import Animation\nfrom ..animation.creation import Create, Write\nfrom ..animation.fading import FadeOut\nfrom ..animation.growing import GrowArrow\nfrom ..animation.transform import ApplyFunction, ApplyPointwiseFunction, Transform\nfrom ..constants import *\nfrom ..mobject.matrix import Matrix\nfrom ..mobject.mobject import Mobject\nfrom ..mobject.types.vectorized_mobject import VGroup, VMobject\nfrom ..scene.scene import Scene\nfrom ..utils.color import BLACK, BLUE_D, GREEN_C, GREY, RED_C, WHITE, YELLOW, ManimColor, ParsableManimColor\nfrom ..utils.rate_functions import rush_from, rush_into\nfrom ..utils.space_ops import angle_of_vector\n\nclass VectorScene(Scene):\n\n    def __init__(self, basis_vector_stroke_width=6, **kwargs):\n        super().__init__(**kwargs)\n        self.basis_vector_stroke_width = basis_vector_stroke_width\n\n    def add_plane(self, animate: bool=False, **kwargs):\n        \"\"\"\n        Adds a NumberPlane object to the background.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the addition of the plane via Create.\n        **kwargs\n            Any valid keyword arguments accepted by NumberPlane.\n\n        Returns\n        -------\n        NumberPlane\n            The NumberPlane object.\n        \"\"\"\n        plane = NumberPlane(**kwargs)\n        if animate:\n            self.play(Create(plane, lag_ratio=0.5))\n        self.add(plane)\n        return plane\n\n    def add_axes(self, animate: bool=False, color: bool=WHITE, **kwargs):\n        \"\"\"\n        Adds a pair of Axes to the Scene.\n\n        Parameters\n        ----------\n        animate\n            Whether or not to animate the addition of the axes through Create.\n        color\n            The color of the axes. Defaults to WHITE.\n        \"\"\"\n        axes = Axes(color=color, axis_config={'unit_size': 1})\n        if animate:\n            self.play(Create(axes))\n        self.add(axes)\n        return axes\n\n    def lock_in_faded_grid(self, dimness: float=0.7, axes_dimness: float=0.5):\n        \"\"\"\n        This method freezes the NumberPlane and Axes that were already\n        in the background, and adds new, manipulatable ones to the foreground.\n\n        Parameters\n        ----------\n        dimness\n            The required dimness of the NumberPlane\n\n        axes_dimness\n            The required dimness of the Axes.\n        \"\"\"\n        plane = self.add_plane()\n        axes = plane.get_axes()\n        plane.fade(dimness)\n        axes.set_color(WHITE)\n        axes.fade(axes_dimness)\n        self.add(axes)\n        self.renderer.update_frame()\n        self.renderer.camera = Camera(self.renderer.get_frame())\n        self.clear()\n\n    def get_vector(self, numerical_vector: np.ndarray | list | tuple, **kwargs):\n        \"\"\"\n        Returns an arrow on the Plane given an input numerical vector.\n\n        Parameters\n        ----------\n        numerical_vector\n            The Vector to plot.\n        **kwargs\n            Any valid keyword argument of Arrow.\n\n        Returns\n        -------\n        Arrow\n            The Arrow representing the Vector.\n        \"\"\"\n        return Arrow(self.plane.coords_to_point(0, 0), self.plane.coords_to_point(*numerical_vector[:2]), buff=0, **kwargs)\n\n    def add_vector(self, vector: Arrow | list | tuple | np.ndarray, color: str=YELLOW, animate: bool=True, **kwargs):\n        \"\"\"\n        Returns the Vector after adding it to the Plane.\n\n        Parameters\n        ----------\n        vector\n            It can be a pre-made graphical vector, or the\n            coordinates of one.\n\n        color\n            The string of the hex color of the vector.\n            This is only taken into consideration if\n            'vector' is not an Arrow. Defaults to YELLOW.\n\n        animate\n            Whether or not to animate the addition of the vector\n            by using GrowArrow\n\n        **kwargs\n            Any valid keyword argument of Arrow.\n            These are only considered if vector is not\n            an Arrow.\n\n        Returns\n        -------\n        Arrow\n            The arrow representing the vector.\n        \"\"\"\n        if not isinstance(vector, Arrow):\n            vector = Vector(vector, color=color, **kwargs)\n        if animate:\n            self.play(GrowArrow(vector))\n        self.add(vector)\n        return vector\n\n    def write_vector_coordinates(self, vector: Arrow, **kwargs):\n        \"\"\"\n        Returns a column matrix indicating the vector coordinates,\n        after writing them to the screen.\n\n        Parameters\n        ----------\n        vector\n            The arrow representing the vector.\n\n        **kwargs\n            Any valid keyword arguments of :meth:`~.Vector.coordinate_label`:\n\n        Returns\n        -------\n        :class:`.Matrix`\n            The column matrix representing the vector.\n        \"\"\"\n        coords = vector.coordinate_label(**kwargs)\n        self.play(Write(coords))\n        return coords\n\n    def get_basis_vectors(self, i_hat_color: str=X_COLOR, j_hat_color: str=Y_COLOR):\n        \"\"\"\n        Returns a VGroup of the Basis Vectors (1,0) and (0,1)\n\n        Parameters\n        ----------\n        i_hat_color\n            The hex colour to use for the basis vector in the x direction\n\n        j_hat_color\n            The hex colour to use for the basis vector in the y direction\n\n        Returns\n        -------\n        VGroup\n            VGroup of the Vector Mobjects representing the basis vectors.\n        \"\"\"\n        return VGroup(*(Vector(vect, color=color, stroke_width=self.basis_vector_stroke_width) for vect, color in [([1, 0], i_hat_color), ([0, 1], j_hat_color)]))\n\n    def get_basis_vector_labels(self, **kwargs):\n        \"\"\"\n        Returns naming labels for the basis vectors.\n\n        Parameters\n        ----------\n        **kwargs\n            Any valid keyword arguments of get_vector_label:\n                vector,\n                label (str,MathTex)\n                at_tip (bool=False),\n                direction (str=\"left\"),\n                rotate (bool),\n                color (str),\n                label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),\n        \"\"\"\n        i_hat, j_hat = self.get_basis_vectors()\n        return VGroup(*(self.get_vector_label(vect, label, color=color, label_scale_factor=1, **kwargs) for vect, label, color in [(i_hat, '\\\\hat{\\\\imath}', X_COLOR), (j_hat, '\\\\hat{\\\\jmath}', Y_COLOR)]))\n\n    def get_vector_label(self, vector: Vector, label, at_tip: bool=False, direction: str='left', rotate: bool=False, color: str | None=None, label_scale_factor: float=LARGE_BUFF - 0.2):\n        \"\"\"\n        Returns naming labels for the passed vector.\n\n        Parameters\n        ----------\n        vector\n            Vector Object for which to get the label.\n\n        at_tip\n            Whether or not to place the label at the tip of the vector.\n\n        direction\n            If the label should be on the \"left\" or right of the vector.\n        rotate\n            Whether or not to rotate it to align it with the vector.\n        color\n            The color to give the label.\n        label_scale_factor\n            How much to scale the label by.\n\n        Returns\n        -------\n        MathTex\n            The MathTex of the label.\n        \"\"\"\n        if not isinstance(label, MathTex):\n            if len(label) == 1:\n                label = '\\\\vec{\\\\textbf{%s}}' % label\n            label = MathTex(label)\n            if color is None:\n                color = vector.get_color()\n            label.set_color(color)\n        label.scale(label_scale_factor)\n        label.add_background_rectangle()\n        if at_tip:\n            vect = vector.get_vector()\n            vect /= np.linalg.norm(vect)\n            label.next_to(vector.get_end(), vect, buff=SMALL_BUFF)\n        else:\n            angle = vector.get_angle()\n            if not rotate:\n                label.rotate(-angle, about_point=ORIGIN)\n            if direction == 'left':\n                label.shift(-label.get_bottom() + 0.1 * UP)\n            else:\n                label.shift(-label.get_top() + 0.1 * DOWN)\n            label.rotate(angle, about_point=ORIGIN)\n            label.shift((vector.get_end() - vector.get_start()) / 2)\n        return label\n\n    def label_vector(self, vector: Vector, label: MathTex | str, animate: bool=True, **kwargs):\n        \"\"\"\n        Shortcut method for creating, and animating the addition of\n        a label for the vector.\n\n        Parameters\n        ----------\n        vector\n            The vector for which the label must be added.\n\n        label\n            The MathTex/string of the label.\n\n        animate\n            Whether or not to animate the labelling w/ Write\n\n        **kwargs\n            Any valid keyword argument of get_vector_label\n\n        Returns\n        -------\n        :class:`~.MathTex`\n            The MathTex of the label.\n        \"\"\"\n        label = self.get_vector_label(vector, label, **kwargs)\n        if animate:\n            self.play(Write(label, run_time=1))\n        self.add(label)\n        return label\n\n    def position_x_coordinate(self, x_coord, x_line, vector):\n        x_coord.next_to(x_line, -np.sign(vector[1]) * UP)\n        x_coord.set_color(X_COLOR)\n        return x_coord\n\n    def position_y_coordinate(self, y_coord, y_line, vector):\n        y_coord.next_to(y_line, np.sign(vector[0]) * RIGHT)\n        y_coord.set_color(Y_COLOR)\n        return y_coord\n\n    def coords_to_vector(self, vector: np.ndarray | list | tuple, coords_start: np.ndarray | list | tuple=2 * RIGHT + 2 * UP, clean_up: bool=True):\n        \"\"\"\n        This method writes the vector as a column matrix (henceforth called the label),\n        takes the values in it one by one, and form the corresponding\n        lines that make up the x and y components of the vector. Then, an\n        Vector() based vector is created between the lines on the Screen.\n\n        Parameters\n        ----------\n        vector\n            The vector to show.\n\n        coords_start\n            The starting point of the location of\n            the label of the vector that shows it\n            numerically.\n            Defaults to 2 * RIGHT + 2 * UP or (2,2)\n\n        clean_up\n            Whether or not to remove whatever\n            this method did after it's done.\n\n        \"\"\"\n        starting_mobjects = list(self.mobjects)\n        array = Matrix(vector)\n        array.shift(coords_start)\n        arrow = Vector(vector)\n        x_line = Line(ORIGIN, vector[0] * RIGHT)\n        y_line = Line(x_line.get_end(), arrow.get_end())\n        x_line.set_color(X_COLOR)\n        y_line.set_color(Y_COLOR)\n        x_coord, y_coord = array.get_mob_matrix().flatten()\n        self.play(Write(array, run_time=1))\n        self.wait()\n        self.play(ApplyFunction(lambda x: self.position_x_coordinate(x, x_line, vector), x_coord))\n        self.play(Create(x_line))\n        animations = [ApplyFunction(lambda y: self.position_y_coordinate(y, y_line, vector), y_coord), FadeOut(array.get_brackets())]\n        self.play(*animations)\n        y_coord, _ = (anim.mobject for anim in animations)\n        self.play(Create(y_line))\n        self.play(Create(arrow))\n        self.wait()\n        if clean_up:\n            self.clear()\n            self.add(*starting_mobjects)\n\n    def vector_to_coords(self, vector: np.ndarray | list | tuple, integer_labels: bool=True, clean_up: bool=True):\n        \"\"\"\n        This method displays vector as a Vector() based vector, and then shows\n        the corresponding lines that make up the x and y components of the vector.\n        Then, a column matrix (henceforth called the label) is created near the\n        head of the Vector.\n\n        Parameters\n        ----------\n        vector\n            The vector to show.\n\n        integer_labels\n            Whether or not to round the value displayed.\n            in the vector's label to the nearest integer\n\n        clean_up\n            Whether or not to remove whatever\n            this method did after it's done.\n\n        \"\"\"\n        starting_mobjects = list(self.mobjects)\n        show_creation = False\n        if isinstance(vector, Arrow):\n            arrow = vector\n            vector = arrow.get_end()[:2]\n        else:\n            arrow = Vector(vector)\n            show_creation = True\n        array = arrow.coordinate_label(integer_labels=integer_labels)\n        x_line = Line(ORIGIN, vector[0] * RIGHT)\n        y_line = Line(x_line.get_end(), arrow.get_end())\n        x_line.set_color(X_COLOR)\n        y_line.set_color(Y_COLOR)\n        x_coord, y_coord = array.get_entries()\n        x_coord_start = self.position_x_coordinate(x_coord.copy(), x_line, vector)\n        y_coord_start = self.position_y_coordinate(y_coord.copy(), y_line, vector)\n        brackets = array.get_brackets()\n        if show_creation:\n            self.play(Create(arrow))\n        self.play(Create(x_line), Write(x_coord_start), run_time=1)\n        self.play(Create(y_line), Write(y_coord_start), run_time=1)\n        self.wait()\n        self.play(Transform(x_coord_start, x_coord, lag_ratio=0), Transform(y_coord_start, y_coord, lag_ratio=0), Write(brackets, run_time=1))\n        self.wait()\n        self.remove(x_coord_start, y_coord_start, brackets)\n        self.add(array)\n        if clean_up:\n            self.clear()\n            self.add(*starting_mobjects)\n        return (array, x_line, y_line)\n\n    def show_ghost_movement(self, vector: Arrow | list | tuple | np.ndarray):\n        \"\"\"\n        This method plays an animation that partially shows the entire plane moving\n        in the direction of a particular vector. This is useful when you wish to\n        convey the idea of mentally moving the entire plane in a direction, without\n        actually moving the plane.\n\n        Parameters\n        ----------\n        vector\n            The vector which indicates the direction of movement.\n        \"\"\"\n        if isinstance(vector, Arrow):\n            vector = vector.get_end() - vector.get_start()\n        elif len(vector) == 2:\n            vector = np.append(np.array(vector), 0.0)\n        x_max = int(config['frame_x_radius'] + abs(vector[0]))\n        y_max = int(config['frame_y_radius'] + abs(vector[1]))\n        dots = VMobject(*(Dot(x * RIGHT + y * UP) for x in range(-x_max, x_max) for y in range(-y_max, y_max)))\n        dots.set_fill(BLACK, opacity=0)\n        dots_halfway = dots.copy().shift(vector / 2).set_fill(WHITE, 1)\n        dots_end = dots.copy().shift(vector)\n        self.play(Transform(dots, dots_halfway, rate_func=rush_into))\n        self.play(Transform(dots, dots_end, rate_func=rush_from))\n        self.remove(dots)"}]}
{"messages": [{"role": "user", "content": "Visualize a sequence of qubit tree cluster states, transitioning smoothly between each state with its corresponding vector notation."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\n\nclass TreeClusterStates(Scene):\n\n    def construct(self):\n        self.camera.background_color = '#ece6e2'\n        my_black = '#343434'\n        radius_scaling = 2.2\n        array_of_treevectors = np.array([np.array([2, 2]), np.array([2, 4]), np.array([2, 4, 2]), np.array([4, 2, 2]), np.array([3, 3, 2]), np.array([2, 2, 2, 2]), np.array([3, 3, 2, 2])], dtype=object)\n        my_titles = VGroup(Tex('\\\\underline{Qubit - Tree cluster states}').to_corner(UL)).set_color(my_black)\n        VTrees = [get_tree(t, radius_scaling, color=my_black) for t in array_of_treevectors]\n\n        def treevector_display(t):\n            return Tex('$\\\\Vec{t}=' + get_treevector_str(t) + '$')\n        treevector_Tex = [treevector_display(t).set_color(my_black).to_corner(UR) for t in array_of_treevectors]\n        self.add(my_titles[0])\n        self.play(Write(VTrees[0]), Write(treevector_Tex[0]))\n        for i in range(1, len(array_of_treevectors)):\n            self.wait(1.8)\n            self.play(TransformMatchingShapes(VTrees[i - 1], VTrees[i], transform_mismatches=True), TransformMatchingTex(treevector_Tex[i - 1], treevector_Tex[i], transform_mismatches=True), run_time=0.5)\n        self.wait()\n        self.play(FadeOut(my_titles[0]), FadeOut(VTrees[-1]), FadeOut(treevector_Tex[-1]))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate the area and circumference of a circle as its radius increases, showing the graph of the area function and its derivative."}, {"role": "assistant", "content": "from manim import *\nimport numpy as np\n\nclass Area(Scene):\n\n    def construct(self):\n        plane_config = dict(axis_config={'include_tip': True, 'include_numbers': True, 'include_ticks': True, 'line_to_number_buff': 0.05, 'stroke_color': WHITE, 'stroke_width': 0.5, 'number_scale_val': 0.4, 'tip_scale': 0.5}, x_axis_config={'exclude_zero_from_default_numbers': True, 'label_direction': DOWN, 'stroke_color': WHITE, 'x_min': 0, 'x_max': 2, 'unit_size': 1, 'numbers_to_show': range(0, 3, 1)}, y_axis_config={'exclude_zero_from_default_numbers': True, 'label_direction': UR, 'stroke_color': WHITE, 'x_min': 0, 'x_max': 13, 'unit_size': 4 / 13, 'numbers_to_show': range(0, 11, 2)}, background_line_style={'stroke_width': 1, 'stroke_opacity': 0.75, 'stroke_color': GREEN_C})\n        plane = NumberPlane(**plane_config)\n        new_origin = LEFT * 6 + DOWN * 3\n        plane.shift(new_origin)\n        for label in plane.y_axis.numbers:\n            label.rotate(-PI / 2)\n        k = ValueTracker(0)\n        graph = plane.get_graph(lambda x: np.pi * x ** 2, x_min=0, x_max=2, color=PINK)\n        graph_lab = MathTex('A(r)=\\\\pi{r}^{2}').set_width(1).next_to(graph, UR, buff=0.2)\n        deriv = plane.get_graph(lambda x: 2 * np.pi * x)\n        title = Text('\u1780\u17d2\u179a\u17b6\u1794\u1780\u17d2\u179a\u17a1\u17b6\u1795\u17d2\u1791\u17c3', font='Khmer OS Siemreap', color=PINK).scale(0.6).next_to(plane, UP, buff=0.5)\n        und = Underline(title)\n\n        def get_secant_line(x):\n            p1 = plane.input_to_graph_point(x, graph)\n            p2 = plane.input_to_graph_point(x + 0.1, graph)\n            secant = Line(p1, p2, color=RED)\n            secant.scale_in_place(1.5 / secant.get_length())\n            return secant\n\n        def get_horiz_line(x):\n            return DashedLine(plane.coords_to_point(0, graph.underlying_function(x)), plane.coords_to_point(x, graph.underlying_function(x)), color=YELLOW_C)\n\n        def get_dot(x):\n            return Dot().move_to(plane.coords_to_point(x, graph.underlying_function(x)))\n        secant = always_redraw(lambda: get_secant_line(x=k.get_value()))\n        horiz_line = always_redraw(lambda: get_horiz_line(x=k.get_value()))\n        dot = always_redraw(lambda: get_dot(x=k.get_value()))\n        circ = always_redraw(lambda: Circle(fill_color=PINK, fill_opacity=0.5, stroke_color=RED, stroke_width=5, radius=k.get_value()).move_to(RIGHT * 3 + UP * 1.5))\n        radius = Line(circ.get_center(), circ.get_top(), stroke_color=RED)\n        radius.add_updater(lambda x: x.become(Line(circ.get_center(), circ.get_top(), stroke_color=RED)))\n        r_tex = MathTex('r').set_color(RED).next_to(radius, RIGHT, buff=0.1)\n        r_tex.add_updater(lambda x: x.next_to(radius, RIGHT, buff=0.1))\n        area_text = Text('\u1780\u17d2\u179a\u17a1\u17b6\u1795\u17d2\u1791\u17c3 = ', font='Khmer OS Siemreap', color=GREEN_B).scale(0.7).shift(DOWN * 2 + RIGHT)\n        area_value = DecimalNumber(num_decimal_places=3).scale(0.7).next_to(area_text, RIGHT).set_color(GREEN_B, BLUE_C)\n        area_value.add_updater(lambda x: x.set_value(graph.underlying_function(k.get_value())))\n        perim_text = Text('\u1794\u179a\u17b7\u1798\u17b6\u178f\u17d2\u179a = ', font='Khmer OS Siemreap', color=RED).scale(0.7).next_to(area_text, DOWN, buff=0.75)\n        perim_value = DecimalNumber(num_decimal_places=3).scale(0.7).next_to(perim_text, RIGHT).set_color(RED)\n        perim_value.add_updater(lambda x: x.set_value(deriv.underlying_function(k.get_value())))\n        self.play(LaggedStart(Write(plane), Write(title), ShowCreation(und), ShowCreation(graph), Write(graph_lab)), run_time=5, lag_ratio=0.75)\n        self.add(circ)\n        self.play(Write(area_text), Write(perim_text))\n        self.add(area_value, perim_value, secant, horiz_line, circ, radius, r_tex, dot)\n        self.play(k.animate.set_value(2), run_time=10)\n        self.wait()\n        self.play(k.animate.set_value(1.5), run_time=5)\n        self.play(k.animate.set_value(0.5), run_time=5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show integration by parts formula and highlight its terms sequentially using surrounding boxes."}, {"role": "assistant", "content": "from manim import *\n\nclass MovingFrameBox(Scene):\n\n    def construct(self):\n        text = MathTex('\\\\int udv=', 'uv', '-', '\\\\int vdu')\n        self.play(Write(text))\n        framebox1 = SurroundingRectangle(text[1], buff=0.1)\n        framebox2 = SurroundingRectangle(text[3], buff=0.1)\n        self.play(ShowCreation(framebox1))\n        self.wait()\n        self.play(ReplacementTransform(framebox1, framebox2))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display a unit circle with a point orbiting it, drawing a sine wave as the point moves."}, {"role": "assistant", "content": "from manim import *\n\nclass SineCurveUnitCircle(Scene):\n\n    def construct(self):\n        title = Text('\u17a2\u1793\u17bb\u1782\u1798\u1793\u17cd\u179f\u17ca\u17b8\u1793\u17bb\u1799\u179f\u17bc\u17a2\u17ca\u17b8\u178f', font='Khmer M1', color=PINK)\n        VGroup(title).arrange(DOWN)\n        self.play(Write(title))\n        self.wait()\n        transform_title = Text('\u179f\u1798\u17b8\u1780\u17b6\u179a\u179a\u179b\u1780\u179f\u17ca\u17b8\u1793\u17bb\u1799\u179f\u17bc\u17a2\u17bb\u17b8\u178f', font='Kantumruy')\n        transform_title.set_color_by_gradient(BLUE, PURPLE)\n        transform_title.to_corner(UP + LEFT)\n        self.play(Transform(title, transform_title))\n        self.wait()\n        self.show_axis()\n        self.show_circle()\n        self.move_dot_and_draw_curve()\n        self.wait()\n\n    def show_axis(self):\n        x_start = np.array([-6, 0, 0])\n        x_end = np.array([6, 0, 0])\n        y_start = np.array([-4, -2, 0])\n        y_end = np.array([-4, 2, 0])\n        x_axis = Line(x_start, x_end)\n        y_axis = Line(y_start, y_end)\n        self.add(x_axis, y_axis)\n        self.add_x_labels()\n        self.origin_point = np.array([-4, 0, 0])\n        self.curve_start = np.array([-3, 0, 0])\n\n    def add_x_labels(self):\n        x_labels = [MathTex('\\\\pi'), MathTex('2 \\\\pi'), MathTex('3 \\\\pi'), MathTex('4 \\\\pi')]\n        for i in range(len(x_labels)):\n            x_labels[i].next_to(np.array([-1 + 2 * i, 0, 0]), DOWN)\n            self.add(x_labels[i])\n\n    def show_circle(self):\n        circle = Circle(radius=1)\n        circle.move_to(self.origin_point)\n        self.add(circle)\n        self.circle = circle\n\n    def move_dot_and_draw_curve(self):\n        orbit = self.circle\n        origin_point = self.origin_point\n        dot = Dot(radius=0.08, color=YELLOW)\n        dot.move_to(orbit.point_from_proportion(0))\n        self.t_offset = 0\n        rate = 0.25\n\n        def go_around_circle(mob, dt):\n            self.t_offset += dt * rate\n            mob.move_to(orbit.point_from_proportion(self.t_offset % 1))\n\n        def get_line_to_circle():\n            return Line(origin_point, dot.get_center(), color=BLUE)\n\n        def get_line_to_curve():\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            return Line(dot.get_center(), np.array([x, y, 0]), color=YELLOW_A, stroke_width=2)\n        self.curve = VGroup()\n        self.curve.add(Line(self.curve_start, self.curve_start))\n\n        def get_curve():\n            last_line = self.curve[-1]\n            x = self.curve_start[0] + self.t_offset * 4\n            y = dot.get_center()[1]\n            new_line = Line(last_line.get_end(), np.array([x, y, 0]), color=YELLOW_D)\n            self.curve.add(new_line)\n            return self.curve\n        dot.add_updater(go_around_circle)\n        origin_to_circle_line = always_redraw(get_line_to_circle)\n        dot_to_curve_line = always_redraw(get_line_to_curve)\n        sine_curve_line = always_redraw(get_curve)\n        self.add(dot)\n        self.add(orbit, origin_to_circle_line, dot_to_curve_line, sine_curve_line)\n        self.wait(8.5)\n        dot.remove_updater(go_around_circle)"}]}
{"messages": [{"role": "user", "content": "Visualize the motivation behind Manim by showing text about transforming mathematical functions, then apply a matrix transformation to a number plane, and finally transform a complex plane using the function $z \\rightarrow z^2$."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass OpeningManimExample(Scene):\n\n    def construct(self):\n        intro_words = Text('\\n            The original motivation for manim was to\\n            better illustrate mathematical functions\\n            as transformations.\\n        ')\n        intro_words.to_edge(UP)\n        self.play(Write(intro_words))\n        self.wait(2)\n        grid = NumberPlane((-10, 10), (-5, 5))\n        matrix = [[1, 1], [0, 1]]\n        linear_transform_words = VGroup(Text('This is what the matrix'), IntegerMatrix(matrix), Text('looks like'))\n        linear_transform_words.arrange(RIGHT)\n        linear_transform_words.to_edge(UP)\n        linear_transform_words.set_backstroke(width=5)\n        self.play(ShowCreation(grid), FadeTransform(intro_words, linear_transform_words))\n        self.wait()\n        self.play(grid.animate.apply_matrix(matrix), run_time=3)\n        self.wait()\n        c_grid = ComplexPlane()\n        moving_c_grid = c_grid.copy()\n        moving_c_grid.prepare_for_nonlinear_transform()\n        c_grid.set_stroke(BLUE_E, 1)\n        c_grid.add_coordinate_labels(font_size=24)\n        complex_map_words = TexText('\\n            Or thinking of the plane as $\\\\mathds{C}$,\\\\\\\\\\n            this is the map $z \\\\rightarrow z^2$\\n        ')\n        complex_map_words.to_corner(UR)\n        complex_map_words.set_backstroke(width=5)\n        self.play(FadeOut(grid), Write(c_grid, run_time=3), FadeIn(moving_c_grid), FadeTransform(linear_transform_words, complex_map_words))\n        self.wait()\n        self.play(moving_c_grid.animate.apply_complex_function(lambda z: z ** 2), run_time=6)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate a grid of pi symbols by shifting it left, coloring it yellow, applying a gradient, resizing it, and then distorting it with exponential and sine functions."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass AnimatingMethods(Scene):\n\n    def construct(self):\n        grid = Tex('\\\\pi').get_grid(10, 10, height=4)\n        self.add(grid)\n        self.play(grid.animate.shift(LEFT))\n        self.play(grid.animate.set_color(YELLOW))\n        self.wait()\n        self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))\n        self.wait()\n        self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))\n        self.wait()\n        self.play(grid.animate.apply_complex_function(np.exp), run_time=5)\n        self.wait()\n        self.play(grid.animate.apply_function(lambda p: [p[0] + 0.5 * math.sin(p[1]), p[1] + 0.5 * math.sin(p[0]), p[2]]), run_time=5)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Display text demonstrating different font, color, slant, and weight customizations."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass TextExample(Scene):\n\n    def construct(self):\n        text = Text('Here is a text', font='Consolas', font_size=90)\n        difference = Text(\"\\n            The most important difference between Text and TexText is that\\n\\n            you can change the font more easily, but can't use the LaTeX grammar\\n            \", font='Arial', font_size=24, t2c={'Text': BLUE, 'TexText': BLUE, 'LaTeX': ORANGE})\n        VGroup(text, difference).arrange(DOWN, buff=1)\n        self.play(Write(text))\n        self.play(FadeIn(difference, UP))\n        self.wait(3)\n        fonts = Text('And you can also set the font according to different words', font='Arial', t2f={'font': 'Consolas', 'words': 'Consolas'}, t2c={'font': BLUE, 'words': GREEN})\n        fonts.set_width(FRAME_WIDTH - 1)\n        slant = Text('And the same as slant and weight', font='Consolas', t2s={'slant': ITALIC}, t2w={'weight': BOLD}, t2c={'slant': ORANGE, 'weight': RED})\n        VGroup(fonts, slant).arrange(DOWN, buff=0.8)\n        self.play(FadeOut(text), FadeOut(difference, shift=DOWN))\n        self.play(Write(fonts))\n        self.wait()\n        self.play(Write(slant))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Demonstrate algebraic manipulation of an equation with color coding for variables and animate transformations between related equations, followed by transformations between text strings."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass TexTransformExample(Scene):\n\n    def construct(self):\n        t2c = {'A': BLUE, 'B': TEAL, 'C': GREEN}\n        kw = dict(font_size=72, t2c=t2c)\n        lines = VGroup(Tex('A^2 + B^2 = C^2', **kw), Tex('A^2 = C^2 - B^2', **kw), Tex('A^2 = (C + B)(C - B)', **kw), Tex('A = \\\\sqrt{(C + B)(C - B)}', **kw))\n        lines.arrange(DOWN, buff=LARGE_BUFF)\n        self.add(lines[0])\n        self.play(TransformMatchingStrings(lines[0].copy(), lines[1], matched_keys=['A^2', 'B^2', 'C^2'], key_map={'+': '-'}, path_arc=90 * DEGREES))\n        self.wait()\n        self.play(TransformMatchingStrings(lines[1].copy(), lines[2], matched_keys=['A^2']))\n        self.wait()\n        self.play(TransformMatchingStrings(lines[2].copy(), lines[3], key_map={'2': '\\\\sqrt'}, path_arc=-30 * DEGREES))\n        self.wait(2)\n        self.play(LaggedStartMap(FadeOut, lines, shift=2 * RIGHT))\n        source = Text('the morse code', height=1)\n        target = Text('here come dots', height=1)\n        saved_source = source.copy()\n        self.play(Write(source))\n        self.wait()\n        kw = dict(run_time=3, path_arc=PI / 2)\n        self.play(TransformMatchingShapes(source, target, **kw))\n        self.wait()\n        self.play(TransformMatchingShapes(target, saved_source, **kw))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Show various mathematical equations, highlighting specific parts and transforming text elements to demonstrate Manim's text manipulation capabilities."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass TexIndexing(Scene):\n\n    def construct(self):\n        equation = Tex('e^{\\\\pi i} = -1', font_size=144)\n        self.add(equation)\n        self.play(FlashAround(equation['e']))\n        self.wait()\n        self.play(Indicate(equation['\\\\pi']))\n        self.wait()\n        self.play(TransformFromCopy(equation['e^{\\\\pi i}'].copy().set_opacity(0.5), equation['-1'], path_arc=-PI / 2, run_time=3))\n        self.play(FadeOut(equation))\n        equation = Tex('A^2 + B^2 = C^2', font_size=144)\n        self.play(Write(equation))\n        for part in equation[re.compile('\\\\w\\\\^2')]:\n            self.play(FlashAround(part))\n        self.wait()\n        self.play(FadeOut(equation))\n        equation = Tex('\\\\sum_{n = 1}^\\\\infty \\\\frac{1}{n^2} = \\\\frac{\\\\pi^2}{6}', font_size=72)\n        self.play(FadeIn(equation))\n        self.play(equation['\\\\infty'].animate.set_color(RED))\n        self.wait()\n        self.play(FadeOut(equation))\n        equation = Tex('\\\\sum_{n = 1}^\\\\infty {1 \\\\over n^2} = {\\\\pi^2 \\\\over 6}', isolate=['\\\\infty'], font_size=72)\n        self.play(FadeIn(equation))\n        self.play(equation['\\\\infty'].animate.set_color(RED))\n        self.wait()\n        self.play(FadeOut(equation))"}]}
{"messages": [{"role": "user", "content": "Animate a square whose width is continuously displayed and updated as it scales and changes width, including a pulsating effect based on a sine wave."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass UpdatersExample(Scene):\n\n    def construct(self):\n        square = Square()\n        square.set_fill(BLUE_E, 1)\n        brace = always_redraw(Brace, square, UP)\n        label = TexText('Width = 0.00')\n        number = label.make_number_changable('0.00')\n        label.always.next_to(brace, UP)\n        number.f_always.set_value(square.get_width)\n        self.add(square, brace, label)\n        self.play(square.animate.scale(2), rate_func=there_and_back, run_time=2)\n        self.wait()\n        self.play(square.animate.set_width(5, stretch=True), run_time=3)\n        self.wait()\n        self.play(square.animate.set_width(2), run_time=3)\n        self.wait()\n        now = self.time\n        w0 = square.get_width()\n        square.add_updater(lambda m: m.set_width(w0 * math.sin(self.time - now) + w0))\n        self.wait(4 * PI)"}]}
{"messages": [{"role": "user", "content": "Display a coordinate system with a dot that moves to specified points, accompanied by redrawing horizontal and vertical lines, and then scale and fade out the system."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass CoordinateSystemExample(Scene):\n\n    def construct(self):\n        axes = Axes(x_range=(-1, 10), y_range=(-2, 2, 0.5), height=6, width=10, axis_config=dict(stroke_color=GREY_A, stroke_width=2, numbers_to_exclude=[0]), y_axis_config=dict(big_tick_numbers=[-2, 2]))\n        axes.add_coordinate_labels(font_size=20, num_decimal_places=1)\n        self.add(axes)\n        dot = Dot(color=RED)\n        dot.move_to(axes.c2p(0, 0))\n        self.play(FadeIn(dot, scale=0.5))\n        self.play(dot.animate.move_to(axes.c2p(3, 2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(5, 0.5)))\n        self.wait()\n        h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))\n        v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))\n        self.play(ShowCreation(h_line), ShowCreation(v_line))\n        self.play(dot.animate.move_to(axes.c2p(3, -2)))\n        self.wait()\n        self.play(dot.animate.move_to(axes.c2p(1, 1)))\n        self.wait()\n        f_always(dot.move_to, lambda: axes.c2p(1, 1))\n        self.play(axes.animate.scale(0.75).to_corner(UL), run_time=2)\n        self.wait()\n        self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))"}]}
{"messages": [{"role": "user", "content": "Animate the display of coordinate axes, followed by the sequential animation of sine, ReLU, and step function graphs, and conclude with a moving dot on a parabola."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass GraphExample(Scene):\n\n    def construct(self):\n        axes = Axes((-3, 10), (-1, 8), height=6)\n        axes.add_coordinate_labels()\n        self.play(Write(axes, lag_ratio=0.01, run_time=1))\n        sin_graph = axes.get_graph(lambda x: 2 * math.sin(x), color=BLUE)\n        relu_graph = axes.get_graph(lambda x: max(x, 0), use_smoothing=False, color=YELLOW)\n        step_graph = axes.get_graph(lambda x: 2.0 if x > 3 else 1.0, discontinuities=[3], color=GREEN)\n        sin_label = axes.get_graph_label(sin_graph, '\\\\sin(x)')\n        relu_label = axes.get_graph_label(relu_graph, Text('ReLU'))\n        step_label = axes.get_graph_label(step_graph, Text('Step'), x=4)\n        self.play(ShowCreation(sin_graph), FadeIn(sin_label, RIGHT))\n        self.wait(2)\n        self.play(ReplacementTransform(sin_graph, relu_graph), FadeTransform(sin_label, relu_label))\n        self.wait()\n        self.play(ReplacementTransform(relu_graph, step_graph), FadeTransform(relu_label, step_label))\n        self.wait()\n        parabola = axes.get_graph(lambda x: 0.25 * x ** 2)\n        parabola.set_stroke(BLUE)\n        self.play(FadeOut(step_graph), FadeOut(step_label), ShowCreation(parabola))\n        self.wait()\n        dot = Dot(color=RED)\n        dot.move_to(axes.i2gp(2, parabola))\n        self.play(FadeIn(dot, scale=0.5))\n        x_tracker = ValueTracker(2)\n        f_always(dot.move_to, lambda: axes.i2gp(x_tracker.get_value(), parabola))\n        self.play(x_tracker.animate.set_value(4), run_time=3)\n        self.play(x_tracker.animate.set_value(-2), run_time=3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Create an animation showing a circle on a coordinate plane, with its radius changing and a related equation updating, followed by a transformation to an implicit function."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass TexAndNumbersExample(Scene):\n\n    def construct(self):\n        axes = Axes((-3, 3), (-3, 3), unit_size=1)\n        axes.to_edge(DOWN)\n        axes.add_coordinate_labels(font_size=16)\n        circle = Circle(radius=2)\n        circle.set_stroke(YELLOW, 3)\n        circle.move_to(axes.get_origin())\n        self.add(axes, circle)\n        tex = Tex('x^2 + y^2 = 4.00')\n        tex.next_to(axes, UP, buff=0.5)\n        value = tex.make_number_changable('4.00')\n        value.add_updater(lambda v: v.set_value(circle.get_radius() ** 2))\n        self.add(tex)\n        text = Text('\\n            You can manipulate numbers\\n            in Tex mobjects\\n        ', font_size=30)\n        text.next_to(tex, RIGHT, buff=1.5)\n        arrow = Arrow(text, tex)\n        self.add(text, arrow)\n        self.play(circle.animate.set_height(2.0), run_time=4, rate_func=there_and_back)\n        exponents = tex.make_number_changable('2', replace_all=True)\n        self.play(LaggedStartMap(FlashAround, exponents, lag_ratio=0.2, buff=0.1, color=RED), exponents.animate.set_color(RED))\n\n        def func(x, y):\n            xa, ya = axes.point_to_coords(np.array([x, y, 0]))\n            return xa ** 4 + ya ** 4 - 4\n        new_curve = ImplicitFunction(func)\n        new_curve.match_style(circle)\n        circle.rotate(angle_of_vector(new_curve.get_start()))\n        value.clear_updaters()\n        self.play(*(ChangeDecimalToValue(exp, 4) for exp in exponents), ReplacementTransform(circle.copy(), new_curve), circle.animate.set_stroke(width=1, opacity=0.5))"}]}
{"messages": [{"role": "user", "content": "Animate textured 3D surfaces like a sphere and tori, demonstrating camera rotation and light source movement."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass SurfaceExample(ThreeDScene):\n\n    def construct(self):\n        surface_text = Text('For 3d scenes, try using surfaces')\n        surface_text.fix_in_frame()\n        surface_text.to_edge(UP)\n        self.add(surface_text)\n        self.wait(0.1)\n        torus1 = Torus(r1=1, r2=1)\n        torus2 = Torus(r1=3, r2=1)\n        sphere = Sphere(radius=3, resolution=torus1.resolution)\n        day_texture = 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg'\n        night_texture = 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg'\n        surfaces = [TexturedSurface(surface, day_texture, night_texture) for surface in [sphere, torus1, torus2]]\n        for mob in surfaces:\n            mob.shift(IN)\n            mob.mesh = SurfaceMesh(mob)\n            mob.mesh.set_stroke(BLUE, 1, opacity=0.5)\n        surface = surfaces[0]\n        self.play(FadeIn(surface), ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3))\n        for mob in surfaces:\n            mob.add(mob.mesh)\n        surface.save_state()\n        self.play(Rotate(surface, PI / 2), run_time=2)\n        for mob in surfaces[1:]:\n            mob.rotate(PI / 2)\n        self.play(Transform(surface, surfaces[1]), run_time=3)\n        self.play(Transform(surface, surfaces[2]), self.frame.animate.increment_phi(-10 * DEGREES), self.frame.animate.increment_theta(-20 * DEGREES), run_time=3)\n        self.frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))\n        light_text = Text('You can move around the light source')\n        light_text.move_to(surface_text)\n        light_text.fix_in_frame()\n        self.play(FadeTransform(surface_text, light_text))\n        light = self.camera.light_source\n        self.add(light)\n        light.save_state()\n        self.play(light.animate.move_to(3 * IN), run_time=5)\n        self.play(light.animate.shift(10 * OUT), run_time=5)\n        drag_text = Text('Try moving the mouse while pressing d or f')\n        drag_text.move_to(light_text)\n        drag_text.fix_in_frame()\n        self.play(FadeTransform(light_text, drag_text))\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a square transforming into a filled blue circle, which then stretches, rotates, shrinks, moves right, and finally has text appear while remaining tethered to the mouse pointer."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass InteractiveDevelopment(Scene):\n\n    def construct(self):\n        circle = Circle()\n        circle.set_fill(BLUE, opacity=0.5)\n        circle.set_stroke(BLUE_E, width=4)\n        square = Square()\n        self.play(ShowCreation(square))\n        self.wait()\n        self.embed()\n        self.play(ReplacementTransform(square, circle))\n        self.wait()\n        self.play(circle.animate.stretch(4, 0))\n        self.play(Rotate(circle, 90 * DEGREES))\n        self.play(circle.animate.shift(2 * RIGHT).scale(0.25))\n        text = Text('\\n            In general, using the interactive shell\\n            is very helpful when developing new scenes\\n        ')\n        self.play(Write(text))\n        always(circle.move_to, self.mouse_point)"}]}
{"messages": [{"role": "user", "content": "Create an interactive scene where a textbox, checkbox, and color picker control the appearance of displayed text."}, {"role": "assistant", "content": "from manimx import *\nimport numpy as np\n\nclass ControlsExample(Scene):\n    drag_to_pan = False\n\n    def setup(self):\n        self.textbox = Textbox()\n        self.checkbox = Checkbox()\n        self.color_picker = ColorSliders()\n        self.panel = ControlPanel(Text('Text', font_size=24), self.textbox, Line(), Text('Show/Hide Text', font_size=24), self.checkbox, Line(), Text('Color of Text', font_size=24), self.color_picker)\n        self.add(self.panel)\n\n    def construct(self):\n        text = Text('text', font_size=96)\n\n        def text_updater(old_text):\n            assert isinstance(old_text, Text)\n            new_text = Text(self.textbox.get_value(), font_size=old_text.font_size)\n            new_text.move_to(old_text)\n            if self.checkbox.get_value():\n                new_text.set_fill(color=self.color_picker.get_picked_color(), opacity=self.color_picker.get_picked_opacity())\n            else:\n                new_text.set_opacity(0)\n            old_text.become(new_text)\n        text.add_updater(text_updater)\n        self.add(MotionMobject(text))\n        self.textbox.set_value('Manim')"}]}
{"messages": [{"role": "user", "content": "Create an empty Manim scene with interactive debugging enabled."}, {"role": "assistant", "content": "from manim.utils.color.XKCD import LIMEGREEN\nimport numpy as np\nfrom manim import *\nfrom manim.opengl import *\nfrom manim_slides.slide import Slide\n\nclass EmptyScene(Scene):\n\n    def construct(self):\n        self.interactive_embed()"}]}
{"messages": [{"role": "user", "content": "Display a transition matrix with its title and hold for five seconds."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom colors import CYAN\n\nclass HiScene(Scene):\n\n    def construct(self):\n        m4 = Matrix([[1, 0, 0, 0, 1], [1, 1, 0, 0, 0], [0, 1, 1, 0, 0], [0, 0, 1, 1, 0], [0, 0, 0, 1, 1]], h_buff=0.8)\n        mt = Text('Transition Matrix').move_to(m4).shift(DOWN * 2.8)\n        self.play(FadeIn(m4), FadeIn(mt), run_time=2)\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Generate a Manim animation demonstrating the Erd\u0151s-R\u00e9nyi random graph model by drawing a graph, highlighting two random vertices, adding and removing a random edge, and finally displaying the graph definition."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\nfrom Utils.colors import SAT_GREEN\n\nclass RandomSmallGraph(Scene):\n\n    def construct(self):\n\n        def rf(x):\n            if x < 0.5:\n                return 16 * x ** 5\n            return 1 - pow(-2 * x + 2, 5) / 2\n        self.vertices = []\n        N = 10\n        for i in range(N):\n            self.vertices.append(i)\n        g = Graph(vertices=self.vertices, edges=[], vertex_config={'radius': 0.1, 'color': SAT_GREEN}, layout='spring', layout_config={'iterations': 10}, edge_config={'stroke_width': 2, 'stroke_opacity': 0.9})\n        self.play(DrawBorderThenFill(g))\n        self.wait(3)\n        u = randint(1, N) - 1\n        v = randint(1, N) - 1\n        uc = Circle(radius=0.2, color=None, stroke_width=3, stroke_color=SAT_GREEN).move_to(g.vertices[self.vertices[u]])\n        vc = Circle(radius=0.2, color=None, stroke_width=3, stroke_color=SAT_GREEN).move_to(g.vertices[self.vertices[v]])\n        self.play(*list(map(DrawBorderThenFill, [uc, vc])))\n        g._add_edge((self.vertices[u], self.vertices[v]))\n        self.wait(1)\n        g._remove_edge((self.vertices[u], self.vertices[v]))\n        self.play(*list(map(FadeOut, [uc, vc])))\n        for i in range(N):\n            for j in range(i + 1, N):\n                r = randint(1, 100)\n                if r <= 35:\n                    g._add_edge((self.vertices[i], self.vertices[j]))\n        er = Text('Erd\u0151s-R\u00e9nyi model', color=SAT_GREEN).shift(DOWN * 2)\n        self.play(g.animate.shift(UP), FadeIn(er, shift=UP / 2), rate_func=rf)\n        self.wait(4)\n        g_def = MathTex('G_{n, p}').scale(1.7).shift(DOWN * 2)\n        self.play(FadeOut(er, shift=UP / 2), FadeIn(g_def, shift=UP / 2), rate_func=rf)\n        self.wait(4)\n        return"}]}
{"messages": [{"role": "user", "content": "Generate a random graph with 150 vertices and a few edges, then zoom out to view the entire graph."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\n\nclass RandomBigGraph(MovingCameraScene):\n\n    def construct(self):\n        self.vertices = []\n        N = 150\n        for i in range(N):\n            self.vertices.append(i)\n        g = Graph(vertices=self.vertices, edges=[], vertex_config={'radius': 0.1, 'color': GREEN}, layout='random', layout_scale=10, edge_config={'stroke_width': 2, 'stroke_opacity': 0.7})\n        for i in range(N):\n            for j in range(i + 1, N):\n                r = randint(1, 100)\n                if r <= 4:\n                    g._add_edge((self.vertices[i], self.vertices[j]))\n        self.play(DrawBorderThenFill(g))\n        self.play(self.camera.frame.animate.scale(1.5), run_time=4)\n        self.wait(4)\n        return"}]}
{"messages": [{"role": "user", "content": "Render an SVG room, then display people as nodes in a circular graph and animate the drawing of all edges between the nodes with a custom easing function."}, {"role": "assistant", "content": "from manim import *\nfrom Utils.colors import SAT_RED\n\nclass RoomScene(Scene):\n\n    def construct(self):\n\n        def rf(x):\n            if x < 0.5:\n                return 16 * x ** 5\n            return 1 - pow(-2 * x + 2, 5) / 2\n        room = SVGMobject('./MaxClique/Room.svg', height=5.4, stroke_width=6)\n        self.play(DrawBorderThenFill(room))\n        self.wait(2)\n        N = 8\n        self.vertices = []\n        for i in range(N):\n            self.vertices.append(i)\n        images: ImageMobject = []\n        for i in range(N):\n            images.append(ImageMobject('./Utils/people/' + str(i % 6 + 1) + '.png').scale(0.25))\n        g = Graph(vertices=self.vertices, edges=[], layout='circular', vertex_config={'radius': 0.2}, edge_config={'stroke_width': 4})\n        for i in range(N):\n            images[i].move_to(g.vertices[self.vertices[i]])\n        self.play(*list(map(FadeIn, images)))\n        self.wait(2)\n        g.z_index = -10\n        for i in range(N):\n            g.vertices[self.vertices[i]].z_index = -10\n        self.play(DrawBorderThenFill(g))\n        for i in range(len(self.vertices)):\n            mobjects = []\n            for j in range(i + 1, len(self.vertices)):\n                mobjects.append(g._add_edge((self.vertices[i], self.vertices[j])))\n            self.play(AnimationGroup(*(DrawBorderThenFill(m, rate_func=rf) for m in mobjects)), run_time=0.5)\n        self.wait(5)\n        return"}]}
{"messages": [{"role": "user", "content": "Animate the formula for the maximum clique size of a random graph, transitioning between different representations of the formula with a custom easing function."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\nfrom Utils.colors import SAT_GREEN\n\nclass Theorem(Scene):\n\n    def construct(self):\n\n        def rf(x):\n            if x < 0.5:\n                return 16 * x ** 5\n            return 1 - pow(-2 * x + 2, 5) / 2\n        g_def = MathTex('G_{n, p}').scale(1.7)\n        self.play(FadeIn(g_def, shift=UP / 2), rate_func=rf)\n        self.wait(2)\n        mxclique = MathTex('|\\\\textrm{maxclique}(G_{n, \\\\frac{1}{2}})|')\n        self.play(FadeOut(g_def, shift=UP / 2), FadeIn(mxclique, shift=UP / 2), rate_func=rf)\n        self.wait(3)\n        mxclique2 = MathTex('|\\\\textrm{maxclique}(G_{n, \\\\frac{1}{2}})| \\\\approx 2 \\\\cdot (1 \\\\pm \\\\mathcal{O}(1)) \\\\cdot \\\\log_2(n)')\n        self.play(FadeOut(mxclique, shift=UP / 2), FadeIn(mxclique2, shift=UP / 2), rate_func=rf)\n        self.wait(4)\n        return"}]}
{"messages": [{"role": "user", "content": "Display an approximation of 2 * log base 2 of 8 * 10^9 with a clarifying note."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\nfrom Utils.colors import SAT_GREEN\n\nclass Theorem(Scene):\n\n    def construct(self):\n\n        def rf(x):\n            if x < 0.5:\n                return 16 * x ** 5\n            return 1 - pow(-2 * x + 2, 5) / 2\n        g_def = MathTex('2 \\\\cdot \\\\log_2(8 \\\\cdot 10^9) \\\\approx 65').scale(1.2)\n        acc = Text('* to be more accurate').scale(0.3).shift(DOWN * 0.6 + RIGHT * 1.3)\n        self.play(FadeIn(g_def, shift=UP / 2), FadeIn(acc, shift=UP / 2), rate_func=rf)\n        self.wait(2)\n        return"}]}
{"messages": [{"role": "user", "content": "Visualize a sequence of blue circles and divide them into sections with lines, then highlight a specific range of circles in red."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\n\nclass BlockComparison(Scene):\n\n    def construct(self):\n\n        def rf(x):\n            if x < 0.5:\n                return 16 * x * x * x * x * x\n            return 1 - pow(-2 * x + 2, 5) / 2\n        N = 40\n        start = LEFT * 6\n        circles = []\n        ratio = 0.3\n\n        def get_center(i):\n            return start + RIGHT * i * ratio\n        for i in range(N):\n            c = Circle(0.05, color=BLUE, fill_color=BLUE, fill_opacity=1)\n            c.shift(get_center(i))\n            circles.append(c)\n            self.play(DrawBorderThenFill(c), run_time=0.05)\n        tN = MathTex(f'N = {N}').shift(UP * 2 + LEFT * 2.5)\n        self.play(Write(tN))\n        B = 20\n        tB = MathTex(f'B = {B}').shift(UP * 1.4 + LEFT * 2.5)\n        self.play(Write(tB))\n        dividers = []\n        for i in range(B - 1):\n            c1 = get_center((i + 1) * (N // B) - 1)\n            c2 = get_center((i + 1) * (N // B))\n            c = (c1 + c2) / 2\n            l = Line(c + DOWN * 0.5, c + UP * 0.5)\n            self.play(Create(l), run_time=0.1)\n            dividers.append(l)\n        self.wait(4)\n\n        def indicate(r):\n            c1 = get_center(r[0]) + DOWN * 0.3\n            c2 = get_center(r[1] + 1) + DOWN * 0.3\n            l = Line(c1, c2, stroke_width=2)\n            animations = [Create(l)]\n            for i in range(r[0], r[1] + 2):\n                animations.append(circles[i].animate.set_fill(RED))\n                animations.append(circles[i].animate.set_color(RED))\n            self.play(AnimationGroup(*animations))\n            self.wait(4)\n        indicate([8, 31])\n        self.wait(5)\n        self.play(FadeOut(tN), FadeOut(tB))\n        return"}]}
{"messages": [{"role": "user", "content": "Draw a series of blue circles, display the number of circles and a grouping parameter, then draw vertical lines to divide the circles into groups, and finally highlight a specific range of circles in red."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\n\nclass BlockComparison2(Scene):\n\n    def construct(self):\n\n        def rf(x):\n            if x < 0.5:\n                return 16 * x * x * x * x * x\n            return 1 - pow(-2 * x + 2, 5) / 2\n        N = 40\n        start = LEFT * 6\n        circles = []\n        ratio = 0.3\n\n        def get_center(i):\n            return start + RIGHT * i * ratio\n        for i in range(N):\n            c = Circle(0.05, color=BLUE, fill_color=BLUE, fill_opacity=1)\n            c.shift(get_center(i))\n            circles.append(c)\n            self.play(DrawBorderThenFill(c), run_time=0.05)\n        tN = MathTex(f'N = {N}').shift(UP * 2 + LEFT * 2.5)\n        self.play(Write(tN))\n        B = 2\n        tB = MathTex(f'B = {B}').shift(UP * 1.4 + LEFT * 2.5)\n        self.play(Write(tB))\n        dividers = []\n        for i in range(B - 1):\n            c1 = get_center((i + 1) * (N // B) - 1)\n            c2 = get_center((i + 1) * (N // B))\n            c = (c1 + c2) / 2\n            l = Line(c + DOWN * 0.5, c + UP * 0.5)\n            self.play(Create(l), run_time=0.1)\n            dividers.append(l)\n        self.wait(4)\n\n        def indicate(r):\n            c1 = get_center(r[0]) + DOWN * 0.3\n            c2 = get_center(r[1] + 1) + DOWN * 0.3\n            l = Line(c1, c2, stroke_width=2)\n            animations = [Create(l)]\n            for i in range(r[0], r[1] + 2):\n                animations.append(circles[i].animate.set_fill(RED))\n                animations.append(circles[i].animate.set_color(RED))\n            self.play(AnimationGroup(*animations))\n            self.wait(4)\n        indicate([8, 26])\n        self.wait(5)\n        self.play(FadeOut(tN), FadeOut(tB))\n        return"}]}
{"messages": [{"role": "user", "content": "Display a number line with labeled points, overlay images on those points, introduce a \"destination\" graphic, and then animate a sum calculation with corresponding images."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\n\nclass AddSum(Scene):\n\n    def construct(self):\n        number_line = NumberLine(x_range=[0, 10, 1], length=10, color=BLUE, include_tip=True, include_numbers=True, label_direction=DOWN)\n        numbers = [1, 1.5, 2, 4, 5.6, 7]\n        dict_numbers = dict()\n        for num in numbers:\n            dict_numbers[float(num)] = Tex(str(num))\n        labels = number_line.add_labels(dict_numbers, direction=UP, buff=None, font_size=None, label_constructor=None)\n        self.play(DrawBorderThenFill(labels), run_time=0.2)\n        number_line.add_ticks()\n        for i in range(len(numbers)):\n            new_dot = number_line.ticks.add(Dot().move_to(labels.number_to_point(numbers[i])))\n        self.play(DrawBorderThenFill(new_dot), run_time=0.2)\n        images: List[ImageMobject] = []\n        for i in range(len(numbers)):\n            images.append(ImageMobject('./people/' + str(i + 1) + '.png').scale(0.15).move_to(labels.number_to_point(numbers[i])).shift(UP))\n        for image in images:\n            self.play(FadeIn(image), run_time=0.1)\n        destination = Dot(fill_color=RED)\n        arrow_destination = Arrow(start=ORIGIN, end=UP / 4, stroke_color=RED, max_stroke_width_to_length_ratio=10).shift(DOWN)\n        label_destination = Tex('destination', font_size=24, fill_color=RED).move_to(arrow_destination, DOWN).shift(DOWN * 0.3)\n        self.play(DrawBorderThenFill(destination), run_time=0.2)\n        self.play(*list(map(DrawBorderThenFill, [arrow_destination, label_destination])), run_time=0.2)\n        destination_group = VGroup()\n        destination_group.add(destination, arrow_destination, label_destination)\n        self.play(destination_group.animate.shift(LEFT * 2), run_time=0.5)\n        self.wait(2)\n        sum_string = ''\n        for i in range(len(numbers)):\n            if i == len(numbers) - 1:\n                sum_string += '\\\\lvert ' + str(numbers[i]) + ' - 3 \\\\rvert'\n            else:\n                sum_string += '\\\\lvert ' + str(numbers[i]) + ' - 3 \\\\rvert + '\n        str_numbers = ['1', '.5', '2', '4', '5.6', '7']\n        sum = MathTex(sum_string + ' = 12.1', substrings_to_isolate=str_numbers).shift(DOWN * 2).scale(0.8)\n        self.play(DrawBorderThenFill(sum))\n        self.wait(2)\n        new_images: List[ImageMobject] = []\n        for i in range(6):\n            new_images.append(ImageMobject('./people/' + str(i + 1) + '.png').scale(0.15).move_to(sum.get_part_by_tex(str_numbers[i])).shift(DOWN / 2))\n        self.play(*list(map(FadeIn, new_images)), run_time=2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize a binary tree structure with specific nodes and edges, animating its creation and growth."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\n\nclass Tree(Scene):\n\n    def construct(self):\n        N = 32\n        nodes = [i for i in range(1, N + 1)]\n        edges = [(1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (3, 7), (3, 8), (4, 9), (4, 10), (4, 11), (5, 12), (5, 13), (5, 14), (6, 15), (8, 16), (9, 17), (12, 18), (12, 19), (13, 20), (16, 21), (16, 22), (17, 23), (17, 24), (19, 25), (19, 26), (21, 27), (21, 28), (22, 29), (23, 30), (24, 31), (24, 32)]\n        animate(self, N, nodes, edges, [[27, 29], [19, 24]], 0.3, [1, 1], 20)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Generate a branching tree animation with specific node and edge configurations."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\n\nclass TreeLong(Scene):\n\n    def construct(self):\n        N = 30\n        nodes = [i for i in range(1, N + 1)]\n        edges = []\n        K = 8\n        M = 20\n        for i in range(2, K):\n            edges.append((i - 1, i))\n        edges.append((K - 1, K))\n        edges.append((K - 1, M))\n        for i in range(K + 1, M):\n            edges.append((i - 1, i))\n        for i in range(M + 1, N + 1):\n            edges.append((i - 1, i))\n        animate(self, N, nodes, edges, [[M - 2, N]], 0.1, [0.3, 0.3], 10, timing=0.2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Visualize a tree structure with specific nodes highlighted in red and connected by animated blue circles."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\n\nclass TreeBigLayer(Scene):\n\n    def construct(self):\n        N = 32\n        nodes = [i for i in range(1, N + 1)]\n        edges = [(1, 2), (1, 3), (1, 4), (2, 5), (2, 6), (3, 7), (3, 8), (4, 9), (4, 10), (4, 11), (5, 12), (5, 13), (5, 14), (6, 15), (8, 16), (9, 17), (12, 18), (12, 19), (13, 20), (16, 21), (16, 22), (17, 23), (17, 24), (19, 25), (19, 26), (21, 27), (21, 28), (22, 29), (23, 30), (24, 31), (24, 32)]\n        g, values, vals = animate(self, N, nodes, edges, [], 0.3, [1, 1], 20)\n        levels = [[] for _ in range(10)]\n        root = 1\n\n        def dfs(i, level):\n            levels[level].append(i)\n            for edge in edges:\n                if edge[0] == i:\n                    dfs(edge[1], level + 1)\n        dfs(root, 0)\n        for l in levels:\n            l.reverse()\n        for u in levels[2]:\n            self.play(g.vertices[u].animate.set_fill(color=RED), run_time=0.5)\n        self.wait(2)\n        for i in range(len(levels[2])):\n            for j in range(i + 1, len(levels[2])):\n                ci = Circle(0.4, color=BLUE).move_to(g.vertices[levels[2][i]])\n                cj = Circle(0.4, color=BLUE).move_to(g.vertices[levels[2][j]])\n                self.play(*[DrawBorderThenFill(ci), DrawBorderThenFill(cj)], run_time=0.1)\n                self.wait(0.1)\n                self.play(*[FadeOut(ci), FadeOut(cj)], run_time=0.1)"}]}
{"messages": [{"role": "user", "content": "Animate the creation of a random tree structure with nodes colored sequentially by level."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\n\nclass TreeRandom(Scene):\n\n    def construct(self):\n        N = 50\n        nodes = [i for i in range(1, N + 1)]\n        edges = []\n\n        def w(m, iter):\n            r = randint(1, m - 1)\n            for _ in range(iter):\n                r = max(r, randint(1, m - 1))\n            return r\n        for i in range(2, N + 1):\n            edges.append((w(i, 2), i))\n        g, values, vals = animate(self, N, nodes, edges, [], 0.2, [0.5, 0.6], 14, timing=0.2)\n        self.wait(2)\n        L = 20\n        levels = [[] for _ in range(L)]\n        root = 1\n\n        def dfs(i, level):\n            levels[level].append(i)\n            for edge in edges:\n                if edge[0] == i:\n                    dfs(edge[1], level + 1)\n        dfs(root, 0)\n        colors = ['#1de051', '#0eecf0', '#f09956', '#56f0cf', '#0eecf0']\n        c = 0\n        cc = 0\n        for i in range(L):\n            if len(levels[i]) == 0:\n                break\n            if c == 2:\n                c = 0\n                cc += 1\n            for nn in range(len(levels[i])):\n                node = levels[i][nn]\n                self.play(g.vertices[node].animate.set_color(color=colors[cc % len(colors)]), run_time=0.1)\n            c += 1"}]}
{"messages": [{"role": "user", "content": "Visualize an array of numbers within circles, highlight a specific range with a line, and then add dividers to group elements."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\n\nclass SQRT_Array(Scene):\n\n    def construct(self):\n        N = 15\n        A = [randint(1, 20) for _ in range(N)]\n        A[6] = 2\n        A[7] = 2\n        A[8] = 6\n\n        def rf(x):\n            if x < 0.5:\n                return 16 * x * x * x * x * x\n            return 1 - pow(-2 * x + 2, 5) / 2\n        array = []\n        array_int = []\n        start = LEFT * 12\n        ratio = 2\n        padding = RIGHT * 0.15\n        coeff = RIGHT * 1.6\n\n        def get_center(i):\n            m1 = (start + i * coeff + padding) / ratio\n            m2 = (start + (i + 1) * coeff - padding) / ratio\n            return (m2 + m1) / 2\n        for i in range(N):\n            center = get_center(i)\n            c = Circle(0.28, color=BLUE, stroke_width=2)\n            c.move_to(center)\n            array.append(c)\n            array_int.append(Text(f'{A[i]}', font_size=22).move_to(center))\n        for i in range(N):\n            self.play(Write(array_int[i]), Create(array[i]), run_time=0.6)\n        self.wait(3)\n        RANGE = [4, 10]\n        range_line = Line(get_center(RANGE[0]) + LEFT * 0.4, get_center(RANGE[1]) + RIGHT * 0.4).shift(DOWN * 0.5)\n        self.play(Create(range_line))\n\n        def indicate(RANGE):\n            for i in range(RANGE[0], RANGE[1] + 1):\n                self.play(array[i].animate.set_fill(RED, opacity=0.5), run_time=0.3, rate_func=rf)\n            self.wait(5)\n            for i in range(RANGE[0], RANGE[1] + 1):\n                self.play(array[i].animate.set_fill(RED, opacity=0), run_time=0.1, rate_func=rf)\n            self.wait(5)\n        indicate([4, 10])\n        dividers = []\n        for i in range(4):\n            between = (get_center(i * 3 + 2) + get_center(i * 3 + 3)) / 2\n            l = Line(between + UP, between + DOWN, stroke_width=1)\n            dividers.append(l)\n            self.play(Create(l), run_time=0.6, rate_func=rf)\n        self.wait(3)\n        indicate([6, 8])\n        return"}]}
{"messages": [{"role": "user", "content": "Animate a number line with labeled points, add dots and images to these points, then animate a destination marker, and finally move all the images to the destination."}, {"role": "assistant", "content": "from manim import *\nfrom matplotlib.pyplot import arrow\n\nclass GoToPoint(Scene):\n\n    def construct(self):\n        number_line = NumberLine(x_range=[0, 10, 1], length=10, color=BLUE, include_tip=True, include_numbers=True, label_direction=DOWN)\n        self.play(DrawBorderThenFill(number_line), run_time=2)\n        numbers = [1, 1.5, 2, 4, 5.6, 7]\n        dict_numbers = dict()\n        for num in numbers:\n            dict_numbers[float(num)] = Tex(str(num))\n        labels = number_line.add_labels(dict_numbers, direction=UP, buff=None, font_size=None, label_constructor=None)\n        self.play(DrawBorderThenFill(labels), run_time=0.5)\n        number_line.add_ticks()\n        for i in range(len(numbers)):\n            new_dot = number_line.ticks.add(Dot().move_to(labels.number_to_point(numbers[i])))\n        self.play(DrawBorderThenFill(new_dot), run_time=0.3)\n        images: ImageMobject = []\n        for i in range(len(numbers)):\n            images.append(ImageMobject('./people/' + str(i + 1) + '.png').scale(0.15).move_to(labels.number_to_point(numbers[i])).shift(UP))\n        for image in images:\n            self.play(FadeIn(image), run_time=0.1)\n        destination = Dot(fill_color=RED)\n        arrow_destination = Arrow(start=DOWN / 12, end=UP, stroke_color=RED).shift(DOWN * 1.4)\n        label_destination = Tex('destination', font_size=24, fill_color=RED).move_to(arrow_destination, DOWN).shift(DOWN * 0.3)\n        self.play(DrawBorderThenFill(destination), run_time=0.5)\n        self.play(*list(map(DrawBorderThenFill, [arrow_destination, label_destination])), run_time=0.5)\n        self.wait(2)\n        destination_group = VGroup()\n        destination_group.add(destination, arrow_destination, label_destination)\n        self.play(destination_group.animate.shift(LEFT * 2), run_time=1)\n        self.wait(1)\n        self.play(*[images[i].animate.move_to(destination).shift(UP) for i in range(0, len(images))], run_time=2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Plot a parametric function and animate the derivation of its minimum."}, {"role": "assistant", "content": "from manim import *\n\nclass GraphFunc(Scene):\n\n    def construct(self):\n        N = 16\n        x_min, x_max, x_step = (0.1, 20, 1)\n        y_min, y_max, y_step = (0.1, 20, 1)\n        axes = Axes(x_range=[x_min, x_max, x_step], y_range=[y_min, y_max, y_step], x_length=7, y_length=5, axis_config={'include_tip': True})\n\n        def func(t):\n            x = t\n            y = N / x + x\n            return axes.c2p(x, y)\n        graph = ParametricFunction(func, t_range=[x_min, x_max], color=BLUE)\n        graph_label = axes.get_graph_label(graph, 'f(B) = \\\\frac{N}{B} + B', x_val=3, direction=UP * 5 + RIGHT, buff=0.3)\n        points = VGroup()\n        for i in range(1, int((x_max - x_min) / x_step) + 1):\n            x = x_min + i * x_step\n            y = N / x + x\n            point = Dot(axes.c2p(x, y), color=RED)\n            points.add(point)\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.play(Create(points))\n        anims = []\n        for i in range(1, len(points)):\n            line = Line(points[i - 1].get_center(), points[i].get_center(), color=YELLOW)\n            anims.append(Create(line))\n        self.play(*anims, run_time=0.5)\n        self.wait()\n        T = 1\n        W = 1\n        self.wait(W)\n        t = MathTex('f(B) = \\\\frac{N + B^2}{B}').shift(DOWN + RIGHT)\n        self.play(Write(t), run_time=T)\n        self.wait(W)\n        td = MathTex(\"f'(B) = 1 - \\\\frac{N}{B^2}\").shift(DOWN + RIGHT)\n        self.play(Transform(t, td), run_time=T)\n        self.wait(W)\n        td2 = MathTex('0 = 1 - \\\\frac{N}{B^2}').shift(DOWN + RIGHT)\n        self.play(Transform(t, td2), run_time=T)\n        self.wait(W)\n        td3 = MathTex('1 = \\\\frac{N}{B^2}').shift(DOWN + RIGHT)\n        self.play(Transform(t, td3), run_time=T)\n        self.wait(W)\n        td4 = MathTex('N = B^2').shift(DOWN + RIGHT)\n        self.play(Transform(t, td4), run_time=T)\n        self.wait(W)\n        td5 = MathTex('B = \\\\sqrt{N}').shift(DOWN + RIGHT)\n        self.play(Transform(t, td5), run_time=T)\n        self.wait(W)\n        self.wait(3)"}]}
{"messages": [{"role": "user", "content": "Display a function definition and then visualize data points on a number line corresponding to the function's variables, highlighting each data point and its label."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom colors import CYAN\n\nclass FuncDef(MovingCameraScene):\n\n    def construct(self):\n        big_sum = MathTex('\\\\displaystyle f(x) = \\\\sum_{i=1}^{n} \\\\; \\\\lvert x_{i} - x \\\\rvert', substrings_to_isolate=['x_{i}', 'x']).scale(1.2)\n        self.play(DrawBorderThenFill(big_sum))\n        self.wait(3)\n        number_line_shift = DOWN\n        number_line = NumberLine(x_range=[0, 10, 1], length=10, color=BLUE, include_tip=True, include_numbers=False, label_direction=DOWN).shift(number_line_shift)\n        self.play(big_sum.animate.shift(UP), DrawBorderThenFill(number_line))\n        shifts = [LEFT * 2.8, LEFT * 2.3, LEFT, RIGHT * 1.2, RIGHT * 3, RIGHT * 3.6]\n        dots = []\n        imgs = []\n        for i in range(len(shifts)):\n            xi = VGroup()\n            xi.add(Dot().shift(number_line_shift + shifts[i]))\n            xi.add(MathTex('x_' + str(i + 1)).scale(0.8).shift(number_line_shift + shifts[i] + DOWN * 0.4))\n            dots.append(xi)\n            imgs.append(ImageMobject('./people/' + str(i + 1) + '.png').scale(0.15).shift(number_line_shift + shifts[i]).shift(UP * 0.4))\n        for i in range(len(dots)):\n            self.play(DrawBorderThenFill(dots[i]), FadeIn(imgs[i]), run_time=0.4)\n        self.wait(5)\n        new_big_sum = big_sum.set_color_by_tex('x', RED)\n        new_big_sum = big_sum.set_color_by_tex('x_{i}', WHITE)\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Visualize points on a number line, highlight them with images, then demonstrate a mathematical transformation involving absolute values and rearrangements of terms."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom colors import CYAN\n\nclass FuncDef(MovingCameraScene):\n\n    def construct(self):\n        number_line = NumberLine(x_range=[0, 10, 1], length=10, color=BLUE, include_tip=True, include_numbers=False, label_direction=DOWN)\n        self.play(DrawBorderThenFill(number_line))\n        shifts = [LEFT * 3.5, LEFT * 2.5, LEFT * 0.8, RIGHT * 1.2, RIGHT * 3.2, RIGHT * 3.6]\n        dots: List[Dot] = []\n        imgs: List[ImageMobject] = []\n        for i in range(len(shifts)):\n            xi = VGroup()\n            xi.add(Dot().shift(shifts[i]))\n            xi.add(MathTex('x_' + str(i + 1)).scale(0.8).shift(shifts[i] + DOWN * 0.4))\n            dots.append(xi)\n            imgs.append(ImageMobject('./people/' + str(i + 1) + '.png').scale(0.15).shift(shifts[i]).shift(UP * 0.4))\n        x_dot = Dot(fill_color=RED).shift(shifts[1])\n        x_dot_label = MathTex('x', fill_color=RED).scale(0.4).shift(shifts[1] + DOWN * 0.2)\n        x_dot_group = VGroup()\n        x_dot_group.add(x_dot, x_dot_label)\n        for i in range(len(dots)):\n            self.play(DrawBorderThenFill(dots[i]), FadeIn(imgs[i]), run_time=0.4)\n        self.wait(5)\n        self.play(self.camera.frame.animate.scale(0.45).shift(LEFT * 1.7))\n        self.wait(3)\n        id = [0, 3]\n        for i in id:\n            self.play(FadeOut(imgs[i]), run_time=0.2)\n            dots[i].set_opacity(0.4)\n        self.wait(3)\n        xk = MathTex('x_k').scale(0.6).move_to(dots[1][1])\n        xk1 = MathTex('x_{k+1}').scale(0.6).move_to(dots[2][1])\n        self.play(self.camera.frame.animate.scale(0.7).shift(RIGHT * 0.1), Transform(dots[1][1], xk), Transform(dots[2][1], xk1))\n        self.wait(5)\n        self.play(*list(map(DrawBorderThenFill, x_dot_group)))\n        self.play(x_dot_group.animate.shift(RIGHT * 1.2), run_time=0.7)\n        self.play(x_dot_group.animate.shift(RIGHT * 0.4), run_time=0.3)\n        self.play(x_dot_group.animate.shift(LEFT * 0.9), run_time=0.5)\n        self.wait(5)\n        substrings = ['x_1', 'x_2', 'x_k', 'x_{k+1}', 'x_n', 'x']\n        constants = '- x_1 - x_2 - ... - x_k + x_{k+1} + ... + x_n'\n        coeff = 'n - 2k'\n        variable = ')x'\n        f_k0 = MathTex('f(x) = \\\\lvert x_1 - x \\\\rvert  + \\\\lvert x_2 - x \\\\rvert  + ... + \\\\lvert x_k - x \\\\rvert  + \\\\lvert x_{k+1} - x \\\\rvert + ... + \\\\lvert x_n - x \\\\rvert', substrings_to_isolate=substrings).move_to(self.camera.frame_center).shift(DOWN * 0.73).scale(0.25)\n        f_k = MathTex('f(x) = x - x_1 + x - x_2 + ... + x - x_k + x_{k+1} - x + ... + x_n - x', substrings_to_isolate=substrings).move_to(self.camera.frame_center).shift(DOWN * 0.9).scale(0.27)\n        f_k_rearrange = MathTex('f(x) = - x_1 - x_2 - ... - x_k + x_{k+1} + ... + x_n - (n - 2k)x', substrings_to_isolate=[constants, variable, coeff]).move_to(self.camera.frame_center).shift(DOWN * 1.1).scale(0.27)\n        self.play(Write(f_k0), run_time=0.8)\n        self.wait(4)\n        self.play(Write(f_k))\n        self.play(f_k0.get_parts_by_tex('x').animate.set_fill(RED), *[f_k0.get_parts_by_tex(substring).animate.set_fill(WHITE) for substring in substrings[0:-1]])\n        self.play(f_k.get_parts_by_tex('x').animate.set_fill(RED), *[f_k.get_parts_by_tex(substring).animate.set_fill(WHITE) for substring in substrings[0:-1]])\n        self.wait(5)\n        self.play(Write(f_k_rearrange))\n        self.play(Indicate(f_k_rearrange.get_part_by_tex(constants)), run_time=1.6)\n        self.wait()\n        self.play(Indicate(f_k_rearrange.get_part_by_tex(coeff)), run_time=1.6)\n        self.wait(3)\n        self.play(FadeOut(f_k), FadeOut(f_k0), self.camera.frame.animate.shift(DOWN * 2))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Animate the absolute value function plot of a set of points with vertical lines marking the points, a moving dot illustrating the minimum, and accompanying mathematical expressions for optimization."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom colors import CYAN\n\nclass AbsPlots(Scene):\n\n    def f(self, x, points):\n        return sum((abs(point - x) for point in points))\n\n    def construct(self):\n        axes = Axes(x_range=[-2, 15, 1], y_range=[-2, 30, 5], x_length=10, axis_config={'color': GREEN}, x_axis_config={'numbers_to_include': np.arange(-2, 15.1, 1), 'numbers_with_elongated_ticks': np.arange(-2, 15.1, 1)}, tips=False)\n        x_axis_label = Tex('$x$').move_to(axes.get_x_axis()).shift(RIGHT * 5.5 + UP * 0.5)\n        y_axis_label = Tex('cost').move_to(axes.get_y_axis()).shift(UP * 2.5 + RIGHT * 0.8)\n        points = [2, 5, 7, 12]\n        abs_graph = axes.plot(lambda x: self.f(x, points), color=BLUE)\n        abs_label = axes.get_graph_label(abs_graph, 'f(x)', x_val=2, direction=UP * 3)\n        lines = []\n        for i in range(len(points)):\n            lines.append(axes.get_vertical_line(axes.i2gp(points[i], abs_graph), color=YELLOW, line_func=Line).set_z_index(-1000))\n        plot = VGroup(abs_graph, abs_label, x_axis_label, y_axis_label)\n        self.play(FadeIn(axes))\n        self.wait(2)\n        dots = []\n        for i in range(len(points)):\n            location = axes.coords_to_point(points[i], 0)\n            dots.append(Dot(location))\n            dots.append(ImageMobject('./people/' + str(i + 1) + '.png').scale(0.15).move_to(location).shift(UP * 0.4))\n        self.play(*list(map(FadeIn, dots)))\n        self.wait(5)\n        self.play(DrawBorderThenFill(plot), *list(map(FadeIn, lines)))\n        self.wait(5)\n        t = ValueTracker(-1)\n        initial_point = [axes.coords_to_point(t.get_value(), self.f(t.get_value(), points))]\n        dot = Dot(point=initial_point)\n        dot.add_updater(lambda x: x.move_to(axes.c2p(t.get_value(), self.f(t.get_value(), points))))\n        x_space = np.linspace(-1, 6)\n        minimum_index = self.f(x_space, points).argmin()\n        dec = MathTex('n - 2k \\\\geq 0').shift(2 * UP)\n        dec2 = MathTex('k \\\\leq \\\\frac{n}{2}').shift(2 * UP)\n        self.play(DrawBorderThenFill(dot), Write(dec))\n        self.play(Transform(dec, dec2))\n        self.play(t.animate.set_value(x_space[minimum_index]), run_time=4)\n        self.wait(3)\n        self.play(FadeOut(dec))\n        self.wait(2)\n        inc = MathTex('n - 2k \\\\leq 0').shift(2 * UP)\n        inc2 = MathTex('k \\\\geq \\\\frac{n}{2}').shift(2 * UP)\n        self.play(DrawBorderThenFill(dot), Write(inc))\n        self.play(Transform(inc, inc2))\n        self.play(t.animate.set_value(18), run_time=4)\n        self.wait(3)\n        self.play(FadeOut(inc))\n        self.wait(10)\n        self.play(FadeOut(dot))\n        t.set_value(-1)\n        self.play(FadeIn(dot))\n        self.play(t.animate.set_value(6), run_time=4)\n        self.wait(1)\n        self.play(t.animate.set_value(18), run_time=4)\n        self.wait(2)\n        stationary = MathTex('n - 2k = 0').shift(2 * UP)\n        stationary2 = MathTex('k = \\\\frac{n}{2}').shift(2 * UP)\n        self.play(Write(stationary))\n        self.wait(2)\n        self.play(Transform(stationary, stationary2))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Plot the absolute value function with respect to a set of points and animate a dot tracing the function's minimum."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom colors import CYAN\n\nclass AbsPlots(Scene):\n\n    def f(self, x, points):\n        return sum((abs(point - x) for point in points))\n\n    def construct(self):\n        axes = Axes(x_range=[-2, 15, 1], y_range=[-2, 30, 5], x_length=10, axis_config={'color': GREEN}, x_axis_config={'numbers_to_include': np.arange(-2, 15.1, 1), 'numbers_with_elongated_ticks': np.arange(-2, 15.1, 1)}, tips=False)\n        x_axis_label = Tex('$x$').move_to(axes.get_x_axis()).shift(RIGHT * 5.5 + UP * 0.5)\n        y_axis_label = Tex('cost').move_to(axes.get_y_axis()).shift(UP * 2.5 + RIGHT * 0.8)\n        points = [2, 5, 12]\n        abs_graph = axes.plot(lambda x: self.f(x, points), color=BLUE)\n        abs_label = axes.get_graph_label(abs_graph, 'f(x)', x_val=2, direction=UP * 3)\n        lines = []\n        for i in range(len(points)):\n            lines.append(axes.get_vertical_line(axes.i2gp(points[i], abs_graph), color=YELLOW, line_func=Line).set_z_index(-1000))\n        plot = VGroup(abs_graph, abs_label, x_axis_label, y_axis_label)\n        self.play(FadeIn(axes))\n        self.wait(2)\n        dots = []\n        for i in range(len(points)):\n            location = axes.coords_to_point(points[i], 0)\n            dots.append(Dot(location))\n            dots.append(ImageMobject('./people/' + str(i + 1) + '.png').scale(0.15).move_to(location).shift(UP * 0.4))\n        self.play(*list(map(FadeIn, dots)))\n        self.wait(5)\n        self.play(DrawBorderThenFill(plot), *list(map(FadeIn, lines)))\n        self.wait(10)\n        t = ValueTracker(-1)\n        initial_point = [axes.coords_to_point(t.get_value(), self.f(t.get_value(), points))]\n        dot = Dot(point=initial_point)\n        dot.add_updater(lambda x: x.move_to(axes.c2p(t.get_value(), self.f(t.get_value(), points))))\n        x_space = np.linspace(-1, 5)\n        minimum_index = self.f(x_space, points).argmin()\n        self.play(DrawBorderThenFill(dot))\n        self.play(t.animate.set_value(x_space[minimum_index]), run_time=4)\n        self.wait(2)\n        self.play(t.animate.set_value(15), FadeOut(dot), run_time=4)\n        self.wait(10)\n        initial_point = [axes.coords_to_point(5, self.f(5, points))]\n        dot = Dot(point=initial_point, fill_color=RED)\n        self.play(DrawBorderThenFill(dot))\n        self.play(dots[3].animate.scale(1.8).shift(UP * 0.2))\n        self.wait(10)"}]}
{"messages": [{"role": "user", "content": "Display the word \"Hi\" in large text for five seconds."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom colors import CYAN\n\nclass HiScene(Scene):\n\n    def construct(self):\n        hi = Text('Hi', font='Roboto Thin').scale(1.5)\n        self.play(FadeIn(hi), run_time=2)\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Display a sequence of scaled images fading in, followed by the text \"Star Wars\"."}, {"role": "assistant", "content": "from manim import *\nimport os\nfrom PIL import Image\n\nclass StarWars(Scene):\n\n    def construct(self):\n        path_images = [Image.open('./bigbang/' + img) for img in images]\n        path_images = map(lambda x: np.array(x), path_images)\n        path_images = list(map(lambda x: ImageMobject(x), path_images))\n        SHIFT_RIGHT = RIGHT * 1.3\n        SHIFT_OFFSET = SHIFT_RIGHT * (len(path_images) - 1) / 2\n        for i in range(len(path_images)):\n            path_images[i].scale(0.3)\n            path_images[i].shift(SHIFT_RIGHT * i - SHIFT_OFFSET)\n        self.wait(1)\n        self.play(*list(map(FadeIn, path_images)))\n        starWars = Text('Star\\nWars', font='BreezeSans', should_center=True)\n        starWars.shift(-SHIFT_OFFSET + LEFT * 2)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate the display of a large summation formula for the sum of absolute differences."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom colors import CYAN\n\nclass AddSum(Scene):\n\n    def construct(self):\n        big_sum = MathTex('\\\\displaystyle \\\\sum_{i=1}^{n} \\\\; \\\\lvert x_{i} - x \\\\rvert').scale(1.5)\n        self.play(DrawBorderThenFill(big_sum))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Simulate a queue operation using images of Big Bang Theory characters, displaying the time progression and queue content."}, {"role": "assistant", "content": "from manim import *\nimport os\nfrom PIL import Image\n\nclass StarWarsQueue(Scene):\n\n    def construct(self):\n        commands = [(1, 'Q', 'sheldon.png'), (2, 'Q', 'amy.png'), (3, 'Q', 'penny.png'), (4, 'D'), (5, 'Q', 'leonard.png'), (8, 'D'), (9, 'Q', 'howard.png'), (10, 'Q', 'bernie.png'), (11, 'D'), (12, 'D'), (13, 'D'), (14, 'Q', 'raj.png'), (15, 'D'), (16, 'D')]\n        times = [Text('Time: ' + str(com[0]), font='BreezeSans').scale(0.9).shift(UP * 2.5 + RIGHT * 3) for com in commands]\n        path_images = dict()\n        for img in images:\n            arr = np.array(Image.open('./bigbang/' + img))\n            path_images[img] = ImageMobject(arr).scale(0.3).shift(LEFT * 4)\n        mq = ManimQueue(RIGHT * 1.3)\n        for i in range(len(commands)):\n            if i > 0:\n                self.play(Transform(times[0], times[i]))\n            else:\n                self.play(Write(times[i]))\n            if commands[i][1] == 'Q':\n                self.play(mq.queue(path_images[commands[i][2]]))\n            else:\n                self.play(*mq.dequeue())\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display a number line with labeled dots and corresponding images, then zoom in on a specific point and animate its movement."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom colors import CYAN\n\nclass FuncDef(MovingCameraScene):\n\n    def construct(self):\n        number_line = NumberLine(x_range=[0, 10, 1], length=10, color=BLUE, include_tip=True, include_numbers=False, label_direction=DOWN)\n        self.play(DrawBorderThenFill(number_line))\n        shifts = [LEFT * 3.5, LEFT * 2.5, LEFT * 0.8, RIGHT * 0.3, RIGHT * 3.2, RIGHT * 3.6]\n        dots: List[Dot] = []\n        imgs: List[ImageMobject] = []\n        for i in range(len(shifts)):\n            xi = VGroup()\n            xi.add(Dot().shift(shifts[i]))\n            xi.add(MathTex('x_' + str(i + 1)).scale(0.8).shift(shifts[i] + DOWN * 0.4))\n            dots.append(xi)\n            imgs.append(ImageMobject('./people/' + str(i + 1) + '.png').scale(0.15).shift(shifts[i]).shift(UP * 0.4))\n        x_dot = Dot(fill_color=RED).shift(shifts[1])\n        x_dot_label = MathTex('x', fill_color=RED).scale(0.4).shift(shifts[1] + DOWN * 0.2)\n        x_dot_group = VGroup()\n        x_dot_group.add(x_dot, x_dot_label)\n        for i in range(len(dots)):\n            self.play(DrawBorderThenFill(dots[i]), FadeIn(imgs[i]), run_time=0.4)\n        self.wait(5)\n        self.play(self.camera.frame.animate.scale(0.45).shift(LEFT * 1.7))\n        self.play(*list(map(DrawBorderThenFill, x_dot_group)))\n        self.play(x_dot_group.animate.shift(RIGHT * 0.2), run_time=0.5)\n        self.wait(5)\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Simulate a queue with Big Bang Theory characters, showing additions and removals over time."}, {"role": "assistant", "content": "from manim import *\nimport os\nfrom PIL import Image\n\nclass StarWarsQueue2(Scene):\n\n    def construct(self):\n        commands = [(1, 'Q', 'sheldon.png'), (2, 'Q', 'amy.png'), (3, 'Q', 'leonard.png'), (4, 'D'), (5, 'Q', 'penny.png'), (8, 'D'), (9, 'Q', 'howard.png'), (10, 'Q', 'bernie.png'), (11, 'D'), (12, 'D'), (13, 'D'), (14, 'Q', 'raj.png'), (15, 'D'), (16, 'D')]\n        times = [Text('Time: ' + str(com[0]), font='BreezeSans').scale(0.9).shift(UP * 2.5 + RIGHT * 3) for com in commands]\n        path_images = dict()\n        for img in images:\n            arr = np.array(Image.open('./bigbang/' + img))\n            path_images[img] = ImageMobject(arr).scale(0.3).shift(LEFT * 4)\n        mq = ManimQueue(RIGHT * 1.3)\n        for i in range(len(commands)):\n            if commands[i][0] > 9:\n                break\n            if i > 0:\n                self.play(Transform(times[0], times[i]))\n            else:\n                self.play(Write(times[i]))\n            if commands[i][1] == 'Q':\n                self.play(mq.queue(path_images[commands[i][2]]))\n            else:\n                self.play(*mq.dequeue())\n        self.wait(6)"}]}
{"messages": [{"role": "user", "content": "Demonstrate the conversion from infix notation to postfix notation with step-by-step evaluation."}, {"role": "assistant", "content": "from manim import *\n\nclass PolishNotation(Scene):\n\n    def construct(self):\n        notation1 = MathTex('2 + 3').scale(1.5).shift(UP * 2)\n        self.play(Write(notation1), run_time=1.5)\n        self.wait(2)\n        notation2 = Tex('$2$ $3$ $+$').scale(1.5).move_to(notation1, DOWN).shift(DOWN)\n        self.play(Write(notation2), run_time=1.5)\n        self.wait(1)\n        notation21 = Tex('$5$').scale(1.5).move_to(notation2)\n        self.play(Transform(notation2, notation21), run_time=1.5)\n        self.wait(2)\n        notation3 = MathTex('5 + 3 * 4').scale(1.5).shift(DOWN)\n        self.play(Write(notation3), run_time=1.5)\n        self.wait(2)\n        notation4 = Tex('$5$ $3$ $4$ $*$ $+$').scale(1.5).move_to(notation3, DOWN).shift(DOWN)\n        self.play(Write(notation4), run_time=1.5)\n        self.wait(2)\n        notation41 = Tex('$5$ $12$ $+$').scale(1.5).move_to(notation4)\n        self.play(Transform(notation4, notation41))\n        self.wait(1)\n        notation42 = Tex('$17$').scale(1.5).move_to(notation41)\n        self.play(Transform(notation4, notation42))\n        self.wait(1)"}]}
{"messages": [{"role": "user", "content": "Animate a series of bars growing from a baseline based on query values and then connect the tops of the remaining bars with dots and lines."}, {"role": "assistant", "content": "from ast import List\nfrom manim import *\nfrom random import randint\n\nclass ProblemE_5(Scene):\n\n    def construct(self):\n        self.will_remove = False\n        self.N = 10\n        self.queries = [(6, 1), (8, 0.8), (3, 1.1), (1, 2.0), (2, 0.65), (5, 0.35)]\n        places = []\n        place_int = []\n        start = LEFT * 10 + DOWN * 3\n        ratio = 2\n        padding = RIGHT * 0.15\n        coeff = RIGHT\n        for i in range(self.N):\n            places.append(Line((start + i * coeff + padding) / ratio, (start + (i + 1) * coeff - padding) / ratio))\n            place_int.append(Text(f'{i}', font_size=15).move_to(places[i].get_center()).shift(DOWN * 0.25))\n\n        def rf(x):\n            if x < 0.5:\n                return 16 * x * x * x * x * x\n            return 1 - pow(-2 * x + 2, 5) / 2\n        self.wait(1)\n        self.play(AnimationGroup(*(Create(m, rate_func=rf) for m in places)), run_time=1.3)\n        self.play(AnimationGroup(*(Write(m, rate_func=rf) for m in place_int)), run_time=1.3)\n        self.wait(1)\n        self.rects: List[Rectangle] = [None for _ in range(20)]\n        self.query_text = None\n        for q in range(len(self.queries)):\n            X, H = self.queries[q]\n            if not self.query_text is None:\n                self.play(FadeOut(self.query_text), run_time=0.3)\n            self.query_text = Text(f'build: ({X}, {int(H * 10 * 10)})', font_size=28)\n            self.query_text.shift(UP * 2.5 + LEFT * 3)\n            self.play(Write(self.query_text), run_time=0.6)\n            rect = Rectangle(BLUE, height=0.001, width=0.2, fill_opacity=1)\n            rect.move_to(places[X], aligned_edge=DOWN)\n            rect.shift(UP * 0.05)\n            rect2 = rect.copy()\n            rect2.stretch_to_fit_height(height=H)\n            rect2.move_to(places[X], aligned_edge=DOWN)\n            rect2.shift(UP * 0.05)\n            self.add(rect)\n            self.play(Transform(rect, rect2))\n            if not self.rects[X] is None:\n                self.rects[X] = None\n            self.rects[X] = (rect, rect2)\n            if not self.will_remove:\n                continue\n            for u in range(X - 1, 0, -1):\n                if self.rects[u] is None:\n                    continue\n                if self.rects[u][0].height <= H:\n                    self.play(self.rects[u][0].animate.set_opacity(0.1), run_time=0.7)\n                    self.rects[u] = None\n        self.play(FadeOut(self.query_text), run_time=0.3)\n        self.wait(1)\n        dots = []\n        for i in range(self.N):\n            if self.rects[i] is None:\n                continue\n            d = Dot()\n            d.move_to(self.rects[i][1], aligned_edge=UP)\n            d.shift(UP * 0.1)\n            self.play(Create(d), run_time=0.4)\n            dots.append(d)\n        for i in range(len(dots) - 1):\n            l = Line(dots[i].get_center(), dots[i + 1].get_center())\n            self.play(Create(l), run_time=0.4)\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Animate the text \"T_1, T_2, T_3, T_4, T_5 ... T_q\" appearing on the screen."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom colors import CYAN\n\nclass TextOnly(Scene):\n\n    def construct(self):\n        txt = MathTex('T_1, T_2, T_3, T_4, T_5 ... T_q').scale(1.1)\n        self.play(Write(txt), run_time=2)\n        self.wait(8)"}]}
{"messages": [{"role": "user", "content": "Show a graph of a function and animate a process of iteratively narrowing an area under the curve by drawing and fading vertical lines."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom Utils.colors import CYAN\n\nclass AbsPlots(Scene):\n\n    def redraw_line(self, pos, axes: Axes, graph, text):\n        line = axes.get_vertical_line(axes.i2gp(pos, graph), color=YELLOW, line_func=Line, stroke_width=3).set_z_index(-1000)\n        text = Tex(text).move_to(line, DOWN).shift(DOWN * 0.7)\n        self.play(DrawBorderThenFill(line), Write(text), run_time=0.15)\n        return [line, text]\n\n    def draw_area(self, axes: Axes, graph, l, r):\n        area = axes.get_area(graph, [l, r])\n        self.add(area)\n        return area\n\n    def remove_lines(self, lines):\n        self.play(*list(map(FadeOut, lines)))\n\n    def construct(self):\n        axes = Axes(x_range=[-2, 15, 1], y_range=[-2, 5, 1], x_length=10, axis_config={'color': GREEN}, x_axis_config={'numbers_to_include': np.arange(0.0001, 15.1, 5), 'numbers_with_elongated_ticks': np.arange(-2, 15.1, 1)}, tips=False)\n        f = lambda x: pow(x - 7, 2) / 5 * ((x + 5) * 0.05) + 1.4\n        q_cont = axes.plot(f, color=RED, x_range=[1, 12, 0.01], stroke_width=4)\n        q_cont_label = axes.get_graph_label(q_cont, 'f(x)', x_val=3, direction=UP * 3)\n        self.play(DrawBorderThenFill(axes))\n        self.play(DrawBorderThenFill(q_cont))\n        self.play(Write(q_cont_label))\n        self.wait(5)\n        lines = []\n        l = 1\n        r = 12\n        area = self.draw_area(axes, q_cont, l, r)\n        while r - l > 0.4:\n            tmp = []\n            if len(lines) >= 4:\n                tmp = lines[:4]\n                for i in range(4):\n                    lines.pop(0)\n                self.remove_lines([tmp[1], tmp[3]])\n            lines.extend(self.redraw_line(l, axes, q_cont, 'L'))\n            lines.extend(self.redraw_line(r, axes, q_cont, 'R'))\n            if len(tmp) != 0:\n                self.remove_lines([tmp[0], tmp[2]])\n            self.play(FadeOut(area), run_time=0.2)\n            area = self.draw_area(axes, q_cont, l, r)\n            self.play(FadeIn(area), run_time=0.2)\n            self.remove_lines(lines[:4])\n            for i in range(4):\n                lines.pop(0)\n            mid1 = l + (r - l) / 3\n            mid2 = l + (r - l) / 3 * 2\n            lines.extend(self.redraw_line(mid1, axes, q_cont, 'M1'))\n            lines.extend(self.redraw_line(mid2, axes, q_cont, 'M2'))\n            if f(mid1) > f(mid2):\n                l = mid1\n            else:\n                r = mid2\n        self.remove_lines(lines)\n        lines = []\n        lines.extend(self.redraw_line((l + r) / 2, axes, q_cont, 'M'))\n        self.wait(4)"}]}
{"messages": [{"role": "user", "content": "Plot a continuous function and then a piecewise constant function, highlighting a minimum and maximum point on the graph."}, {"role": "assistant", "content": "from typing import List\nfrom manim import *\nfrom colors import CYAN\n\nclass AbsPlots(Scene):\n\n    def construct(self):\n        axes = Axes(x_range=[-2, 15, 1], y_range=[-2, 5, 1], x_length=10, axis_config={'color': GREEN}, x_axis_config={'numbers_to_include': np.arange(0.0001, 15.1, 5), 'numbers_with_elongated_ticks': np.arange(-2, 15.1, 1)}, tips=False)\n        f = lambda x: pow(x - 7, 2) / 3\n        q_cont = axes.plot(f, color=RED, x_range=[3, 11, 0.01])\n        q_cont_label = axes.get_graph_label(q_cont, 'f(x)', x_val=2, direction=DOWN * 3 + RIGHT * 4)\n        self.play(DrawBorderThenFill(axes))\n        self.play(DrawBorderThenFill(q_cont))\n        self.play(Write(q_cont_label))\n        self.wait(5)\n        save_disc = None\n        sx = 1.5\n        for rep in range(2):\n            for i in range(5):\n                off = rep * 5 * sx\n                q_disc = axes.plot(lambda x: i if rep == 0 else 5 - i, color=BLUE, x_range=[off + i * sx, off + (i + 1) * sx, 1])\n                self.play(DrawBorderThenFill(q_disc), run_time=0.2)\n                if rep == 0 and i == 2:\n                    save_disc = q_disc\n        q_disc_label = axes.get_graph_label(save_disc, 'g(x)', x_val=4, direction=UP * 1.5)\n        self.play(Write(q_disc_label), run_time=0.5)\n        self.wait(5)\n        mn_point = [axes.coords_to_point(7, f(7))]\n        dot = Dot(point=mn_point, radius=0.12)\n        self.play(DrawBorderThenFill(dot))\n        mn_text = Tex('minimum').move_to(mn_point, DOWN).shift(UP * 0.4 + RIGHT * 0.8)\n        self.play(Write(mn_text))\n        self.wait(5)\n        mx_point = [axes.coords_to_point(8, 5)]\n        dot2 = Dot(point=mx_point, radius=0.12)\n        self.play(DrawBorderThenFill(dot2))\n        mx_text = Tex('maximum').move_to(mx_point, DOWN).shift(UP * 0.4 + RIGHT * 0.8)\n        self.play(Write(mx_text))\n        self.wait(5)"}]}
{"messages": [{"role": "user", "content": "Create a circular graph with highlighted vertices."}, {"role": "assistant", "content": "from manim import *\n\nclass MaxClique(Scene):\n\n    def construct(self):\n        self.vertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G']\n        self.highlight_set = ['A', 'C', 'D', 'G', 'B']\n        self.edges = []\n        for i in range(len(self.vertices)):\n            for j in range(i + 1, len(self.vertices)):\n                self.edges.append((self.vertices[i], self.vertices[j]))\n        g = Graph(vertices=self.vertices, edges=self.edges, layout='circular', vertex_config={'radius': 0.25})\n        self.play(Create(g))\n        for node in self.highlight_set:\n            vertex = g.vertices[node]\n            self.play(vertex.animate.set_color(YELLOW))"}]}
{"messages": [{"role": "user", "content": "Create a graph with 7 nodes arranged in a circle and connected by edges, then animate their creation."}, {"role": "assistant", "content": "from manim import *\n\nclass MaxClique(Scene):\n\n    def construct(self):\n        circle = Circle(radius=2)\n        vertices = [circle.point_at_angle(i * TAU / 7) for i in range(7)]\n        edges = [(i, j) for i in range(7) for j in range(i + 1, 7)]\n        clique = [0, 1, 2, 3]\n        non_clique = [4, 5, 6]\n        nodes = VGroup(*[Dot(vertices[i], color=WHITE, radius=0.2) for i in range(7)])\n        edges = VGroup(*[Line(vertices[i], vertices[j]) for i, j in edges])\n        self.play(Create(nodes), Create(edges), run_time=3)\n        self.wait()"}]}
{"messages": [{"role": "user", "content": "Animate a random graph with vertices clustered in different areas and edges drawn with varying opacity and animation speeds, then highlight the first cluster in red and the remaining vertices in blue."}, {"role": "assistant", "content": "from manim import *\nfrom random import randint\n\nclass Clusters(Scene):\n\n    def construct(self):\n        self.vertices = [x for x in range(0, 20)]\n        g = Graph(vertices=self.vertices, edges=[], vertex_config={'radius': 0.25})\n\n        def rf(x):\n            if x < 0.5:\n                return 16 * x * x * x * x * x\n            return 1 - pow(-2 * x + 2, 5) / 2\n        for i in range(0, 8):\n            g.vertices[i].move_to(randint(-300, 300) / 100 * DOWN + randint(-300, 300) / 100 * RIGHT)\n        for i in range(8, 12):\n            g.vertices[i].move_to(randint(-800, -400) / 100 * DOWN + randint(200, 500) / 100 * RIGHT)\n        for i in range(12, 16):\n            g.vertices[i].move_to(randint(-800, -400) / 100 * DOWN + randint(-500, -200) / 100 * RIGHT)\n        for i in range(16, 20):\n            g.vertices[i].move_to(randint(400, 800) / 100 * DOWN + randint(-500, -200) / 100 * RIGHT)\n        self.play(DrawBorderThenFill(g))\n        mobjects = []\n        for i in range(8):\n            for j in range(i + 1, 8):\n                if randint(1, 100) <= 80:\n                    mobjects.append(g._add_edge((self.vertices[i], self.vertices[j])))\n        for i in range(len(self.vertices)):\n            for j in range(i + 1, len(self.vertices)):\n                if i < 8 and j < 8:\n                    continue\n                v = g.vertices[i].get_center() - g.vertices[j].get_center()\n                k = np.linalg.norm(v)\n                p = 100 * (1 / (k / 2) ** 2)\n                if randint(1, 100) <= p:\n                    mobjects.append(g._add_edge((self.vertices[i], self.vertices[j]), edge_config={'stroke_opacity': 0.3}))\n        self.play(AnimationGroup(*(DrawBorderThenFill(m, rate_func=rf) for m in mobjects)), run_time=0.5)\n        in_network = Circle(4, color=RED)\n        self.play(Create(in_network))\n        for i in range(8):\n            vertex = g.vertices[i]\n            self.play(vertex.animate.set_color(RED), run_time=0.06)\n        self.wait(2)\n        for i in range(8, len(self.vertices)):\n            vertex = g.vertices[i]\n            self.play(vertex.animate.set_color(BLUE), run_time=0.06)\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Animate the construction of a circular graph, then gradually add all possible edges with a custom animation, and finally highlight a specific set of vertices."}, {"role": "assistant", "content": "from manim import *\n\nclass MaxClique(Scene):\n\n    def construct(self):\n        self.vertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G']\n        self.highlight_set = ['A', 'C', 'D', 'G', 'B']\n        g = Graph(vertices=self.vertices, edges=[], layout='circular', vertex_config={'radius': 0.25})\n        self.play(DrawBorderThenFill(g))\n\n        def rf(x):\n            if x < 0.5:\n                return 16 * x * x * x * x * x\n            return 1 - pow(-2 * x + 2, 5) / 2\n        for i in range(len(self.vertices)):\n            mobjects = []\n            for j in range(i + 1, len(self.vertices)):\n                mobjects.append(g._add_edge((self.vertices[i], self.vertices[j])))\n            self.play(AnimationGroup(*(DrawBorderThenFill(m, rate_func=rf) for m in mobjects)), run_time=0.5)\n        for node in self.highlight_set:\n            vertex = g.vertices[node]\n            self.play(vertex.animate.set_color(WHITE), run_time=0.01)\n        for node in self.highlight_set:\n            vertex = g.vertices[node]\n            self.play(Indicate(vertex))\n        self.wait(2)"}]}
{"messages": [{"role": "user", "content": "Display a set of points, form a polygon connecting them, highlight the first point, draw and fade out triangles, show vector operations representing area, and conclude with an O(N) complexity notation."}, {"role": "assistant", "content": "from manim import *\n\nclass ConvexHull(Scene):\n\n    def construct(self):\n        points = [[-1, -1.2], [1.4, -1.4], [2.3, -0.4], [3, 1.8], [1, 2.3], [-0.3, 2], [-1.4, 1]]\n        offset = [-0.5, -0.5]\n        N = len(points)\n        for i in range(N):\n            points[i][0] += offset[0]\n            points[i][1] += offset[1]\n\n        def getLocation(point):\n            return point[0] * RIGHT + point[1] * UP\n        for point in points:\n            p = Dot(getLocation(point), radius=0.08, color=BLUE)\n            self.play(DrawBorderThenFill(p), run_time=0.3)\n        poly = Polygon(*list(map(getLocation, points)))\n        self.play(Create(poly))\n        self.wait(1)\n        self.play(poly.animate.set_fill(opacity=0.2))\n        self.wait(1)\n        self.play(poly.animate.set_fill(opacity=0))\n        self.wait(1)\n        fixed = Dot(getLocation(points[0]), color=RED, radius=0.1)\n        self.play(Create(fixed))\n        p0t = MathTex('p_0').move_to(fixed).shift(DOWN * 0.4 + LEFT * 0.4)\n        self.play(Write(p0t))\n        triangles = []\n        for i in range(0, N - 2):\n            p0 = getLocation(points[0])\n            p1 = getLocation(points[i + 1])\n            p2 = getLocation(points[i + 2])\n            tri = Polygon(*[p0, p1, p2], color=RED, fill_opacity=0.2)\n            triangles.append(tri)\n            self.play(DrawBorderThenFill(tri), run_time=0.4)\n        self.wait(1)\n        for i in range(len(triangles) - 1, 0, -1):\n            t = triangles[i]\n            self.play(FadeOut(t), run_time=0.2)\n\n        def vec(p0, pi, pii, time):\n            v1 = Arrow(getLocation(points[p0]), getLocation(points[pi]), buff=0, stroke_width=3, max_tip_length_to_length_ratio=0.1)\n            v2 = Arrow(getLocation(points[p0]), getLocation(points[pii]), buff=0, stroke_width=3, max_tip_length_to_length_ratio=0.08)\n            v1t = MathTex('\\\\vec{v}', font_size=32).move_to(v1, UP).shift(UP * 0.25 + RIGHT * 0.4)\n            v2t = MathTex('\\\\vec{u}', font_size=32).move_to(v2, UP)\n            self.play(*[Create(v1), Write(v1t)], run_time=1)\n            self.play(*[Create(v2), Write(v2t)], run_time=1)\n            return [v1, v2, v1t, v2t]\n        vectors = vec(0, 1, 2, 1)\n        self.wait(2)\n        area = MathTex('2P = |\\\\vec{u}\\\\times\\\\vec{v}|').shift(DOWN * 2.5 + RIGHT * 0.5)\n        self.play(Write(area))\n        self.wait(2)\n        self.play(FadeOut(area), FadeOut(triangles[0]))\n        self.wait(2)\n        self.play(*[FadeOut(x) for x in vectors])\n        for i in range(2, N - 1):\n            V = vec(0, i, i + 1, 0.2)\n            p = Polygon(*[getLocation(points[0]), getLocation(points[i]), getLocation(points[i + 1])], color=RED, fill_opacity=0.2)\n            self.play(FadeIn(p), run_time=0.5)\n            self.wait(0.5)\n            V.extend(p)\n            self.play(*[FadeOut(x) for x in V])\n        t = MathTex('O(N)')\n        self.play(Write(t))\n        self.wait(2)\n        self.play(*[FadeOut(p0t), FadeOut(fixed)])\n        self.wait(2)\n        return"}]}
{"messages": [{"role": "user", "content": "Display the names of five geometric shapes, then transform each name into its corresponding shape and display its formula."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass ShapesPlay(Scene):\n    TEXT_SIZE_F = 1.5\n    TOP_LEFT = (LEFT_SIDE + TOP) / TEXT_SIZE_F\n    TOP_RIGHT = (RIGHT_SIDE + TOP) / TEXT_SIZE_F\n    BOTTOM_LEFT = (LEFT_SIDE + BOTTOM) / TEXT_SIZE_F\n    BOTTOM_RIGHT = (RIGHT_SIDE + BOTTOM) / TEXT_SIZE_F\n    shapes_info = {'circle': (GOLD, ORIGIN), 'square': (RED_E, TOP_LEFT), 'triangle': (BLUE_E, TOP_RIGHT), 'ellipse': (GREY, BOTTOM_RIGHT), 'rectangle': (MAROON, BOTTOM_LEFT)}\n    SHAPE_NAMES = shapes_info.keys()\n\n    def gen_shape_text(self, name):\n        color, pos = self.shapes_info[name]\n        shape_text = TextMobject(name)\n        shape_text.set_color(color)\n        shape_text.shift(pos)\n        return shape_text\n\n    def construct(self):\n        texts = [self.gen_shape_text(name) for name in self.SHAPE_NAMES]\n        shapes = [self.gen_shape_obj(name) for name in self.SHAPE_NAMES]\n        formulas = [self.gen_shape_formula(name) for name in self.SHAPE_NAMES]\n        text_animations = [Write(text_obj, run_time=3) for text_obj in texts]\n        self.play(*text_animations)\n        for text, shape, formula in zip(texts, shapes, formulas):\n            self.play(Transform(text, shape, run_time=2))\n            formula.next_to(shape, DOWN)\n            self.play(Write(formula, run_time=2))\n\n    def gen_shape_obj(self, name):\n        circle = Circle(radius=1.0, color=PURPLE_A)\n        triangle = Polygon(np.array([0, 0, 0]), np.array([1, -1, 0]), np.array([-1, -1, 0]))\n        square = Square(side_length=1.0, color=GOLD_A)\n        ellipse = Ellipse(width=2, height=1, color=RED)\n        rectangle = Rectangle(height=1, width=1.5)\n        shapes_map = {'circle': circle, 'triangle': triangle, 'square': square, 'rectangle': rectangle, 'ellipse': ellipse}\n        for shape_name, shape_obj in shapes_map.items():\n            color, pos = self.shapes_info[shape_name]\n            shape_obj.move_to(pos)\n        return shapes_map[name]\n\n    def gen_shape_formula(self, name):\n        circle = TexMobject('\\\\pi r^2')\n        triangle = TexMobject('\\\\frac{1}{2} base \\\\times height')\n        square = TexMobject('length^2')\n        ellipse = TexMobject('\\\\pi a b')\n        rectangle = TexMobject('length \\\\times breadth')\n        formula_map = {'circle': circle, 'triangle': triangle, 'square': square, 'rectangle': rectangle, 'ellipse': ellipse}\n        return formula_map[name]"}]}
{"messages": [{"role": "user", "content": "Present an educational animation explaining the scalar product of vectors, covering its algebraic calculation, geometric interpretation, perpendicularity case, and properties."}, {"role": "assistant", "content": "from manimlib.imports import *\n\nclass Test(Scene):\n    scalar_topic = None\n\n    def construct(self):\n        self.topic()\n        self.intro()\n        self.vector_intro_graph()\n        self.algebric_calc()\n        self.geometric_interpretation()\n        self.geometric_calc()\n        self.case_of_perpendicularity()\n        self.dot_product_properties()\n        self.angle_of_vectors()\n        self.angle_of_vectors_algebric()\n        self.wait(3)\n\n    def topic(self):\n        title = TextMobject('Product of Vectors', color=BLUE)\n        title.scale(1.5)\n        self.play(Write(title), run_time=3)\n        self.wait(1)\n        self.play(title.to_edge, UP)\n        types = ('The product of vectors can be calculated in two ways', '1. Scalar Product (Dot Product)', '2. Vector Product (Cross Product)')\n        types_text = VGroup(*[TextMobject(i) for i in types])\n        types_text.arrange(DOWN, center=False).shift(UP)\n        self.play(Write(types_text), run_time=8)\n        self.scalar_topic = types_text[1]\n        self.play(FadeOut(title), FadeOut(types_text[0]), FadeOut(types_text[2]))\n\n    def intro(self):\n        text = TextMobject('Scalar Product of Two Vectors', color=BLUE)\n        text.scale(1.5).to_edge(UP)\n        self.play(ReplacementTransform(self.scalar_topic, text))\n        self.wait(1)\n        intro = ('If $\\\\vec{A}$ ($a_1$, $b_1$) and $\\\\vec{B}$ ($a_2$, $b_2$) be two', 'vectors then their scalar product is given by,', '$\\\\vec{A} \\\\cdot \\\\vec{B}$ = ($a_1$, $b_1$) $\\\\cdot$ ($a_2$, $b_2$)', '= $a_1 a_2$ + $b_1 b_2$')\n        intro_text = VGroup(*[TextMobject(i) for i in intro])\n        intro_text.arrange(DOWN, center=False).shift(UP)\n        self.play(Write(intro_text), run_time=8)\n        for_eg_text = TextMobject('Let us take two vectors $\\\\vec{A}$ = 2i + 2j and $\\\\vec{B}$ = 2i, ')\n        for_eg_text.to_edge(DOWN).shift(UP)\n        self.play(Write(for_eg_text), run_time=3)\n        self.wait(3)\n        self.play(FadeOutAndShiftDown(VGroup(*self.mobjects)))\n\n    def vector_intro_graph(self):\n        grid = NumberPlane(background_line_style={'stroke_color': WHITE})\n        va = Vector(direction=UR, color=GREEN).scale(2).shift(UR / 2)\n        vb = Vector(color=BLUE).scale(2, about_edge=LEFT)\n        origin_tex = TexMobject('O')\n        origin_tex.shift(DL / 3)\n        va_coor_tex = TexMobject('\\\\vec{A} \\\\ \\\\ (2, 2)')\n        vb_coor_tex = TexMobject('\\\\vec{B} \\\\ \\\\ (2, 0)')\n        va_coor_tex.next_to(va.get_end(), UR)\n        vb_coor_tex.next_to(vb.get_end(), UR)\n        va_tex, vb_tex = (TexMobject('2i+2j'), TexMobject('2i+0j'))\n        arrow = TexMobject('\\\\rightarrow').scale(1.5)\n        va_arrow, vb_arrow = (arrow.copy(), arrow.copy())\n        va_arrow.next_to(va_coor_tex)\n        vb_arrow.next_to(vb_coor_tex)\n        va_tex.next_to(va_arrow).set_color(GREEN)\n        vb_tex.next_to(vb_arrow).set_color(BLUE)\n        self.play(ShowCreation(grid))\n        self.play(ShowCreation(origin_tex))\n        self.wait()\n        self.play(ShowCreation(va))\n        self.play(Write(va_coor_tex))\n        self.wait()\n        self.play(ShowCreation(vb))\n        self.play(Write(vb_coor_tex))\n        self.wait()\n        self.play(ShowCreation(va_arrow))\n        self.play(Write(va_tex))\n        self.wait()\n        self.play(ShowCreation(vb_arrow))\n        self.play(Write(vb_tex))\n        self.wait(3)\n        self.play(FadeOut(Group(*self.mobjects)))\n\n    def algebric_calc(self):\n        title = TextMobject('Solving algebraically, ')\n        title.to_edge(UL)\n        a_b = TexMobject('\\\\vec{A} \\\\cdot \\\\vec{B} =').to_edge(UL).shift(DOWN)\n        tex_parts = [TexMobject(i) for i in ['(2i', '+', '2j)', '\\\\cdot', '(2i', '+', '0j)']]\n        vec_parts = [tex for n, tex in enumerate(tex_parts) if n % 2 == 0]\n        i_parts = VGroup(vec_parts[0], vec_parts[2]).set_color(BLUE)\n        j_parts = VGroup(vec_parts[1], vec_parts[3]).set_color(ORANGE)\n        row_one = [a_b]\n        for tex in tex_parts:\n            tex.next_to(row_one[-1])\n            row_one.append(tex)\n        a_b2 = a_b.copy().shift(DOWN)\n        i_dest = TexMobject('(2i \\\\cdot 2i) \\\\ + \\\\ ', color=BLUE).next_to(a_b2)\n        j_dest = TexMobject('(2j \\\\cdot 0j)', color=ORANGE).next_to(i_dest)\n        two_row = VGroup(a_b2, i_dest, j_dest)\n        a_b3 = a_b2.copy().shift(DOWN)\n        new_row = VGroup(a_b3, TexMobject('4').next_to(a_b3))\n        conclusion = TextMobject('$\\\\therefore$ the scalar product of $\\\\vec{A}$ and $\\\\vec{B}$ is 4.')\n        conclusion.next_to(new_row, DOWN, buff=1.0).to_edge(LEFT)\n        self.play(Write(title), run_time=3)\n        self.wait()\n        self.play(Write(VGroup(*row_one)))\n        self.play(ReplacementTransform(a_b.copy(), a_b2))\n        self.wait()\n        self.play(ReplacementTransform(i_parts.copy(), i_dest))\n        self.wait()\n        self.play(ReplacementTransform(j_parts.copy(), j_dest))\n        self.wait()\n        self.play(ReplacementTransform(two_row.copy(), new_row))\n        self.play(Write(conclusion), run_time=5)\n        self.wait(3)\n        self.play(FadeOutAndShiftDown(Group(*self.mobjects)))\n\n    def geometric_interpretation(self):\n        title = TextMobject('Geometric Interpretation', color=BLUE)\n        title.scale(1.5).to_edge(UP)\n        self.play(Write(title), run_time=3)\n        self.wait(1)\n        types = ('Scalar product can be geometrically explained through', 'the concept of projection.', 'Scalar product of two vectors, $\\\\vec{A}$ and $\\\\vec{B}$ is given by', '$\\\\vec{A} \\\\cdot \\\\vec{B}$ = (length of proj. of $\\\\vec{A}$)(length of $\\\\vec{B}$)', 'alternatively, $\\\\vec{A} \\\\cdot \\\\vec{B}$ = (length of proj. of $\\\\vec{B}$)(length of $\\\\vec{A}$)', 'Let us now obtain scalar product of two vectors,', '$\\\\vec{A}$=2i+2j and $\\\\vec{B}$=3i+0j')\n        types_text = VGroup(*[TextMobject(i) for i in types])\n        types_text.arrange(DOWN, center=False, buff=0.325)\n        types_text.next_to(title, DOWN, buff=0.7)\n        for line in types_text:\n            self.play(Write(line), run_time=4)\n        self.wait(3)\n        self.play(FadeOut(Group(*self.mobjects)))\n\n    @staticmethod\n    def get_projection(vector_to_project, stable_vector):\n        v1, v2 = (stable_vector, vector_to_project)\n        return v1 * np.dot(v1, v2) / get_norm(v1) ** 2\n\n    def get_vect_mob_projection(self, vector_to_project, stable_vector):\n        return Vector(self.get_projection(vector_to_project.get_end(), stable_vector.get_end()), color=vector_to_project.get_color()).fade()\n\n    def geometric_calc(self):\n        grid = NumberPlane(background_line_style={'stroke_color': GREY})\n        va = Vector(direction=UR, color=GREEN).scale(2).shift(UR / 2)\n        vb = Vector(color=BLUE).scale(3, about_edge=LEFT)\n        origin_tex = TexMobject('O')\n        va_tex = TexMobject('\\\\vec{A}')\n        vb_tex = TexMobject('\\\\vec{B}')\n        va_tex.next_to(va.get_end(), UR)\n        vb_tex.next_to(vb.get_end(), UR)\n        origin_tex.shift(DL / 3)\n        va_perp_drop = Line(va.get_end(), va.get_end() + 2 * DOWN, color=BLUE)\n        va_proj = Vector(va_perp_drop.get_end(), color=va.get_color()).fade()\n        vb_proj = self.get_vect_mob_projection(vb, va)\n        vb_perp_drop = Line(vb.get_end(), vb_proj.get_end(), color=BLUE)\n        a_b = TexMobject('\\\\vec{A} \\\\cdot \\\\vec{B} =').to_edge(UL)\n        va_proj_brace = Brace(va_proj, DOWN)\n        va_proj_tex = va_proj_brace.get_text('Length of proj. of $\\\\vec{A}$')\n        vb_brace = Brace(vb, DOWN)\n        vb_brace_tex = vb_brace.get_text('Length of $\\\\vec{B}$')\n        va_tar = va_proj_tex.generate_target().next_to(a_b)\n        vb_brace_tex.generate_target().next_to(va_tar)\n        va_dot_vb_g = VGroup(va_proj_tex, vb_brace_tex)\n        va_dot_vb_exp = TextMobject('(Length of proj. of $\\\\vec{A}$) $\\\\cdot$ (Length of $\\\\vec{B}$)').next_to(a_b)\n        alternatively = TextMobject('Alternatively,', color=BLUE).scale(1.5).to_edge(UL)\n        vb_proj_brace = Brace(vb_proj, UL)\n        vb_proj_tex = TextMobject('Length of proj. of $\\\\vec{B}$').scale(0.8)\n        vb_proj_tex.rotate(va.get_angle()).move_to(vb_proj_brace).shift(UL / 2)\n        va_brace = Brace(va, UL)\n        va_brace_tex = TextMobject('Length of $\\\\vec{A}$').scale(0.8)\n        va_brace_tex.rotate(va.get_angle()).move_to(va_brace).shift(UL / 2)\n        vb_tar = vb_proj_tex.generate_target().rotate(-va.get_angle()).next_to(a_b)\n        va_brace_tex.generate_target().rotate(-va.get_angle()).next_to(vb_tar)\n        vb_dot_va_g = VGroup(a_b, vb_proj_tex, va_brace_tex)\n        vb_dot_va_exp = TextMobject('$\\\\vec{A} \\\\cdot \\\\vec{B}$ = (Length of proj. of $\\\\vec{B}$) $\\\\cdot$ (Length of $\\\\vec{A}$)').to_edge(UL)\n        self.play(ShowCreation(grid))\n        self.play(ShowCreation(origin_tex))\n        self.wait()\n        self.play(ShowCreation(va))\n        self.play(Write(va_tex))\n        self.wait()\n        self.play(ShowCreation(vb))\n        self.play(Write(vb_tex))\n        self.wait()\n        self.play(Write(a_b))\n        self.wait()\n        self.play(ShowCreation(va_perp_drop))\n        self.play(ReplacementTransform(va.copy(), va_proj))\n        self.wait()\n        self.play(ShowCreation(va_proj_brace))\n        self.play(ShowCreation(va_proj_tex))\n        self.wait()\n        self.play(FadeOut(va_proj_brace))\n        self.play(MoveToTarget(va_proj_tex))\n        self.wait()\n        self.play(ShowCreation(vb_brace))\n        self.play(ShowCreation(vb_brace_tex))\n        self.play(MoveToTarget(vb_brace_tex), FadeOut(vb_brace))\n        self.play(ReplacementTransform(va_dot_vb_g, va_dot_vb_exp))\n        self.wait(2)\n        self.play(FadeOut(a_b), ReplacementTransform(va_dot_vb_exp, alternatively))\n        self.play(FadeOut(VGroup(va_perp_drop, va_proj)))\n        self.play(Uncreate(alternatively))\n        self.play(Write(a_b))\n        self.play(ShowCreation(vb_perp_drop))\n        self.play(ReplacementTransform(vb.copy(), vb_proj))\n        self.wait()\n        self.play(ShowCreation(vb_proj_brace))\n        self.play(ShowCreation(vb_proj_tex))\n        self.wait()\n        self.play(FadeOut(vb_proj_brace))\n        self.play(MoveToTarget(vb_proj_tex))\n        self.wait()\n        self.play(ShowCreation(va_brace))\n        self.play(ShowCreation(va_brace_tex))\n        self.play(MoveToTarget(va_brace_tex))\n        self.play(ReplacementTransform(vb_dot_va_g, vb_dot_va_exp))\n        self.wait(2)\n        self.play(FadeOut(Group(*self.mobjects)))\n\n    def case_of_perpendicularity(self):\n        grid = NumberPlane(background_line_style={'stroke_color': GREY})\n        va = Vector(direction=UR, color=GREEN).scale(2).shift(UR / 2)\n        vb = Vector(color=BLUE).scale(3, about_edge=LEFT)\n        va_tex = TexMobject('\\\\vec{A}')\n        vb_tex = TexMobject('\\\\vec{B}')\n        va_tex.add_updater(lambda x: x.next_to(va.get_end(), UL))\n        vb_tex.add_updater(lambda x: x.next_to(vb.get_end(), UR))\n        va_extension = Line(va.get_start(), va.get_end()).scale(5)\n        vb_obtuse = vb.generate_target().rotate(-PI / 2, about_edge=LEFT)\n        vb_proj = self.get_vect_mob_projection(vb_obtuse, va)\n        vb_perp_drop = Line(vb_obtuse.get_end(), vb_proj.get_end(), color=BLUE)\n        a_b = TexMobject('\\\\vec{A} \\\\cdot \\\\vec{B} =').to_edge(UL)\n        vb_dot_va_exp = TextMobject('- ', ' (Length of proj. of $\\\\vec{B}$) $\\\\cdot$ (Length of $\\\\vec{A}$)').next_to(a_b)\n        vb_dot_va_exp[0].set_color(YELLOW).scale(2)\n        case_of_perp = TextMobject('Case of perpendicularity', color=BLUE).scale(1.5)\n        case_of_perp.to_edge(UL)\n        vb_right = vb.copy().rotate(-PI / 4, about_edge=LEFT)\n        vb_right_angle_indicator = Arc().set_points_as_corners([UR / 3, RIGHT / 1.5, DR / 3])\n        vb_dot_va_exp_right = TextMobject('0 $\\\\cdot$ (Length of $\\\\vec{A}$)').next_to(a_b)\n        vb_dot_va_exp_right2 = TextMobject('0').next_to(a_b)\n        self.add(grid, va, va_tex, vb, vb_tex, a_b)\n        self.play(ShowCreation(va_extension))\n        self.play(MoveToTarget(vb))\n        self.play(ShowCreation(vb_perp_drop))\n        self.play(ReplacementTransform(vb.copy(), vb_proj))\n        self.wait()\n        self.play(Write(vb_dot_va_exp))\n        self.wait()\n        self.play(Indicate(vb_dot_va_exp[0]))\n        self.wait()\n        self.play(FadeOut(VGroup(vb_perp_drop, vb_proj, vb_dot_va_exp, a_b)))\n        self.play(Write(case_of_perp))\n        self.wait()\n        self.play(Transform(vb, vb_right))\n        self.play(ShowCreation(vb_right_angle_indicator))\n        self.wait()\n        self.play(ReplacementTransform(case_of_perp, a_b))\n        self.play(Write(vb_dot_va_exp_right))\n        self.wait()\n        self.play(ReplacementTransform(vb_dot_va_exp_right, vb_dot_va_exp_right2))\n        self.wait(2)\n        self.play(FadeOut(Group(*self.mobjects)))\n\n    def angle_of_vectors(self):\n        title = TextMobject('Angle between Vectors', color=BLUE)\n        title.scale(1.5)\n        self.play(Write(title), run_time=3)\n        self.wait(1)\n        self.play(FadeOutAndShift(title, UP))\n        axes = Axes(x_min=-1, y_min=0)\n        va = Vector(direction=UP + RIGHT / 2, color=GREEN).scale(3).shift(UP + RIGHT / 2)\n        vb = Vector(direction=UR, color=BLUE).scale(2).shift(UR / 2)\n        x_tex = axes.get_x_axis_label('X')\n        origin_tex = TexMobject('O').shift(DOWN / 2)\n        va_tex = TexMobject('\\\\vec{A}')\n        vb_tex = TexMobject('\\\\vec{B}')\n        va_tex.add_updater(lambda x: x.next_to(va.get_end(), UL))\n        vb_tex.add_updater(lambda x: x.next_to(vb.get_end(), UR))\n        given = ('Here, angle between $\\\\vec{A}$ and $\\\\vec{B}$ = $\\\\angle{AOB}$', 'Angle made with X-axis;', 'by $\\\\vec{A}$ = $\\\\angle{XOA}$', 'by $\\\\vec{B}$ = $\\\\angle{XOB}$', 'From figure, we can say, $\\\\angle{AOB}$ = $\\\\angle{XOA} - \\\\angle{XOB}$')\n        given_g = VGroup(*[TextMobject(i) for i in given]).arrange(DOWN, center=False)\n        given_g.scale(0.8).to_edge(DOWN, buff=0.1)\n        tri_xoa = ('Let us now look at $\\\\triangle{AOD}$ to find $\\\\angle{XOA}$', 'From distance formula, OA, OD can be obtained.', 'Now, $cos \\\\theta = \\\\frac{b}{h} = \\\\frac{OD}{OA}$ or, cos$\\\\theta = \\\\frac{ \\\\sqrt{a_1^2} }{ \\\\sqrt{a_1^2 + b_1^2} } = \\\\frac{a_1}{| \\\\vec{A} |}$', '$\\\\therefore \\\\theta = cos^{-1}(\\\\frac{a_1}{| \\\\vec{A} |})$')\n        tri_xoa_g = VGroup(*[TextMobject(i) for i in tri_xoa])\n        tri_xoa_g.arrange(DOWN, center=False).scale(0.9).to_edge(DOWN, buff=0.1)\n        side_AD = Line(va.get_end(), va.get_end() + 3 * DOWN, color=GREEN)\n        label_D = TextMobject('D').next_to(side_AD.get_end(), DOWN)\n        coor_tex_OA = TexMobject('(a_1,b_1)').next_to(va_tex)\n        coor_tex_OD = TexMobject('(a_1,0)').next_to(label_D)\n        angle_OA_point = va.get_start() + (UP + RIGHT / 2) / 3\n        angle_indicator = ArcBetweenPoints(start=angle_OA_point, end=RIGHT / 3, angle=-TAU / 4, color=YELLOW)\n        theta_tex = TexMobject('\\\\theta').scale(0.8)\n        theta_tex.next_to(va.get_start(), buff=0.5).shift(UP / 4)\n        tri_xoa_animations = [(ShowCreation(side_AD), ShowCreation(label_D), FadeOut(vb), ShowCreation(coor_tex_OA), ShowCreation(coor_tex_OD)), (ShowCreation(angle_indicator), FadeIn(theta_tex)), (Animation(va),), (Animation(va),)]\n        tri_xob = ('Similarly, for $\\\\triangle{BOE}$, we can find $\\\\angle{XOB}$.', 'Here, $cos \\\\alpha = \\\\frac{b}{h} = \\\\frac{OE}{OB}$ or, cos$\\\\alpha = \\\\frac{ \\\\sqrt{a_2^2} }{ \\\\sqrt{a_2^2 + b_2^2} } = \\\\frac{a_2}{| \\\\vec{B} |}$', '$\\\\therefore \\\\alpha = cos^{-1}(\\\\frac{a_2}{| \\\\vec{B} |})$')\n        tri_xob_g = VGroup(*[TextMobject(i) for i in tri_xob])\n        tri_xob_g.arrange(DOWN, center=False).scale(0.9).to_edge(DOWN, buff=0.1)\n        side_BE = Line(vb.get_end(), vb.get_end() + 2 * DOWN, color=BLUE)\n        label_E = TextMobject('E').next_to(side_BE.get_end(), DOWN)\n        coor_tex_OB = TexMobject('(a_2,b_2)').next_to(vb_tex)\n        coor_tex_OE = TexMobject('(a_2,0)').next_to(label_E)\n        angle_OB_point = vb.get_start() + UR / 3\n        angle_XOB_indicator = ArcBetweenPoints(start=angle_OB_point, end=RIGHT / 3, angle=-TAU / 4, color=YELLOW)\n        alpha_tex = TexMobject('\\\\alpha').scale(0.8)\n        alpha_tex.next_to(va.get_start(), buff=0.5).shift(UP / 4)\n        tri_xob_animations = [(FadeOut(VGroup(side_AD, label_D, angle_indicator, theta_tex)), FadeOut(VGroup(va, coor_tex_OA, coor_tex_OD, va_tex)), FadeIn(vb), ShowCreation(side_BE), ShowCreation(label_E), ShowCreation(coor_tex_OB), ShowCreation(coor_tex_OE)), (ShowCreation(angle_XOB_indicator), FadeIn(alpha_tex)), (Animation(vb),), (Animation(vb),)]\n        conclusion = (\"Let's now look at the initial figure,\", 'As discussed earlier, $\\\\angle{AOB}$ = $\\\\angle{XOA}(\\\\theta) - \\\\angle{XOB}(\\\\alpha)$', 'or, $\\\\angle{AOB} = cos^{-1}(\\\\frac{a_1}{| \\\\vec{A} |}) - cos^{-1}(\\\\frac{a_2}{| \\\\vec{B} |})$', '$\\\\therefore$ The angle between vectors is obtained.')\n        conclusion_g = VGroup(*[TextMobject(i) for i in conclusion])\n        conclusion_g.arrange(DOWN, center=False).scale(0.9).to_edge(DOWN, buff=0.1)\n        angle_BOA_indicator = ArcBetweenPoints(start=angle_OA_point, end=angle_OB_point, angle=-TAU / 4, color=YELLOW)\n        conclusion_animations = [(FadeOut(VGroup(side_BE, label_E, angle_XOB_indicator, alpha_tex)), FadeOut(VGroup(coor_tex_OB, coor_tex_OE)), FadeIn(VGroup(va, va_tex))), (ShowCreation(angle_BOA_indicator),), (Animation(vb),), (Animation(vb),)]\n        self.play(ShowCreation(axes), FadeIn(x_tex), FadeIn(origin_tex))\n        self.play(ShowCreation(VGroup(va, va_tex)))\n        self.play(ShowCreation(VGroup(vb, vb_tex)))\n        for line in given_g:\n            self.play(Write(line), run_time=3)\n            self.wait()\n        self.wait(3)\n        self.play(FadeOut(given_g))\n        for text, anim in zip(tri_xoa_g, tri_xoa_animations):\n            self.play(Write(text), *anim, run_time=5)\n            self.wait()\n        self.wait(3)\n        self.play(FadeOut(tri_xoa_g))\n        for text, anim in zip(tri_xob_g, tri_xob_animations):\n            self.play(Write(text), *anim, run_time=5)\n            self.wait()\n        self.wait(3)\n        self.play(FadeOut(tri_xob_g))\n        for text, anim in zip(conclusion_g, conclusion_animations):\n            self.play(Write(text), *anim, run_time=5)\n            self.wait()\n        self.wait(3)\n        self.play(FadeOut(VGroup(*self.mobjects)))\n\n    def angle_of_vectors_algebric(self):\n        title = TextMobject('Angle of vector using cosine dot product relation')\n        title.set_color(BLUE).scale(1.2).to_edge(UL)\n        text = ('Let us look at another way of calculating the angle between', 'vectors. Let, $\\\\vec{A}$ and $\\\\vec{B}$ be any two vectors', 'and $\\\\theta$ be the angle between them. Then,')\n        text_g = VGroup(*[TextMobject(i) for i in text])\n        text_g.arrange(DOWN, center=False).next_to(title, DOWN, buff=0.8)\n        cosine_formula = TexMobject('cos \\\\theta = \\\\frac{ \\\\vec{A} \\\\cdot \\\\vec{B} }{| \\\\vec{A} | \\\\cdot | \\\\vec{B} |}\\\\ \\\\ \\\\ \\\\ or, \\\\theta = cos^{-1}(\\\\frac{ \\\\vec{A} \\\\cdot \\\\vec{B} }{| \\\\vec{A} | \\\\cdot | \\\\vec{B} |})')\n        cosine_formula.next_to(text_g, DOWN, buff=0.8).to_edge(LEFT).shift(RIGHT)\n        where_text = TextMobject('Where, |$\\\\vec{A}$|, |$\\\\vec{B}$| are magnitude of $\\\\vec{A}$ and $\\\\vec{B}$ resp.').next_to(cosine_formula, DOWN, buff=0.2).to_edge(DOWN)\n        self.play(Write(title))\n        for line in text_g:\n            self.play(Write(line), run_time=3)\n        self.play(Write(cosine_formula, run_time=3))\n        self.play(Write(where_text, run_time=3))\n        self.wait(3)\n\n    def dot_product_properties(self):\n        text = TextMobject('Properties of Scalar Product', color=BLUE)\n        text.scale(1.5).to_edge(UP)\n        self.play(Write(text))\n        commutative = TextMobject('Commutative Law').next_to(text, DOWN, buff=1.0)\n        associative = TextMobject('Associative Law').next_to(text, DOWN, buff=1.0)\n        distributive = TextMobject('Distributive Law').next_to(text, DOWN, buff=1.0)\n        texts = ('Let, $\\\\vec{A}$ and $\\\\vec{B}$ be two vectors then,', '$\\\\vec{A} \\\\cdot \\\\vec{B} = \\\\vec{B} \\\\cdot \\\\vec{A}$')\n        commutative_g = VGroup(*[TextMobject(i) for i in texts]).arrange(DOWN, center=False).next_to(commutative, DOWN, buff=1.0)\n        texts = ('Let, $\\\\vec{A}$ and $\\\\vec{B}$ be two vectors and x and y be any two scalars', 'then, $x\\\\vec{A} \\\\cdot y\\\\vec{B} = xy(\\\\vec{A} \\\\cdot \\\\vec{B}) = xy \\\\vec{A} \\\\cdot \\\\vec{B} = \\\\vec{A} \\\\cdot xy\\\\vec{B}$')\n        associative_g = VGroup(*[TextMobject(i) for i in texts]).arrange(DOWN, center=False).next_to(associative, DOWN, buff=1.0)\n        texts = ('Let, $\\\\vec{A}$, $\\\\vec{B}$ and $\\\\vec{C}$ be three vectors then,', '$\\\\vec{A} \\\\cdot (\\\\vec{B} + \\\\vec{C}) = \\\\vec{A} \\\\cdot \\\\vec{B} + \\\\vec{A} \\\\cdot \\\\vec{C}$')\n        distributive_g = VGroup(*[TextMobject(i) for i in texts]).arrange(DOWN, center=False).next_to(distributive, DOWN, buff=1.0)\n        self.play(Write(commutative))\n        self.play(Write(commutative_g), run_time=6)\n        self.wait()\n        self.play(FadeOut(VGroup(commutative, commutative_g)))\n        self.play(Write(associative))\n        self.play(Write(associative_g), run_time=6)\n        self.wait(3)\n        self.play(FadeOut(VGroup(associative, associative_g)))\n        self.play(Write(distributive))\n        self.play(Write(distributive_g), run_time=6)\n        self.wait()\n        self.play(FadeOut(VGroup(distributive, distributive_g)))\n        self.play(FadeOut(VGroup(*self.mobjects)))"}]}
